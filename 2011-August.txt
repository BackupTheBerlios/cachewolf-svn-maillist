From araber95 at mail.berlios.de  Mon Aug  1 08:08:06 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Mon,  1 Aug 2011 08:08:06 PM +0200
Subject: [Cachewolf-svn] r3048 - in branches/r1.2: . docs res_noewe
	res_noewe/attributes res_noewe/languages res_noewe/symbols
	res_noewe/templates res_noewe/webmapservices resources
	src/CacheWolf src/CacheWolf/exp src/CacheWolf/imp
	src/CacheWolf/model src/CacheWolf/navi
	src/CacheWolf/navi/touchControls src/CacheWolf/utils
	src/CacheWolf/view src/CacheWolf/view/ewe
	src/CacheWolf/view/pda tools/MakeWMSFile
	tools/MakeWMSFile/capxml2wms tools/MakeWMSFile/capxml2wms/My
	Project tools/MakeWMSFile/capxml2wms/bin/Debug
Message-ID: <20110801180808.147394833A6@sheep.berlios.de>

Author: araber95
Date: 2011-08-01 20:08:06 +0200 (Mon, 01 Aug 2011)
New Revision: 3048

Added:
   branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt
   branches/r1.2/res_noewe/attributes/sponsored-no.gif
   branches/r1.2/res_noewe/attributes/sponsored-non.gif
   branches/r1.2/res_noewe/attributes/sponsored-yes.gif
   branches/r1.2/res_noewe/icon_smile_dissapprove.gif
   branches/r1.2/res_noewe/icon_smile_sad.gif
   branches/r1.2/res_noewe/icon_smile_shy.gif
   branches/r1.2/res_noewe/templates/Parking.tpl
   branches/r1.2/res_noewe/webmapservices/at-5_p.wms
   branches/r1.2/res_noewe/webmapservices/at-5_t.wms
   branches/r1.2/res_noewe/webmapservices/at-6_p.wms
   branches/r1.2/res_noewe/webmapservices/at-8_t.wms
   branches/r1.2/res_noewe/webmapservices/cz_t.wms
   branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms
   branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms
   branches/r1.2/res_noewe/webmapservices/de-sl-t.wms
   branches/r1.2/res_noewe/webmapservices/de_t25.wms
   branches/r1.2/res_noewe/webmapservices/de_t_itc.wms
   branches/r1.2/res_noewe/webmapservices/dk_p.wms
   branches/r1.2/res_noewe/webmapservices/dk_t.wms
   branches/r1.2/res_noewe/webmapservices/dk_t25.wms
   branches/r1.2/res_noewe/webmapservices/dk_t50.wms
   branches/r1.2/res_noewe/webmapservices/fr_t.wms
   branches/r1.2/res_noewe/webmapservices/it-25_p.wms
   branches/r1.2/res_noewe/webmapservices/wfl-format.txt
   branches/r1.2/resources/archived.png
   branches/r1.2/resources/bonus.png
   branches/r1.2/resources/disabled.png
   branches/r1.2/resources/dnf.png
   branches/r1.2/resources/found.png
   branches/r1.2/resources/owned.png
   branches/r1.2/resources/solved.png
   branches/r1.2/src/CacheWolf/exp/OCLogExport.java
   branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java
   branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java
   branches/r1.2/src/CacheWolf/model/
   branches/r1.2/src/CacheWolf/model/DefaultListModel.java
   branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java
   branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java
   branches/r1.2/src/CacheWolf/view/
   branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java
   branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java
   branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java
   branches/r1.2/src/CacheWolf/view/ewe/
   branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
   branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java
   branches/r1.2/src/CacheWolf/view/pda/
   branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java
   branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java
   branches/r1.2/src/CacheWolf/view/pda/PDAList.java
   branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java
   branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java
   branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java
   branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java
   branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java
   branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java
Modified:
   branches/r1.2/CacheWolf.launch
   branches/r1.2/compile.bat
   branches/r1.2/currentversions.txt
   branches/r1.2/fwrtsnapshot.sh
   branches/r1.2/res_noewe/languages/DE.cfg
   branches/r1.2/res_noewe/languages/EN.cfg
   branches/r1.2/res_noewe/languages/FR.cfg
   branches/r1.2/res_noewe/languages/NL.cfg
   branches/r1.2/res_noewe/languages/PL.cfg
   branches/r1.2/res_noewe/languages/SV.cfg
   branches/r1.2/res_noewe/legende.html
   branches/r1.2/res_noewe/legende_de.html
   branches/r1.2/res_noewe/spider.def
   branches/r1.2/res_noewe/symbols/readme.htm
   branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm
   branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms
   branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms
   branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms
   branches/r1.2/res_noewe/webmapservices/at-3_p.wms
   branches/r1.2/res_noewe/webmapservices/at-3_t50.wms
   branches/r1.2/res_noewe/webmapservices/at_p.wms
   branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms
   branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms
   branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms
   branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-bw_p.wms
   branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-by_p.wms
   branches/r1.2/res_noewe/webmapservices/de-by_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-he_p.wms
   branches/r1.2/res_noewe/webmapservices/de-he_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms
   branches/r1.2/res_noewe/webmapservices/de-ni_p.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_p.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-rp_p.wms
   branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-sh_t.wms
   branches/r1.2/res_noewe/webmapservices/de-sn_p.wms
   branches/r1.2/res_noewe/webmapservices/de-sn_t.wms
   branches/r1.2/res_noewe/webmapservices/de-st_p.wms
   branches/r1.2/res_noewe/webmapservices/de-st_t10.wms
   branches/r1.2/res_noewe/webmapservices/de-st_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-th_t25.wms
   branches/r1.2/res_noewe/webmapservices/de_t2500.wms
   branches/r1.2/res_noewe/webmapservices/es-an_p.wms
   branches/r1.2/res_noewe/webmapservices/es-an_t.wms
   branches/r1.2/res_noewe/webmapservices/es-an_t1.wms
   branches/r1.2/res_noewe/webmapservices/es-ar_p.wms
   branches/r1.2/res_noewe/webmapservices/es-ar_t.wms
   branches/r1.2/res_noewe/webmapservices/es-cn_p.wms
   branches/r1.2/res_noewe/webmapservices/es-cn_t.wms
   branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms
   branches/r1.2/res_noewe/webmapservices/es_p.wms
   branches/r1.2/res_noewe/webmapservices/es_t25.wms
   branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms
   branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms
   branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms
   branches/r1.2/res_noewe/webmapservices/it-52_t10.wms
   branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms
   branches/r1.2/res_noewe/webmapservices/it-88_m.wms
   branches/r1.2/res_noewe/webmapservices/it-88_p.wms
   branches/r1.2/res_noewe/webmapservices/it-88_t10.wms
   branches/r1.2/res_noewe/webmapservices/it_p.wms
   branches/r1.2/res_noewe/webmapservices/it_t100.wms
   branches/r1.2/res_noewe/webmapservices/it_t25.wms
   branches/r1.2/res_noewe/webmapservices/jp-t.wms
   branches/r1.2/res_noewe/webmapservices/no-no_t.wms
   branches/r1.2/res_noewe/webmapservices/pl_p.wms
   branches/r1.2/res_noewe/webmapservices/pl_t50.wms
   branches/r1.2/res_noewe/webmapservices/pt_t500.wms
   branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms
   branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms
   branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms
   branches/r1.2/res_noewe/webmapservices/us_p.wms
   branches/r1.2/res_noewe/webmapservices/us_t.wms
   branches/r1.2/src/CacheWolf/Attribute.java
   branches/r1.2/src/CacheWolf/Attributes.java
   branches/r1.2/src/CacheWolf/AttributesSelector.java
   branches/r1.2/src/CacheWolf/CacheHolder.java
   branches/r1.2/src/CacheWolf/CacheHolderDetail.java
   branches/r1.2/src/CacheWolf/CacheImages.java
   branches/r1.2/src/CacheWolf/CacheList.java
   branches/r1.2/src/CacheWolf/CacheType.java
   branches/r1.2/src/CacheWolf/CalcPanel.java
   branches/r1.2/src/CacheWolf/Common.java
   branches/r1.2/src/CacheWolf/CoordsScreen.java
   branches/r1.2/src/CacheWolf/DBStats.java
   branches/r1.2/src/CacheWolf/DataMover.java
   branches/r1.2/src/CacheWolf/DateFormat.java
   branches/r1.2/src/CacheWolf/DateTimeChooser.java
   branches/r1.2/src/CacheWolf/DetailsPanel.java
   branches/r1.2/src/CacheWolf/Extractor.java
   branches/r1.2/src/CacheWolf/Filter.java
   branches/r1.2/src/CacheWolf/GeoCodeGui.java
   branches/r1.2/src/CacheWolf/GeocoderOsm.java
   branches/r1.2/src/CacheWolf/GuiImageBroker.java
   branches/r1.2/src/CacheWolf/HintLogPanel.java
   branches/r1.2/src/CacheWolf/HttpConnection.java
   branches/r1.2/src/CacheWolf/ImagePanel.java
   branches/r1.2/src/CacheWolf/InfoBox.java
   branches/r1.2/src/CacheWolf/LogList.java
   branches/r1.2/src/CacheWolf/MainForm.java
   branches/r1.2/src/CacheWolf/MainMenu.java
   branches/r1.2/src/CacheWolf/MainTab.java
   branches/r1.2/src/CacheWolf/MyComparer.java
   branches/r1.2/src/CacheWolf/OC.java
   branches/r1.2/src/CacheWolf/Parser.java
   branches/r1.2/src/CacheWolf/Preferences.java
   branches/r1.2/src/CacheWolf/PreferencesScreen.java
   branches/r1.2/src/CacheWolf/Profile.java
   branches/r1.2/src/CacheWolf/RadarPanel.java
   branches/r1.2/src/CacheWolf/SafeXML.java
   branches/r1.2/src/CacheWolf/Travelbug.java
   branches/r1.2/src/CacheWolf/TravelbugJourneyList.java
   branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java
   branches/r1.2/src/CacheWolf/TravelbugPickup.java
   branches/r1.2/src/CacheWolf/TravelbugScreen.java
   branches/r1.2/src/CacheWolf/UrlFetcher.java
   branches/r1.2/src/CacheWolf/exp/DistanceComparer.java
   branches/r1.2/src/CacheWolf/exp/ExploristExporter.java
   branches/r1.2/src/CacheWolf/exp/Exporter.java
   branches/r1.2/src/CacheWolf/exp/GpxExportNg.java
   branches/r1.2/src/CacheWolf/exp/KMLExporter.java
   branches/r1.2/src/CacheWolf/exp/LocExporter.java
   branches/r1.2/src/CacheWolf/exp/OziExporter.java
   branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java
   branches/r1.2/src/CacheWolf/exp/TPLExporter.java
   branches/r1.2/src/CacheWolf/exp/TomTomExporter.java
   branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java
   branches/r1.2/src/CacheWolf/imp/GPXImporter.java
   branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java
   branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java
   branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java
   branches/r1.2/src/CacheWolf/imp/SpiderGC.java
   branches/r1.2/src/CacheWolf/myTableControl.java
   branches/r1.2/src/CacheWolf/myTableModel.java
   branches/r1.2/src/CacheWolf/navi/Area.java
   branches/r1.2/src/CacheWolf/navi/AreaList.java
   branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java
   branches/r1.2/src/CacheWolf/navi/GotoPanel.java
   branches/r1.2/src/CacheWolf/navi/MapImage.java
   branches/r1.2/src/CacheWolf/navi/MapInfoObject.java
   branches/r1.2/src/CacheWolf/navi/MapLoader.java
   branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java
   branches/r1.2/src/CacheWolf/navi/MapSymbol.java
   branches/r1.2/src/CacheWolf/navi/MapsList.java
   branches/r1.2/src/CacheWolf/navi/MovingMap.java
   branches/r1.2/src/CacheWolf/navi/Navigate.java
   branches/r1.2/src/CacheWolf/navi/Track.java
   branches/r1.2/src/CacheWolf/navi/TrackOverlay.java
   branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
   branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
   branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java
   branches/r1.2/src/CacheWolf/utils/CWWrapper.java
   branches/r1.2/tools/MakeWMSFile/capxml2wms.sln
   branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/bin/Debug/capxml2wms.exe
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user
Log:
Release from NB 3047

Modified: branches/r1.2/CacheWolf.launch
===================================================================
--- branches/r1.2/CacheWolf.launch	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/CacheWolf.launch	2011-08-01 18:08:06 UTC (rev 3048)
@@ -7,9 +7,9 @@
 <listEntry value="4"/>
 </listAttribute>
 <listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
-<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry internalArchive=&quot;/CacheWolf/lib/ewe.jar&quot; path=&quot;3&quot; type=&quot;2&quot;/&gt;&#13;&#10;"/>
-<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.jdt.launching.classpathentry.defaultClasspath&quot;&gt;&#13;&#10;&lt;memento exportedEntriesOnly=&quot;false&quot; project=&quot;CacheWolf&quot;/&gt;&#13;&#10;&lt;/runtimeClasspathEntry&gt;&#13;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry path=&quot;3&quot; projectName=&quot;CacheWolf&quot; type=&quot;1&quot;/&gt;&#13;&#10;"/>
 <listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry internalArchive=&quot;/CacheWolf/lib/JavaEwe.zip&quot; path=&quot;3&quot; type=&quot;2&quot;/&gt;&#13;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry internalArchive=&quot;/CacheWolf/lib&quot; path=&quot;3&quot; type=&quot;2&quot;/&gt;&#13;&#10;"/>
 </listAttribute>
 <booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
 <stringAttribute key="org.eclipse.jdt.launching.MAIN_TYPE" value="Ewe"/>

Modified: branches/r1.2/compile.bat
===================================================================
--- branches/r1.2/compile.bat	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/compile.bat	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,4 +1,4 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
-javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/CacheWolf/navi/touchControls/*.java ./src/CacheWolf/exp/*.java ./src/CacheWolf/utils/*.java 
+javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/CacheWolf/navi/touchControls/*.java ./src/CacheWolf/exp/*.java ./src/CacheWolf/utils/*.java ./src/CacheWolf/model/*.java ./src/CacheWolf/view/*.java  ./src/CacheWolf/view/ewe/*.java  ./src/CacheWolf/view/pda/*.java
 javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./lib/ -deprecation ./lib/net/ax86/*.java ./lib/org/json/*.java
-pause
\ No newline at end of file
+pause

Modified: branches/r1.2/currentversions.txt
===================================================================
--- branches/r1.2/currentversions.txt	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/currentversions.txt	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,12 +1,12 @@
 # Release
 T0VersionMajor: 1
-T0VersionMinor: 0
-T0SvnRevision: 2716
+T0VersionMinor: 2
+T0SvnRevision: http://cachewolf.aldos.de/rc/mostrecentbuild.txt [\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)
 
 # ReleaseCandidate
 T1VersionMajor: 1
-T1VersionMinor: 2
-T1SvnRevision: http://cachewolf.aldos.de/rc/mostrecentbuild.txt [\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)
+T1VersionMinor: 3
+T1SvnRevision: http://cachewolf.aldos.de/mostrecentbuild.txt [\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)
 
 # InDevelopmentStable
 T2VersionMajor: 1

Added: branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt
===================================================================
--- branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt	                        (rev 0)
+++ branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,27 @@
+???Zeichen sind als "Quoted printable" kodiert mit einem % Zeichen
+Siehe auch http://de.wikipedia.org/wiki/Quoted-printable
+und http://www.cs.tut.fi/~jkorpela/chars.html
+
+Leertaste: +
+?? %e4
+?? %f6
+?? %fc
+?? %df
+?? %c4
+?? %d6
+?? %dc
+\n %0a
+?? %e9
+?? %e8
+?? %c9
+?? %c8
+?? %e0
+?? %c0
+?? %f9
+?? %d9
+?? %ee
+?? %ce
+?? %e2
+?? %c2
+?? %f4
+?? %d4

Modified: branches/r1.2/fwrtsnapshot.sh
===================================================================
--- branches/r1.2/fwrtsnapshot.sh	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/fwrtsnapshot.sh	2011-08-01 18:08:06 UTC (rev 3048)
@@ -18,8 +18,8 @@
 rm -rf bin
 mkdir -p bin/CacheWolf
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
-    -cp lib/CompileEwe.zip:lib -d bin -deprecation -nowarn \
-    src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java
+     -cp lib/CompileEwe.zip:lib -d bin -deprecation -nowarn \
+     src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java src/CacheWolf/view/*/*.java	 
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
     -cp ./lib/CompileEwe.zip:lib -d lib -deprecation -nowarn \
 	lib/net/ax86/*.java ./lib/org/json/*.java

Added: branches/r1.2/res_noewe/attributes/sponsored-no.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/attributes/sponsored-no.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/attributes/sponsored-non.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/attributes/sponsored-non.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/attributes/sponsored-yes.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/attributes/sponsored-yes.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/icon_smile_dissapprove.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/icon_smile_dissapprove.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/icon_smile_sad.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/icon_smile_sad.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/icon_smile_shy.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/icon_smile_shy.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: branches/r1.2/res_noewe/languages/DE.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/DE.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/DE.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Markierte ausfiltern
 161=Zeige Blacklist
 162=Kalibrierte herunterladen
+163=von OC Funde
+164=nur bei OC gelistet
+165=Lade nur, wenn mit Cache
 170=Datenverzeichnis w??hlen
 171=Profil existiert nicht:+
 172=Kann das Kartenverzeichnis nicht erstellen:
@@ -452,6 +455,8 @@
 1206=Rechner
 1207=??nderungen im Profil Speichern?
 1208=Bewertungen von gcvote
+1209=Link zu OC - Cache
+1210=Logs nach OC
 1300=Letzte Einstellung
 1301=Profil ausw??hlen:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=Tankstelle nahebei
 2679=keine Verpflegungsm??glichkeit
 2680=Verpflegungsm??glichkeit nahebei
-2681=RFID / Funk Ausr??stung
+2681=RFID, CHIRP / Funk Ausr??stung nicht n??tig
+2682=RFID, CHIRP / Funk Ausr??stung
+2683=keine Erste Hilfe 
+2684=Erste Hilfe nahebei
+2685=nicht gesponsert
+2686=gesponsert
 3000=Schlie??en
 4000=Geladene Caches:+
 4001=GPX-Dateien von Opencaching enthalten keine Informationen zu Bildern, sie werden nicht heruntergeladen. Am besten Caches von Opencaching holen per Men?? /Anwendung/Import/von Opencaching
@@ -988,6 +998,7 @@
 5520=Nur das eingestellte Maximum an Caches wurde geladen.\nWiederholen sie das Spidern sp??ter um weitere Caches zu laden.\nEs wurden keine vorhandenen Caches aktualisiert.
 5521=Seite+
 5522=Pr??fen auf ??ltere XML-Dateien ( ohne <CACHE... /> ) ?
+
 6000=Guid
 6001=Name
 6002=Track#
@@ -1029,7 +1040,19 @@
 6046=Nur nicht geloggte zeigen
 6047=Ausgew??hlte Zeilen l??schen
 6050=Spalten zeigen
-6051=Spalten verbergen
+6051=Spalten verbergen
+6052=Men??
+6053=Travelbug Men??
+6054=Alle anzeigen
+6055=Sortieren...
+6056=Expertenansicht
+6057=zur??ck
+6058=Aufgenommen:
+6059=Datum: 
+6060=Abgelegt:
+6061=Schlie??en
+6062=Track-Nr
+
 6100=Sonne
 6101=Mond
 6102=Gro??er Wagen

Modified: branches/r1.2/res_noewe/languages/EN.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/EN.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/EN.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filter out ticked
 161=Show Blacklist
 162=Download calibrated
+163 = OC finds
+164 = only available at OC
+165 = load only, if with cache
 170=Select data directory
 171=Profile does not exist:+
 172=Error: cannot create maps directory:
@@ -452,6 +455,8 @@
 1206=Calc
 1207=Your profile has unsaved changes. Do you want to save?
 1208=ratings from GCVote
+1209=link to OC - Cache
+1210=logs to OC
 1300=Last Setting
 1301=Select Profile:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=Fuel nearby
 2679=no Food nearby
 2680=Food nearby
-2681=wireless beacon
+2681 = RFID, CHIRP / radio equipment is not necessary
+2682 = RFID, CHIRP / radio equipment
+2683 = No emergency
+2684 = First Aid nearby
+2685=not sponsored
+2686=sponsored
 3000=Close
 4000=Loaded caches:+
 4001=GPX files from opencaching don't contain information of images, they cannot be loaded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching
@@ -1029,7 +1039,19 @@
 6046=Show only not logged
 6047=Delete selected Travelbugs
 6050=Show column
-6051=Don't show column
+6051=Don't show column
+6052=Menu
+6053=Travelbug Menu
+6054=Show all
+6055=Sort ...
+6056=Expertview
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-No
+
 6100=Sun
 6101=Moon
 6102=Greater Bear

Modified: branches/r1.2/res_noewe/languages/FR.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/FR.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/FR.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filtre les caches coch??es
 161=Montre liste noire
 162=T??l??charger calibr??e
+163 = OC trouve
+164 = uniquement disponible chez OC
+165 = seulement, si avec une cache
 170=Choisir dossier de base pour les profiles
 171=Profile n'existe pas:+
 172=Ne peut pas cr??er dossier pour des cartes:
@@ -452,6 +455,8 @@
 1206=Ordinateur
 1207=Sauvegarder les changements dans le profil?
 1208=ratings from GCVote
+1209 = lien vers OC - Cache
+1210 = journaux pour OC
 1300=Dernier param??tage
 1301=Choisir profil:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=carburant ?? proximit??
 2679=pas de nourriture ?? proximit??
 2680=la nourriture ?? proximit??
-2681=Chirp (Garmin)
+2681 = RFID, CHIRP / ??quipement radio n'est pas n??cessaire
+2682 = RFID, CHIRP ??quipement radio /
+2683 = Pas d'urgence
+2684 = First Aid ?? proximit??
+2685 = non parrain??
+2686 = parrain??
 3000=Fermer
 4000=Caches charg??es:
 4001=GPX fichiers ?? partir Opencaching ne contiennent pas d'informations d'images, ils ne peuvent pas ??tre charg??. Pour le meilleur vous obtenez des caches de Opencaching par le menu /Application/importation/Download from Opencaching
@@ -1030,6 +1040,18 @@
 6047=Effacer lignes selectionn??es
 6050=Montrer colonnes
 6051=Masquer colonnes
+6052=Menu
+6053=Travelbug Men??
+6054=Alle anzeigen
+6055=Sort ...
+6056=Expertenansicht
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-Nr
+
 6100=Soleil
 6101=Lune
 6102=Grande Ourse

Modified: branches/r1.2/res_noewe/languages/NL.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/NL.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/NL.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Gemarkeerd filteren
 161=Toon Blacklist
 162=Gekalibreerde kaarten downloaden.
+163 = OC vindt
+164 = alleen verkrijgbaar bij OC
+165 = alleen downloaden, als met cache
 170=Selecteer basis map voor cache data.
 171=Profiel bestaat niet:+
 172=Fout: kan kaarten map niet maken:\n.
@@ -452,6 +455,8 @@
 1206=Calculator
 1207=Jouw profiel is veranderd, wil je het profiel opslaan?
 1208=ratings from GCVote
+1209 = link naar OC - Cache
+1210 = logboeken naar OC
 1300=Laatste instellingen
 1301=Selecteer profiel
 1400=Zone
@@ -786,7 +791,12 @@
 2678=brandstof in de omgeving
 2679=geen eten in de buurt
 2680=Voedsel in de buurt
-2681=Chirp (Garmin)
+2681 = RFID, CHIRP / radio-apparatuur is niet nodig
+2682 = RFID, CHIRP / radio-apparatuur
+2683 = Geen spoed
+2684 = Eerste Hulp in de buurt
+2685 = niet gesponsord
+2686 = gesponsord
 3000=Sluiten
 4000=Geladen caches
 4001=GPX bestanden uit opencaching bevatten geen informatie van beelden, kunnen zij niet worden downloaden. Beste je caches van opencaching menu /Application/Import/Download from Opencaching
@@ -1029,7 +1039,19 @@
 6046=Toon alleen gelogd.
 6047=Verwijder geselecteerde Travelbugs.
 6050=Toon kolom
-6051=Toon kolom niet.
+6051=Toon kolom niet.
+6052=Menu
+6053=Travelbug Men??
+6054=Alle anzeigen
+6055=Sort ...
+6056=Expertenansicht
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-Nr
+
 6100=Zon
 6101=Maan
 6102=Grote Beer

Modified: branches/r1.2/res_noewe/languages/PL.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/PL.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/PL.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filtruj zaznaczone
 161=Pokaz czarna liste
 162=Sciagnij skalibrowane
+163 = OC stwierdzi
+164 = dost??pne tylko w OC
+165 = tylko w??wczas, gdy z pami??ci podr??cznej
 170=Wybierz folder z danymi
 171=Profil nie istnieje:+
 172=Blad: nie mozna utworzyc katalogu map:
@@ -452,6 +455,8 @@
 1206=Calc
 1207=Twoj Profil ma niezapisane zmiany. Chcesz zapisac?
 1208=ratings from GCVote
+1209 = link do OC - Cache
+1210 = dziennik??w OC
 1300=Ostatnie ustawienia
 1301=Wybierz Profil:
 1400=Strefa
@@ -786,7 +791,12 @@
 2678=paliwa w poblizu
 2679=brak zywnosci w poblizu
 2680=Zywnosci w poblizu
-2681=Chirp (Garmin)
+2681 = RFID, CHIRP / radio sprz??t nie jest konieczne
+2682 = RFID, CHIRP / urz??dze?? radiowych
+2683 = Nie awaryjne
+2684 = Pierwsza pomoc w pobli??u
+2685 = nie sponsorowane
+2686 = sponsorowane
 3000=Zamknij
 4000=Wczytaj skrzynki:+
 4001=Pliki GPX z opencaching nie zawieraja informacji o obrazach, nie moga byc one wczytane. Najlepiej pobierz skrzynki z opencaching przez menu /Aplikacja/Importuj/Sciagnij Z Opencaching
@@ -1029,7 +1039,19 @@
 6046=Pokaz tylko nie zalogowane
 6047=Usun wybrane Travelbugi
 6050=Pokaz kolumny
-6051=Nie pokazuj kolumny
+6051=Nie pokazuj kolumny
+6052=Menu
+6053=Travelbug Men??
+6054=Alle anzeigen
+6055=Sort ...
+6056=Expertenansicht
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-Nr
+
 6100=Slonce
 6101=Ksiezyc
 6102=Wielka Niedzwiedzica

Modified: branches/r1.2/res_noewe/languages/SV.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/SV.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/SV.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filter markeras ut
 161=Visa Blacklist
 162=Ladda kalibrerad
+163 = OC finner
+164 = endast tillg??nglig p?? OC
+165 = endast h??mta om med cache
 170=V??lj databas
 171=profil finns inte:+
 172=Fel: kan inte skapa kartor katalog:
@@ -452,6 +455,8 @@
 1206=Calc
 1207=Din profil har sparats. Vill du spara?
 1208=ratings from GCVote
+1209 = l??nk till OC - Cache
+1210 = loggar till OC
 1300=senaste inst??llningen
 1301=V??lj profil:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=Br??nsle i n??rheten
 2679=ingen mat i n??rheten
 2680=Food i n??rheten
-2681=Chirp (Garmin)
+2681 = RFID,CHIRP / tr??dl??s utrustning ??r inte n??dv??ndig
+2682 = RFID,CHIRP / tr??dl??s utrustning
+2683 = Ingen akut
+2684 = F??rsta hj??lpen i n??rheten
+2685 = inte sponsras
+2686 = sponsrade
 3000=St??ng
 4000=Loaded cachar:+
 4001=GPX filer fr??n opencaching inte inneh??ller n??gon information av bilder, kan de inte laoded. B??st du cachar fr??n opencaching genom menyn / Application / Import / Download fr??n Opencaching

Modified: branches/r1.2/res_noewe/legende.html
===================================================================
--- branches/r1.2/res_noewe/legende.html	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/legende.html	2011-08-01 18:08:06 UTC (rev 3048)
@@ -19,4 +19,5 @@
 
 <b><i>Other Symbols</i></b><br>
 <img src='bug.gif'>TravelBug<br>
-<img src='dnf.gif'>DNF-Indicator (as You can see more colours, the more DNF's are logged)
+<img src='dnf.gif'>DNF-Indicator (as You can see more colours, the more DNF's are logged)<br>
+<img src='guiError.png'>Data record incomplete<br>

Modified: branches/r1.2/res_noewe/legende_de.html
===================================================================
--- branches/r1.2/res_noewe/legende_de.html	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/legende_de.html	2011-08-01 18:08:06 UTC (rev 3048)
@@ -19,4 +19,5 @@
 
 <b><i>Sonstige Symbole</i></b><br>
 <img src='bug.gif'>TravelBug<br>
-<img src='dnf.gif'>DNF-Indikator (je mehr Farben zu sehen, desto mehr DNF's)
+<img src='dnf.gif'>DNF-Indikator (je mehr Farben zu sehen, desto mehr DNF's)<br>
+<img src='guiError.png'>Datensatz unvollst??ndig<br>

Modified: branches/r1.2/res_noewe/spider.def
===================================================================
--- branches/r1.2/res_noewe/spider.def	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/spider.def	2011-08-01 18:08:06 UTC (rev 3048)
@@ -53,7 +53,8 @@
 # * When entering spaces into a string ensure to escape them or write them as \\u0020
 # * Be sure that you have no hidden spaces at the end of a line or the patterns will not match!
 #------------------------------------------------------------
-loginPage          = http://www.geocaching.com/login/default.aspx
+#loginPage          = http://www.geocaching.com/login/default.aspx
+loginPage          = https://www.geocaching.com/login/default.aspx
 loginSuccess       = You\ are\ logged\ in\ as
 nextPage           = /login/default.aspx
 waypoint           = http://www.geocaching.com/seek/cache_details.aspx?wp=
@@ -67,9 +68,9 @@
 maxDistance        = &dist=
 nextListPage       = /seek/nearest.aspx
 # Regex to search for cachenames
-listBlockRex       = <table id="ctl00_ContentBody_dlResults"((?s).*?)</table>
-lineRex            = <tr\ bgcolor='#.{6}'\\s*class="Data\ BorderTop">((?s).*?)</tr>
-logDateRex         = <td valign="top">\\s*(.*?)<br\ />
+listBlockRex       = <table\ class="SearchResultsTable\ Table">((?s).*?)</table>
+lineRex            = Data\ BorderTop">((?s).*?)</tr>
+logDateRex         = </span>\\s+</td>\\s+<td\ valign="top"\ width="70">\\s+<span\ class="small">\\s+(.*?)<br\ />
 availableRex       = class="lnk\ \ Strike">
 archivedRex        = class="lnk\ OldWarning\ Strike\ Strike">
 PMRex              = small_profile.gif
@@ -78,8 +79,8 @@
 distRex            = (.*?)(?:km|mi|ft)
 DTSRex             = v=(.*?)"
 DTSCodeKey         = hbM9fjmrxy7z42LFD58BkKgPGdHscvCqNnw3ptO6lJ
-waypointRex        = \\(GC(.*?)\\)<br\ />
-TypeRex            = www.geocaching.com/images/wpttypes/sm/(.*?)\\.gif
+waypointRex        = \\|\\s+GC(.*?)\\s+
+TypeRex            = www.geocaching.com/images/wpttypes/(.*?)\\.gif
 found              = class="Success"
 own                = /WptTypes/name_tag.gif
 TBRex              = /wpttypes/([0-9]+).gif" alt="(.*?)"
@@ -109,13 +110,12 @@
 cacheArchived      = class="OldWarning"><li>This\ cache\ has\ been\ archived
 premiumCachepage   = class="Warning">listing\ visible\ to\ Premium
 latLonRex          = tBody_LatLon"\ style="font-weight:bold;">((?s).*?)</span>
-#latLonRex          = tBody_LatLon"><b>((?s).*?)</b></span>
 shortDescRex       = tBody_ShortDescription">((?s).*?)</span>
-longDescRex        = tBody_LongDescription">((?s).*?)<td\ valign="top"\ width="10%">\\s*&nbsp;\\s*</td
+longDescRex        = tBody_LongDescription">((?s).*?)<strong>\\s+Additional\ Hints</strong>
 cacheNameRex       = tBody_CacheName">((?s).*?)</span>
 cacheOwnerRex      = &wid(?:(?s).*?)>((?s).*?)<
 dateHiddenRex      = (?:Hidden|Event\ Date)\\s*:\\s*((?s).*?)<
-hintsRex           = <div id="div_hint" class="HalfLeft">\\s*((?s).*?)\\s*</div>
+hintsRex           = <div\ id="div_hint"\ class="span-8\ WrapFix">\\s*((?s).*?)\\s*</div>
 sizeRex            = alt="Size:\ ((?s).*?)"
 difficultyRex      = difficulty\ of\ (.*?),
 terrainRex         = terrain\ of\ (.*?)\\.\\ 
@@ -126,7 +126,7 @@
 #Section2a: Logs
 #--------------------------------------
 # blockRex extrahiert zun?chst aus der gesamten Seite den Logbereich
-blockRex           = <table class="LogsTable Table">((?s).*?)<td></td></tr></table>
+blockRex           = <table class="LogsTable">((?s).*?)</table>\\s+<p>
 # singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
 singleLogExStart   = ><strong><img src=
 singleLogExEnd     = <small><a\ href="
@@ -153,16 +153,17 @@
 #Section2b: Bugs
 #--------------------------------------
 # blockEx extrahiert zun?chst den Bugbereich aus der gesamten Seite
-blockExStart       = <span\ id="ctl00_ContentBody_uxTravelBugList_uxInventoryLabel">Inventory</span>
-blockExEnd         = <p\ class="NoSpacing">
+blockExStart       = ctl00_ContentBody_uxTravelBugList_uxInventoryLabel
+#blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsLinks
+blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsHistory
 # bugEx extrahiert die Namen der einzelnen Bugs aus dem Bugbereich
 bugExStart         = <a\ href="
 bugExEnd           = </a>
 bugLinkEnd         = "\ class="lnk">
 bugNameExStart     = <span>
 bugNameExEnd       = </span>
-bugDetailsStart    = "og:description"\ content="
-bugDetailsEnd      = "\ property="og:desc
+bugDetailsStart    = <meta\ name="og:description"\ content="
+bugDetailsEnd      = "\ property="og:description"
 getBugByName       = http://www.geocaching.com/track/search.aspx?k=
 getBugByGuid       = http://www.geocaching.com/track/details.aspx?guid=
 getBugById         = http://www.geocaching.com/track/details.aspx?id=
@@ -208,7 +209,7 @@
 #--------------------------------------
 #Section2e: Attributes
 #--------------------------------------
-attBlockExStart = <div\ class="CacheDetailNavigationWidget\ Spacing">
+attBlockExStart = <div\ class="CacheDetailNavigationWidget
 attBlockExEnd  = What\ are\ Attributes?</a></small></p>
 attExStart = /images/attributes/
 attExEnd = "\ alt="

Modified: branches/r1.2/res_noewe/symbols/readme.htm
===================================================================
--- branches/r1.2/res_noewe/symbols/readme.htm	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/symbols/readme.htm	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,18 +13,18 @@
 <!--[if gte mso 9]><xml>
  <o:DocumentProperties>
   <o:Author>.</o:Author>
-  <o:LastAuthor>.</o:LastAuthor>
-  <o:Revision>5</o:Revision>
+  <o:LastAuthor>Franz</o:LastAuthor>
+  <o:Revision>8</o:Revision>
   <o:Created>2009-10-23T21:05:00Z</o:Created>
-  <o:LastSaved>2010-06-08T16:27:00Z</o:LastSaved>
+  <o:LastSaved>2011-05-20T16:42:00Z</o:LastSaved>
   <o:Pages>1</o:Pages>
-  <o:Words>238</o:Words>
-  <o:Characters>1506</o:Characters>
+  <o:Words>390</o:Words>
+  <o:Characters>2458</o:Characters>
   <o:Company>CF Computer</o:Company>
-  <o:Lines>12</o:Lines>
-  <o:Paragraphs>3</o:Paragraphs>
-  <o:CharactersWithSpaces>1741</o:CharactersWithSpaces>
-  <o:Version>10.6858</o:Version>
+  <o:Lines>20</o:Lines>
+  <o:Paragraphs>5</o:Paragraphs>
+  <o:CharactersWithSpaces>2843</o:CharactersWithSpaces>
+  <o:Version>10.6870</o:Version>
  </o:DocumentProperties>
 </xml><![endif]--><!--[if gte mso 9]><xml>
  <w:WordDocument>
@@ -84,7 +84,7 @@
 	font-family:"Times New Roman";}
 </style>
 <![endif]--><!--[if gte mso 9]><xml>
- <o:shapedefaults v:ext="edit" spidmax="5122"/>
+ <o:shapedefaults v:ext="edit" spidmax="7170"/>
 </xml><![endif]--><!--[if gte mso 9]><xml>
  <o:shapelayout v:ext="edit">
   <o:idmap v:ext="edit" data="1"/>
@@ -97,7 +97,7 @@
 
 <p class=MsoNormal>In diesem Verzeichnis vorhandene .<span class=SpellE>png-Dateien</span>
 werden als alternative Symbole in den Cachewolf geladen, falls in den
-Einstellungen/Tab mehr eingeschaltet.</p>
+Einstellungen/Tab Mehr/nutze eigene Symbole eingeschaltet.</p>
 
 <p class=MsoNormal>Dabei sollte es sich um <span class=SpellE>PNGs</span> der
 Gr??e 16x16 handeln oder kleiner.</p>
@@ -106,9 +106,38 @@
 Symbole angezeigt, falls sie existieren und der Dateiname auf <span
 class=SpellE>size</span> endet.</p>
 
-<p class=MsoNormal>Es m?ssen nur die Dateien erstellt werden, die ersetzt
-werden sollen.</p>
+<p class=MsoNormal>F?r folgende <span class=SpellE>Stati</span> kann ein extra
+Symbol auf der Kartenansicht ?berlagert werden: </p>
 
+<p class=MsoNormal><span class=SpellE><span class=GramE>found.png</span></span><span
+class=GramE> :</span> habe den Cache schon gefunden.</p>
+
+<p class=MsoNormal><span class=SpellE>dnf.png</span>: habe den Cache nicht
+gefunden:<o:p></o:p></p>
+
+<p class=MsoNormal><span class=SpellE><span class=GramE>archived.png</span></span><span
+class=GramE> :</span> der Cache ist archiviert.</p>
+
+<p class=MsoNormal><span class=SpellE>disabled.png</span>: Der Cache ist
+vor?bergehend nicht <span class=SpellE>suchbar</span>.</p>
+
+<p class=MsoNormal><span class=SpellE>owned.png</span>: Den Cache habe ich
+selber platziert.</p>
+
+<p class=MsoNormal><span class=SpellE>solved.png</span>: Du hast dem Cache den
+Status ?gel?st? gegeben, d.h. an den Koordinaten ist der Cache zu finden.</p>
+
+<p class=MsoNormal><span class=SpellE>bonus.png</span>: Das ist ein Bonuscache.
+Die Koordinaten ergeben sich durch Suchen eines anderen Cache.</p>
+
+<p class=MsoNormal>Das ?berlagernde Symbol <span class=SpellE>mu?</span>
+kleiner oder gleich gro? sein wie das Cachesymbol.<o:p></o:p></p>
+
+<p class=MsoNormal><o:p>&nbsp;</o:p></p>
+
+<p class=MsoNormal>Es m?ssen nur die Dateien erstellt werden, die ersetzt werden
+sollen.</p>
+
 <p class=MsoNormal>Ist keine entsprechende Datei vorhanden, wird das
 Cachewolf-interne Symbol beibehalten.</p>
 
@@ -118,19 +147,35 @@
 <p class=MsoNormal><o:p>&nbsp;</o:p></p>
 
 <p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>.<span
-class=SpellE>png</span>-files in this directory will be loaded as customized
-symbols into <span class=SpellE>Cachewolf</span> if checked in preferences tab
-more.<o:p></o:p></span></p>
+class=SpellE>png</span>-files in this directory will be loaded as customized symbols
+into <span class=SpellE>Cachewolf</span> if checked in preferences tab more.<o:p></o:p></span></p>
 
 <p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>They're
 supposed to be 16x16 <span class=SpellE>PNGs</span> or less.<o:p></o:p></span></p>
 
-<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>On the map larger
-symbols are shown, if they exist and the filename ends on size.<o:p></o:p></span></p>
+<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>On the map
+larger symbols are shown, if they exist and the filename ends on size.<o:p></o:p></span></p>
 
-<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>Incorrectly
-named files will be ignored.<o:p></o:p></span></p>
+<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>For&nbsp;the
+following&nbsp;states, an&nbsp;extra&nbsp;symbol is&nbsp;superimposed&nbsp;on&nbsp;the&nbsp;map<span
+class=GramE>:</span><br>
+<span class=SpellE>found.png</span>:&nbsp;the&nbsp;cache&nbsp;had&nbsp;been&nbsp;found.<br>
+<span class=SpellE>dnf.png</span>:&nbsp;the&nbsp;cache&nbsp;was&nbsp;not found<span
+class=GramE>:</span><br>
+<span class=SpellE>archived.png</span>:&nbsp;the cache&nbsp;is&nbsp;archived.<br>
+<span class=SpellE>disabled.png</span>: The&nbsp;cache&nbsp;is&nbsp;temporarily
+not searchable.<br>
+<span class=SpellE>owned.png</span>:&nbsp;the&nbsp;cache&nbsp;I&nbsp;have myself
+placed.<br>
+<span class=SpellE>solved.png</span>: You&nbsp;have&nbsp;the&nbsp;cache&nbsp;status
+&quot;solved&quot;&nbsp;if&nbsp;i.e.&nbsp;at coordinates cache can be&nbsp;found.<br>
+<span class=SpellE>bonus.png</span>: This is&nbsp;a&nbsp;bonus.&nbsp;The Coordinates&nbsp;result&nbsp;from&nbsp;searching
+another&nbsp;cache.<br>
+The&nbsp;superimposed&nbsp;image&nbsp;must be smaller&nbsp;or be&nbsp;the same
+size&nbsp;as&nbsp;the&nbsp;icon&nbsp;cache.<o:p></o:p></span></p>
 
+<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>
+
 <p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>You only
 have to create images for those symbols you want customized.<o:p></o:p></span></p>
 
@@ -154,12 +199,11 @@
 <p class=MsoNormal><span class=GramE><span lang=EN-GB style='mso-ansi-language:
 EN-GB'>old</span></span><span lang=EN-GB style='mso-ansi-language:EN-GB'> Nr<span
 style='mso-tab-count:1'>? </span><span class=SpellE>newNr</span><span
-style='mso-tab-count:1'> </span><span style='mso-tab-count:1'>??????????? </span>meaning<o:p></o:p></span></p>
+style='mso-tab-count:2'>???????????? </span>meaning<o:p></o:p></span></p>
 
 <p class=MsoNormal><span class=GramE><span lang=EN-GB style='mso-ansi-language:
 EN-GB'>0.png</span></span><span lang=EN-GB style='mso-ansi-language:EN-GB'><span
-style='mso-tab-count:1'>?? </span>0.png<span style='mso-tab-count:1'>?? </span><span
-style='mso-tab-count:1'>??????????? </span>Custom<o:p></o:p></span></p>
+style='mso-tab-count:1'>?? </span>0.png<span style='mso-tab-count:2'>?????????????? </span>Custom<o:p></o:p></span></p>
 
 <p class=MsoNormal><span class=GramE><span lang=EN-GB style='mso-ansi-language:
 EN-GB'>1.png</span></span><span lang=EN-GB style='mso-ansi-language:EN-GB'><span

Added: branches/r1.2/res_noewe/templates/Parking.tpl
===================================================================
--- branches/r1.2/res_noewe/templates/Parking.tpl	                        (rev 0)
+++ branches/r1.2/res_noewe/templates/Parking.tpl	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,14 @@
+???<tmpl_par name="decsep" value=".">
+<tmpl_par name="Out" value="*.loc">
+<tmpl_par name="charset" value="UTF8">
+<tmpl_par name="newline" value="CRLF">
+<tmpl_par name="takeOnlyWp" value="parking">
+<?xml version="1.0"?><loc version="1.0" src="EasyGPS"><br/>
+<tmpl_loop cache_index>
+<waypoint><br/>
+   <name id="<tmpl_var WAYPOINT>"><![CDATA[<tmpl_var NAME>]]></name><br/>
+   <coord lat="<tmpl_var LAT>" lon="<tmpl_var LON>"/><br/>
+   <type><tmpl_var GMTYPE></type><br/>
+</waypoint><br/>
+</tmpl_loop>
+</loc><br/>

Modified: branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm
===================================================================
--- branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm	2011-08-01 18:08:06 UTC (rev 3048)
@@ -43,7 +43,7 @@
 	mso-font-charset:0;
 	mso-generic-font-family:swiss;
 	mso-font-pitch:variable;
-	mso-font-signature:-520078593 -1073717157 41 0 66047 0;}
+	mso-font-signature:-520077569 -1073717157 41 0 66047 0;}
  /* Style Definitions */
  p.MsoNormal, li.MsoNormal, div.MsoNormal
 	{mso-style-parent:"";
@@ -77,9 +77,6 @@
 span.SpellE
 	{mso-style-name:"";
 	mso-spl-e:yes;}
-span.GramE
-	{mso-style-name:"";
-	mso-gram-e:yes;}
 @page Section1
 	{size:595.3pt 841.9pt;
 	margin:70.85pt 70.85pt 2.0cm 70.85pt;
@@ -165,80 +162,71 @@
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>&lt;#--
-<span class=SpellE>TomTom</span> ASC or POI --&gt;<span style='mso-tab-count:
-5'>??????????????????????????????????????????????????? </span>Anything between
-&quot;&lt;#--&quot; and &quot;--&gt;&quot; is handled as a comment</span><span
+TomTom ASC or POI --&gt;<span style='mso-tab-count:5'>??????????????????????????????????????????????????? </span>Anything
+between &quot;&lt;#--&quot; and &quot;--&gt;&quot; is handled as a comment</span><span
 lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>Configuration
 section </span></u><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span
-class=SpellE>NameOfParameter</span>&quot; value=&quot;<span class=SpellE>ValueOfParameter</span>&quot;&gt;</span><span
-lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
+mso-ansi-language:EN-GB'>&lt;tmpl_par name=&quot;NameOfParameter&quot;
+value=&quot;ValueOfParameter&quot;&gt;</span><span lang=EN-GB style='mso-ansi-language:
+EN-GB'><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>&lt;<span
-class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>charset</span>&quot;
-value=&quot;ASCII&quot;&gt;<span style='mso-tab-count:3'>??????????????????????????????? </span><span
-class=SpellE>Charsets</span>: &nbsp;values ASCII or UTF8 or UNICODE<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>badchars</span>&quot;
-value=&quot;,&quot;&gt;<span style='mso-tab-count:4'>???????????????????????????????????? </span><span
-class=SpellE><span class=GramE>BadChars</span></span><span class=GramE> :</span>
-These chars are removed from the <span class=SpellE>cachename</span>, hints and
-notes. <br>
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>&lt;tmpl_par
+name=&quot;charset&quot; value=&quot;ASCII&quot;&gt;<span style='mso-tab-count:
+3'>??????????????????????????????? </span>Charsets: &nbsp;values ASCII or UTF8
+or UNICODE<br>
+&lt;tmpl_par name=&quot;badchars&quot; value=&quot;,&quot;&gt;<span
+style='mso-tab-count:4'>???????????????????????????????????? </span>BadChars :
+These chars are removed from the cachename, hints and notes. <br>
 <span style='mso-spacerun:yes'>?</span><span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????????? </span>for
-example the value=&quot;,&quot; if ',' is used as a separator. <span
-class=GramE>Regular expressions possible.</span><br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>newline</span>&quot;
-value=&quot;CRLF&quot;&gt;<span style='mso-tab-count:3'>??????????????????????????????? </span><span
-class=SpellE><span class=GramE>Newline</span></span><span class=GramE> :</span>
-values are CR, LF or CRLF . These defines, what should be used for replacing<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>decsep</span>&quot;
-value=&quot;,&quot;&gt;<span style='mso-tab-count:4'>??????????????????????????????????????? </span>Decimal
+example the value=&quot;,&quot; if ',' is used as a separator. Regular
+expressions possible.<br>
+&lt;tmpl_par name=&quot;newline&quot; value=&quot;CRLF&quot;&gt;<span
+style='mso-tab-count:3'>??????????????????????????????? </span>Newline : values
+are CR, LF or CRLF . These defines, what should be used for replacing<br>
+&lt;tmpl_par name=&quot;decsep&quot; value=&quot;,&quot;&gt;<span
+style='mso-tab-count:4'>??????????????????????????????????????? </span>Decimal
 separator : Defines, which decimal separator is used , values &quot;.&quot; or ','<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>ShortNameLength</span>&quot;
-value=&quot;30&quot;&gt;<span style='mso-tab-count:2'>????????????????????? </span>Number
-of characters for Variable SHORTNAME <br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>WaypointLength</span>&quot;
-value=&quot;3&quot;&gt;<span style='mso-tab-count:3'>????????????????????????? </span>Number
-of characters for Variable SHORTWAYPOINT<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;Out&quot; value=&quot;.<span
-class=SpellE>gpx</span>&quot;&gt;<span style='mso-tab-count:4'>??????????????????????????????????????? </span>Output
+&lt;tmpl_par name=&quot;ShortNameLength&quot; value=&quot;30&quot;&gt;<span
+style='mso-tab-count:2'>????????????????????? </span>Number of characters for
+Variable SHORTNAME <br>
+&lt;tmpl_par name=&quot;WaypointLength&quot; value=&quot;3&quot;&gt;<span
+style='mso-tab-count:3'>????????????????????????? </span>Number of characters
+for Variable SHORTWAYPOINT<br>
+&lt;tmpl_par name=&quot;Out&quot; value=&quot;.gpx&quot;&gt;<span
+style='mso-tab-count:4'>??????????????????????????????????????? </span>Output
 Filename or Extension<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>NrLogs</span>&quot;
-value=&quot;-1&quot;&gt;<span style='mso-tab-count:4'>????????????????????????????????????? </span><span
-class=SpellE>Anzahl</span> logs (-1 = alle)<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>singleFile</span>&quot;
-value=&quot;yes&quot;&gt;<span style='mso-tab-count:3'>??????????????????????????????? </span>one
-<span class=SpellE>outputfile</span> value=?yes? or one file per cache
-value=?no? (use a dummy / not existing name for Out par)<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>formatModifier</span>&quot;
-value=&quot;0&quot;&gt;<span style='mso-tab-count:3'>???????????????????????????? </span>0
-is xml as <span class=SpellE>gpx</span> generation before, 1 is html for local
-use 2 is html for export use<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>takeOnlyWp</span>&quot;
-value=&quot;all&quot;&gt;<span style='mso-tab-count:3'>????????????????????????????? </span>process
-only this <span class=SpellE>Cachetypegroups</span> value is either ?main? or ?<span
-class=SpellE>addi</span>? else both (here all = default ) is assumed<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>CopyCacheImages</span>&quot;
-value=&quot;yes&quot;&gt;<span style='mso-tab-count:2'>?????????????????? </span><span
-class=SpellE>CacheImages</span> are copied to the output directory (copy <span
-class=SpellE>attribs</span> and icons manually, they are fix)<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>inputEingabe</span>&quot;
-value=&quot;default&quot;&gt;<span style='mso-tab-count:2'>?????????????????????? </span>calls
-input with a ?default? value and makes a <span class=SpellE>tmpl_var</span>
-with the name <span class=SpellE>Eingabe</span> (<span class=SpellE>Eingabe</span>
-is placeholder) (!<span class=SpellE>dont</span> use umlauts in defaults)<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>constKonstante</span>&quot;
-value=&quot;value&quot;&gt;<span style='mso-tab-count:2'>???????????????????? </span>sets
-a <span class=SpellE>tmpl_var</span> with the name <span class=SpellE>Konstante</span>
-(<span class=SpellE>Konstante</span> is placeholder) (!<span class=SpellE>dont</span>
-use umlauts in value)<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>sortedBy</span>&quot;
-value=&quot;-1&quot;&gt;<span style='mso-tab-count:3'>??????????????????????????????????? </span>sets
-a <span class=SpellE>tmpl_var</span> with the name <span class=SpellE>sortedBy</span>:
-values are 1..19. (4=Waypoint,5=Name,9=Status,10=Distance? see myComparer.java)<o:p></o:p></span></p>
+&lt;tmpl_par name=&quot;NrLogs&quot; value=&quot;-1&quot;&gt;<span
+style='mso-tab-count:4'>????????????????????????????????????? </span>Anzahl
+logs (-1 = alle)<br>
+&lt;tmpl_par name=&quot;singleFile&quot; value=&quot;yes&quot;&gt;<span
+style='mso-tab-count:3'>??????????????????????????????? </span>one outputfile
+value=?yes? or one file per cache value=?no? (use a dummy / not existing name
+for Out par)<br>
+&lt;tmpl_par name=&quot;formatModifier&quot; value=&quot;0&quot;&gt;<span
+style='mso-tab-count:3'>???????????????????????????? </span>0 is xml as gpx
+generation before, 1 is html for local use 2 is html for export use<br>
+&lt;tmpl_par name=&quot;takeOnlyWp&quot; value=&quot;all&quot;&gt;<span
+style='mso-tab-count:3'>????????????????????????????? </span>process only this
+Cachetypegroups value is either ?main? or ?addi? or ?parking? else all (here
+all = default ) is assumed<br>
+&lt;tmpl_par name=&quot;CopyCacheImages&quot; value=&quot;yes&quot;&gt;<span
+style='mso-tab-count:2'>?????????????????? </span>CacheImages are copied to the
+output directory (copy attribs and icons manually, they are fix)<br>
+&lt;tmpl_par name=&quot;inputEingabe&quot; value=&quot;default&quot;&gt;<span
+style='mso-tab-count:2'>?????????????????????? </span>calls input with a
+?default? value and makes a tmpl_var with the name Eingabe (Eingabe is
+placeholder) (!dont use umlauts in defaults)<br>
+&lt;tmpl_par name=&quot;constKonstante&quot; value=&quot;value&quot;&gt;<span
+style='mso-tab-count:2'>???????????????????? </span>sets a tmpl_var with the
+name Konstante (Konstante is placeholder) (!dont use umlauts in value)<br>
+&lt;tmpl_par name=&quot;sortedBy&quot; value=&quot;-1&quot;&gt;<span
+style='mso-tab-count:3'>??????????????????????????????????? </span>sets a
+tmpl_var with the name sortedBy: values are 1..19.
+(4=Waypoint,5=Name,9=Status,10=Distance? see myComparer.java)<o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>Output
@@ -247,23 +235,20 @@
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>Anything
 (except comments and variables) is written to the output file.<br>
-The <span class=SpellE>cachedata</span> <span class=SpellE><span class=GramE>ist</span></span>
-placed between &lt;<span class=SpellE>tmpl_loop</span> <span class=SpellE>cache_index</span>&gt;
-and &lt;/<span class=SpellE>tmpl_loop</span>&gt;. <br>
-Variables defined like this: &lt;<span class=SpellE>tmpl_var</span>
-name=LON&gt;. <br>
-At the end of the line &lt;<span class=SpellE>br</span> /&gt; has to be placed,
-this is replaced by CR.<o:p></o:p></span></p>
+The cachedata ist placed between &lt;tmpl_loop cache_index&gt; and
+&lt;/tmpl_loop&gt;. <br>
+Variables defined like this: &lt;tmpl_var name=LON&gt;. <br>
+At the end of the line &lt;br /&gt; has to be placed, this is replaced by CR.<o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>Variables
-&lt;<span class=SpellE>tmpl_var</span> <span class=SpellE>NameOfVariable</span>&gt;</span></u><u><span
-lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
+&lt;tmpl_var NameOfVariable&gt;</span></u><u><span lang=EN-GB style='mso-ansi-language:
+EN-GB'><o:p></o:p></span></u></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>PROGDIR<span
 style='mso-tab-count:8'>?????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>FileBase.getProgramDirectory</span>()<br>
+FileBase.getProgramDirectory()<br>
 PROFILDIR<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????? </span>:<span
 style='mso-tab-count:6'>????????????????????????????????????????????????????????????????????? </span><span
 style='mso-tab-count:2'>??????????????????????? </span>: <br>
@@ -271,13 +256,12 @@
 TYPE<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 &lt;type&gt; Type of cache, e.g. Regular, Multi<br>
 TYPENO<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????????? </span>:
-&lt;type&gt; as number string (see <span class=SpellE>CacheType.java</span> <span
-class=SpellE>e.g</span> : 0=Custom , 2=<span class=SpellE>Tradi</span>
+&lt;type&gt; as number string (see CacheType.java e.g : 0=Custom , 2=Tradi
 ,50=Parking 104=Earth)<br>
 SYM<span style='mso-tab-count:9'>?????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 &lt;sym&gt;<br>
 GSTYPE<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????????? </span>:
-&lt;<span class=SpellE>groundspeak:type</span>&gt;<br>
+&lt;groundspeak:type&gt;<br>
 SHORTTYPE<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????? </span>:
 First Letter of &lt;type&gt; ???<br>
 SIZE<span style='mso-tab-count:9'>?????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
@@ -286,57 +270,49 @@
 First letter of size<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'>MAINWP<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????????? </span>:
-?? if is <span class=SpellE>Mainwaypoint</span>, <span class=SpellE>Mainwaypoint</span>
-if is <span class=SpellE>Addi</span> Waypoint<br>
+?? if is Mainwaypoint, Mainwaypoint if is Addi Waypoint<br>
 MAINWPNAME<span style='mso-tab-count:8'>?????????????????????????????????????????????????????????????????????????????????? </span>:
-?? if is <span class=SpellE>Mainwaypoint</span>, <span class=SpellE>Mainwaypoint</span>
-name if is <span class=SpellE>Addi</span> Waypoint<br>
+?? if is Mainwaypoint, Mainwaypoint name if is Addi Waypoint<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'>WAYPOINT<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????? </span>:
 &lt;name&gt; GCXXXX, OCXXXX<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'>SHORTWAYPOINT<span style='mso-tab-count:7'>????????????????????????????????????????????????????????????????????????????? </span>:
-</span><span class=SpellE><span lang=EN-GB style='font-size:10.0pt;font-family:
-Arial;mso-ansi-language:EN-GB'>ShortNameLength</span></span><span lang=EN-GB
-style='font-size:10.0pt;font-family:Helvetica;mso-ansi-language:EN-GB'> <span
-class=SpellE>Zeichen</span> des Waypoints (<span class=SpellE>f?r</span> <span
-class=SpellE>Benutzer</span> alter <span class=SpellE>Ger?te</span> <span
-class=SpellE>mit</span> <span class=SpellE>nur</span> 6 <span class=SpellE>Waypointzeichen</span>,
-<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
+EN-GB'>ShortNameLength</span><span lang=EN-GB style='font-size:10.0pt;
+font-family:Helvetica;mso-ansi-language:EN-GB'> Zeichen des Waypoints (f?r
+Benutzer alter Ger?te mit nur 6 Waypointzeichen, <br>
+</span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'>OWNER<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>Cacheowner</span><br>
+Cacheowner<br>
 DIFFICULTY<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????? </span>:<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'>SHORTDIFFICULTY<span style='mso-tab-count:7'>???????????????????????????????????????????????????????????????????????????? </span>:
-Difficulty mal 10 also 15 <span class=SpellE>statt</span> 1.5<br>
+Difficulty mal 10 also 15 statt 1.5<br>
 SHDIFFICULTY<span style='mso-tab-count:8'>?????????????????????????????????????????????????????????????????????????????????? </span>:
-Difficulty <span class=SpellE>abgerundet</span> also 1 <span class=SpellE>statt</span>
-1.5<br>
+Difficulty abgerundet also 1 statt 1.5<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'>TERRAIN<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????????? </span>:<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'>SHORTTERRAIN<span style='mso-tab-count:7'>???????????????????????????????????????????????????????????????????????????????? </span>:
 Terrain mal 10<br>
 SHTERRAIN<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????? </span>:
-Terrain <span class=SpellE>abgerundet</span><br>
+Terrain abgerundet<br>
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'>DISTANCE<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Distance calculated in <span class=SpellE>cachelist</span><br>
+Distance calculated in cachelist<br>
 BEARING<span style='mso-tab-count:8'>?????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Bearing calculated in <span class=SpellE>cachelist</span><br>
+Bearing calculated in cachelist<br>
 LATLON<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 Coordinates in long format, e.g. N 50? 31.234 E 008? 45.267<br>
 LAT<span style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-&lt;<span class=SpellE>wpt</span> lat=?<span class=SpellE>xx.yyyy</span>?
-??..&gt; Latitude in decimal format, e.g. 50.20147<br>
+&lt;wpt lat=?xx.yyyy? ??..&gt; Latitude in decimal format, e.g. 50.20147<br>
 LON<span style='mso-tab-count:9'>?????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-&lt;<span class=SpellE>wpt</span> ?? <span class=SpellE>lon</span>=?<span
-class=SpellE>xx.yyyy</span>? &gt; Longitude in decimal format, e.g. 008.58132<br>
+&lt;wpt ?? lon=?xx.yyyy? &gt; Longitude in decimal format, e.g. 008.58132<br>
 STATUS<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????????? </span>:<span
 style='mso-spacerun:yes'>? </span>means found<br>
 GC_LOGTYPE<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????? </span>:
-the English Status texts (for <span class=SpellE>gpx</span> ? export)<br>
+the English Status texts (for gpx ? export)<br>
 STATUS_DATE<span style='mso-tab-count:8'>?????????????????????????????????????????????????????????????????????????????????? </span>:
 Get the date part of the status <br>
 STATUS_TIME<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????? </span>:
@@ -346,44 +322,30 @@
 CACHE_NAME<span style='mso-tab-count:8'>?????????????????????????????????????????????????????????????????????????????????? </span>:
 original Name of cache<br>
 NAME<span style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Name of cache (<span class=SpellE>badchars</span> are removed, see below) (<span
-class=SpellE>neuerdings</span> <span class=SpellE>bei</span> ASCII <span
-class=SpellE>Simplifizierung</span> von <span class=SpellE>Zeichen</span>)<br>
+Name of cache (badchars are removed, see below) (neuerdings bei ASCII
+Simplifizierung von Zeichen)<br>
 SHORTNAME<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????? </span>:
 </span><span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
-mso-ansi-language:EN-GB'>Name <span class=SpellE>der</span> <span class=SpellE>durch</span>
-<span class=SpellE>Weglassen</span> von <span class=SpellE>Vokalen</span> von <span
-class=SpellE>hinten</span> und <span class=SpellE>wenn</span> <span
-class=SpellE>das</span> <span class=SpellE>nicht</span> <span class=SpellE>reicht</span>
-<span class=SpellE>durch</span> <span class=SpellE>Weglassen</span> von<span
-style='mso-spacerun:yes'>???? </span><span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????????? </span><span
+mso-ansi-language:EN-GB'>Name der durch Weglassen von Vokalen von hinten und
+wenn das nicht reicht durch Weglassen von<span style='mso-spacerun:yes'>????
+</span><span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????????? </span><span
 style='mso-tab-count:5'>?????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>Kleinbuchstaben</span> von <span class=SpellE>hinten</span>
-auf <span class=SpellE>eine</span> in den <span class=SpellE>Einstellungen</span>
-<span class=SpellE>vorgegebene</span> <span class=SpellE>L?nge</span> <span
-class=SpellE>gek?rzt</span> <span class=SpellE>wird</span>. <br>
+Kleinbuchstaben von hinten auf eine in den Einstellungen vorgegebene L?nge
+gek?rzt wird. <br>
 <span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-(<span class=SpellE>Hintergrund</span>: <span class=SpellE>das</span> Notes -<span
-class=SpellE>Feld</span> <span class=SpellE>der</span> <span class=SpellE>meisten</span>
-<span class=SpellE>Garmins</span> <span class=SpellE>kann</span> <span
-class=SpellE>nur</span> 30 <span class=SpellE>Buchstaben</span>)<br>
+(Hintergrund: das Notes -Feld der meisten Garmins kann nur 30 Buchstaben)<br>
 <span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>dann</span> <span class=SpellE>kriegen</span> <span
-class=SpellE>sie</span> <span class=SpellE>noch</span> <span class=SpellE>Infos</span>
-<span class=SpellE>wie</span> Difficulty etc. rein)<br>
+dann kriegen sie noch Infos wie Difficulty etc. rein)<br>
 CACHEID<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????????? </span>:<br>
 ARCHIVED<span style='mso-tab-count:4'>????????????????????????????????????????? </span><span
 style='mso-tab-count:4'>?????????????????????????????????????????????? </span>:<br>
 AVAILABLE<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????? </span>:
 <br>
 TRAVELBUG<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????? </span>:
-Y or N <span class=SpellE>f?r</span> <span class=SpellE>Anwesenheit/Abwesenheit</span>
-von <span class=SpellE>TBs</span> <span class=SpellE>im</span> Cache&nbsp;<br>
+Y or N f?r Anwesenheit/Abwesenheit von TBs im Cache&nbsp;<br>
 GMTYPE<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Type <span class=SpellE>aus</span> <span class=SpellE>der</span> <span
-class=SpellE>Garminmap.xml</span>, also <span class=SpellE>z.B</span>. Custom
-1, <span class=SpellE>zur</span> <span class=SpellE>Verwendung</span> <span
-class=SpellE>der</span> <span class=SpellE>Benutzerdefinierten</span> Icons<br>
+Type aus der Garminmap.xml, also z.B. Custom 1, zur Verwendung der
+Benutzerdefinierten Icons<br>
 NOW</span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
 mso-ansi-language:EN-GB'>_DATE<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????? </span>:
 Get the date part of now<br>
@@ -393,47 +355,42 @@
 DESCRIPTION<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????? </span>:
 Cache Description (possibly in HTML Format)<br>
 NOTES<span style='mso-tab-count:9'>?????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-User Notes&nbsp;&nbsp; (<span class=SpellE>badchars</span> are removed, see
-below)<br>
+User Notes&nbsp;&nbsp; (badchars are removed, see below)<br>
 HINTS<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Encrypted hints&nbsp;&nbsp; (<span class=SpellE>badchars</span> are removed,
-see below)<br>
+Encrypted hints&nbsp;&nbsp; (badchars are removed, see below)<br>
 DECRYPTEDHINTS<span style='mso-tab-count:7'>???????????????????????????????????????????????????????????????????????????? </span>:
-Decrypted hints&nbsp;&nbsp;&nbsp; (<span class=SpellE>badchars</span> are
-removed, see below) <br>
+Decrypted hints&nbsp;&nbsp;&nbsp; (badchars are removed, see below) <br>
 BUGS<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>Liste</span> <span class=SpellE>der</span> <span
-class=SpellE>TBs</span> : <br>
+Liste der TBs : <br>
 SOLVER<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Solver <span class=SpellE>Infos</span><br>
+Solver Infos<br>
 COUNTRY<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>Staat</span> <br>
+Staat <br>
 STATE<span style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>Bundesland</span><br>
+Bundesland<br>
 HTML<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 TRUE / FALSE if description is html<br>
 VOTE<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>gcvote</span> / OC<br style='mso-special-character:line-break'>
+gcvote / OC<br style='mso-special-character:line-break'>
 <![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
 <![endif]><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>ATTRIBUTES<span
 style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????? </span>:
-the &lt;<span class=SpellE>tmpl_loop</span> ATTRIBUTES&gt;, example see
-GCTemplate.html / show cache in browser offline<br>
+the &lt;tmpl_loop ATTRIBUTES&gt;, example see GCTemplate.html / show cache in
+browser offline<br>
 PATHANDIMAGE<span style='mso-tab-count:7'>??????????????????????????????????????????????????????????????????????????????? </span>:
-path an <span class=SpellE>imagename</span> of the attribute<br>
+path an imagename of the attribute<br>
 IMAGE<span style='mso-tab-count:9'>?????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>imagename</span> of the attribute<br>
+imagename of the attribute<br>
 INFO<span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-description of the attribute from language <span class=SpellE>config</span><br>
+description of the attribute from language config<br>
 GCINFO<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 description of the attribute as from gc.com<br>
 BR<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-contains &lt;<span class=SpellE>br</span>/&gt; every 5<sup>th</sup> attribute
-else empty (can be used with &lt;<span class=SpellE>tmp_if</span>&gt;<span
-class=GramE>)</span><br>
+contains &lt;br/&gt; every 5<sup>th</sup> attribute else empty (can be used
+with &lt;tmp_if&gt;)<br>
 GCID<span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 ID of gc.com<br>
 INC<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
@@ -445,21 +402,21 @@
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>LOGS<span
 style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-the &lt;<span class=SpellE>tmpl_loop</span> LOGS &gt;, example see
-GCTemplate.html / show cache in browser offline<br>
+the &lt;tmpl_loop LOGS &gt;, example see GCTemplate.html / show cache in
+browser offline<br>
 ICON<span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 name of the log picture<br>
 LOGTYPE<span style='mso-tab-count:8'>?????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=GramE>Text :</span> found it<span style='mso-spacerun:yes'>?
-</span>etc?.(</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>gc.com
+Text : found it<span style='mso-spacerun:yes'>? </span>etc?.(</span><span
+lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
+style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>gc.com
 compatible string representation)<br>
 DATE<span style='mso-tab-count:9'>???????????????????????????????????????????????????????????????????????????????????????????????? </span>:
 date of the log<br>
 LOGGER<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????????? </span>:
 name<br>
 MESSAGE<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>logtext</span><o:p></o:p></span></p>
+logtext<o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>
@@ -467,23 +424,19 @@
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>ADDIS<span
 style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-the &lt;<span class=SpellE>tmpl_loop</span> ADDIS&gt; example see
-GCTemplate.html<br>
+the &lt;tmpl_loop ADDIS&gt; example see GCTemplate.html<br>
 WAYPOINT<span style='mso-tab-count:8'>???????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>der</span> <span class=SpellE>Addi</span><br>
+der Addi<br>
 NAME<span style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Name des <span class=SpellE>Addi</span><br>
+Name des Addi<br>
 LATLON<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-<span class=SpellE>Koordinaten</span> des <span class=SpellE>Addi</span><br>
-LAT<span style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????????? </span><span
-class=GramE>:</span><br>
+Koordinaten des Addi<br>
+LAT<span style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????????? </span>:<br>
 LON<span style='mso-tab-count:9'>?????????????????????????????????????????????????????????????????????????????????????????????????? </span>:<br>
 IMG<span style='mso-tab-count:9'>??????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-Name des <span class=SpellE>Addi</span> Icons <span class=SpellE>png</span>
-(resources <span class=SpellE>oder</span> <span class=SpellE>exporticons</span>)<br>
+Name des Addi Icons png (resources oder exporticons)<br>
 ICON<span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
-&lt;type&gt; as number string (see <span class=SpellE>CacheType.java</span> <span
-class=SpellE>e.g</span> : ?,50=Parking ?.)<br>
+&lt;type&gt; as number string (see CacheType.java e.g : ?,50=Parking ?.)<br>
 </span><span style='font-size:10.0pt;font-family:Arial'>TYPENAME<span
 style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????? </span>:
 Typename des Addi wie in der GUI<br>
@@ -500,11 +453,9 @@
 mso-outline-level:1'><span style='font-size:10.0pt;font-family:Arial'><o:p>&nbsp;</o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
-mso-outline-level:1'><span class=SpellE><span class=GramE><span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>cacheImg</span></span></span><span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'><span
-style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????????? </span>:
-the &lt;<span class=SpellE>tmpl_loop</span> <span class=SpellE>cacheImg</span>&gt;<br>
+mso-outline-level:1'><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'>cacheImg<span style='mso-tab-count:8'>??????????????????????????????????????????????????????????????????????????????????????????? </span>:
+the &lt;tmpl_loop cacheImg&gt;<br>
 FILENAME<span style='mso-tab-count:8'>????????????????????????????????????????????????????????????????????????????????????????? </span>:
 the filename in the profile directory<br>
 TEXT<span style='mso-tab-count:9'>????????????????????????????????????????????????????????????????????????????????????????????????? </span>:
@@ -528,34 +479,24 @@
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>&lt;#--
 Microsoft AutoRoute --&gt;<br>
-&lt;#-- <span class=SpellE>Codecs</span>: ASCII, UTF8 --&gt;<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>charset</span>&quot;
-value=&quot;ASCII&quot;&gt;<br>
-&lt;#-- <span class=SpellE>somme</span> chars should not appear in the <span
-class=SpellE>cachename</span> --&gt;<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>badchars</span>&quot;
-value=&quot;;&quot;&quot;<span class=GramE>&gt;</span><br>
-&lt;#-- <span class=SpellE>newline</span>: CR, LF, CRLF --&gt;<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>newline</span>&quot;
-value=&quot;CRLF&quot;&gt;<br>
-&lt;#-- decimal <span class=SpellE>seperator</span>: . or , --&gt;<br>
-&lt;<span class=SpellE>tmpl_par</span> name=&quot;<span class=SpellE>decsep</span>&quot;
-value=&quot;,&quot;&gt;<br>
+&lt;#-- Codecs: ASCII, UTF8 --&gt;<br>
+&lt;tmpl_par name=&quot;charset&quot; value=&quot;ASCII&quot;&gt;<br>
+&lt;#-- somme chars should not appear in the cachename --&gt;<br>
+&lt;tmpl_par name=&quot;badchars&quot; value=&quot;;&quot;&quot;&gt;<br>
+&lt;#-- newline: CR, LF, CRLF --&gt;<br>
+&lt;tmpl_par name=&quot;newline&quot; value=&quot;CRLF&quot;&gt;<br>
+&lt;#-- decimal seperator: . or , --&gt;<br>
+&lt;tmpl_par name=&quot;decsep&quot; value=&quot;,&quot;&gt;<br>
 Name;Breitengrad;L?ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink&lt;br /&gt;<br>
-&lt;<span class=SpellE>tmpl_loop</span> <span class=SpellE>cache_index</span>&gt;<br>
-&quot;&lt;<span class=SpellE>tmpl_var</span> name=SHORTTYPE&gt;-&lt;<span
-class=SpellE>tmpl_var</span> name=SHORTSIZE&gt;-&lt;<span class=SpellE>tmpl_var</span>
-name=DIFFICULTY&gt;-&lt;<span class=SpellE>tmpl_var</span> name=TERRAIN&gt;
-&lt;<span class=SpellE>tmpl_var</span> name=NAME&gt;&quot;;&lt;<span
-class=SpellE>tmpl_var</span> name=LAT&gt;;&lt;<span class=SpellE>tmpl_var</span>
-name=LON&gt;;&quot;&lt;<span class=SpellE>tmpl_var</span>
-name=TYPE&gt;&quot;;&quot;&lt;<span class=SpellE>tmpl_var</span>
-name=SIZE&gt;&quot;;&quot;&lt;<span class=SpellE>tmpl_var</span>
-name=WAYPOINT&gt;&quot;;&quot;&lt;<span class=SpellE>tmpl_var</span>
-name=DATE&gt;&quot;;&quot;&lt;<span class=SpellE>tmpl_var</span>
-name=URL&gt;&quot;&lt;<span class=SpellE>br</span> /&gt;<br>
-&lt;/<span class=SpellE>tmpl_loop</span>&gt;<br style='mso-special-character:
-line-break'>
+&lt;tmpl_loop cache_index&gt;<br>
+&quot;&lt;tmpl_var name=SHORTTYPE&gt;-&lt;tmpl_var
+name=SHORTSIZE&gt;-&lt;tmpl_var name=DIFFICULTY&gt;-&lt;tmpl_var
+name=TERRAIN&gt; &lt;tmpl_var name=NAME&gt;&quot;;&lt;tmpl_var
+name=LAT&gt;;&lt;tmpl_var name=LON&gt;;&quot;&lt;tmpl_var
+name=TYPE&gt;&quot;;&quot;&lt;tmpl_var name=SIZE&gt;&quot;;&quot;&lt;tmpl_var
+name=WAYPOINT&gt;&quot;;&quot;&lt;tmpl_var name=DATE&gt;&quot;;&quot;&lt;tmpl_var
+name=URL&gt;&quot;&lt;br /&gt;<br>
+&lt;/tmpl_loop&gt;<br style='mso-special-character:line-break'>
 <![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
 <![endif]></span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
@@ -564,22 +505,19 @@
 Arial;mso-ansi-language:EN-GB'>Tags</span></u><u><span lang=EN-GB
 style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
 
-<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-class=SpellE><u><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>tmpl_var</span></u></span><u><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
+<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>tmpl_var</span></u><u><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>You
 can set default values for your template variables, which</span><span
 lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
 style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>will be used
-if no value has been set through the <span class=SpellE>setParam</span> method.<br>
-&lt;TMPL_VAR name=&quot;<span class=SpellE>var_name</span>&quot;
-default=&quot;my value&quot;&gt;<br>
-If <span class=SpellE>var_name</span> is set using <span class=SpellE>setParam</span>
-(or <span class=SpellE>setParams</span>), then it's value will be whatever it
-was set to<span class=GramE>,<span style='mso-spacerun:yes'>? </span>else</span></span><span
+if no value has been set through the setParam method.<br>
+&lt;TMPL_VAR name=&quot;var_name&quot; default=&quot;my value&quot;&gt;<br>
+If var_name is set using setParam (or setParams), then it's value will be
+whatever it was set to,<span style='mso-spacerun:yes'>? </span>else</span><span
 lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
 style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>it will be
 &quot;my value&quot; (without the quotes).<o:p></o:p></span></p>
@@ -589,21 +527,15 @@
 can also &quot;escape&quot; certain strings. The following escape modes are
 possible.<br>
 </span><span lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp; </span><span
-class=GramE><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>none</span></span><span lang=EN-GB style='font-size:
-10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>:&nbsp;&nbsp; String
-unchanged (this is the default if escape is not specified)<br>
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>none:&nbsp;&nbsp;
+String unchanged (this is the default if escape is not specified)<br>
 </span><span lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp; </span><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>html:&nbsp;&nbsp;
 Encode special characters: &amp; &gt; &lt; &quot;.&nbsp; They are changed to
-&amp;amp; &amp;<span class=SpellE>lt</span>;<span class=GramE>&nbsp; &amp;</span><span
-class=SpellE>gt</span>;&nbsp; and &amp;<span class=SpellE>quot</span>;
-respectively<br>
+&amp;amp; &amp;lt;&nbsp; &amp;gt;&nbsp; and &amp;quot; respectively<br>
 </span><span lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp; </span><span
-class=SpellE><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>url</span></span><span lang=EN-GB style='font-size:
-10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>:&nbsp;&nbsp;&nbsp; Encode
-special characters in URL, e.g. space becomes %20<br>
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>url:&nbsp;&nbsp;&nbsp;
+Encode special characters in URL, e.g. space becomes %20<br>
 </span><span lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp; </span><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>quote:&nbsp;
 Change quotation marks:&nbsp;&nbsp; &quot; becomes \&quot;&nbsp; and ' becomes
@@ -613,47 +545,41 @@
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>Example:
-&lt;TMPL_VAR name=&quot;<span class=SpellE>var_name</span>&quot;
-escape=&quot;html&quot;&gt;</span><span lang=EN-GB style='mso-ansi-language:
-EN-GB'><o:p></o:p></span></p>
+&lt;TMPL_VAR name=&quot;var_name&quot; escape=&quot;html&quot;&gt;</span><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp;<o:p></o:p></span></p>
 
-<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-class=SpellE><u><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>tmpl_if</span></u></span><u><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
+<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>tmpl_if</span></u><u><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>The
-&lt;<span class=SpellE>tmpl_if</span>&gt; tag allows you to include or not
-include a block of the template based on the <span class=GramE>value<span
-style='mso-spacerun:yes'>? </span>of</span></span><span lang=EN-GB
-style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;
-font-family:Arial;mso-ansi-language:EN-GB'>a given parameter name. If the
-parameter is given a value that is true, then the block is included in</span><span
+&lt;tmpl_if&gt; tag allows you to include or not include a block of the
+template based on the value<span style='mso-spacerun:yes'>? </span>of</span><span
 lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>the output.
-If the value is false, then it is skipped.<br>
-The <span class=SpellE>tmpl_if</span> must be closed with a corresponding /<span
-class=SpellE>tmpl_if</span>, e.g.</span><span lang=EN-GB style='mso-ansi-language:
-EN-GB'><o:p></o:p></span></p>
+style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>a given
+parameter name. If the parameter is given a value that is true, then the block
+is included in</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>the
+output. If the value is false, then it is skipped.<br>
+The tmpl_if must be closed with a corresponding /tmpl_if, e.g.</span><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>&lt;<span
-class=SpellE>tmpl_if</span> ...&gt;<br>
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>&lt;tmpl_if
+...&gt;<br>
 ...<br>
-&lt;/<span class=SpellE>tmpl_if</span>&gt;</span><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
+&lt;/tmpl_if&gt;</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>Parameter
-values for conditions are Strings in java, and not <span class=SpellE><span
-class=GramE>boolean</span></span> values, hence, what evaluates to true and</span><span
-lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>false needs
-to be specifically defined.<br>
+values for conditions are Strings in java, and not boolean values, hence, what
+evaluates to true and</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>false
+needs to be specifically defined.<br>
 As of now, the following values evaluate to false:<br>
 &quot;&quot; - the empty string<br>
 &quot;0&quot; - the string containing only the number zero<br>
@@ -663,58 +589,52 @@
 <![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
 <![endif]></span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
-<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-class=SpellE><u><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>tmpl_else</span></u></span><u><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
+<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>tmpl_else</span></u><u><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>While
-the if block allows us to display some output if a condition is true<span
-class=GramE>,<span style='mso-spacerun:yes'>? </span>we</span></span><span
-lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>may also
-need to display content if the condition is false. This can be done by using
-the optional else</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>branch
-of <span class=GramE>the if</span> block.</span><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
+the if block allows us to display some output if a condition is true,<span
+style='mso-spacerun:yes'>? </span>we</span><span lang=EN-GB style='mso-ansi-language:
+EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'>may also need to display content if the condition is
+false. This can be done by using the optional else</span><span lang=EN-GB
+style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'>branch of the if block.</span><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
-<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-class=SpellE><u><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>tmpl_unless</span></u></span><u><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
+<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>tmpl_unless</span></u><u><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>This
-tag is the exact opposite of the &lt;<span class=SpellE>tmpl_if</span>&gt; tag.
-A &lt;<span class=SpellE>tmpl_unless</span>&gt; block is displayed if its
-control variable</span><span lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>evaluates
-to false. If the control variable evaluates to true, then the else block, if</span><span
-lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>any, is
-displayed instead.</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
+tag is the exact opposite of the &lt;tmpl_if&gt; tag. A &lt;tmpl_unless&gt;
+block is displayed if its control variable</span><span lang=EN-GB
+style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'>evaluates to false. If the control
+variable evaluates to true, then the else block, if</span><span lang=EN-GB
+style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'>any, is displayed instead.</span><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
-<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-class=SpellE><u><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>tmpl_loop</span></u></span><u><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
+<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>tmpl_loop</span></u><u><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>The
-&lt;<span class=SpellE>tmpl_loop</span>&gt; tag is a bit more complicated than
-the other tags. It allows you to create a section of text that</span><span
-lang=EN-GB style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>will be
-displayed repeatedly for every item in the loop control variable. Inside the
-&lt;<span class=SpellE>tmpl_loop</span>&gt;<span class=GramE>,<span
-style='mso-spacerun:yes'>? </span>you</span></span><span lang=EN-GB
-style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;
-font-family:Arial;mso-ansi-language:EN-GB'>place &lt;<span class=SpellE>tmpl_var</span>&gt;s.<b
-style='mso-bidi-font-weight:normal'> The only loop used by the template
-exporter is '<span class=SpellE>cache_index</span>', see example above. </b></span><span
-lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
+&lt;tmpl_loop&gt; tag is a bit more complicated than the other tags. It allows
+you to create a section of text that</span><span lang=EN-GB style='mso-ansi-language:
+EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'>will be displayed repeatedly for every item in the
+loop control variable. Inside the &lt;tmpl_loop&gt;,<span
+style='mso-spacerun:yes'>? </span>you</span><span lang=EN-GB style='mso-ansi-language:
+EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'>place &lt;tmpl_var&gt;s.<b style='mso-bidi-font-weight:
+normal'> The only loop used by the template exporter is 'cache_index', see
+example above. </b></span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
 mso-outline-level:1'><st1:place><u><span lang=EN-GB style='font-size:10.0pt;
@@ -725,11 +645,11 @@
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>If
-you set <span class=SpellE>loop_context_vars</span> to true in your Template's
-constructor, then you will have access to five special</span><span lang=EN-GB
-style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;
-font-family:Arial;mso-ansi-language:EN-GB'>variables in all your loops. These
-are:</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
+you set loop_context_vars to true in your Template's constructor, then you will
+have access to five special</span><span lang=EN-GB style='mso-ansi-language:
+EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'>variables in all your loops. These are:</span><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>__FIRST__<span
@@ -761,20 +681,18 @@
 mso-ansi-language:EN-GB'>You may use these like any other &lt;TMPL_VAR&gt;
 inside your loop.</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
 
-<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
-class=SpellE><u><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>tmpl_include</span></u></span><u><span lang=EN-GB
-style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
+<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><u><span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>tmpl_include</span></u><u><span
+lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></u></p>
 
 <p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'>The
-&lt;<span class=SpellE>tmpl_include</span>&gt; tag is the next simplest tag
-after &lt;<span class=SpellE>tmpl_var</span>&gt;, however, it will not do what
-you expect it to do inside</span><span lang=EN-GB style='mso-ansi-language:
-EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'>a &lt;<span class=SpellE>tmpl_if</span>&gt;<br>
-&lt;<span class=SpellE>tmpl_include</span>&gt; is used to include the contents
-of another template within this template, at the position of the tag. <br>
+&lt;tmpl_include&gt; tag is the next simplest tag after &lt;tmpl_var&gt;,
+however, it will not do what you expect it to do inside</span><span lang=EN-GB
+style='mso-ansi-language:EN-GB'> </span><span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'>a &lt;tmpl_if&gt;<br>
+&lt;tmpl_include&gt; is used to include the contents of another template within
+this template, at the position of the tag. <br>
 Processing then continues, as if the included template were always a part of
 the current template. <o:p></o:p></span></p>
 

Modified: branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,27 @@
-TakenFromUrl: http://downloads.igorbrejc.net/osm/kosmos/
-#Kosmos Download : http://downloads.igorbrejc.net/osm/kosmos/
+TakenFromUrl: http://maperitive.net/
 GetCapabilitiesUrl:
-Name:               OSMCycleMap mit Kosmos.Console.exe
+Name:               OSM Cyclemap with Maperitive.exe
 MapType:                        topo
-MainUrl:            C:\\Programme\\Kosmos-2.5.405.6\\Console\\Kosmos.Console.exe
-ServiceTypeUrlPart: OSMCycleMap.kpr
-VersionUrlPart:
+#MainUrl: name of exceutable
+MainUrl:            Maperitive.exe
+#ServiceTypeUrlPart: default map to use : may be empty(=mapnik) or mapnik or osmarender or cyclemap
+ServiceTypeUrlPart: cyclemap
+#VersionUrlPart: path to executable of mainUrl
+VersionUrlPart: C:/Programme/Maperitive
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:     Kosmos
+#RequestUrlPart: must be Maperitive
+RequestUrlPart:     Maperitive
+#LayersUrlPart: empty or filename (osm or other) for the load-source command; path from VersionUrlPart will be added by CW
 LayersUrlPart:
+#StylesUrlPart: empty or filename for the use-ruleset location; path from VersionUrlPart will be added by CW
 StylesUrlPart:
 ImageFormatUrlPart:FORMAT=image/png
+# BBox the osm-file covers
 BoundingBoxTopLeftWGS84: N 90.0000 W 180.0000
-BoundingBoxButtomRightWGS84: S 90.0000 E 180.0000
+BoundingBoxBottomRightWGS84: S 90.0000 E 180.0000
 MinScale:   0
 MaxScale:   1000
 RecommendedScale:   5
-ImageFileExtension: .png
+#Maperitive does many png, jpg(jpeg), bmp, tif(tiff) , gif, emf, wmf
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,27 @@
-TakenFromUrl: http://downloads.igorbrejc.net/osm/kosmos/
-#Kosmos Download : http://downloads.igorbrejc.net/osm/kosmos/
+TakenFromUrl: http://maperitive.net/
 GetCapabilitiesUrl:
-Name:               OSMMapnik mit Kosmos.Console.exe
+Name:               OSM Mapnik with Maperitive.exe
 MapType:                        topo
-MainUrl:            C:\\Programme\\Kosmos-2.5.405.6\\Console\\Kosmos.Console.exe
-ServiceTypeUrlPart: OSMMapnik.kpr
-VersionUrlPart:
+#MainUrl: name of exceutable
+MainUrl:            Maperitive.exe
+#ServiceTypeUrlPart: default map to use : may be empty(=mapnik) or mapnik or osmarender or cyclemap
+ServiceTypeUrlPart: 
+#VersionUrlPart: path to executable of mainUrl
+VersionUrlPart: C:/Programme/Maperitive
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:     Kosmos
+#RequestUrlPart: must be Maperitive
+RequestUrlPart:     Maperitive
+#LayersUrlPart: empty or filename (osm or other) for the load-source command; path from VersionUrlPart will be added by CW
 LayersUrlPart:
+#StylesUrlPart: empty or filename for the use-ruleset location; path from VersionUrlPart will be added by CW
 StylesUrlPart:
 ImageFormatUrlPart:FORMAT=image/png
+# BBox the osm-file covers
 BoundingBoxTopLeftWGS84: N 90.0000 W 180.0000
-BoundingBoxButtomRightWGS84: S 90.0000 E 180.0000
+BoundingBoxBottomRightWGS84: S 90.0000 E 180.0000
 MinScale:   0
 MaxScale:   1000
 RecommendedScale:   5
-ImageFileExtension: .png
+#Maperitive does many png, jpg(jpeg), bmp, tif(tiff) , gif, emf, wmf
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,27 @@
-TakenFromUrl: http://downloads.igorbrejc.net/osm/kosmos/
-#Kosmos Download : http://downloads.igorbrejc.net/osm/kosmos/
+TakenFromUrl: http://maperitive.net/
 GetCapabilitiesUrl:
-Name:               OSMOsmarender mit Kosmos.Console.exe
+Name:               OSMarender with Maperitive.exe
 MapType:                        topo
-MainUrl:            C:\\Programme\\Kosmos-2.5.405.6\\Console\\Kosmos.Console.exe
-ServiceTypeUrlPart: OSMOsmarender.kpr
-VersionUrlPart:
+#MainUrl: name of exceutable
+MainUrl:            Maperitive.exe
+#ServiceTypeUrlPart: default map to use : may be empty(=mapnik) or mapnik or osmarender or cyclemap
+ServiceTypeUrlPart: osmarender
+#VersionUrlPart: path to executable of mainUrl
+VersionUrlPart: C:/Programme/Maperitive
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:     Kosmos
+#RequestUrlPart: must be Maperitive
+RequestUrlPart:     Maperitive
+#LayersUrlPart: empty or filename (osm or other) for the load-source command; path from VersionUrlPart will be added by CW
 LayersUrlPart:
+#StylesUrlPart: empty or filename for the use-ruleset location; path from VersionUrlPart will be added by CW
 StylesUrlPart:
 ImageFormatUrlPart:FORMAT=image/png
+# BBox the osm-file covers
 BoundingBoxTopLeftWGS84: N 90.0000 W 180.0000
-BoundingBoxButtomRightWGS84: S 90.0000 E 180.0000
+BoundingBoxBottomRightWGS84: S 90.0000 E 180.0000
 MinScale:   0
 MaxScale:   1000
 RecommendedScale:   5
-ImageFileExtension: .png
+#Maperitive does many png, jpg(jpeg), bmp, tif(tiff) , gif, emf, wmf
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/at-3_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-3_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/at-3_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -41,7 +41,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.112935  E 14.243781
-BoundingBoxButtomRightWGS84:   N 47.297627 E 17.481360
+BoundingBoxBottomRightWGS84:   N 47.297627 E 17.481360
 #BBox_Mitte: N 48.205281 E 15.862571
 MinScale:   0
 MaxScale:   45

Modified: branches/r1.2/res_noewe/webmapservices/at-3_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-3_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/at-3_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -39,7 +39,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.112935  E 14.243781
-BoundingBoxButtomRightWGS84:   N 47.297627 E 17.481360
+BoundingBoxBottomRightWGS84:   N 47.297627 E 17.481360
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   5

Added: branches/r1.2/res_noewe/webmapservices/at-5_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-5_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-5_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+TakenFromUrl:       http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer
+GetCapabilitiesUrl: http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               at.Salzburg p
+MapType:                        photo
+MainUrl:            http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=0|Polygondecker||
+#LayersUrlPart:     LAYERS=1|Orientierungskarte|0.000396|198.000000
+#LayersUrlPart:     LAYERS=2|Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=3|Flugjahr Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=4|Vogelschutzgebiete|0.792000|39.600000
+#LayersUrlPart:     LAYERS=5|Habitat Richtlinie (PSCI)|0.792000|39.600000
+#LayersUrlPart:     LAYERS=6|Naturpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=7|Landschaftsschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=8|Nationalpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=9|Naturschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=10|geschuetzte Landschaftsteile|0.792000|39.600000
+#LayersUrlPart:     LAYERS=11|Landesstrasse B|0.000396|39.600000
+#LayersUrlPart:     LAYERS=12|Landesstrasse L|0.000396|39.600000
+#LayersUrlPart:     LAYERS=13|Autobahn|0.000396|39.600000
+#LayersUrlPart:     LAYERS=14|Radwanderroute|0.0|1.980396
+#LayersUrlPart:     LAYERS=15|geonam|0.000396|7.919604
+#LayersUrlPart:     LAYERS=16|Politische Gemeinde|7.920000|39.600000
+#LayersUrlPart:     LAYERS=17|Politische Bezirke|39.600396|99.000000
+#LayersUrlPart:     LAYERS=18|NUTS 3 Regionen|3.959604|Infinity
+#LayersUrlPart:     LAYERS=19|Landesgrenze|198.000396|297.000000
+LayersUrlPart:     LAYERS=2
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 48.8794 E 11.1495
+BoundingBoxBottomRightWGS84: N 46.5273 E 15.1958
+#BBox_Mitte: N 47.70337 E 13.1726725
+MinScale:   0
+MaxScale:   3
+RecommendedScale:    1 2
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/at-5_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-5_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-5_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+TakenFromUrl:       http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer
+GetCapabilitiesUrl: http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               at.Salzburg t
+MapType:                        topo
+MainUrl:            http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=0|Polygondecker||
+#LayersUrlPart:     LAYERS=1|Orientierungskarte|0.000396|198.000000
+#LayersUrlPart:     LAYERS=2|Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=3|Flugjahr Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=4|Vogelschutzgebiete|0.792000|39.600000
+#LayersUrlPart:     LAYERS=5|Habitat Richtlinie (PSCI)|0.792000|39.600000
+#LayersUrlPart:     LAYERS=6|Naturpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=7|Landschaftsschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=8|Nationalpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=9|Naturschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=10|geschuetzte Landschaftsteile|0.792000|39.600000
+#LayersUrlPart:     LAYERS=11|Landesstrasse B|0.000396|39.600000
+#LayersUrlPart:     LAYERS=12|Landesstrasse L|0.000396|39.600000
+#LayersUrlPart:     LAYERS=13|Autobahn|0.000396|39.600000
+#LayersUrlPart:     LAYERS=14|Radwanderroute|0.0|1.980396
+#LayersUrlPart:     LAYERS=15|geonam|0.000396|7.919604
+#LayersUrlPart:     LAYERS=16|Politische Gemeinde|7.920000|39.600000
+#LayersUrlPart:     LAYERS=17|Politische Bezirke|39.600396|99.000000
+#LayersUrlPart:     LAYERS=18|NUTS 3 Regionen|3.959604|Infinity
+#LayersUrlPart:     LAYERS=19|Landesgrenze|198.000396|297.000000
+LayersUrlPart:     LAYERS=1,11,12,13,15,16,17,19
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/png
+BoundingBoxTopLeftWGS84: N 48.8794 E 11.1495
+BoundingBoxBottomRightWGS84: N 46.5273 E 15.1958
+#BBox_Mitte: N 47.70337 E 13.1726725
+MinScale:   0
+MaxScale:   1000
+RecommendedScale:   1 5 10
+ImageFileExtension: .png

Added: branches/r1.2/res_noewe/webmapservices/at-6_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-6_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-6_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,42 @@
+???TakenFromUrl:       http://stmk-nt10:80/wmsconnector/com.esri.wms.Esrimap/geoland34_wms?
+GetCapabilitiesUrl: http://gis2.stmk.gv.at/wmsconnector/com.esri.wms.Esrimap?serviceName=geoland34_wms&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               at.Steiermark p
+MapType:                        photo
+MainUrl:            http://gis2.stmk.gv.at/wmsconnector/com.esri.wms.Esrimap?serviceName=geoland34_wms&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=Polygondecker|Polygondecker||
+#LayersUrlPart:     LAYERS=orientierungskarte|Orientierungskarte|NaN|99999999
+#LayersUrlPart:     LAYERS=Vogelschutzrichtlinie|Vogelschutzrichtlinie (SPA)||
+#LayersUrlPart:     LAYERS=Habitatrichtlinie|Habitat-Richtlinie (PSCI)||
+#LayersUrlPart:     LAYERS=Naturpark|Naturpark||
+#LayersUrlPart:     LAYERS=Landschaftsschutzgebiet|Landschaftsschutzgebiet||
+#LayersUrlPart:     LAYERS=Nationalpark|Nationalpark||
+#LayersUrlPart:     LAYERS=Naturschutzgebiet|Naturschutzgebiet||
+#LayersUrlPart:     LAYERS=geschuetzteLandschaftsteile|geschuetzte Landschaftsteile||
+#LayersUrlPart:     LAYERS=l_str|Landesstrasse L||
+#LayersUrlPart:     LAYERS=b_str|Landesstrasse B||
+#LayersUrlPart:     LAYERS=s_str|Schnellstrasse||
+#LayersUrlPart:     LAYERS=a_str|Autobahn||
+#LayersUrlPart:     LAYERS=radwanderrouten|Radwanderrouten||
+#LayersUrlPart:     LAYERS=oertl_str|??rtliches Strassennetz||
+#LayersUrlPart:     LAYERS=geo_nam|geonam|NaN|NaN
+#LayersUrlPart:     LAYERS=ortho05m_farbe|Orthofoto||
+#LayersUrlPart:     LAYERS=Flugdatum_Farbe|Flugdatum Orthofoto Farbe||
+#LayersUrlPart:     LAYERS=PolitischeGemeinden|Politische Gemeinden||
+#LayersUrlPart:     LAYERS=PolitischeBezirke|Politische Bezirke||
+#LayersUrlPart:     LAYERS=Nuts3Regionen|Nuts3 Regionen|NaN|99999999
+#LayersUrlPart:     LAYERS=Landesgrenzen|Landesgrenzen||
+LayersUrlPart:     LAYERS=l_str,b_str,s_str,a_str,oertl_str,geo_nam,ortho05m_farbe
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 50.6551 E 6.6948
+BoundingBoxBottomRightWGS84: N 42.9679 E 23.0349
+#BBox_Mitte: N 46.8114789243 E 14.86481406315
+MinScale:   0
+MaxScale:   1000
+RecommendedScale:   1
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/at-8_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-8_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-8_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,29 @@
+TakenFromUrl:       http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&version=1.1.1&
+GetCapabilitiesUrl: http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               at.Vorarlberg t
+MapType:                        topo
+MainUrl:            http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=MS|Topographische Karten||
+#LayersUrlPart:     LAYERS=topokarte_isoli_text_20t|Topographische Karte Isoli_Text 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topokarte_winter_isoli_text_20t|Topographische Karte Isoli_Text Winter 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topokarte_20t|Topographische Karte 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topokarte_winter_20t|Topographische Karte Winter 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topo_symbole|Topographische Karte Symbole|0.37455131345855|18.7092309932477
+#LayersUrlPart:     LAYERS=topo_texte|Topographische Karte Texte|0.37455131345855|18.7092309932477
+#LayersUrlPart:     LAYERS=topo_linien|Topographische Karte Linien|0.37455131345855|18.7092309932477
+#LayersUrlPart:     LAYERS=topo_textlinien|Topographische Karte Textlinien|0.37455131345855|18.7092309932477
+LayersUrlPart:     LAYERS=topokarte_20t
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 47.6586 E 9.4012
+BoundingBoxBottomRightWGS84: N 46.7554 E 10.3996
+#BBox_Mitte: N 47.207 E 9.90039
+MinScale:   1.3811
+MaxScale:   88.3883
+RecommendedScale:    2 5 10
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/at_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/at_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -32,7 +32,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.027050  E 9.529250
-BoundingBoxButtomRightWGS84:   N 46.357433 E 17.202733
+BoundingBoxBottomRightWGS84:   N 46.357433 E 17.202733
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #S?db?hmen
 BoundingBoxTopLeftWGS84: N 49.62233 E 13.51730
-BoundingBoxButtomRightWGS84: N 48.54843 E 15.61450
+BoundingBoxBottomRightWGS84: N 48.54843 E 15.61450
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -91,7 +91,7 @@
 ImageFormatUrlPart:FORMAT=image/jpeg
 #manuell
 BoundingBoxTopLeftWGS84: N 49.634341 E 15.50975
-BoundingBoxButtomRightWGS84: N 48.614016 E 17.666016
+BoundingBoxBottomRightWGS84: N 48.614016 E 17.666016
 #MinScale:   0
 #MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #Real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #S?dm?hren
 BoundingBoxTopLeftWGS84: N 49.634619 E 15.531836
-BoundingBoxButtomRightWGS84: N 48.609817 E 17.657948
+BoundingBoxBottomRightWGS84: N 48.609817 E 17.657948
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -33,9 +33,9 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 #BoundingBoxTopLeftWGS84: N 49.9457 E 14.7989
-#BoundingBoxButtomRightWGS84: N 48.8765 E 16.5340
+#BoundingBoxBottomRightWGS84: N 48.8765 E 16.5340
 BoundingBoxTopLeftWGS84: N 49.9841 E 14.7605
-BoundingBoxButtomRightWGS84: N 48.7959 E 16.5811
+BoundingBoxBottomRightWGS84: N 48.7959 E 16.5811
 #BBox_Mitte: N 49.41110624465 E 15.6664623227
 #MinScale:   0
 #MaxScale:   45

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -33,9 +33,9 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 #BoundingBoxTopLeftWGS84: N 49.9457 E 14.7989
-#BoundingBoxButtomRightWGS84: N 48.8765 E 16.5340
+#BoundingBoxBottomRightWGS84: N 48.8765 E 16.5340
 BoundingBoxTopLeftWGS84: N 49.9841 E 14.7605
-BoundingBoxButtomRightWGS84: N 48.7959 E 16.5811
+BoundingBoxBottomRightWGS84: N 48.7959 E 16.5811
 #BBox_Mitte: N 49.41110624465 E 15.6664623227
 #MinScale:   0
 #MaxScale:   45

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #Hochland
 BoundingBoxTopLeftWGS84: N 49.86521 E 14.886475
-BoundingBoxButtomRightWGS84: N 48.932583 E 16.42529
+BoundingBoxBottomRightWGS84: N 48.932583 E 16.42529
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -33,9 +33,9 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 #BoundingBoxTopLeftWGS84: N 49.9457 E 14.7989
-#BoundingBoxButtomRightWGS84: N 48.8765 E 16.5340
+#BoundingBoxBottomRightWGS84: N 48.8765 E 16.5340
 BoundingBoxTopLeftWGS84: N 49.9841 E 14.7605
-BoundingBoxButtomRightWGS84: N 48.7959 E 16.5811
+BoundingBoxBottomRightWGS84: N 48.7959 E 16.5811
 #BBox_Mitte: N 49.41110624465 E 15.6664623227
 #MinScale:   0
 #MaxScale:   45

Added: branches/r1.2/res_noewe/webmapservices/cz_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/cz_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,22 @@
+???TakenFromUrl:       
+GetCapabilitiesUrl: http://geoportal.cuzk.cz/WMS_ZM50_PUB/service.svc/get?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               cz.Tschechien t50k
+MapType:                        topo
+MainUrl:            http://geoportal.cuzk.cz/WMS_ZM50_PUB/service.svc/get?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=GR_ZM50|Z??kladn?? mapa 1:50 000|1|100000
+#LayersUrlPart:     LAYERS=GT_TEXT_ZM10|Copyright|1|100000
+LayersUrlPart:     LAYERS=GR_ZM50
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 51.4961 E 11.6156
+BoundingBoxBottomRightWGS84: N 48.0913 E 19.0612
+#BBox_Mitte: N 49.7936991896322 E 15.3384076389007
+MinScale:   0
+MaxScale:   12
+RecommendedScale:    5 2 4
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:   STYLES=2
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.5000 E 11.7000
-BoundingBoxButtomRightWGS84: N 51.3000 E 14.8000
+BoundingBoxBottomRightWGS84: N 51.3000 E 14.8000
 MinScale:   0.1
 MaxScale:   11
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -20,7 +20,7 @@
 StylesUrlPart:     STYLES=2
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.5000 E 11.7000
-BoundingBoxButtomRightWGS84: N 51.3000 E 14.8000
+BoundingBoxBottomRightWGS84: N 51.3000 E 14.8000
 MinScale:   0.1
 MaxScale:   25
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/de-bw_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bw_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bw_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.0000 E 7.6000
-BoundingBoxButtomRightWGS84: N 47.4000 E 10.0000
+BoundingBoxBottomRightWGS84: N 47.4000 E 10.0000
 MinScale:   1
 MaxScale:   700
 RecommendedScale:    1 8

Added: branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,22 @@
+TakenFromUrl:       http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten
+GetCapabilitiesUrl: http://www.lv-bw.de/dv/service/getrds.asp?login=dv&pw=anonymous&SERVICE=WMS&REQUEST=GetCapabilities
+Name: de.Baden-Wuerttemberg t10k
+MapType:                        topo
+#MainUrl:            http://www.lv-bw.de/dv/service/getrds.asp?login=dv&pw=anonymous&
+MainUrl:            http://www.lv-bw.de/dv/service/getrds.asp?login=geoportal&pw=gdi_bw&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31467
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31467
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=DVDOP2|DOP_2m||
+#LayersUrlPart:     LAYERS=DVTK50K|TK50||
+LayersUrlPart:     LAYERS=RK10
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 50.0000 E 7.6000
+BoundingBoxBottomRightWGS84: N 47.4000 E 10.0000
+MinScale:   0
+MaxScale:   20
+RecommendedScale:    1 5 10
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.0000 E 7.6000
-BoundingBoxButtomRightWGS84: N 47.4000 E 10.0000
+BoundingBoxBottomRightWGS84: N 47.4000 E 10.0000
 MinScale:   0.3
 MaxScale:   700
 RecommendedScale:    5 8 4 2 1

Modified: branches/r1.2/res_noewe/webmapservices/de-by_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-by_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-by_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -17,7 +17,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.6269 E 8.8929
-BoundingBoxButtomRightWGS84: N 47.0828 E 13.9782
+BoundingBoxBottomRightWGS84: N 47.0828 E 13.9782
 MinScale:   2.82
 MaxScale:   11
 RecommendedScale:    3 4 5

Modified: branches/r1.2/res_noewe/webmapservices/de-by_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-by_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-by_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -17,7 +17,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.6269 E 8.8929
-BoundingBoxButtomRightWGS84: N 47.0828 E 13.9782
+BoundingBoxBottomRightWGS84: N 47.0828 E 13.9782
 MinScale:   1
 MaxScale:   15
 RecommendedScale:    3 5 7

Modified: branches/r1.2/res_noewe/webmapservices/de-he_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-he_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-he_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.6697 E 7.6991
-BoundingBoxButtomRightWGS84: N 49.3455 E 11.3986
+BoundingBoxBottomRightWGS84: N 49.3455 E 11.3986
 MinScale:   0.4
 MaxScale:   3
 RecommendedScale:    1

Modified: branches/r1.2/res_noewe/webmapservices/de-he_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-he_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-he_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -16,7 +16,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.6697 E 7.6991
-BoundingBoxButtomRightWGS84: N 49.3455 E 11.3986
+BoundingBoxBottomRightWGS84: N 49.3455 E 11.3986
 MinScale:   2
 MaxScale:   16
 RecommendedScale:    3 7 10

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	0.000374177136322228
 MaxScale:	37.4180878093591
 RecommendedScale:	0.4

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/png
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	0.186714391024792
 MaxScale:	11.2256882668032
 RecommendedScale:	1.0

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/png
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	1.87051150447482
 MaxScale:	18.7092309932477
 RecommendedScale:	2.5

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/png
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	5.6122828676971
 MaxScale:	28.0636594013034
 RecommendedScale:	5.0

Modified: branches/r1.2/res_noewe/webmapservices/de-ni_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-ni_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-ni_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,43 +1,43 @@
-TakenFromUrl:       http://www.umwelt.niedersachsen.de/master/C7089178_N7088657_L20_D0_I598.html
+???TakenFromUrl:       http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer
 GetCapabilitiesUrl: http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
-Name:               de.Niedersachsen photo c SF=0..1,95
+Name:               de.Niedersachsen p
 MapType:                        photo
-#MainUrl:            http://www.umweltkarten.niedersachsen.de/arcgis/services/GR_Gebiete/MapServer/WMSServer?
 MainUrl:            http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
-CoordinateReferenceSystemCacheWolf:  31467
-CoordinateReferenceSystemUrlPart: SRS=EPSG:31467 
+CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
 RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=0|Gebiete mit gesamtstaatlicher repr?sentativer Bedeutung|2.772396|Infinity
-#LayersUrlPart:     LAYERS=1|Flie?gew?sserschutzsystem Verbindungsgew?sser|2.772396|Infinity
-#LayersUrlPart:     LAYERS=2|Flie?gew?sserschutzsystem Hauptgew?sser und Auen|2.772396|Infinity
-#LayersUrlPart:     LAYERS=3|Moorschutzprogramm Neubewertung|2,772396|Infinity
+#LayersUrlPart:     LAYERS=0|Gebiete mit gesamtstaatlicher repr??sentativer Bedeutung|2.772396|Infinity
+#LayersUrlPart:     LAYERS=1|Flie??gew??sserschutzsystem Verbindungsgew??sser|2.772396|Infinity
+#LayersUrlPart:     LAYERS=2|Flie??gew??sserschutzsystem Hauptgew??sser und Auen|2.772396|Infinity
+#LayersUrlPart:     LAYERS=3|Moorschutzprogramm Neubewertung|2.772396|Infinity
 #LayersUrlPart:     LAYERS=4|Moorschutzprogramm Teil II|2.772396|Infinity
 #LayersUrlPart:     LAYERS=5|Abgrenzung des Hochmoorkomplexes MSP Teil I|2.772396|Infinity
 #LayersUrlPart:     LAYERS=6|Moorschutzprogramm (MSP) Teil I|2.772396|Infinity
-#LayersUrlPart:     LAYERS=7|Untere  Naturschutzbeh?rden|2.772396|Infinity
-#LayersUrlPart:     LAYERS=8|Landkreise||
-#LayersUrlPart:     LAYERS=9|Ortslagen|99.000000|237.600000
-#LayersUrlPart:     LAYERS=10|Grosse Seen|198.000000|Infinity
-#LayersUrlPart:     LAYERS=11|Gro?e Fl?sse|198.000000|Infinity
-#LayersUrlPart:     LAYERS=12|Orthophoto Farbe|0.0|2.772000
-#LayersUrlPart:     LAYERS=13|DTK 25|2.772396|4.950000
-#LayersUrlPart:     LAYERS=14|TK 50|4.950396|9.900000
-#LayersUrlPart:     LAYERS=15|TK 100|9.900396|29.700000
-#LayersUrlPart:     LAYERS=16|TK 500|29.700396|99.000000
-#LayersUrlPart:     LAYERS=17|Autobahnen||
-#LayersUrlPart:     LAYERS=18|Schrift: Gro?e Orte||
-#LayersUrlPart:     LAYERS=19|Schrift: Kleine Orte||
-LayersUrlPart:     LAYERS=12
+#LayersUrlPart:     LAYERS=7|Untere  Naturschutzbeh??rden|2.772396|Infinity
+#LayersUrlPart:     LAYERS=8|Naturr??umliche Regionen und Unterregionen DTK50||
+#LayersUrlPart:     LAYERS=9|Naturr??umliche Regionen DTK50||
+#LayersUrlPart:     LAYERS=10|Landesgrenze inkl. 12 Seemeilen-Zone||
+#LayersUrlPart:     LAYERS=11|Landkreise||
+#LayersUrlPart:     LAYERS=12|Ortslagen|99.000000|237.600000
+#LayersUrlPart:     LAYERS=13|Grosse Seen|198.000000|Infinity
+#LayersUrlPart:     LAYERS=14|Gro??e Fl??sse|198.000000|Infinity
+#LayersUrlPart:     LAYERS=15|Orthophoto Farbe|0.0|2.772000
+#LayersUrlPart:     LAYERS=16|DTK 25|2.772396|4.950000
+#LayersUrlPart:     LAYERS=17|TK 50 |4.950396|9.900000
+#LayersUrlPart:     LAYERS=18|TK 100|9.900396|29.700000
+#LayersUrlPart:     LAYERS=19|DTK 500 |29.700396|99.000000
+#LayersUrlPart:     LAYERS=20|Autobahnen||
+#LayersUrlPart:     LAYERS=21|Schrift: Gro??e Orte||
+#LayersUrlPart:     LAYERS=22|Schrift: Kleine Orte||
+LayersUrlPart:     LAYERS=15
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
-BoundingBoxTopLeftWGS84: N 53.898485 E 6.600296
-BoundingBoxButtomRightWGS84: N 51.265165 E 11.665345
-MinScale:   0
-MaxScale:   2.772396
-RecommendedScale:   1
-#MinSFInput:0
-#MaxSFInput:1,9586
+BoundingBoxTopLeftWGS84: N 54.0098 E 6.4705
+BoundingBoxBottomRightWGS84: N 51.2325 E 11.6591
+#BBox_Mitte: N 52.6211685 E 9.0647625
+MinScale:   0.2
+MaxScale:   3
+RecommendedScale:    1
 ImageFileExtension: .jpg
-#weitere Overlays hinzuf?gen geht bei Photo nicht.
\ No newline at end of file

Added: branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,220 @@
+???TakenFromUrl:       http://www.geodaten.niedersachsen.de/
+GetCapabilitiesUrl: http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               de.Niedersachsen t50
+MapType:                        topo
+MainUrl:            http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=map_618|Kartenhintergrund||
+#LayersUrlPart:     LAYERS=map_2501|Kartenhintergrund (grau / transp.)||
+#LayersUrlPart:     LAYERS=layer_3603|Bundesl??ndergrenzen|4989.031178|0.000499
+#LayersUrlPart:     LAYERS=layer_3602|Kreisgrenzen Bund|748.354677|0.000499
+#LayersUrlPart:     LAYERS=layer_3601|Gemeindegrenzen Bund|249.451559|0.000499
+#LayersUrlPart:     LAYERS=layer_3701|??bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3702|??bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3703|??bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3704|??bersichtskarte 1:500000|296.052238|0.000000
+#LayersUrlPart:     LAYERS=layer_3705|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3707|Digit. Topogr. Karte 1:50000|29.605225|0.000000
+#LayersUrlPart:     LAYERS=layer_3708|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3709|Digit. Stra??enkarte 1:10000|5.921047|0.000000
+#LayersUrlPart:     LAYERS=layer_1445|Hausnummern|3.492322|0.000000
+#LayersUrlPart:     LAYERS=layer_3710|Amtliche Karte 1:5000|6.315779|0.000000
+#LayersUrlPart:     LAYERS=layer_3713|Digit. Orthophoto||
+#LayersUrlPart:     LAYERS=layer_3714|??bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3715|??bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3716|??bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3717|??bersichtskarte 1:500000|296.052240|0.000000
+#LayersUrlPart:     LAYERS=layer_3718|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3720|Digit. Topogr. Karte 1:50000|29.605224|0.000000
+#LayersUrlPart:     LAYERS=layer_3721|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3722|Digit. Stra??enkarte 1:10000|5.921045|0.000000
+#LayersUrlPart:     LAYERS=layer_3723|Amtliche Karte 1:5000|6.315781|0.000000
+#LayersUrlPart:     LAYERS=layer_3724|??bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3725|??bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3726|??bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3727|??bersichtskarte 1:500000|296.052240|0.000000
+#LayersUrlPart:     LAYERS=layer_3728|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3730|Digit. Topogr. Karte 1:50000|29.605224|0.000000
+#LayersUrlPart:     LAYERS=layer_3731|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3732|Digit. Stra??enkarte 1:10000|5.921045|0.000000
+#LayersUrlPart:     LAYERS=layer_3733|Amtliche Karte 1:5000|3.947363|0.000000
+#LayersUrlPart:     LAYERS=layer_1487|Geolog. ??bersichtskarte 1: 500000||
+#LayersUrlPart:     LAYERS=layer_1485|Geologische Karte 1:50000|132.582186|0.000000
+#LayersUrlPart:     LAYERS=layer_2102|Tiefenlage der Quart??rbasis 1:500000||
+#LayersUrlPart:     LAYERS=layer_1489|Hochwassergef??hrdg. 1:500000||
+#LayersUrlPart:     LAYERS=layer_1486|Hochwassergef??hrdg. 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1488|Urspr??ngliche Moorverbreitung||
+#LayersUrlPart:     LAYERS=layer_1490|Rohstoffsicherungskarte 1:25000||
+#LayersUrlPart:     LAYERS=layer_1494|Ingenieurgeolog. Karte 1:500000||
+#LayersUrlPart:     LAYERS=layer_1493|Ingenieurgeolog. Karte 1:50000|132.582186|0.000000
+#LayersUrlPart:     LAYERS=layer_1491|Bodenklassen??bersichtskarte von 0m bis 1m|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1492|Bodenklassen??bersichtskarte von 1m bis 2m (n. DIN 18300) 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1542|Bodengro??landschaften 1:500000||
+#LayersUrlPart:     LAYERS=layer_1535|Bodenversiegelung 1:500000||
+#LayersUrlPart:     LAYERS=layer_1533|Bodenlandschaften 1:200000||
+#LayersUrlPart:     LAYERS=layer_1541|Bodentypenkarte 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1537|Standortbezogenes ackerbaul. Ertragspotenzial 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1534|Standorteignung f??r die Beseitigung von Tierk??rpern bei Seuchenz??gen 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1538|Schutzw??rdige B??den 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1539|Bodensch??tzungskarte 1:25000|33.145547|0.000000
+#LayersUrlPart:     LAYERS=layer_1540|Forstliche Standortstypenkarte 1:25000|33.145547|0.000000
+#LayersUrlPart:     LAYERS=layer_1536|Histor. Landnutzung 1:25000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1902|Hydrogeolog. Einheiten 1:500000||
+#LayersUrlPart:     LAYERS=layer_1913|Hydrogeolog. R??ume u. Teilr??ume 1:500000||
+#LayersUrlPart:     LAYERS=layer_1907|Grundwasserleitertypen der oberfl??chennahen Gesteine 1:500000||
+#LayersUrlPart:     LAYERS=layer_1906|Durchl??ssigkeit der oberfl??chennahen Gesteine 1:500000||
+#LayersUrlPart:     LAYERS=layer_1903|Entnahmebedingungen in den Grundwasser f??hrenden Gesteinen 1:500000||
+#LayersUrlPart:     LAYERS=layer_1914|Grundwasserk??rper 1:500000||
+#LayersUrlPart:     LAYERS=layer_1904|Schutzpotenzial der Grundwasser??berdeckung 1:200000||
+#LayersUrlPart:     LAYERS=layer_1908|Versalzung des Grundwassers 1:200000||
+#LayersUrlPart:     LAYERS=layer_1915|Fliessrichtung im Festgestein||
+#LayersUrlPart:     LAYERS=map_802|Grundwasseroberfl??che 1:200000||
+#LayersUrlPart:     LAYERS=layer_1917|Tiefenstufe||
+#LayersUrlPart:     LAYERS=layer_1916|H??hengleichen u. Beschriftung||
+#LayersUrlPart:     LAYERS=map_803|Grundwasseroberfl??che 1:50000||
+#LayersUrlPart:     LAYERS=layer_1922|Tiefenstufe||
+#LayersUrlPart:     LAYERS=layer_1919|H??hengleichen|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1918|H??hengleichen (Beschriftung)|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1613|Erlaubnisse offshore||
+#LayersUrlPart:     LAYERS=layer_1609|Erlaubnisse onshore||
+#LayersUrlPart:     LAYERS=layer_1611|Bewilligungen offshore||
+#LayersUrlPart:     LAYERS=layer_1612|Bewilligungen onshore||
+#LayersUrlPart:     LAYERS=layer_1608|Bergwerksfelder||
+#LayersUrlPart:     LAYERS=layer_1610|Entenschnabel||
+#LayersUrlPart:     LAYERS=layer_1607|Nutzungsbed. oberfl??chennaher Geothermie||
+#LayersUrlPart:     LAYERS=layer_1606|Potenzielle Standorteignung f??r Erdw??rmekollektoren (Einbautiefe 1,2-1,5m) 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1468|Staatsgrenze (12sm-Grenze)||
+#LayersUrlPart:     LAYERS=layer_1469|Grenzpunkte||
+#LayersUrlPart:     LAYERS=layer_1471|Weitere Grenzen u. Linien||
+#LayersUrlPart:     LAYERS=layer_1470|Tiefwasserreede (Zust. NI)||
+#LayersUrlPart:     LAYERS=layer_1472|Grenze Binnenwasserstr.||
+#LayersUrlPart:     LAYERS=layer_1473|Bereich Emsm??ndung (8.4.1960)||
+#LayersUrlPart:     LAYERS=layer_1474|Grenzbereich Emsm??ndung||
+#LayersUrlPart:     LAYERS=layer_1475|Linie Zusatzabkommen||
+#LayersUrlPart:     LAYERS=layer_1476|Gebiet mit nds. Recht||
+#LayersUrlPart:     LAYERS=layer_1477|Wasserpolizeilicher Bereich|997.805697|0.498903
+#LayersUrlPart:     LAYERS=layer_1478|Wasserpolizeil. Grenzen zum K??stenmeer|1995.611394|0.498903
+#LayersUrlPart:     LAYERS=layer_1479|zust??ndige Bundesl??nder|299.341711|0.498903
+#LayersUrlPart:     LAYERS=layer_1480|Grenze Wasser- u. Schifffahrtsdirektionen Nordwest u. Nord||
+#LayersUrlPart:     LAYERS=layer_1481|Nationalpark Nds. Wattenmeer||
+#LayersUrlPart:     LAYERS=layer_3101|Landschaftsschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3102|Naturpark||
+#LayersUrlPart:     LAYERS=layer_3103|Biosph??renreservat||
+#LayersUrlPart:     LAYERS=layer_3104|Nationalpark||
+#LayersUrlPart:     LAYERS=layer_3105|Vogelschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3106|Fauna-Flora-Habitat - Gebiet||
+#LayersUrlPart:     LAYERS=layer_3107|Naturschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3108|Wasserschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_4111|Nationalpark (NLP)||
+#LayersUrlPart:     LAYERS=layer_4110|Biosph??renreservat (BSR)||
+#LayersUrlPart:     LAYERS=layer_4109|Naturschutzgebiet (NSG)||
+#LayersUrlPart:     LAYERS=layer_4108|Naturdenkmal (ND)||
+#LayersUrlPart:     LAYERS=layer_4107|ND in schmaler Laengsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4106|ND kleiner 1 ha||
+#LayersUrlPart:     LAYERS=layer_4105|Landschaftsschutzgebiet (LSG)||
+#LayersUrlPart:     LAYERS=layer_4104|LSG in schmaler L??ngsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4103|Gesch. Landschaftsbestandteil (GLB)||
+#LayersUrlPart:     LAYERS=layer_4102|GLB in schmaler L??ngsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4101|GLB kleiner 1 ha||
+#LayersUrlPart:     LAYERS=layer_3007|Gebietsname und -nummer||
+#LayersUrlPart:     LAYERS=layer_3008|H??chster Schutzzweck/zone||
+#LayersUrlPart:     LAYERS=layer_3009|Priorit??tenprogramm Trinkwasserschutz||
+#LayersUrlPart:     LAYERS=layer_3010|Zuwendungskulisse ELER||
+#LayersUrlPart:     LAYERS=layer_3011|Wasserrahmenrichtlinie: Gesch??tzte Gebiete||
+#LayersUrlPart:     LAYERS=layer_3013|Heilquellenschutzgebiete||
+#LayersUrlPart:     LAYERS=layer_3014|Trinkwasserschutzgebiete||
+#LayersUrlPart:     LAYERS=layer_3012|Trinkwassergewinnungsgeb.||
+#LayersUrlPart:     LAYERS=layer_3405|vorl??ufig gesicherte ??berschwemmungsgebiete||
+#LayersUrlPart:     LAYERS=layer_3401|??berschwemmungsgebiete im Verfahren (Bremen)||
+#LayersUrlPart:     LAYERS=layer_3402|Verordnungsfl??chen||
+#LayersUrlPart:     LAYERS=layer_3404|... geeignet ab 1: 50000|15.839605|0.000000
+#LayersUrlPart:     LAYERS=layer_3403|... geeignet ab 1: 10000|3.168000|0.000000
+#LayersUrlPart:     LAYERS=layer_1482|Feldbl??cke|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_1484|Feldblockinseln|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_1483|Landschaftselemente|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_4201|Potenzielle Wassererosion|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_4202|Potenzielle Winderosion|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1805|Amtsbezirke ??fL|1000000.000002|1.000001
+#LayersUrlPart:     LAYERS=layer_1806|Dorferneuerung|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1809|Neuvermessungsgebiete|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1807|Stand der Flurbereinigung|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1808|Flurbereinigungsgebiete|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_2301|LROP (Stand: 2008)|9899.495094|24.945141
+#LayersUrlPart:     LAYERS=layer_2501|ROKK 2005|548.793430|24.944657
+#LayersUrlPart:     LAYERS=layer_2603|Fl??chennutzungsplan|99.780624|0.049890
+#LayersUrlPart:     LAYERS=layer_2602|B-Plan (Umringe)|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2610|Kompensationsfl??chen|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2601|Liegenschaften|14.967094|0.049890
+#LayersUrlPart:     LAYERS=layer_2611|1: Landsch.-??kolog. Raumeinheiten|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2612|2: Wasser|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2613|3: Boden|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2614|4: Luft|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2615|5a: Arten u. Lebensgemeinschaften|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2616|5b: Schutzgebiete|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2617|6: Vielfalt, Eigenart, Sch??nheit|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2618|7: Belastungen, Gef??hrdungen|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2619|7a: Konflikte mit st??dtebaul. Entwicklung|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2620|8: Ma??nahmen und Entwicklung|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2621|Gew??sser 2. Ordnung|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2622|Gew??sser 3. Ordnung|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2606|Renaturierung der Else|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2201|B-Plan Hiddestorf||
+#LayersUrlPart:     LAYERS=map_1702|Regionale Gesch??ftsbereiche||
+#LayersUrlPart:     LAYERS=layer_2912|GB-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2913|GB-Standorte||
+#LayersUrlPart:     LAYERS=map_1703|Stra??enmeistereien||
+#LayersUrlPart:     LAYERS=layer_2910|SM-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2911|SM-Standorte||
+#LayersUrlPart:     LAYERS=map_1704|Autobahnmeistereien||
+#LayersUrlPart:     LAYERS=layer_2908|AM-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2909|AM-Standorte||
+#LayersUrlPart:     LAYERS=layer_2907|sonstige Dienstorte||
+#LayersUrlPart:     LAYERS=layer_1454|Autobahnen||
+#LayersUrlPart:     LAYERS=layer_1455|Bundesstra??en||
+#LayersUrlPart:     LAYERS=layer_1456|Landesstra??en||
+#LayersUrlPart:     LAYERS=layer_1457|Kreisstra??en||
+#LayersUrlPart:     LAYERS=layer_1458|Anschlussstellenbezeichnung|249.451559|0.000000
+#LayersUrlPart:     LAYERS=layer_1459|Anschlussstellennummer||
+#LayersUrlPart:     LAYERS=layer_1460|Netzknoten||
+#LayersUrlPart:     LAYERS=layer_1461|Nullpunkte||
+#LayersUrlPart:     LAYERS=layer_815|Z??hlstellen||
+#LayersUrlPart:     LAYERS=layer_812|Werte Kraftfahrzeuge||
+#LayersUrlPart:     LAYERS=layer_813|Werte G??terverkehr||
+#LayersUrlPart:     LAYERS=layer_814|Werte Schwerverkehr||
+#LayersUrlPart:     LAYERS=layer_809|Verkehrsmengen Autobahn||
+#LayersUrlPart:     LAYERS=layer_810|Verkehrsmengen Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_811|Verkehrsmengen Landesstr.||
+#LayersUrlPart:     LAYERS=layer_1448|Verkehrsmengen Autobahn||
+#LayersUrlPart:     LAYERS=layer_1449|Verkehrsmengen Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_1450|Verkehrsmengen Landesstr.||
+#LayersUrlPart:     LAYERS=layer_1451|DTV- / SV-Werte Autobahn||
+#LayersUrlPart:     LAYERS=layer_1452|DTV- / SV-Werte Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_1453|DTV- / SV-Werte Landesstr.||
+#LayersUrlPart:     LAYERS=layer_2402|Sonderflugh??fen||
+#LayersUrlPart:     LAYERS=layer_2403|Verkehrsflugh??fen||
+#LayersUrlPart:     LAYERS=layer_2404|Verkehrslandepl??tze||
+#LayersUrlPart:     LAYERS=layer_2405|Sonderlandepl??tze||
+#LayersUrlPart:     LAYERS=layer_2406|Segelfluggel??nde||
+#LayersUrlPart:     LAYERS=layer_802|Arch??ologie (Gro??steingr??ber)|126.713409|1.999998
+#LayersUrlPart:     LAYERS=layer_803|Arch??ologie (GeoLife)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_804|Arch??ologie (Wurten und Deiche)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_805|Bau- und Kunstdenkmalpflege (M??hlen)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_806|Bau- und Kunstdenkmalpflege (Kirchen)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_807|Bau- und Kunstdenkmalpflege (Worpswede)|15.839176|1.999998
+#LayersUrlPart:     LAYERS=layer_808|Bau- und Kunstdenkmalpflege (Herrenhausen)|15.839176|1.999998
+#LayersUrlPart:     LAYERS=layer_1428|Preu??. Landesaufn. 1:25000 (grau/transp.)|24.945141|0.000000
+#LayersUrlPart:     LAYERS=layer_1427|Preu??. Landesaufn. 1:25000 (schwarz/transp.)|24.945141|0.000000
+LayersUrlPart:     LAYERS=layer_3707
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 53.9771 E 6.4229
+BoundingBoxBottomRightWGS84: N 51.2089 E 11.7272
+#BBox_Mitte: N 52.5929772805 E 9.0750485755
+MinScale:   0
+MaxScale:   16
+RecommendedScale:    5 1 10
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,36 @@
+???TakenFromUrl:       http://www.lgln.niedersachsen.de?
+GetCapabilitiesUrl: http://www.geobasisdaten.niedersachsen.de/bestand?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               de.Niedersachsen t25
+MapType:                        topo
+MainUrl:            http://www.geobasisdaten.niedersachsen.de/bestand?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=bestand|LGLN-Bestand||
+#LayersUrlPart:     LAYERS=rasterdaten|??bersichtskarten||
+#LayersUrlPart:     LAYERS=ueb5000_gd|UKN 5.000|633.499852296075|9899.49490168847
+#LayersUrlPart:     LAYERS=ukn2500_gd|UKN 2.500|296.999859087254|633.499852296075
+#LayersUrlPart:     LAYERS=ueb1000_gd|UKN 1.000|126.713500006|296.999859087254
+#LayersUrlPart:     LAYERS=ukn500_gd|UKN 500|44.901280999479|126.713500006
+#LayersUrlPart:     LAYERS=dtk100_v_gd|TK 100|0|44.901280999479
+#LayersUrlPart:     LAYERS=dtk100_v_b|Topographischen Karte 1:100.000||
+#LayersUrlPart:     LAYERS=dtk50_b|Topographischen Karte 1:50.000||
+#LayersUrlPart:     LAYERS=dtk25_b|Topographischen Karte 1:25.000||
+#LayersUrlPart:     LAYERS=pl25_b|Preu??ischen Landesaufnahme 1:25.000||
+#LayersUrlPart:     LAYERS=dsk10_b|Digitalen Stra??enkarte 1:10.000||
+#LayersUrlPart:     LAYERS=dgk5g_b|Deutsche Grundkarte 1:5.000||
+#LayersUrlPart:     LAYERS=ak5_b|Amtlichen Karte 1:5.000||
+#LayersUrlPart:     LAYERS=dop_b|Digitales Orthophoto||
+#LayersUrlPart:     LAYERS=landkreise_umringe|Landkreisgrenzen|0|9899.49490168847
+#LayersUrlPart:     LAYERS=gemeinden_umringe|Gemeindegrenzen|0|126.713500006
+LayersUrlPart:     LAYERS=rasterdaten
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 54.5532 E 5.8980
+BoundingBoxBottomRightWGS84: N 50.6527 E 12.6222
+MinScale:   2
+MaxScale:   60
+RecommendedScale:    2.5 1 5 7.5
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 52.5391 E 5.7591
-BoundingBoxButtomRightWGS84: N 50.3040 E 9.4718
+BoundingBoxBottomRightWGS84: N 50.3040 E 9.4718
 #BBox_Mitte: N 51.421555 E 7.6154425
 MinScale:   0
 MaxScale:   1000

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 52.6020 E 5.7250
-BoundingBoxButtomRightWGS84: N 50.1506 E 9.5315
+BoundingBoxBottomRightWGS84: N 50.1506 E 9.5315
 #BBox_Mitte: N 51.3763 E 7.628265
 MinScale:   0
 MaxScale:   1000

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 52.5850 E 5.7043
-BoundingBoxButtomRightWGS84: N 50.2178 E 9.5219
+BoundingBoxBottomRightWGS84: N 50.2178 E 9.5219
 #BBox_Mitte: N 51.4014 E 7.61312
 MinScale:   0.5
 MaxScale:   18

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 52.5850 E 5.7043
-BoundingBoxButtomRightWGS84: N 50.2178 E 9.5219
+BoundingBoxBottomRightWGS84: N 50.2178 E 9.5219
 #BBox_Mitte: N 51.4014 E 7.61312
 MinScale:   2
 MaxScale:   36

Modified: branches/r1.2/res_noewe/webmapservices/de-rp_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-rp_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-rp_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 51.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 48.8000 E 8.7000
+BoundingBoxBottomRightWGS84: N 48.8000 E 8.7000
 MinScale:   0.5
 MaxScale:   24.95
 RecommendedScale:	0.4

Modified: branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 48.8000 E 8.7000
+BoundingBoxBottomRightWGS84: N 48.8000 E 8.7000
 MinScale:   1
 MaxScale:   50
 RecommendedScale:   2,5

Modified: branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 48.8000 E 8.7000
+BoundingBoxBottomRightWGS84: N 48.8000 E 8.7000
 MinScale:   1
 MaxScale:   50
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/de-sh_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sh_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-sh_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -121,7 +121,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 55.08 E 8.156
-BoundingBoxButtomRightWGS84: N 53.34 E 11.33
+BoundingBoxBottomRightWGS84: N 53.34 E 11.33
 MinScale:   0
 MaxScale:   150
 RecommendedScale:    1 2.5 5 10 16

Added: branches/r1.2/res_noewe/webmapservices/de-sl-t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sl-t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-sl-t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,38 @@
+TakenFromUrl:       http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?
+GetCapabilitiesUrl: http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               de.Saarland t
+MapType:                        topo
+MainUrl:            http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31466 31467
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=Saarland|SL_UEBERSICHT||
+#LayersUrlPart:     LAYERS=landesflaeche|Landesflaeche||
+#LayersUrlPart:     LAYERS=gruenland|Gruenland||
+#LayersUrlPart:     LAYERS=industrie|Industrie||
+#LayersUrlPart:     LAYERS=wald|Wald||
+#LayersUrlPart:     LAYERS=sonderkultur|Sonderkulturen||
+#LayersUrlPart:     LAYERS=ortslagen|Ortslagen||
+#LayersUrlPart:     LAYERS=gewaesser|Gewaesser||
+#LayersUrlPart:     LAYERS=weg|Wege||
+#LayersUrlPart:     LAYERS=strasse|Strassen||
+#LayersUrlPart:     LAYERS=gemeindestrasse|Gemeindestrassen||
+#LayersUrlPart:     LAYERS=kreisstrasse|Kreisstrassen||
+#LayersUrlPart:     LAYERS=landesstrasse|Landesstrassen||
+#LayersUrlPart:     LAYERS=bundesstrasse|Bundesstrassen||
+#LayersUrlPart:     LAYERS=autobahn|Autobahnen||
+#LayersUrlPart:     LAYERS=bahn|Bahn||
+#LayersUrlPart:     LAYERS=orte|Orte||
+#LayersUrlPart: LAYERS=Saarland,landesflaeche,gruenland,industrie,wald,sonderkultur,ortslagen,gewaesser,weg,strasse,gemeindestrasse,kreisstrasse,landesstrasse,bundesstrasse,autobahn,bahn,orte
+LayersUrlPart:		LAYERS=Saarland
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 49.6445 E 6.3553
+BoundingBoxBottomRightWGS84: N 49.1094 E 7.4138
+#BBox_Mitte: N 49.37695 E 6.88454
+MinScale:   0.2
+MaxScale:   200
+RecommendedScale:    9 2
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-sn_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sn_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-sn_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -15,7 +15,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84: N 50.0294 E 15.1358
+BoundingBoxBottomRightWGS84: N 50.0294 E 15.1358
 #BBox_Mitte: N 50.9443 E 13.45045
 MinScale:   0.2
 MaxScale:   10

Modified: branches/r1.2/res_noewe/webmapservices/de-sn_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sn_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-sn_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84: N 50.0294 E 15.1358
+BoundingBoxBottomRightWGS84: N 50.0294 E 15.1358
 #BBox_Mitte: N 50.9443 E 13.45045
 MinScale:   0.5
 MaxScale:   70

Modified: branches/r1.2/res_noewe/webmapservices/de-st_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-st_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-st_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -75,7 +75,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 53.2226 E 10.5012
-BoundingBoxButtomRightWGS84: N 50.5272 E 13.4957
+BoundingBoxBottomRightWGS84: N 50.5272 E 13.4957
 #BBox_Mitte: N 51.874924375 E 11.9984684985
 MinScale:   0
 MaxScale:   25

Modified: branches/r1.2/res_noewe/webmapservices/de-st_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-st_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-st_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -75,7 +75,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.2226 E 10.5012
-BoundingBoxButtomRightWGS84: N 50.5272 E 13.4957
+BoundingBoxBottomRightWGS84: N 50.5272 E 13.4957
 #BBox_Mitte: N 51.874924375 E 11.9984684985
 MinScale:   0
 MaxScale:   12

Modified: branches/r1.2/res_noewe/webmapservices/de-st_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-st_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-st_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -75,7 +75,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.2226 E 10.5012
-BoundingBoxButtomRightWGS84: N 50.5272 E 13.4957
+BoundingBoxBottomRightWGS84: N 50.5272 E 13.4957
 #BBox_Mitte: N 51.874924375 E 11.9984684985
 MinScale:   5
 MaxScale:   90

Modified: branches/r1.2/res_noewe/webmapservices/de-th_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-th_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-th_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -349,7 +349,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.7 E 10.3
-BoundingBoxButtomRightWGS84: N 50.1 E 12.7
+BoundingBoxBottomRightWGS84: N 50.1 E 12.7
 MinScale:   1
 MaxScale:   12
 RecommendedScale:   2,5

Added: branches/r1.2/res_noewe/webmapservices/de_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de_t25.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,19 @@
+TakenFromUrl:       map.adfc-tourenportal.de = 195.66.99.21
+GetCapabilitiesUrl: doesn't work
+Name:               ADFC Tourenportal t25
+MapType:                        topo
+MainUrl:            http://195.66.99.21/mm-mapserver_v2/wms/wms.php?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
+RequestUrlPart:     REQUEST=GetMap
+LayersUrlPart:     LAYERS=MM_TOPO
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/gif
+BoundingBoxTopLeftWGS84: N 55.7319 E 4.6186
+BoundingBoxBottomRightWGS84: N 45.9690 E 16.7118
+MinScale:   3.5
+MaxScale:   3.6
+RecommendedScale:    2.5
+ImageFileExtension: .gif

Modified: branches/r1.2/res_noewe/webmapservices/de_t2500.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de_t2500.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de_t2500.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,8 +13,8 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 55.7319 E 4.6186
-BoundingBoxButtomRightWGS84: N 45.9690 E 16.7118
+BoundingBoxBottomRightWGS84: N 45.9690 E 16.7118
 MinScale:   50
-MaxScale:   350
-RecommendedScale:    150
+MaxScale:   400
+RecommendedScale:    250 100 200 300
 ImageFileExtension: .png

Added: branches/r1.2/res_noewe/webmapservices/de_t_itc.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de_t_itc.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de_t_itc.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,34 @@
+???TakenFromUrl:       http://osmwms.itc-halle.de/maps/osmfree?SERVICE=WMS&
+GetCapabilitiesUrl: http://osmwms.itc-halle.de/maps/osmfree?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               de OSM(ITC Halle)  t
+MapType:                        topo
+MainUrl:            http://osmwms.itc-halle.de/maps/osmfree?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=osmwms|OpenStreetMap-WMS||
+#LayersUrlPart:     LAYERS=grenzen|Administrative Grenzen||
+#LayersUrlPart:     LAYERS=flaechen|Fl??chen (M 1:5000)||
+#LayersUrlPart:     LAYERS=gebaeude|Geb??udefl??chen (M1:50000)||
+#LayersUrlPart:     LAYERS=wasser|Wasserstrassen (M 1:100000000)||
+#LayersUrlPart:     LAYERS=schienen|Bahn (M 1:10000000)||
+#LayersUrlPart:     LAYERS=strassen|Strassen und Wege (M 1:100000000)||
+#LayersUrlPart:     LAYERS=Wanderwege|Wanderwege (M 1:100000000)|0|49890.2848429637
+#LayersUrlPart:     LAYERS=Radwanderwege|Radwanderwege_50000 (M 1:100000000)|0|49890.2848429637
+#LayersUrlPart:     LAYERS=power|Stromleitungen (M 1:100000)||
+#LayersUrlPart:     LAYERS=Funkmasten|Funkmasten||
+#LayersUrlPart:     LAYERS=Atomkraftwerke|Atomkraftwerke||
+#LayersUrlPart:     LAYERS=punkte|Punkte (M 1:20000)||
+#LayersUrlPart:     LAYERS=orte|Ortsnamen (M 1:100000000)||
+LayersUrlPart:     LAYERS=grenzen,flaechen,gebaeude,wasser,schienen,strassen,Wanderwege,Radwanderwege,orte
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 81.8600 W 31.2600
+BoundingBoxBottomRightWGS84: N 34.8100 E 69.0700
+#BBox_Mitte: N 58.335 E 18.905
+MinScale:   0.1
+MaxScale:   180
+RecommendedScale:   5 1 2.5 10 15 30 60
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,46 @@
+???TakenFromUrl:       http://kortforsyningen.kms.dk/orto_foraar?
+GetCapabilitiesUrl: http://kortforsyningen.kms.dk/service?servicename=orto_foraar&&login=kfmonitor&password=kfmonitor&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               dk p
+MapType:                        photo
+MainUrl:            http://kortforsyningen.kms.dk/service?servicename=orto_foraar&&login=kfmonitor&password=kfmonitor&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=orto_foraar|Ortofoto for??r||
+#LayersUrlPart:     LAYERS=jylland2004_40cm|jylland2004_40cm||
+#LayersUrlPart:     LAYERS=fyn2005_40cm|fyn2005_40cm||
+#LayersUrlPart:     LAYERS=jylland2005_40cm|jylland2005_40cm||
+#LayersUrlPart:     LAYERS=jylland2006_40cm|jylland2006_40cm||
+#LayersUrlPart:     LAYERS=sjaelland2006_40cm|sjaelland2006_40cm||
+#LayersUrlPart:     LAYERS=sjaelland2006_10cm|sjaelland2006_10cm||
+#LayersUrlPart:     LAYERS=bornholm2006_40cm|bornholm2006_40cm||
+#LayersUrlPart:     LAYERS=jylland2007_20cm|jylland2007_20cm||
+#LayersUrlPart:     LAYERS=jylland2007_10cm|jylland2007_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2007_10cm|sjaelland2007_10cm||
+#LayersUrlPart:     LAYERS=jylland2008_20cm|jylland2008_20cm||
+#LayersUrlPart:     LAYERS=jylland2008_10cm|jylland2008_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2008_10cm|sjaelland2008_10cm||
+#LayersUrlPart:     LAYERS=jylland2009_20cm|jylland2009_20cm||
+#LayersUrlPart:     LAYERS=jylland2009_10cm|jylland2009_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2009_20cm|sjaelland2009_20cm||
+#LayersUrlPart:     LAYERS=sjaelland2009_10cm|sjaelland2009_10cm||
+#LayersUrlPart:     LAYERS=bornholm2010_hrks10cm|bornholm2010_hrks10cm||
+#LayersUrlPart:     LAYERS=fyn2010_20cm|fyn2010_20cm||
+#LayersUrlPart:     LAYERS=fyn2010_10cm|fyn2010_10cm||
+#LayersUrlPart:     LAYERS=jylland2010_20cm|jylland2010_20cm||
+#LayersUrlPart:     LAYERS=jylland2010_10cm|jylland2010_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2010_20cm|sjaelland2010_20cm||
+#LayersUrlPart:     LAYERS=sjaelland2010_10cm|sjaelland2010_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2010_hrks10cm|sjaelland2010_hrks10cm||
+LayersUrlPart:     LAYERS=orto_foraar
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   0
+MaxScale:   25
+RecommendedScale:    1 4 8
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,21 @@
+???TakenFromUrl:       http://kortforsyningen.kms.dk/topo_skaermkort?
+GetCapabilitiesUrl: http://kortforsyningen.kms.dk/service?servicename=topo_skaermkort&login=kfmonitor&password=kfmonitor&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               dk topo
+MapType:                        topo
+MainUrl:            http://kortforsyningen.kms.dk/service?servicename=topo_skaermkort&login=kfmonitor&password=kfmonitor&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=dtk_skaermkort|DTK/Sk??rmkort||
+LayersUrlPart:     LAYERS=dtk_skaermkort
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   0
+MaxScale:   20
+RecommendedScale:    4 1
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_t25.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+???TakenFromUrl:       http://kortforsyningen.kms.dk/topo25?
+GetCapabilitiesUrl: http://kortforsyningen.kms.dk/service?servicename=topo25&login=kfmonitor&password=kfmonitor&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               dk t25
+MapType:                        topo
+MainUrl:            http://kortforsyningen.kms.dk/service?servicename=topo25&login=kfmonitor&password=kfmonitor&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=topo25_graa_2008|DTK/kort25 gr?? 2008||
+#LayersUrlPart:     LAYERS=topo25_daempet_2008|DTK/kort25 d??mpet 2008||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2008|DTK/kort25 klassisk 2008||
+#LayersUrlPart:     LAYERS=topo25_graa_2007|DTK/kort25 gr?? 2007||
+#LayersUrlPart:     LAYERS=topo25_daempet_2007|DTK/kort25 d??mpet 2007||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2007|DTK/kort25 klassisk 2007||
+#LayersUrlPart:     LAYERS=topo25_graa_2006|DTK/kort25 gr?? 2006||
+#LayersUrlPart:     LAYERS=topo25_daempet_2006|DTK/kort25 d??mpet 2006||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2006|DTK/kort25 klassisk 2006||
+#LayersUrlPart:     LAYERS=topo25_graa_2005|DTK/kort25 gr?? 2005||
+#LayersUrlPart:     LAYERS=topo25_daempet_2005|DTK/kort25 d??mpet 2005||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2005|DTK/kort25 klassisk 2005||
+#LayersUrlPart:     LAYERS=topo25_graa_2004|DTK/kort25 gr?? 2004||
+#LayersUrlPart:     LAYERS=topo25_daempet_2004|DTK/kort25 d??mpet 2004||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2004|DTK/kort25 klassisk 2004||
+#LayersUrlPart:     LAYERS=topo25_daempet_2002|DTK/kort25 d??mpet 2002||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2002|DTK/kort25 klassisk 2002||
+#LayersUrlPart:     LAYERS=topo25_graa|DTK/kort25 gr??||
+#LayersUrlPart:     LAYERS=topo25_daempet|DTK/kort25 d??mpet||
+#LayersUrlPart:     LAYERS=topo25_klassisk|DTK/kort25 klassisk||
+LayersUrlPart:     LAYERS=topo25_klassisk
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   1
+MaxScale:   20
+RecommendedScale:    2.5 5
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_t50.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,26 @@
+TakenFromUrl:       http://kortforsyningen.kms.dk/topo50?
+GetCapabilitiesUrl: http://kortforsyningen.kms.dk/service?servicename=topo50&login=kfmonitor&password=kfmonitor&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               dk t50
+MapType:                        topo
+MainUrl:            http://kortforsyningen.kms.dk/service?servicename=topo50&login=kfmonitor&password=kfmonitor&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=dtk_2cm_2007|DTK/kort50 2007|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2006|DTK/kort50 2006|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2005|DTK/kort50 2005|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2004|DTK/kort50 2004|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2002|DTK/kort50 2002|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm|DTK/kort50|0.000000|0.000000
+LayersUrlPart:     LAYERS=dtk_2cm
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   1
+MaxScale:   20
+RecommendedScale:    5 4 6
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/es-an_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-an_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-an_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 38.748  W 7.587
-BoundingBoxButtomRightWGS84:   N 35.947 W 1.602
+BoundingBoxBottomRightWGS84:   N 35.947 W 1.602
 MinScale:   0
 MaxScale:   49.8902848429637
 RecommendedScale:   1.000

Modified: branches/r1.2/res_noewe/webmapservices/es-an_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-an_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-an_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 38.748  W 7.587
-BoundingBoxButtomRightWGS84:   N 35.947 W 1.602
+BoundingBoxBottomRightWGS84:   N 35.947 W 1.602
 MinScale:   0
 MaxScale:   49.8902848429637
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es-an_t1.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-an_t1.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-an_t1.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 38.748  W 7.587
-BoundingBoxButtomRightWGS84:   N 35.947 W 1.602
+BoundingBoxBottomRightWGS84:   N 35.947 W 1.602
 MinScale:   0
 MaxScale:   49.8902848429637
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es-ar_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-ar_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-ar_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -27,7 +27,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 42.945  W 2.19
-BoundingBoxButtomRightWGS84:   N 39.813 E 0.805
+BoundingBoxBottomRightWGS84:   N 39.813 E 0.805
 MinScale:   0
 MaxScale:   72
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/es-ar_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-ar_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-ar_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -27,7 +27,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 42.945  W 2.19
-BoundingBoxButtomRightWGS84:   N 39.813 E 0.805
+BoundingBoxBottomRightWGS84:   N 39.813 E 0.805
 MinScale:   0
 MaxScale:   72
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/es-cn_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-cn_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-cn_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 29.8305 W 18.3099
-BoundingBoxButtomRightWGS84: N 26.1839 W 13.1373
+BoundingBoxBottomRightWGS84: N 26.1839 W 13.1373
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/es-cn_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-cn_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-cn_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 29.8305 W 18.3099
-BoundingBoxButtomRightWGS84:   N 26.1839 W 13.137
+BoundingBoxBottomRightWGS84:   N 26.1839 W 13.137
 MinScale:   1.49671
 MaxScale:   174.0000
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 29.8305 W 18.3099
-BoundingBoxButtomRightWGS84:   N 26.1839 W 13.137
+BoundingBoxBottomRightWGS84:   N 26.1839 W 13.137
 MinScale:   0
 MaxScale:   2500.0000
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -15,7 +15,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 45.2863 W 18.1621
-BoundingBoxButtomRightWGS84: N 21.8992 E 6.2893
+BoundingBoxBottomRightWGS84: N 21.8992 E 6.2893
 MinScale:   0
 MaxScale:   10
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/es_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 44.3814 W 18.3276
-BoundingBoxButtomRightWGS84: N 27.0611 E 6.6826
+BoundingBoxBottomRightWGS84: N 27.0611 E 6.6826
 MinScale:   2
 MaxScale:   80
 RecommendedScale:    2.5 5 15 30 

Modified: branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -59,7 +59,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 74.1000 W 10.4000
-BoundingBoxButtomRightWGS84: N 35.7000 E 43.0000
+BoundingBoxBottomRightWGS84: N 35.7000 E 43.0000
 #BBox_Mitte: N 54.9 E 16.3
 MinScale: 0.6
 MaxScale: 99.99

Added: branches/r1.2/res_noewe/webmapservices/fr_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/fr_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/fr_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,90 @@
+???TakenFromUrl:       http://mapdmz.brgm.fr/cgi-bin/mapserv?map=/carto/infoterre/mapFiles/geocat_metr.map&
+GetCapabilitiesUrl: http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               fr + (Guadeloupe..Polynesie) t
+MapType:                        topo
+MainUrl:            http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=METROPOLE|Fonds Geosignal|1.24725712107409|0
+#LayersUrlPart:     LAYERS=raster_geosignal|raster_geosignal||
+#LayersUrlPart:     LAYERS=WORLD_COUNTRIES_FR|Limites du monde|1496.70854528891|0
+#LayersUrlPart:     LAYERS=HydroSurf|Hydrographie surfacique - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=HydroLigne|Hydrographie lineaire - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=Routes|Reseau routier - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=fer|Reseau ferre - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=Communes|Communes - France metropolitaine|0|37.4182125350712
+
+#LayersUrlPart:     LAYERS=RASTER4000k|Raster Metropole 1/4 000 000|997.805696859274|4989.02848429637
+#LayersUrlPart:     LAYERS=RASTER1000k|Raster Metropole 1/1 000 000|374.177136322228|997.805696859274
+#LayersUrlPart:     LAYERS=RASTER500k_01|Raster Metropole 1/500 000|199.561139371855|374.177136322228
+#LayersUrlPart:     LAYERS=RASTER250k_01|Raster Metropole 1/250 000|99.7805696859274|199.561139371855
+#LayersUrlPart:     LAYERS=RASTER175k|Raster Metropole 1/175 000|62.3628560537046|99.7805696859274
+#LayersUrlPart:     LAYERS=RASTER100k_01|Raster Metropole 1/100 000|37.4177136322228|62.3628560537046
+#LayersUrlPart:     LAYERS=RASTER50k_01|Raster Metropole 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_01|Raster Metropole 1/25 000|6.23628560537046|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER10k|Raster Metropole 1/10 000|3.74177136322228|6.23628560537046
+#LayersUrlPart:     LAYERS=RASTER5k_01|Raster Metropole 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_02|Raster Guadeloupe 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_02|Raster Guadeloupe 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_02|Raster Guadeloupe 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_02|Raster Guadeloupe 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_02|Raster Guadeloupe 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_01|Raster Guadeloupe 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_02|Raster Guadeloupe 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_03|Raster Guyane 1/500 000|174.615996950373|4989.02848429637
+#LayersUrlPart:     LAYERS=RASTER250k_03|Raster Guyane 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_03|Raster Guyane 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_03|Raster Guyane 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_03|Raster Guyane 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_02|Raster Guyane 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_03|Raster Guyane 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_04|Raster Martinique 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_04|Raster Martinique 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_04|Raster Martinique 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_04|Raster Martinique 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_04|Raster Martinique 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_03|Raster Martinique 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_04|Raster Martinique 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_05|Raster La Reunion 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_05|Raster La Reunion 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_05|Raster La Reunion 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_05|Raster La Reunion 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_05|Raster La Reunion 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_04|Raster La Reunion 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_05|Raster La Reunion 1/5 000|0|7.48354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_06|Raster Mayotte 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_06|Raster Mayotte 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_06|Raster Mayotte 1/100 000|0|74.8354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_07|Raster caledonie 1/500 000|174.615996950373|1496.70854528891
+#LayersUrlPart:     LAYERS=RASTER250k_07|Raster caledonie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_07|Raster caledonie 1/100 000|0|74.8354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_08|Raster Polynesie 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_08|Raster Polynesie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_08|Raster Polynesie 1/100 000|0|1496.70854528891
+#LayersUrlPart:     LAYERS=RASTER500k_09|Raster Polynesie 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_09|Raster Polynesie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_09|Raster Polynesie 1/100 000|0|1496.70854528891
+
+#LayersUrlPart:     LAYERS=RASTER500k_10|Raster Saint-Pierre et Miquelon 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_10|Raster Saint-Pierre et Miquelon 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_10|Raster Saint-Pierre et Miquelon 1/100 000|0|74.8354272644456
+LayersUrlPart:     LAYERS=raster_geosignal
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+#BoundingBoxTopLeftWGS84: N 51.1007 W 5.8482
+#BoundingBoxBottomRightWGS84: N 41.1326 E 11.1984
+#BBox_Mitte: N 46.11665 E 2.67511
+MinScale:   0
+MaxScale:   100
+RecommendedScale:   1 5
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #HU Gyor-Moson-Sopron
 BoundingBoxTopLeftWGS84: N 48.027490 E 16.421143
-BoundingBoxButtomRightWGS84: N 47.392132 E 17.953978
+BoundingBoxBottomRightWGS84: N 47.392132 E 17.953978
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #HU Vas
 BoundingBoxTopLeftWGS84: N 47.46660 E 16.11368
-BoundingBoxButtomRightWGS84: N 46.72205 E 17.33420
+BoundingBoxBottomRightWGS84: N 46.72205 E 17.33420
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Added: branches/r1.2/res_noewe/webmapservices/it-25_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-25_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/it-25_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,22 @@
+TakenFromUrl:       http://10.220.56.127/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer
+GetCapabilitiesUrl: http://www.cartografia.regione.lombardia.it/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               it.lombardia p
+MapType:                        photo
+MainUrl:            http://www.cartografia.regione.lombardia.it/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=0|lombardia2007wgs84.ecw||
+#LayersUrlPart:     LAYERS=1|Province||
+LayersUrlPart:     LAYERS=0
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/png
+BoundingBoxTopLeftWGS84: N 46.7475 E 8.2398
+BoundingBoxBottomRightWGS84: N 44.5181 E 11.7416
+#BBox_Mitte: N 45.632761 E 9.990684
+MinScale:   0.3453
+MaxScale:   2.7621
+RecommendedScale:    1
+ImageFileExtension: .png

Modified: branches/r1.2/res_noewe/webmapservices/it-52_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-52_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-52_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -284,7 +284,7 @@
 StylesUrlPart:   STYLES=Default,Default,Default,Default,Default,Default,Default,Default
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 44.500805 E 9.642548
-BoundingBoxButtomRightWGS84:   N 42.168745 E 12.462359
+BoundingBoxBottomRightWGS84:   N 42.168745 E 12.462359
 MinScale:   0
 MaxScale:   70
 # maxscale 14.14214

Modified: branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -283,7 +283,7 @@
 StylesUrlPart:   STYLES=Default,Default,Default,Default,Default,Default,Default,Default
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 44.500805 E 9.642548
-BoundingBoxButtomRightWGS84:   N 42.168745 E 12.462359
+BoundingBoxBottomRightWGS84:   N 42.168745 E 12.462359
 MinScale:   0
 MaxScale:   71
 #Scale 2 and 3 are scaled versions of scale 1. Scale 5 and 6 are scaled versions of scale 4

Modified: branches/r1.2/res_noewe/webmapservices/it-88_m.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-88_m.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-88_m.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -12,7 +12,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 41.400307 E 7.964019
-BoundingBoxButtomRightWGS84:   N 38.792131 E 10.022418
+BoundingBoxBottomRightWGS84:   N 38.792131 E 10.022418
 MinScale:   1
 MaxScale:   3
 #RecommendedScale:   1.000 sonst kann man die Topodaten nicht lesen bzw es werden keine Fotos geladen

Modified: branches/r1.2/res_noewe/webmapservices/it-88_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-88_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-88_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,26 @@
-TakenFromUrl:   http://wiki.gfoss.it/index.php/GIS_Open_Data#Italia
-GetCapabilitiesUrl:   http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?request=getcapabilities&service=WMS&version=1.1.1
-Name:   it.Sardinien photo
-MapType:   photo
-MainUrl:   http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?
-ServiceTypeUrlPart:   SERVICE=WMS
-VersionUrlPart:   VERSION=1.1.1
+TakenFromUrl:       http://webgis.regione.sardegna.it:80/wmsconnector/com.esri.wms.Esrimap/ras_wms?
+GetCapabilitiesUrl: http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               it.sardegna p
+MapType:                        photo
+MainUrl:            http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:   REQUEST=GetMap
-LayersUrlPart:   LAYERS=ortofoto_it_2006
-StylesUrlPart:   STYLES=
-ImageFormatUrlPart:   FORMAT=image/png
-BoundingBoxTopLeftWGS84:   N 41.400307 E 7.964019
-BoundingBoxButtomRightWGS84:   N 38.792131 E 10.022418
-MinScale:   4
-MaxScale:   6
-# RecommendedScale:   1.000
-RecommendedScale:   4
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=ortofoto_it_2000|Ortofoto IT2000||
+#LayersUrlPart:     LAYERS=ortofoto_it_2006|Ortofoto IT2006||
+#LayersUrlPart:     LAYERS=Carta fisica|Carta fisica||
+#LayersUrlPart:     LAYERS=CTR10K raster|CTR10K raster||
+#LayersUrlPart:     LAYERS=IKONOS_RGB_Mosaico_Sardegna|IKONOS Mosaico RGB||
+#LayersUrlPart:     LAYERS=orto2k_totale|Ortofoto 2K||
+LayersUrlPart:     LAYERS=ortofoto_it_2006
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/png
+BoundingBoxTopLeftWGS84: N 41.4003 E 7.9640
+BoundingBoxBottomRightWGS84: N 38.7921 E 10.0224
+#BBox_Mitte: N 40.0962197844 E 8.99321880565
+MinScale:   0.3453
+MaxScale:   2.7621
+RecommendedScale:    1 0.5 1.5
 ImageFileExtension: .png

Modified: branches/r1.2/res_noewe/webmapservices/it-88_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-88_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-88_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -22,7 +22,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 41.400307 E 7.964019
-BoundingBoxButtomRightWGS84:   N 38.792131 E 10.022418
+BoundingBoxBottomRightWGS84:   N 38.792131 E 10.022418
 MinScale:   1
 MaxScale:   3
 #RecommendedScale:   1 - 2.000 bei gr?sserer Skalierung wird es un?bersichtlich

Modified: branches/r1.2/res_noewe/webmapservices/it_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -16,7 +16,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 48.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 36.0000 E 19.0000
+BoundingBoxBottomRightWGS84: N 36.0000 E 19.0000
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/it_t100.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it_t100.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it_t100.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -16,7 +16,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 48.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 36.0000 E 19.0000
+BoundingBoxBottomRightWGS84: N 36.0000 E 19.0000
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   10

Modified: branches/r1.2/res_noewe/webmapservices/it_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -19,9 +19,9 @@
 # .jpg appears white in sun-vm --> use .gif, that works on both VMs 
 ImageFormatUrlPart:FORMAT=image/gif
 BoundingBoxTopLeftWGS84: N 48.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 36.0000 E 19.0000
+BoundingBoxBottomRightWGS84: N 36.0000 E 19.0000
 # min and maxScale found by testing the server (pfeffer 1-10-2009)
-MinScale:   0
-MaxScale:   6.6
-RecommendedScale:   2.5
+MinScale:   1
+MaxScale:   25
+RecommendedScale:   2.5 5 8
 ImageFileExtension: .gif

Modified: branches/r1.2/res_noewe/webmapservices/jp-t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/jp-t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/jp-t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -30,7 +30,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 45.576199 E 122.521907
-BoundingBoxButtomRightWGS84: N 20.424949 E 145.888782
+BoundingBoxBottomRightWGS84: N 20.424949 E 145.888782
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/no-no_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/no-no_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/no-no_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -165,7 +165,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 71.8912 W 2.5599
-BoundingBoxButtomRightWGS84: N 57.0881 E 33.0199
+BoundingBoxBottomRightWGS84: N 57.0881 E 33.0199
 #BBox_Mitte: N 64.48965 E 15.229995
 MinScale:   0
 MaxScale:   1000

Modified: branches/r1.2/res_noewe/webmapservices/pl_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/pl_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/pl_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 54.8793 E 10.0579
-BoundingBoxButtomRightWGS84: N 48.3726 E 28.4862
+BoundingBoxBottomRightWGS84: N 48.3726 E 28.4862
 #BBox_Center: N 51.6259298143288 E 19.2720480387164
 MinScale:   0
 MaxScale:   24

Modified: branches/r1.2/res_noewe/webmapservices/pl_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/pl_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/pl_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -37,7 +37,7 @@
 
 # pfeffer entered here the bounding box of Poland
 BoundingBoxTopLeftWGS84: N 54.84 E 14.121686
-BoundingBoxButtomRightWGS84: N 48.9996 E 24.1488
+BoundingBoxBottomRightWGS84: N 48.9996 E 24.1488
 MinScale:   1
 MaxScale:   11
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/pt_t500.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/pt_t500.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/pt_t500.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -12,10 +12,10 @@
 #LayersUrlPart:     LAYERS=sc500k|Carta de Portugal Continental 1:500.000|0.249451424214819|249451.424214819
 LayersUrlPart:     LAYERS=sc500k
 StylesUrlPart:     STYLES=
-ImageFormatUrlPart:FORMAT=image/png
+ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 42.2787 W 10.1943
-BoundingBoxButtomRightWGS84: N 36.7636 W 5.71067
+BoundingBoxBottomRightWGS84: N 36.7636 W 5.71067
 MinScale:   0
-MaxScale:   45
-RecommendedScale:   5
-ImageFileExtension: .png
+MaxScale:   100
+RecommendedScale:   50
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -32,7 +32,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.027050  E 9.529250
-BoundingBoxButtomRightWGS84:   N 46.357433 E 17.202733
+BoundingBoxBottomRightWGS84:   N 46.357433 E 17.202733
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #SK Bratislava
 BoundingBoxTopLeftWGS84: N 48.659222 E 16.819382
-BoundingBoxButtomRightWGS84: N 48.009865 E 17.517636
+BoundingBoxBottomRightWGS84: N 48.009865 E 17.517636
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #SK Tyrnauer
 BoundingBoxTopLeftWGS84: N 48.882582 E 16.927528
-BoundingBoxButtomRightWGS84: N 47.75606 E 18.08583
+BoundingBoxBottomRightWGS84: N 47.75606 E 18.08583
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/us_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/us_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/us_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,22 +1,21 @@
-TakenFromUrl:       http://terraservice.net/
-GetCapabilitiesUrl: http://terraservice.net/ogccapabilities.ashx?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
-Name:               USA photo
-MapType:                        photo
-MainUrl:            http://terraservice.net/ogcwms.aspx?
+TakenFromUrl:       http://igskmncngs617.cr.usgs.gov/arcgis/services/baseline/ImageServer/WMSServer
+GetCapabilitiesUrl: http://isse.cr.usgs.gov/ArcGIS/services/Baseline/ImageServer/WMSServer?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               USA p
+MapType:            photo
+MainUrl:            http://isse.cr.usgs.gov/ArcGIS/services/Baseline/ImageServer/WMSServer?
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
 RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=DOQ|USGS Digital Ortho-Quadrangles||
-#LayersUrlPart:     LAYERS=DRG|USGS Raster Graphics (Topo Maps)||
-#LayersUrlPart:     LAYERS=UrbanArea|USGS Urban Areas Ortho-Imagery||
-LayersUrlPart:     LAYERS=DOQ
+#LayersUrlPart:     LAYERS=0|IGSKMNCNGS617/baseline||
+LayersUrlPart:     LAYERS=0
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
-BoundingBoxTopLeftWGS84: N 71.5500 W 168.6700
-BoundingBoxButtomRightWGS84: N 17.8400 W 65.1500
+BoundingBoxTopLeftWGS84: N 81.9971 W 170.9250
+BoundingBoxBottomRightWGS84: N 6.2961 W 50.8429
+#BBox_Mitte: N 44.146614 W 110.883977
 MinScale:   0
-MaxScale:   45
-RecommendedScale:   5
+MaxScale:   20
+RecommendedScale:    1 0.5 2
 ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/us_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/us_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/us_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,8 +1,8 @@
 TakenFromUrl:       http://terraservice.net/
 GetCapabilitiesUrl: http://terraservice.net/ogccapabilities.ashx?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
-Name:               USA topo
-MapType:                        topo
-MainUrl:            http://terraservice.net/ogcwms.aspx?
+Name:               USA t
+MapType:            topo
+MainUrl:            http://terraservice.net/ogcmap.ashx?
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf:  4326
@@ -15,8 +15,8 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 71.5500 W 168.6700
-BoundingBoxButtomRightWGS84: N 17.8400 W 65.1500
+BoundingBoxBottomRightWGS84: N 17.8400 W 65.1500
 MinScale:   0
 MaxScale:   45
-RecommendedScale:   5
+RecommendedScale:   2.5 5 10
 ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/wfl-format.txt
===================================================================
--- branches/r1.2/res_noewe/webmapservices/wfl-format.txt	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/wfl-format.txt	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,34 @@
+f0 affine lat x
+f1 affine lon x
+f2 affine lat y
+f3 affine lon y
+topleft.lat
+topleft.lon
+bottomright.lat
+bottomright.lon
+EPSG - Code
+
+
+
+
+
+Berechnung der Koordinaten ll aus einem Bildpunkt (x,y)
+		ll.lat = x * f0 + y * f2 + topleft.lat;
+		ll.lon = x * f1 + y * f3 + topleft.lon;
+
+Berechnung 
+			//calculate reverse affine
+			double nenner=(-f1*f2+f0*f3);
+			transLatX = f3/nenner; // nenner == 0 cannot happen as long als affine is correct
+			transLonX = -f2/nenner;
+			transLatY = -f1/nenner;
+			transLonY = f0/nenner;
+
+Berechnung Bildpunkt x,y aus Koordinaten t
+		x = (int)Math.round(transLatX * (t.latDec - topleft.lat) + transLonX * (t.lonDec - topleft.lon));
+		y = (int)Math.round(transLatY * (t.latDec - topleft.lat) + transLonY * (t.lonDec - topleft.lon));
+
+Beispiel
+Berechnung f2,f1 vereinfacht bei f0,f3=0(keineDrehung) Bildgr?sse 500x500
+(bottomright.lon-topleft.lon)/499=f1
+(bottomright.lat-topleft.lat)/499=f2

Added: branches/r1.2/resources/archived.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/archived.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/bonus.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/bonus.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/disabled.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/disabled.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/dnf.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/dnf.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/found.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/found.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/owned.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/owned.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/solved.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/solved.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: branches/r1.2/src/CacheWolf/Attribute.java
===================================================================
--- branches/r1.2/src/CacheWolf/Attribute.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Attribute.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.mImage;
@@ -30,331 +30,372 @@
 
 /**
  * This class represents a single attribute
+ * 
  * @author skg
- *
+ * 
  */
 public class Attribute {
 	// Constructors
-	public Attribute(int id, int inc) {_Id=id;setInc(inc);setIdBit();}
-	public Attribute(String attributeName) { attName2attNo(attributeName); setIdBit();}
-	public Attribute(int attIdOC) { OCAttNo2attNo(attIdOC); setIdBit();}
-	public Attribute(int attIdGC, String Yes1No0) { GCAttNo2attNo(attIdGC, Yes1No0); setIdBit();}
+	public Attribute(int id, int inc) {
+		_Id = id;
+		setInc(inc);
+		setIdBit();
+	}
+
+	public Attribute(String attributeName) {
+		attName2attNo(attributeName);
+		setIdBit();
+	}
+
+	public Attribute(int attIdOC) {
+		OCAttNo2attNo(attIdOC);
+		setIdBit();
+	}
+
+	public Attribute(int attIdGC, String Yes1No0) {
+		GCAttNo2attNo(attIdGC, Yes1No0);
+		setIdBit();
+	}
+
 	// Constructors end
 	private int _Id;
 	private int _Inc; // Yes=1 No=0 non=2
 	private String _ImageName;
-	private long[] _bit = {0l,0l};
+	private long[] _bit = { 0l, 0l };
+
 	// for GC Constructor Spider
 	private void attName2attNo(String attributeName) {
-    	for (int i=0; i<maxAttRef; i++) {
-    		if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
-				_Id=i;
-				_Inc=attributeName.toLowerCase().endsWith("-no.gif") ? 0 : 1;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? "-no.gif" : "-yes.gif");
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
+				_Id = i;
+				_Inc = attributeName.toLowerCase().endsWith("-no.gif") ? 0 : 1;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? "-no.gif" : "-yes.gif");
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName="error.gif";
-    	}
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = "error.gif";
+	}
+
 	// for OC Constructor
-    private void OCAttNo2attNo(int attIdOC) {
-    	for (int i=0; i<maxAttRef; i++) {
-    		if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
-				_Id=i;
-				_Inc=1;
-				_ImageName=attRef[i][PIC_NAME]+"-yes.gif";
+	private void OCAttNo2attNo(int attIdOC) {
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
+				_Id = i;
+				_Inc = 1;
+				_ImageName = attRef[i][PIC_NAME] + "-yes.gif";
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName="error.gif";
-    }
-    // for GC Constructor gpx-Import
-    private void GCAttNo2attNo(int attIdGC, String Yes1No0 ) {
-    	for (int i=0; i<maxAttRef; i++) {
-    		if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
-				_Id=i;
-    			_Inc=Yes1No0.equals("1") ? 1 : 0;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? "-no.gif" : "-yes.gif");
-				return;				
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName="error.gif";
-    }
-    // used by all Constructors
-    private void setIdBit() {
-    	_bit=getIdBit(_Id);
-    }
-    // checking for array limits (caus -1 is possible value)
-    private static String attRef(int row, int column ) {
-    	if (row > -1 && row < maxAttRef) {
-    		return attRef[row][column];
-    	}
-    	else {
-    		return "";
-    	}
-    }
-    // *** public part
-    public static long[] getIdBit(int id) {
-    	long [] bit = new long[2];
-    	if (id>-1 && id<maxAttRef) {
-        	int b = Common.parseInt(attRef[id][BIT_NR]);
-    		bit[0] = b>63 ? 0l : (1L << b);
-    		bit[1] = b>63 ? (1L << b-64) : 0;
-    	}
-    	else {
-        	bit[0]=0;
-        	bit[1]=0;
-    	}
-    	return bit;
-    }    
-    /**
-     * get GC_TEXT string
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = "error.gif";
+	}
+
+	// for GC Constructor gpx-Import
+	private void GCAttNo2attNo(int attIdGC, String Yes1No0) {
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
+				_Id = i;
+				_Inc = Yes1No0.equals("1") ? 1 : 0;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? "-no.gif" : "-yes.gif");
+				return;
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = "error.gif";
+	}
+
+	// used by all Constructors
+	private void setIdBit() {
+		_bit = getIdBit(_Id);
+	}
+
+	// checking for array limits (caus -1 is possible value)
+	private static String attRef(int row, int column) {
+		if (row > -1 && row < maxAttRef) {
+			return attRef[row][column];
+		} else {
+			return "";
+		}
+	}
+
+	// *** public part
+	public static long[] getIdBit(int id) {
+		long[] bit = new long[2];
+		if (id > -1 && id < maxAttRef) {
+			int b = Common.parseInt(attRef[id][BIT_NR]);
+			bit[0] = b > 63 ? 0l : (1L << b);
+			bit[1] = b > 63 ? (1L << b - 64) : 0;
+		} else {
+			bit[0] = 0;
+			bit[1] = 0;
+		}
+		return bit;
+	}
+
+	/**
+	 * get GC_TEXT string
 	 */
-    public String getGCText () { return attRef(_Id,GC_TEXT); }
-    /**
-     * get GC_ID string
+	public String getGCText() {
+		return attRef(_Id, GC_TEXT);
+	}
+
+	/*
+     * 
+     */
+	public static String getIdFromGCText(String t) {
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attRef[i][GC_TEXT].equals(t)) {
+				return attRef[i][GC_ID];
+			}
+		}
+		return "-1";
+	}
+
+	/**
+	 * get GC_ID string
 	 */
-    public String getGCId () { return attRef(_Id,GC_ID); }
-    /**
-     * getting attribute given=1,negative=0,not specified=2  
-     */
-	public int getInc () { return _Inc; }
-    /**
-     * getting CW internal attribute number (-1..127)  
-     */
-	public int getId () { return _Id; }
-    /**
-     * setting/changing attribute given=1,negative=0,not specified=2  
-     */
-    public void setInc(int inc) {
-    	_Inc=inc;
-    	if (_Id<0 || _Id>=maxAttRef) {
-    		_ImageName="error.gif";
-    	}
-    	else {
-    		_ImageName=attRef(_Id,PIC_NAME);
-    		if (inc==0) _ImageName+="-no.gif";
-    		else if (inc==1) _ImageName+="-yes.gif";
-    		else _ImageName+="-non.gif";
-    	}
-    }
-    /**
-     * getting name of corresponding image stored in attributes subdirectory 
-     */
-    public String getImageName() {
-    	return _ImageName;
-    }   
-    /**
-     * getting path+name of corresponding image stored in attributes subdirectory 
-     */
-    public String getPathAndImageName() {
-    	return IMAGEDIR+_ImageName;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getYesBit(long[] yes) {
-    	if (_Inc==1) {
-    		yes[0]|=_bit[0];
-    		yes[1]|=_bit[1];    		
-    	}
-    	else {
-    		yes[0]&=~_bit[0];
-    		yes[1]&=~_bit[1];    		
-    	}
-    	return yes;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getNoBit(long[] no) {
-    	if (_Inc==0) {
-    		no[0]|=_bit[0];
-    		no[1]|=_bit[1];
-    	}
-    	else {
-    		no[0]&=~_bit[0];
-    		no[1]&=~_bit[1];    		
-    	}
-    	return no;
-    }
-    /**
-     * get the language dependant description of the attribute  
-     */
-    public String getMsg() {
-    	return getMsg(_Id,_Inc);
-    }
-	
-	private final static int BIT_NR = 0; 
+	public String getGCId() {
+		return attRef(_Id, GC_ID);
+	}
+
+	/**
+	 * getting attribute given=1,negative=0,not specified=2
+	 */
+	public int getInc() {
+		return _Inc;
+	}
+
+	/**
+	 * getting CW internal attribute number (-1..127)
+	 */
+	public int getId() {
+		return _Id;
+	}
+
+	/**
+	 * setting/changing attribute given=1,negative=0,not specified=2
+	 */
+	public void setInc(int inc) {
+		_Inc = inc;
+		if (_Id < 0 || _Id >= maxAttRef) {
+			_ImageName = "error.gif";
+		} else {
+			_ImageName = attRef(_Id, PIC_NAME);
+			if (inc == 0)
+				_ImageName += "-no.gif";
+			else if (inc == 1)
+				_ImageName += "-yes.gif";
+			else
+				_ImageName += "-non.gif";
+		}
+	}
+
+	/**
+	 * getting name of corresponding image stored in attributes subdirectory
+	 */
+	public String getImageName() {
+		return _ImageName;
+	}
+
+	/**
+	 * getting path+name of corresponding image stored in attributes subdirectory
+	 */
+	public String getPathAndImageName() {
+		return IMAGEDIR + _ImageName;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getYesBit(long[] yes) {
+		if (_Inc == 1) {
+			yes[0] |= _bit[0];
+			yes[1] |= _bit[1];
+		} else {
+			yes[0] &= ~_bit[0];
+			yes[1] &= ~_bit[1];
+		}
+		return yes;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getNoBit(long[] no) {
+		if (_Inc == 0) {
+			no[0] |= _bit[0];
+			no[1] |= _bit[1];
+		} else {
+			no[0] &= ~_bit[0];
+			no[1] &= ~_bit[1];
+		}
+		return no;
+	}
+
+	/**
+	 * get the language dependant description of the attribute
+	 */
+	public String getMsg() {
+		return getMsg(_Id, _Inc);
+	}
+
+	private final static int BIT_NR = 0;
 	private final static int MSG_NR = 1;
 	private final static int PIC_NAME = 2;
-	private final static int OC_ID = 3;
-	private final static int GC_ID = 4;
-	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum	
-	private static final String[][] attRef = {
-		// Empfehlungen / Personen - Conditions (Yes/No)
-		{"30","2562","scenic","0","8","Scenic view"},//62 scenic view
-		{"17","2536","kids","59","6","Recommended for kids"},//36 kid friendly
-		{"35","2572","stroller","0","41","Stroller accessible"},//72 stroller accessible	
-		{"41","2584","wheelchair","0","24","Wheelchair accessible"},//84 wheelchair accessible
-		//  vorhanden / Eigenschaften / Infrastruktur - Facilities (Yes/No)
-		{"22","2546","parking","18","25","Parking available"},//46 parking available
-		{"26","2554","public","19","26","Public transportation"},//54 public transit available
-		{"40","2582","water","20","27","Drinking water nearby"},//82 drinking water nearby
-		{"29","2560","restrooms","21","28","Public restrooms nearby"},//60 restrooms available
-		{"23","2548","phone","22","29","Telephone nearby"},//48 telephone nearby
-		{"24","2550","picnic","0","30","Picnic tables nearby"},//50 picnic tables available
-		{"43","2588","firstaid","23","42","Firstaid"}, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe 
-		{"73","2654","rv","0","46","Truck Driver/RV"},// changed by Moorteufel 12.07.10 
-		{"85","2678","fuel","0","58","Fuel nearby"}, // changed by araber95 14.08.10 
-		{"86","2680","food","0","59","Food nearby"}, // changed by araber95 14.08.10
-		// Erlaubt - Permissions (Allowed/Not Allowed)
-		{"11","2524","dogs","0","1","Dogs"},//24 dogs allowed
-		{"05","2512","camping","0","31","Camping available"},//12 Camping allowed
-		{"01","2504","bicycles","0","32","Bicycles"},//04 bikes allowed
-		{"19","2540","motorcycles","0","33","Motorcycles"},//40 motorcycles allowed
-		{"27","2556","quads","0","34","Quads"},//56 quads allowed
-		{"16","2534","jeeps","0","35","Off-road vehicles"},//34 off-road vehicles allowed
-		{"33","2568","snowmobiles","0","36","Snowmobiles"},//68
-		{"14","2530","horses","0","37","Horses"},//30 horses allowed
-		{"04","2510","campfires","0","38","Campfires"},//10 campfires allowed
-		// Eigenschaften / Gefahren - Hazards (Present/Not Present)
-		{"10","2522","danger","9","23","Dangerous area"},//22 dangerous area
-		{"62","2644","train","10","0",""},// 144 aktive Eisenbahnlinien in der N?he
-		{"06","2514","cliff","11","21","Cliff / falling rocks"},//14 falling-rocks nearby
-		{"15","2532","hunting","12","22","Hunting"},//32 hunting area
-		{"37","2576","thorn","13","39","Thorns"},//76 thorns!
-		{"38","2578","ticks","14","19","Ticks"},//78 ticks!
-		{"18","2538","mine","15","20","Abandoned mines"},//38
-		{"25","2552","poisonoak","16","17","Poison plants"},//52 Giftige Pflanzen
-		{"46","2594","animals","17","0",""},// 94 Giftige/gef%e4hrliche Tiere
-		// {"03","2508","cactus","0","0",""},//08 removed 14.08.10 araber95
-		{"32","2566","dangerousanimals","0","18","Dangerous Animals"},//66
-		// {"32","2566","snakes","0","18","Snakes"},//66 araber95 replaced by Dangerous Animals 14.08.10
-		{"09","2520","cow","0","43","Watch for livestock"},//20 watch for livestock
-		// Eigenschaften / Der Weg - Conditions (Yes/No)
-		{"49","2600","car","24","0",""},// 100 Nahe beim Auto
-		{"21","2544","onehour","0","7","Takes less than an hour"},//44 takes less than one hour
-		{"82","2672","hike_short","0","55","Short hike"}, // added by araber95 14.8.10
-		{"83","2674","hike_med","0","56","Medium Hike"}, // added by araber95 14.8.10
-		{"84","2676","hike_long","0","57","Long Hike"}, // added by araber95 14.8.10
-		{"13","2528","hiking","25","9","Significant hike"},//28 significant hike
-		{"39","2580","wading","26","11","May require wading"},//80 may require wading
-		{"65","2634","steep","27","0",""},// 134 H?geliges Gel?nde
-		{"07","2516","climbing","28","10","Difficult climbing"},//16 easy climbing(OC-28), difficult climbing(GC-10) 
-		{"36","2574","swimming","29","12","May require swimming"},//74
-		{"79","2666","nightcache","0","52","Night Cache"}, // added by araber95 14.8.10
-		{"80","2668","parkngrab","0","53","Park and grab"}, // added by araber95 14.8.10
-		{"81","2670","abandonedbuilding","0","54","Abandoned structure"}, // added by araber95 14.8.10
-		// Eigenschaften / Wegpunkte  - Conditions (Yes/No)
-		{"55","2612","letter","8","0",""},// 112 Letterbox (ben?tigt Stempel)
-		{"54","2610","interestsign","30","0",""},// 110 Interessanter Ort ev mit scenic zusammenfassen?
-		{"56","2614","moving","31","0",""},// 114 Bewegliches Ziel
-		{"64","2646","webcam","32","0",""},// 146 Webcam am Ziel
-		{"53","2608","indoor","33","0",""},// 108 In geschlossenen R?umen
-		{"66","2636","submerged","34","0",""},// 136 Im Wasser
-		{"58","2618","nogps","35","0",""},// 118 Ohne GPS
-		{"34","2570","stealth","0","40","Stealth required"},//70 stealth required (Heimlich,List,Schl?ue)
-		// Einschr?nkungen und Voraussetzungen / Allgemein
-		{"12","2526","fee","36","2","Access or parking fee"},//26 access/parking fees
-		{"61","2624","overnight","37","0",""},// 124 ?bernachtung erforderlich
-		// Einschr?nkungen und Voraussetzungen / Zeitlich
-		{"20","2542","night","1","14","Recommended at night"},//42 recommended at night
-		{"00","2502","available","38","13","Available at all times"},//02 available 24-7
-		{"68","2640","time","39","0",""},// 140 An bestimmte Zeiten gebunden
-		{"52","2606","day","40","0",""},// 106 nur tags?ber
-		{"67","2638","tide","41","0",""},// 138 Gezeiten
-		// Einschr?nkungen und Voraussetzungen / Saisonbedingt
-		{"51","2604","date","42","0",""},// 104 w?hrend des ganzen Jahres zug?nglich
-		{"57","2616","naturschutz","43","0",""},// 116 Brutsaison/Naturschutz
-		{"42","2586","winter","44","15","Available during winter"},//86 available in winter 132 Schneesicheres Versteck
-		// Einschr?nkungen und Voraussetzungen / Systembedingt
-		{"59","2620","oconly","6","0",""},// 120 Nur bei Opencaching logbar
-		{"71","2650","wwwlink","7","0",""},// 150 Nur Hyperlink zu OC-externen Portalen
-		// Einschr?nkungen und Voraussetzungen / Werkzeug - Equipment (Required/Not Required)
-		{"69","2642","tools","46","0","Special Tool required"},// 142 Spezielle Ausr?stung
-		{"08","2518","compass","47","0",""},//18 Kompass
-		{"44","2590","flashlight","48","44","Flashlight required"}, // 90 Flashlight required
-		{"28","2558","rappelling","49","3","Climbing gear"},//58 climbing gear Kletterausr?stung
-		{"50","2602","cave","50","0",""},// 102 H?hlenausr?stung
-		{"31","2564","scuba","51","5","Scuba gear"},//64 Tauchausr?stung
-		{"02","2506","boat","52","4","Boat"},//06 Wasserfahrzeug
-		{"45","2592","aircraft","53","38",""},// 92
-		{"75","2658","uv","0","48","UV Light required"}, // added by araber95 14.8.10
-		{"76","2660","snowshoes","0","49","Snowshoes"}, // added by araber95 14.8.10"
-		{"77","2662","skiis","0","50","Cross Country Skis"}, // added by araber95 14.8.10
-		{"78","2664","s-tool","0","51","Special Tool required"}, // added by araber95 14.8.10
-		{"87","2681","wirelessbeacon","0","60","Wireless Beacon"}, // added by araber95 27.10.10
-		// Einschr?nkungen und Voraussetzungen / Ben?tigt Vorarbeit
-		{"70","2648","wiki","54","0",""},// 148 Recherche
-		{"63","2630","riddle","55","0",""},// 130 R?tsel
-		{"74","2656","field_puzzle","0","47","Field Puzzle"},// changed by Moorteufel 12.07.10
-		{"47","2596","arith_prob","56","0",""},// 96 Rechenaufgabe
-		{"60","2622","othercache","57","0",""},// 122 besondere Cacheart
-		{"48","2598","ask","58","0",""},// 98 Startbedingungen beim Owner erfragen
-		{"72","2652","landf","0","45","Lost And Found Tour"}, // thx to Kappler and MiK
-		// {"-1","2500","error","0","0",""}, //
+	private final static int OC_ID = 3; // OC - XML
+	private final static int GC_ID = 4; // auch OC neues gpx
+	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum
+	private static final String[][] attRef = { { "00", "2502", "available", "38", "13", "Available at all times" },// 02 available 24-7
+			{ "01", "2504", "bicycles", "0", "32", "Bicycles" },// 04 bikes allowed
+			{ "02", "2506", "boat", "52", "4", "Boat" },// 06 Wasserfahrzeug
+			// {"03","2508","cactus","0","0",""},//08 removed 14.08.10 araber95
+			{ "04", "2510", "campfires", "0", "38", "Campfires" },// 10 campfires allowed
+			{ "05", "2512", "camping", "0", "31", "Camping available" },// 12 Camping allowed
+			{ "06", "2514", "cliff", "11", "21", "Cliff / falling rocks" },// 14 falling-rocks nearby
+			{ "07", "2516", "climbing", "28", "10", "Difficult climbing" },// 16 easy climbing(OC-28), difficult climbing(GC-10)
+			{ "08", "2518", "compass", "47", "147", "Compass" }, // OC special
+			{ "09", "2520", "cow", "0", "43", "Watch for livestock" },// 20 watch for livestock
+			{ "10", "2522", "danger", "9", "23", "Dangerous area" },// 22 dangerous area
+			{ "11", "2524", "dogs", "0", "1", "Dogs" },// 24 dogs allowed
+			{ "12", "2526", "fee", "36", "2", "Access or parking fee" },// 26 access/parking fees
+			// {"13","2528","hiking","0","9","Significant hike"},//28 significant hike : removed
+			{ "13", "2528", "hiking", "25", "125", "Long walk" }, // OC special
+			{ "14", "2530", "horses", "0", "37", "Horses" },// 30 horses allowed
+			{ "15", "2532", "hunting", "12", "22", "Hunting" },// 32 hunting area
+			{ "16", "2534", "jeeps", "0", "35", "Off-road vehicles" },// 34 off-road vehicles allowed
+			{ "17", "2536", "kids", "59", "6", "Recommended for kids" },// 36 kid friendly
+			{ "18", "2538", "mine", "15", "20", "Abandoned mines" },// 38
+			{ "19", "2540", "motorcycles", "0", "33", "Motorcycles" },// 40 motorcycles allowed
+			{ "20", "2542", "night", "1", "14", "Recommended at night" },// 42 recommended at night
+			{ "21", "2544", "onehour", "0", "7", "Takes less than an hour" },// 44 takes less than one hour
+			{ "22", "2546", "parking", "18", "25", "Parking available" },// 46 parking available
+			{ "23", "2548", "phone", "22", "29", "Telephone nearby" },// 48 telephone nearby
+			{ "24", "2550", "picnic", "0", "30", "Picnic tables nearby" },// 50 picnic tables available
+			{ "25", "2552", "poisonoak", "16", "17", "Poison plants" },// 52 Giftige Pflanzen
+			{ "26", "2554", "public", "19", "26", "Public transportation" },// 54 public transit available
+			{ "27", "2556", "quads", "0", "34", "Quads" },// 56 quads allowed
+			{ "28", "2558", "rappelling", "49", "3", "Climbing gear" },// 58 climbing gear Kletterausr?stung
+			{ "29", "2560", "restrooms", "21", "28", "Public restrooms nearby" },// 60 restrooms available
+			{ "30", "2562", "scenic", "0", "8", "Scenic view" },// 62 scenic view
+			{ "31", "2564", "scuba", "51", "5", "Scuba gear" },// 64 Tauchausr?stung
+			// {"32","2566","snakes","0","18","Snakes"},//66 araber95 replaced by Dangerous Animals 14.08.10
+			{ "32", "2566", "dangerousanimals", "0", "18", "Dangerous Animals" },// 66
+			{ "33", "2568", "snowmobiles", "0", "36", "Snowmobiles" },// 68
+			{ "34", "2570", "stealth", "0", "40", "Stealth required" },// 70 stealth required (Heimlich,List,Schl?ue)
+			{ "35", "2572", "stroller", "0", "41", "Stroller accessible" },// 72 stroller accessible
+			{ "36", "2574", "swimming", "29", "12", "May require swimming" },// 74
+			{ "37", "2576", "thorn", "13", "39", "Thorns" },// 76 thorns!
+			{ "38", "2578", "ticks", "14", "19", "Ticks" },// 78 ticks!
+			{ "39", "2580", "wading", "26", "11", "May require wading" },// 80 may require wading
+			{ "40", "2582", "water", "20", "27", "Drinking water nearby" },// 82 drinking water nearby
+			{ "41", "2584", "wheelchair", "0", "24", "Wheelchair accessible" },// 84 wheelchair accessible
+			{ "42", "2586", "winter", "44", "15", "Available during winter" },// 86 available in winter 132 Schneesicheres Versteck
+			{ "43", "2588", "firstaid", "0", "42", "Firstaid" }, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe
+			{ "44", "2590", "flashlight", "48", "44", "Flashlight required" }, // 90 Flashlight required
+			{ "45", "2592", "aircraft", "53", "153", "Aircraft" }, // OC special //38 GC removed
+			{ "46", "2594", "animals", "17", "0", "" },// 94 Giftige/gef%e4hrliche Tiere
+			{ "47", "2596", "arith_prob", "56", "156", "Arithmetical problem" }, // OC special
+			{ "48", "2598", "ask", "58", "158", "Ask owner for start conditions" }, // OC special
+			{ "49", "2600", "car", "24", "0", "" },// 100 Nahe beim Auto
+			{ "50", "2602", "cave", "50", "150", "Cave equipment" }, // OC special
+			{ "51", "2604", "date", "42", "142", "All seasons" }, // OC special
+			{ "52", "2606", "day", "40", "140", "by day only" }, // OC special
+			{ "53", "2608", "indoor", "33", "133", "Within enclosed rooms (caves, buildings etc.)" }, // OC special
+			{ "54", "2610", "interestsign", "30", "130", "Point of interest" }, // OC special
+			{ "55", "2612", "letter", "8", "108", "Letterbox (needs stamp)" }, // OC special
+			{ "56", "2614", "moving", "31", "131", "Moving target" }, // OC special
+			{ "57", "2616", "naturschutz", "43", "143", "Breeding season / protected nature" }, // OC special
+			{ "58", "2618", "nogps", "35", "135", "Without GPS (letterboxes, cistes, compass juggling ...)" }, // OC special
+			{ "59", "2620", "oconly", "6", "106", "Only loggable at Opencaching" },// 120 Nur bei Opencaching logbar
+			{ "60", "2622", "othercache", "57", "157", "Other cache type" }, // OC special
+			{ "61", "2624", "overnight", "37", "137", "Overnight stay necessary" }, // OC special
+			{ "62", "2644", "train", "10", "110", "Active railway nearby" }, // OC special
+			{ "63", "2630", "riddle", "55", "0", "" },// 130 R?tsel
+			{ "64", "2646", "webcam", "32", "132", "Webcam" }, // OC special
+			{ "65", "2634", "steep", "27", "127", "Hilly area" }, // OC special
+			{ "66", "2636", "submerged", "34", "134", "In the water" }, // OC special
+			{ "67", "2638", "tide", "41", "141", "Tide" }, // OC special
+			{ "68", "2640", "time", "39", "139", "Only available at specified times" }, // OC special
+			{ "69", "2642", "tools", "46", "0", "Special Tool required" },// 142 Spezielle Ausr?stung
+			{ "70", "2648", "wiki", "54", "154", "Investigation" }, // OC special
+			{ "71", "2650", "wwwlink", "7", "107", "Hyperlink to another caching portal only" }, // OC special
+			{ "72", "2652", "landf", "0", "45", "Lost And Found Tour" }, // thx to Kappler and MiK
+			{ "73", "2654", "rv", "0", "46", "Truck Driver/RV" },// changed by Moorteufel 12.07.10
+			{ "74", "2656", "field_puzzle", "0", "47", "Field Puzzle" },// changed by Moorteufel 12.07.10
+			{ "75", "2658", "uv", "0", "48", "UV Light required" }, // added by araber95 14.8.10
+			{ "76", "2660", "snowshoes", "0", "49", "Snowshoes" }, // added by araber95 14.8.10"
+			{ "77", "2662", "skiis", "0", "50", "Cross Country Skis" }, // added by araber95 14.8.10
+			{ "78", "2664", "s-tool", "0", "51", "Special Tool required" }, // added by araber95 14.8.10
+			{ "79", "2666", "nightcache", "0", "52", "Night Cache" }, // added by araber95 14.8.10
+			{ "80", "2668", "parkngrab", "0", "53", "Park and grab" }, // added by araber95 14.8.10
+			{ "81", "2670", "abandonedbuilding", "0", "54", "Abandoned structure" }, // added by araber95 14.8.10
+			{ "82", "2672", "hike_short", "0", "55", "Short hike" }, // added by araber95 14.8.10
+			{ "83", "2674", "hike_med", "0", "56", "Medium Hike" }, // added by araber95 14.8.10
+			{ "84", "2676", "hike_long", "0", "57", "Long Hike" }, // added by araber95 14.8.10
+			{ "85", "2678", "fuel", "0", "58", "Fuel nearby" }, // changed by araber95 14.08.10
+			{ "86", "2680", "food", "0", "59", "Food nearby" }, // changed by araber95 14.08.10
+			{ "87", "2681", "wirelessbeacon", "0", "60", "Wireless Beacon" }, // added by araber95 27.10.10
+			{ "88", "2588", "firstaid", "23", "123", "First aid available" }, // OC special
+			{ "89", "2685", "sponsored", "0", "61", "Sponsored Cache" },
+	// {"-1","2500","error","0","0",""}, //
 
 	};
-    public static int maxAttRef=attRef.length;	
-    private static String IMAGEDIR=STRreplace.replace(FileBase.getProgramDirectory()+"/attributes/", "//", "/");
-    /*
-    private static String getImageName(int cw_Id, int cw_Inc){
-		if (cw_Id<0 || cw_Id>maxAttRef)
-			return "error.gif";
-		else {
-			switch (cw_Inc) {
-			case 1: return attRef[cw_Id][PIC_NAME]+"-yes.gif";
-			case 0: return attRef[cw_Id][PIC_NAME]+"-no.gif";
-			case 2: return attRef[cw_Id][PIC_NAME]+"-non.gif";
-			default:return "error.gif";
-			}
+	public static int maxAttRef = attRef.length;
+	private static String IMAGEDIR = STRreplace.replace(FileBase.getProgramDirectory() + "/attributes/", "//", "/");
+
+	/*
+	 * private static String getImageName(int cw_Id, int cw_Inc){ if (cw_Id<0 || cw_Id>maxAttRef) return "error.gif"; else { switch (cw_Inc) { case 1: return attRef[cw_Id][PIC_NAME]+"-yes.gif"; case 0: return attRef[cw_Id][PIC_NAME]+"-no.gif"; case 2:
+	 * return attRef[cw_Id][PIC_NAME]+"-non.gif"; default:return "error.gif"; } } }
+	 */
+	private static String getMsg(int cw_Id, int cw_Inc) {
+		if (cw_Id < 0 || cw_Id >= maxAttRef) {
+			return MyLocale.getMsg(2500, "error attribute");
 		}
-	}
-	*/
-    private static String getMsg(int cw_Id, int cw_Inc){
-    	if (cw_Id<0 || cw_Id>=maxAttRef) {
-    		return MyLocale.getMsg(2500,"error attribute");
-    	}
-		if (cw_Inc==0)
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR])-1,"");
+		if (cw_Inc == 0)
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]) - 1, "");
 		else
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]),"");
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]), "");
 	}
-    private static mImage[] yesImages=new mImage[maxAttRef];
-	private static mImage[] noImages=new mImage[maxAttRef];
-	private static mImage[] nonImages=new mImage[maxAttRef];
-	private static final mImage errorImage=new mImage(IMAGEDIR+"error.gif");	
+
+	private static mImage[] yesImages = new mImage[maxAttRef];
+	private static mImage[] noImages = new mImage[maxAttRef];
+	private static mImage[] nonImages = new mImage[maxAttRef];
+	private static final mImage errorImage = new mImage(IMAGEDIR + "error.gif");
+
 	/**
 	 * Returns the width of the attribute icons
-	 * @return The width of the images 
+	 * 
+	 * @return The width of the images
 	 */
 	public static int getImageWidth() {
 		return errorImage.image.getWidth();
-	}	
-    /**
-     * Get the image for a given attribute number. 
-     * We use lazy initialisation here, i.e. the images are only loaded when they are requested. 
-     * @return
-     */
-    public mImage getImage() {
-    	if (_Id<0 || _Id>=maxAttRef) {
-    		return errorImage;
-    	}
-    	if (_Inc==1) {
-    		if (yesImages[_Id]==null) {yesImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return yesImages[_Id];
-    	}
-    	else if (_Inc==0) {
-    		if (noImages[_Id]==null) {noImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return noImages[_Id];
-    	} 
-    	else {
-    		if (nonImages[_Id]==null) {nonImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return nonImages[_Id];
-    	}
-    }	
+	}
+
+	/**
+	 * Get the image for a given attribute number. We use lazy initialisation here, i.e. the images are only loaded when they are requested.
+	 * 
+	 * @return
+	 */
+	public mImage getImage() {
+		if (_Id < 0 || _Id >= maxAttRef) {
+			return errorImage;
+		}
+		if (_Inc == 1) {
+			if (yesImages[_Id] == null) {
+				yesImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return yesImages[_Id];
+		} else if (_Inc == 0) {
+			if (noImages[_Id] == null) {
+				noImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return noImages[_Id];
+		} else {
+			if (nonImages[_Id] == null) {
+				nonImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return nonImages[_Id];
+		}
+	}
 }

Modified: branches/r1.2/src/CacheWolf/Attributes.java
===================================================================
--- branches/r1.2/src/CacheWolf/Attributes.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Attributes.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,133 +1,150 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 public class Attributes {
-	public Attributes(){} // Just a public constructor
-	public final static int MAXATTRIBS=12;
+	public Attributes() {
+	} // Just a public constructor
+
+	public final static int MAXATTRIBS = 12;
 	/**
 	 * The number of attributes for this cache (=number of array elements in use in attribs)
 	 */
-	private int _count=0;
+	private int _count = 0;
 	/**
 	 * The attributes as array of MAXATTRIBS Attribute
 	 */
-	private Attribute attribs[]=new Attribute[MAXATTRIBS];
+	private Attribute attribs[] = new Attribute[MAXATTRIBS];
 	/**
-	 * The attributes presence in Bit Representation 
+	 * The attributes presence in Bit Representation
 	 */
-	private long[] attrYes = {0l,0l};
-	private long[] attrNo = {0l,0l};	
+	private long[] attrYes = { 0l, 0l };
+	private long[] attrNo = { 0l, 0l };
+
 	/**
 	 * Get the number of attributes in the list
+	 * 
 	 * @return number of attributes
 	 */
-	public int count(){return _count;}	
+	public int count() {
+		return _count;
+	}
+
 	/**
-	 * getting an empty attributes list for this Cache 
+	 * getting an empty attributes list for this Cache
 	 */
 	public void clear() {
-		_count=0;
-		attrYes[0]=0l;
-		attrYes[1]=0l;
-		attrNo[0]=0l;
-		attrNo[1]=0l;
+		_count = 0;
+		attrYes[0] = 0l;
+		attrYes[1] = 0l;
+		attrNo[0] = 0l;
+		attrNo[1] = 0l;
 	}
+
 	/**
-	 *  Filling the Attributes from Cache.xml (CacheHolderDetail)
-	 *  todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
+	 * Filling the Attributes from Cache.xml (CacheHolderDetail)
+	 * todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public void XmlAttributesEnd(String elem){
+	public void XmlAttributesEnd(String elem) {
 		clear();
-		Extractor ex=new Extractor(elem,"<ATT>","</ATT>",0,true);
-		String dummy = ex.findNext();
-		while(ex.endOfSearch()==false){
+		Extractor ex = new Extractor(elem, "<ATT>", "</ATT>", 0, true);
+		String dummy;
+		while ((dummy = ex.findNext()).length() > 0) {
 			add(dummy);
-			dummy = ex.findNext();
 		}
 	}
+
 	/**
-	 * Prepare for attributes to be written to cache.xml file 
-	 *  todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
+	 * Prepare for attributes to be written to cache.xml file
+	 * todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public String XmlAttributesWrite(){
-		StringBuffer sb=new StringBuffer(1000);
+	public String XmlAttributesWrite() {
+		StringBuffer sb = new StringBuffer(1000);
 		sb.append("<ATTRIBUTES>\n");
-		for (int i=0; i<_count; i++) {
+		for (int i = 0; i < _count; i++) {
 			sb.append("   <ATT>");
 			sb.append(attribs[i].getImageName());
 			sb.append("</ATT>\n");
 		}
 		sb.append("</ATTRIBUTES>\n");
 		return sb.toString();
-	}	
+	}
+
 	/**
 	 * Add a new attribute to the array by Name, meaning its icon picture name
+	 * 
 	 * @param attributeName
 	 */
-	public void add(String attributeName){
-		if (_count<attribs.length) {
-			if ( !attributeName.equalsIgnoreCase( "attribute-blank.gif" ) ) {
+	public void add(String attributeName) {
+		if (_count < attribs.length) {
+			if (!attributeName.equalsIgnoreCase("attribute-blank.gif")) {
 				Attribute attr = new Attribute(attributeName);
 				attribs[_count++] = attr;
-				attrYes=attr.getYesBit(attrYes);
-				attrNo=attr.getNoBit(attrNo);
+				attrYes = attr.getYesBit(attrYes);
+				attrNo = attr.getNoBit(attrNo);
 			}
 		}
 	}
+
 	/**
 	 * Add a new attribute to the array by ID and Inc as you get it from GC gpx-File
-	 * @param GC attribute ID
-	 * @param GC attribute Inc (attribute set = 0 ,attribute  not set = 1)
+	 * 
+	 * @param GC
+	 *            attribute ID
+	 * @param GC
+	 *            attribute Inc (attribute set = 0 ,attribute not set = 1)
 	 */
 	public void add(int attIdGC, String Yes1No0) {
-		if (_count<attribs.length) {
+		if (_count < attribs.length) {
 			Attribute attr = new Attribute(attIdGC, Yes1No0);
 			boolean doAdd = true;
-			int replace=0;
+			int replace = 0;
 			for (int i = 0; i < _count; i++) {
-				if (attribs[i].getGCId().equals(attr.getGCId())){
-					doAdd=false;
-					replace=i;
+				if (attribs[i].getGCId().equals(attr.getGCId())) {
+					doAdd = false;
+					replace = i;
 					break;
 				}
 			}
 			if (doAdd) {
 				attribs[_count++] = attr;
-			}
-			else {
+			} else {
 				// free old attr ?
-				attribs[replace]=attr;
+				attribs[replace] = attr;
 			}
-			attrYes=attr.getYesBit(attrYes);
-			attrNo=attr.getNoBit(attrNo);			
+			attrYes = attr.getYesBit(attrYes);
+			attrNo = attr.getNoBit(attrNo);
 		}
 	}
+
 	/**
-	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download 
-	 * @param OC attribute ID
+	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download
+	 * 
+	 * @param OC
+	 *            attribute ID
 	 */
 	public void add(int attIdOC) {
 		Attribute attr = new Attribute(attIdOC);
@@ -136,30 +153,34 @@
 				return;
 			}
 		}
-		if (_count<attribs.length) {
+		if (_count < attribs.length) {
 			attribs[_count++] = attr;
-			attrYes=attr.getYesBit(attrYes);
+			attrYes = attr.getYesBit(attrYes);
 		}
 	}
+
 	/**
 	 * to get the Bit Representation of the Attributs of this Cache
+	 * 
 	 * @return the Long array representing the Attributes of this Cache
 	 */
 	public long[] getAttribsAsBits() {
 		long ret[] = new long[4];
-		ret[0]=attrYes[0];
-		ret[1]=attrYes[1];
-		ret[2]=attrNo[0];
-		ret[3]=attrNo[1];
+		ret[0] = attrYes[0];
+		ret[1] = attrYes[1];
+		ret[2] = attrNo[0];
+		ret[3] = attrNo[1];
 		return ret;
 	}
+
 	/**
 	 * Get the i-th attribute
-	 * @param i The number for which the attribute is to be retrieved
+	 * 
+	 * @param i
+	 *            The number for which the attribute is to be retrieved
 	 * @return The attribute
 	 */
 	public Attribute getAttribute(int i) {
 		return attribs[i];
 	}
 }
-

Modified: branches/r1.2/src/CacheWolf/AttributesSelector.java
===================================================================
--- branches/r1.2/src/CacheWolf/AttributesSelector.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/AttributesSelector.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Image;
@@ -38,99 +38,107 @@
 
 public class AttributesSelector extends Panel {
 	protected static int TILESIZE;
-	protected static int W_OFFSET;  // depends on Global.getPref().fontSize ?
-	protected static int H_OFFSET;	// depends on Global.getPref().fontSize ?
-	private long[] selectionMaskYes = {0l,0l};
-	private long[] selectionMaskNo = {0l,0l};
+	protected static int W_OFFSET; // depends on Global.getPref().fontSize ?
+	protected static int H_OFFSET; // depends on Global.getPref().fontSize ?
+	private long[] selectionMaskYes = { 0l, 0l };
+	private long[] selectionMaskNo = { 0l, 0l };
 	protected mLabel mInfo;
-	protected InteractivePanel iap=new attInteractivePanel();
+	protected InteractivePanel iap = new attInteractivePanel();
 	protected MyScrollBarPanel scp = new MyScrollBarPanel(iap);
-	private int virtualWidth; 
+	private int virtualWidth;
 
 	public AttributesSelector() {
 		scp.setOptions(MyScrollBarPanel.NeverShowHorizontalScrollers);
-		TILESIZE = 30; W_OFFSET=100; H_OFFSET=150;
-		if(Vm.isMobile()){
-			if(MyLocale.getScreenWidth() == 240 & MyLocale.getScreenHeight() == 320){
-				TILESIZE = 28; W_OFFSET=80; H_OFFSET=120;
+		TILESIZE = 30;
+		W_OFFSET = 100;
+		H_OFFSET = 150;
+		if (Vm.isMobile()) {
+			if (MyLocale.getScreenWidth() == 240 & MyLocale.getScreenHeight() == 320) {
+				TILESIZE = 28;
+				W_OFFSET = 80;
+				H_OFFSET = 120;
 			}
-			if(MyLocale.getScreenWidth() == 320 & MyLocale.getScreenHeight() == 240){
+			if (MyLocale.getScreenWidth() == 320 & MyLocale.getScreenHeight() == 240) {
 			}
-			if(MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 640){
+			if (MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 640) {
 			}
-			if(MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 800){
+			if (MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 800) {
 			}
-			if(MyLocale.getScreenWidth() == 640 & MyLocale.getScreenHeight() == 480){
+			if (MyLocale.getScreenWidth() == 640 & MyLocale.getScreenHeight() == 480) {
 			}
+		} else {
+			TILESIZE = 36;
+			W_OFFSET = 106;
+			H_OFFSET = 150;
 		}
-		else {
-			TILESIZE = 36; W_OFFSET=106; H_OFFSET=150;
-		}
-		iap.virtualSize = new Rect(0,0,0,0); // create once
-		addLast(scp,STRETCH,FILL);
-		addLast(mInfo=new mLabel(""),HSTRETCH,HFILL);
+		iap.virtualSize = new Rect(0, 0, 0, 0); // create once
+		addLast(scp, STRETCH, FILL);
+		addLast(mInfo = new mLabel(""), HSTRETCH, HFILL);
 	}
 
 	public void setSelectionMasks(long[] SelectionMasks) {
 		selectionMaskYes[0] = SelectionMasks[0];
 		selectionMaskYes[1] = SelectionMasks[1];
 		selectionMaskNo[0] = SelectionMasks[2];
-		selectionMaskNo[1] = SelectionMasks[3];		
+		selectionMaskNo[1] = SelectionMasks[3];
 		showAttributePalette();
 	}
-	
+
 	public long[] getSelectionMasks() {
 		long[] SelectionMasks = new long[4];
 		SelectionMasks[0] = selectionMaskYes[0];
 		SelectionMasks[1] = selectionMaskYes[1];
 		SelectionMasks[2] = selectionMaskNo[0];
-		SelectionMasks[3] = selectionMaskNo[1];		
+		SelectionMasks[3] = selectionMaskNo[1];
 		return SelectionMasks;
 	}
-	
+
 	public boolean isSetSelectionMask() {
-		return  selectionMaskYes[0] != 0l || selectionMaskNo[0] != 0l ||
-				selectionMaskYes[1] != 0l || selectionMaskNo[1] != 0l;
+		return selectionMaskYes[0] != 0l || selectionMaskNo[0] != 0l || selectionMaskYes[1] != 0l || selectionMaskNo[1] != 0l;
 	}
 
 	protected class attImage extends AniImage {
-		public Attribute att;		
-		attImage (mImage img, Attribute _att) {
+		public Attribute att;
+
+		attImage(mImage img, Attribute _att) {
 			super(img);
-			att=_att;
-		}		
+			att = _att;
+		}
+
 		attImage(attImage cp, int val) {
-			att=cp.att;
+			att = cp.att;
 			att.setInc(val);
-			mImage rawImg=att.getImage();
-			setMImage (rawImg.getHeight()!=TILESIZE-2 ? rawImg.scale(TILESIZE-2,TILESIZE-2,null,Image.FOR_DISPLAY) : rawImg  );
+			mImage rawImg = att.getImage();
+			setMImage(rawImg.getHeight() != TILESIZE - 2 ? rawImg.scale(TILESIZE - 2, TILESIZE - 2, null, Image.FOR_DISPLAY) : rawImg);
 			location = cp.location;
 		}
 	}
-	
+
 	protected class attInteractivePanel extends InteractivePanel {
 		public boolean imageMovedOn(AniImage which) {
-			mInfo.setText(((attImage)which).att.getMsg());			
+			mInfo.setText(((attImage) which).att.getMsg());
 			mInfo.repaintNow();
 			return true;
 		}
+
 		public boolean imageMovedOff(AniImage which) {
 			mInfo.setText("");
 			mInfo.repaintNow();
 			return true;
 		}
+
 		public boolean imagePressed(AniImage which, Point pos) {
 			if (which != null) {
-				int value=((attImage)which).att.getInc();
-				value=(value + 1) % 3;
-				((attImage)which).att.setInc(value);
-				selectionMaskNo=((attImage)which).att.getNoBit(selectionMaskNo);
-				selectionMaskYes=((attImage)which).att.getYesBit(selectionMaskYes);
-				attImage tmpImg = new attImage(((attImage)which), value );
+				int value = ((attImage) which).att.getInc();
+				value = (value + 1) % 3;
+				((attImage) which).att.setInc(value);
+				selectionMaskNo = ((attImage) which).att.getNoBit(selectionMaskNo);
+				selectionMaskYes = ((attImage) which).att.getYesBit(selectionMaskYes);
+				attImage tmpImg = new attImage(((attImage) which), value);
 				removeImage(which);
 				addImage(tmpImg);
 				refresh();
-				notifyDataChange(new DataChangeEvent(DataChangeEvent.DATA_CHANGED,this));
+				notifyDataChange(new DataChangeEvent(DataChangeEvent.DATA_CHANGED, this));
 			}
 			return true;
 		}
@@ -139,51 +147,49 @@
 	private void showAttributePalette() {
 		iap.images.clear();
 		int myWidth = virtualWidth;
-		int myX = 2; int myY = 2;
+		int myX = 2;
+		int myY = 2;
 		int inc = 2;
 		for (int i = 0; i < Attribute.maxAttRef; i++) {
 			long[] bitMask = Attribute.getIdBit(i);
-			if ( ((selectionMaskYes[0] & bitMask[0]) != 0 ) || 
-					((selectionMaskYes[1] & bitMask[1]) != 0 ))
+			if (((selectionMaskYes[0] & bitMask[0]) != 0) || ((selectionMaskYes[1] & bitMask[1]) != 0))
 				inc = 1;
-			else if ( ((selectionMaskNo[0] & bitMask[0]) != 0 ) ||
-					((selectionMaskNo[1] & bitMask[1]) != 0 ))
+			else if (((selectionMaskNo[0] & bitMask[0]) != 0) || ((selectionMaskNo[1] & bitMask[1]) != 0))
 				inc = 0;
 			else
-				inc = 2;			
-			Attribute att = new Attribute(i,inc); 
-			mImage rawImg=att.getImage();
-			attImage img=new attImage(rawImg.getHeight()!=TILESIZE-2 ? rawImg.scale(TILESIZE-2,TILESIZE-2,null,Image.FOR_DISPLAY) : rawImg, att);
+				inc = 2;
+			Attribute att = new Attribute(i, inc);
+			mImage rawImg = att.getImage();
+			attImage img = new attImage(rawImg.getHeight() != TILESIZE - 2 ? rawImg.scale(TILESIZE - 2, TILESIZE - 2, null, Image.FOR_DISPLAY) : rawImg, att);
 
-			if (myX+TILESIZE > myWidth) {
+			if (myX + TILESIZE > myWidth) {
 				myX = 2;
 				myY += TILESIZE;
 			}
-			img.location=new Rect(myX,myY,TILESIZE,TILESIZE);
+			img.location = new Rect(myX, myY, TILESIZE, TILESIZE);
 			iap.addImage(img);
 			myX += TILESIZE;
-			
+
 		}
-		iap.repaintNow();		
+		iap.repaintNow();
 	}
-	
 
 	private void setIapSize(int width, int height) {
 		iap.setPreferredSize(width, height);
-		Global.getPref().log("[AttributesSelector:changeIapSize]  pref. area: "+width+"x"+height);
+		Global.getPref().log("[AttributesSelector:changeIapSize]  pref. area: " + width + "x" + height);
 
-		int anzPerWidth = width / (TILESIZE+2);
-		virtualWidth = anzPerWidth * (TILESIZE+2);
+		int anzPerWidth = width / (TILESIZE + 2) - 1;
+		virtualWidth = anzPerWidth * (TILESIZE + 2);
 		double max = Attribute.maxAttRef;
 		int anzPerHeight = (int) java.lang.Math.ceil(max / anzPerWidth);
-		iap.virtualSize.set(0,0,virtualWidth ,anzPerHeight * (TILESIZE+2));
-		Global.getPref().log("[AttributesSelector:setIapSize] virt. area: "+virtualWidth+"x"+anzPerHeight * (TILESIZE+2));
+		iap.virtualSize.set(0, 0, virtualWidth, anzPerHeight * (TILESIZE + 2));
+		Global.getPref().log("[AttributesSelector:setIapSize] virt. area: " + virtualWidth + "x" + anzPerHeight * (TILESIZE + 2));
 
 	}
 
 	public void changeIapSize(int width, int height) {
-		Global.getPref().log("[AttributesSelector:changeIapSize]  max. area: "+width+"x"+height);
-		setIapSize(width-W_OFFSET, height-H_OFFSET);
+		Global.getPref().log("[AttributesSelector:changeIapSize]  max. area: " + width + "x" + height);
+		setIapSize(width - W_OFFSET, height - H_OFFSET);
 		showAttributePalette();
 	}
 

Modified: branches/r1.2/src/CacheWolf/CacheHolder.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheHolder.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheHolder.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,33 +1,34 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.exp.Exporter;
 import CacheWolf.exp.GarminMap;
 import CacheWolf.navi.Metrics;
+import CacheWolf.navi.TrackPoint;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -45,12 +46,11 @@
 import ewe.util.Vector;
 
 /**
- *	A class to hold information on a cache.<br>
- *	Not all attributes are filled at once. You will have to look at other
- *	classes and methods to get more information.
- *	
+ * A class to hold information on a cache.<br>
+ * Not all attributes are filled at once. You will have to look at other classes and methods to get more information.
+ * 
  */
-public class CacheHolder{
+public class CacheHolder {
 	protected static final String NOBEARING = "?";
 	protected static final String EMPTY = "";
 
@@ -59,13 +59,11 @@
 	/** The name of the waypoint, typically GC.... or OC.... or CW...... (can be any characters) */
 	private String wayPoint = EMPTY;
 	/** The name of the cache (short description) */
-	public String cacheName = EMPTY;
+	private String cacheName = EMPTY;
 	/** The alias of the owner */
 	private String cacheOwner = EMPTY;
 	/** The coordinates of the cache */
-	public CWPoint pos = new CWPoint();
-	/** The coordinates of the cache */
-	private String LatLon = pos.toString();
+	private CWPoint pos = new CWPoint();
 	/** The date when the cache was hidden in format yyyy-mm-dd */
 	private String dateHidden = EMPTY;
 	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
@@ -79,12 +77,12 @@
 	private String bearing = NOBEARING;
 	/** The angle (0=North, 180=South) from the current centre to this point */
 	public double degrees = 0;
-	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
+	/** The difficulty of the cache from 1 to 5 in .5 incements */
 	private byte hard = CacheTerrDiff.CW_DT_UNSET;
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
 	private byte terrain = CacheTerrDiff.CW_DT_UNSET;
-	/** The cache type (@see CacheType for translation table)  */
-	private byte type; 
+	/** The cache type (@see CacheType for translation table) */
+	private byte type;
 	/** True if the cache has been archived */
 	private boolean archived = false;
 	/** True if the cache is available for searching */
@@ -97,7 +95,7 @@
 	private boolean filtered = false;
 	/** True if the number of logs for this cache has changed */
 	private boolean log_updated = false;
-	/** True if cache details have changed: longDescription, Hints,  */
+	/** True if cache details have changed: longDescription, Hints, */
 	private boolean cache_updated = false;
 	/** True if the cache data is incomplete (e.g. an error occurred during spidering */
 	private boolean incomplete = false;
@@ -119,7 +117,7 @@
 	private int numRecommended = 0;
 	/** Number of Founds since start of recommendations system */
 	private int numFoundsSinceRecommendation = 0;
-	/** Recommendation score: calculated as rations  numRecommended / numLogsSinceRecommendation * 100 */
+	/** Recommendation score: calculated as rations numRecommended / numLogsSinceRecommendation * 100 */
 	public int recommendationScore = 0;
 	/** True if this cache has travelbugs */
 	private boolean bugs = false;
@@ -127,7 +125,7 @@
 	private boolean html = true;
 	/** List of additional waypoints associated with this waypoint */
 	public Vector addiWpts = new Vector();
-	/** in range is used by the route filter to identify caches in range of a segment*/
+	/** in range is used by the route filter to identify caches in range of a segment */
 	public boolean in_range = false;
 	/** If this is an additional waypoint, this links back to the main waypoint */
 	public CacheHolder mainCache;
@@ -138,304 +136,295 @@
 	/** True if a note is entered for the cache */
 	private boolean hasNote = false;
 	private CacheHolderDetail details = null;
-	/** When sorting the cacheDB this field is used. The relevant field is copied here and
-	 *  the sort is always done on this field to speed up the sorting process 
+	/**
+	 * When sorting the cacheDB this field is used. The relevant field is copied here and the sort is always done on this field to speed up the sorting process
 	 */
 	public String sort;
-	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
+	private static StringBuffer sb = new StringBuffer(530); // Used in toXML()
 
-	private long[] attributesBits = {0l,0l,0l,0l};
-	
+	private long[] attributesBits = { 0l, 0l, 0l, 0l };
+
 	private IconAndText iconAndTextWP = null;
 	private int iconAndTextWPLevel = 0;
 
-	static char decSep,notDecSep;
+	static char decSep, notDecSep;
 	static {
-		decSep=MyLocale.getDigSeparator().charAt(0);
-		notDecSep = (decSep == '.'?',':'.');
+		decSep = MyLocale.getDigSeparator().charAt(0);
+		notDecSep = (decSep == '.' ? ',' : '.');
 	}
 
 	public CacheHolder() {
 		// do nothing
 	}
-	
+
 	public CacheHolder(String wp) {
 		wayPoint = wp;
-		type=CacheType.CW_TYPE_ERROR;
-    }
-	
+		type = CacheType.CW_TYPE_ERROR;
+	}
+
 	public CacheHolder(String xmlString, int version) {
-		int start,end;
-	        try {
-				if (version == 1) {
-			        start = xmlString.indexOf('"');
-			        end = xmlString.indexOf('"', start + 1);
-			        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        // Assume coordinates are in decimal format
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        pos = new CWPoint(lat, lon);
-			        LatLon = pos.toString();
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setDateHidden(xmlString.substring(start + 1, end));
-			        // Convert the US format to YYYY-MM-DD if necessary
-			        if (getDateHidden().indexOf('/') > -1)
-				        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setCacheStatus(xmlString.substring(start + 1, end));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-		        	setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
-		            
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setHard(CacheTerrDiff.CW_DT_UNSET);
-			        } else {
-				        try {
-				        	setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setHard(CacheTerrDiff.CW_DT_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('"', end + 1);
-				    end = xmlString.indexOf('"', start + 1);
-				    if (isAddiWpt() || isCustomWpt()) {
-				    	setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				    } else {
-					    try {
-					    	setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-					    } catch (IllegalArgumentException ex) {
-					    	setTerrain(CacheTerrDiff.CW_DT_ERROR);
-					    	setIncomplete(true);
-					    	Global.getPref().log(wayPoint, ex, true);
-				        }
-				    }
-			        // The next item was 'dirty' but this is no longer used.
-		            start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setFiltered(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-			        } else {
-				        try {
-				        	setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setCacheSize(CacheSize.CW_SIZE_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setAvailable(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setArchived(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setHas_bugs(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setBlack(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setOwned(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setFound(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setNew(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setLog_updated(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setUpdated(xmlString.substring(start + 1, end).equals("true"));
-			        // for backwards compatibility set value to true, if it is not in the file
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setHTML(!xmlString.substring(start + 1, end).equals("false"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-		            setNoFindLogs((byte)Convert.toInt(xmlString.substring(start + 1, end)));
-	
-		            start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setOcCacheID(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setIncomplete(xmlString.substring(start + 1, end).equals("true") || incomplete);
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setLastSync(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-			        recommendationScore = LogList.getScore(getNumRecommended(),
-			                getNumFoundsSinceRecommendation());
-	
-			        start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-		            if (start > -1 && end > -1) {
-		            	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		        		
-				        start = xmlString.indexOf('"', end + 1);
-				        end = xmlString.indexOf('"', start + 1);
-				        if (start > -1 && end > -1)
-			            	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            setAttribsAsBits(attribsBits);
-	            } else if (version == 3 || version == 2) {
-		            start = xmlString.indexOf('"');
-		            end = xmlString.indexOf('"', start + 1);
-		            setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            // Assume coordinates are in decimal format
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            pos = new CWPoint(lat, lon);
-		            LatLon = pos.toString();
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setDateHidden(xmlString.substring(start + 1, end));
-		            // Convert the US format to YYYY-MM-DD if necessary
-		            if (getDateHidden().indexOf('/') > -1)
-			            setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setCacheStatus(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setOcCacheID(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setLastSync(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-		            recommendationScore = LogList.getScore(getNumRecommended(),
-		                    getNumFoundsSinceRecommendation());
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-			        if (start > -1 && end > -1) {
-			        	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('"', end + 1);
-				        end = xmlString.indexOf('"', start + 1);
-				        if (start > -1 && end > -1)
-				        	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            if (version == 2) {
-		            	long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            } else {
-		            	long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-			        if (start > -1 && end > -1) {
-			        	attribsBits[1]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('"', end + 1);
-				        end = xmlString.indexOf('"', start + 1);
-				        if (start > -1 && end > -1)
-				        	attribsBits[3]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        setAttribsAsBits(attribsBits);
-	            }
-				if (version < Profile.CURRENTFILEFORMAT) {
-		            // forceload of details, creates waypoint.xml if missing
-		            details = getCacheDetails(false);
-		            // make sure details get (re)written in new format
-		            details.hasUnsavedChanges = true;
-		            // update information on notes and solver info
-		            setHasNote(!details.getCacheNotes().equals(""));
-			    setHasSolver(!details.getSolver().equals(""));
+		int start, end;
+		try {
+			if (version == 1) {
+				start = xmlString.indexOf('"');
+				end = xmlString.indexOf('"', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos.set(lat, lon);
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') > -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setHard(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
 				}
-	        } catch (Exception ex) {
-	        	// Global.getPref().log("Ignored Exception in CacheHolder()", ex, true);
-	        }
-        }
-	
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setTerrain(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				// The next item was 'dirty' but this is no longer used.
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setFiltered(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				} else {
+					try {
+						setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setCacheSize(CacheSize.CW_SIZE_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setAvailable(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setArchived(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setHas_bugs(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setBlack(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setOwned(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setFound(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNew(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setLog_updated(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setUpdated(xmlString.substring(start + 1, end).equals("true"));
+				// for backwards compatibility set value to true, if it is not in the file
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setHTML(!xmlString.substring(start + 1, end).equals("false"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNoFindLogs((byte) Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setIncomplete(xmlString.substring(start + 1, end).equals("true") || incomplete);
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start > -1 && end > -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('"', end + 1);
+					end = xmlString.indexOf('"', start + 1);
+					if (start > -1 && end > -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			} else if (version == 3 || version == 2) {
+				start = xmlString.indexOf('"');
+				end = xmlString.indexOf('"', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos = new CWPoint(lat, lon);
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') > -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start > -1 && end > -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('"', end + 1);
+					end = xmlString.indexOf('"', start + 1);
+					if (start > -1 && end > -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (version == 2) {
+					long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
+				} else {
+					long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (start > -1 && end > -1) {
+					attribsBits[1] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('"', end + 1);
+					end = xmlString.indexOf('"', start + 1);
+					if (start > -1 && end > -1)
+						attribsBits[3] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			}
+			if (version < Profile.CURRENTFILEFORMAT) {
+				// forceload of details, creates waypoint.xml if missing
+				details = getCacheDetails(false);
+				// make sure details get (re)written in new format
+				details.hasUnsavedChanges = true;
+				// update information on notes and solver info
+				setHasNote(!details.getCacheNotes().equals(""));
+				setHasSolver(!details.getSolver().equals(""));
+			}
+		} catch (Exception ex) {
+			// Global.getPref().log("Ignored Exception in CacheHolder()", ex, true);
+		}
+	}
+
 	/**
-	 * Returns the distance in formatted output. Using kilometers when metric system is active,
-	 * using miles when imperial system is active.
+	 * Returns the distance in formatted output. Using kilometers when metric system is active, using miles when imperial system is active.
 	 * 
 	 * @return The current distance.
 	 */
@@ -461,8 +450,7 @@
 				}
 				result = MyLocale.formatDouble(newValue, "0.00") + " " + newUnit;
 			} else {
-				result = "? "
-				        + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
+				result = "? " + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
 			}
 			// Caching values, so reevaluation is only done when really needed
 			this.lastKilom = this.kilom;
@@ -471,31 +459,26 @@
 		}
 		return result;
 	}
-	/** 
-	 * Updates Cache information with information provided by cache given as argument. This is used
-	 * to update the cache with the information retrieved from files or web: The argument cache
-	 * is the one that is filled with the read information, <code>this</code> is the cache that
-	 * is already in the database and subject to update. 
-	 * @param ch The cache who's information is updating the current one
-	 * @param overwrite If <code>true</code>, then <i>status</i>, <i>is_found</i> and <i>position</i>
-	 * is updated, otherwise not.
+
+	/**
+	 * Updates Cache information with information provided by cache given as argument. This is used to update the cache with the information retrieved from files or web: The argument cache is the one that is filled with the read information,
+	 * <code>this</code> is the cache that is already in the database and subject to update.
+	 * 
+	 * @param ch
+	 *            The cache who's information is updating the current one
+	 * @param overwrite
+	 *            If <code>true</code>, then <i>status</i>, <i>is_found</i> and <i>position</i> is updated, otherwise not.
 	 */
 	public void update(CacheHolder ch) {
 		this.recommendationScore = ch.recommendationScore;
 		this.setNumFoundsSinceRecommendation(ch.getNumFoundsSinceRecommendation());
 		this.setNumRecommended(ch.getNumRecommended());
-		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362,"solved"));
-		/* Here we have to distinguish several cases:
-		 * this.is_found       this                ch               Update 'this'
-		 *                                         (values are
-		 *                                     empty or yyyy-mm-dd)
-		 * ----------------------------------------------------------------------
-		 * false               any                 yyyy-mm-dd       yes
-		 * true                "Found"             yyyy-mm-dd       yes
-		 * true                yyyy-mm-dd          yyyy-mm-dd       yes (or no)
-		 * true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
-		*/
-		if (!this.found || this.cacheStatus.indexOf(":")<0) {
+		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362, "solved"));
+		/*
+		 * Here we have to distinguish several cases: this.is_found this ch Update 'this' (values are empty or yyyy-mm-dd) ---------------------------------------------------------------------- false any yyyy-mm-dd yes true "Found" yyyy-mm-dd yes true
+		 * yyyy-mm-dd yyyy-mm-dd yes (or no) true yyyy-mm-dd hh:mm yyyy-mm-dd no
+		 */
+		if (!this.found || this.cacheStatus.indexOf(":") < 0) {
 			// don't overwrite with empty data
 			if (!ch.getCacheStatus().trim().equals("")) {
 				this.setCacheStatus(ch.getCacheStatus());
@@ -506,7 +489,6 @@
 		if (ch.pos.isValid() || !this.pos.isValid()) {
 			if (mayChangeCoordinates) {
 				this.pos = ch.pos;
-				this.LatLon = ch.LatLon;
 			}
 		}
 		this.setWayPoint(ch.getWayPoint());
@@ -527,19 +509,21 @@
 		this.setFiltered(ch.is_filtered());
 		this.setIncomplete(ch.is_incomplete());
 		this.addiWpts = ch.addiWpts;
-		this.mainCache=ch.mainCache;
-		this.setOcCacheID(ch.getOcCacheID());
+		this.mainCache = ch.mainCache;
+		if (ch.getOcCacheID().length() > 0)
+			this.setOcCacheID(ch.getOcCacheID());
 		this.setNoFindLogs(ch.getNoFindLogs());
 		this.setHas_bugs(ch.has_bugs());
 		this.setHTML(ch.is_HTML());
-		this.sort=ch.sort;
+		this.sort = ch.sort;
 		this.setLastSync(ch.getLastSync());
 
 		this.setAttribsAsBits(ch.getAttributesBits());
 		if (ch.detailsLoaded()) {
 			this.getCacheDetails(false).update(ch.getCacheDetails(false));
-		}	
+		}
 	}
+
 	/**
 	 * Call it only when necessary, it takes time, because all logs must be parsed
 	 */
@@ -565,84 +549,93 @@
 		} else {
 			recommendationScore = -1;
 			setNumFoundsSinceRecommendation(-1);
-//			setNumRecommended(-1);
+			// setNumRecommended(-1);
 		}
 	}
-	
+
 	/** Return a XML string containing all the cache data for storing in index.xml */
 	public String toXML() {
-		calcRecommendationScore(); 
-		sb.delete(0,sb.length());
+		calcRecommendationScore();
+		sb.delete(0, sb.length());
 		sb.append("    <CACHE ");
-		sb.append(" name = \"");        sb.append(SafeXML.clean(getCacheName()));
-		sb.append("\" owner = \"");		sb.append(SafeXML.clean(getCacheOwner()));
-		sb.append("\" lat = \""); 		sb.append(pos.latDec ); 
-		sb.append("\" lon = \"");		sb.append(pos.lonDec);
-		sb.append("\" hidden = \"");	sb.append(getDateHidden());
-		sb.append("\" wayp = \"");		sb.append(SafeXML.clean(getWayPoint()));
-		sb.append("\" status = \"");	sb.append(getCacheStatus());
-		sb.append("\" ocCacheID = \"" );sb.append(getOcCacheID()); 
-		sb.append("\" lastSyncOC = \"" );sb.append(getLastSync()); 
-		sb.append("\" num_recommended = \"");sb.append(Convert.formatInt(getNumRecommended())); 
-		sb.append("\" num_found = \"" );sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
+		sb.append(" name = \"");
+		sb.append(SafeXML.clean(getCacheName()));
+		sb.append("\" owner = \"");
+		sb.append(SafeXML.clean(getCacheOwner()));
+		sb.append("\" lat = \"");
+		sb.append(pos.latDec);
+		sb.append("\" lon = \"");
+		sb.append(pos.lonDec);
+		sb.append("\" hidden = \"");
+		sb.append(getDateHidden());
+		sb.append("\" wayp = \"");
+		sb.append(SafeXML.clean(getWayPoint()));
+		sb.append("\" status = \"");
+		sb.append(getCacheStatus());
+		sb.append("\" ocCacheID = \"");
+		sb.append(getOcCacheID());
+		sb.append("\" lastSyncOC = \"");
+		sb.append(getLastSync());
+		sb.append("\" num_recommended = \"");
+		sb.append(Convert.formatInt(getNumRecommended()));
+		sb.append("\" num_found = \"");
+		sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
 		long[] attribsBits = getAttributesBits();
-		sb.append("\" attributesYes = \"" ); sb.append(Convert.formatLong(attribsBits[0]));
-		sb.append("\" attributesNo = \"" ); sb.append(Convert.formatLong(attribsBits[2]));
-		sb.append("\" boolFields=\"" ); sb.append(Convert.formatLong(this.boolFields2long()));
-		sb.append("\" byteFields=\"" ); sb.append(Convert.formatLong(this.byteFields2long()));
-		sb.append("\" attributesYes1 = \"" ); sb.append(Convert.formatLong(attribsBits[1]));
-		sb.append("\" attributesNo1 = \"" ); sb.append(Convert.formatLong(attribsBits[3]));
+		sb.append("\" attributesYes = \"");
+		sb.append(Convert.formatLong(attribsBits[0]));
+		sb.append("\" attributesNo = \"");
+		sb.append(Convert.formatLong(attribsBits[2]));
+		sb.append("\" boolFields=\"");
+		sb.append(Convert.formatLong(this.boolFields2long()));
+		sb.append("\" byteFields=\"");
+		sb.append(Convert.formatLong(this.byteFields2long()));
+		sb.append("\" attributesYes1 = \"");
+		sb.append(Convert.formatLong(attribsBits[1]));
+		sb.append("\" attributesNo1 = \"");
+		sb.append(Convert.formatLong(attribsBits[3]));
 		sb.append("\" />\n");
 		return sb.toString();
 	}
-	
+
 	/** Return a Hashtable containing all the cache data for Templates */
-	public Hashtable toHashtable(
-			Regex decSep, Regex badChars, 
-			int shortWaypointLength, int shortNameLength, int nrOfLogs,
-			TextCodec codec, GarminMap gm,
-			boolean withFoundText,
-			int ModTyp,
-			String expName
-			) {
+	public Hashtable toHashtable(Regex decSep, Regex badChars, int shortWaypointLength, int shortNameLength, int nrOfLogs, TextCodec codec, GarminMap gm, boolean withFoundText, int ModTyp, String expName) {
 		Hashtable varParams = new Hashtable();
 		CacheHolderDetail det = this.getCacheDetails(false);
 		varParams.put("PROGDIR", FileBase.getProgramDirectory());
 		varParams.put("PROFILDIR", Global.getProfile().dataDir);
 		varParams.put("ALIAS", Global.getPref().myAlias);
-		varParams.put("TYPE", CacheType.type2TypeTag(type)); //<type>
-		varParams.put("TYPENO",""+type);
-		varParams.put("SYM", CacheType.type2SymTag(type)); //<sym>
-		varParams.put("GSTYPE", CacheType.type2GSTypeTag(type)); //<groundspeak:type>
+		varParams.put("TYPE", CacheType.type2TypeTag(type)); // <type>
+		varParams.put("TYPENO", "" + type);
+		varParams.put("SYM", CacheType.type2SymTag(type)); // <sym>
+		varParams.put("GSTYPE", CacheType.type2GSTypeTag(type)); // <groundspeak:type>
 		varParams.put("SHORTTYPE", CacheType.getExportShortId(type));
 		if (isAddiWpt()) {
-			CacheHolder ch=this.mainCache;
-			varParams.put("MAINWP",ch.getWayPoint());
+			CacheHolder ch = this.mainCache;
+			varParams.put("MAINWP", ch.getWayPoint());
 			varParams.put("MAINWPNAME", ch.getCacheName());
-			varParams.put("DIFFICULTY", (ch.hard < 0)?"!<!":decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
+			varParams.put("DIFFICULTY", (ch.hard < 0) ? "!<!" : decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
 			String sHard = Integer.toString(ch.hard);
-			varParams.put("SHORTDIFFICULTY", (ch.hard < 0)?"":sHard);
-			varParams.put("SHDIFFICULTY", (ch.hard < 0)?"":sHard.substring(0,1));
-			varParams.put("TERRAIN", (ch.terrain < 0)?"":decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
+			varParams.put("SHORTDIFFICULTY", (ch.hard < 0) ? "" : sHard);
+			varParams.put("SHDIFFICULTY", (ch.hard < 0) ? "" : sHard.substring(0, 1));
+			varParams.put("TERRAIN", (ch.terrain < 0) ? "" : decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
 			String sTerrain = Integer.toString(ch.terrain);
-			varParams.put("SHORTTERRAIN", (ch.terrain < 0)?"":sTerrain);
-			varParams.put("SHTERRAIN", (ch.terrain < 0)?"":sTerrain.substring(0,1));
+			varParams.put("SHORTTERRAIN", (ch.terrain < 0) ? "" : sTerrain);
+			varParams.put("SHTERRAIN", (ch.terrain < 0) ? "" : sTerrain.substring(0, 1));
 			varParams.put("SIZE", CacheSize.cw2ExportString(ch.cacheSize));
 			varParams.put("SHORTSIZE", CacheSize.getExportShortId(ch.cacheSize));
 			varParams.put("OWNER", (ModTyp == 0) ? SafeXML.cleanGPX(ch.cacheOwner) : ch.cacheOwner);
 			varParams.put("DATE", ch.dateHidden);
-		}
-		else {
+		} else {
 			varParams.put("MAINWP", "");
 			varParams.put("MAINWPNAME", "");
-			varParams.put("DIFFICULTY", (isCustomWpt() || hard < 0)?"":decSep.replaceAll(CacheTerrDiff.longDT(hard)));
+			varParams.put("DIFFICULTY", (isCustomWpt() || hard < 0) ? "" : decSep.replaceAll(CacheTerrDiff.longDT(hard)));
 			String sHard = Integer.toString(hard);
-			varParams.put("SHORTDIFFICULTY", (isCustomWpt() || hard < 0)?"":sHard);
-			varParams.put("SHDIFFICULTY", (isCustomWpt() || hard < 0)?"":sHard.substring(0,1));
-			varParams.put("TERRAIN", (isCustomWpt() || terrain < 0)?"":decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
+			varParams.put("SHORTDIFFICULTY", (isCustomWpt() || hard < 0) ? "" : sHard);
+			varParams.put("SHDIFFICULTY", (isCustomWpt() || hard < 0) ? "" : sHard.substring(0, 1));
+			varParams.put("TERRAIN", (isCustomWpt() || terrain < 0) ? "" : decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
 			String sTerrain = Integer.toString(terrain);
-			varParams.put("SHORTTERRAIN", (isCustomWpt() || terrain < 0)?"":sTerrain);
-			varParams.put("SHTERRAIN", (isCustomWpt() || terrain < 0)?"":sTerrain.substring(0,1));
+			varParams.put("SHORTTERRAIN", (isCustomWpt() || terrain < 0) ? "" : sTerrain);
+			varParams.put("SHTERRAIN", (isCustomWpt() || terrain < 0) ? "" : sTerrain.substring(0, 1));
 			varParams.put("SIZE", CacheSize.cw2ExportString(cacheSize));
 			varParams.put("SHORTSIZE", CacheSize.getExportShortId(cacheSize));
 			varParams.put("OWNER", (ModTyp == 0) ? SafeXML.cleanGPX(cacheOwner) : cacheOwner);
@@ -650,48 +643,52 @@
 		}
 		if (isCustomWpt()) {
 
-		}		
-		varParams.put("WAYPOINT", wayPoint); //<name>
+		}
+		varParams.put("WAYPOINT", wayPoint); // <name>
 		int wpl = wayPoint.length();
 		int wps = (wpl < shortWaypointLength) ? 0 : wpl - shortWaypointLength;
 		varParams.put("SHORTWAYPOINT", wayPoint.substring(wps, wpl));
 		varParams.put("DISTANCE", decSep.replaceAll(getDistance()));
 		varParams.put("BEARING", bearing);
-		if ((pos!=null && pos.isValid())) {
-			varParams.put("LATLON", decSep.replaceAll(LatLon));
+		if ((pos != null && pos.isValid())) {
+			varParams.put("LATLON", decSep.replaceAll(pos.toString()));
 			varParams.put("LAT", decSep.replaceAll(pos.getLatDeg(CWPoint.DD)));
-			varParams.put("LON", decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));		
-		}
-		else {
+			varParams.put("LON", decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));
+		} else {
 			varParams.put("LATLON", "unknown");
 			varParams.put("LAT", "");
-			varParams.put("LON", "");		
+			varParams.put("LON", "");
 		}
 		if (withFoundText) {
-			varParams.put("STATUS",getStatusText());
-		}
-		else
+			varParams.put("STATUS", getStatusText());
+		} else
 			varParams.put("STATUS", cacheStatus);
 		varParams.put("GC_LOGTYPE", getGCLogType());
 		varParams.put("STATUS_DATE", getStatusDate());
 		varParams.put("STATUS_TIME", getStatusTime());
 		varParams.put("CACHE_NAME", cacheName);
-		if (codec instanceof AsciiCodec) { cacheName=Exporter.simplifyString(cacheName);} // use for "NAME"
-		if (badChars != null) { cacheName=badChars.replaceAll(cacheName); } // use for "NAME"
-		varParams.put("NAME", cacheName); // !!! cacheName used twice
-		String shortName=shortenName(cacheName, shortNameLength);
+		String cn = cacheName;
+		if (codec instanceof AsciiCodec) {
+			cn = Exporter.simplifyString(cacheName);
+		} // use for "NAME"
+		if (badChars != null) {
+			cn = badChars.replaceAll(cacheName);
+		} // use for "NAME"
+		varParams.put("NAME", cn);
+		String shortName = shortenName(cn, shortNameLength);
 		varParams.put("SHORTNAME", shortName);
-		varParams.put("TRAVELBUG", (bugs?"Y":"N"));
-		if (gm!=null) varParams.put("GMTYPE", gm.getIcon(this));
-		varParams.put("NOW_DATE",nowdate().setToCurrentTime().toString());
-		varParams.put("NOW_TIME",nowtime().setToCurrentTime().toString());
+		varParams.put("TRAVELBUG", (bugs ? "Y" : "N"));
+		if (gm != null)
+			varParams.put("GMTYPE", gm.getIcon(this));
+		varParams.put("NOW_DATE", nowdate().setToCurrentTime().toString());
+		varParams.put("NOW_TIME", nowtime().setToCurrentTime().toString());
 		varParams.put("CACHEID", GetCacheID());
 		varParams.put("AVAILABLE", available ? "TRUE" : "FALSE");
 		varParams.put("ARCHIVED", archived ? "TRUE" : "FALSE");
 		varParams.put("HTML", html ? "TRUE" : "FALSE");
 		varParams.put("VOTE", getRecommended());
-		//() ? TRUE : FALSE
-		if (det == null){
+		// () ? TRUE : FALSE
+		if (det == null) {
 			varParams.put("URL", "");
 			varParams.put("DESCRIPTION", "");
 			varParams.put("NOTES", "");
@@ -699,145 +696,157 @@
 			varParams.put("DECRYPTEDHINTS", "");
 			varParams.put("COUNTRY", "");
 			varParams.put("STATE", "");
-		}
-		else {
+		} else {
 			varParams.put("URL", det.URL);
 			if (html) {
 				if (ModTyp == 0) {
-					varParams.put("DESCRIPTION",SafeXML.cleanGPX(det.LongDescription));
-				}
-				else {
+					varParams.put("DESCRIPTION", SafeXML.cleanGPX(det.LongDescription));
+				} else {
 					varParams.put("DESCRIPTION", modifyLongDesc(det, ModTyp));
 				}
 			} else {
-				 // what was the reason? replace or no replace? I dont remember
-				varParams.put("DESCRIPTION",STRreplace.replace(det.LongDescription, "\n", "<br>"));
+				// what was the reason? replace or no replace? I dont remember
+				varParams.put("DESCRIPTION", STRreplace.replace(det.LongDescription, "\n", "<br>"));
 			}
-			
+
 			if (badChars != null) {
-				if (ModTyp == 0){
-					varParams.put("NOTES",badChars.replaceAll(det.getCacheNotes()));
+				if (ModTyp == 0) {
+					varParams.put("NOTES", badChars.replaceAll(det.getCacheNotes()));
+				} else {
+					varParams.put("NOTES", STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), "\n", "<br>"));
 				}
-				else {
-					varParams.put("NOTES",STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), "\n", "<br>"));
-				}
-				varParams.put("HINTS",(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
-				varParams.put("DECRYPTEDHINTS",(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
+				varParams.put("HINTS", (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
+				varParams.put("DECRYPTEDHINTS", (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
 			} else {
-				if (ModTyp == 0){
+				if (ModTyp == 0) {
 					varParams.put("NOTES", SafeXML.cleanGPX(det.getCacheNotes()));
-				}
-				else {
+				} else {
 					varParams.put("NOTES", STRreplace.replace(det.getCacheNotes(), "\n", "<br>"));
 				}
-				varParams.put("HINTS",(ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
-				varParams.put("DECRYPTEDHINTS",(ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
+				varParams.put("HINTS", (ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
+				varParams.put("DECRYPTEDHINTS", (ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
 			}
-			if (det.Travelbugs.size()>0) varParams.put("BUGS",(ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
-			if (det.getSolver()!=null && det.getSolver().trim().length()>0) 
-				varParams.put("SOLVER", STRreplace.replace(det.getSolver(),"\n","<br/>\n"));
+			if (det.Travelbugs.size() > 0)
+				varParams.put("BUGS", (ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
+			if (det.getSolver() != null && det.getSolver().trim().length() > 0)
+				varParams.put("SOLVER", STRreplace.replace(det.getSolver(), "\n", "<br/>\n"));
 			varParams.put("COUNTRY", det.Country);
 			varParams.put("STATE", det.State);
-			
+
 			// attributes
-			Vector attVect=new Vector(det.attributes.count()+1);
-			for (int i=0; i<det.attributes.count(); i++) {
-				Hashtable atts=new Hashtable();
+			Vector attVect = new Vector(det.attributes.count() + 1);
+			for (int i = 0; i < det.attributes.count(); i++) {
+				Hashtable atts = new Hashtable();
 				atts.put("PATHANDIMAGE", det.attributes.getAttribute(i).getPathAndImageName());
 				atts.put("IMAGE", det.attributes.getAttribute(i).getImageName());
 				atts.put("GCID", det.attributes.getAttribute(i).getGCId());
 				atts.put("INC", "" + det.attributes.getAttribute(i).getInc());
-				atts.put("INC2TXT", det.attributes.getAttribute(i).getInc()==1 ? "YES:" : "NO:");
-				if (i % 5 ==4)
-					atts.put("BR","<br/>");
+				atts.put("INC2TXT", det.attributes.getAttribute(i).getInc() == 1 ? "YES:" : "NO:");
+				if (i % 5 == 4)
+					atts.put("BR", "<br/>");
 				else
-					atts.put("BR","");
-				atts.put("INFO",det.attributes.getAttribute(i).getMsg());
-				atts.put("GCINFO",det.attributes.getAttribute(i).getGCText());
+					atts.put("BR", "");
+				atts.put("INFO", det.attributes.getAttribute(i).getMsg());
+				atts.put("GCINFO", det.attributes.getAttribute(i).getGCText());
 				attVect.add(atts);
 			}
-			varParams.put("ATTRIBUTES",attVect);
-			
+			varParams.put("ATTRIBUTES", attVect);
+
 			// logs
-			Vector logVect=new Vector(det.CacheLogs.size());
+			Vector logVect = new Vector(det.CacheLogs.size());
 			int maxlogs = det.CacheLogs.size();
-			if (nrOfLogs > -1 && nrOfLogs < maxlogs ) maxlogs=nrOfLogs;
-			for (int i=0; i<maxlogs; i++) {
-				Hashtable logs=new Hashtable();
+			if (nrOfLogs > -1 && nrOfLogs < maxlogs)
+				maxlogs = nrOfLogs;
+			for (int i = 0; i < maxlogs; i++) {
+				Hashtable logs = new Hashtable();
 				String stmp;
 				if (det.CacheLogs.getLog(i).getIcon().equals("MAXLOG")) {
 					logs.put("WAYPOINT", wayPoint);
-					logs.put("ICON","");
-					logs.put("LOGTYPE","");
+					logs.put("ICON", "");
+					logs.put("LOGTYPE", "");
 					logs.put("DATE", "");
 					logs.put("LOGGER", "");
-					stmp = "<hr>"+MyLocale.getMsg(736,"Too many logs")+"<hr>";
-				}
-				else {
+					stmp = "<hr>" + MyLocale.getMsg(736, "Too many logs") + "<hr>";
+				} else {
 					logs.put("WAYPOINT", wayPoint);
-					logs.put("ICON",det.CacheLogs.getLog(i).getIcon());
-					logs.put("LOGTYPE",image2TypeText(det.CacheLogs.getLog(i).getIcon()));
+					logs.put("ICON", det.CacheLogs.getLog(i).getIcon());
+					logs.put("LOGTYPE", image2TypeText(det.CacheLogs.getLog(i).getIcon()));
 					logs.put("DATE", det.CacheLogs.getLog(i).getDate());
 					logs.put("LOGGER", (ModTyp == 0) ? SafeXML.cleanGPX(det.CacheLogs.getLog(i).getLogger()) : det.CacheLogs.getLog(i).getLogger());
-					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(),"http://www.geocaching.com/images/icons/",null);
+					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(), "http://www.geocaching.com/images/icons/", null);
 				}
 				logs.put("MESSAGE", (ModTyp == 0) ? SafeXML.cleanGPX(stmp) : stmp);
 				logVect.add(logs);
 			}
-			varParams.put("LOGS",logVect);
+			varParams.put("LOGS", logVect);
 
-			Vector addiVect=new Vector(addiWpts.size());
-			for (int i=0; i<addiWpts.size(); i++) {
-				Hashtable addis=new Hashtable();
-				CacheHolder ch=(CacheHolder) addiWpts.get(i);
-				addis.put("WAYPOINT",ch.getWayPoint());
-				addis.put("NAME",(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
-				if ((ch.pos!=null && ch.pos.isValid())) {
-					addis.put("LATLON",decSep.replaceAll(ch.pos.toString()));
-					addis.put("LAT",decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
-					addis.put("LON",decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
-				}
-				else {
+			Vector addiVect = new Vector(addiWpts.size());
+			for (int i = 0; i < addiWpts.size(); i++) {
+				Hashtable addis = new Hashtable();
+				CacheHolder ch = (CacheHolder) addiWpts.get(i);
+				addis.put("WAYPOINT", ch.getWayPoint());
+				addis.put("NAME", (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
+				if ((ch.pos != null && ch.pos.isValid())) {
+					addis.put("LATLON", decSep.replaceAll(ch.pos.toString()));
+					addis.put("LAT", decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
+					addis.put("LON", decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
+				} else {
 					addis.put("LATLON", "unknown");
 					addis.put("LAT", "");
-					addis.put("LON", "");		
+					addis.put("LON", "");
 				}
-				addis.put("IMG",CacheType.typeImageForId(ch.getType()));
-				addis.put("ICON",""+ch.getType());
+				addis.put("IMG", CacheType.typeImageForId(ch.getType()));
+				addis.put("ICON", "" + ch.getType());
 				addis.put("TYPENAME", CacheType.type2Gui(ch.getType()));
-				addis.put("TYPE", CacheType.type2TypeTag(ch.getType())); //<type>
-				addis.put("SYM", CacheType.type2SymTag(ch.getType())); //<sym>
-				addis.put("GSTYPE", CacheType.type2GSTypeTag(ch.getType())); //<groundspeak:type>
-				addis.put("LONGDESC",(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
+				addis.put("TYPE", CacheType.type2TypeTag(ch.getType())); // <type>
+				addis.put("SYM", CacheType.type2SymTag(ch.getType())); // <sym>
+				addis.put("GSTYPE", CacheType.type2GSTypeTag(ch.getType())); // <groundspeak:type>
+				addis.put("LONGDESC", (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
 				addiVect.add(addis);
 			}
-			varParams.put("ADDIS",addiVect);
-			
-			Vector imgVect=new Vector(det.images.size());
-			for (int i=0; i<det.images.size(); i++) {
-				Hashtable imgs=new Hashtable();
+			varParams.put("ADDIS", addiVect);
+
+			Vector imgVect = new Vector(det.images.size());
+			for (int i = 0; i < det.images.size(); i++) {
+				Hashtable imgs = new Hashtable();
 				String imgFile = det.images.get(i).getFilename();
-				imgs.put("FILENAME",imgFile);
-				imgs.put("TEXT",det.images.get(i).getTitle());
-				imgs.put("COMMENT",det.images.get(i).getComment());
-				imgs.put("URL",det.images.get(i).getURL());
-				if (!expName.equals("")) {
-					String src = Global.getProfile().dataDir + imgFile;
-					String dest = Global.getPref().getExportPath(expName) + imgFile;
-					if (!DataMover.copy(src,dest)) {
-						Global.getPref().log("[CacheHolder:toHashtable]error copying "+imgFile+" to "+Global.getPref().getExportPath(expName));
+				boolean doit = true;
+				for (int j = i + 1; j < det.images.size(); j++) {
+					String jmgFile = det.images.get(j).getFilename();
+					if (imgFile.equals(jmgFile)) {
+						doit = false;
+						break;
 					}
 				}
-				imgVect.add(imgs);
+				if (doit) {
+					imgs.put("FILENAME", imgFile);
+					String title = det.images.get(i).getTitle();
+					imgs.put("TEXT", title);
+					String comment = det.images.get(i).getComment();
+					imgs.put("COMMENT", comment);
+					imgs.put("URL", det.images.get(i).getURL());
+					if (!expName.equals("")) {
+						String src = Global.getProfile().dataDir + imgFile;
+						String dest = Global.getPref().getExportPath(expName) + imgFile;
+						if (!DataMover.copy(src, dest)) {
+							Global.getPref().log("[CacheHolder:toHashtable]error copying " + imgFile + " to " + Global.getPref().getExportPath(expName));
+						}
+					}
+					if (!title.toLowerCase().startsWith(wayPoint.toLowerCase())) {
+						imgVect.add(imgs);
+					}
+				}
 			}
-			varParams.put("cacheImg",imgVect);
+			varParams.put("cacheImg", imgVect);
 		}
 		return varParams;
-	}	
+	}
 
 	/**
 	 * generate a gc.com compatible string representation of log derived from the internally stored image
-	 * @param image name of the image to display
+	 * 
+	 * @param image
+	 *            name of the image to display
 	 * @return log type. will default to "Write note" for unknown logtypes
 	 */
 	public static final String image2TypeText(String image) {
@@ -877,36 +886,43 @@
 	}
 
 	/**
-	 * Modify the image links in the long description so that they point to image files in the local directory
-	 * Also copy the image file to the target directory so that it can be displayed.
-	 * @param chD CacheHolderDetail
+	 * Modify the image links in the long description so that they point to image files in the local directory Also copy the image file to the target directory so that it can be displayed.
+	 * 
+	 * @param chD
+	 *            CacheHolderDetail
 	 * @param int ModTypLongDesc == 1 get image from profile path, == 2 get image from html-path
 	 * @return The modified long description
 	 */
 	private String modifyLongDesc(CacheHolderDetail chD, int ModTypLongDesc) {
-		StringBuffer s=new StringBuffer(chD.LongDescription.length());
-		int start=0;
+		StringBuffer s = new StringBuffer(chD.LongDescription.length());
+		int start = 0;
 		int pos;
-		int imageNo=0;
-		String imgsrc="";
-		if (ModTypLongDesc==1) imgsrc="file://"+Global.getProfile().dataDir;
-		while (start>=0 && (pos=chD.LongDescription.indexOf("<img",start))>0) {
-			if (imageNo >= chD.images.size()) break;
-			s.append(chD.LongDescription.substring(start,pos));
-			start=chD.LongDescription.indexOf(">",pos)+1;
-			String oldurl=chD.images.get(imageNo).getURL();
-			String imgString=chD.LongDescription.substring(pos, start);
-			if (imgString.indexOf(oldurl)==-1) {
+		int imageNo = 0;
+		String imgsrc = "";
+		if (ModTypLongDesc == 1)
+			imgsrc = "file://" + Global.getProfile().dataDir;
+		while (start >= 0 && (pos = chD.LongDescription.indexOf("<img", start)) > 0) {
+			if (imageNo >= chD.images.size())
+				break;
+			s.append(chD.LongDescription.substring(start, pos));
+			start = chD.LongDescription.indexOf(">", pos) + 1;
+			String oldurl = chD.images.get(imageNo).getURL();
+			String imgString = chD.LongDescription.substring(pos, start);
+			imgString = STRreplace.replace(imgString, "\n", "");
+			imgString = STRreplace.replace(imgString, "\r", "");
+			imgString = STRreplace.replace(imgString, "groundspeak", "geocaching");
+			if (imgString.indexOf(oldurl) == -1) {
 				if (oldurl.startsWith("http://")) {
-					int i = oldurl.indexOf("/", 7)+1;
-					oldurl=oldurl.substring(i);
+					int i = oldurl.indexOf("/", 7) + 1;
+					oldurl = oldurl.substring(i);
 				}
 			}
-			String newurl=imgsrc+chD.images.get(imageNo).getFilename();
-			s.append(STRreplace.replace(imgString,oldurl,newurl));
+			String newurl = imgsrc + chD.images.get(imageNo).getFilename();
+			s.append(STRreplace.replace(imgString, oldurl, newurl));
 			imageNo++;
 		}
-		if (start>=0) s.append(chD.LongDescription.substring(start));
+		if (start >= 0)
+			s.append(chD.LongDescription.substring(start));
 		return s.toString();
 	}
 
@@ -914,56 +930,61 @@
 		Time nd = new Time();
 		return nd.setFormat("yyyy-MM-dd");
 	}
+
 	private final static Time nowtime() {
 		Time nt = new Time();
 		return nt.setFormat("HH:mm");
 	}
 
-	private final static String selbstLaute="aeiouAEIOU";
+	private final static String selbstLaute = "aeiouAEIOU";
+
 	private final static String mitLauteKlein() {
-		final StringBuffer lower=new StringBuffer(26);// region/language dependent ?
-		for (int i=97; i<=122; i++ ) {
+		final StringBuffer lower = new StringBuffer(26);// region/language dependent ?
+		for (int i = 97; i <= 122; i++) {
 			lower.append((char) i);
 		}
 		return lower.toString();
 	}
+
 	public String shortenName(String Name, int maxLength) {
-		String shortName=removeCharsfromString(Name, maxLength, selbstLaute);
-		return  removeCharsfromString(shortName, maxLength, mitLauteKlein());
+		String shortName = removeCharsfromString(Name, maxLength, selbstLaute);
+		return removeCharsfromString(shortName, maxLength, mitLauteKlein());
 	}
-    private static String removeCharsfromString( String text, int MaxLength, String chars ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        int anzToRemove=originalTextLength-MaxLength;
-        if (anzToRemove<=0) return text;
-        int anzRemoved=0;
-        StringBuffer sb = new StringBuffer( 50 );
-        for ( int i = originalTextLength-1; i >= 0; i-- ) {
-            char c = text.charAt( i );
-            if (chars.indexOf(c) == -1) {
-            	sb.insert(0,c);
-            }
-            else {
-            	anzRemoved++;
-            	if (anzRemoved==anzToRemove) {
-            		sb.insert(0, text.substring(0,i));
-            		i=0; // exit for
-            	}
-            }
-        }
-        return sb.toString();
-    }
 
+	private static String removeCharsfromString(String text, int MaxLength, String chars) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		int anzToRemove = originalTextLength - MaxLength;
+		if (anzToRemove <= 0)
+			return text;
+		int anzRemoved = 0;
+		StringBuffer sb = new StringBuffer(50);
+		for (int i = originalTextLength - 1; i >= 0; i--) {
+			char c = text.charAt(i);
+			if (chars.indexOf(c) == -1) {
+				sb.insert(0, c);
+			} else {
+				anzRemoved++;
+				if (anzRemoved == anzToRemove) {
+					sb.insert(0, text.substring(0, i));
+					i = 0; // exit for
+				}
+			}
+		}
+		return sb.toString();
+	}
+
 	/** return true if waypoint is an additional waypoint of a cache */
 	public boolean isAddiWpt() {
 		return CacheType.isAddiWpt(type);
 	}
-	
+
 	/** return true if waypoint is a custom waypoint */
 	public boolean isCustomWpt() {
 		return CacheType.isCustomWpt(type);
 	}
-	
+
 	/** return true if waypoint is a cache main waypoint */
 	public boolean isCacheWpt() {
 		return CacheType.isCacheWpt(type);
@@ -971,15 +992,15 @@
 
 	/** return true waypoint has one or more additional waypoints */
 	public boolean hasAddiWpt() {
-		return addiWpts.getCount()>0;
+		return addiWpts.getCount() > 0;
 	}
 
 	public boolean isOC() {
 		return OC.isOC(wayPoint);
 	}
 
-	public void calcDistance(CWPoint toPoint) {	
-		if(pos.isValid()){
+	public void calcDistance(CWPoint toPoint) {
+		if (pos.isValid()) {
 			kilom = pos.getDistance(toPoint);
 			degrees = toPoint.getBearing(pos);
 			bearing = CWPoint.getDirection(degrees);
@@ -989,7 +1010,7 @@
 		}
 	}
 
-	public void setAttributesFromMainCache(){
+	public void setAttributesFromMainCache() {
 		CacheHolder mainCh = this.mainCache;
 		this.setCacheOwner(mainCh.getCacheOwner());
 		if (mainCh.is_found()) {
@@ -997,9 +1018,8 @@
 				this.setCacheStatus(mainCh.getCacheStatus());
 				this.setFound(true);
 			}
-			// else addi is already found (perhaps at other time) 
-		}
-		else {
+			// else addi is already found (perhaps at other time)
+		} else {
 			// there may be a found addi , so don't overwrite
 			if ((this.getType() == CacheType.CW_TYPE_FINAL)) {
 				this.setCacheStatus(mainCh.getCacheStatus());
@@ -1013,10 +1033,10 @@
 		this.setNew(mainCh.is_new());
 	}
 
-	public void setAttributesToAddiWpts(){
-		if (this.hasAddiWpt()){
+	public void setAttributesToAddiWpts() {
+		if (this.hasAddiWpt()) {
 			CacheHolder addiWpt;
-			for (int i= this.addiWpts.getCount() - 1;  i>=0; i--){
+			for (int i = this.addiWpts.getCount() - 1; i >= 0; i--) {
 				addiWpt = (CacheHolder) this.addiWpts.get(i);
 				addiWpt.setAttributesFromMainCache();
 			}
@@ -1024,39 +1044,46 @@
 	}
 
 	/**
-	 * True if ch and this belong to the same main cache. 
+	 * True if ch and this belong to the same main cache.
+	 * 
 	 * @param ch
 	 * @return
 	 */
 	public boolean hasSameMainCache(CacheHolder ch) {
-		if (this == ch) return true;
-		if (ch == null) return false;
-		if ((!this.isAddiWpt()) && (!ch.isAddiWpt())) return false;
+		if (this == ch)
+			return true;
+		if (ch == null)
+			return false;
+		if ((!this.isAddiWpt()) && (!ch.isAddiWpt()))
+			return false;
 		CacheHolder main1, main2;
-		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
-		if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
+		if (this.isAddiWpt())
+			main1 = this.mainCache;
+		else
+			main1 = this;
+		if (ch.isAddiWpt())
+			main2 = ch.mainCache;
+		else
+			main2 = ch;
 		return main1 == main2;
 	}
 
-	/** Find out of detail object of Cache is loaded. Returns <code>true</code> if this is the case.
+	/**
+	 * Find out of detail object of Cache is loaded. Returns <code>true</code> if this is the case.
+	 * 
 	 * @return True when details object is present
 	 */
 	public boolean detailsLoaded() {
-		return details!=null;
+		return details != null;
 	}
 
 	/**
-	 * Gets the detail object of a cache. The detail object stores information which is not needed
-	 * for every cache instantaneously, but can be loaded if the user decides to look at this cache.
-	 * If the cache object is already existing, the method will return this object, otherwise it 
-	 * will create it and try to read it from the corresponding <waypoint>.xml file.
-	 * Depending on the parameters it is allowed that the <waypoint>.xml file does not yet exist,
-	 * or the user is warned that the file doesn't exist.
-	 * If more than <code>maxdetails</code> details are loaded, then the 5 last recently loaded 
-	 * caches are unloaded (to save ram). 
+	 * Gets the detail object of a cache. The detail object stores information which is not needed for every cache instantaneously, but can be loaded if the user decides to look at this cache. If the cache object is already existing, the method will
+	 * return this object, otherwise it will create it and try to read it from the corresponding <waypoint>.xml file. Depending on the parameters it is allowed that the <waypoint>.xml file does not yet exist, or the user is warned that the file doesn't
+	 * exist. If more than <code>maxdetails</code> details are loaded, then the 5 last recently loaded caches are unloaded (to save ram).
+	 * 
 	 * @param alarmuser
-	 *            If true an error message will be displayed to the user, if the details could not
-	 *            be read, and the method returns null 
+	 *            If true an error message will be displayed to the user, if the details could not be read, and the method returns null
 	 * @return The respective CacheHolderDetail, or null
 	 */
 	public CacheHolderDetail getCacheDetails(boolean alarmuser) {
@@ -1066,9 +1093,8 @@
 				details.readCache(Global.getProfile().dataDir);
 			} catch (IOException e) {
 				if (alarmuser) {
-					//FIXME: put a message to languages file
-					(new MessageBox(MyLocale.getMsg(31415,"Error"), MyLocale.getMsg(31415, "Could not read cache details for cache: ")
-					        + this.getWayPoint(), FormBase.OKB)).execute();
+					// FIXME: put a message to languages file
+					(new MessageBox(MyLocale.getMsg(31415, "Error"), MyLocale.getMsg(31415, "Could not read cache details for cache: ") + this.getWayPoint(), FormBase.OKB)).execute();
 					// details = null;
 				}
 				this.setIncomplete(true);
@@ -1076,111 +1102,115 @@
 			// for importing/spidering reasons helper objects with same waypoint are created
 			if (details != null && !cachesWithLoadedDetails.contains(this)) {
 				cachesWithLoadedDetails.add(this);
-				if (cachesWithLoadedDetails.size() >= Global.getPref().maxDetails) removeOldestDetails();
+				if (cachesWithLoadedDetails.size() >= Global.getPref().maxDetails)
+					removeOldestDetails();
 			}
 		}
 		return details;
 	}
 
 	/**
-	 * Saves the cache to the corresponding <waypoint>.xml file, located in the profiles
-	 * directory. The waypoint of the 
-	 * cache should be set to do so.
+	 * Saves the cache to the corresponding <waypoint>.xml file, located in the profiles directory. The waypoint of the cache should be set to do so.
 	 */
 	public void save() {
 		checkIncomplete();
 		this.getCacheDetails(false).saveCacheDetails(Global.getProfile().dataDir);
 	}
-	
+
 	void releaseCacheDetails() {
-		if (details != null && details.hasUnsavedChanges){
+		if (details != null && details.hasUnsavedChanges) {
 			details.saveCacheDetails(Global.getProfile().dataDir);
 		}
 		details = null;
 		cachesWithLoadedDetails.remove(this);
 	}
 
-	//final static int maxDetails = 50; 
+	// final static int maxDetails = 50;
 	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
 
 	public static void removeOldestDetails() {
 		CacheHolder ch;
-		for (int i=0; i<Global.getPref().deleteDetails; i++) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-	//		CacheHolder ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = 0; i < Global.getPref().deleteDetails; i++) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null) ch.releaseCacheDetails();
-		}	
+			if (ch != null)
+				ch.releaseCacheDetails();
+		}
 	}
 
 	public static void removeAllDetails() {
 		CacheHolder ch;
-		for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--) {
+		for (int i = cachesWithLoadedDetails.size() - 1; i >= 0; i--) {
 			// String wp = (String) cachesWithLoadedDetails.get(i);
 			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null && ch.detailsLoaded()) ch.releaseCacheDetails();
+			if (ch != null && ch.detailsLoaded())
+				ch.releaseCacheDetails();
 		}
 	}
 
 	/**
-	 * when importing caches you can set details.saveChanges = true
-	 * when the import is finished call this method to save the pending changes
+	 * when importing caches you can set details.saveChanges = true when the import is finished call this method to save the pending changes
 	 */
 	public static void saveAllModifiedDetails() {
 		CacheHolder ch;
 		CacheHolderDetail chD;
-		for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-//			ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = cachesWithLoadedDetails.size() - 1; i >= 0; i--) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
 			if (ch != null) {
-	            chD = ch.getCacheDetails(true);
-	            if (chD!=null && chD.hasUnsavedChanges) {
-		            //ch.calcRecommendationScore();
-		            chD.saveCacheDetails(Global.getProfile().dataDir);
-	            }
-            }
+				chD = ch.getCacheDetails(true);
+				if (chD != null && chD.hasUnsavedChanges) {
+					// ch.calcRecommendationScore();
+					chD.saveCacheDetails(Global.getProfile().dataDir);
+				}
+			}
 		}
 	}
-	
+
 	public String getFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		return MyLocale.getMsg(msgNr, "Found");
 	}
+
 	public String getGCFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		for (int i = 0; i < _logType.length; i++) {
-			if ((""+msgNr).equals(_logType[i][MSG_NR])) {
+			if (("" + msgNr).equals(_logType[i][MSG_NR])) {
 				return _logType[i][GC_MSG];
-			}			
+			}
 		}
 		return "";
 	}
+
 	public String getCWLogText(String s) {
 		for (int i = 0; i < _logType.length; i++) {
 			if ((s).equals(_logType[i][GC_MSG])) {
-				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),"");
-			}			
+				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), "");
+			}
 		}
 		return "";
 	}
-	
+
 	public String getStatusText() {
-		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) &&
-				cacheStatus.charAt(4) == '-') {
-			return getFoundText() + " " + cacheStatus;			
+		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) && cacheStatus.charAt(4) == '-') {
+			return getFoundText() + " " + cacheStatus;
 		} else {
 			if (found) {
 				return getFoundText();
-			}
-			else {
+			} else {
 				return cacheStatus;
 			}
 		}
@@ -1188,137 +1218,119 @@
 
 	public String getStatusDate() {
 		String statusDate = "";
-		
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,"not found"))>10) {
-			Regex rexDate=new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
+
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, "not found")) > 10) {
+			Regex rexDate = new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
 			rexDate.search(getCacheStatus());
-			if (rexDate.stringMatched(1)!= null) {
+			if (rexDate.stringMatched(1) != null) {
 				statusDate = rexDate.stringMatched(1);
 			}
 		}
 
-		return statusDate;		
+		return statusDate;
 	}
-	
+
 	public String getStatusTime() {
 		String statusTime = "";
 
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,"not found"))>10) {
-			Regex rexTime=new Regex("([0-9]{1,2}:[0-9]{2})");
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, "not found")) > 10) {
+			Regex rexTime = new Regex("([0-9]{1,2}:[0-9]{2})");
 			rexTime.search(getCacheStatus());
-			if (rexTime.stringMatched(1)!= null) {
+			if (rexTime.stringMatched(1) != null) {
 				statusTime = rexTime.stringMatched(1);
-			}
-			else {
-				Regex rexDate=new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
+			} else {
+				Regex rexDate = new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
 				rexDate.search(getCacheStatus());
-				if (rexDate.stringMatched(1)!= null) {
+				if (rexDate.stringMatched(1) != null) {
 					statusTime = "00:00";
 				}
 			}
 		}
 
-		return statusTime;		
+		return statusTime;
 	}
-		
+
 	public String GetCacheID() {
 		String result = "";
-		String pattern = getWayPoint().toUpperCase();
+		String pattern = wayPoint.toUpperCase();
 
-		if ( pattern.startsWith( "GC" ) ) {
+		if (pattern.startsWith("GC")) {
 			int gcId = 0;
 
 			String sequence = "0123456789ABCDEFGHJKMNPQRTVWXYZ";
-			
-			String rightPart = getWayPoint().substring( 2 ).toUpperCase();
-			
+
+			String rightPart = getWayPoint().substring(2).toUpperCase();
+
 			int base = 31;
 			if ((rightPart.length() < 4) || (rightPart.length() == 4 && sequence.indexOf(rightPart.charAt(0)) < 16)) {
 				base = 16;
 			}
-			
-			for ( int p = 0; p < rightPart.length(); p++ ) {
+
+			for (int p = 0; p < rightPart.length(); p++) {
 				gcId *= base;
 				gcId += sequence.indexOf(rightPart.charAt(p));
 			}
-			
-	        if ( base == 31 ) {
-	        	gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
-	        }
-	        
-	        result = Integer.toString(gcId);	        
+
+			if (base == 31) {
+				gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
+			}
+
+			result = Integer.toString(gcId);
 		} else if (isOC()) {
-        	result = getOcCacheID();
-        }
+			result = getOcCacheID();
+		}
 
 		return result;
 	}
 
-	private final static int MSG_NR = 0; 
-	private final static int GC_MSG = 1; 
-	private final static int IDX_WRITENOTE = 5; 	
-	private final static String[][] _logType = {	
-			{"353", ""},
-			{"318", "Found it"},
-			{"355", "Attended"},
-			{"361", "Webcam Photo Taken"},
-			{"319", "Didn't find it"},
-			{"314", "Write note"}, // at change do change IDX_WRITENOTE = 5;
-			{"315", "Needs Archived"},
-			{"316", "Needs Maintenance"},
-			{"317", "Search"}, 
-			{"354", "Will Attend"},
-			{"320", "Owner"},
-			{"359", "Owner Maintenance"},
-			{"356", "Temporarily Disable Listing"},
-			{"357", "Enable Listing"},
-			{"358", "Post Reviewer Note"},
-			{"362", "Solved"},
-			{"313", "Flag 1"},
-			{"360", "Flag 2"},
-	};
+	private final static int MSG_NR = 0;
+	private final static int GC_MSG = 1;
+	private final static int IDX_WRITENOTE = 5;
+	private final static String[][] _logType = { { "353", "" }, { "318", "Found it" }, { "355", "Attended" }, { "361", "Webcam Photo Taken" }, { "319", "Didn't find it" },
+			{ "314", "Write note" }, // at change do change IDX_WRITENOTE = 5;
+			{ "315", "Needs Archived" }, { "316", "Needs Maintenance" }, { "317", "Search" }, { "354", "Will Attend" }, { "320", "Owner" }, { "359", "Owner Maintenance" }, { "356", "Temporarily Disable Listing" }, { "357", "Enable Listing" },
+			{ "358", "Post Reviewer Note" }, { "362", "Solved" }, { "313", "Flag 1" }, { "360", "Flag 2" }, };
 
 	public final static String[] GetGuiLogTypes() {
 		String[] ret = new String[_logType.length];
 		for (int i = 0; i < _logType.length; i++) {
-			ret[i]=MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),"");
+			ret[i] = MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), "");
 		}
 		return ret;
 	}
-	
-	public String getGCLogType() {                                                                                
-		String gcLogType=_logType[IDX_WRITENOTE][GC_MSG];
+
+	public String getGCLogType() {
+		String gcLogType = _logType[IDX_WRITENOTE][GC_MSG];
 		if (is_found()) {
-			String msgNr="318"; // normal found			
-			if (type == CacheType.CW_TYPE_WEBCAM) { msgNr="361";}
-			else if (type == CacheType.CW_TYPE_EVENT 
-					|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr="355";}
+			String msgNr = "318"; // normal found
+			if (type == CacheType.CW_TYPE_WEBCAM) {
+				msgNr = "361";
+			} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+				msgNr = "355";
+			}
 			for (int i = 1; i < _logType.length; i++) {
 				if (_logType[i][MSG_NR].equals(msgNr)) {
-					gcLogType = _logType[i][GC_MSG]; 
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
-		}
-		else {
-			String CacheStatus=getCacheStatus();  
+		} else {
+			String CacheStatus = getCacheStatus();
 			for (int i = 1; i < _logType.length; i++) {
-				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),""))) {
-					gcLogType=_logType[i][GC_MSG];
+				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), ""))) {
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
 		}
-		return gcLogType;    
-	}                                                                                                             
-	
-	
-	
+		return gcLogType;
+	}
+
 	/**
-	 * Initializes the caches states (and its addis) before updating, so that the "new", "updated",
-	 * "log_updated" and "incomplete" properties are properly set. 
-	 * @param pNewCache <code>true</code> if it is a new cache (i.e. a cache not existing in CacheDB),
-	 * <code>false</code> otherwise.
+	 * Initializes the caches states (and its addis) before updating, so that the "new", "updated", "log_updated" and "incomplete" properties are properly set.
+	 * 
+	 * @param pNewCache
+	 *            <code>true</code> if it is a new cache (i.e. a cache not existing in CacheDB), <code>false</code> otherwise.
 	 */
 	public void initStates(boolean pNewCache) {
 		this.setNew(pNewCache);
@@ -1326,59 +1338,43 @@
 		this.setLog_updated(false);
 		this.setIncomplete(false);
 		if (!pNewCache && this.hasAddiWpt()) {
-			for (int i=0; i<this.addiWpts.size(); i++) {
-				((CacheHolder)this.addiWpts.get(i)).initStates(pNewCache);
+			for (int i = 0; i < this.addiWpts.size(); i++) {
+				((CacheHolder) this.addiWpts.get(i)).initStates(pNewCache);
 			}
 		}
 	}
 
 	/**
-	 * Creates a bit field of boolean values of the cache, represented as a long value.
-	 * Boolean value of <code>true</code> results in <code>1</code> in the long values bits,
-	 * and, vice versa, 0 for false.
+	 * Creates a bit field of boolean values of the cache, represented as a long value. Boolean value of <code>true</code> results in <code>1</code> in the long values bits, and, vice versa, 0 for false.
+	 * 
 	 * @return long value representing the boolean bit field
 	 */
 	private long boolFields2long() {
 		// To get the same list of visible caches after loading a profile,
-		// the property isVisible() is saved instead of is_filtered(), but at 
+		// the property isVisible() is saved instead of is_filtered(), but at
 		// the place where is_filtered() is read.
-		long value = bool2BitMask(!this.isVisible(), 1)     | 
-		             bool2BitMask(this.is_available(), 2)   |
-		             bool2BitMask(this.is_archived(), 3)    |
-		             bool2BitMask(this.has_bugs(), 4)       |
-		             bool2BitMask(this.is_black(), 5)       |
-		             bool2BitMask(this.is_owned(), 6)       |
-		             bool2BitMask(this.is_found(), 7)       |
-		             bool2BitMask(this.is_new(), 8)         |
-		             bool2BitMask(this.is_log_updated(), 9) |
-		             bool2BitMask(this.is_updated(), 10)    |
-		             bool2BitMask(this.is_HTML(), 11)       |
-		             bool2BitMask(this.is_incomplete(), 12) |
-		             bool2BitMask(this.hasNote(), 13)       |
-		             bool2BitMask(this.hasSolver(), 14);		             
+		long value = bool2BitMask(!this.isVisible(), 1) | bool2BitMask(this.is_available(), 2) | bool2BitMask(this.is_archived(), 3) | bool2BitMask(this.has_bugs(), 4) | bool2BitMask(this.is_black(), 5) | bool2BitMask(this.is_owned(), 6)
+				| bool2BitMask(this.is_found(), 7) | bool2BitMask(this.is_new(), 8) | bool2BitMask(this.is_log_updated(), 9) | bool2BitMask(this.is_updated(), 10) | bool2BitMask(this.is_HTML(), 11) | bool2BitMask(this.is_incomplete(), 12)
+				| bool2BitMask(this.hasNote(), 13) | bool2BitMask(this.hasSolver(), 14);
 		return value;
 	}
 
 	/**
-	 * Creates a field of byte values of certain properties of the cache, represented
-	 * as a long value.
-	 * As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8
-	 * bits. The position indicates the group of bits where the byte is packed,
+	 * Creates a field of byte values of certain properties of the cache, represented as a long value. As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8 bits. The position indicates the group of bits where the byte is packed,
 	 * counting starting from one by the right side of the long.
+	 * 
 	 * @return long value representing the byte field
 	 */
 	private long byteFields2long() {
-		long value = byteBitMask(hard, 1)    | 
-		byteBitMask(terrain, 2)   |
-		byteBitMask(type, 3)    |
-		byteBitMask(cacheSize, 4)|
-		byteBitMask(this.noFindLogs, 5);		             
+		long value = byteBitMask(hard, 1) | byteBitMask(terrain, 2) | byteBitMask(type, 3) | byteBitMask(cacheSize, 4) | byteBitMask(this.noFindLogs, 5);
 		return value;
 	}
-	
+
 	/**
 	 * Evaluates byte values from a long value for certain properties of the cache.
-	 * @param value The long value which contains up to 8 bytes.
+	 * 
+	 * @param value
+	 *            The long value which contains up to 8 bytes.
 	 */
 	private void long2byteFields(long value) {
 		setHard(byteFromLong(value, 1));
@@ -1386,17 +1382,15 @@
 		setType(byteFromLong(value, 3));
 		setCacheSize(byteFromLong(value, 4));
 		setNoFindLogs((byteFromLong(value, 5)));
-		
-		if ( getHard() == CacheTerrDiff.CW_DT_ERROR 
-				|| getTerrain() == CacheTerrDiff.CW_DT_ERROR 
-				|| getCacheSize() == CacheSize.CW_SIZE_ERROR 
-				|| getType() == CacheType.CW_TYPE_ERROR ) {
+
+		if (getHard() == CacheTerrDiff.CW_DT_ERROR || getTerrain() == CacheTerrDiff.CW_DT_ERROR || getCacheSize() == CacheSize.CW_SIZE_ERROR || getType() == CacheType.CW_TYPE_ERROR) {
 			setIncomplete(true);
 		}
 	}
-	
+
 	/**
 	 * convert a v2 byte filed to the current structures
+	 * 
 	 * @param value
 	 */
 	private void long2byteFieldsv2(long value) {
@@ -1408,11 +1402,14 @@
 		if (getHard() == -1 || getTerrain() == -1 || getCacheSize() == -1) {
 			if (isAddiWpt() || isCustomWpt()) {
 				// Addis don't have their own values for difficulty, terrain and size
-				// Custom waypoints can't be updated to remove incomplete flag, so we 
+				// Custom waypoints can't be updated to remove incomplete flag, so we
 				// have to set reasonable values.
-				if (getHard() == CacheTerrDiff.CW_DT_ERROR) setHard(CacheTerrDiff.CW_DT_UNSET);
-				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR) setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (getCacheSize() == CacheSize.CW_SIZE_ERROR) setCacheSize(CacheSize.CW_SIZE_NONE);
+				if (getHard() == CacheTerrDiff.CW_DT_ERROR)
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR)
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				if (getCacheSize() == CacheSize.CW_SIZE_ERROR)
+					setCacheSize(CacheSize.CW_SIZE_NONE);
 			} else {
 				setIncomplete(true);
 			}
@@ -1420,21 +1417,24 @@
 	}
 
 	/**
-	 * Extracts a byte from a long value. The position is the number of the 8-bit block
-	 * of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the
-	 * right side of the long.
-     * @param value The long value which contains the bytes
-     * @param position The position of the byte, from 1 to 8
-     * @return The decoded byte value
-     */
-    private byte byteFromLong(long value, int position) {
+	 * Extracts a byte from a long value. The position is the number of the 8-bit block of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the right side of the long.
+	 * 
+	 * @param value
+	 *            The long value which contains the bytes
+	 * @param position
+	 *            The position of the byte, from 1 to 8
+	 * @return The decoded byte value
+	 */
+	private byte byteFromLong(long value, int position) {
 		byte b = -1; // = 11111111
-	    return (byte)((value & this.byteBitMask(b, position))>>>(position-1)*8);
-    }
+		return (byte) ((value & this.byteBitMask(b, position)) >>> (position - 1) * 8);
+	}
 
 	/**
 	 * Evaluates boolean values from a long value, which is seen as bit field.
-	 * @param value The bit field as long value
+	 * 
+	 * @param value
+	 *            The bit field as long value
 	 */
 	private void long2boolFields(long value) {
 		this.setFiltered((value & this.bool2BitMask(true, 1)) != 0);
@@ -1452,57 +1452,49 @@
 		this.setHasNote((value & this.bool2BitMask(true, 13)) != 0);
 		this.setHasSolver((value & this.bool2BitMask(true, 14)) != 0);
 	}
-	
+
 	/**
-	 * Represents a bit mask as long value for a boolean value which is saved at
-	 * a specified position in the long field.
-	 * @param value The boolean value we want to code
-	 * @param position Position of the value in the bit mask
-	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for
-	 * the one we like to represent: This is 1 if the value is true, 0 if not. 
+	 * Represents a bit mask as long value for a boolean value which is saved at a specified position in the long field.
+	 * 
+	 * @param value
+	 *            The boolean value we want to code
+	 * @param position
+	 *            Position of the value in the bit mask
+	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for the one we like to represent: This is 1 if the value is true, 0 if not.
 	 */
 	private long bool2BitMask(boolean value, int position) {
 		if (value) {
-			return (1L << (position-1));
+			return (1L << (position - 1));
 		} else {
 			return 0L;
 		}
 	}
-	
+
 	/**
-	 * Coding a long field which has only the bits of the byte value set. The position is the 
-	 * number (from 1 to 8) of the byte block which is used from the long.
-	 * @param value Byte to encode
-	 * @param position Position of the byte value in the long
+	 * Coding a long field which has only the bits of the byte value set. The position is the number (from 1 to 8) of the byte block which is used from the long.
+	 * 
+	 * @param value
+	 *            Byte to encode
+	 * @param position
+	 *            Position of the byte value in the long
 	 * @return Encoded byte value as long
 	 */
 	private long byteBitMask(byte value, int position) {
-		long result = (0xFF & (long) value) << ((position-1) *8);
+		long result = (0xFF & (long) value) << ((position - 1) * 8);
 		return result;
 	}
 
-
 	/**
-	 * Returns <code>true</code> if the waypoint should appear in the cache list, 
-	 * <code>false</code> if it should not appear.<br>
-	 * The method takes into account blacklist, filters, search results - everything
-	 * that determines if a cache is visible in the list or not. 
+	 * Returns <code>true</code> if the waypoint should appear in the cache list, <code>false</code> if it should not appear.<br>
+	 * The method takes into account blacklist, filters, search results - everything that determines if a cache is visible in the list or not.
+	 * 
 	 * @return
 	 */
 	public boolean isVisible() {
 		Profile profile = Global.getProfile();
 		int filter = profile.getFilterActive();
-		boolean noShow=
-			(  (profile.showBlacklisted() != this.is_black())   
-				||
-			   (profile.showSearchResult() && !this.is_flaged)   
-			    ||
-			   ( (filter == Filter.FILTER_ACTIVE||filter == Filter.FILTER_MARKED_ONLY) &&	
-			  	 (this.is_filtered())^profile.isFilterInverted())                            
-			  	||
-			   (filter == Filter.FILTER_CACHELIST) && 
-			     !Global.mainForm.cacheList.contains(this.getWayPoint())
-			);
+		boolean noShow = ((profile.showBlacklisted() != this.is_black()) || (profile.showSearchResult() && !this.is_flaged) || ((filter == Filter.FILTER_ACTIVE || filter == Filter.FILTER_MARKED_ONLY) && (this.is_filtered()) ^ profile.isFilterInverted()) || (filter == Filter.FILTER_CACHELIST)
+				&& !Global.mainForm.cacheList.contains(this.getWayPoint()));
 		boolean showAddi = this.showAddis() && this.mainCache != null && this.mainCache.isVisible();
 		noShow = noShow && !showAddi;
 		return !noShow;
@@ -1510,198 +1502,215 @@
 
 	// Getter and Setter for private properties
 
-	public String getLatLon() { return LatLon; }
-	public void setLatLon(String _LatLon) {
-		_LatLon=_LatLon.trim();
-		if (!_LatLon.equals(LatLon.trim())) setUpdated(true);
-		LatLon = _LatLon;
-		pos.set(_LatLon);
+	public CWPoint getPos() {
+		return pos;
 	}
 
-	public String getBearing() {return bearing;}
-	
+	public void setPos(TrackPoint _pos) {
+		if (!_pos.toString().equals(pos.toString()))
+			setUpdated(true);
+		pos.set(_pos);
+	}
+
+	public String getBearing() {
+		return bearing;
+	}
+
 	/**
-	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the 
-	 * last call of the method, the same (cached) object is returned. If the object is
-	 * null or the level is different, a new object is created.<br> 
-	 * @param level 4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
-	 * @param fm Font metrics
+	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the last call of the method, the same (cached) object is returned. If the object is null or the level is different, a new object is created.<br>
+	 * 
+	 * @param level
+	 *            4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
+	 * @param fm
+	 *            Font metrics
 	 * @return New or old IconAndText object
 	 */
 	public IconAndText getIconAndTextWP(int level, FontMetrics fm) {
 		if (level != iconAndTextWPLevel || iconAndTextWP == null || !iconAndTextWP.text.equals(wayPoint)) {
 			switch (level) {
-				case 4: iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm); break;
-				case 3: iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm); break;
-				case 2: iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm); break;
-				case 1: iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm); break;
+			case 4:
+				iconAndTextWP = new IconAndText(CacheType.getTypeImage(CacheType.CW_TYPE_ERROR), wayPoint, fm);
+				break;
+			case 3:
+				iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm);
+				break;
+			case 2:
+				iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm);
+				break;
+			case 1:
+				iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm);
+				break;
 			}
 			iconAndTextWPLevel = level;
 		}
 		return iconAndTextWP;
 	}
-	
-	public String getCacheStatus() { return cacheStatus; }
 
+	public String getCacheStatus() {
+		return cacheStatus;
+	}
+
 	public void setCacheStatus(String cacheStatus) {
-        if (!cacheStatus.equals(this.cacheStatus)) {
-        	this.cacheStatus = cacheStatus;
-            Global.getProfile().notifyUnsavedChanges(true);		
-            this.cacheStatus = cacheStatus;
-            if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null) ) {
-              this.mainCache.setCacheStatus(this.getCacheStatus());
-              // change the addi's in setFound
-            }
-        }
+		if (!cacheStatus.equals(this.cacheStatus)) {
+			this.cacheStatus = cacheStatus;
+			Global.getProfile().notifyUnsavedChanges(true);
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null)) {
+				this.mainCache.setCacheStatus(this.getCacheStatus());
+				// change the addi's in setFound
+			}
+		}
 	}
 
 	public String getWayPoint() {
-    	return wayPoint;
-    }
+		return wayPoint;
+	}
 
 	public void setWayPoint(String wayPoint) {
-		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));		
-    	this.wayPoint = wayPoint;
-    }
+		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));
+		this.wayPoint = wayPoint;
+	}
 
 	public String getCacheName() {
-    	return cacheName;
-    }
+		return cacheName;
+	}
 
 	public void setCacheName(String cacheName) {
-		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));		
-    	this.cacheName = cacheName;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));
+		this.cacheName = cacheName;
+	}
 
 	public String getCacheOwner() {
-    	return cacheOwner;
-    }
+		return cacheOwner;
+	}
 
 	public void setCacheOwner(String cacheOwner) {
-		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));		
-    	this.cacheOwner = cacheOwner;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));
+		this.cacheOwner = cacheOwner;
+	}
 
 	public String getDateHidden() {
-    	return dateHidden;
-    }
+		return dateHidden;
+	}
 
 	public void setDateHidden(String dateHidden) {
-		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));		
-    	this.dateHidden = dateHidden;
-    }
+		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));
+		this.dateHidden = dateHidden;
+	}
 
 	public byte getCacheSize() {
-    	return cacheSize;
-    }
+		return cacheSize;
+	}
 
 	public void setCacheSize(byte cacheSize) {
-		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);		
-    	this.cacheSize = cacheSize;
-    }
+		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);
+		this.cacheSize = cacheSize;
+	}
 
 	public byte getHard() {
-    	return hard;
-    }
+		return hard;
+	}
 
 	public void setHard(byte hard) {
-		Global.getProfile().notifyUnsavedChanges(hard != this.hard);		
-    	this.hard = hard;
-    }
+		Global.getProfile().notifyUnsavedChanges(hard != this.hard);
+		this.hard = hard;
+	}
 
 	public byte getTerrain() {
-    	return terrain;
-    }
+		return terrain;
+	}
 
 	public void setTerrain(byte terrain) {
-		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);		
-    	this.terrain = terrain;
-    }
+		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);
+		this.terrain = terrain;
+	}
 
 	/**
 	 * Gets the type of cache as integer.
+	 * 
 	 * @return Cache type
 	 */
 	public byte getType() {
 		return type;
-    }
+	}
 
 	/**
-	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf
-	 * and byte internally of CacheHolder, some conversion has to be done.
-	 * @param typeId Cache Type
+	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf and byte internally of CacheHolder, some conversion has to be done.
+	 * 
+	 * @param typeId
+	 *            Cache Type
 	 */
 	public void setType(byte typeId) {
-		Global.getProfile().notifyUnsavedChanges(typeId != type);		
-    	type = typeId;
-    }
+		Global.getProfile().notifyUnsavedChanges(typeId != type);
+		type = typeId;
+	}
 
 	public boolean is_archived() {
-    	return archived;
-    }
+		return archived;
+	}
 
 	public void setArchived(boolean is_archived) {
-		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);		
-    	this.archived = is_archived;
-    	if (this.archived) {this.available=false;}
-    }
+		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);
+		this.archived = is_archived;
+		if (this.archived) {
+			this.available = false;
+		}
+	}
 
 	public boolean is_available() {
-    	return available;
-    }
+		return available;
+	}
 
 	public void setAvailable(boolean is_available) {
 		Global.getProfile().notifyUnsavedChanges(is_available != this.available);
-    	this.available = is_available;
-		if (this.available) {this.archived=false;}
-    }
+		this.available = is_available;
+		if (this.available) {
+			this.archived = false;
+		}
+	}
 
 	public boolean is_owned() {
-    	return owned;
-    }
+		return owned;
+	}
 
 	public void setOwned(boolean is_owned) {
-		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);		
-    	this.owned = is_owned;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);
+		this.owned = is_owned;
+	}
 
 	public boolean is_found() {
-    	return found;
-    }
+		return found;
+	}
 
 	public void setFound(boolean is_found) {
-    if (is_found != this.found) {
-      Global.getProfile().notifyUnsavedChanges(true);		
-      this.found = is_found;
-      if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null) ) {
-        this.mainCache.setFound(is_found);
-		// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
-        // so setFound should be called after setCacheStatus 
-        if (is_found) this.mainCache.setAttributesToAddiWpts();
-      }
-    }
-  }
+		if (is_found != this.found) {
+			Global.getProfile().notifyUnsavedChanges(true);
+			this.found = is_found;
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null)) {
+				this.mainCache.setFound(is_found);
+				// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
+				// so setFound should be called after setCacheStatus
+				if (is_found)
+					this.mainCache.setAttributesToAddiWpts();
+			}
+		}
+	}
 
 	/**
-	 * If this returns <code>true</code>, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is <code>false</code>, then the normal 
-	 * filter settings apply.<br>
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
+	 * If this returns <code>true</code>, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is <code>false</code>, then the normal filter settings apply.<br>
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
 	 * @return <code>True</code>: Always display additional waypoints for cache.
 	 */
 	public boolean showAddis() {
 		return this.showAddis;
 	}
-	
+
 	/**
-	 * Setter for <code>showAddis()</code>. 
-	 * If this returns <code>true</code>, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is <code>false</code>, then the normal 
-	 * filter settings apply.<br>
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
-	 * @param value <code>True</code>: Always display additional waypoints for cache.
+	 * Setter for <code>showAddis()</code>. If this returns <code>true</code>, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is <code>false</code>, then the normal filter settings apply.<br>
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
+	 * @param value
+	 *            <code>True</code>: Always display additional waypoints for cache.
 	 */
 	public void setShowAddis(boolean value) {
 		// This value is always stored in the main cache and all addis.
@@ -1713,17 +1722,15 @@
 		}
 		if (mc.showAddis != value) {
 			mc.showAddis = value;
-			for (int i=0; i<mc.addiWpts.size(); i++) {
+			for (int i = 0; i < mc.addiWpts.size(); i++) {
 				CacheHolder ac = (CacheHolder) mc.addiWpts.get(i);
 				ac.showAddis = value;
 			}
 		}
 	}
-	
+
 	/**
-	 * <b><u>Important</u></b>: This flag no longer indicates if a cache is visible
-	 * in the list. Instead, it now <u>only</u> flags if the cache is filtered out
-	 * by filter criteria. Use <code>isVisible()</code> instead.<br>
+	 * <b><u>Important</u></b>: This flag no longer indicates if a cache is visible in the list. Instead, it now <u>only</u> flags if the cache is filtered out by filter criteria. Use <code>isVisible()</code> instead.<br>
 	 * This property is affected by the following features:
 	 * <ul>
 	 * <li>"Defining and applying" a filter</li>
@@ -1737,239 +1744,232 @@
 	 * <li>Applying a cache tour filter</li>
 	 * <li>Switching between normal view and blacklist view</li>
 	 * <li>Performing searches</li>
-	 * <li>Anything else that isn't directly connected to filters in 
-	 * it's proper sense.</li>
+	 * <li>Anything else that isn't directly connected to filters in it's proper sense.</li>
 	 * </ul>
 	 * The new method for deciding if a cache is visible or not is <code>isVisible()
-	 * </code>.  
+	 * </code>.
+	 * 
 	 * @return <code>True</code> if filter criteria are matched
 	 */
 	public boolean is_filtered() {
-    	return filtered;
-    }
+		return filtered;
+	}
 
 	public void setFiltered(boolean is_filtered) {
-		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);		
-    	this.filtered = is_filtered;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);
+		this.filtered = is_filtered;
+	}
 
 	public boolean is_log_updated() {
-    	return log_updated;
-    }
+		return log_updated;
+	}
 
 	public void setLog_updated(boolean is_log_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);		
-		if (is_log_updated && iconAndTextWPLevel == 1) iconAndTextWP = null;
-    	this.log_updated = is_log_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);
+		if (is_log_updated && iconAndTextWPLevel == 1)
+			iconAndTextWP = null;
+		this.log_updated = is_log_updated;
+	}
 
 	public boolean is_updated() {
-    	return cache_updated;
-    }
+		return cache_updated;
+	}
 
 	public void setUpdated(boolean is_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);		
-		if (is_updated && iconAndTextWPLevel == 2) iconAndTextWP = null;
-    	this.cache_updated = is_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);
+		if (is_updated && iconAndTextWPLevel == 2)
+			iconAndTextWP = null;
+		this.cache_updated = is_updated;
+	}
 
 	public boolean is_incomplete() {
-    	return incomplete;
-    }
+		return incomplete;
+	}
 
 	public void setIncomplete(boolean is_incomplete) {
-		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);	
-		if (is_incomplete && iconAndTextWPLevel == 4) iconAndTextWP = null;
-    	this.incomplete = is_incomplete;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);
+		if (is_incomplete && iconAndTextWPLevel == 4)
+			iconAndTextWP = null;
+		this.incomplete = is_incomplete;
+	}
+
 	/** checks the waypoint data integrity to set a warning flag if something is missing */
 	public boolean checkIncomplete() {
 		// TODO: discuss if we should only check cache waypoints and silently "fix" everything else
 		boolean ret;
 		if (isCacheWpt()) {
-			if (getWayPoint().length() < 3
-					|| getHard() < CacheTerrDiff.CW_DT_UNSET
-					|| getTerrain() < CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() == CacheSize.CW_SIZE_ERROR
-					|| getCacheOwner().length() == 0
-					|| getDateHidden().length() == 0 
-					|| getCacheName().length() == 0) 
+			if (getWayPoint().length() < 3 || getHard() < CacheTerrDiff.CW_DT_UNSET || getTerrain() < CacheTerrDiff.CW_DT_UNSET || getCacheSize() == CacheSize.CW_SIZE_ERROR || getCacheOwner().length() == 0 || getDateHidden().length() == 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isAddiWpt()) {
-			//FIXME: do not check for mainCache == null, since it will be null during initial import
-			//FIXME: find out why we only check waypoints with IDs of a certain length ???
-//			if (mainCache == null
-//					|| getHard() != CacheTerrDiff.CW_DT_UNSET 
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getWayPoint().length() < 3
-//					|| getCacheOwner().length() > 0
-//					|| getDateHidden().length() > 0 
-					|| getCacheName().length() == 0
-					)
+			// FIXME: do not check for mainCache == null, since it will be null during initial import
+			// FIXME: find out why we only check waypoints with IDs of a certain length ???
+			// if (mainCache == null
+			// || getHard() != CacheTerrDiff.CW_DT_UNSET
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getWayPoint().length() < 3
+			// || getCacheOwner().length() > 0
+			// || getDateHidden().length() > 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isCustomWpt()) {
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET 
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getWayPoint().length() < 3
-//					|| getCacheOwner().length() > 0
-//					|| getDateHidden().length() > 0 
-//					|| getCacheName().length() == 0
-					)
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getWayPoint().length() < 3
+			// || getCacheOwner().length() > 0
+			// || getDateHidden().length() > 0
+			// || getCacheName().length() == 0
+			)
 				ret = true;
 			else
 				ret = false;
 		} else {
 			// we should not get here, so let's set a warning just in case
-			ret=true;
+			ret = true;
 		}
 		setIncomplete(ret);
 		return ret;
 	}
 
 	/**
-	 * Determines if the blacklist status is set for the cache. Do not use this method
-	 * to check if the cache should be displayed. Use <code>isVisible()</code> for
-	 * this, which already does this (and other) checks.<br>
-	 * Only use this method if you really want to inform yourself about the 
-	 * black status of the cache!
+	 * Determines if the blacklist status is set for the cache. Do not use this method to check if the cache should be displayed. Use <code>isVisible()</code> for this, which already does this (and other) checks.<br>
+	 * Only use this method if you really want to inform yourself about the black status of the cache!
+	 * 
 	 * @return <code>true</code> if he black status of the cache is set.
 	 */
 	public boolean is_black() {
-    	return black;
-    }
+		return black;
+	}
 
 	public void setBlack(boolean is_black) {
-		Global.getProfile().notifyUnsavedChanges(is_black != this.black);		
-    	this.black = is_black;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_black != this.black);
+		this.black = is_black;
+	}
 
 	public boolean is_new() {
-    	return newCache;
-    }
+		return newCache;
+	}
 
 	public void setNew(boolean is_new) {
-		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);		
-		if (is_new && iconAndTextWPLevel == 3) iconAndTextWP = null;
+		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);
+		if (is_new && iconAndTextWPLevel == 3)
+			iconAndTextWP = null;
 		this.newCache = is_new;
-    }
+	}
 
 	public String getOcCacheID() {
-    	return ocCacheID;
-    }
+		return ocCacheID;
+	}
 
 	public void setOcCacheID(String ocCacheID) {
-		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));		
-    	this.ocCacheID = ocCacheID;
-    }
+		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));
+		this.ocCacheID = ocCacheID;
+	}
 
 	public byte getNoFindLogs() {
-    	return noFindLogs;
-    }
+		return noFindLogs;
+	}
 
 	public void setNoFindLogs(byte noFindLogs) {
-		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);		
-    	this.noFindLogs = noFindLogs;
-    }
+		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);
+		this.noFindLogs = noFindLogs;
+	}
 
 	public int getNumRecommended() {
-    	return numRecommended;
-    }
+		return numRecommended;
+	}
+
 	public String getRecommended() {
 		if (!isCacheWpt())
 			return "";
-		if ( isOC() ) {
-		  return Convert.formatInt(numRecommended);
+		if (isOC()) {
+			return Convert.formatInt(recommendationScore) + " (" + Convert.formatInt(numRecommended) + ")";
 		} else {
-		  int gcVote = numRecommended;
-		  if ( gcVote < 100 ) {
-		    return MyLocale.formatDouble((double)gcVote/10.0, "0.0"); 
-		  } else {
-		    int votes = gcVote / 100;
-		    gcVote = gcVote - 100 * votes;
-		    return MyLocale.formatDouble((double)gcVote/10.0, "0.0") + " (" + Convert.formatInt(votes) + ")";
-		  }
+			int gcVote = numRecommended;
+			if (gcVote < 100) {
+				return MyLocale.formatDouble((double) gcVote / 10.0, "0.0");
+			} else {
+				int votes = gcVote / 100;
+				gcVote = gcVote - 100 * votes;
+				return MyLocale.formatDouble((double) gcVote / 10.0, "0.0") + " (" + Convert.formatInt(votes) + ")";
+			}
 		}
 	}
 
 	public void setNumRecommended(int numRecommended) {
-		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);		
-    	this.numRecommended = numRecommended;
-    }
+		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);
+		this.numRecommended = numRecommended;
+	}
 
 	public int getNumFoundsSinceRecommendation() {
-    	return numFoundsSinceRecommendation;
-    }
+		return numFoundsSinceRecommendation;
+	}
 
 	public void setNumFoundsSinceRecommendation(int numFoundsSinceRecommendation) {
-		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);		
-    	this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
-    }
+		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);
+		this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
+	}
 
 	public boolean has_bugs() {
-    	return bugs;
-    }
+		return bugs;
+	}
 
 	public void setHas_bugs(boolean has_bug) {
-		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);		
-    	this.bugs = has_bug;
-    }
+		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);
+		this.bugs = has_bug;
+	}
 
 	public boolean is_HTML() {
-    	return html;
-    }
+		return html;
+	}
 
 	public void setHTML(boolean is_HTML) {
-		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);		
-    	this.html = is_HTML;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);
+		this.html = is_HTML;
+	}
 
 	public String getLastSync() {
-    	return lastSync;
-    }
+		return lastSync;
+	}
 
 	public void setLastSync(String lastSync) {
-		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));		
-    	this.lastSync = lastSync;
-    }
+		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));
+		this.lastSync = lastSync;
+	}
 
 	public long[] getAttributesBits() {
-    	return this.attributesBits;
-    }
+		return this.attributesBits;
+	}
 
 	public void setAttribsAsBits(long[] attributesBits) {
-		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);		
-    	this.attributesBits = attributesBits;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);
+		this.attributesBits = attributesBits;
+	}
+
 	public boolean hasSolver() {
 		return hasSolver;
 	}
-	
+
 	public void setHasSolver(boolean hasSolver) {
-		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);		
+		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);
 		this.hasSolver = hasSolver;
 	}
 
 	public boolean hasNote() {
 		return hasNote;
 	}
-	
+
 	public void setHasNote(boolean hasNote) {
-		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);		
+		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);
 		this.hasNote = hasNote;
 	}
-	
+
 	/**
 	 * rename a waypoint and all its associated files
-	 * @param newWptId new waypoint id (will be converted to upper case)
+	 * 
+	 * @param newWptId
+	 *            new waypoint id (will be converted to upper case)
 	 * @return true on success, false on error
 	 */
 	public boolean rename(String newWptId) {
@@ -1985,4 +1985,3 @@
 		}
 	}
 }
-

Modified: branches/r1.2/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheHolderDetail.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheHolderDetail.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -40,532 +40,555 @@
 import ewe.util.Vector;
 
 public class CacheHolderDetail {
-	  
-	  
-	 /** CacheHolder which holds the detail. <b>Only</b> set by CacheHolder when creating detail! **/
-	  private CacheHolder parent = null;
-	  public String LongDescription = CacheHolder.EMPTY;
-	  public String LastUpdate = CacheHolder.EMPTY;
-	  public String Hints = CacheHolder.EMPTY;
-	  public LogList CacheLogs=new LogList();
-	  private String CacheNotes = CacheHolder.EMPTY;
-	  public CacheImages images = new CacheImages();
-	  public CacheImages logImages = new CacheImages();
-	  public CacheImages userImages = new CacheImages();
-	  public Attributes attributes=new Attributes();
-	  public Vector CacheIcons = new Vector();
-	  public TravelbugList Travelbugs=new TravelbugList();
-	  //public String Bugs = EMPTY; Superceded by Travelbugs
-	  public String URL = CacheHolder.EMPTY;
-	  private String Solver = CacheHolder.EMPTY;
-	  public String OwnLogId = CacheHolder.EMPTY;
-	  public Log OwnLog = null;
-	  public String Country = CacheHolder.EMPTY;
-	  public String State = CacheHolder.EMPTY;
-	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
-	   * If you want to save the changes automatically when the details are unloaded, set this to true */ 
-	  public boolean hasUnsavedChanges = false;
-	  
-	 public CacheHolderDetail(CacheHolder ch) {
-		 parent = ch;
-	 }
 
-	 public CacheHolder getParent() {
-		 return parent;
-	 }
-	 public void setLongDescription(String longDescription) {
-	 	if (LongDescription.equals("")) getParent().setNew(true);
-	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) getParent().setUpdated(true);
-	 	LongDescription = longDescription;
-	 }
-	 
-	 private String stripControlChars(String desc) {
-		 StringBuffer sb=new StringBuffer(desc.length());
-		 for (int i=0; i<desc.length(); i++) {
-			char c=desc.charAt(i);
-			if (c>' ') sb.append(c);
-		 }
-		 return sb.toString();
-	 }
-	 
-	 public void setHints(String hints) {
-	 	if (!Hints.equals(hints)) getParent().setUpdated(true);
-	 	Hints = hints;
-	 }
-	 
-	 public void setSolver(String solver) {
-		 if (!Solver.equals(solver)) getParent().setUpdated(true);
-		 getParent().setHasSolver(!solver.trim().equals(""));
-		 Solver = solver;
-	 }
-	 
-	 public String getSolver() {
-		 return this.Solver;
-	 }
+	/** CacheHolder which holds the detail. <b>Only</b> set by CacheHolder when creating detail! **/
+	private CacheHolder parent = null;
+	public String LongDescription = CacheHolder.EMPTY;
+	public String LastUpdate = CacheHolder.EMPTY;
+	public String Hints = CacheHolder.EMPTY;
+	public LogList CacheLogs = new LogList();
+	private String CacheNotes = CacheHolder.EMPTY;
+	public CacheImages images = new CacheImages();
+	public CacheImages logImages = new CacheImages();
+	public CacheImages userImages = new CacheImages();
+	public Attributes attributes = new Attributes();
+	public Vector CacheIcons = new Vector();
+	public TravelbugList Travelbugs = new TravelbugList();
+	// public String Bugs = EMPTY; Superceded by Travelbugs
+	public String URL = CacheHolder.EMPTY;
+	private String Solver = CacheHolder.EMPTY;
+	public String OwnLogId = CacheHolder.EMPTY;
+	public Log OwnLog = null;
+	public String Country = CacheHolder.EMPTY;
+	public String State = CacheHolder.EMPTY;
+	/**
+	 * For faster cache import (from opencaching) changes are only written when the details are freed from memory
+	 * If you want to save the changes automatically when the details are unloaded, set this to true
+	 */
+	public boolean hasUnsavedChanges = false;
 
-	 public void setCacheNotes(String notes) {
-		 if (!CacheNotes.equals(notes)) getParent().setUpdated(true);
-		 getParent().setHasNote(!notes.trim().equals(""));
-		 CacheNotes = notes;
-	 }
-	 
-	 public String getCacheNotes() {
-		 return this.CacheNotes;
-	 }
-	 
-	 public void setCacheLogs(LogList newLogs) {
-		 int size=newLogs.size();
-		 for (int i=size-1; i>=0; i--) { // Loop over all new logs, must start with oldest log
-			 if (CacheLogs.merge(newLogs.getLog(i))>=0) getParent().setLog_updated(true);
-		 }
-		 if (CacheLogs.purgeLogs() > 0) hasUnsavedChanges=true;
-		 getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
-	 }
+	public CacheHolderDetail(CacheHolder ch) {
+		parent = ch;
+	}
 
-	 
-	  /**
+	public CacheHolder getParent() {
+		return parent;
+	}
+
+	public void setLongDescription(String longDescription) {
+		if (LongDescription.equals(""))
+			getParent().setNew(true);
+		else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription)))
+			getParent().setUpdated(true);
+		LongDescription = longDescription;
+	}
+
+	private String stripControlChars(String desc) {
+		StringBuffer sb = new StringBuffer(desc.length());
+		for (int i = 0; i < desc.length(); i++) {
+			char c = desc.charAt(i);
+			if (c > ' ')
+				sb.append(c);
+		}
+		return sb.toString();
+	}
+
+	public void setHints(String hints) {
+		if (!Hints.equals(hints))
+			getParent().setUpdated(true);
+		Hints = hints;
+	}
+
+	public void setSolver(String solver) {
+		if (!Solver.equals(solver))
+			getParent().setUpdated(true);
+		getParent().setHasSolver(!solver.trim().equals(""));
+		Solver = solver;
+	}
+
+	public String getSolver() {
+		return this.Solver;
+	}
+
+	public void setCacheNotes(String notes) {
+		if (!CacheNotes.equals(notes))
+			getParent().setUpdated(true);
+		getParent().setHasNote(!notes.trim().equals(""));
+		CacheNotes = notes;
+	}
+
+	public String getCacheNotes() {
+		return this.CacheNotes;
+	}
+
+	public void setCacheLogs(LogList newLogs) {
+		int size = newLogs.size();
+		for (int i = size - 1; i >= 0; i--) { // Loop over all new logs, must start with oldest log
+			if (CacheLogs.merge(newLogs.getLog(i)) >= 0)
+				getParent().setLog_updated(true);
+		}
+		if (CacheLogs.purgeLogs() > 0)
+			hasUnsavedChanges = true;
+		getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
+	}
+
+	/**
 	 * Method to update an existing cache with new data. This is
 	 * necessary to avoid missing old logs. Called from GPX Importer
-	 * @param newCh new cache data
+	 * 
+	 * @param newCh
+	 *            new cache data
 	 * @return CacheHolder with updated data
 	 */
-	 public CacheHolderDetail update(CacheHolderDetail newCh) {
-			// flags
-			CacheHolder ch = getParent();
-			if (ch.is_found() && ch.getCacheStatus().equals("")) {
-				ch.setCacheStatus(ch.getFoundText());
+	public CacheHolderDetail update(CacheHolderDetail newCh) {
+		// flags
+		CacheHolder ch = getParent();
+		if (ch.is_found() && ch.getCacheStatus().equals("")) {
+			ch.setCacheStatus(ch.getFoundText());
+		}
+		// travelbugs:GPX-File contains all actual travelbugs but not the missions
+		// we need to check whether the travelbug is already in the existing list
+		getParent().setHas_bugs(newCh.Travelbugs.size() > 0);
+		for (int i = newCh.Travelbugs.size() - 1; i >= 0; i--) {
+			Travelbug tb = newCh.Travelbugs.getTB(i);
+			Travelbug oldTB = this.Travelbugs.find(tb.getName());
+			// If the bug is already in the cache, we keep it
+			if (oldTB != null) {
+				if (tb.getMission().length() > 0)
+					oldTB.setMission(tb.getMission());
+				if (tb.getGuid().length() > 0)
+					oldTB.setGuid(tb.getGuid());
+				newCh.Travelbugs.replace(i, oldTB);
 			}
-			//travelbugs:GPX-File contains all actual travelbugs but not the missions
-			// we need to check whether the travelbug is already in the existing list
-			getParent().setHas_bugs(newCh.Travelbugs.size()>0);
-			for (int i=newCh.Travelbugs.size()-1; i>=0; i--) {
-				Travelbug tb=newCh.Travelbugs.getTB(i);
-				Travelbug oldTB=this.Travelbugs.find(tb.getName());
-				// If the bug is already in the cache, we keep it
-				if (oldTB != null) {
-					if (tb.getMission().length() > 0)
-						oldTB.setMission(tb.getMission());
-					if (tb.getGuid().length() > 0)
-						oldTB.setGuid(tb.getGuid());
-					newCh.Travelbugs.replace(i,oldTB);
-				}
+		}
+		this.Travelbugs = newCh.Travelbugs;
+		if (newCh.attributes.count() > 0)
+			this.attributes = newCh.attributes;
+		// URL
+		this.URL = newCh.URL;
+		// Images
+		this.images = newCh.images;
+		setLongDescription(newCh.LongDescription);
+		setHints(newCh.Hints);
+		setCacheLogs(newCh.CacheLogs);
+		if (newCh.OwnLogId.length() > 0)
+			this.OwnLogId = newCh.OwnLogId;
+		if (newCh.OwnLog != null)
+			this.OwnLog = newCh.OwnLog;
+		if (newCh.Country.length() > 0)
+			this.Country = newCh.Country;
+		if (newCh.State.length() > 0)
+			this.State = newCh.State;
+		if (newCh.getSolver().length() > 0)
+			this.setSolver(newCh.getSolver());
+		return this;
+	}
+
+	/**
+	 * Adds a user image to the cache data
+	 * 
+	 * @param profile
+	 */
+	public void addUserImage(Profile profile) {
+		File imgFile;
+		String imgDesc, imgDestName;
+
+		// Get Image and description
+		FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
+		fc.setTitle("Select image file:");
+		if (fc.execute() != FormBase.IDCANCEL) {
+			imgFile = fc.getChosenFile();
+			imgDesc = new InputBox("Description").input("", 10);
+			// Create Destination Filename
+			String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
+			imgDestName = getParent().getWayPoint() + "_U_" + (this.userImages.size() + 1) + ext;
+
+			ImageInfo userImageInfo = new ImageInfo();
+			userImageInfo.setFilename(imgDestName);
+			userImageInfo.setTitle(imgDesc);
+			this.userImages.add(userImageInfo);
+			// Copy File
+			DataMover.copy(imgFile.getFullPath(), profile.dataDir + imgDestName);
+			// Save Data
+			saveCacheDetails(profile.dataDir);
+		}
+	}
+
+	/**
+	 * Method to parse a specific cache.xml file.
+	 * It fills information on cache details, hints, logs, notes and
+	 * images.
+	 */
+	void readCache(String dir) throws IOException {
+		String dummy;
+		FileReader in = null;
+		ImageInfo imageInfo;
+		// If parent cache has empty waypoint then don't do anything. This might happen
+		// when a cache object is freshly created to serve as container for imported data
+		if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY))
+			return;
+		FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml");
+		if (cacheFile.exists()) {
+			try {
+				in = new FileReader(cacheFile.getAbsolutePath());
+			} catch (FileNotFoundException e) {
+				in = null; // exception is thrown again below, if file could not be found in upper case, too
 			}
-			this.Travelbugs = newCh.Travelbugs;
-			if (newCh.attributes.count() > 0) this.attributes = newCh.attributes;
-			// URL
-			this.URL = newCh.URL;
-			// Images
-			this.images = newCh.images;
-			setLongDescription(newCh.LongDescription);
-			setHints(newCh.Hints);
-			setCacheLogs(newCh.CacheLogs);
-			if (newCh.OwnLogId.length()>0) this.OwnLogId=newCh.OwnLogId;
-			if (newCh.OwnLog != null) this.OwnLog = newCh.OwnLog;
-			if (newCh.Country.length()>0) this.Country=newCh.Country;
-			if (newCh.State.length()>0) this.State=newCh.State;
-			if (newCh.getSolver().length()>0) this.setSolver(newCh.getSolver());
-			return this;		
-	 }
-	  
-	  /**
-	   * Adds a user image to the cache data
-	   * @param profile
-	   */
-		public void addUserImage(Profile profile){
-		  File imgFile;
-		  String imgDesc, imgDestName;
-		  
-		  //Get Image and description
-			FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
-			fc.setTitle("Select image file:");
-			if(fc.execute() != FormBase.IDCANCEL){
-				imgFile = fc.getChosenFile();
-				imgDesc = new InputBox("Description").input("",10);
-				//Create Destination Filename
-				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
-				imgDestName = getParent().getWayPoint() + "_U_" + (this.userImages.size()+1) + ext;
-				
-				ImageInfo userImageInfo = new ImageInfo();
-				userImageInfo.setFilename(imgDestName);
-				userImageInfo.setTitle(imgDesc);
-				this.userImages.add(userImageInfo);
-				// Copy File
-				DataMover.copy(imgFile.getFullPath(),profile.dataDir + imgDestName);
-				// Save Data
-				saveCacheDetails(profile.dataDir);
+		}
+		if (in == null) {
+			cacheFile = new FileBugfix(dir + getParent().getWayPoint() + ".xml");
+			if (cacheFile.exists()) {
+				in = new FileReader(cacheFile.getAbsolutePath());
 			}
-	  }
+		}
 
-	  
-		/**
-		*	Method to parse a specific cache.xml file.
-		*	It fills information on cache details, hints, logs, notes and
-		*	images.
-		*/
-		void readCache(String dir) throws IOException{
-			String dummy;
-			FileReader in = null;
-			ImageInfo imageInfo;
-			// If parent cache has empty waypoint then don't do anything. This might happen
-			// when a cache object is freshly created to serve as container for imported data
-			if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY)) return;
-			FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml");			
-			if (cacheFile.exists()) {
-				try {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				} catch (FileNotFoundException e) {
-					in = null; //exception is thrown again below, if file could not be found in upper case, too
-				}
+		if (in == null)
+			throw new FileNotFoundException(dir + getParent().getWayPoint().toLowerCase() + ".xml");
+		Global.getPref().log("Reading file " + getParent().getWayPoint() + ".xml");
+		String text = in.readAll();
+		in.close();
+
+		Extractor ex = new Extractor(text, "<DETAILS><![CDATA[", "]]></DETAILS>", 0, true);
+		LongDescription = ex.findNext();
+
+		ex.set(text, "<COUNTRY><![CDATA[", "]]></COUNTRY>", 0, true);
+		Country = ex.findNext();
+
+		ex.set(text, "<STATE><![CDATA[", "]]></STATE>", 0, true);
+		State = ex.findNext();
+
+		// Attributes
+		ex.set(text, "<ATTRIBUTES>", "</ATTRIBUTES>", 0, true);
+		attributes.XmlAttributesEnd(ex.findNext());
+
+		ex.set(text, "<HINTS><![CDATA[", "]]></HINTS>", 0, true);
+		Hints = ex.findNext();
+
+		ex.set(text, "<LOGS>", "</LOGS>", 0, true);
+		dummy = ex.findNext();
+
+		ex.set(dummy, "<OWNLOGID>", "</OWNLOGID>", 0, true);
+		OwnLogId = ex.findNext();
+
+		ex.set(dummy, "<OWNLOG><![CDATA[", "]]></OWNLOG>", 0, true);
+		String ownLogText = ex.findNext();
+		if (ownLogText.length() > 0) {
+			if (ownLogText.indexOf("<img src='") >= 0) {
+				OwnLog = new Log(ownLogText + "]]>");
+			} else {
+				OwnLog = new Log("icon_smile.gif", "1900-01-01", Global.getPref().myAlias, ownLogText);
 			}
-			if (in == null) {
-				cacheFile = new FileBugfix(dir + getParent().getWayPoint() + ".xml");			
-				if (cacheFile.exists()) {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				}
-			}
+		} else {
+			OwnLog = null;
+		}
 
-			if (in == null) throw new FileNotFoundException(dir+getParent().getWayPoint().toLowerCase()+".xml");
-			Global.getPref().log("Reading file "+getParent().getWayPoint() + ".xml");
-			String text= in.readAll();
-			in.close();
-			Extractor ex = new Extractor(text, "<DETAILS><![CDATA[", "]]></DETAILS>", 0, true);		
-			LongDescription = ex.findNext();
-			ex = new Extractor(text, "<COUNTRY><![CDATA[", "]]></COUNTRY>", 0, true);
-			Country = ex.findNext();
-			ex = new Extractor(text, "<STATE><![CDATA[", "]]></STATE>", 0, true);
-			State = ex.findNext();
-			// Attributes
-			ex = new Extractor(text,"<ATTRIBUTES>","</ATTRIBUTES>",0,true);
-			attributes.XmlAttributesEnd(ex.findNext());
-			
-			ex = new Extractor(text, "<HINTS><![CDATA[", "]]></HINTS>", 0, true);
-			Hints = ex.findNext();
-			ex = new Extractor(text, "<LOGS>","</LOGS>", 0, true);
-			dummy = ex.findNext();
-			ex = new Extractor(dummy, "<OWNLOGID>","</OWNLOGID>", 0, true);
-			OwnLogId = ex.findNext();
-			ex = new Extractor(dummy, "<OWNLOG><![CDATA[", "]]></OWNLOG>", 0, true);
-			String ownLogText = ex.findNext();
-			if ( ownLogText.length() > 0 ) {
-				if (ownLogText.indexOf("<img src='") >= 0) {
-					OwnLog = new Log( ownLogText + "]]>" );
-				} else {
-					OwnLog = new Log( "icon_smile.gif", "1900-01-01", Global.getPref().myAlias, ownLogText );
-				}
+		CacheLogs.clear();
+		ex.set(dummy, "<LOG>", "</LOG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			CacheLogs.add(new Log(dummy));
+		}
+
+		ex.set(text, "<NOTES><![CDATA[", "]]></NOTES>", 0, true);
+		CacheNotes = ex.findNext();
+		images.clear();
+
+		ex.set(text, "<IMG>", "</IMG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = new ImageInfo();
+			int pos = dummy.indexOf("<URL>");
+			if (pos > 0) {
+				imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0, pos)));
+				imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos + 5, dummy.indexOf("</URL>")))));
 			} else {
-				OwnLog = null;
+				imageInfo.setFilename(SafeXML.cleanback(dummy));
 			}
-			CacheLogs.clear();
-			ex = new Extractor(dummy, "<LOG>","</LOG>", 0, true);
-			
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				CacheLogs.add(new Log(dummy));
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, "<NOTES><![CDATA[", "]]></NOTES>", 0, true);
-			CacheNotes = ex.findNext();
-			images.clear();
-			ex = new Extractor(text, "<IMG>", "</IMG>", 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				int pos=dummy.indexOf("<URL>");
-				if (pos>0) {
-					imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0,pos)));
-					imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos+5,dummy.indexOf("</URL>")))));
-				} else {
-					imageInfo.setFilename(SafeXML.cleanback(dummy));
-				}
-				this.images.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, "<IMGTEXT>", "</IMGTEXT>", 0, true);
-			dummy = ex.findNext();
-			int imgNr = 0;
-			while(!ex.endOfSearch()){
-				if (imgNr >= this.images.size()) {
-					images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the <cache>.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
-					Global.getPref().log("Error reading " + this.getParent().getWayPoint() + "More IMGTEXT tags than IMG tags");
-				}
-				imageInfo = this.images.get(imgNr);
-				int pos=dummy.indexOf("<DESC>");
-				if (pos>0) {
-					imageInfo.setTitle(dummy.substring(0,pos));
-					imageInfo.setComment(dummy.substring(pos+6,dummy.indexOf("</DESC>")));
-				} else {
-					imageInfo.setTitle(dummy);
-				}
-				dummy = ex.findNext();
-				imgNr = imgNr + 1;
-			}
-			// Logimages
-			logImages.clear();
-			ex = new Extractor(text, "<LOGIMG>", "</LOGIMG>", 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				logImages.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, "<LOGIMGTEXT>", "</LOGIMGTEXT>", 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = logImages.get(imgNr++);
-				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
-			}
+			this.images.add(imageInfo);
+		}
 
-			userImages.clear();
-			ex = new Extractor(text, "<USERIMG>", "</USERIMG>", 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				userImages.add(imageInfo);
-				dummy = ex.findNext();
+		ex.set(text, "<IMGTEXT>", "</IMGTEXT>", 0, true);
+		int imgNr = 0;
+		while ((dummy = ex.findNext()).length() > 0) {
+			if (imgNr >= this.images.size()) {
+				images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the <cache>.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
+				Global.getPref().log("Error reading " + this.getParent().getWayPoint() + "More IMGTEXT tags than IMG tags");
 			}
-			ex = new Extractor(text, "<USERIMGTEXT>", "</USERIMGTEXT>", 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = userImages.get(imgNr++);
+			imageInfo = this.images.get(imgNr);
+			int pos = dummy.indexOf("<DESC>");
+			if (pos > 0) {
+				imageInfo.setTitle(dummy.substring(0, pos));
+				imageInfo.setComment(dummy.substring(pos + 6, dummy.indexOf("</DESC>")));
+			} else {
 				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
 			}
+			imgNr = imgNr + 1;
+		}
 
-			ex = new Extractor(text, "<TRAVELBUGS>", "</TRAVELBUGS>", 0, false);
-			dummy=ex.findNext();
-			if (ex.endOfSearch()) {
-				ex = new Extractor(text, "<BUGS><![CDATA[", "]]></BUGS>", 0, true);
-				String Bugs = ex.findNext();
-				Travelbugs.addFromHTML(Bugs);
-			} else
-				Travelbugs.addFromXML(dummy);
-			
-			ex = new Extractor(text, "<URL><![CDATA[", "]]></URL>", 0, true);
-			// if no URL is stored, set default URL (at this time only possible for gc.com)
-			dummy = ex.findNext();
-			if (dummy.length() > 10){
-				URL = dummy;
-				int logpos = URL.indexOf("&"); //&Submit &log=y
-				if (logpos > 0) URL=URL.substring(0,logpos);
-			}
-			else {
-				if (getParent().getWayPoint().startsWith("GC")) {
-					URL = "http://www.geocaching.com/seek/cache_details.aspx?wp="+ getParent().getWayPoint();
-				}
-			}
-			ex = new Extractor(text, "<SOLVER><![CDATA[", "]]></SOLVER>", 0, true);
-			this.setSolver(ex.findNext());
+		logImages.clear();
+		ex.set(text, "<LOGIMG>", "</LOGIMG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			logImages.add(imageInfo);
 		}
-		public void deleteFile(String FileName) {	
-			//File exists?
-			boolean exists = (new File(FileName)).exists();
-			//yes: then delete
-			if (exists) {
-				boolean ok = (new File(FileName)).delete();
-				if(ok) ok = true;
-			}
-			boolean exists2 = (new File(FileName.toLowerCase())).exists();
-			//yes: delete
-			if (exists2) {
-				boolean ok2 = (new File(FileName.toLowerCase())).delete();
-				if(ok2) ok2=true;
-			}
+
+		ex.set(text, "<LOGIMGTEXT>", "</LOGIMGTEXT>", 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = logImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
 		}
-		/**
-		*	Method to save a cache.xml file.
-		*/
-		public void saveCacheDetails(String dir){
-			PrintWriter detfile;
-			deleteFile(dir + getParent().getWayPoint() + ".xml");
-			try{
-			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml").getAbsolutePath())));
-			} catch (Exception e) {
-				Global.getPref().log("Problem creating details file",e,true);
-				return;
-			}
-			try{
-				if(getParent().getWayPoint().length()>0){
-				  detfile.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n");
-				  detfile.print("<CACHEDETAILS>\r\n");
-				  detfile.print("<VERSION value = \"3\"/>\n");
-				  detfile.print("<DETAILS><![CDATA["+LongDescription+"]]></DETAILS>\r\n");
-				  detfile.print("<COUNTRY><![CDATA["+Country+"]]></COUNTRY>\n");
-				  detfile.print("<STATE><![CDATA["+State+"]]></STATE>\n");
-				  detfile.print(attributes.XmlAttributesWrite());
-				  detfile.print("<HINTS><![CDATA["+Hints+"]]></HINTS>\r\n");
-				  detfile.print("<LOGS>\r\n");
-				  detfile.print("<OWNLOGID>"+OwnLogId+"</OWNLOGID>\r\n");
-				  if ( OwnLog != null ) {
-					  detfile.print("<OWNLOG><![CDATA["+OwnLog.toHtml()+"]]></OWNLOG>\r\n");
-				  } else {
-					  detfile.print("<OWNLOG><![CDATA[]]></OWNLOG>\r\n");
-				  }
-				  for(int i = 0; i < CacheLogs.size(); i++){
-					  detfile.print(CacheLogs.getLog(i).toXML());
-				  }
-				  detfile.print("</LOGS>\r\n");
-			
-				  detfile.print("<NOTES><![CDATA["+CacheNotes+"]]></NOTES>\n");
-				  detfile.print("<IMAGES>\n");
-				  String stbuf = new String();
-				  for(int i = 0;i<images.size();i++){
-						stbuf = images.get(i).getFilename();
-						String urlBuf = images.get(i).getURL();
-						if (urlBuf != null && !urlBuf.equals("")) {
-							detfile.print("    <IMG>"+SafeXML.clean(stbuf)+"<URL>"+SafeXML.clean(urlBuf)+"</URL></IMG>\n");
-						} else {
-							detfile.print("    <IMG>"+SafeXML.clean(stbuf)+"</IMG>\n");
-						}
-				  }
-				  int iis = images.size();
-				  for(int i = 0;i<iis;i++){
-						stbuf = images.get(i).getTitle();
-						if (i< iis && !images.get(i).getComment().equals(""))
-							detfile.print("    <IMGTEXT>"+stbuf+"<DESC>"+images.get(i).getComment()+"</DESC></IMGTEXT>\n");
-						else 
-							detfile.print("    <IMGTEXT>"+stbuf+"</IMGTEXT>\n");
-				  }
 
-				  for(int i = 0;i<logImages.size();i++){
-						stbuf = logImages.get(i).getFilename();
-						detfile.print("    <LOGIMG>"+stbuf+"</LOGIMG>\n");
-				  }
-				  for(int i = 0;i<logImages.size();i++){
-						stbuf = logImages.get(i).getTitle();
-						detfile.print("    <LOGIMGTEXT>"+stbuf+"</LOGIMGTEXT>\n");
-				  }
-				  for(int i = 0;i<userImages.size();i++){
-						stbuf = userImages.get(i).getFilename();
-						detfile.print("    <USERIMG>"+stbuf+"</USERIMG>\n");
-				  }
-				  for(int i = 0;i<userImages.size();i++){
-						stbuf = userImages.get(i).getTitle();
-						detfile.print("    <USERIMGTEXT>"+stbuf+"</USERIMGTEXT>\n");
-				  }
+		userImages.clear();
+		ex.set(text, "<USERIMG>", "</USERIMG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			userImages.add(imageInfo);
+		}
 
+		ex.set(text, "<USERIMGTEXT>", "</USERIMGTEXT>", 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = userImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
+		}
 
-				  detfile.print("</IMAGES>\n");
-				  //detfile.print("<BUGS><![CDATA[\n");
-				  //detfile.print(Bugs+"\n");
-				  //detfile.print("]]></BUGS>\n");
-				  detfile.print(Travelbugs.toXML());
-				  detfile.print("<URL><![CDATA["+URL+"]]></URL>\r\n");
-				  detfile.print("<SOLVER><![CDATA["+getSolver()+"]]></SOLVER>\r\n");
-				  detfile.print(getParent().toXML()); // This will allow restoration of index.xml
-				  detfile.print("</CACHEDETAILS>\n");
-				  Global.getPref().log("Writing file: "+getParent().getWayPoint().toLowerCase() + ".xml");
-				} // if length
-			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ",e);
+		ex.set(text, "<TRAVELBUGS>", "</TRAVELBUGS>", 0, false);
+		dummy = ex.findNext();
+		if (dummy.length() == 0) {
+			ex = new Extractor(text, "<BUGS><![CDATA[", "]]></BUGS>", 0, true);
+			String Bugs = ex.findNext();
+			Travelbugs.addFromHTML(Bugs);
+		} else
+			Travelbugs.addFromXML(dummy);
+
+		ex.set(text, "<URL><![CDATA[", "]]></URL>", 0, true);
+		// if no URL is stored, set default URL (at this time only possible for gc.com)
+		dummy = ex.findNext();
+		if (dummy.length() > 10) {
+			URL = dummy;
+			int logpos = URL.indexOf("&"); // &Submit &log=y
+			if (logpos > 0)
+				URL = URL.substring(0, logpos);
+		} else {
+			if (getParent().getWayPoint().startsWith("GC")) {
+				URL = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + getParent().getWayPoint();
 			}
-			try{
-			  detfile.close();
-			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ",e);
-			}
-			hasUnsavedChanges = false;
 		}
-				
-		/**
-		 * Return true if this cache has additional info for some pictures
-		 * @return true if cache has additional info, false otherwise
-		 */
-		public boolean hasImageInfo() {
-			for (int i=this.images.size()-1; i>=0; i--)
-				if (!this.images.get(i).getComment().equals("")) return true;
-			return false;
+
+		ex.set(text, "<SOLVER><![CDATA[", "]]></SOLVER>", 0, true);
+		this.setSolver(ex.findNext());
+	}
+
+	public void deleteFile(String FileName) {
+		// File exists?
+		boolean exists = (new File(FileName)).exists();
+		// yes: then delete
+		if (exists) {
+			boolean ok = (new File(FileName)).delete();
+			if (ok)
+				ok = true;
 		}
+		boolean exists2 = (new File(FileName.toLowerCase())).exists();
+		// yes: delete
+		if (exists2) {
+			boolean ok2 = (new File(FileName.toLowerCase())).delete();
+			if (ok2)
+				ok2 = true;
+		}
+	}
 
-		/**
-		 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
-		 * @param newWptId new id of the waypoint
-		 * @return true on success, false for failure
-		 */
-		protected boolean rename(String newWptId) {
-			boolean success = false;
-			String profiledir = Global.getProfile().dataDir;
-			int oldWptLength = getParent().getWayPoint().length();
-			
-			// just in case ... (got the pun? ;) )
-			newWptId = newWptId.toUpperCase();
-			
-			// update image information
-			for(int i = 0;i<images.size();i++){
-				String filename = images.get(i).getFilename();
-				String comment = images.get(i).getComment();
-				String title = images.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					images.get(i).setFilename(filename);
+	/**
+	 * Method to save a cache.xml file.
+	 */
+	public void saveCacheDetails(String dir) {
+		PrintWriter detfile;
+		deleteFile(dir + getParent().getWayPoint() + ".xml");
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml").getAbsolutePath())));
+		} catch (Exception e) {
+			Global.getPref().log("Problem creating details file", e, true);
+			return;
+		}
+		try {
+			if (getParent().getWayPoint().length() > 0) {
+				detfile.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n");
+				detfile.print("<CACHEDETAILS>\r\n");
+				detfile.print("<VERSION value = \"3\"/>\n");
+				detfile.print("<DETAILS><![CDATA[" + LongDescription + "]]></DETAILS>\r\n");
+				detfile.print("<COUNTRY><![CDATA[" + Country + "]]></COUNTRY>\n");
+				detfile.print("<STATE><![CDATA[" + State + "]]></STATE>\n");
+				detfile.print(attributes.XmlAttributesWrite());
+				detfile.print("<HINTS><![CDATA[" + Hints + "]]></HINTS>\r\n");
+				detfile.print("<LOGS>\r\n");
+				detfile.print("<OWNLOGID>" + OwnLogId + "</OWNLOGID>\r\n");
+				if (OwnLog != null) {
+					detfile.print("<OWNLOG><![CDATA[" + OwnLog.toHtml() + "]]></OWNLOG>\r\n");
+				} else {
+					detfile.print("<OWNLOG><![CDATA[]]></OWNLOG>\r\n");
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					images.get(i).setComment(comment);
+				for (int i = 0; i < CacheLogs.size(); i++) {
+					detfile.print(CacheLogs.getLog(i).toXML());
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					images.get(i).setTitle(title);
+				detfile.print("</LOGS>\r\n");
+
+				detfile.print("<NOTES><![CDATA[" + CacheNotes + "]]></NOTES>\n");
+				detfile.print("<IMAGES>\n");
+				String stbuf;
+				for (int i = 0; i < images.size(); i++) {
+					stbuf = images.get(i).getFilename();
+					String urlBuf = images.get(i).getURL();
+					if (urlBuf != null && !urlBuf.equals("")) {
+						detfile.print("    <IMG>" + SafeXML.clean(stbuf) + "<URL>" + SafeXML.clean(urlBuf) + "</URL></IMG>\n");
+					} else {
+						detfile.print("    <IMG>" + SafeXML.clean(stbuf) + "</IMG>\n");
+					}
 				}
-			}
-			for(int i = 0;i<logImages.size();i++){
-				String filename = logImages.get(i).getFilename();
-				String comment = logImages.get(i).getComment();
-				String title = logImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					logImages.get(i).setFilename(filename);
+				int iis = images.size();
+				for (int i = 0; i < iis; i++) {
+					stbuf = images.get(i).getTitle();
+					if (i < iis && !images.get(i).getComment().equals(""))
+						detfile.print("    <IMGTEXT>" + stbuf + "<DESC>" + images.get(i).getComment() + "</DESC></IMGTEXT>\n");
+					else
+						detfile.print("    <IMGTEXT>" + stbuf + "</IMGTEXT>\n");
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					logImages.get(i).setComment(comment);
+
+				for (int i = 0; i < logImages.size(); i++) {
+					stbuf = logImages.get(i).getFilename();
+					detfile.print("    <LOGIMG>" + stbuf + "</LOGIMG>\n");
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					logImages.get(i).setTitle(title);
+				for (int i = 0; i < logImages.size(); i++) {
+					stbuf = logImages.get(i).getTitle();
+					detfile.print("    <LOGIMGTEXT>" + stbuf + "</LOGIMGTEXT>\n");
 				}
-			}
-			for(int i = 0;i<userImages.size();i++){
-				String filename = userImages.get(i).getFilename();
-				String comment = userImages.get(i).getComment();
-				String title = userImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					userImages.get(i).setFilename(filename);
+				for (int i = 0; i < userImages.size(); i++) {
+					stbuf = userImages.get(i).getFilename();
+					detfile.print("    <USERIMG>" + stbuf + "</USERIMG>\n");
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					userImages.get(i).setComment(comment);
+				for (int i = 0; i < userImages.size(); i++) {
+					stbuf = userImages.get(i).getTitle();
+					detfile.print("    <USERIMGTEXT>" + stbuf + "</USERIMGTEXT>\n");
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					userImages.get(i).setTitle(title);
-				}
+
+				detfile.print("</IMAGES>\n");
+				// detfile.print("<BUGS><![CDATA[\n");
+				// detfile.print(Bugs+"\n");
+				// detfile.print("]]></BUGS>\n");
+				detfile.print(Travelbugs.toXML());
+				detfile.print("<URL><![CDATA[" + URL + "]]></URL>\r\n");
+				detfile.print("<SOLVER><![CDATA[" + getSolver() + "]]></SOLVER>\r\n");
+				detfile.print(getParent().toXML()); // This will allow restoration of index.xml
+				detfile.print("</CACHEDETAILS>\n");
+				Global.getPref().log("Writing file: " + getParent().getWayPoint().toLowerCase() + ".xml");
+			} // if length
+		} catch (Exception e) {
+			Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ", e);
+		}
+		try {
+			detfile.close();
+		} catch (Exception e) {
+			Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ", e);
+		}
+		hasUnsavedChanges = false;
+	}
+
+	/**
+	 * Return true if this cache has additional info for some pictures
+	 * 
+	 * @return true if cache has additional info, false otherwise
+	 */
+	public boolean hasImageInfo() {
+		for (int i = this.images.size() - 1; i >= 0; i--)
+			if (!this.images.get(i).getComment().equals(""))
+				return true;
+		return false;
+	}
+
+	/**
+	 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
+	 * 
+	 * @param newWptId
+	 *            new id of the waypoint
+	 * @return true on success, false for failure
+	 */
+	protected boolean rename(String newWptId) {
+		boolean success = false;
+		String profiledir = Global.getProfile().dataDir;
+		int oldWptLength = getParent().getWayPoint().length();
+
+		// just in case ... (got the pun? ;) )
+		newWptId = newWptId.toUpperCase();
+
+		// update image information
+		for (int i = 0; i < images.size(); i++) {
+			String filename = images.get(i).getFilename();
+			String comment = images.get(i).getComment();
+			String title = images.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				images.get(i).setFilename(filename);
 			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				images.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				images.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i < logImages.size(); i++) {
+			String filename = logImages.get(i).getFilename();
+			String comment = logImages.get(i).getComment();
+			String title = logImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				logImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				logImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				logImages.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i < userImages.size(); i++) {
+			String filename = userImages.get(i).getFilename();
+			String comment = userImages.get(i).getComment();
+			String title = userImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				userImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				userImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				userImages.get(i).setTitle(title);
+			}
+		}
 
-			// rename the files
-			try {
-				// since we use *.* we do not need FileBugFix
-				String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat("*.*"), ewe.io.FileBase.LIST_FILES_ONLY);
-				for (int i=0; i < srcFiles.length;i++){
-					String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
-					File srcFile = new File(profiledir.concat(srcFiles[i]));
-					File dstFile = new File(profiledir.concat(newfile));
-					srcFile.move(dstFile);
-				}
-				success = true;
-			} catch (Exception e) {
-				Global.getPref().log("Error renaming waypoint details", e, true);
-				//TODO: any chance of a roll back?
-				//TODO: should we ignore a file not found?
+		// rename the files
+		try {
+			// since we use *.* we do not need FileBugFix
+			String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat("*.*"), ewe.io.FileBase.LIST_FILES_ONLY);
+			for (int i = 0; i < srcFiles.length; i++) {
+				String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
+				File srcFile = new File(profiledir.concat(srcFiles[i]));
+				File dstFile = new File(profiledir.concat(newfile));
+				srcFile.move(dstFile);
 			}
-			hasUnsavedChanges = true;
-			return success;
+			success = true;
+		} catch (Exception e) {
+			Global.getPref().log("Error renaming waypoint details", e, true);
+			// TODO: any chance of a roll back?
+			// TODO: should we ignore a file not found?
 		}
+		hasUnsavedChanges = true;
+		return success;
+	}
 }
-
-

Modified: branches/r1.2/src/CacheWolf/CacheImages.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheImages.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheImages.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -30,66 +30,75 @@
 import ewe.util.Vector;
 
 /**
- * This class holds the image information of a cache. 
+ * This class holds the image information of a cache.
+ * 
  * @author torsti
- *
+ * 
  */
 public class CacheImages {
-	
-	private int initialSize=10;
-	/** Lazy initialization of the vector: It is created only when needed. If it is not accessed,
-	 * it will stay <code>null</code>.*/
-	private Vector vector=null;
+
+	private int initialSize = 10;
+	/**
+	 * Lazy initialization of the vector: It is created only when needed. If it is not accessed,
+	 * it will stay <code>null</code>.
+	 */
+	private Vector vector = null;
 	/** Images that should display in the image panel */
-	private CacheImages display=null;
-	
-	public CacheImages(){ // Public constructor
+	private CacheImages display = null;
+
+	public CacheImages() { // Public constructor
 	}
 
 	public CacheImages(int initialSize) {
-		if (initialSize<0) {
-			throw new IllegalArgumentException("Initial size for CacheImage must be > 0. Value: "+String.valueOf(initialSize));
+		if (initialSize < 0) {
+			throw new IllegalArgumentException("Initial size for CacheImage must be > 0. Value: " + String.valueOf(initialSize));
 		}
 		this.initialSize = initialSize;
 	}
-	private Vector getVector(){
-		if (this.vector==null) {
+
+	private Vector getVector() {
+		if (this.vector == null) {
 			vector = new Vector(this.initialSize);
 		}
 		return this.vector;
 	}
-	
+
 	/**
-	 * Adds an ImageInfo object to the list of images. The object is always appended in the 
+	 * Adds an ImageInfo object to the list of images. The object is always appended in the
 	 * last position.
-	 * @param img ImageInfo object to add.
+	 * 
+	 * @param img
+	 *            ImageInfo object to add.
 	 */
 	public void add(ImageInfo img) {
-		display = null;  // New Image? Force display to get reevaluated 
-        getVector().add(img);
-    }
-	
+		display = null; // New Image? Force display to get reevaluated
+		getVector().add(img);
+	}
+
 	/**
 	 * Gets the ImageInfo object at the specified position.
-	 * @param idx Index of object to retrieve.
+	 * 
+	 * @param idx
+	 *            Index of object to retrieve.
 	 * @return ImageInfo object
 	 */
 	public ImageInfo get(int idx) {
 		return (ImageInfo) getVector().get(idx);
 	}
-	
+
 	/**
 	 * Removes all image information.
 	 */
 	public void clear() {
-		if (this.vector!=null) {
-			display = null; 
+		if (this.vector != null) {
+			display = null;
 			this.vector.clear();
 		}
 	}
-	
+
 	/**
 	 * Returns the number of ImageInfo objects in the collection.
+	 * 
 	 * @return Number
 	 */
 	public int size() {
@@ -99,52 +108,59 @@
 			return this.vector.size();
 		}
 	}
-	
+
 	/**
 	 * Fills the <code>display</code> collection with the images that really should display
 	 * in the image panel.
-	 * @param prefix The prefix which is used to name default image titles
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
 	 */
 	private void checkForDisplayImages(String prefix) {
-		if (this.size()>1) {
+		if (this.size() > 1) {
 			display = new CacheImages(this.size());
 			// Loop over every image
-			for (int i=0; i<this.size(); i++) {
+			for (int i = 0; i < this.size(); i++) {
 				boolean shouldDisplay = true;
 				ImageInfo currImg = this.get(i);
 				// Now check against every other image
-				for (int j=0; j<this.size(); j++) {
-					if (i==j) continue; // Except same image
+				for (int j = 0; j < this.size(); j++) {
+					if (i == j)
+						continue; // Except same image
 					ImageInfo testImg = this.get(j);
 					// Are the filenames the same?
 					if (currImg.getFilename().toLowerCase().equals(testImg.getFilename().toLowerCase())) {
 						// Check if other title is better than current one
-						if (currImg.getTitle().startsWith(prefix) &&
-							!testImg.getTitle().startsWith(prefix)) {
+						if (currImg.getTitle().startsWith(prefix) && !testImg.getTitle().startsWith(prefix)) {
 							// If yes: Don't show the image
 							shouldDisplay = false;
 						}
 					}
 				}
-				if (shouldDisplay) display.add(currImg);
+				if (shouldDisplay)
+					display.add(currImg);
 			}
 		}
 	}
-	
+
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should <b>not</b> be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should <b>not</b> be present in this collection if its title is
 	 * starting with the indicated prefix and if there is another image referring to the same file but
 	 * with a different title.<br>
 	 * Normally, the results are cached and don't need to be evaluated again. If they should
-	 * be reevaluated for whatever reason, then pass <code>true</code> as parameter.  
-	 * @param prefix The prefix which is used to name default image titles
-	 * @param forceEvaluation When <code>true</code> the images that should display are
-	 * reexamined.
-	 * @return The CacheImage collection of images. 
+	 * be reevaluated for whatever reason, then pass <code>true</code> as parameter.
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @param forceEvaluation
+	 *            When <code>true</code> the images that should display are
+	 *            reexamined.
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix, boolean forceEvaluation) {
-		if (display == null || forceEvaluation) this.checkForDisplayImages(prefix);
+		if (display == null || forceEvaluation)
+			this.checkForDisplayImages(prefix);
 		if (display == null) {
 			return this;
 		} else {
@@ -153,40 +169,42 @@
 	}
 
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should <b>not</b> be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should <b>not</b> be present in this collection if its title is
 	 * equivalent to its filename and if there is another image referring to the same file but
 	 * with a different title.
-	 * @param prefix The prefix which is used to name default image titles
-	 * @return The CacheImage collection of images. 
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix) {
 		return this.getDisplayImages(prefix, false);
 	}
-	
+
 	/**
 	 * Checks if a image of a given URL needs to be spidered. It does <b>not</b> need to be spidered
-	 * if the following conditions meet: <ul>
-	 * <li>The url is from <code>http://img.geocaching.com/cache/</code> or 
-	 * <code>http://img.groundspeak.com/cache/</code>. (Reason: Images at these places don't change - 
-	 * if images change, they get a new url.)</li>
+	 * if the following conditions meet:
+	 * <ul>
+	 * <li>The url is from <code>http://img.geocaching.com/cache/</code> or <code>http://img.groundspeak.com/cache/</code>. (Reason: Images at these places don't change - if images change, they get a new url.)</li>
 	 * <li>An image with the given URL is among the images of the caches image object.</li>
 	 * <li>The intended file name is the same.</li>
 	 * <li>The image is present in the file system.</li>
-	 * </ul> If no spidering is needed, then the <code>ImageInfo</code> object of the equivalent image is
+	 * </ul>
+	 * If no spidering is needed, then the <code>ImageInfo</code> object of the equivalent image is
 	 * returned, otherwise (when spidering is needed) <code>null</code> is returned.
-	 * @param pNewUrl URL to check
+	 * 
+	 * @param pNewUrl
+	 *            URL to check
 	 * @return ImageInfo object
 	 */
 	public ImageInfo needsSpidering(String pNewUrl, String pFilename) {
 		String newUrl = CacheImages.optimizeLink(pNewUrl);
 		ImageInfo result = null;
-		if (this.size() > 0 && 
-				(newUrl.startsWith("http://img.geocaching.com/cache/"))) {
-			for (int i=0; i<this.size(); i++) {
+		if (this.size() > 0 && (newUrl.startsWith("http://img.geocaching.com/cache/"))) {
+			for (int i = 0; i < this.size(); i++) {
 				ImageInfo img = this.get(i);
-				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) 
-						&& img.getFilename().equals(pFilename)) {
+				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) && img.getFilename().equals(pFilename)) {
 					String location = Global.getProfile().dataDir + pFilename;
 					if ((new FileBugfix(location)).exists()) {
 						result = img;
@@ -197,16 +215,18 @@
 		}
 		return result;
 	}
-	
+
 	/**
-	 * Checks if an image with a certain filename is present in the collection of the caches 
+	 * Checks if an image with a certain filename is present in the collection of the caches
 	 * images.
-	 * @param filename Filename to check
+	 * 
+	 * @param filename
+	 *            Filename to check
 	 * @return <code>true</code> if there is such a file, <code>false</code> if not.
 	 */
 	private boolean hasFile(String filename) {
 		boolean result = false;
-		for (int i=0; i<this.size(); i++) {
+		for (int i = 0; i < this.size(); i++) {
 			if (this.get(i).getFilename().toUpperCase().equals(filename.toUpperCase())) {
 				result = true;
 				break;
@@ -214,38 +234,43 @@
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Deletes images that are no longer needed. It takes two CacheImage objects as arguments, one
-	 * as a collection of images before an update, the other after. Then every file in the old 
+	 * as a collection of images before an update, the other after. Then every file in the old
 	 * collection is checked if it is also present in the new collection. If not, the file is deleted.
 	 * Note that the <i>content</i> of the files is irrelevant. It is only important to remove files
-	 * - regardles of their contents - if they are no longer referenced after a cache update. 
-	 * @param oldImages Set of images before update
-	 * @param newImages Set of images after update
+	 * - regardles of their contents - if they are no longer referenced after a cache update.
+	 * 
+	 * @param oldImages
+	 *            Set of images before update
+	 * @param newImages
+	 *            Set of images after update
 	 */
 	public static void cleanupOldImages(CacheImages oldImages, CacheImages newImages) {
 		// Loop over every image in the old collection
-		for (int i=0; i<oldImages.size(); i++) {
+		for (int i = 0; i < oldImages.size(); i++) {
 			// Check if image file is present in new collection
 			String obsoleteFilename = oldImages.get(i).getFilename();
 			if (!newImages.hasFile(obsoleteFilename)) {
 				String location = Global.getProfile().dataDir + obsoleteFilename;
 				File tmpFile = new FileBugfix(location);
 				if (tmpFile.exists() && tmpFile.canWrite()) {
-					Global.getPref().log("Image not longer needed. Deleting: "+obsoleteFilename);
+					Global.getPref().log("Image not longer needed. Deleting: " + obsoleteFilename);
 					tmpFile.delete();
 				}
 			}
 		}
 	}
-	
+
 	/**
 	 * Takes an image url and does some optimization: As img.groundspeak.com is the same as
-	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html, 
-	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to 
+	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html,
+	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to
 	 * identify identical pictures as such.
-	 * @param pUrl URL to modify
+	 * 
+	 * @param pUrl
+	 *            URL to modify
 	 * @return Same URL, eventually modified
 	 */
 	public static String optimizeLink(String pUrl) {
@@ -256,5 +281,5 @@
 		}
 		return url;
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/CacheList.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -133,14 +133,12 @@
 		myList(int rows, int columns, boolean multi) { super(rows,columns,multi); }
 
 		//  Allow the caches to be dragged out of the cachelist
-		String wayPoint;
 		int idx;
 
 		public void startDragging(DragContext dc) {
 			 idx=getSelectedIndex(0);
 			 if (idx>=0) {
 				 CacheHolder ch=cacheList.get(idx);
-				 wayPoint=ch.getWayPoint();
 				 IconAndText imgDrag=new IconAndText();
 				 imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
 				 imgDrag.addColumn(ch.getWayPoint());

Modified: branches/r1.2/src/CacheWolf/CacheType.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheType.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheType.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Image;
@@ -31,26 +31,27 @@
 	public byte _cwMappedCType; // CW Cache Typ intern
 	public byte _cwCType; // CW Cache Typ intern
 	public char _cwCGroup; // Cache Typ Group intern
-	public String _cwCTypeV1; // V1 Cache Typ 
-	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com 
-	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com 
-	public byte _cwCTypeV2; // V2 Cache Typ 
+	public String _cwCTypeV1; // V1 Cache Typ
+	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com
+	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com
+	public byte _cwCTypeV2; // V2 Cache Typ
 	public char _gpxShortCType; // Short Typ (one char abbreviation)
 	public String _imageName; // name of imageName for Icon, "showCacheInBrowser" and "KML Export"
 	public String _gpxWptTypeTag; // gpx wpt <type> tag
 	public String _gpxWptSymTag; // gpx wpt <sym> tag
 	public String _gpxWptGCextensionTypTag; // gpx cache extension <groundspeak:type> tag
-	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources 		
+	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources
 	public int _msgNrCTypeName; // message number for gui cache Typ name
 	public int _GUIOrder; // sort Order in GUI selection //TODO more intelligent implementation (now manually change each line on new one)
-	public int _FilterStringPos; // BitNr in Filter String (profile) 
+	public int _FilterStringPos; // BitNr in Filter String (profile)
 	public int _FilterPattern; // 2**BitNr in Filter int (does not correspond with BitNr in String)
-	public Image _iconImage; 
+	public Image _iconImage;
 	public Image _mapImage;
-	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, 
-			String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, 
-			String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos, int filterPattern) {
-		
+	public Image[] _modImage = { null, null, null, null, null, null, null };
+
+	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos,
+			int filterPattern) {
+
 		_cwMappedCType = cwMappedCType;
 		_cwCType = cwCType;
 		_cwCGroup = cwCGroup;
@@ -69,15 +70,14 @@
 		_FilterStringPos = filterStringPos;
 		_FilterPattern = filterPattern;
 		if (!_imageName.equals("")) {
-			_iconImage=new Image(_imageName);
-			_mapImage=_iconImage;
+			_iconImage = new Image(_imageName);
+			_mapImage = _iconImage;
 		}
 	}
 }
 
-
 /**
- * Handles all aspects of converting cache type information 
+ * Handles all aspects of converting cache type information
  * from and to the various im- and exporters ...
  * converting legacy profiles to current standard
  *
@@ -110,7 +110,7 @@
 	public static final byte CW_TYPE_WEBCAM = 11;
 	/** locationless cache (GC) */
 	public static final byte CW_TYPE_LOCATIONLESS = 12;
-	/** CITO cache (GC)*/
+	/** CITO cache (GC) */
 	public static final byte CW_TYPE_CITO = 13;
 	/** Mega Event Cache (GC) */
 	public static final byte CW_TYPE_MEGA_EVENT = 100;
@@ -132,88 +132,103 @@
 	public static final byte CW_TYPE_REFERENCE = 55;
 	/** unrecognized cache type or missing information */
 	public static final byte CW_TYPE_ERROR = -1;
-	String[] ggpx={"Geocache|Custom","Custom","Custom",""};
+	String[] ggpx = { "Geocache|Custom", "Custom", "Custom", "" };
+	private static final byte found = 0;
+	private static final byte archived = 1;
+	private static final byte disabled = 2;
+	private static final byte solved = 3;
+	private static final byte bonus = 4;
+	private static final byte owned = 5;
+	private static final byte dnf = 6;
+	//
 	private static final CTyp[] cTypRef = {
-		// custom waypoints
-		new CTyp(CW_TYPE_CUSTOM,CW_TYPE_CUSTOM,'P',"0","","",(byte) -128,'C',"typeCustom.png",new String[] {"Geocache|Custom","Custom","Custom",""},1,0,10,0x000100),
-		// Cache waypoints
-		new CTyp(CW_TYPE_TRADITIONAL,CW_TYPE_TRADITIONAL,'C',"2","2","2",(byte) -126,'T',"typeTradi.png",new String[] {"Geocache|Traditional Cache","Geocache","Traditional Cache","Traditional|Classic"},2,1,0,0x000001),
-		new CTyp(CW_TYPE_MULTI,CW_TYPE_MULTI,'C',"3","3","3",(byte) -125,'M',"typeMulti.png",new String[] {"Geocache|Multi-cache","Geocache","Multi-cache","Multi|Offset"},3,2,1,0x000002),
-		new CTyp(CW_TYPE_VIRTUAL,CW_TYPE_VIRTUAL,'C',"4","4","4",(byte) -124,'V',"typeVirtual.png",new String[] {"Geocache|Virtual Cache","Geocache","Virtual Cache","Virtual"},4,3,2,0x000004),
-		new CTyp(CW_TYPE_LETTERBOX,CW_TYPE_LETTERBOX,'C',"5","5","",(byte) -123,'L',"typeLetterbox.png",new String[] {"Geocache|Letterbox Hybrid","Geocache","Letterbox Hybrid","Letterbox"},5,4,3,0x000008),
-		new CTyp(CW_TYPE_EVENT,CW_TYPE_EVENT,'C',"6","6","6",(byte) -122,'X',"typeEvent.png",new String[] {"Geocache|Event Cache","Geocache","Event Cache","Event"},6,5,4,0x000010),
-		new CTyp(CW_TYPE_MEGA_EVENT,CW_TYPE_MEGA_EVENT,'C',"453","453","",(byte) 101,'X',"typeMegaevent.png",new String[] {"Geocache|Mega-Event Cache","Geocache","Mega-Event Cache","Mega"},14,6,9,0x000200),
-		new CTyp(CW_TYPE_WEBCAM,CW_TYPE_WEBCAM,'C',"11","11","5",(byte) -117,'W',"typeWebcam.png",new String[] {"Geocache|Webcam Cache","Geocache","Webcam Cache","Webcam"},11,7,5,0x000020),
-		new CTyp(CW_TYPE_UNKNOWN,CW_TYPE_UNKNOWN,'C',"8","8","",(byte) -120,'U',"typeUnknown.png",new String[] {"Geocache|Unknown Cache","Geocache","Unknown Cache","Mystery"},8,8,6,0x000040),
-		new CTyp(CW_TYPE_LOCATIONLESS,CW_TYPE_LOCATIONLESS,'C',"12","12","",(byte) -116,'O',"typeLocless.png",new String[] {"Geocache|Locationless (Reverse) Cache","Geocache","Locationless (Reverse) Cache","Locationless"},12,9,8,0x000080),
-		new CTyp(CW_TYPE_CITO,CW_TYPE_CITO,'C',"13","13","",(byte) -115,'X',"typeCito.png",new String[] {"Geocache|Cache In Trash Out Event","Geocache","Cache In Trash Out Event","CITO"},13,10,17,0x020000),
-		new CTyp(CW_TYPE_EARTH,CW_TYPE_EARTH,'C',"137","137","",(byte) 9,'E',"typeEarth.png",new String[] {"Geocache|Earthcache","Geocache","Earthcache","Earth"},18,11,7,0x000400),
-		new CTyp(CW_TYPE_WHEREIGO,CW_TYPE_WHEREIGO,'C',"1858","1858","",(byte) 100,'G',"typeWhereigo.png",new String[] {"Geocache|Wherigo Cache","Geocache","Wherigo Cache","Wherigo"},15,12,18,0x040000),
-		// additional waypoints
-		new CTyp(CW_TYPE_PARKING,CW_TYPE_PARKING,'A',"50","","",(byte) -78,'P',"typeParking.png",new String[] {"Waypoint|Parking Area","Parking Area","Parking Area",""},50,13,11,0x000800),
-		new CTyp(CW_TYPE_STAGE,CW_TYPE_STAGE,'A',"51","","",(byte) -77,'S',"typeStage.png",new String[] {"Waypoint|Stages of a Multicache","Stages of a Multicache","Stages of a Multicache",""},51,14,12,0x001000),
-		new CTyp(CW_TYPE_QUESTION,CW_TYPE_QUESTION,'A',"52","","",(byte) -76,'Q',"typeQuestion.png",new String[] {"Waypoint|Question to Answer","Question to Answer","Question to Answer",""},52,15,13,0x002000),
-		new CTyp(CW_TYPE_FINAL,CW_TYPE_FINAL,'A',"53","","",(byte) -75,'F',"typeFinal.png",new String[] {"Waypoint|Final Location","Final Location","Final Location",""},53,16,14,0x004000),
-		new CTyp(CW_TYPE_TRAILHEAD,CW_TYPE_TRAILHEAD,'A',"54","","",(byte) -74,'H',"typeTrailhead.png",new String[] {"Waypoint|Trailhead","Trailhead","Trailhead",""},54,17,15,0x008000),
-		new CTyp(CW_TYPE_REFERENCE,CW_TYPE_REFERENCE,'A',"55","","",(byte) -73,'R',"typeReference.png",new String[] {"Waypoint|Reference Point","Reference Point","Reference Point",""},55,18,16,0x010000),
-		// error on waypoint
-		new CTyp(CW_TYPE_ERROR,CW_TYPE_ERROR,'E',"","","",(byte) -1,'-',"guiError.png",new String[] {"","","",""},49,-1,-1,0),
-        // mapped types (recognized on input from gpx or download-spider / or cw - version)                 
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 1,'C',"","","1",(byte) -1,'U',"",new String[] {"Geocache|Other","Geocache","Other","Other"},21,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 7,'C',"7","","7",(byte) -121,'U',"",new String[] {"Geocache|Quiz","Geocache","Quiz","Quiz"},7,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 9,'C',"9","","9",(byte) -119,'U',"",new String[] {"Geocache|Moving","Geocache","Moving","Moving"},9,-1,-1,0),
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 10,'C',"10","","10",(byte) -118,'U',"",new String[] {"Geocache|DriveIn","Geocache","DriveIn","DriveIn"},10,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 14,'C',"","3653","",(byte) -1,'X',"",new String[] {"Geocache|Lost and Found Event Cache","Geocache","Lost and Found Event Cache",""},6,-1,-1,0),		         
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 102,'C',"","9","",(byte) -1,'T',"",new String[] {"Geocache|Project APE Cache","Geocache","Project APE Cache","APE"},16,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 103,'C',"","1304","",(byte) -1,'X',"",new String[] {"Geocache|GPS Adventures Exhibit","Geocache","GPS Adventures Exhibit","MAZE"},17,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 108,'C',"","","8",(byte) -1,'U',"",new String[] {"only on OC download","","",""},19,-1,-1,0),
-		new CTyp(CW_TYPE_WHEREIGO,(byte) 15,'C',"","","",(byte) -62,'G',"",new String[] {"Hack for V2 Typ","","",""},-1,-1,-1,0),
-	};
+			// custom waypoints
+			new CTyp(CW_TYPE_CUSTOM, CW_TYPE_CUSTOM, 'P', "0", "", "", (byte) -128, 'C', "typeCustom.png", new String[] { "Geocache|Custom", "Custom", "Custom", "" }, 1, 0, 10, 0x000100),
+			// Cache waypoints
+			new CTyp(CW_TYPE_TRADITIONAL, CW_TYPE_TRADITIONAL, 'C', "2", "2", "2", (byte) -126, 'T', "typeTradi.png", new String[] { "Geocache|Traditional Cache", "Geocache", "Traditional Cache", "Traditional|Classic" }, 2, 1, 0, 0x000001),
+			new CTyp(CW_TYPE_MULTI, CW_TYPE_MULTI, 'C', "3", "3", "3", (byte) -125, 'M', "typeMulti.png", new String[] { "Geocache|Multi-cache", "Geocache", "Multi-cache", "Multi|Offset" }, 3, 2, 1, 0x000002),
+			new CTyp(CW_TYPE_VIRTUAL, CW_TYPE_VIRTUAL, 'C', "4", "4", "4", (byte) -124, 'V', "typeVirtual.png", new String[] { "Geocache|Virtual Cache", "Geocache", "Virtual Cache", "Virtual" }, 4, 3, 2, 0x000004),
+			new CTyp(CW_TYPE_LETTERBOX, CW_TYPE_LETTERBOX, 'C', "5", "5", "", (byte) -123, 'L', "typeLetterbox.png", new String[] { "Geocache|Letterbox Hybrid", "Geocache", "Letterbox Hybrid", "Letterbox" }, 5, 4, 3, 0x000008),
+			new CTyp(CW_TYPE_EVENT, CW_TYPE_EVENT, 'C', "6", "6", "6", (byte) -122, 'X', "typeEvent.png", new String[] { "Geocache|Event Cache", "Geocache", "Event Cache", "Event" }, 6, 5, 4, 0x000010),
+			new CTyp(CW_TYPE_MEGA_EVENT, CW_TYPE_MEGA_EVENT, 'C', "453", "453", "", (byte) 101, 'X', "typeMegaevent.png", new String[] { "Geocache|Mega-Event Cache", "Geocache", "Mega-Event Cache", "Mega" }, 14, 6, 9, 0x000200),
+			new CTyp(CW_TYPE_WEBCAM, CW_TYPE_WEBCAM, 'C', "11", "11", "5", (byte) -117, 'W', "typeWebcam.png", new String[] { "Geocache|Webcam Cache", "Geocache", "Webcam Cache", "Webcam" }, 11, 7, 5, 0x000020),
+			new CTyp(CW_TYPE_UNKNOWN, CW_TYPE_UNKNOWN, 'C', "8", "8", "", (byte) -120, 'U', "typeUnknown.png", new String[] { "Geocache|Unknown Cache", "Geocache", "Unknown Cache", "Mystery" }, 8, 8, 6, 0x000040),
+			new CTyp(CW_TYPE_LOCATIONLESS, CW_TYPE_LOCATIONLESS, 'C', "12", "12", "", (byte) -116, 'O', "typeLocless.png", new String[] { "Geocache|Locationless (Reverse) Cache", "Geocache", "Locationless (Reverse) Cache", "Locationless" }, 12, 9, 8,
+					0x000080),
+			new CTyp(CW_TYPE_CITO, CW_TYPE_CITO, 'C', "13", "13", "", (byte) -115, 'X', "typeCito.png", new String[] { "Geocache|Cache In Trash Out Event", "Geocache", "Cache In Trash Out Event", "CITO" }, 13, 10, 17, 0x020000),
+			new CTyp(CW_TYPE_EARTH, CW_TYPE_EARTH, 'C', "137", "137", "", (byte) 9, 'E', "typeEarth.png", new String[] { "Geocache|Earthcache", "Geocache", "Earthcache", "Earth" }, 18, 11, 7, 0x000400),
+			new CTyp(CW_TYPE_WHEREIGO, CW_TYPE_WHEREIGO, 'C', "1858", "1858", "", (byte) 100, 'G', "typeWhereigo.png", new String[] { "Geocache|Wherigo Cache", "Geocache", "Wherigo Cache", "Wherigo" }, 15, 12, 18, 0x040000),
+			// additional waypoints
+			new CTyp(CW_TYPE_PARKING, CW_TYPE_PARKING, 'A', "50", "", "", (byte) -78, 'P', "typeParking.png", new String[] { "Waypoint|Parking Area", "Parking Area", "Parking Area", "" }, 50, 13, 11, 0x000800),
+			new CTyp(CW_TYPE_STAGE, CW_TYPE_STAGE, 'A', "51", "", "", (byte) -77, 'S', "typeStage.png", new String[] { "Waypoint|Stages of a Multicache", "Stages of a Multicache", "Stages of a Multicache", "" }, 51, 14, 12, 0x001000),
+			new CTyp(CW_TYPE_QUESTION, CW_TYPE_QUESTION, 'A', "52", "", "", (byte) -76, 'Q', "typeQuestion.png", new String[] { "Waypoint|Question to Answer", "Question to Answer", "Question to Answer", "" }, 52, 15, 13, 0x002000),
+			new CTyp(CW_TYPE_FINAL, CW_TYPE_FINAL, 'A', "53", "", "", (byte) -75, 'F', "typeFinal.png", new String[] { "Waypoint|Final Location", "Final Location", "Final Location", "" }, 53, 16, 14, 0x004000),
+			new CTyp(CW_TYPE_TRAILHEAD, CW_TYPE_TRAILHEAD, 'A', "54", "", "", (byte) -74, 'H', "typeTrailhead.png", new String[] { "Waypoint|Trailhead", "Trailhead", "Trailhead", "" }, 54, 17, 15, 0x008000),
+			new CTyp(CW_TYPE_REFERENCE, CW_TYPE_REFERENCE, 'A', "55", "", "", (byte) -73, 'R', "typeReference.png", new String[] { "Waypoint|Reference Point", "Reference Point", "Reference Point", "" }, 55, 18, 16, 0x010000),
+			// error on waypoint
+			new CTyp(CW_TYPE_ERROR, CW_TYPE_ERROR, 'E', "", "", "", (byte) -1, '-', "guiError.png", new String[] { "", "", "", "" }, 49, -1, -1, 0),
+			// mapped types (recognized on input from gpx or download-spider / or cw - version)
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 1, 'C', "", "", "1", (byte) -1, 'U', "", new String[] { "Geocache|Other", "Geocache", "Other", "Other" }, 21, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 7, 'C', "7", "", "7", (byte) -121, 'U', "", new String[] { "Geocache|Quiz", "Geocache", "Quiz", "Quiz" }, 7, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 9, 'C', "9", "", "9", (byte) -119, 'U', "", new String[] { "Geocache|Moving", "Geocache", "Moving", "Moving" }, 9, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 10, 'C', "10", "", "10", (byte) -118, 'U', "", new String[] { "Geocache|DriveIn", "Geocache", "DriveIn", "DriveIn" }, 10, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 14, 'C', "", "3653", "", (byte) -1, 'X', "", new String[] { "Geocache|Lost and Found Event Cache", "Geocache", "Lost and Found Event Cache", "" }, 6, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 102, 'C', "", "9", "", (byte) -1, 'T', "", new String[] { "Geocache|Project APE Cache", "Geocache", "Project APE Cache", "APE" }, 16, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 103, 'C', "", "1304", "", (byte) -1, 'X', "", new String[] { "Geocache|GPS Adventures Exhibit", "Geocache", "GPS Adventures Exhibit", "MAZE" }, 17, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 108, 'C', "", "", "8", (byte) -1, 'U', "", new String[] { "only on OC download", "", "", "" }, 19, -1, -1, 0),
+			new CTyp(CW_TYPE_WHEREIGO, (byte) 15, 'C', "", "", "", (byte) -62, 'G', "", new String[] { "Hack for V2 Typ", "", "", "" }, -1, -1, -1, 0), };
 	// public static final int anzCacheTyps=cTypRef.length;
-	public static final byte maxCWCType=110;
-    static final byte[] Ref_Index = new byte[maxCWCType];
+	public static final byte maxCWCType = 110;
+	static final byte[] Ref_Index = new byte[maxCWCType];
 	static {
 		// +1 cause error is -1 and array starts at 0
-	  for (byte i = (byte) (cTypRef.length - 1); i>=0; i--) {
-		  Ref_Index[1 + cTypRef[i]._cwCType]= i;
-	   }
+		for (byte i = (byte) (cTypRef.length - 1); i >= 0; i--) {
+			Ref_Index[1 + cTypRef[i]._cwCType] = i;
+		}
 	}
+
 	public static byte Ref_Index(final byte type) {
-		byte ret=Ref_Index[cTypRef[Ref_Index[type+1]]._cwMappedCType + 1];
+		final byte ret = Ref_Index[cTypRef[Ref_Index[type + 1]]._cwMappedCType + 1];
 		return ret;
 	}
-	
-	
-	
+
 	/**
 	 * check if a given waypoint type is an additional waypoint
-	 * @param type waypoint type to check
+	 *
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an additional waypoint, false otherwise
 	 */
 	public static boolean isAddiWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'A';
 	}
+
 	/**
 	 * check if a given waypoint type is an cache waypoint
-	 * @param type waypoint type to check
+	 *
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Cache waypoint, false otherwise
 	 */
 	public static boolean isCacheWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'C';
 	}
+
 	/**
 	 * check if a given waypoint type is an Custom waypoint
-	 * @param type waypoint type to check
+	 *
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Custom waypint, false otherwise
 	 */
 	public static boolean isCustomWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'P';
 	}
-	
-	
+
 	// done for DetailsPanel.java and KML- and TomTom-Exporter
 	/**
 	 * create list of cache types to be shown in GUI drop down lists
+	 *
 	 * @return list of cache types to be shown in GUI drop down list
 	 * @see guiSelect2Cw
 	 * @see cw2GuiSelect
@@ -222,36 +237,47 @@
 		int j = 0;
 		for (int i = 0; i < cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder > j) {
-				j=cTypRef[i]._GUIOrder;
+				j = cTypRef[i]._GUIOrder;
 			}
 		}
-		String[] ret = new String[j+1];
+		final String[] ret = new String[j + 1];
 		for (int i = 0; i < cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder > -1) {
-				ret[cTypRef[i]._GUIOrder]=MyLocale.getMsg(cTypRef[i]._msgNrCTypeName,"");
+				ret[cTypRef[i]._GUIOrder] = MyLocale.getMsg(cTypRef[i]._msgNrCTypeName, "");
 			}
 		}
 		return ret;
 	}
+
 	/**
 	 * translate GUI drop down index selection back to internally stored type
-	 * @param selection index value from drop down list
+	 *
+	 * @param selection
+	 *            index value from drop down list
 	 * @return internal type
-	 * @throws IllegalArgumentException if <code>selection</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>selection</code> can not be matched
 	 * @see guiTypeStrings
 	 * @see cw2GuiSelect
 	 */
 	public static byte guiSelect2Cw(final int selection) {
-		for (byte i=0; i<cTypRef.length; i++) {
-			if (cTypRef[i]._GUIOrder == selection) {return cTypRef[i]._cwCType;};
+		for (byte i = 0; i < cTypRef.length; i++) {
+			if (cTypRef[i]._GUIOrder == selection) {
+				return cTypRef[i]._cwCType;
+			}
+			;
 		}
 		return -1;
 	}
+
 	/**
 	 * translate cache type to position of index to highlight in GUI cache type drop down list
-	 * @param typeId internal id of cache type
+	 *
+	 * @param typeId
+	 *            internal id of cache type
 	 * @return index of the cache type in GUI list
-	 * @throws IllegalArgumentException if <code>id</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>id</code> can not be matched
 	 * @see guiTypeStrings
 	 * @see guiSelect2Cw
 	 */
@@ -259,35 +285,46 @@
 		return cTypRef[Ref_Index(typeId)]._GUIOrder;
 	}
 
-	
-	
 	/**
 	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
-	 * @param gpxType type information found in GPX
+	 *
+	 * @param gpxType
+	 *            type information found in GPX
 	 * @return internal cache type
 	 */
 	public static byte gpxType2CwType(final String gpxType) throws IllegalArgumentException {
-		for (byte i=0; i<cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptTypeTag.equals(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i < cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
-		for (byte i=0; i<cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptGCextensionTypTag.equals(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i < cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
-		for (byte i=0; i<cTypRef.length; i++) {
-			if (cTypRef[i]._gpxAlternativeWptTypTags.indexOf(gpxType) != -1) {
+		final String lowerCaseGPXType = gpxType.toLowerCase();
+		for (byte i = 0; i < cTypRef.length; i++) {
+			if (cTypRef[i]._gpxAlternativeWptTypTags.toLowerCase().indexOf(lowerCaseGPXType) != -1) {
 				return cTypRef[i]._cwMappedCType;
-			};
+			}
+			;
 		}
 		// TODO extend definition of _gpxAlternativeWptTypTags for all cases of Mystery
-		// old code was : if (!(gpxType.indexOf("Mystery")==-1)) return CW_TYPE_UNKNOWN; 
+		// old code was : if (!(gpxType.indexOf("Mystery")==-1)) return CW_TYPE_UNKNOWN;
 		return -1;
 	}
 
 	/**
 	 * convert the cache type information from an OC XML import to internal cache type
-	 * @param ocType cache type found in OC XML
+	 *
+	 * @param ocType
+	 *            cache type found in OC XML
 	 * @return internal cache type
-	 * @throws IllegalArgumentException if <code>ocType</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>ocType</code> can not be matched
 	 */
 	public static byte ocType2CwType(final String ocType) {
 		for (int i = 0; i < cTypRef.length; i++) {
@@ -297,11 +334,15 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert type information discovered by GC spider to internal type information
-	 * @param gcType type information from GC spider
+	 *
+	 * @param gcType
+	 *            type information from GC spider
 	 * @return internal representation of cache type
-	 * @throws IllegalArgumentException if <code>gcType</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>gcType</code> can not be matched
 	 */
 	public static byte gcSpider2CwType(final String gcType) {
 		for (int i = 0; i < cTypRef.length; i++) {
@@ -311,9 +352,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version1 type information to current values
-	 * @param type version1 cache type information
+	 *
+	 * @param type
+	 *            version1 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v1 file version compatibility is abandoned
 	 */
@@ -325,9 +369,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version2 type information to current values
-	 * @param type version2 cache type information
+	 *
+	 * @param type
+	 *            version2 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v2 file version compatibility is abandoned
 	 */
@@ -340,121 +387,218 @@
 		return -1;
 	}
 
-	
-	
 	/**
 	 * translate cache type to a short version for compact exporters or "smart" cache names.
-	 * @param typeId CacheWolf internal type information
+	 *
+	 * @param typeId
+	 *            CacheWolf internal type information
 	 * @return abbreviation of cache type
 	 */
 	public static String getExportShortId(final byte typeId) {
-		return ""+cTypRef[Ref_Index(typeId)]._gpxShortCType;
+		return "" + cTypRef[Ref_Index(typeId)]._gpxShortCType;
 	}
+
 	/**
 	 * map cache types to images
-	 * @param typeId internal cache type id
+	 *
+	 * @param typeId
+	 *            internal cache type id
 	 * @return non qualified name of image
 	 */
 	public static String typeImageForId(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._imageName;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com <type> GPX format
 	 */
 	public static String type2TypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptTypeTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return symb information in GC.com <sym> GPX format
 	 */
 	public static String type2SymTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptSymTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com <groundspeak:type> GPX format
 	 */
 	public static String type2GSTypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptGCextensionTypTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return Gui - string for type
 	 */
 	public static String type2Gui(final byte typeId) {
-		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName,"");
+		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName, "");
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 *
+	 * @param typeId
+	 *            internal cache type id
 	 * @return <code>Image</code> object to be displayed
 	 */
 	public static Image getTypeImage(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 *
+	 * @param typeId
+	 *            internal cache type id
 	 * @return <code>Image</code> object to be displayed
 	 */
-	public static Image getMapImage(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._mapImage;
+	public static Image getMapImage(CacheHolder ch) {
+		byte typeId = ch.getType();
+		Image im = cTypRef[Ref_Index(typeId)]._mapImage;
+		if (ch.is_found()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[found] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[found] = newOverlayedImage(im, GuiImageBroker.found);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[found];
+		} else if (ch.is_archived()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[archived] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[archived] = newOverlayedImage(im, GuiImageBroker.archived);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[archived];
+		} else if (!ch.is_available()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[disabled] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[disabled] = newOverlayedImage(im, GuiImageBroker.disabled);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[disabled];
+		} else if (ch.is_owned()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[owned] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[owned] = newOverlayedImage(im, GuiImageBroker.owned);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[owned];
+		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(362, "solved"))) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[solved] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[solved] = newOverlayedImage(im, GuiImageBroker.solved);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[solved];
+		} else if (ch.getCacheStatus().indexOf(MyLocale.getMsg(319, "Not Found")) > -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[dnf] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[dnf] = newOverlayedImage(im, GuiImageBroker.dnf);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[dnf];
+		} else if (ch.getCacheName().toLowerCase().indexOf("bonus") > -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[bonus] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[bonus] = newOverlayedImage(im, GuiImageBroker.bonus);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[bonus];
+		}
+		return im;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setTypeImage(final byte id, final Image iconImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage) 
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._iconImage.free();
-		cTypRef[Ref_Index(id)]._iconImage=iconImage;
+		cTypRef[Ref_Index(id)]._iconImage = iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setMapImage(final byte id, final Image mapImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage) 
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._mapImage.free();
-		cTypRef[Ref_Index(id)]._mapImage=mapImage;
+		cTypRef[Ref_Index(id)]._mapImage = mapImage;
 	}
-	
-	
+
 	// TODO do it better in Version 4
 	public static int getCacheTypePattern(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._FilterPattern;
 	}
+
 	public static int Type_FilterString2Type_FilterPattern(final String Type_FilterString) {
 		int typeMatchPattern = 0;
 		for (int i = 0; i < cTypRef.length; i++) {
 			if (cTypRef[i]._FilterStringPos > -1) {
 				if (Type_FilterString.charAt(cTypRef[i]._FilterStringPos) == '1') {
-					typeMatchPattern|=cTypRef[i]._FilterPattern;
+					typeMatchPattern |= cTypRef[i]._FilterPattern;
 				}
 			}
 		}
 		return typeMatchPattern;
 	}
+
 	public static boolean hasTypeMatchPattern(final int typeMatchPattern) {
 		return typeMatchPattern != 0;
 	}
+
 	public static boolean hasMainTypeMatchPattern(final int typeMatchPattern) {
 		int TYPE_MAIN = 0;
 		for (int i = 0; i < cTypRef.length; i++) {
-			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P' ) {
-				TYPE_MAIN|=cTypRef[i]._FilterPattern;
+			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P') {
+				TYPE_MAIN |= cTypRef[i]._FilterPattern;
 			}
 		}
 		return (typeMatchPattern & TYPE_MAIN) != 0;
 	}
-	
+
+	private static Image newOverlayedImage(Image imsrc, Image imovl) {
+		// Overlay added at topleft
+		int srcWidth = imsrc.getWidth();
+		int srcHeight = imsrc.getHeight();
+		int ovlWidth = imovl.getWidth();
+		int ovlHeight = imovl.getHeight();
+		if (srcWidth < ovlWidth || srcHeight < ovlHeight)
+			return imsrc;
+		int[] srcPixels = imsrc.getPixels(null, 0, 0, 0, srcWidth, srcHeight, 0);
+		int[] ovlPixels = imovl.getPixels(null, 0, 0, 0, ovlWidth, ovlHeight, 0);
+		int offsrc;
+		int offovl = 0;
+		for (int y = 0; y < ovlHeight; y++) { // top down
+			offsrc = y * srcWidth;
+			for (int x = 0; x < ovlWidth; x++) {
+				int alphaval = (ovlPixels[offovl] >> 24) & 0xff;
+				if (alphaval > 0) {
+					srcPixels[offsrc] = ovlPixels[offovl];
+				}
+				offovl++;
+				offsrc++;
+			}
+		}
+		Image modImage = new Image(imsrc, 0);
+		modImage.setPixels(srcPixels, 0, 0, 0, srcWidth, srcHeight, 0);
+		return modImage;
+	}
+
 	// TODO it for OCXMLImporterScreen and FilterScreen ?
 }

Modified: branches/r1.2/src/CacheWolf/CalcPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/CalcPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CalcPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -45,10 +45,10 @@
 import ewe.ui.formatted.TextDisplay;
 
 /**
-*	Class to create the panel to do calculation with waypoints<br>
-*	Also allows for creation of a custom waypoint.<br>
-*	Class ID 1400
-*/
+ *	Class to create the panel to do calculation with waypoints<br>
+ *	Also allows for creation of a custom waypoint.<br>
+ *	Class ID 1400
+ */
 
 /**
  * Wrapper class to pass bearing and distance
@@ -57,7 +57,7 @@
 	public double degrees;
 	public double distance;
 
-	public BearingDistance(){
+	public BearingDistance() {
 		this.degrees = 0;
 		this.distance = 0;
 	}
@@ -95,18 +95,17 @@
 	int currFormat;
 	mButton btnChangeLatLon;
 
-	public CalcPanel()	{
+	public CalcPanel() {
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		cacheDB = profile.cacheDB;
 
+		TopP.addNext(chkDD = new mCheckBox("d.d?"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMM = new mCheckBox("d?m.m\'"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMS = new mCheckBox("d?m\'s\""), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkCustom = new mCheckBox(""), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		TopP.addNext(chkDD =new mCheckBox("d.d?"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMM =new mCheckBox("d?m.m\'"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMS =new mCheckBox("d?m\'s\""),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		TopP.addNext(chkCustom =new mCheckBox(""),CellConstants.DONTSTRETCH, CellConstants.WEST);
-
 		chkDD.setGroup(chkFormat);
 		chkDMM.setGroup(chkFormat);
 		chkDMS.setGroup(chkFormat);
@@ -114,24 +113,25 @@
 		chkFormat.setInt(1);
 		currFormat = 1;
 		String[] ls = TransformCoordinates.getProjectedSystemNames();
-		TopP.addLast(localCooSystem = new mChoice(ls, 0),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addLast(localCooSystem = new mChoice(ls, 0), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		btnChangeLatLon=new mButton();
-		TopP.addLast(btnChangeLatLon,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//inpBearing and direction, unit for inpDistance
-		BottomP.addNext(new mLabel(MyLocale.getMsg(1403,"Bearing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(new mLabel(MyLocale.getMsg(1404,"Distance")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(inpBearing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		btnChangeLatLon = new mButton();
+		TopP.addLast(btnChangeLatLon, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpBearing and direction, unit for inpDistance
+		BottomP.addNext(new mLabel(MyLocale.getMsg(1403, "Bearing")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(new mLabel(MyLocale.getMsg(1404, "Distance")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(inpBearing = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpBearing.setText("0");
-		BottomP.addNext(inpDistance = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(inpDistance = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpDistance.setText("0");
 		// Check for narrow screen and reduce width of fields to avoid horizontal scroll panel
-		if (MyLocale.getScreenWidth()<=240) {
+		if (MyLocale.getScreenWidth() <= 240) {
 			FontMetrics fm = getFontMetrics(inpBearing.getFont());
-			inpBearing.setPreferredSize(fm.getTextWidth("99999999"),fm.getHeight()*4/3);
-			inpDistance.setPreferredSize(fm.getTextWidth("99999999"),fm.getHeight()*4/3);
+			inpBearing.setPreferredSize(fm.getTextWidth("99999999"), fm.getHeight() * 4 / 3);
+			inpDistance.setPreferredSize(fm.getTextWidth("99999999"), fm.getHeight() * 4 / 3);
 		}
-		BottomP.addLast(chcDistUnit = new mChoice(new String[]{"m", "km", MyLocale.getMsg(1407,"steps"), MyLocale.getMsg(1408,"feet"), MyLocale.getMsg(1409,"yards"), MyLocale.getMsg(1410,"miles")},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.INSETS,new ewe.fx.Insets(0,2,0,0));
+		BottomP.addLast(chcDistUnit = new mChoice(new String[] { "m", "km", MyLocale.getMsg(1407, "steps"), MyLocale.getMsg(1408, "feet"), MyLocale.getMsg(1409, "yards"), MyLocale.getMsg(1410, "miles") }, 0), CellConstants.DONTSTRETCH,
+				(CellConstants.HFILL | CellConstants.WEST)).setTag(CellConstants.INSETS, new ewe.fx.Insets(0, 2, 0, 0));
 		if (Global.getPref().metricSystem == Metrics.METRIC) {
 			chcDistUnit.setInt(0); // Meter
 		} else {
@@ -139,19 +139,19 @@
 		}
 
 		// Buttons for calc and save
-		BottomP.addNext(btnCalc = new mButton("Calc"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnClear = new mButton("Clear"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnGoto = new mButton("Goto"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnCalc = new mButton("Calc"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnClear = new mButton("Clear"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnGoto = new mButton("Goto"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311, "Create Waypoint")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
 		// Output
-		txtOutput = new TextDisplay(3,1); // Need to limit size for small screens
+		txtOutput = new TextDisplay(3, 1); // Need to limit size for small screens
 		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
-		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4, 1)), CellConstants.STRETCH, (CellConstants.FILL | CellConstants.WEST));
 
-		//add Panels
-		this.addLast(TopP,CellConstants.HSTRETCH, CellConstants.WEST);//.setTag(SPAN,new Dimension(4,1));
-		this.addLast(BottomP,CellConstants.VSTRETCH, CellConstants.VFILL|CellConstants.WEST); //.setTag(SPAN,new Dimension(4,1));
+		// add Panels
+		this.addLast(TopP, CellConstants.HSTRETCH, CellConstants.WEST);// .setTag(SPAN,new Dimension(4,1));
+		this.addLast(BottomP, CellConstants.VSTRETCH, CellConstants.VFILL | CellConstants.WEST); // .setTag(SPAN,new Dimension(4,1));
 
 	}
 
@@ -159,13 +159,13 @@
 		return CoordsScreen.getLocalSystem(currFormat);
 	}
 
-	public final void readFields(CWPoint coords, BearingDistance degKm){
+	public final void readFields(CWPoint coords, BearingDistance degKm) {
 		// coords.set(btnChangeLatLon.getText());
 		currFormat = CoordsScreen.combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt());
 		degKm.degrees = Common.parseDouble(inpBearing.getText());
 
 		double rawDistance = Common.parseDouble(inpDistance.getText());
-		switch ( chcDistUnit.getInt() ) {
+		switch (chcDistUnit.getInt()) {
 		case 0:
 			// meter
 			degKm.distance = rawDistance / 1000.0;
@@ -199,88 +199,81 @@
 	}
 
 	// ch must not be null
-	public void setFields(CacheHolder ch){
-		if ( !ch.getWayPoint().equalsIgnoreCase(lastWaypoint) ) {
+	public void setFields(CacheHolder ch) {
+		if (!ch.getWayPoint().equalsIgnoreCase(lastWaypoint)) {
 			lastWaypoint = ch.getWayPoint();
-			if (ch.pos.isValid()) {
+			if (ch.getPos().isValid()) {
 				inpBearing.setText("0");
 				inpDistance.setText("0");
-
-				//currFormat = 1;
-				if (ch.getLatLon().length()== 0) coordInp.set(0,0);
-				else coordInp.set(ch.getLatLon(), TransformCoordinates.CW);
+				coordInp.set(ch.getPos());
 				setFields();
 			}
 		}
 	}
 
-
 	public void setFields() {
 		btnChangeLatLon.setText(coordInp.toString(getLocalCooSystem()));
-		//chkFormat.selectIndex(currFormat);
+		// chkFormat.selectIndex(currFormat);
 	}
 
+	public void onEvent(Event ev) {
 
-	public void onEvent(Event ev){
-
-
-
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == chkFormat
-					|| ((ev.type == ControlEvent.PRESSED) && (ev.target == localCooSystem )) ) {
-				if (ev.target == localCooSystem) chkFormat.selectIndex(3);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == chkFormat || ((ev.type == ControlEvent.PRESSED) && (ev.target == localCooSystem))) {
+				if (ev.target == localCooSystem)
+					chkFormat.selectIndex(3);
 				readFields(coordInp, bd);
 				setFields();
 				this.repaintNow();
 			}
 
-			if (ev.target == btnCalc){
+			if (ev.target == btnCalc) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				txtOutput.appendText(coordOut.toString(getLocalCooSystem())+ "\n",true);
+				txtOutput.appendText(coordOut.toString(getLocalCooSystem()) + "\n", true);
 			}
-			if (ev.target == btnClear){
+			if (ev.target == btnClear) {
 				txtOutput.setText("");
 			}
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				ch.setLatLon(coordOut.toString());
-				ch.pos.set(coordOut);
+				ch.setPos(coordOut);
 				ch.setType(CacheType.CW_TYPE_STAGE); // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 
-			if (ev.target == btnGoto){
+			if (ev.target == btnGoto) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				mainT.gotoP.setDestinationAndSwitch(coordOut);
 			}
-			
-			if (ev.target == btnChangeLatLon){
-				if(Vm.isMobile()){
+
+			if (ev.target == btnChangeLatLon) {
+				if (Vm.isMobile()) {
 					readFields(coordInp, bd);
 					InputScreen InScr = new InputScreen(getLocalCooSystem());
-					if (coordInp.isValid())	InScr.setCoords(coordInp);
-						else InScr.setCoords(new CWPoint(0,0));
-				if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
-				{
-					btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(InScr.getCoords());
+					if (coordInp.isValid())
+						InScr.setCoords(coordInp);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
+					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
+						btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(InScr.getCoords());
+					}
+				} else {
+					CoordsScreen cs = new CoordsScreen();
+					readFields(coordInp, bd);
+					cs.setFields(coordInp, getLocalCooSystem());
+					if (cs.execute() == FormBase.IDOK) {
+						btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(cs.getCoords());
+					}
 				}
-			}else{
-				CoordsScreen cs = new CoordsScreen();
-				readFields(coordInp, bd);
-				cs.setFields(coordInp, getLocalCooSystem());
-				if (cs.execute()== FormBase.IDOK){
-					btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(cs.getCoords());
-				}
-			}
 
+			}
+			super.onEvent(ev);
 		}
-		super.onEvent(ev);
 	}
-	}
 }
\ No newline at end of file

Modified: branches/r1.2/src/CacheWolf/Common.java
===================================================================
--- branches/r1.2/src/CacheWolf/Common.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Common.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -185,7 +185,7 @@
 	}
 	
 	public static String fixSerialPortName(String name) {
-		if (name.startsWith("/")) return new String(".."+name); // on linux (*nix) machines it is quite usual to give the complete file path to the serial port, but ewe expects only "ttyS0" or similar
+		if (name.startsWith("/")) return ".."+name; // on linux (*nix) machines it is quite usual to give the complete file path to the serial port, but ewe expects only "ttyS0" or similar
 		else                      return name;
 	}
 	

Modified: branches/r1.2/src/CacheWolf/CoordsScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/CoordsScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CoordsScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.imp.SpiderGC;
@@ -50,11 +50,10 @@
 import ewe.ui.mLabel;
 
 /**
- *	Class for entering coordinates<br>
- *	Class IDs 1400 and 600 (same as calc panel and preferences screen)<br>
+ * Class for entering coordinates<br>
+ * Class IDs 1400 and 600 (same as calc panel and preferences screen)<br>
  */
 
-
 public class CoordsScreen extends Form {
 
 	mCheckBox chkDMM, chkDMS, chkDD, chkCustom;
@@ -70,138 +69,171 @@
 	CWPoint coordInp = new CWPoint();
 	CellPanel topLinePanel = new CellPanel();
 	CellPanel mainPanel = new CellPanel();
-	int exitKeys[]={75009};
+	int exitKeys[] = { 75009 };
 	int currFormat;
 
 	boolean bNSDeg = false;
 	boolean bNSm = false;
-	boolean	bNSs = false;
+	boolean bNSs = false;
 	boolean bEWDeg = false;
 	boolean bEWm = false;
 	boolean bEWs = false;
 	boolean bUTMNorthing = false;
 	boolean bUTMEasting = false;
-	
 
 	private boolean allowInvalid = false;
 
-	public CoordsScreen(boolean allowInvalidCoords)
-	{
+	public CoordsScreen(boolean allowInvalidCoords) {
 		allowInvalid = allowInvalidCoords;
 
-		InitCoordsScreen();		
+		InitCoordsScreen();
 	}
 
-	public CoordsScreen()
-	{
-		InitCoordsScreen();		
+	public CoordsScreen() {
+		InitCoordsScreen();
 	}
 
-	private void InitCoordsScreen()
-	{
+	private void InitCoordsScreen() {
 		this.setTitle("");
-		//Radiobuttons for format
-		topLinePanel.addNext(chkDD =new mCheckBox("d.d?"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMM =new mCheckBox("d?m.m\'"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMS =new mCheckBox("d?m\'s\""),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		//topLinePanel.addNext(chkUTM =new mCheckBox("UTM"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkCustom =new mCheckBox(""),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		// Radiobuttons for format
+		topLinePanel.addNext(chkDD = new mCheckBox("d.d?"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMM = new mCheckBox("d?m.m\'"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMS = new mCheckBox("d?m\'s\""), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		// topLinePanel.addNext(chkUTM =new mCheckBox("UTM"),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkCustom = new mCheckBox(""), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		String[] ls = TransformCoordinates.getProjectedSystemNames();
-		topLinePanel.addLast(localCooSystem = new mChoice(ls, 0),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addLast(localCooSystem = new mChoice(ls, 0), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		chkDD.setGroup(chkFormat); chkDD.exitKeys=exitKeys;
-		chkDMM.setGroup(chkFormat);chkDMM.exitKeys=exitKeys;
-		chkDMS.setGroup(chkFormat);chkDMS.exitKeys=exitKeys;
-		chkCustom.setGroup(chkFormat);chkCustom.exitKeys=exitKeys;
-		this.addLast(topLinePanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		chkDD.setGroup(chkFormat);
+		chkDD.exitKeys = exitKeys;
+		chkDMM.setGroup(chkFormat);
+		chkDMM.exitKeys = exitKeys;
+		chkDMS.setGroup(chkFormat);
+		chkDMS.exitKeys = exitKeys;
+		chkCustom.setGroup(chkFormat);
+		chkCustom.exitKeys = exitKeys;
+		this.addLast(topLinePanel, CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		// Input for degrees
-		mainPanel.addNext(chcNS = new mChoice(new String[]{"N", "S"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(chcNS = new mChoice(new String[] { "N", "S" }, 0), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		chcNS.setInt(0);
-		mainPanel.addNext(inpNSDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpNSm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpNSs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpNSDeg = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpNSm = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(inpNSs = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
-		mainPanel.addNext(chcEW = new mChoice(new String[]{"E", "W"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(chcEW = new mChoice(new String[] { "E", "W" }, 0), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		chcEW.setInt(0);
-		mainPanel.addNext(inpEWDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpEWm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpEWs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpEWDeg = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpEWm = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(inpEWs = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
 		// Input for UTM
-		if (allowInvalid){
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,"Zone")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,"Easting")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401,"Northing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(btnClear = new mButton(MyLocale.getMsg(1413,"Clear")),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		if (allowInvalid) {
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400, "Zone")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402, "Easting")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401, "Northing")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addLast(btnClear = new mButton(MyLocale.getMsg(1413, "Clear")), CellConstants.HSTRETCH, (CellConstants.HFILL));
 		} else {
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,"Zone")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,"Easting")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401,"Northing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(btnSearch = new mButton(MyLocale.getMsg(1414,"Search")),CellConstants.HSTRETCH, (CellConstants.HFILL));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400, "Zone")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402, "Easting")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401, "Northing")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addLast(btnSearch = new mButton(MyLocale.getMsg(1414, "Search")), CellConstants.HSTRETCH, (CellConstants.HFILL));
 		}
 
-		mainPanel.addNext(inpUTMZone = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMEasting = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMNorthing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(btnGps = new mButton("GPS"),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		mainPanel.addNext(inpUTMZone = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpUTMEasting = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpUTMNorthing = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(btnGps = new mButton("GPS"), CellConstants.HSTRETCH, (CellConstants.HFILL));
 
-		//	mainPanel.addLast(new mLabel(MyLocale.getMsg(1405,"To load coordinates from GC, enter GCxxxxx below")),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
+		// mainPanel.addLast(new mLabel(MyLocale.getMsg(1405,"To load coordinates from GC, enter GCxxxxx below")),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
 		// Input for free Text
-		mainPanel.addNext(inpText = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		inpText.toolTip=MyLocale.getMsg(1406,"Enter coordinates in any format or GCxxxxx");
-		inpText.setTag(SPAN,new Dimension(3,1));
-		mainPanel.addLast(btnParse = new mButton(MyLocale.getMsg(619,"Parse")),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		mainPanel.addNext(inpText = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		inpText.toolTip = MyLocale.getMsg(1406, "Enter coordinates in any format or GCxxxxx");
+		inpText.setTag(SPAN, new Dimension(3, 1));
+		mainPanel.addLast(btnParse = new mButton(MyLocale.getMsg(619, "Parse")), CellConstants.HSTRETCH, (CellConstants.HFILL));
 
 		// Buttons for cancel and apply, copy and paste
-		btnCancel = new mButton(MyLocale.getMsg(614,"Cancel"));
+		btnCancel = new mButton(MyLocale.getMsg(614, "Cancel"));
 		btnCancel.setHotKey(0, IKeys.ESCAPE);
-		mainPanel.addNext(btnCancel,CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCancel.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnApply = new mButton(MyLocale.getMsg(615,"Apply")),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnApply.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnPaste = new mButton(MyLocale.getMsg(617,"Paste")),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnParse.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addLast(btnCopy = new mButton(MyLocale.getMsg(618,"Copy")),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCopy.setTag(SPAN,new Dimension(4,1));
-		chcNS.exitKeys=exitKeys; chcEW.exitKeys=exitKeys;
-		//add Panels
-		this.addLast(mainPanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		mainPanel.addNext(btnCancel, CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnCancel.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnApply = new mButton(MyLocale.getMsg(615, "Apply")), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnApply.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnPaste = new mButton(MyLocale.getMsg(617, "Paste")), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnParse.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addLast(btnCopy = new mButton(MyLocale.getMsg(618, "Copy")), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnCopy.setTag(SPAN,new Dimension(4,1));
+		chcNS.exitKeys = exitKeys;
+		chcEW.exitKeys = exitKeys;
+		// add Panels
+		this.addLast(mainPanel, CellConstants.DONTSTRETCH, CellConstants.WEST);
 		chcNS.takeFocus(ControlConstants.ByKeyboard);
-		
-		
+
 	}
 
-	public void activateFields(int format){
-		//inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
+	public void activateFields(int format) {
+		// inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
 
-		switch (format){
+		switch (format) {
 		case TransformCoordinates.DD:
-			enable(chcNS); enable(inpNSDeg); disable(inpNSm); disable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); disable(inpEWm); disable(inpEWs);
-			//inpEWDeg.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+			enable(chcNS);
+			enable(inpNSDeg);
+			disable(inpNSm);
+			disable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			disable(inpEWm);
+			disable(inpEWs);
+			// inpEWDeg.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		case TransformCoordinates.DMM: 	
-			enable(chcNS); enable(inpNSDeg); enable(inpNSm); disable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); enable(inpEWm); disable(inpEWs);
-			//inpEWm.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+		case TransformCoordinates.DMM:
+			enable(chcNS);
+			enable(inpNSDeg);
+			enable(inpNSm);
+			disable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			enable(inpEWm);
+			disable(inpEWs);
+			// inpEWm.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		case TransformCoordinates.DMS: 	
-			enable(chcNS); enable(inpNSDeg); enable(inpNSm); enable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); enable(inpEWm); enable(inpEWs);
-			//inpEWs.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+		case TransformCoordinates.DMS:
+			enable(chcNS);
+			enable(inpNSDeg);
+			enable(inpNSm);
+			enable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			enable(inpEWm);
+			enable(inpEWs);
+			// inpEWs.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		default: 	
-			disable(chcNS); disable(inpNSDeg); disable(inpNSm); disable(inpNSs);
-			disable(chcEW); disable(inpEWDeg); disable(inpEWm); disable(inpEWs);
-			if (TransformCoordinates.localSystems[localCooSystem.getInt()].zoneSeperatly) enable(inpUTMZone);
-			else disable(inpUTMZone); 
-			enable(inpUTMNorthing); enable(inpUTMEasting);
-			//inpUTMNorthing.wantReturn=true;
+		default:
+			disable(chcNS);
+			disable(inpNSDeg);
+			disable(inpNSm);
+			disable(inpNSs);
+			disable(chcEW);
+			disable(inpEWDeg);
+			disable(inpEWm);
+			disable(inpEWs);
+			if (TransformCoordinates.localSystems[localCooSystem.getInt()].zoneSeperatly)
+				enable(inpUTMZone);
+			else
+				disable(inpUTMZone);
+			enable(inpUTMNorthing);
+			enable(inpUTMEasting);
+			// inpUTMNorthing.wantReturn=true;
 			break;
 		}
 
@@ -210,54 +242,57 @@
 		this.repaintNow();
 	}
 
-	private void enable(Control c) {c.modify(ControlConstants.TakesKeyFocus,ControlConstants.Disabled); }
-	private void disable(Control c) {c.modify(ControlConstants.Disabled,ControlConstants.TakesKeyFocus); }
+	private void enable(Control c) {
+		c.modify(ControlConstants.TakesKeyFocus, ControlConstants.Disabled);
+	}
 
-	public void readFields(CWPoint coords){
+	private void disable(Control c) {
+		c.modify(ControlConstants.Disabled, ControlConstants.TakesKeyFocus);
+	}
+
+	public void readFields(CWPoint coords) {
 		String NS, EW;
 		if (localSystemToformatSel(currFormat) >= formatSelToLocalSystem.length) {
 			if (TransformCoordinates.getLocalSystem(currFormat).zoneSeperatly)
-				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), inpUTMZone.getText(), currFormat); 
+				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), inpUTMZone.getText(), currFormat);
 			else
-				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), currFormat);			
+				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), currFormat);
+		} else {
+			NS = chcNS.getInt() == 0 ? "N" : "S";
+			EW = chcEW.getInt() == 0 ? "E" : "W";
+			coords.set(NS, inpNSDeg.getText(), inpNSm.getText(), inpNSs.getText(), EW, inpEWDeg.getText(), inpEWm.getText(), inpEWs.getText(), currFormat);
 		}
-		else {
-			NS = chcNS.getInt()== 0?"N":"S";
-			EW = chcEW.getInt()== 0?"E":"W";
-			coords.set(NS, inpNSDeg.getText(), inpNSm.getText(), inpNSs.getText(),
-					EW, inpEWDeg.getText(), inpEWm.getText(), inpEWs.getText(),
-					currFormat);
-		}
 		int formatsel = combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt());
 		currFormat = getLocalSystem(formatsel);
 		return;
 	}
+
 	public void setFields(CWPoint coords, int format) {
-		int formatsel = localSystemToformatSel(format); 
-		if ( formatsel >= formatSelToLocalSystem.length){ // projected point = neither dd, dd? mm.mm nor dd? mm' ss.s"
-			if (coords.isValid()){
+		int formatsel = localSystemToformatSel(format);
+		if (formatsel >= formatSelToLocalSystem.length) { // projected point = neither dd, dd? mm.mm nor dd? mm' ss.s"
+			if (coords.isValid()) {
 				localCooSystem.setInt(formatsel - formatSelToLocalSystem.length);
 				ProjectedPoint pp = TransformCoordinates.wgs84ToLocalsystem(coords, format);
 				inpText.setText(pp.toHumanReadableString());
-				inpUTMNorthing.setText(Common.DoubleToString(pp.getNorthing(),0,0));
-				inpUTMEasting.setText(Common.DoubleToString(pp.getEasting(),0,0));
-				if (TransformCoordinates.getLocalSystem(format).zoneSeperatly) inpUTMZone.setText(pp.getZoneString()); 
-				else inpUTMZone.setText("");
-			}
-			else {
+				inpUTMNorthing.setText(Common.DoubleToString(pp.getNorthing(), 0, 0));
+				inpUTMEasting.setText(Common.DoubleToString(pp.getEasting(), 0, 0));
+				if (TransformCoordinates.getLocalSystem(format).zoneSeperatly)
+					inpUTMZone.setText(pp.getZoneString());
+				else
+					inpUTMZone.setText("");
+			} else {
 				inpUTMNorthing.setText("0");
 				inpUTMEasting.setText("0");
 			}
-		}
-		else {
-			chcNS.setInt(coords.getNSLetter().equals("N")?0:1);
-			chcEW.setInt(coords.getEWLetter().equals("E")?0:1);
+		} else {
+			chcNS.setInt(coords.getNSLetter().equals("N") ? 0 : 1);
+			chcEW.setInt(coords.getEWLetter().equals("E") ? 0 : 1);
 
-			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format),"-",""));
+			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format), "-", ""));
 			inpNSm.setText(coords.getLatMin(format));
 			inpNSs.setText(coords.getLatSec(format));
 
-			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format),"-",""));
+			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format), "-", ""));
 			inpEWm.setText(coords.getLonMin(format));
 			inpEWs.setText(coords.getLonSec(format));
 		}
@@ -267,140 +302,139 @@
 		activateFields(format);
 	}
 
-	public CWPoint getCoords(){
+	public CWPoint getCoords() {
 		return coordInp;
 	}
 
+	public void onEvent(Event ev) {
 
-	
-	public void onEvent(Event ev){
-
 		// Ensure that the Enter key moves to the appropriate field
 		// for Checkboxes and Choice controls this is done via the exitKeys
 		// For input fields we use the wantReturn field
 
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.EXITED){
-			if (((ControlEvent)ev).target==chkDD || ((ControlEvent)ev).target==chkDMM ||
-					((ControlEvent)ev).target==chkDMS) Gui.takeFocus(chcNS,ControlConstants.ByKeyboard);	
-			if (((ControlEvent)ev).target==chkCustom) Gui.takeFocus(inpUTMEasting,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcNS) Gui.takeFocus(inpNSDeg,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcEW) Gui.takeFocus(inpEWDeg,ControlConstants.ByKeyboard);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.EXITED) {
+			if (((ControlEvent) ev).target == chkDD || ((ControlEvent) ev).target == chkDMM || ((ControlEvent) ev).target == chkDMS)
+				Gui.takeFocus(chcNS, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chkCustom)
+				Gui.takeFocus(inpUTMEasting, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chcNS)
+				Gui.takeFocus(inpNSDeg, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chcEW)
+				Gui.takeFocus(inpEWDeg, ControlConstants.ByKeyboard);
 		}
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (((ControlEvent)ev).target==inpEWDeg || ((ControlEvent)ev).target==inpEWm ||
-					((ControlEvent)ev).target==inpEWs || ((ControlEvent)ev).target==inpUTMNorthing) Gui.takeFocus(btnApply,ControlConstants.ByKeyboard);	
-			
-			
-			if (ev.target == chkFormat || ev.target == localCooSystem){
-				if (ev.target == localCooSystem) chkFormat.selectIndex(3);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (((ControlEvent) ev).target == inpEWDeg || ((ControlEvent) ev).target == inpEWm || ((ControlEvent) ev).target == inpEWs || ((ControlEvent) ev).target == inpUTMNorthing)
+				Gui.takeFocus(btnApply, ControlConstants.ByKeyboard);
+
+			if (ev.target == chkFormat || ev.target == localCooSystem) {
+				if (ev.target == localCooSystem)
+					chkFormat.selectIndex(3);
 				readFields(coordInp);
 				setFields(coordInp, currFormat);
 				this.repaintNow();
 			}
 
-			if (ev.target == btnCancel){
+			if (ev.target == btnCancel) {
 				this.close(IDCANCEL);
 			}
 
-			if (ev.target == btnApply){
+			if (ev.target == btnApply) {
 				currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
 				readFields(coordInp);
-				if (coordInp.isValid()) this.close(IDOK);
+				if (coordInp.isValid())
+					this.close(IDOK);
 				else {
-					if	( allowInvalid ) {
-						if ((new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1412,"Coordinates invalid. Apply anyway?"),FormBase.DEFOKB|FormBase.NOB)).execute() == FormBase.IDOK ) {
-							this.close(IDOK);						
+					if (allowInvalid) {
+						if ((new MessageBox(MyLocale.getMsg(144, "Warnung"), MyLocale.getMsg(1412, "Coordinates invalid. Apply anyway?"), FormBase.DEFOKB | FormBase.NOB)).execute() == FormBase.IDOK) {
+							this.close(IDOK);
 						}
 					} else {
-						(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(1411,"Please enter valid coordinates"), FormBase.OKB)).execute();						
+						(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1411, "Please enter valid coordinates"), FormBase.OKB)).execute();
 					}
 				}
 			}
 
-			if (ev.target == btnPaste){
+			if (ev.target == btnPaste) {
 				inpText.setText(Vm.getClipboardText(""));
 			}
 
-			if (ev.target == btnCopy){
+			if (ev.target == btnCopy) {
 				readFields(coordInp); // TODO was anderes als Gau?-Kr?ger unterst?tzen
 				Vm.setClipboardText(coordInp.toString(currFormat));
 			}
 
-			if (ev.target == btnParse){
+			if (ev.target == btnParse) {
 				// try to parse coords
 				CWPoint coord;
-				String inp=inpText.getText().trim().toUpperCase();
+				String inp = inpText.getText().trim().toUpperCase();
 				if (inp.startsWith("GC")) {
-					SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile(), false);
+					SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
 					coord = new CWPoint(spider.getCacheCoordinates(inp));
-				} else {	
+					Global.getPref().setOldGCLanguage();
+				} else {
 					coord = new CWPoint(inp);
 				}
-				if (!coord.isValid()){
-					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
+				if (!coord.isValid()) {
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
 					tmpMB.exec();
-				}else {
-					currFormat =  getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(coord,currFormat);
+				} else {
+					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
+					setFields(coord, currFormat);
 					this.repaintNow();
 				}
 			}
 
-			if (ev.target == btnGps){
-				Navigate nav=Global.mainTab.nav;
-				if (nav.gpsPos.isValid()){
+			if (ev.target == btnGps) {
+				Navigate nav = Global.mainTab.nav;
+				if (nav.gpsPos.isValid()) {
 					CWPoint coord = nav.gpsPos;
 					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(coord,currFormat);
+					setFields(coord, currFormat);
 				}
 			}
 
-			if (ev.target == btnClear){
-				CWPoint coord = new CWPoint(91,361);
+			if (ev.target == btnClear) {
+				CWPoint coord = new CWPoint(91, 361);
 				currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-				setFields(coord,currFormat);
+				setFields(coord, currFormat);
 			}
-			
+
 			if (ev.target == btnSearch) {
-				GeoCodeGui s = new GeoCodeGui(); 
+				GeoCodeGui s = new GeoCodeGui();
 				int ok = s.execute();
 				if (ok == FormBase.IDOK) {
 					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(s.coordInp,currFormat);
+					setFields(s.coordInp, currFormat);
 				}
 			}
 		}
 		super.onEvent(ev);
 	}
-	
 
-	private static final int[] formatSelToLocalSystem = {
-		TransformCoordinates.DD,
-		TransformCoordinates.DMM,
-		TransformCoordinates.DMS,
-	};
+	private static final int[] formatSelToLocalSystem = { TransformCoordinates.DD, TransformCoordinates.DMM, TransformCoordinates.DMS, };
 
 	public int localSystemToformatSel(int cwpointformat) {
-		for (int i=0; i < formatSelToLocalSystem.length; i++) 
-			if (formatSelToLocalSystem[i] == cwpointformat) return i;
-		for (int i=0; i < TransformCoordinates.localSystems.length; i++) 
-			if (TransformCoordinates.localSystems[i].code == cwpointformat) return i + formatSelToLocalSystem.length;
-		
+		for (int i = 0; i < formatSelToLocalSystem.length; i++)
+			if (formatSelToLocalSystem[i] == cwpointformat)
+				return i;
+		for (int i = 0; i < TransformCoordinates.localSystems.length; i++)
+			if (TransformCoordinates.localSystems[i].code == cwpointformat)
+				return i + formatSelToLocalSystem.length;
+
 		throw new IllegalArgumentException("CoordScreen.CWPointformatToformatSel: cwpointformat " + cwpointformat + "not supported");
 	}
 
 	public static final int getLocalSystem(int formatsel) { // be carefull: this method is also used by CalcPanel
-		if (formatsel < formatSelToLocalSystem.length) return formatSelToLocalSystem[formatsel];
+		if (formatsel < formatSelToLocalSystem.length)
+			return formatSelToLocalSystem[formatsel];
 		return TransformCoordinates.localSystems[formatsel - formatSelToLocalSystem.length].code;
 	}
-	
+
 	public static final int combineToFormatSel(int radiobuttonindex, int choiceindex) {
 		int ret = radiobuttonindex;
-		if (ret == formatSelToLocalSystem.length) ret += choiceindex;
+		if (ret == formatSelToLocalSystem.length)
+			ret += choiceindex;
 		return ret;
 	}
 
 }
-
-
-

Modified: branches/r1.2/src/CacheWolf/DBStats.java
===================================================================
--- branches/r1.2/src/CacheWolf/DBStats.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DBStats.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,115 +1,118 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
  * @author Marc
- * Use this class to obtain statistics or information on a cache database.
+ *         Use this class to obtain statistics or information on a cache database.
  */
 public class DBStats {
 	CacheDB cacheDB = null;
-	
-	public DBStats(CacheDB db){
+
+	public DBStats(CacheDB db) {
 		cacheDB = db;
 	}
-	
+
 	/**
 	 * Method to get the number of caches displayed in the list.
 	 * It will count waypoints only that start with
 	 * GC,or
 	 * OC
+	 * 
 	 * @return
 	 */
-	public String visible(boolean big){
+	public String visible(boolean big) {
 		CacheHolder holder;
 		int counter = 0;
 		int whiteCaches = 0;
 		int whiteWaypoints = 0;
-		for(int i = 0; i<cacheDB.size();i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			holder = cacheDB.get(i);
-			if(holder.isVisible()){
+			if (holder.isVisible()) {
 				counter++;
 				if (CacheType.isAddiWpt(holder.getType())) {
 					whiteWaypoints++;
+				} else {
+					whiteCaches++;
 				}
-				else {				
-					whiteCaches++;
-				}		
 			}
 		}
 		if (big)
-			return counter+"("+whiteCaches+"/"+whiteWaypoints+")";
+			return counter + "(" + whiteCaches + "/" + whiteWaypoints + ")";
 		else
-			return ""+whiteCaches;
-		
+			return "" + whiteCaches;
+
 	}
-	
+
 	/**
 	 * Method to get the number of caches available for display
+	 * 
 	 * @return
 	 */
-	public String total(boolean big){
+	public String total(boolean big) {
 		CacheHolder holder;
 		int all = cacheDB.size();
 		int whiteCaches = 0;
 		int whiteWaypoints = 0;
 		int blackCaches = 0;
 		int blackWaypoints = 0;
-		for(int i = 0; i<all;i++){
+		for (int i = 0; i < all; i++) {
 			holder = cacheDB.get(i);
-			if(holder.is_black()){
-			  if (CacheType.isAddiWpt(holder.getType())) {
-				  blackWaypoints++;  
-			  }
-			  else {
-				  blackCaches++;
-			  }
-			}
-			else {
+			if (holder.is_black()) {
 				if (CacheType.isAddiWpt(holder.getType())) {
+					blackWaypoints++;
+				} else {
+					blackCaches++;
+				}
+			} else {
+				if (CacheType.isAddiWpt(holder.getType())) {
 					whiteWaypoints++;
+				} else {
+					whiteCaches++;
 				}
-				else {				
-					whiteCaches++;
-				}		
 			}
 		}
-		if (big)
-			return all+"("+whiteCaches+"/"+whiteWaypoints+"+"+blackCaches+"/"+blackWaypoints+")";
-		else
-			return ""+whiteCaches;
+		if (big) {
+			if (blackCaches > 0 || blackWaypoints > 0) {
+				return all + "(" + whiteCaches + "/" + whiteWaypoints + "+" + blackCaches + "/" + blackWaypoints + ")";
+			} else {
+				return all + "(" + whiteCaches + "/" + whiteWaypoints + ")";
+			}
+		} else
+			return "" + whiteCaches;
 	}
-	
-	public int totalFound(){
+
+	public int totalFound() {
 		CacheHolder holder;
 		int counter = 0;
-		for(int i = 0; i<cacheDB.size();i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			holder = cacheDB.get(i);
-			if(holder.is_found() == true) {
-				if(holder.getWayPoint().startsWith("GC") || holder.isOC()) counter++;
+			if (holder.is_found() == true) {
+				if (holder.isCacheWpt())
+					counter++;
 			}
 		}
 		return counter;

Modified: branches/r1.2/src/CacheWolf/DataMover.java
===================================================================
--- branches/r1.2/src/CacheWolf/DataMover.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DataMover.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -281,10 +281,11 @@
 		if (wpt.length() == 0){
 			return;
 		}
+
 		// delete files in dstDir to clean up trash
-		// String tmp[] = new FileBugfix(dir).list(wpt + "*.*", ewe.io.FileBase.LIST_FILES_ONLY);
+		wpt=wpt.toLowerCase();
 		for (int i=0; i < tmp.length;i++){
-			if (tmp[i].substring(0, java.lang.Math.min(tmp[i].length(),wpt.length())).equalsIgnoreCase(wpt)) {
+			if (tmp[i].toLowerCase().startsWith(wpt+'.') || tmp[i].toLowerCase().startsWith(wpt+'_')){
 				File tmpFile = new File(dir + tmp[i]);
 				tmpFile.delete();
 			}
@@ -295,9 +296,9 @@
 		if (wpt.length() == 0){
 			return;
 		}
-		// String srcFiles[] = new FileBugfix(srcDir).list(wpt + "*.*", ewe.io.FileBase.LIST_FILES_ONLY);
+		wpt=wpt.toLowerCase();
 		for (int i=0; i < srcFiles.length;i++){
-			if (srcFiles[i].substring(0, java.lang.Math.min(srcFiles[i].length(),wpt.length())).equalsIgnoreCase(wpt)) {
+			if (srcFiles[i].toLowerCase().startsWith(wpt+'.') || srcFiles[i].toLowerCase().startsWith(wpt+'_')){
 				File srcFile = new File(srcDir + srcFiles[i]);
 				File dstFile = new File(dstDir + srcFiles[i]);
 				srcFile.move(dstFile);
@@ -309,9 +310,9 @@
 		if (wpt.length() == 0){
 			return;
 		}
-		// String srcFiles[] = new FileBugfix(srcDir).list(wpt + "*.*", ewe.io.FileBase.LIST_FILES_ONLY);
+		wpt=wpt.toLowerCase();
 		for (int i=0; i < srcFiles.length;i++){
-			if (srcFiles[i].substring(0, java.lang.Math.min(srcFiles[i].length(),wpt.length())).equalsIgnoreCase(wpt)) {
+			if (srcFiles[i].toLowerCase().startsWith(wpt+'.') || srcFiles[i].toLowerCase().startsWith(wpt+'_')){
 				copy(srcDir + srcFiles[i],dstDir + srcFiles[i]);
 			}
 		}
@@ -439,6 +440,7 @@
 			 destFileList= destPath.list(null,FileBase.LIST_FILES_ONLY|FileBase.LIST_DONT_SORT);
 			 pbf.exit(0);
 		 }
+		 
 		 public void doIt(int i,CacheHolder srcHolder) {
 			 srcDB.removeElementAt(i);
 			 deleteCacheFiles(srcHolder.getWayPoint(),dstProfile.dataDir, destFileList);

Modified: branches/r1.2/src/CacheWolf/DateFormat.java
===================================================================
--- branches/r1.2/src/CacheWolf/DateFormat.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DateFormat.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /* Several date formats are used by GC.COM
@@ -33,75 +33,136 @@
  *    2004-02-27    - YYYY-MM-DD   
  */
 
-import ewe.sys.Convert;
 import ewe.sys.Time;
+import ewe.util.mString;
 
 public class DateFormat {
 
+	public static String GCDateFormat = "";
+
 	/** Convert the US Format into a sortable format */
-	public static String MDY2YMD(String date) {
-		// Dates are in format M/D/Y
-		int p1, p2 = -1, p3;
-		p1 = date.indexOf("/");
-		if (p1==-1){
-			//dayofweek, dayofmonth month year (Monday, 07 June 2010)
-			p1 = date.indexOf(",");			
-			p2 = date.indexOf(" ", p1 + 2);
-			p3 = date.indexOf(" ", p2 + 1);
-			final String monthNames[] = { "January", "February", "March", "April", "May",
-					"June", "July", "August", "September", "October", "November",
-					"December" };
-			for (int m = 0; m < 12; m++) {
-				if (monthNames[m].equals(date.substring(p2+1,p3))) {
-					String mm = Integer.toString(m+1);
-					if (mm.length()==1) {mm=0+mm;}
-					return date.substring(p3+1,p3+5) + "-" + mm + "-" + date.substring(p1+2, p1+4);
+	public static String toYYMMDD(String date) {
+		return toYYMMDD(toDate(date));
+	}
+
+	public static Time toDate(String ds) {
+		if (ds == null || ds.equals("") || ds.indexOf("1900") > -1)
+			return new Time(1, 1, 1900);
+		final long adaylong = new Time(2, 1, 2000).getTime() - new Time(1, 1, 2000).getTime();
+		Time d = new Time();
+		d.hour = 0;
+		d.minute = 0;
+		d.second = 0;
+		d.millis = 0;
+		if (ds.indexOf("day") > 0) {
+			if (ds.indexOf("Yesterday") > -1) {
+				d.setTime(d.getTime() - adaylong);
+			} else {
+				d.setTime(d.getTime() - adaylong * Common.parseInt(ds.substring(0, 1)));
+			}
+		} else {
+			String[] SDate;
+			ds = STRreplace.replace(ds, ",", " ");
+			ds = STRreplace.replace(ds, "  ", " ");
+			SDate = mString.split(ds, ' ');
+			if (SDate.length == 1) {
+				if (ds.indexOf('/') > -1)
+					SDate = mString.split(ds, '/');
+				else if (ds.indexOf('-') > -1)
+					SDate = mString.split(ds, '-');
+				// trying to determine Dateformat
+				int v0 = Common.parseInt(SDate[0]);
+				int v1 = Common.parseInt(SDate[1]);
+				int v2 = Common.parseInt(SDate[2]);
+				int dd, mm, yy;
+				if (v0 > 31) {
+					// yyyy mm dd
+					yy = v0;
+					mm = v1;
+					dd = v2;
+				} else {
+					yy = v2;
+					if ((v0 == 0) || (v1 == 0)) {
+						// month as text
+						String month;
+						if (v0 == 0) {
+							month = SDate[0];
+							dd = v1;
+						} else {
+							month = SDate[1];
+							dd = v0;
+						}
+						mm = monthName2int(month);
+					} else {
+						// mm dd yyyy (doesn't work for dd mm yyyy)
+						if (GCDateFormat.equals("dd/MM/yyyy")) {
+							dd = v0;
+							mm = v1;
+						} else {
+							mm = v0;
+							dd = v1;
+						}
+					}
+
 				}
+				d.month = mm;
+				d.day = dd;
+				d.year = yy;
+			} else {
+				// starting with dayOfWeek or missing year
+				int offs = SDate.length - 3;
+				if (offs < 0)
+					offs = 0;
+				int v0 = Common.parseInt(SDate[offs]);
+				if (v0 == 0) {
+					d.day = Common.parseInt(SDate[offs + 1]);
+					d.month = monthName2int(SDate[offs]);
+				} else {
+					d.day = Common.parseInt(SDate[offs]);
+					d.month = monthName2int(SDate[offs + 1]);
+				}
+				if (SDate.length > 2) {
+					int yy = Common.parseInt(SDate[offs + 2]);
+					if (yy < 100)
+						d.year = 2000 + yy;
+					else
+						d.year = yy;
+				} else
+					// missing year
+					; // d.year = this year
 			}
-			return date;
 		}
-		else {
-			if (p1 > 0)
-				p2 = date.indexOf("/", p1 + 1);
-			if (p1 > 0 && p2 > 0) {
-				return date.substring(p2 + 1) + "-" + (p1 == 1 ? "0" : "")
-						+ date.substring(0, p1) + "-" + (p1 + 2 == p2 ? "0" : "")
-						+ date.substring(p1 + 1, p2);
-			} else
-				return date;
-		}
+		return d;
 	}
 
-	/* Convert the sortable date into a US date */
-	// static String YMD2MDY(String date) {
-	// return
-	// date.substring(4,6)+"/"+date.substring(6,8)+"/"+date.substring(0,4);
-	// }
-	/** Convert the log format into a sortable format */
-	public static String logdate2YMD(String logdate) {
-		String monthNames[] = { "January", "February", "March", "April", "May",
-				"June", "July", "August", "September", "October", "November",
-				"December" };
-		Time t = new Time();
-		String year, month, day;
-		int i, m;
-		logdate += ", " + t.year; // If logdate already has a year, this one is
-									// ignored
-		i = logdate.indexOf(',');
-		year = logdate.substring(i + 2, i + 6);
-		for (m = 0; m < 12; m++) {
-			if (logdate.startsWith(monthNames[m])) {
-				month = (m < 9 ? "0" : "") + Convert.formatInt(m + 1);
-				day = logdate.substring(monthNames[m].length() + 1, i);
-				if (day.length() == 1)
-					day = "0" + day;
-				return year + "-" + month + "-" + day;
+	private static int monthName2int(String month) {
+		final String enMonthNames[] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
+		for (int m = 0; m < 12; m++) {
+			if (enMonthNames[m].startsWith(month)) {
+				return m + 1;
 			}
 		}
-		return "";
+		final String deMonthNames[] = { "Januar", "Februar", "M?rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember" };
+		for (int m = 0; m < 12; m++) {
+			if (deMonthNames[m].startsWith(month)) {
+				return m + 1;
+			}
+		}
+		return 1; // Januar if not detected / in other language
 	}
+
+	public static String toYYMMDD(Time d) {
+		return toYYMMDD(d, '-');
+	}
+
+	public static String toYYMMDD(Time d, char separator) {
+		// the CW Time Format is with separator
+		String f = "yyyy" + separator + "MM" + separator + "dd";
+		return d.format(f);
+	}
+
 	// from lastSyncDate (yyyyMMddHHmmss) to gpxLogdate (yyyy-MM-dd)
-	// if no lastSyncDate returns current Date 
+	// if no lastSyncDate returns current Date
 	public static String yyyyMMddHHmmss2gpxLogdate(String yyyyMMddHHmmss) {
 		Time d = new Time();
 		try {
@@ -109,7 +170,7 @@
 		} catch (IllegalArgumentException e) {
 			d = new Time();
 			d.parse(yyyyMMddHHmmss, "yyyyMMddHHmmss");
-		}		
+		}
 		return d.format("yyyy-MM-dd"); // +d.format("HH:mm:ss"); is set to 00:00:00 at gpxExport
 	}
 

Modified: branches/r1.2/src/CacheWolf/DateTimeChooser.java
===================================================================
--- branches/r1.2/src/CacheWolf/DateTimeChooser.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DateTimeChooser.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -62,6 +62,7 @@
 	public int hour;
 	public int minute;
 	public String time;
+	Time dateSet;
 	
 	public boolean autoAdvance = true;
 	public boolean didAll = false;
@@ -75,7 +76,7 @@
 	Control timeDisplay;
 	//Control minuteDisplay;
 
-	Time getTime() {
+	Time getDate() {
 		Time t = (Time)dateSet.getCopy();
 		t.day = day;
 		t.month = month;
@@ -84,7 +85,6 @@
 		t.minute = minute;
 		t.update();
 		return t;
-		//return new Time(day,month,year);
 	}
 	
 	void addTable(TableControl tc,TableModel tm,String pName) {
@@ -246,7 +246,6 @@
 		else super.onControlEvent(ev);
 	}
 	
-	Time dateSet;
 	
 	public void setDate(Time t) {
 		dateSet = t;
@@ -275,6 +274,30 @@
 		//dayChooser.repaintNow();
 		//monthChooser.repaintNow();
 	}
+
+	public int getDay() {		
+		return day;
+	}
+
+	public int getMonth() {
+		return month;
+	}
+
+	public int getYear() {
+		return year;
+	}
+
+	public String getTime() {
+		return time;
+	}
+
+	public int getHour() {
+		return hour;
+	}
+
+	public int getMinute() {
+		return minHeight;
+	}
 } // DateTimeChooser
 
 

Modified: branches/r1.2/src/CacheWolf/DetailsPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/DetailsPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DetailsPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.TransformCoordinates;
@@ -64,7 +64,7 @@
  */
 public class DetailsPanel extends CellPanel {
 
-    // ===== GUI elements =====
+	// ===== GUI elements =====
 	/** way point id. */
 	private static mInput inpWaypoint;
 	/** way point name. */
@@ -135,24 +135,20 @@
 	private boolean blackStatusChanged;
 	/** FIXME */
 	private boolean needsTableUpdate;
-	/** screen is VGA or better */
-	private final boolean isBigScreen;
-	/** use big icons */
-	private final boolean useBigIcons;
-	/** String to display for invalid or not applicable terrain or difficulty values.*/
+	/** String to display for invalid or not applicable terrain or difficulty values. */
 	private final static String DTINVALID = ": -.-";
-	public boolean evWaypointChanged=false;
-	private String warnedForWaypoint="";
+	public boolean evWaypointChanged = false;
+	private String warnedForWaypoint = "";
 
-    // TODO: move images to image broker
-    //mImage imgBlack, imgBlackNo, imgShowBug, imgShowBugNo, imgNewWpt, imgGoto, imgShowMaps, imgAddImages, imgNotes;
+	// TODO: move images to image broker
+	// mImage imgBlack, imgBlackNo, imgShowBug, imgShowBugNo, imgNewWpt, imgGoto, imgShowMaps, imgAddImages, imgNotes;
 
 	/**
 	 * public constructor for detail panels. should only be called from main tab.
 	 */
 	public DetailsPanel() {
 		super();
-        // ===== local objects =====
+		// ===== local objects =====
 		/** helper panels to organize layout */
 		CellPanel helperPanel1, helperPanel2, helperPanel3, helperPanel4, helperPanel5;
 
@@ -166,11 +162,9 @@
 		blackStatus = false;
 		blackStatusChanged = false;
 		needsTableUpdate = false;
-		isBigScreen = pref.isBigScreen;
-		useBigIcons = pref.useBigIcons;
 
 		// ===== initialize GUI objects =====
-        // ----- main body -----
+		// ----- main body -----
 
 		helperPanel1 = new CellPanel();
 		helperPanel2 = new CellPanel();
@@ -183,7 +177,7 @@
 		chcType.alwaysDrop = true;
 		chcSize = new mChoice(CacheSize.guiSizeStrings(), 0);
 		chcSize.alwaysDrop = true;
-		chcStatus = new mComboBox(CacheHolder.GetGuiLogTypes(),0);
+		chcStatus = new mComboBox(CacheHolder.GetGuiLogTypes(), 0);
 		inpWaypoint = new mInput();
 		inpName = new mInput();
 
@@ -196,7 +190,7 @@
 
 		// ===== put the controls onto the GUI =====
 
-        // ----- helper panels -----
+		// ----- helper panels -----
 
 		btnDiff = new mButton(MyLocale.getMsg(1000, "D") + ": 5.5");
 		btnDiff.setPreferredSize(pref.fontSize * 3, chcSize.getPreferredSize(null).height);
@@ -208,10 +202,10 @@
 
 		lblAddiCount = new mLabel(MyLocale.getMsg(1044, "Addis") + ": 888");
 
-		btnFoundDate = new mButton(new mImage(useBigIcons ? "calendar_vga.png" : "calendar.png"));
+		btnFoundDate = new mButton(new mImage(pref.useBigIcons ? "calendar_vga.png" : "calendar.png"));
 		btnFoundDate.setToolTip(MyLocale.getMsg(31415, "Set found date / time"));
 
-		btnHiddenDate = new mButton(new mImage(useBigIcons ? "calendar_vga.png"	: "calendar.png"));
+		btnHiddenDate = new mButton(new mImage(pref.useBigIcons ? "calendar_vga.png" : "calendar.png"));
 		btnHiddenDate.setToolTip(MyLocale.getMsg(31415, "Set hidden date"));
 
 		helperPanel1.addNext(chcType, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
@@ -226,7 +220,7 @@
 		helperPanel4.addNext(chcStatus, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 		helperPanel4.addLast(btnFoundDate, DONTSTRETCH, DONTFILL);
 
-		helperPanel5.addNext(inpHidden, CellConstants.HSTRETCH,	(CellConstants.HFILL | CellConstants.WEST));
+		helperPanel5.addNext(inpHidden, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 		helperPanel5.addLast(btnHiddenDate, DONTSTRETCH, DONTFILL);
 
 		// ----- main body -----
@@ -242,10 +236,10 @@
 		addLast(helperPanel3, DONTSTRETCH, HFILL).setTag(CellConstants.SPAN, new Dimension(2, 1));
 
 		addNext(new mLabel(MyLocale.getMsg(303, "Name:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
-		addLast(inpName.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.DONTSTRETCH,	(CellConstants.HFILL | CellConstants.WEST));
+		addLast(inpName.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
 		addNext(new mLabel(MyLocale.getMsg(304, "Coordinates:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
-		addLast(btnCoordinates.setTag(CellConstants.SPAN, new Dimension(2, 1)),	CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		addLast(btnCoordinates.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
 		addNext(new mLabel(MyLocale.getMsg(307, "Status:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		addLast(helperPanel4, DONTSTRETCH, HFILL).setTag(CellConstants.SPAN, new Dimension(2, 1));
@@ -258,56 +252,56 @@
 
 		addLast(attViewer);
 
-		//TODO: decide whether to still use the object without display on small screens to handle notes
-		if (isBigScreen) {
+		// TODO: decide whether to still use the object without display on small screens to handle notes
+		if (pref.isBigScreen) {
 			addLast(new mLabel(MyLocale.getMsg(308, "Notes:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			waypointNotes = new mTextPad();
 			waypointNotes.modify(ControlConstants.NotEditable, 0);
 			addLast(new MyScrollBarPanel(waypointNotes));
 		}
 
-		//FIXME: get rid of this
-		imgBlack = new mImage(useBigIcons?"is_black_vga.png":"is_black.png");
+		// FIXME: get rid of this
+		imgBlack = new mImage(pref.useBigIcons ? "is_black_vga.png" : "is_black.png");
 		imgBlack.transparentColor = Color.White;
-		imgBlackNo = new mImage(useBigIcons ? "no_black_vga.png" : "no_black.png");
+		imgBlackNo = new mImage(pref.useBigIcons ? "no_black_vga.png" : "no_black.png");
 		imgBlackNo.transparentColor = Color.Black;
-		imgShowBug = new mImage(useBigIcons ? "bug_vga.gif":"bug.gif");
-		imgShowBugNo = new mImage(useBigIcons ? "bug_no_vga.gif":"bug_no.gif");
+		imgShowBug = new mImage(pref.useBigIcons ? "bug_vga.gif" : "bug.gif");
+		imgShowBugNo = new mImage(pref.useBigIcons ? "bug_no_vga.gif" : "bug_no.gif");
 	}
 
 	private CellPanel createToolsPanel() {
 		final CellPanel pnlTools = new CellPanel();
 
-		btnNewWpt = new mButton(imgNewWpt = new mImage(useBigIcons ? "newwpt_vga.png" : "newwpt.png"));
+		btnNewWpt = new mButton(imgNewWpt = new mImage(pref.useBigIcons ? "newwpt_vga.png" : "newwpt.png"));
 		// FIXME: get an image with proper transparency
 		imgNewWpt.transparentColor = new Color(255, 0, 0);
 		btnNewWpt.setToolTip(MyLocale.getMsg(311, "Create Waypoint"));
 
-		btnGoto = new mButton(imgGoto = new mImage(useBigIcons ? "goto_vga.png"	: "goto.png"));
+		btnGoto = new mButton(imgGoto = new mImage(pref.useBigIcons ? "goto_vga.png" : "goto.png"));
 		// FIXME: get an image with proper transparency
 		imgGoto.transparentColor = Color.White;
 		btnGoto.setToolTip(MyLocale.getMsg(345, "Goto these coordinates"));
 
-		btnShowBug = new mButton(new mImage(useBigIcons ? "bug_no_vga.gif" : "bug_no.gif"));
+		btnShowBug = new mButton(new mImage(pref.useBigIcons ? "bug_no_vga.gif" : "bug_no.gif"));
 		btnShowBug.setToolTip(MyLocale.getMsg(346, "Show travelbugs"));
 
-		btnShowMap = new mButton(new mImage(useBigIcons ? "globe_small_vga.gif" : "globe_small.gif"));
+		btnShowMap = new mButton(new mImage(pref.useBigIcons ? "globe_small_vga.gif" : "globe_small.gif"));
 		btnShowMap.setToolTip(MyLocale.getMsg(347, "Show map"));
 
-		btnAddPicture = new mButton(new mImage(useBigIcons ? "images_vga.gif" : "images.gif"));
+		btnAddPicture = new mButton(new mImage(pref.useBigIcons ? "images_vga.gif" : "images.gif"));
 		btnAddPicture.setToolTip(MyLocale.getMsg(348, "Add user pictures"));
 
-		btnBlack = new mButton(imgBlack = new mImage(useBigIcons ? "no_black_vga.png" : "no_black.png"));
+		btnBlack = new mButton(imgBlack = new mImage(pref.useBigIcons ? "no_black_vga.png" : "no_black.png"));
 		// FIXME: get an image with proper transparency
 		imgBlack.transparentColor = Color.Black;
 		btnBlack.setToolTip(MyLocale.getMsg(349, "Toggle Blacklist status"));
 
-		btnNotes = new mButton(imgNotes = new mImage(useBigIcons ? "notes_vga.gif" : "notes.gif"));
+		btnNotes = new mButton(imgNotes = new mImage(pref.useBigIcons ? "notes_vga.gif" : "notes.gif"));
 		// FIXME: get an image with proper transparency
 		imgNotes.transparentColor = Color.DarkBlue;
 		btnNotes.setToolTip(MyLocale.getMsg(351, "Add/Edit notes"));
 
-		btnAddDateTime = new mButton(new mImage(useBigIcons ? "date_time_vga.gif" : "date_time.gif"));
+		btnAddDateTime = new mButton(new mImage(pref.useBigIcons ? "date_time_vga.gif" : "date_time.gif"));
 		btnAddDateTime.setToolTip(MyLocale.getMsg(350, "Add timestamp to notes"));
 
 		pnlTools.addNext(btnNewWpt);
@@ -351,7 +345,7 @@
 		dirtyDetails = false;
 		inpWaypoint.setText(ch.getWayPoint());
 		inpName.setText(ch.getCacheName());
-		btnCoordinates.setText(ch.pos.toString());
+		btnCoordinates.setText(ch.getPos().toString());
 		inpHidden.setText(mainCache.getDateHidden());
 		inpOwner.setText(mainCache.getCacheOwner());
 		chcStatus.setText(ch.getStatusText());
@@ -425,7 +419,7 @@
 		}
 		lblAddiCount.setText(MyLocale.getMsg(1044, "Addis") + ": " + addiCount);
 
-		if (isBigScreen) {
+		if (pref.isBigScreen) {
 			waypointNotes.setText(ch.getCacheDetails(true).getCacheNotes());
 		}
 	}
@@ -436,307 +430,270 @@
 	 */
 	public void createWptName() {
 		final String wpt = inpWaypoint.getText().toUpperCase();
-		if (CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-				&& Global.mainTab.mainCache != null
-				&& (Global.mainTab.mainCache.startsWith("GC")
-					|| OC.isOC(Global.mainTab.mainCache) || Global.mainTab.mainCache.startsWith("CW"))
+		if (CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) && Global.mainTab.mainCache != null && (Global.mainTab.mainCache.startsWith("GC") || OC.isOC(Global.mainTab.mainCache) || Global.mainTab.mainCache.startsWith("CW"))
 				&& wpt.startsWith("CW")) {
 			// for creating the Addiname on creating a new Waypoint
-			Global.mainTab.lastselected = Global.mainTab.mainCache; 
+			Global.mainTab.lastselected = Global.mainTab.mainCache;
 
-			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(
-					Global.mainTab.mainCache));
+			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(Global.mainTab.mainCache));
 		}
-		if (!CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-				&& !(wpt.startsWith("GC")
-					|| OC.isOC(wpt) || wpt.startsWith("CW"))) {
+		if (!CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) && !(wpt.startsWith("GC") || OC.isOC(wpt) || wpt.startsWith("CW"))) {
 			inpWaypoint.setText(Global.getProfile().getNewWayPointName());
 		}
 	}
 
-    /**
-     * Method to react to a user input.
-     */
-    public void onEvent(final Event ev) {
-        if (ev instanceof DataChangeEvent) {
-            if (ev.target == inpWaypoint) {
-                if (evWaypointChanged) {
-                    String iTmp=inpWaypoint.getText();
-                    String uTmp=iTmp.toUpperCase();
-                    if (!iTmp.equals(uTmp)){
-                        inpWaypoint.setText(uTmp); // If user entered LowerCase -> convert directly to UpperCase
-                        evWaypointChanged=false; //next DataChangeEvent fired by change to UpperCase will be ignored
-                    }
-                    // already warned(multi same DataChangeEvents) or same waypointname as before edit !!!
-                    if(!warnedForWaypoint.equals(uTmp) && !uTmp.equals(this.cache.getWayPoint())){
-                        if ((new File(profile.dataDir + iTmp.toLowerCase()+".xml")).exists()) {
-                            warnedForWaypoint=uTmp; // before MessageBox cause Multithread DataChangeEvents
-                            // filename is LowerCase
-                            new MessageBox("Warning :",uTmp+"\n"+MyLocale.getMsg(275,"Waypoint already exists!"),MessageBox.OKB).execute();
-                            // revert waypointname
-                            inpWaypoint.setText(this.cache.getWayPoint());
-                        }
-                    }
-                }
-                else {
-                    // first DataChangeEvent is fired by Klick into (after reload).
-                    // that really didn't change anything
-                    evWaypointChanged=true;
-                }
-                // FIXME: if name was changed, we should rename the waypoint.xml file. how? where?
-            } else if (ev.target == chcType) {
-                createWptName();
-                if (CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.selectedIndex))) {
-                    activateControl(btnTerr);
-                    activateControl(btnDiff);
-                    activateControl(chcSize);
-                    activateControl(inpOwner);
-                    activateControl(inpHidden);
-                    activateControl(btnShowBug);
-                    activateControl(btnBlack);
-                } else {
-                    deactivateControl(btnTerr);
-                    deactivateControl(btnDiff);
-                    deactivateControl(chcSize);
-                    deactivateControl(inpOwner);
-                    deactivateControl(inpHidden);
-                    deactivateControl(btnShowBug);
-                    deactivateControl(btnBlack);
-                    chcSize.select(0);
-                    btnTerr.setText(MyLocale.getMsg(1001, "T") + DTINVALID);
-                    btnDiff.setText(MyLocale.getMsg(1000, "D") + DTINVALID);
-                }
-            }
-            //FIXME: check if something was actually changed, since datacachnge events also occur if you just hop through the fileds with the tab key (Why? don't know!)
-            dirtyDetails = true;
-            needsTableUpdate = true;
-        }
-        if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
-            if (ev.target == btnNotes) {
-                dirtyNotes = true; // TODO I think this is redundant, because
-                                    // the notes are saved separately by the notes screen itself
-                final NotesScreen nsc = new NotesScreen(cache.getCacheDetails(true));
-                nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
-                if (isBigScreen) {
-                    waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
-                }
-            } else if (ev.target == btnShowMap) {
-                Global.mainTab.SwitchToMovingMap(cache.pos, true);
-            } else if (ev.target == btnShowBug) {
-                // InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
-                // "Travelbugs",
-                // false, pref);
-                // is.execute();
-                final TravelbugInCacheScreen ts = new TravelbugInCacheScreen(cache.getCacheDetails(true).Travelbugs.toHtml(),	"Travelbugs");
-                ts.execute(this.getFrame(), Gui.CENTER_FRAME);
-            /* not fully implemented
-            } else if (ev.target == btnCenter) {
-                final CWPoint cp = new CWPoint(cache.LatLon);
-                if (cp.isValid()) {
-                    pref.setCurCentrePt(cp);
-                } else {
-                    final MessageBox tmpMB = new MessageBox(
-                            MyLocale.getMsg(312, "Error"),
-                            MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"),
-                            FormBase.OKB);
-                    tmpMB.exec();
-                }
-            */
+	/**
+	 * Method to react to a user input.
+	 */
+	public void onEvent(final Event ev) {
+		if (ev instanceof DataChangeEvent) {
+			if (ev.target == inpWaypoint) {
+				if (evWaypointChanged) {
+					String iTmp = inpWaypoint.getText();
+					String uTmp = iTmp.toUpperCase();
+					if (!iTmp.equals(uTmp)) {
+						inpWaypoint.setText(uTmp); // If user entered LowerCase -> convert directly to UpperCase
+						evWaypointChanged = false; // next DataChangeEvent fired by change to UpperCase will be ignored
+					}
+					// already warned(multi same DataChangeEvents) or same waypointname as before edit !!!
+					if (!warnedForWaypoint.equals(uTmp) && !uTmp.equals(this.cache.getWayPoint())) {
+						if ((new File(profile.dataDir + iTmp.toLowerCase() + ".xml")).exists()) {
+							warnedForWaypoint = uTmp; // before MessageBox cause Multithread DataChangeEvents
+							// filename is LowerCase
+							new MessageBox("Warning :", uTmp + "\n" + MyLocale.getMsg(275, "Waypoint already exists!"), MessageBox.OKB).execute();
+							// revert waypointname
+							inpWaypoint.setText(this.cache.getWayPoint());
+						}
+					}
+				} else {
+					// first DataChangeEvent is fired by Klick into (after reload).
+					// that really didn't change anything
+					evWaypointChanged = true;
+				}
+				// FIXME: if name was changed, we should rename the waypoint.xml file. how? where?
+			} else if (ev.target == chcType) {
+				createWptName();
+				if (CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.selectedIndex))) {
+					activateControl(btnTerr);
+					activateControl(btnDiff);
+					activateControl(chcSize);
+					activateControl(inpOwner);
+					activateControl(inpHidden);
+					activateControl(btnShowBug);
+					activateControl(btnBlack);
+				} else {
+					deactivateControl(btnTerr);
+					deactivateControl(btnDiff);
+					deactivateControl(chcSize);
+					deactivateControl(inpOwner);
+					deactivateControl(inpHidden);
+					deactivateControl(btnShowBug);
+					deactivateControl(btnBlack);
+					chcSize.select(0);
+					btnTerr.setText(MyLocale.getMsg(1001, "T") + DTINVALID);
+					btnDiff.setText(MyLocale.getMsg(1000, "D") + DTINVALID);
+				}
+			}
+			// FIXME: check if something was actually changed, since datacachnge events also occur if you just hop through the fileds with the tab key (Why? don't know!)
+			dirtyDetails = true;
+			needsTableUpdate = true;
+		}
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == btnNotes) {
+				dirtyNotes = true; // TODO I think this is redundant, because
+									// the notes are saved separately by the notes screen itself
+				final NotesScreen nsc = new NotesScreen(cache.getCacheDetails(true));
+				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
+				if (pref.isBigScreen) {
+					waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
+				}
+			} else if (ev.target == btnShowMap) {
+				Global.mainTab.SwitchToMovingMap(cache.getPos(), true);
+			} else if (ev.target == btnShowBug) {
+				// InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
+				// "Travelbugs",
+				// false, pref);
+				// is.execute();
+				final TravelbugInCacheScreen ts = new TravelbugInCacheScreen(cache.getCacheDetails(true).Travelbugs.toHtml(), "Travelbugs");
+				ts.execute(this.getFrame(), Gui.CENTER_FRAME);
+				/*
+				 * not fully implemented
+				 * } else if (ev.target == btnCenter) {
+				 * final CWPoint cp = new CWPoint(cache.LatLon);
+				 * if (cp.isValid()) {
+				 * pref.setCurCentrePt(cp);
+				 * } else {
+				 * final MessageBox tmpMB = new MessageBox(
+				 * MyLocale.getMsg(312, "Error"),
+				 * MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"),
+				 * FormBase.OKB);
+				 * tmpMB.exec();
+				 * }
+				 */
 
-            } else if (ev.target == btnAddDateTime) {
-                dirtyNotes = true;
+			} else if (ev.target == btnAddDateTime) {
+				dirtyNotes = true;
 
-                final StringBuffer newNote = new StringBuffer();
-                newNote.append(cache.getCacheDetails(true).getCacheNotes());
+				final StringBuffer newNote = new StringBuffer();
+				newNote.append(cache.getCacheDetails(true).getCacheNotes());
 
-                final Time dtm = new Time();
-                dtm.getTime();
-                dtm.setFormat("E dd.MM.yyyy '/' HH:mm");
+				final Time dtm = new Time();
+				dtm.getTime();
+				dtm.setFormat("E dd.MM.yyyy '/' HH:mm");
 
-                if (newNote.length() > 0) {
-                    newNote.append('\n');
-                }
-                newNote.append(dtm.toString()).append('\n');
+				if (newNote.length() > 0) {
+					newNote.append('\n');
+				}
+				newNote.append(dtm.toString()).append('\n');
 
-                cache.getCacheDetails(true).setCacheNotes(newNote.toString());
-                //FIXME: better use saveDirtyWaypoint()?
-                cache.save();
-            } else if (ev.target == btnAddPicture) {
-                cache.getCacheDetails(true).addUserImage(profile);
-            } else if (ev.target == btnBlack) {
-                if (cache.is_black()) {
-                    cache.setBlack(false);
-                    btnBlack.image = imgBlackNo;
-                } else {
-                    cache.setBlack(true);
-                    btnBlack.image = imgBlack;
-                }
-                blackStatus = cache.is_black();
-                cache.setAttributesToAddiWpts();
-                btnBlack.repaintNow();
-                dirtyDetails = true;
-                blackStatusChanged = true;
-            } else if (ev.target == btnNewWpt) {
-                final CacheHolder ch = new CacheHolder();
-                ch.setLatLon(cache.getLatLon());
-                ch.pos = new CWPoint(cache.pos);
-                ch.setType(CacheType.CW_TYPE_STAGE);
-                ch.setHard(CacheTerrDiff.CW_DT_UNSET);
-                ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-                ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-                Global.mainTab.newWaypoint(ch);
-            } else if (ev.target == btnGoto) {
-                // FIXME: if something changed saveDirtyWaypoint();
-                Global.mainTab.gotoP.setDestinationAndSwitch(cache);
-            } else if (ev.target == btnCoordinates) {
-                CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);
-                if(Vm.isMobile()){
-                    InputScreen InScr = new InputScreen(TransformCoordinates.CW, true);
-                    if (coords.isValid())	InScr.setCoords(coords);
-                        else InScr.setCoords(new CWPoint(0,0));
-                    if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
-                    {
-                        dirtyDetails = true;
-                        coords = InScr.getCoords();
-                        Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-                        cache.pos.set(coords);
-                        btnCoordinates.setText(coords.toString());
-                        cache.setLatLon(coords.toString());
-                        // If the current centre is valid, calculate the distance and bearing to it
-                        final CWPoint centre = Global.getPref().getCurCentrePt();
-                        if (centre.isValid()) {
-                            cache.calcDistance(centre); // todo perhaps sortTable
-                        }
-                    }
-                }else{
-                    final CoordsScreen cs = new CoordsScreen(true);
-                    cs.setFields(coords, TransformCoordinates.CW);
-                    if (cs.execute() == FormBase.IDOK) {
-                        dirtyDetails = true;
-                        coords = cs.getCoords();
-                        Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-                        cache.pos.set(coords);
-                        btnCoordinates.setText(coords.toString());
-                        cache.setLatLon(coords.toString());
-                        // If the current centre is valid, calculate the distance and bearing to it
-                        final CWPoint centre = Global.getPref().getCurCentrePt();
-                        if (centre.isValid()) {
-                            cache.calcDistance(centre); // todo perhaps sortTable
-                        }
-                    }
-                }
-            } else if (ev.target == btnFoundDate) {
-            	int msgNr=318; // normal found
-            	if (cache.getType() == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-            	else if (cache.getType() == CacheType.CW_TYPE_EVENT 
-            			|| cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
-                // DateChooser.dayFirst=true;
-                final DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
-                dc.title = MyLocale.getMsg(328, "Date found");
-                dc.setPreferredSize(240, 240);
-                String foundDate = chcStatus.getText();
-                if (foundDate.startsWith(MyLocale.getMsg(msgNr, "Found") + " ")) {
-                    foundDate = foundDate.substring(MyLocale.getMsg(msgNr, "Found").length() + 1);
-                }
-                else if (foundDate.endsWith(MyLocale.getMsg(319, "not Found"))) {
-                    foundDate = foundDate.substring(0,foundDate.length()-MyLocale.getMsg(319, "not Found").length());
-                    dc.title=MyLocale.getMsg(330,"Date Not Found");
-                }
-                foundDate=foundDate.trim();
-                if (foundDate.length()>0 && foundDate.indexOf('-')>0) { //Don't try and parse empty date
-                    final Time t = new Time();
-                    try {
-                        t.parse(foundDate, "y-M-d H:m");
-                    } catch (IllegalArgumentException e) {
-                        try {
-                            t.parse(foundDate, "y-M-d");
-                        } catch (IllegalArgumentException e1) {
-                            Global.getPref().log("No parsable date given - should not appear ("+foundDate+")", e1, true);
-                        }
-                    }
+				cache.getCacheDetails(true).setCacheNotes(newNote.toString());
+				// FIXME: better use saveDirtyWaypoint()?
+				cache.save();
+			} else if (ev.target == btnAddPicture) {
+				cache.getCacheDetails(true).addUserImage(profile);
+			} else if (ev.target == btnBlack) {
+				if (cache.is_black()) {
+					cache.setBlack(false);
+					btnBlack.image = imgBlackNo;
+				} else {
+					cache.setBlack(true);
+					btnBlack.image = imgBlack;
+				}
+				blackStatus = cache.is_black();
+				cache.setAttributesToAddiWpts();
+				btnBlack.repaintNow();
+				dirtyDetails = true;
+				blackStatusChanged = true;
+			} else if (ev.target == btnNewWpt) {
+				final CacheHolder ch = new CacheHolder();
+				ch.setPos(cache.getPos());
+				ch.setType(CacheType.CW_TYPE_STAGE);
+				ch.setHard(CacheTerrDiff.CW_DT_UNSET);
+				ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				Global.mainTab.newWaypoint(ch);
+			} else if (ev.target == btnGoto) {
+				// FIXME: if something changed saveDirtyWaypoint();
+				Global.mainTab.gotoP.setDestinationAndSwitch(cache);
+			} else if (ev.target == btnCoordinates) {
+				CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);
+				if (Vm.isMobile()) {
+					InputScreen InScr = new InputScreen(TransformCoordinates.CW, true);
+					if (coords.isValid())
+						InScr.setCoords(coords);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
+					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
+						dirtyDetails = true;
+						coords = InScr.getCoords();
+						cache.setPos(coords);
+						btnCoordinates.setText(coords.toString());
+						// If the current centre is valid, calculate the distance and bearing to it
+						final CWPoint centre = Global.getPref().getCurCentrePt();
+						if (centre.isValid()) {
+							cache.calcDistance(centre); // todo perhaps sortTable
+						}
+					}
+				} else {
+					final CoordsScreen cs = new CoordsScreen(true);
+					cs.setFields(coords, TransformCoordinates.CW);
+					if (cs.execute() == FormBase.IDOK) {
+						dirtyDetails = true;
+						coords = cs.getCoords();
+						cache.setPos(coords);
+						btnCoordinates.setText(coords.toString());
+						// If the current centre is valid, calculate the distance and bearing to it
+						final CWPoint centre = Global.getPref().getCurCentrePt();
+						if (centre.isValid()) {
+							cache.calcDistance(centre); // todo perhaps sortTable
+						}
+					}
+				}
+			} else if (ev.target == btnFoundDate) {
+				int msgNr = 318; // normal found
+				if (cache.getType() == CacheType.CW_TYPE_WEBCAM) {
+					msgNr = 361;
+				} else if (cache.getType() == CacheType.CW_TYPE_EVENT || cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+					msgNr = 355;
+				}
+				// DateChooser.dayFirst=true;
+				final DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, "Date found");
+				dc.setPreferredSize(240, 240);
+				String foundDate = chcStatus.getText();
+				if (foundDate.startsWith(MyLocale.getMsg(msgNr, "Found") + " ")) {
+					foundDate = foundDate.substring(MyLocale.getMsg(msgNr, "Found").length() + 1);
+				} else if (foundDate.endsWith(MyLocale.getMsg(319, "not Found"))) {
+					foundDate = foundDate.substring(0, foundDate.length() - MyLocale.getMsg(319, "not Found").length());
+					dc.title = MyLocale.getMsg(330, "Date Not Found");
+				}
+				foundDate = foundDate.trim();
+				if (foundDate.length() > 0 && foundDate.indexOf('-') > 0) { // Don't try and parse empty date
+					final Time t = new Time();
+					try {
+						t.parse(foundDate, "y-M-d H:m");
+					} catch (IllegalArgumentException e) {
+						try {
+							t.parse(foundDate, "y-M-d");
+						} catch (IllegalArgumentException e1) {
+							Global.getPref().log("No parsable date given - should not appear (" + foundDate + ")", e1, true);
+						}
+					}
 
-                    dc.reset(t);
-                }
-                // We can create a not found log with date in two ways:
-                //   1) Exiting the date-time dialog by clicking the x if the status is empty (somewhat
-                //      non-standard but quick and dirty)
-                //   2) Exiting the date-time dialog by clicking the tick. Then we check whether
-                //      the status field was preset with the not-found text. If yes it stays a not found
-                //      but the date is prepended
-                //TODO: The functions for extracting the date and the found/not-found text should not be in the GUI
-                int retCode=dc.execute();
-                if (retCode == ewe.ui.FormBase.IDOK && !chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found"))) {
-                    chcStatus.setText(MyLocale.getMsg(msgNr, "Found") + " "
-                                    + Convert.toString(dc.year) + "-"
-                                    + MyLocale.formatLong(dc.month, "00") + "-"
-                                    + MyLocale.formatLong(dc.day, "00") + " "
-                                    + dc.time);
-                    dirtyDetails = true;
-                }
-                else if (chcStatus.getText().length()==0 ||
-                		(retCode==ewe.ui.FormBase.IDOK && chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found")) )) {
-                    chcStatus.setText(Convert.toString(dc.year) + "-"
-                            + MyLocale.formatLong(dc.month, "00") + "-"
-                            + MyLocale.formatLong(dc.day, "00") + " "
-                            + dc.time + " "
-                            + MyLocale.getMsg(319, "not Found")
-                            );
-                    dirtyDetails = true;
-                }
-            } else if (ev.target == btnHiddenDate) {
-                DateChooser.dayFirst = true;
-                final DateChooser dc = new DateChooser(Vm.getLocale());
-                dc.title = MyLocale.getMsg(329, "Hidden date");
-                dc.setPreferredSize(240, 240);
-                if (inpHidden.getText().length() == 10)
-                    try {
-                        dc.setDate(new Time(Convert.parseInt(inpHidden
-                                .getText().substring(8)), Convert
-                                .parseInt(inpHidden.getText().substring(5, 7)),
-                                Convert.parseInt(inpHidden.getText().substring(
-                                        0, 4))));
-                    } catch (NumberFormatException e) {
-                        dc.reset(new Time());
-                    }
-                if (dc.execute() == ewe.ui.FormBase.IDOK) {
-                    inpHidden.setText(Convert.toString(dc.year) + "-"
-                            + MyLocale.formatLong(dc.month, "00") + "-"
-                            + MyLocale.formatLong(dc.day, "00"));
-                    dirtyDetails = true;
-                    // profile.hasUnsavedChanges=true;
-                }
-            } else if (ev.target == btnTerr) {
-                int returnValue;
-                final TerrDiffForm tdf = new TerrDiffForm(true,
-                        decodeTerrDiff(btnTerr,
-                                MyLocale.getMsg(1001, "T"),
-                                CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-                            )
-                        );
-                returnValue = tdf.execute();
-                if (returnValue == 1) {
-                    btnTerr.setText(MyLocale.getMsg(1001, "T") + ": " + CacheTerrDiff.longDT(tdf.getDT()));
-                    dirtyDetails = true;
-                }
-            } else if (ev.target == btnDiff) {
-                int returnValue;
-                final TerrDiffForm tdf = new TerrDiffForm(false,
-                        decodeTerrDiff(btnDiff,
-                                MyLocale.getMsg(1001, "D"),
-                                CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-                            )
-                        );
+					dc.reset(t);
+				}
+				// We can create a not found log with date in two ways:
+				// 1) Exiting the date-time dialog by clicking the x if the status is empty (somewhat
+				// non-standard but quick and dirty)
+				// 2) Exiting the date-time dialog by clicking the tick. Then we check whether
+				// the status field was preset with the not-found text. If yes it stays a not found
+				// but the date is prepended
+				// TODO: The functions for extracting the date and the found/not-found text should not be in the GUI
+				int retCode = dc.execute();
+				if (retCode == ewe.ui.FormBase.IDOK && !chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found"))) {
+					chcStatus.setText(MyLocale.getMsg(msgNr, "Found") + " " + Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time);
+					dirtyDetails = true;
+				} else if (chcStatus.getText().length() == 0 || (retCode == ewe.ui.FormBase.IDOK && chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found")))) {
+					chcStatus.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time + " " + MyLocale.getMsg(319, "not Found"));
+					dirtyDetails = true;
+				}
+			} else if (ev.target == btnHiddenDate) {
+				DateChooser.dayFirst = true;
+				final DateChooser dc = new DateChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(329, "Hidden date");
+				dc.setPreferredSize(240, 240);
+				if (inpHidden.getText().length() == 10)
+					try {
+						dc.setDate(new Time(Convert.parseInt(inpHidden.getText().substring(8)), Convert.parseInt(inpHidden.getText().substring(5, 7)), Convert.parseInt(inpHidden.getText().substring(0, 4))));
+					} catch (NumberFormatException e) {
+						dc.reset(new Time());
+					}
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpHidden.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00"));
+					dirtyDetails = true;
+					// profile.hasUnsavedChanges=true;
+				}
+			} else if (ev.target == btnTerr) {
+				int returnValue;
+				final TerrDiffForm tdf = new TerrDiffForm(true, decodeTerrDiff(btnTerr, MyLocale.getMsg(1001, "T"), CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))));
+				returnValue = tdf.execute();
+				if (returnValue == 1) {
+					btnTerr.setText(MyLocale.getMsg(1001, "T") + ": " + CacheTerrDiff.longDT(tdf.getDT()));
+					dirtyDetails = true;
+				}
+			} else if (ev.target == btnDiff) {
+				int returnValue;
+				final TerrDiffForm tdf = new TerrDiffForm(false, decodeTerrDiff(btnDiff, MyLocale.getMsg(1001, "D"), CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))));
 
-                returnValue = tdf.execute();
-                if (returnValue == 1) {
-                    btnDiff.setText(MyLocale.getMsg(1000, "D") + ": "
-                            + CacheTerrDiff.longDT(tdf.getDT()));
-                    dirtyDetails = true;
-                }
-            }
-            ev.consumed = true;
-        }
-    }
+				returnValue = tdf.execute();
+				if (returnValue == 1) {
+					btnDiff.setText(MyLocale.getMsg(1000, "D") + ": " + CacheTerrDiff.longDT(tdf.getDT()));
+					dirtyDetails = true;
+				}
+			}
+			ev.consumed = true;
+		}
+	}
 
 	/** allow user input on control item */
 	private void activateControl(final Control ctrl) {
@@ -751,39 +708,39 @@
 	}
 
 	public void saveDirtyWaypoint() {
-		//FIXME: here we should check if the data is now different from what it used to be when calling the details panel instead of relying on dirty flags
-		//FIXME: take care of renaming waypoints
-		//FIXME: add method to convert back text of difficulty & terrain buttons
-		//FIXME: check if manual changes have converted a cache from incomplete to complete
+		// FIXME: here we should check if the data is now different from what it used to be when calling the details panel instead of relying on dirty flags
+		// FIXME: take care of renaming waypoints
+		// FIXME: add method to convert back text of difficulty & terrain buttons
+		// FIXME: check if manual changes have converted a cache from incomplete to complete
 
 		// We have to update two objects: thisCache (a CacheHolderDetail) which
 		// contains
 		// the full cache which will be written to the cache.xml file AND
 		// the CacheHolder object which sits in cacheDB
-		//FIXME: so how do we do this??
+		// FIXME: so how do we do this??
 
-		int msgNr=318; // normal found
-    	if (cache.getType() == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-    	else if (cache.getType() == CacheType.CW_TYPE_EVENT 
-    			|| cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (cache.getType() == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (cache.getType() == CacheType.CW_TYPE_EVENT || cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 
 		// Strip the found message if the status contains a date
-		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) &&
-			chcStatus.getText().length() >= MyLocale.getMsg(msgNr, "Found").length() + 11) {
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) && chcStatus.getText().length() >= MyLocale.getMsg(msgNr, "Found").length() + 11) {
 			cache.setCacheStatus(chcStatus.getText().substring(MyLocale.getMsg(msgNr, "Found").length() + 1));
 		} else {
 			cache.setCacheStatus(chcStatus.getText());
 		}
 
-		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) ||
-			(cache.getCacheStatus().length() == 10 || cache.getCacheStatus().length() == 16) && cache.getCacheStatus().charAt(4) == '-') {
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) || (cache.getCacheStatus().length() == 10 || cache.getCacheStatus().length() == 16) && cache.getCacheStatus().charAt(4) == '-') {
 			// Use same heuristic condition as in setDetails(CacheHolder) to
 			// determine, if this
 			// cache
 			// has to considered as found.
 			cache.setFound(true);
-		}
-		else cache.setFound(false);
+		} else
+			cache.setFound(false);
 
 		if (!cache.isAddiWpt()) {
 			cache.setCacheOwner(inpOwner.getText().trim());
@@ -791,13 +748,7 @@
 		cache.setOwned(cache.getCacheStatus().equals(MyLocale.getMsg(320, "Owner")));
 		// Avoid setting is_owned if alias is empty and username is empty
 		if (!cache.is_owned()) {
-			cache.setOwned(
-					(!pref.myAlias.equals("") &&
-						pref.myAlias.equals(cache.getCacheOwner()))
-					||
-					(!pref.myAlias2.equals("") &&
-						pref.myAlias2.equals(cache.getCacheOwner()))
-					);
+			cache.setOwned((!pref.myAlias.equals("") && pref.myAlias.equals(cache.getCacheOwner())) || (!pref.myAlias2.equals("") && pref.myAlias2.equals(cache.getCacheOwner())));
 		}
 		cache.setBlack(blackStatus);
 		final String oldWaypoint = cache.getWayPoint();
@@ -815,7 +766,6 @@
 		if (cache.getWayPoint().length() < 2)
 			cache.setWayPoint(cache.getWayPoint() + " ");
 		cache.setCacheName(inpName.getText().trim());
-		cache.setLatLon(cache.pos.toString());
 		if (!cache.isAddiWpt()) {
 			cache.setDateHidden(inpHidden.getText().trim());
 		}
@@ -833,51 +783,57 @@
 		 * - the cachetype changed from addi->normal or from normal->addi
 		 * - the old cachetype or the new cachetype were 'addi' and the waypointname has changed
 		 */
-		if (CacheType.isAddiWpt(cache.getType()) != CacheType.isAddiWpt(oldType) ||
-			((CacheType.isAddiWpt(cache.getType()) || CacheType.isAddiWpt(oldType)) && !cache.getWayPoint().equals(oldWaypoint))) {
+		if (CacheType.isAddiWpt(cache.getType()) != CacheType.isAddiWpt(oldType) || ((CacheType.isAddiWpt(cache.getType()) || CacheType.isAddiWpt(oldType)) && !cache.getWayPoint().equals(oldWaypoint))) {
 			// If we changed the type to addi, check that a parent exists
-			//FIXME: if cache was renamed we need to rebuild CacheDB.hashDB first
+			// FIXME: if cache was renamed we need to rebuild CacheDB.hashDB first
 			profile.buildReferences();
 		} else {
 			// set status also on addi wpts
 			cache.setAttributesToAddiWpts();
 		}
 		if (!cache.isAddiWpt()) {
-			cache.setHard(decodeTerrDiff(btnDiff,MyLocale.getMsg(1000, "D"),cache.isCacheWpt()));
-			cache.setTerrain(decodeTerrDiff(btnTerr,MyLocale.getMsg(1001, "T"),cache.isCacheWpt()));
+			cache.setHard(decodeTerrDiff(btnDiff, MyLocale.getMsg(1000, "D"), cache.isCacheWpt()));
+			cache.setTerrain(decodeTerrDiff(btnTerr, MyLocale.getMsg(1001, "T"), cache.isCacheWpt()));
 		}
 		dirtyNotes = false;
 		dirtyDetails = false;
 		needsTableUpdate = false;
 		cache.getCacheDetails(false).hasUnsavedChanges = true;
-		if (!oldWaypoint.equals(cache.getWayPoint())){
-		 // Delete old XML - File
-			cache.getCacheDetails(false).deleteFile(Global.getProfile().dataDir+oldWaypoint+".xml");
+		if (!oldWaypoint.equals(cache.getWayPoint())) {
+			// Delete old XML - File
+			cache.getCacheDetails(false).deleteFile(Global.getProfile().dataDir + oldWaypoint + ".xml");
 		}
 	}
 
 	/**
 	 * convert the string displayed in the terrain in difficulty buttons to a byte for intrernal use<br>
 	 * assumes that the relevant information will at positions 3 and 5 in a 0 indexed string
-	 * @param button button control to get the text from
-	 * @param td localized string for abbreviation of terrain or difficulty
-	 * @param isCache true if waypoint is a cache, false for addis and custom
+	 * 
+	 * @param button
+	 *            button control to get the text from
+	 * @param td
+	 *            localized string for abbreviation of terrain or difficulty
+	 * @param isCache
+	 *            true if waypoint is a cache, false for addis and custom
 	 * @return 0 for additional or custum waypoints, -1 for caches if td is not valid, parsed byte otherwise
 	 */
 	private byte decodeTerrDiff(mButton button, String td, boolean isCache) {
 		// terrain and difficulty are always unset for non cache waypoints
-		if (! isCache) return CacheTerrDiff.CW_DT_UNSET;
+		if (!isCache)
+			return CacheTerrDiff.CW_DT_UNSET;
 
 		// cut off beginning of string
-		String buttonText = button.getText().substring(td.length()+2);
+		String buttonText = button.getText().substring(td.length() + 2);
 		// we now should have a string of length 3
-		if (buttonText.length() != 3) return -1;
+		if (buttonText.length() != 3)
+			return -1;
 
 		final StringBuffer tdv = new StringBuffer(2);
-		buttonText=tdv.append(buttonText.charAt(0)).append(buttonText.charAt(2)).toString();
+		buttonText = tdv.append(buttonText.charAt(0)).append(buttonText.charAt(2)).toString();
 
 		// unset value is invalid
-		if ("--".equals(buttonText)) return CacheTerrDiff.CW_DT_ERROR;
+		if ("--".equals(buttonText))
+			return CacheTerrDiff.CW_DT_ERROR;
 
 		return Byte.parseByte(buttonText);
 	}
@@ -887,18 +843,14 @@
 		private final DispPanel disp = new DispPanel();
 		private final mButton btCancel;
 
-
 		TravelbugInCacheScreen(String text, String title) {
 			super();
 			this.setTitle(title);
 			this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 			disp.setHtml(text);
-			final ScrollBarPanel sbp = new MyScrollBarPanel(disp,
-					ScrollablePanel.NeverShowHorizontalScrollers);
+			final ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
 			this.addLast(sbp);
-			this.addLast(
-					btCancel = new mButton(MyLocale.getMsg(3000, "Close")),
-					CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(btCancel = new mButton(MyLocale.getMsg(3000, "Close")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
 
 		public void onEvent(Event ev) {
@@ -917,10 +869,8 @@
 
 			DispPanel() {
 				super();
-				tbMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(
-						6016, "Pick up Travelbug"));
-				tbMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6017,
-						"Drop Travelbug"));
+				tbMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6016, "Pick up Travelbug"));
+				tbMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6017, "Drop Travelbug"));
 				mnuPopup = new Menu(tbMenuItems, "");
 			}
 
@@ -946,8 +896,7 @@
 						tbjList = new TravelbugJourneyList();
 						tbjList.readTravelbugsFile();
 						// Add the tb to this list
-						tbjList.addTbPickup(tb, Global.getProfile().name,
-								cache.getWayPoint());
+						tbjList.addTbPickup(tb, Global.getProfile().name, cache.getWayPoint());
 						tbjList.saveTravelbugsFile();
 						setHtml(cache.getCacheDetails(true).Travelbugs.toHtml());
 						repaint();
@@ -958,14 +907,12 @@
 					tbjList = new TravelbugJourneyList();
 					tbjList.readTravelbugsFile();
 					TravelbugList tbl = tbjList.getMyTravelbugs();
-					TravelbugScreen tbs = new TravelbugScreen(tbl, MyLocale
-							.getMsg(6017, "Drop a travelbug"), false);
+					TravelbugScreen tbs = new TravelbugScreen(tbl, MyLocale.getMsg(6017, "Drop a travelbug"), false);
 					tbs.execute();
 					if (tbs.selectedItem >= 0) {
 						Travelbug tb = tbl.getTB(tbs.selectedItem);
 						cache.getCacheDetails(true).Travelbugs.add(tb);
-						tbjList.addTbDrop(tb, Global.getProfile().name,
-								cache.getWayPoint());
+						tbjList.addTbDrop(tb, Global.getProfile().name, cache.getWayPoint());
 					}
 					tbjList.saveTravelbugsFile();
 					cache.setHas_bugs(cache.getCacheDetails(true).Travelbugs.size() > 0);
@@ -993,8 +940,7 @@
 			resizable = false;
 			setTitle(MyLocale.getMsg(31415, "D & T"));
 
-			addNext(new mLabel(terrain ? MyLocale.getMsg(31415, "Terrain")
-					: MyLocale.getMsg(31415, "Difficulty")));
+			addNext(new mLabel(terrain ? MyLocale.getMsg(31415, "Terrain") : MyLocale.getMsg(31415, "Difficulty")));
 			addLast(mcDT);
 			addButton(btnOk);
 			addButton(btnCancel);

Modified: branches/r1.2/src/CacheWolf/Extractor.java
===================================================================
--- branches/r1.2/src/CacheWolf/Extractor.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Extractor.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,104 +1,124 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+/**
+ * This is a powerfull class that is used very often. It is quicker than
+ * XML parsing and should be used whenever possible to find and extract
+ * parts of a string in a string.
+ */
+public class Extractor {
+	int _startOffset;
+	String _searchText;
+	String start;
+	String end;
+	boolean _betweenonly;
+	public static boolean INCLUDESTARTEND = false;
+	public static boolean EXCLUDESTARTEND = true;
 
-/**
-*	This is a powerfull class that is used very often. It is quicker than
-*	XML parsing and should be used whenever possible to find and extract
-*	parts of a string in a string.
-*/
-public class Extractor  {
-		int startOffset; // No initialisation needed, done in constructor
-		String searchText;
-		String start;
-		String end;
-		String tst;
-		boolean betweenonly;
-		public static boolean INCLUDESTARTEND = false;
-		public static boolean EXCLUDESTARTEND = true;
-		/**
-		*	Create an extractor.
-		*	sTxt = The string to search through.<br>
-		*	st = The string that denotes the start of the string to extract<br>
-		*	e = The string that denotes the end of the string to extract<br>
-		*	sOff = The beginning offset from which to start the search in sTxt<br>
-		*	only = if false the string returned will inlcude st and e; if true
-		*	it will not include st and e.
-		*
-		*/
-		public Extractor(String sTxt, String st, String e, int sOff, boolean only){
-			startOffset = sOff;
-			searchText = sTxt;
-			end = e;
-			start = st;
-			betweenonly = only;
-		}
-		
-		/**
-		 * Mehtod to set the source text to be searched through
-		 * 
-		 */
-		public void setSource(String sTxt){
-			searchText = sTxt;
-			startOffset = 0;
-		}
-		
-		/**
-		* Method that informs if the search has encountered the end of the string
-		* that is being searched through.
-		*/
-		public boolean endOfSearch(){
-			if(searchText == null || startOffset >= searchText.length()) return true;
-			else return false;
-		}
-		
-		/**
-		*	Method to find the next occurance of a string that is enclosed by
-		*	that start (st) and end string (e). if end is not found the string
-		*	is returned til it's end.
-		*/
-		public String findNext(){
-			if (searchText == null) return new String(); //maby null should 
-			int idxStart = searchText.indexOf(start,startOffset);
-			int idxEnd = searchText.indexOf(end, idxStart+start.length());
-			if(idxEnd == -1) idxEnd = searchText.length(); //index counts from zero length from 1 but the last char is not included in substr and substr accepts length +1 (but not length+2)
-			startOffset = idxEnd;
-			tst = new String();
-			if(idxStart > -1){
-				if(betweenonly == false){
-					if (idxEnd+end.length() >= searchText.length()) 
-						 tst = searchText.substring(idxStart);
-					else tst = searchText.substring(idxStart,idxEnd+end.length());
-				}else{ 
-					tst = searchText.substring(idxStart+start.length(),idxEnd);
+	/**
+	 * Create an extractor.
+	 * searchText = The string to search through.<br>
+	 * st = The string that denotes the start of the string to extract<br>
+	 * e = The string that denotes the end of the string to extract<br>
+	 * startOffset = The beginning offset from which to start the search in sTxt<br>
+	 * betweenonly = if false the string returned will inlcude st and e;
+	 * if true it will not include st and e.
+	 * 
+	 */
+	public Extractor(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	/**
+	 * Mehtod to set the source text to be searched through
+	 * 
+	 */
+	public void set(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	public void set(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+	}
+
+	public void set(String searchText, int startOffset) {
+		_searchText = searchText;
+		_startOffset = startOffset;
+	}
+
+	public String findFirst(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+		return findNext();
+	}
+
+	public String findNext(String startText) {
+		start = startText;
+		return findNext();
+	}
+
+	public String findNext(String startText, String endText) {
+		start = startText;
+		end = endText;
+		return findNext();
+	}
+
+	/**
+	 * Method to find the next occurance of a string that is enclosed by
+	 * that start (st) and end string (e).
+	 * if end is not found empty string is returned.
+	 */
+	public String findNext() {
+		String ret = "";
+		if (_searchText != null && _searchText.length() > _startOffset + start.length() + end.length()) {
+			int idxStart = _searchText.indexOf(start, _startOffset);
+			int idxEnd = -1;
+			if (idxStart > -1) {
+				idxEnd = _searchText.indexOf(end, idxStart + start.length());
+				if (idxEnd > -1) {
+					_startOffset = idxEnd;
+					ret = _searchText.substring(idxStart + start.length(), idxEnd);
+					if (!this._betweenonly)
+						ret = start + ret + end;
 				}
-			} else {
-				startOffset = searchText.length();
 			}
-			return tst;
+			if (idxEnd == -1) {
+				_startOffset = _searchText.length(); // Schluss
+			}
 		}
+		return ret;
+	}
 }

Modified: branches/r1.2/src/CacheWolf/Filter.java
===================================================================
--- branches/r1.2/src/CacheWolf/Filter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Filter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,31 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import CacheWolf.imp.KMLImporter;
-import CacheWolf.navi.TransformCoordinates;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -40,21 +40,22 @@
 import ewe.util.Vector;
 
 /**
-*	Class that actually filters the cache database.<br>
-*	The class that uses this filter must set the different public variables.
-*   @author BilboWolf (optimiert von salzkammergut)
-*/
-public class Filter{
-	public static final int FILTER_INACTIVE=0;
-	public static final int FILTER_ACTIVE=1;
-	public static final int FILTER_CACHELIST=2;
-	public static final int FILTER_MARKED_ONLY=3;
-	
+ * Class that actually filters the cache database.<br>
+ * The class that uses this filter must set the different public variables.
+ * 
+ * @author BilboWolf (optimiert von salzkammergut)
+ */
+public class Filter {
+	public static final int FILTER_INACTIVE = 0;
+	public static final int FILTER_ACTIVE = 1;
+	public static final int FILTER_CACHELIST = 2;
+	public static final int FILTER_MARKED_ONLY = 3;
+
 	/** Indicator whether a filter is inverted */
-	//public static boolean filterInverted=false;
+	// public static boolean filterInverted=false;
 	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
-	//public static int filterActive=FILTER_INACTIVE;
-	
+	// public static int filterActive=FILTER_INACTIVE;
+
 	private static final int SMALLER = -1;
 	private static final int EQUAL = 0;
 	private static final int GREATER = 1;
@@ -75,123 +76,125 @@
 	private static final int NW = 8192;
 	private static final int NNW = 16384;
 	private static final int S = 32768;
-	private static final int ROSE_ALL= N|NNE|NE|ENE|E|ESE|SE|SSE|SSW|SW|WSW|W|WNW|NW|NNW|S;
+	private static final int ROSE_ALL = N | NNE | NE | ENE | E | ESE | SE | SSE | SSW | SW | WSW | W | WNW | NW | NNW | S;
 
 	private int distdirec = 0;
 	private int diffdirec = 0;
 	private int terrdirec = 0;
-	
+
 	String[] byVec;
-	
-	
+
 	private int roseMatchPattern;
 	private boolean hasRoseMatchPattern;
 	private int typeMatchPattern;
 	private boolean hasTypeMatchPattern;
 	private int sizeMatchPattern;
 	private boolean hasSizeMatchPattern;
-	
+
 	private boolean foundByMe;
 	private boolean notFoundByMe;
 
 	private String cacheStatus;
 	private boolean useRegexp;
 	private boolean filterNoCoord;
-	
+
 	private boolean ownedByMe;
 	private boolean notOwnedByMe;
 
 	double fscDist;
 	double fscTerr;
 	double fscDiff;
-	
+
 	private boolean archived = false;
 	private boolean notArchived = false;
-	
-	private boolean available=false;
+
+	private boolean available = false;
 	private boolean notAvailable = false;
-	double pi180=java.lang.Math.PI / 180.0;
+	double pi180 = java.lang.Math.PI / 180.0;
 
-	private long[] attributesPattern = {0l,0l,0l,0l};
+	private long[] attributesPattern = { 0l, 0l, 0l, 0l };
 	private int attributesChoice = 0;
-	
+
 	/**
-	*	Apply a route filter. Each waypoint is on a seperate line.
-	*	We use a regex method to allow for different formats of waypoints:
-	*	possible is currently: DD MM.mmm
-	*/
-	public void doFilterRoute(File routeFile, double distance){
+	 * Apply a route filter. Each waypoint is on a seperate line.
+	 * We use a regex method to allow for different formats of waypoints:
+	 * possible is currently: DD MM.mmm
+	 */
+	public void doFilterRoute(File routeFile, double distance) {
 		Global.getProfile().selectionChanged = true;
-	    CacheDB cacheDB=Global.getProfile().cacheDB;
-		//load file into a vector:
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		// load file into a vector:
 		Vector wayPoints = new Vector();
 		Regex rex = new Regex("(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})");
 		CWPoint cwp, fromPoint, toPoint;
 		CacheHolder ch;
-		double lat,lon, calcDistance = 0;
-		try{
-			if((routeFile.getFullPath()).indexOf(".kml") > 0){
+		double lat, lon, calcDistance = 0;
+		try {
+			if ((routeFile.getFullPath()).indexOf(".kml") > 0) {
 				KMLImporter kml = new KMLImporter(routeFile.getFullPath());
 				kml.importFile();
 				wayPoints = kml.getPoints();
 			} else {
 				FileReader in = new FileReader(routeFile);
-				String line; 
-				while((line = in.readLine()) != null){
+				String line;
+				while ((line = in.readLine()) != null) {
 					rex.search(line);
 					// parse the route file
-					if(rex.didMatch()){
-						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
-						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-					
-						if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = -lat;
-						if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = -lon;	
-					
+					if (rex.didMatch()) {
+						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3)) / 60 + Convert.toDouble(rex.stringMatched(5)) / 60000;
+						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8)) / 60 + Convert.toDouble(rex.stringMatched(10)) / 60000;
+
+						if (rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s"))
+							lat = -lat;
+						if (rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w"))
+							lon = -lon;
+
 						cwp = new CWPoint(lat, lon);
-						
+
 						wayPoints.add(cwp);
 					}
 				}
 			}
-			//initialise database
-			for(int i = cacheDB.size()-1; i >=0 ; i--){
+			// initialise database
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				ch = cacheDB.get(i);
 				ch.in_range = false;
-				//cacheDB.set(i, ch);
+				// cacheDB.set(i, ch);
 			}
 			// for each segment of the route...
-			for(int z=0;z<wayPoints.size()-1;z++){
+			for (int z = 0; z < wayPoints.size() - 1; z++) {
 				fromPoint = new CWPoint();
 				toPoint = new CWPoint();
-				fromPoint = (CWPoint)wayPoints.get(z);
-				toPoint = (CWPoint)wayPoints.get(z+1);
-				//... go through the current cache database
-				for(int i = cacheDB.size()-1; i >=0 ; i--){
+				fromPoint = (CWPoint) wayPoints.get(z);
+				toPoint = (CWPoint) wayPoints.get(z + 1);
+				// ... go through the current cache database
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					ch = cacheDB.get(i);
-					cwp = new CWPoint(ch.getLatLon(), TransformCoordinates.CW);
+					cwp = new CWPoint(ch.getPos());
 					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
-					calcDistance = (calcDistance*180*60)/java.lang.Math.PI;
+					calcDistance = (calcDistance * 180 * 60) / java.lang.Math.PI;
 					calcDistance = calcDistance * 1.852;
-					if(calcDistance <= distance) {
+					if (calcDistance <= distance) {
 						ch.in_range = true;
 					}
 				} // for database
 			} // for segments
-			for(int i = cacheDB.size()-1; i >=0 ; i--){
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				ch = cacheDB.get(i);
-				if(ch.is_filtered() == false && ch.in_range == false) ch.setFiltered(true);
+				if (ch.is_filtered() == false && ch.in_range == false)
+					ch.setFiltered(true);
 			}
-		}catch(FileNotFoundException fnex){
+		} catch (FileNotFoundException fnex) {
 			(new MessageBox("Error", "File not found", FormBase.OKB)).execute();
-		}catch(IOException ioex){
+		} catch (IOException ioex) {
 			(new MessageBox("Error", "Problem reading file!", FormBase.OKB)).execute();
 		}
 	}
-	
+
 	/**
-	*	Method to calculate the distance of a point to a segment
-	*/
-	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp){
+	 * Method to calculate the distance of a point to a segment
+	 */
+	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp) {
 		double dist = 0;
 		double px = cwp.lonDec * pi180;
 		double py = cwp.latDec * pi180;
@@ -201,91 +204,114 @@
 		double Y2 = toPoint.latDec * pi180;
 		double dx = X2 - X1;
 		double dy = Y2 - Y1;
-		if(dx == 0 && dy == 0){
+		if (dx == 0 && dy == 0) {
 			// have a point and not a segment!
 			dx = px - X1;
 			dy = py - Y1;
-			return java.lang.Math.sqrt(dx*dx + dy*dy);
+			return java.lang.Math.sqrt(dx * dx + dy * dy);
 		}
-		dist = Matrix.cross(X1,Y1,X2,Y2,px,py) / Matrix.dist(X1,Y1,X2,Y2);
-		double dot1 = Matrix.dot(X1,Y1,X2,Y2,px,py);
-		if(dot1 > 0) return Matrix.dist(X2,Y2,px,py);
-		double dot2 = Matrix.dot(X2,Y2,X1,Y1,px,py);
-		if(dot2 > 0) return Matrix.dist(X1,Y1,px,py);
+		dist = Matrix.cross(X1, Y1, X2, Y2, px, py) / Matrix.dist(X1, Y1, X2, Y2);
+		double dot1 = Matrix.dot(X1, Y1, X2, Y2, px, py);
+		if (dot1 > 0)
+			return Matrix.dist(X2, Y2, px, py);
+		double dot2 = Matrix.dot(X2, Y2, X1, Y1, px, py);
+		if (dot2 > 0)
+			return Matrix.dist(X1, Y1, px, py);
 		dist = java.lang.Math.abs(dist);
 		return dist;
-		
+
 	}
-	
+
 	/**
 	 * Set the filter from the filter data stored in the profile
 	 * (the filterscreen also updates the profile)
 	 */
 	public void setFilter() {
-		Profile profile=Global.getProfile();
-		archived     = profile.getFilterVar().charAt(0) == '1';
-		available    = profile.getFilterVar().charAt(1) == '1';
-		foundByMe    = profile.getFilterVar().charAt(2) == '1';
-		ownedByMe    = profile.getFilterVar().charAt(3) == '1';
-		notArchived  = profile.getFilterVar().charAt(4) == '1';
+		Profile profile = Global.getProfile();
+		archived = profile.getFilterVar().charAt(0) == '1';
+		available = profile.getFilterVar().charAt(1) == '1';
+		foundByMe = profile.getFilterVar().charAt(2) == '1';
+		ownedByMe = profile.getFilterVar().charAt(3) == '1';
+		notArchived = profile.getFilterVar().charAt(4) == '1';
 		notAvailable = profile.getFilterVar().charAt(5) == '1';
 		notFoundByMe = profile.getFilterVar().charAt(6) == '1';
 		notOwnedByMe = profile.getFilterVar().charAt(7) == '1';
-		cacheStatus  = profile.getFilterStatus();
-		useRegexp    = profile.getFilterUseRegexp();
+		cacheStatus = profile.getFilterStatus();
+		useRegexp = profile.getFilterUseRegexp();
 		filterNoCoord = profile.getFilterNoCoord();
-		
-		typeMatchPattern=CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
-		hasTypeMatchPattern=CacheType.hasTypeMatchPattern(typeMatchPattern);
-		roseMatchPattern=0;
-		String filterRose=profile.getFilterRose();
-		if (filterRose.charAt(0) == '1') roseMatchPattern|=NW;
-		if (filterRose.charAt(1) == '1') roseMatchPattern|=NNW;
-		if (filterRose.charAt(2) == '1') roseMatchPattern|=N;
-		if (filterRose.charAt(3) == '1') roseMatchPattern|=NNE;
-		if (filterRose.charAt(4) == '1') roseMatchPattern|=NE;
-		if (filterRose.charAt(5) == '1') roseMatchPattern|=ENE;
-		if (filterRose.charAt(6) == '1') roseMatchPattern|=E;
-		if (filterRose.charAt(7) == '1') roseMatchPattern|=ESE;
-		if (filterRose.charAt(8) == '1') roseMatchPattern|=SE;
-		if (filterRose.charAt(9) == '1') roseMatchPattern|=SSE;
-		if (filterRose.charAt(10) == '1') roseMatchPattern|=S;
-		if (filterRose.charAt(11) == '1') roseMatchPattern|=SSW;
-		if (filterRose.charAt(12) == '1') roseMatchPattern|=SW;
-		if (filterRose.charAt(13) == '1') roseMatchPattern|=WSW;
-		if (filterRose.charAt(14) == '1') roseMatchPattern|=W;
-		if (filterRose.charAt(15) == '1') roseMatchPattern|=WNW;
-		hasRoseMatchPattern=roseMatchPattern!=ROSE_ALL;
-		sizeMatchPattern=0;
-		String filterSize=profile.getFilterSize();
-		if (filterSize.charAt(0) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_MICRO;
-		if (filterSize.charAt(1) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_SMALL;
-		if (filterSize.charAt(2) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NORMAL;
-		if (filterSize.charAt(3) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_LARGE;
-		if (filterSize.charAt(4) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_VERYLARGE;
-		if (filterSize.charAt(5) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NONPHYSICAL;
-		hasSizeMatchPattern=sizeMatchPattern!=CacheSize.CW_FILTER_ALL;
-		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER; 
-		fscDist = Common.parseDouble(profile.getFilterDist().substring(1));  // Distance
-		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : 
-					(profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER );
-		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1));  // Difficulty
-		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : 
-				(profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER );
-		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1));  // Terrain
+
+		typeMatchPattern = CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
+		hasTypeMatchPattern = CacheType.hasTypeMatchPattern(typeMatchPattern);
+		roseMatchPattern = 0;
+		String filterRose = profile.getFilterRose();
+		if (filterRose.charAt(0) == '1')
+			roseMatchPattern |= NW;
+		if (filterRose.charAt(1) == '1')
+			roseMatchPattern |= NNW;
+		if (filterRose.charAt(2) == '1')
+			roseMatchPattern |= N;
+		if (filterRose.charAt(3) == '1')
+			roseMatchPattern |= NNE;
+		if (filterRose.charAt(4) == '1')
+			roseMatchPattern |= NE;
+		if (filterRose.charAt(5) == '1')
+			roseMatchPattern |= ENE;
+		if (filterRose.charAt(6) == '1')
+			roseMatchPattern |= E;
+		if (filterRose.charAt(7) == '1')
+			roseMatchPattern |= ESE;
+		if (filterRose.charAt(8) == '1')
+			roseMatchPattern |= SE;
+		if (filterRose.charAt(9) == '1')
+			roseMatchPattern |= SSE;
+		if (filterRose.charAt(10) == '1')
+			roseMatchPattern |= S;
+		if (filterRose.charAt(11) == '1')
+			roseMatchPattern |= SSW;
+		if (filterRose.charAt(12) == '1')
+			roseMatchPattern |= SW;
+		if (filterRose.charAt(13) == '1')
+			roseMatchPattern |= WSW;
+		if (filterRose.charAt(14) == '1')
+			roseMatchPattern |= W;
+		if (filterRose.charAt(15) == '1')
+			roseMatchPattern |= WNW;
+		hasRoseMatchPattern = roseMatchPattern != ROSE_ALL;
+		sizeMatchPattern = 0;
+		String filterSize = profile.getFilterSize();
+		if (filterSize.charAt(0) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_MICRO;
+		if (filterSize.charAt(1) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_SMALL;
+		if (filterSize.charAt(2) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NORMAL;
+		if (filterSize.charAt(3) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_LARGE;
+		if (filterSize.charAt(4) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_VERYLARGE;
+		if (filterSize.charAt(5) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NONPHYSICAL;
+		hasSizeMatchPattern = sizeMatchPattern != CacheSize.CW_FILTER_ALL;
+		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER;
+		fscDist = Common.parseDouble(profile.getFilterDist().substring(1)); // Distance
+		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : (profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER);
+		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1)); // Difficulty
+		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : (profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER);
+		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1)); // Terrain
 		attributesPattern = profile.getFilterAttr();
 		attributesChoice = profile.getFilterAttrChoice();
 	}
-	
+
 	/**
-	*	Apply the filter. Caches that match a criteria are flagged
-	*	is_filtered = true. The table model is responsible for displaying or
-	*	not displaying a cache that is filtered.
-	*/
-	public void doFilter(){
-		CacheDB cacheDB=Global.getProfile().cacheDB;
+	 * Apply the filter. Caches that match a criteria are flagged
+	 * is_filtered = true. The table model is responsible for displaying or
+	 * not displaying a cache that is filtered.
+	 */
+	public void doFilter() {
+		CacheDB cacheDB = Global.getProfile().cacheDB;
 		Hashtable examinedCaches;
-		if (cacheDB.size()==0) return;
+		if (cacheDB.size() == 0)
+			return;
 		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
 			clearFilter();
 			return;
@@ -293,13 +319,14 @@
 		Global.getProfile().selectionChanged = true;
 		CacheHolder ch;
 		examinedCaches = new Hashtable(cacheDB.size());
-		
-		for(int i = cacheDB.size()-1; i >=0 ; i--){
+
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
-			if (examinedCaches.containsKey(ch)) continue;
-			
+			if (examinedCaches.containsKey(ch))
+				continue;
+
 			boolean filterCache = excludedByFilter(ch);
-			if (!filterCache && ch.mainCache!=null && CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
+			if (!filterCache && ch.mainCache != null && CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
 				if (examinedCaches.containsKey(ch.mainCache)) {
 					filterCache = ch.mainCache.is_filtered();
 				} else {
@@ -308,270 +335,261 @@
 					examinedCaches.put(ch.mainCache, null);
 				}
 			}
-			ch.setFiltered(filterCache);			
+			ch.setFiltered(filterCache);
 		}
 		Global.getProfile().setFilterActive(FILTER_ACTIVE);
 		examinedCaches = null;
-		//Global.getProfile().hasUnsavedChanges=true;
+		// Global.getProfile().hasUnsavedChanges=true;
 	}
 
 	public boolean excludedByFilter(CacheHolder ch) {
-		//Match once against type pattern and once against rose pattern
-		//Default is_filtered = false, means will be displayed!
-		//If cache does not match type or rose pattern then is_filtered is set to true
+		// Match once against type pattern and once against rose pattern
+		// Default is_filtered = false, means will be displayed!
+		// If cache does not match type or rose pattern then is_filtered is set to true
 		// and we proceed to next cache (no further tests needed)
-		//Then we check the other filter criteria one by one: As soon as one is found that
+		// Then we check the other filter criteria one by one: As soon as one is found that
 		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
 		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
-	    int cacheTypePattern;
-	    int cacheRosePattern;
-	    int cacheSizePattern;
-	    double dummyd1;
-	    boolean cacheFiltered=false;
-	    do {
-	        ///////////////////////////////
-	        // Filter criterium 1: Cache type
-	        ///////////////////////////////
-	        if (hasTypeMatchPattern) { // Only do the checks if we have a filter
-	        	cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
-		        if ((cacheTypePattern & typeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 2: Bearing from centre
-	        ///////////////////////////////
-	        // The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
-	        // By using else if we can reduce the number of comparisons from 16 to just over 8
-	        // By first checking the first letter, we can reduce the average number further to
-	        // just under 5
-	        if (hasRoseMatchPattern) {
-		        if (ch.getBearing().startsWith("N")) {
-			        if (ch.getBearing().equals("NW"))
-				        cacheRosePattern = NW;
-			        else if (ch.getBearing().equals("NNW"))
-				        cacheRosePattern = NNW;
-			        else if (ch.getBearing().equals("N"))
-				        cacheRosePattern = N;
-			        else if (ch.getBearing().equals("NNE"))
-				        cacheRosePattern = NNE;
-			        else
-				        cacheRosePattern = NE;
-		        } else if (ch.getBearing().startsWith("E")) {
-			        if (ch.getBearing().equals("ENE"))
-				        cacheRosePattern = ENE;
-			        else if (ch.getBearing().equals("E"))
-				        cacheRosePattern = E;
-			        else
-				        cacheRosePattern = ESE;
-		        } else if (ch.getBearing().startsWith("S")) {
-			        if (ch.getBearing().equals("SW"))
-				        cacheRosePattern = SW;
-			        else if (ch.getBearing().equals("SSW"))
-				        cacheRosePattern = SSW;
-			        else if (ch.getBearing().equals("S"))
-				        cacheRosePattern = S;
-			        else if (ch.getBearing().equals("SSE"))
-				        cacheRosePattern = SSE;
-			        else
-				        cacheRosePattern = SE;
-		        } else {
-			        if (ch.getBearing().equals("WNW"))
-				        cacheRosePattern = WNW;
-			        else if (ch.getBearing().equals("W"))
-				        cacheRosePattern = W;
-			        else if (ch.getBearing().equals("WSW"))
-				        cacheRosePattern = WSW;
-			        else
-				        cacheRosePattern = 0;
-		        }
-		        if ((cacheRosePattern != 0) && ((cacheRosePattern & roseMatchPattern) == 0)) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 3: Distance
-	        ///////////////////////////////
-	        if (fscDist > 0.0) {
-		        dummyd1 = ch.kilom;
-		        if (distdirec == SMALLER && dummyd1 > fscDist) {
-			        cacheFiltered = true; break;
-		        }
-		        if (distdirec == GREATER && dummyd1 < fscDist) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 4: Difficulty
-	        ///////////////////////////////
-	        if (fscDiff > 0.0) {
-		        dummyd1 = ch.getHard() / 10D;
-		        if (diffdirec == SMALLER && dummyd1 > fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == EQUAL && dummyd1 != fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == GREATER && dummyd1 < fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 5: Terrain
-	        ///////////////////////////////
-	        if (fscTerr > 0.0) {
-	        	dummyd1 = ch.getTerrain() / 10D;
-		        if (terrdirec == SMALLER && dummyd1 > fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == EQUAL && dummyd1 != fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == GREATER && dummyd1 < fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-	        }
+		int cacheTypePattern;
+		int cacheRosePattern;
+		int cacheSizePattern;
+		double dummyd1;
+		boolean cacheFiltered = false;
+		do {
+			// /////////////////////////////
+			// Filter criterium 1: Cache type
+			// /////////////////////////////
+			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
+				cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
+				if ((cacheTypePattern & typeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 2: Bearing from centre
+			// /////////////////////////////
+			// The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
+			// By using else if we can reduce the number of comparisons from 16 to just over 8
+			// By first checking the first letter, we can reduce the average number further to
+			// just under 5
+			if (hasRoseMatchPattern) {
+				if (ch.getBearing().startsWith("N")) {
+					if (ch.getBearing().equals("NW"))
+						cacheRosePattern = NW;
+					else if (ch.getBearing().equals("NNW"))
+						cacheRosePattern = NNW;
+					else if (ch.getBearing().equals("N"))
+						cacheRosePattern = N;
+					else if (ch.getBearing().equals("NNE"))
+						cacheRosePattern = NNE;
+					else
+						cacheRosePattern = NE;
+				} else if (ch.getBearing().startsWith("E")) {
+					if (ch.getBearing().equals("ENE"))
+						cacheRosePattern = ENE;
+					else if (ch.getBearing().equals("E"))
+						cacheRosePattern = E;
+					else
+						cacheRosePattern = ESE;
+				} else if (ch.getBearing().startsWith("S")) {
+					if (ch.getBearing().equals("SW"))
+						cacheRosePattern = SW;
+					else if (ch.getBearing().equals("SSW"))
+						cacheRosePattern = SSW;
+					else if (ch.getBearing().equals("S"))
+						cacheRosePattern = S;
+					else if (ch.getBearing().equals("SSE"))
+						cacheRosePattern = SSE;
+					else
+						cacheRosePattern = SE;
+				} else {
+					if (ch.getBearing().equals("WNW"))
+						cacheRosePattern = WNW;
+					else if (ch.getBearing().equals("W"))
+						cacheRosePattern = W;
+					else if (ch.getBearing().equals("WSW"))
+						cacheRosePattern = WSW;
+					else
+						cacheRosePattern = 0;
+				}
+				if ((cacheRosePattern != 0) && ((cacheRosePattern & roseMatchPattern) == 0)) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 3: Distance
+			// /////////////////////////////
+			if (fscDist > 0.0) {
+				dummyd1 = ch.kilom;
+				if (distdirec == SMALLER && dummyd1 > fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+				if (distdirec == GREATER && dummyd1 < fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 4: Difficulty
+			// /////////////////////////////
+			if (fscDiff > 0.0) {
+				dummyd1 = ch.getHard() / 10D;
+				if (diffdirec == SMALLER && dummyd1 > fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == EQUAL && dummyd1 != fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == GREATER && dummyd1 < fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 5: Terrain
+			// /////////////////////////////
+			if (fscTerr > 0.0) {
+				dummyd1 = ch.getTerrain() / 10D;
+				if (terrdirec == SMALLER && dummyd1 > fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == EQUAL && dummyd1 != fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == GREATER && dummyd1 < fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+			}
 
-	        ///////////////////////////////
-	        // Filter criterium 6: Found by me
-	        ///////////////////////////////
-	        if ((ch.is_found() && !foundByMe) || (!ch.is_found() && !notFoundByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 7: Owned by me
-	        ///////////////////////////////
-	        if ((ch.is_owned() && !ownedByMe) || (!ch.is_owned() && !notOwnedByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 8: Archived
-	        ///////////////////////////////
-	        if ((ch.is_archived() && !archived) || (!ch.is_archived() && !notArchived)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 9: Unavailable
-	        ///////////////////////////////
-	        if ((ch.is_available() && !available) || (!ch.is_available() && !notAvailable)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 10: Size
-	        ///////////////////////////////
-	        if (hasSizeMatchPattern) {
-		        cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
-		        if ((cacheSizePattern & sizeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: Attributes
-	        ///////////////////////////////
-	        if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) 
-	        		&& ch.mainCache == null) {
-	        	long[] chAtts=ch.getAttributesBits();
-		        if (attributesChoice == 0) {
-			        // AND-condition:
-			        if ((chAtts[0] & attributesPattern[0]) != attributesPattern[0] ||
-				        	(chAtts[1] & attributesPattern[1]) != attributesPattern[1] ||
-				        	(chAtts[2] & attributesPattern[2]) != attributesPattern[2] ||
-				        	(chAtts[3] & attributesPattern[3]) != attributesPattern[3] )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else if (attributesChoice == 1) {
-			        // OR-condition:
-			        if ((chAtts[0] & attributesPattern[0]) == 0 ||
-				        	(chAtts[1] & attributesPattern[1]) == 0 ||
-				        	(chAtts[2] & attributesPattern[2]) == 0 ||
-				        	(chAtts[3] & attributesPattern[3]) == 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else {
-			        // NOT-condition:
-			        if ((chAtts[0] & attributesPattern[0]) != 0 ||
-				        	(chAtts[1] & attributesPattern[1]) != 0 ||
-				        	(chAtts[2] & attributesPattern[2]) != 0 ||
-				        	(chAtts[3] & attributesPattern[3]) != 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 12: Status
-	        ///////////////////////////////
-	        if (!cacheStatus.equals("")) {
-	        	if (!useRegexp) {
-	        		if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase())<0) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	} else {
-	        		Regex rex=new Regex(cacheStatus.toLowerCase());
-	        		rex.search(ch.getStatusText().toLowerCase());
-	        		if (rex.stringMatched()==null) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	}
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: NoCoord
-	        ///////////////////////////////
-	        if (!filterNoCoord && !ch.pos.isValid()) {
-	          cacheFiltered = true;
-	        	break;
-        }
+			// /////////////////////////////
+			// Filter criterium 6: Found by me
+			// /////////////////////////////
+			if ((ch.is_found() && !foundByMe) || (!ch.is_found() && !notFoundByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 7: Owned by me
+			// /////////////////////////////
+			if ((ch.is_owned() && !ownedByMe) || (!ch.is_owned() && !notOwnedByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 8: Archived
+			// /////////////////////////////
+			if ((ch.is_archived() && !archived) || (!ch.is_archived() && !notArchived)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 9: Unavailable
+			// /////////////////////////////
+			if ((ch.is_available() && !available) || (!ch.is_available() && !notAvailable)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 10: Size
+			// /////////////////////////////
+			if (hasSizeMatchPattern) {
+				cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
+				if ((cacheSizePattern & sizeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: Attributes
+			// /////////////////////////////
+			if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) && ch.mainCache == null) {
+				long[] chAtts = ch.getAttributesBits();
+				if (attributesChoice == 0) {
+					// AND-condition:
+					if ((chAtts[0] & attributesPattern[0]) != attributesPattern[0] || (chAtts[1] & attributesPattern[1]) != attributesPattern[1] || (chAtts[2] & attributesPattern[2]) != attributesPattern[2]
+							|| (chAtts[3] & attributesPattern[3]) != attributesPattern[3]) {
+						cacheFiltered = true;
+						break;
+					}
+				} else if (attributesChoice == 1) {
+					// OR-condition:
+					if ((chAtts[0] & attributesPattern[0]) == 0 && (chAtts[1] & attributesPattern[1]) == 0 && (chAtts[2] & attributesPattern[2]) == 0 && (chAtts[3] & attributesPattern[3]) == 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					// NOT-condition:
+					if ((chAtts[0] & attributesPattern[0]) != 0 || (chAtts[1] & attributesPattern[1]) != 0 || (chAtts[2] & attributesPattern[2]) != 0 || (chAtts[3] & attributesPattern[3]) != 0) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 12: Status
+			// /////////////////////////////
+			if (!cacheStatus.equals("")) {
+				if (!useRegexp) {
+					if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase()) < 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					Regex rex = new Regex(cacheStatus.toLowerCase());
+					rex.search(ch.getStatusText().toLowerCase());
+					if (rex.stringMatched() == null) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: NoCoord
+			// /////////////////////////////
+			if (!filterNoCoord && !ch.getPos().isValid()) {
+				cacheFiltered = true;
+				break;
+			}
 
-	        break;
-        } while (true);
+			break;
+		} while (true);
 		return cacheFiltered;
-    }
-	
+	}
+
 	/**
-	*	Switches flag to invert filter property.
-	*/
-	public void invertFilter(){
+	 * Switches flag to invert filter property.
+	 */
+	public void invertFilter() {
 		Global.getProfile().setFilterInverted(!Global.getProfile().isFilterInverted());
 	}
-	
+
 	/**
-	*	Clear the is_filtered flag from the cache database.
-	*/
-	public void clearFilter(){
+	 * Clear the is_filtered flag from the cache database.
+	 */
+	public void clearFilter() {
 		Global.getProfile().selectionChanged = true;
-		CacheDB cacheDB=Global.getProfile().cacheDB;
-		for(int i = cacheDB.size()-1; i >=0 ; i--){
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			CacheHolder ch = cacheDB.get(i);
 			ch.setFiltered(false);
 		}
 		Global.getProfile().setFilterActive(FILTER_INACTIVE);
 	}
 
-		public boolean hasFilter() {
-		Profile prof=Global.getProfile();
-		long[] attribs=prof.getFilterAttr();
-		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) &&
-		    prof.getFilterRose().equals(FilterData.FILTERROSE) &&
-		    prof.getFilterVar().equals(FilterData.FILTERVAR) &&
-		    prof.getFilterSize().equals(FilterData.FILTERSIZE) &&
-		    prof.getFilterDist().equals("L") &&
-		    prof.getFilterDiff().equals("L") &&
-		    prof.getFilterTerr().equals("L") &&
-		    attribs[0] == 0l &&
-		    attribs[1] == 0l &&
-		    attribs[2] == 0l &&
-		    attribs[3] == 0l &&
-		    prof.getFilterStatus().equals("") &&
-        prof.getFilterNoCoord());
+	public boolean hasFilter() {
+		Profile prof = Global.getProfile();
+		long[] attribs = prof.getFilterAttr();
+		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) && prof.getFilterRose().equals(FilterData.FILTERROSE) && prof.getFilterVar().equals(FilterData.FILTERVAR) && prof.getFilterSize().equals(FilterData.FILTERSIZE)
+				&& prof.getFilterDist().equals("L") && prof.getFilterDiff().equals("L") && prof.getFilterTerr().equals("L") && attribs[0] == 0l && attribs[1] == 0l && attribs[2] == 0l && attribs[3] == 0l && prof.getFilterStatus().equals("") && prof
+					.getFilterNoCoord());
 	}
 
 }
-
-

Modified: branches/r1.2/src/CacheWolf/GeoCodeGui.java
===================================================================
--- branches/r1.2/src/CacheWolf/GeoCodeGui.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/GeoCodeGui.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -25,10 +25,7 @@
     */
 package CacheWolf;
 
-import ewe.io.IOException;
-import ewe.sys.Handle;
-import ewe.sys.HandleStoppedException;
-import ewe.sys.mThread;
+import ewe.sys.Vm;
 import ewe.ui.CellConstants;
 import ewe.ui.CellPanel;
 import ewe.ui.ControlEvent;
@@ -40,8 +37,8 @@
 import ewe.ui.mButton;
 import ewe.ui.mInput;
 import ewe.ui.mLabel;
+import ewe.ui.mList;
 import ewe.util.Vector;
-import ewesoft.xml.sax.SAXException;
 
 /**
  * Class for entering an address and convert it to lat/lon
@@ -55,12 +52,12 @@
 	CWPoint coordInp = new CWPoint();
 	CellPanel topLinePanel = new CellPanel();
 	CellPanel mainPanel = new CellPanel();
-	HtmlDisplay foundTxt;
+	// HtmlDisplay foundTxt;
+	mList choice;
 	int exitKeys[]={75009};
 
 	Vector geoCodeAnsw;
 	String searchText;
-	Handle[] fetchHandle = new Handle[1];
 
 	public GeoCodeGui()
 	{
@@ -76,10 +73,9 @@
 		this.addLast(topLinePanel,CellConstants.STRETCH, CellConstants.FILL | CellConstants.WEST);
 
 		// Description of found sites
-		foundTxt     = new HtmlDisplay();
-		foundTxt.setPreferredSize(200, 200);
-		ScrollBarPanel sbp = new MyScrollBarPanel(foundTxt, 0);
-		sbp.setClientConstraints(ScrollBarPanel.HCONTRACT|ScrollBarPanel.HCONTRACT);
+		choice=new mList(8,50,false);
+		ScrollBarPanel sbp = new MyScrollBarPanel(choice, 0);
+		sbp.setOptions(MyScrollBarPanel.NeverShowVerticalScrollers);
 		mainPanel.addLast(sbp, CellConstants.STRETCH, CellConstants.FILL | CellConstants.WEST);
 
 		// Buttons for cancel and apply
@@ -95,60 +91,29 @@
 
 	public void onEvent(Event ev){
 
-		// Ensure that the Enter key moves to the appropriate field
-		// for Checkboxes and Choice controls this is done via the exitKeys
-		// For input fields we use the wantReturn field
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == searchBtn ){
-				foundTxt.setHtml(MyLocale.getMsg(7306, "searching..."));
-				// only insert "," if city AND street is set
-				searchText = streetInp.text.trim();
-				if (searchText.length() > 0) {
-					if (cityInp.text.trim().length() > 0) searchText = searchText + ","+cityInp.text;
-				} else searchText = cityInp.text;
-
-				mThread thrdfetch = 
-					new mThread() {
-					public void run() {
-						try {
-							fetchHandle[0] = null;
-							geoCodeAnsw = GeocoderOsm.geocode(searchText, fetchHandle);
-						} catch (IOException e) {
-							geoCodeAnsw = new Vector();
-							geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), "IOExecption"));
-						} catch (SAXException e) {
-							geoCodeAnsw = new Vector();
-							geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), "SAXException"));
-						} catch (HandleStoppedException ie) {
-							geoCodeAnsw = new Vector();
-							if (fetchHandle[0].stopReason == 4321)
-								geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7307, "Canceled by user")));
-							else geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7308, "Could not connect")));
-						} catch (InterruptedException ie) {
-							geoCodeAnsw = new Vector();
-							if (fetchHandle[0].stopReason == 4321)
-								geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7307, "Canceled by user")));
-							else geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7308, "Could not connect")));
-
-						}
-						// foundTxt.startHtml();
-						if (geoCodeAnsw.size() == 0) foundTxt.setHtml("nothing found");
-						else {
-							GeocodeAnswer ga = (GeocodeAnswer)geoCodeAnsw.get(0);
-							foundTxt.setHtml(ga.where.toString() + "<br>" + ga.foundname);
-						}
-						fetchHandle[0] = null;
-					}
-				};
-				thrdfetch.start();
+		        Vm.showWait(true);
+				try {
+					geoCodeAnsw = GeocoderOsm.geocode(cityInp.text.trim(), streetInp.text.trim());
+				} catch (Exception e) {
+					geoCodeAnsw = new Vector();
+					geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), e.getMessage()));
+				}
+		        Vm.showWait(false);
+				if (geoCodeAnsw.size() == 0) {
+					geoCodeAnsw = new Vector();
+					geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), "nothing found"));
+				}
+				choice.items.clear();
+				for (int i = 0; i < geoCodeAnsw.size(); i++) {
+					GeocodeAnswer ga = (GeocodeAnswer)geoCodeAnsw.get(i);
+					choice.addItem(ga.where.toString() + " | " + ga.foundname);
+				}
+				choice.updateItems();
 			}
 
 			if (ev.target == searchCancelBtn){
-				if (fetchHandle != null && fetchHandle[0] != null)
-				{
-					fetchHandle[0].stop(4321);
-					fetchHandle[0].set(Handle.Stopped);
-				}
 			}
 
 			if (ev.target == btnCancel){
@@ -156,8 +121,10 @@
 			}
 
 			if (ev.target == btnOk){
-				if (geoCodeAnsw != null && geoCodeAnsw.size() > 0)
-				coordInp = ((GeocodeAnswer)geoCodeAnsw.get(0)).where;
+				if (geoCodeAnsw != null && geoCodeAnsw.size() > 0) {
+					int i = choice.selectedIndex;
+					coordInp = ((GeocodeAnswer)geoCodeAnsw.get(i)).where;					
+				}
 				else coordInp.makeInvalid();
 				this.close(IDOK);
 			}

Modified: branches/r1.2/src/CacheWolf/GeocoderOsm.java
===================================================================
--- branches/r1.2/src/CacheWolf/GeocoderOsm.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/GeocoderOsm.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -25,10 +25,14 @@
     */
 package CacheWolf;
 
+import CacheWolf.utils.FileBugfix;
 import ewe.io.ByteArrayInputStream;
+import ewe.io.File;
+import ewe.io.FileInputStream;
 import ewe.io.IO;
 import ewe.io.IOException;
 import ewe.io.InputStreamReader;
+import ewe.io.StringStream;
 import ewe.sys.Handle;
 import ewe.sys.HandleStoppedException;
 import ewe.util.ByteArray;
@@ -39,35 +43,46 @@
 
 public class GeocoderOsm {
 
-	private static final String geocoderUrl = "http://gazetteer.openstreetmap.org/namefinder/search.xml?max=1&find=";  
+	//private static final String geocoderUrl = "http://gazetteer.openstreetmap.org/namefinder/search.xml?max=1&find=";
+	private static final String geocoderUrl = "http://nominatim.openstreetmap.org/search?"; //q=135+pilkington+avenue,+birmingham&format=xml&polygon=1&addressdetails=1
 
-	public static Vector geocode(String address, Handle[] h) 
-	throws SAXException, IOException, HandleStoppedException, InterruptedException {
-		ByteArray answ = UrlFetcher.fetchByteArray((geocoderUrl+UrlFetcher.toUtf8Url(address)), null, h);
+	public static Vector geocode(String city, String street) throws Exception 
+	{
+		String searchFor;
+		if (street.equals("")) {
+			searchFor=UrlFetcher.toUtf8Url(city);
+		}
+		else {
+			searchFor=UrlFetcher.toUtf8Url(street) + "+" + UrlFetcher.toUtf8Url(city);
+		}
+		String answer = UrlFetcher.fetch(geocoderUrl + "q=" + searchFor + "&format=xml");
+		answer=STRreplace.replace(answer,"\'","\' ");
+		answer=STRreplace.replace(answer,"  "," ");
 		XMLDecoder xmldec = new XMLDecoder();
-		xmldec.parse(new InputStreamReader(new ByteArrayInputStream(answ), IO.JAVA_UTF8_CODEC));
 		Vector erg = new Vector();
-		if ( "searchresults".equalsIgnoreCase((String)xmldec.document.tag) ) {
-			XMLElement xe, xe2;
-			String desc, lat, lon;
-			desc = null;
-			CWPoint where = new CWPoint();
-			if (xmldec.document != null && xmldec.document.subElements != null) {
-				for (int i=0;  i < xmldec.document.subElements.size(); i++) {
-					xe = (XMLElement) xmldec.document.subElements.elementAt(i);
-					if (xe.tag.equalsIgnoreCase("named")) {
-						lat = (String) xe.attributes.getPropertyValues("lat").get(0);
-						lon = (String) xe.attributes.getPropertyValues("lon").get(0);
-						where.set(Common.parseDouble(lat), Common.parseDouble(lon));
-						for (int j = 0; j < xe.subElements.size(); j++) {
-							xe2 = (XMLElement) xe.subElements.elementAt(j);
-							if ( xe2.tag.equalsIgnoreCase("description")) { desc = xe2.text; break; }  
+		try {
+			xmldec.parse(new InputStreamReader(new StringStream(answer)));
+			if ( "searchresults".equalsIgnoreCase((String)xmldec.document.tag) ) {
+				XMLElement xe;
+				String desc, lat, lon;
+				desc = null;
+				CWPoint where = new CWPoint();
+				if (xmldec.document != null && xmldec.document.subElements != null) {
+					for (int i=0;  i < xmldec.document.subElements.size(); i++) {
+						xe = (XMLElement) xmldec.document.subElements.elementAt(i);
+						if (xe.tag.equalsIgnoreCase("place")) {
+							lat = (String) xe.attributes.getPropertyValues("lat").get(0);
+							lon = (String) xe.attributes.getPropertyValues("lon").get(0);
+							where.set(Common.parseDouble(lat.trim()), Common.parseDouble(lon.trim()));
+							desc = (String) xe.attributes.getPropertyValues("display_name").get(0);
+							erg.add(new GeocodeAnswer(where, desc));
 						}
-						erg.add(new GeocodeAnswer(where, desc));
 					}
 				}
 			}
-		}
+		} catch (Exception e) {
+			throw new Exception(e.getMessage());
+		}	
 		return erg;
 	}
 

Modified: branches/r1.2/src/CacheWolf/GuiImageBroker.java
===================================================================
--- branches/r1.2/src/CacheWolf/GuiImageBroker.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/GuiImageBroker.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -31,38 +31,23 @@
 
 /**
  * hold preloaded versions of GUI images in a single place
- *
+ * 
  * Do not instantiate this class, only use it in a static way.
  */
 
 public final class GuiImageBroker {
+	public static Image found = new Image("found.png");
+	public static Image disabled = new Image("disabled.png"); // available
+	public static Image archived = new Image("archived.png");
+	public static Image solved = new Image("solved.png");
+	public static Image bonus = new Image("bonus.png");
+	public static Image owned = new Image("owned.png");
+	public static Image dnf = new Image("dnf.png");
 
-	// TODO: check with Image and mImage
-
-	/** image to be displayed in case of error */
-	public static Image imageError = new Image("guiError.png");
-
-	/**
-	 * images to be displayed for cache types in GUI
-	 * @see getTypeImage
-	 * @see CacheTypes
-	 */
-
-	/** thou shallst not instantiate this object */
 	private GuiImageBroker() {
 		// Noting to do
 	}
 
-	public static Image getTypeImage(byte typeId,boolean map) {
-		if (!map) {
-			return CacheType.getTypeImage(typeId);
-		}
-		else {
-			return CacheType.getMapImage(typeId);
-		}
-	}
-
-
 	/**
 	 * Replaces the build-in symbols by images stored in /symbols:
 	 * If the sub directory symbols exists in CW-directory *.png-files
@@ -73,35 +58,56 @@
 	 * Images are NOT checked for size etc.
 	 */
 	public static void customizedSymbols() {
-		final String sdir="/symbols/";
-		final FileBugfix dir=new FileBugfix(FileBase.getProgramDirectory()+sdir);
-		if (dir.isDirectory()){
+		final String sdir = "/symbols/";
+		final FileBugfix dir = new FileBugfix(FileBase.getProgramDirectory() + sdir);
+		if (dir.isDirectory()) {
 			int id;
-			boolean size=false;
+			boolean size = false;
 			String name = "";
-			String [] pngFiles;
-			pngFiles=dir.list("*.png",0);
-			Global.getPref().log("Nr. of own symbols (png-files) : "+pngFiles.length);
-			for (int i=0; i<pngFiles.length; i++) {
-				name = pngFiles[i].substring(0,pngFiles[i].length()-4);
-				if (name.toLowerCase().endsWith("size")){
-					size=true;
-					name=name.substring(0,name.length()-4);
+			String[] pngFiles;
+			pngFiles = dir.list("*.png", FileBase.LIST_FILES_ONLY);
+			Global.getPref().log("Nr. of own symbols (png-files) : " + pngFiles.length);
+			for (int i = 0; i < pngFiles.length; i++) {
+				name = pngFiles[i].substring(0, pngFiles[i].length() - 4).toLowerCase();
+				if (name.endsWith("size")) {
+					size = true;
+					name = name.substring(0, name.length() - 4);
+				} else {
+					if (name.equals("disabled")) {
+						disabled = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("archived")) {
+						archived = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("solved")) {
+						solved = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("bonus")) {
+						bonus = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("owned")) {
+						owned = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("dnf")) {
+						dnf = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("found")) {
+						found = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
 				}
 				try {
 					id = Integer.parseInt(name);
+				} catch (final Exception E) {
+					id = -1; // filename invalid for symbols
 				}
-				catch (Exception E){
-					id = -1; //filename invalid for symbols
-				}
-				if (0<=id && id<=CacheType.maxCWCType){
-					String s=FileBase.getProgramDirectory()+sdir+pngFiles[i];
-					Global.getPref().log("own symbol: "+(i+1)+" = "+pngFiles[i]);
-					if (size){
+				if (0 <= id && id <= CacheType.maxCWCType) {
+					final String s = FileBase.getProgramDirectory() + sdir + pngFiles[i];
+					Global.getPref().log("own symbol: " + (i + 1) + " = " + pngFiles[i]);
+					if (size) {
 						CacheType.setMapImage((byte) id, new Image(s));
-						size=false;
-					}
-					else{
+						size = false;
+
+					} else {
 						CacheType.setTypeImage((byte) id, new Image(s));
 					}
 				}

Modified: branches/r1.2/src/CacheWolf/HintLogPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/HintLogPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/HintLogPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -289,7 +289,7 @@
 			if (dx != 0 || dy != 0) scroll(dx,dy);
 			refresh();
 			return true;
-		}else if (true || where.x < origin.x || where.x >= origin.x+r.width || where.y < origin.y || where.y >= origin.y+r.height){
+		}else if (true/* || where.x < origin.x || where.x >= origin.x+r.width || where.y < origin.y || where.y >= origin.y+r.height*/){
 	 			if (autoScrolling) {
 					didAutoScroll = true;
 					scroll(-to.x,-to.y);

Modified: branches/r1.2/src/CacheWolf/HttpConnection.java
===================================================================
--- branches/r1.2/src/CacheWolf/HttpConnection.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/HttpConnection.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -257,6 +257,11 @@
 {
 	getRequestorProperties().set(name,property);
 }
+public void setRequestorProperty(PropertyList pl)
+//===================================================================
+{
+	getRequestorProperties().set(pl);
+}
 /**
  * Add a non-exclusive requestor property. These are sent to the web server after the initial request line.
  * @param name The name of the property.
@@ -347,6 +352,8 @@
 			}
 		}
 	}
+	getRequestorProperties().clear();
+	command = "GET";
 }
 
 //FIXME: never referenced

Modified: branches/r1.2/src/CacheWolf/ImagePanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/ImagePanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/ImagePanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.Color;
 import ewe.fx.Font;
@@ -45,105 +46,110 @@
 import ewe.ui.MessageBox;
 import ewe.ui.PenEvent;
 
-
 /**
-*	Class to display the cache and log images. It creates a thumbnail view and
-*	allows the user to click on an image that will then be displayed in its original size
-*	as long as the image fits the application size. If the application size is not sufficient
-*	then the image will be scaled to the available screen size.
-*   A right mouseclick on an image will open a dialogue to delete the file. 
-*/
-public class ImagePanel extends InteractivePanel{
+ * Class to display the cache and log images. It creates a thumbnail view and
+ * allows the user to click on an image that will then be displayed in its original size
+ * as long as the image fits the application size. If the application size is not sufficient
+ * then the image will be scaled to the available screen size.
+ * A right mouseclick on an image will open a dialogue to delete the file.
+ */
+public class ImagePanel extends InteractivePanel {
 	/** Picture to replace deleted pictures */
-	private final String NO_IMAGE="no_picture.png";
+	private final String NO_IMAGE = "no_picture.png";
 	/** Minimum time (msec) to recognise a long pen down event (=right mouse key) */
-	private final int LONG_PEN_DOWN_DURATION=500;
+	private final int LONG_PEN_DOWN_DURATION = 500;
 
 	Preferences pref;
 	Profile profile;
-	//private final int thumb_max_size = 300;
-	//private final int thumb_min_size = 100;
+	// private final int thumb_max_size = 300;
+	// private final int thumb_min_size = 100;
 	private final int padding = 20;
 	private int thumb_size = 0;
 	private int locX, locY, locCounter;
 	/** Start and duration of pen-pressed event to simulate right mouse key */
-	private long start, duration=0;
-	
+	private long start, duration = 0;
+
 	/**
-	* Constructor to create the image panel.<p>
-	*/
-	public ImagePanel(){ // Public constructor
+	 * Constructor to create the image panel.
+	 * <p>
+	 */
+	public ImagePanel() { // Public constructor
 	}
-	
-	static CacheHolderDetail oldCache=null;
+
+	static CacheHolderDetail oldCache = null;
+
 	/**
-	* Method to set the individual cache images.
-	* Gets called immediatly before panel is displayed
-	* @see MainTab#onEvent(Event ev)
-	*/
-	public void setImages(CacheHolderDetail cache){
-		if (cache!=oldCache) { 
+	 * Method to set the individual cache images.
+	 * Gets called immediatly before panel is displayed
+	 * 
+	 * @see MainTab#onEvent(Event ev)
+	 */
+	public void setImages(CacheHolderDetail cache) {
+		if (cache != oldCache) {
 			pref = Global.getPref();
-			profile=Global.getProfile();
+			profile = Global.getProfile();
 			Vm.showWait(true);
 			clearImages();
-			thumb_size = ((pref.myAppWidth-2*padding) / 3);
+			thumb_size = ((pref.myAppWidth - 2 * padding) / 3);
 			thumb_size = thumb_size - padding;
 			double rowCounter1 = 0;
-			if (cache.images.getDisplayImages(cache.getParent().getWayPoint()).size()>0) {
+			if (cache.images.getDisplayImages(cache.getParent().getWayPoint()).size() > 0) {
 				rowCounter1 = cache.images.getDisplayImages(cache.getParent().getWayPoint()).size();
-				rowCounter1 = java.lang.Math.ceil(rowCounter1/3);
+				rowCounter1 = java.lang.Math.ceil(rowCounter1 / 3);
 			}
 			double rowCounter2 = 0;
-			if (cache.userImages.size()>0){
+			if (cache.userImages.size() > 0) {
 				rowCounter2 = cache.userImages.size();
-				rowCounter2 = java.lang.Math.ceil(rowCounter2/3);
+				rowCounter2 = java.lang.Math.ceil(rowCounter2 / 3);
 			}
 			int rowCounter = (int) (rowCounter1 + rowCounter2);
-			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+padding);
+			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter * thumb_size + rowCounter * padding + padding);
 			this.virtualSize = r;
-			//this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
+			// this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
 			// this.checkScrolls();
 			// this.refresh();
-			locY=0;
-			addTitle(MyLocale.getMsg(340,"Cache Images:"));
+			locY = 0;
+			addTitle(MyLocale.getMsg(340, "Cache Images:"));
 			locY = 20;
 			locX = padding;
 			addImages(cache.images.getDisplayImages(cache.getParent().getWayPoint()));
 			// load user images
-			if(locCounter==1 || locCounter ==2) locY = locY + thumb_size;
-			if (cache.userImages.size()> 0){
-				addTitle(MyLocale.getMsg(341,"User Images:"));
+			if (locCounter == 1 || locCounter == 2)
+				locY = locY + thumb_size;
+			if (cache.userImages.size() > 0) {
+				addTitle(MyLocale.getMsg(341, "User Images:"));
 				locY = locY + 20;
 				locX = padding;
 				locCounter = 0;
 				addImages(cache.userImages);
 			}
-			oldCache=cache;
-		} // cache!=oldCache	
-		if (locY>this.height) {
+			oldCache = cache;
+		} // cache!=oldCache
+		if (locY > this.height) {
 			this.checkScrolls();
 		}
 		this.refresh();
 		Vm.showWait(false);
-		//this.repaintNow();
+		// this.repaintNow();
 	}
 
 	/**
 	 * Clear the images in the panel
-	 *
+	 * 
 	 */
 	public void clearImages() {
-		oldCache=null;
+		oldCache = null;
 		int lgr = images.size();
-		for(int i = 0; i<lgr;i++){
-			this.removeImage((AniImage)images.get(0));
+		for (int i = 0; i < lgr; i++) {
+			this.removeImage((AniImage) images.get(0));
 		}
 	}
-	
+
 	/**
 	 * Add a title above the cache images and above the user images
-	 * @param title Title to add ("cache images" or "user images")
+	 * 
+	 * @param title
+	 *            Title to add ("cache images" or "user images")
 	 */
 	private void addTitle(String title) {
 		AniImage aImg;
@@ -151,24 +157,27 @@
 		FontMetrics fm = getFontMetrics();
 		int stringWidth = fm.getTextWidth(title);
 		int stringHeight = fm.getHeight();
-		Image img = new Image(stringWidth*2,stringHeight+5);
+		Image img = new Image(stringWidth * 2, stringHeight + 5);
 		Graphics g = new Graphics(img);
-		g.setColor(new Color(195,195,195));
-		g.fillRect(0,0,stringWidth*2,stringHeight+5);
-		g.setColor(new Color(0,0,0));
+		g.setColor(new Color(195, 195, 195));
+		g.fillRect(0, 0, stringWidth * 2, stringHeight + 5);
+		g.setColor(new Color(0, 0, 0));
 		g.setFont(titleFont);
-		g.drawText(title, 0,0);
+		g.drawText(title, 0, 0);
 		g.free();
 		aImg = new AniImage(img);
 		aImg.setLocation(0, locY);
 		addImage(aImg);
 		aImg.refresh();
 	}
-	
+
 	/**
 	 * Add the images to the panel. Can add both normal and user images
-	 * @param pImages Vector of images or userImages
-	 * @param imagesText Vector of image texts or user image texts
+	 * 
+	 * @param pImages
+	 *            Vector of images or userImages
+	 * @param imagesText
+	 *            Vector of image texts or user image texts
 	 */
 	private void addImages(CacheImages pImages) {
 		String location, imgText;
@@ -177,133 +186,147 @@
 		double dummyC;
 		ImagePanelImage ipi;
 		AniImage AimgText;
-		locCounter=0;
-		for(int i = 0; i<pImages.size(); i++){
-			location = profile.dataDir + pImages.get(i).getFilename();
-			if (!(new FileBugfix(location)).exists()) {
-				location=NO_IMAGE;
-				if (!pref.showDeletedImages) continue; // Don't show the deleted Image if user does not want it
+		locCounter = 0;
+		for (int i = 0; i < pImages.size(); i++) {
+			location = pImages.get(i).getFilename();
+			boolean doit = true;
+			for (int j = i + 1; j < pImages.size(); j++) {
+				String jmgFile = pImages.get(j).getFilename();
+				if (location.equals(jmgFile)) {
+					doit = false;
+					break;
+				}
 			}
-			try{
-				mI = new mImage(location);
-				// actuall new mImage(location); should do the following "if" but it doesn't anyhow
-				if (mI.getWidth() <= 0 || mI.getHeight() <= 0 ) throw new IllegalArgumentException(location);
-				scaleX = thumb_size;
-				scaleY = thumb_size;
-				dummyC = 0;
-				double thumb_size2 = thumb_size;
-				if(mI.getWidth()>mI.getHeight()){
+			if (doit) {
+				location = profile.dataDir + location;
+				if (!(new FileBugfix(location)).exists()) {
+					location = NO_IMAGE;
+					if (!pref.showDeletedImages)
+						continue; // Don't show the deleted Image if user does not want it
+				}
+				try {
+					mI = new mImage(location);
+					// actuall new mImage(location); should do the following "if" but it doesn't anyhow
+					if (mI.getWidth() <= 0 || mI.getHeight() <= 0)
+						throw new IllegalArgumentException(location);
 					scaleX = thumb_size;
-					dummyC = (double)mI.getHeight()/ (double)mI.getWidth();
-					dummyC = dummyC * thumb_size2;
-					scaleY = (int)dummyC;
-				}
-				if(mI.getWidth() <= mI.getHeight()){
 					scaleY = thumb_size;
-					dummyC = (double)mI.getWidth()/(double)mI.getHeight();
-					dummyC = dummyC * thumb_size2;
-					scaleX = (int)dummyC;
+					dummyC = 0;
+					double thumb_size2 = thumb_size;
+					if (mI.getWidth() > mI.getHeight()) {
+						scaleX = thumb_size;
+						dummyC = (double) mI.getHeight() / (double) mI.getWidth();
+						dummyC = dummyC * thumb_size2;
+						scaleY = (int) dummyC;
+					}
+					if (mI.getWidth() <= mI.getHeight()) {
+						scaleY = thumb_size;
+						dummyC = (double) mI.getWidth() / (double) mI.getHeight();
+						dummyC = dummyC * thumb_size2;
+						scaleX = (int) dummyC;
+					}
+					if (mI.getWidth() <= thumb_size) {
+						scaleX = mI.getWidth();
+						scaleY = mI.getHeight();
+					}
+					mI = mI.scale(scaleX, scaleY, null, 0);
+					mI.freeSource();
+					ipi = new ImagePanelImage(mI);
+					ipi.freeSource();
+					// mI.free(); --> this only works in java-VM, in ewe it will delete the image, so leave it commented out
+					ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
+					ipi.setLocation(locX, locY);
+					addImage(ipi);
+					// Name of picture:
+					if (pImages.size() > i) {
+						if (location.equals(NO_IMAGE))
+							imgText = MyLocale.getMsg(342, "Deleted");
+						else
+							imgText = SafeXML.cleanback(pImages.get(i).getTitle());
+						if (imgText.length() == 0)
+							imgText = "???";
+						AimgText = new AniImage();
+						AimgText = getImageText(imgText);
+						AimgText.setLocation(locX, locY + scaleY);
+						addImage(AimgText);
+						AimgText.refresh();
+						ipi.imageText = imgText;
+						ipi.imageComment = SafeXML.cleanback(pImages.get(i).getComment());
+					}
+					ipi.refresh();
+					locX = locX + thumb_size + padding;
+
+					locCounter++;
+					if (locCounter > 2) {
+						locCounter = 0;
+						locX = padding;
+						locY = locY + thumb_size + padding;
+					}
+				} catch (IllegalArgumentException imex) { // file not found, could not decode etc.
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321, "Fehler"), MyLocale.getMsg(322, "Kann Bild/Karte nicht laden") + ":\n" + imex.getMessage(), FormBase.OKB); // @todo: language support
+					tmp.exec();
+				} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
+					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(343, "Not enough free memory to load cache image") + ":\n" + location, FormBase.OKB)).exec();
+				} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
+					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(343, "Not enough free memory to load cache image") + "\n" + location, FormBase.OKB)).exec();
 				}
-				if(mI.getWidth() <= thumb_size){
-					scaleX = mI.getWidth();
-					scaleY = mI.getHeight();
-				}
-				mI = mI.scale(scaleX,scaleY,null,0);
-				mI.freeSource();
-				ipi = new ImagePanelImage(mI);
-				ipi.freeSource();
-				//mI.free(); --> this only works in java-VM, in ewe it will delete the image, so leave it commented out
-				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
-				ipi.setLocation(locX, locY);
-				addImage(ipi);
-				//Name of picture:
-				if(pImages.size()>i){
-					if (location.equals(NO_IMAGE))
-						imgText=MyLocale.getMsg(342,"Deleted");
-					else
-						imgText = SafeXML.cleanback(pImages.get(i).getTitle());
-					if(imgText.length()==0) imgText = "???";
-					AimgText = new AniImage();
-					AimgText = getImageText(imgText);
-					AimgText.setLocation(locX,locY+scaleY);
-					addImage(AimgText);
-					AimgText.refresh();
-					ipi.imageText = imgText;
-					ipi.imageComment = SafeXML.cleanback(pImages.get(i).getComment());
-				}
-				ipi.refresh();
-				locX = locX + thumb_size + padding;
-				
-				locCounter++;
-				if(locCounter > 2) {
-					locCounter = 0;
-					locX = padding;
-					locY = locY+thumb_size+padding;
-				}
-			}catch(IllegalArgumentException imex){ // file not found, could not decode etc.
-				MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht laden")+":\n"+imex.getMessage(), FormBase.OKB); // @todo: language support
-				tmp.exec();
-			} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+":\n"+location,FormBase.OKB)).exec();
-			} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+"\n"+location,FormBase.OKB)).exec();
 			}
-		} //for
-		
+		} // for
+
 	}
-	
-	private AniImage getImageText(String pText){
+
+	private AniImage getImageText(String pText) {
 		Font aniImageFont = new Font("Verdana", Font.BOLD, 14);
 		FontMetrics fm = getFontMetrics();
 		int stringWidth = fm.getTextWidth(pText);
 		int stringHeight = fm.getHeight();
-		Image img = new Image(stringWidth*2,stringHeight+5);
+		Image img = new Image(stringWidth * 2, stringHeight + 5);
 		Graphics g = new Graphics(img);
-		g.setColor(new Color(195,195,195));
-		g.fillRect(0,0,stringWidth*2,stringHeight+5);
-		g.setColor(new Color(0,0,0));
+		g.setColor(new Color(195, 195, 195));
+		g.fillRect(0, 0, stringWidth * 2, stringHeight + 5);
+		g.setColor(new Color(0, 0, 0));
 		g.setFont(aniImageFont);
-		g.drawText(pText, 0,0);
+		g.drawText(pText, 0, 0);
 		g.free();
 		AniImage a = new AniImage(img);
 		return a;
 	}
 
-	
 	/**
-	* React to when a user clicks an image.
-	* If left mouse key is clicked, will open a new window displaying the image scaled
-	* to window size if the image is larger, otherwise the true size is displayed.
-	* If right mouse key is clicked, a dialogue to delete the image wil be displayed
-	*/
-	public void imageClicked(AniImage which, Point pos){
-		if ((ControlBase.currentPenEvent.modifiers&PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON || duration>LONG_PEN_DOWN_DURATION) {
+	 * React to when a user clicks an image.
+	 * If left mouse key is clicked, will open a new window displaying the image scaled
+	 * to window size if the image is larger, otherwise the true size is displayed.
+	 * If right mouse key is clicked, a dialogue to delete the image wil be displayed
+	 */
+	public void imageClicked(AniImage which, Point pos) {
+		if ((ControlBase.currentPenEvent.modifiers & PenEvent.RIGHT_BUTTON) == PenEvent.RIGHT_BUTTON || duration > LONG_PEN_DOWN_DURATION) {
 			// Right button pressed - delete image to conserve space
-			if (which instanceof ImagePanelImage && !((ImagePanelImage)which).fileName.equals(NO_IMAGE)) {
-				MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(344,"Delete image")+" \""+((ImagePanelImage)which).imageText+"\"?", FormBase.IDYES |FormBase.IDNO);
-				if (mBox.execute() == FormBase.IDOK){
-						try {
-							File f=new File(((ImagePanelImage)which).fileName);
-							f.delete();
-							removeImage(which);
-						} catch(Exception e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						};
+			if (which instanceof ImagePanelImage && !((ImagePanelImage) which).fileName.equals(NO_IMAGE)) {
+				MessageBox mBox = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(344, "Delete image") + " \"" + ((ImagePanelImage) which).imageText + "\"?", FormBase.IDYES | FormBase.IDNO);
+				if (mBox.execute() == FormBase.IDOK) {
+					try {
+						File f = new File(((ImagePanelImage) which).fileName);
+						f.delete();
+						removeImage(which);
+					} catch (Exception e) {
+						// Global.getPref().log("Ignored Exception", e, true);
+					}
+					;
 				}
 			}
-		} else { 
+		} else {
 			String fn = new String();
-			if(which instanceof ImagePanelImage){
-				ImagePanelImage ich = (ImagePanelImage)which;
+			if (which instanceof ImagePanelImage) {
+				ImagePanelImage ich = (ImagePanelImage) which;
 				fn = ich.fileName;
 				try {
 					ImageDetailForm iF = new ImageDetailForm(fn, ich.imageText, ich.imageComment, pref);
 					iF.execute(null, Gui.CENTER_FRAME);
 				} catch (IllegalArgumentException e) {
-					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht finden"), FormBase.OKB); // @todo: language support
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321, "Fehler"), MyLocale.getMsg(322, "Kann Bild/Karte nicht finden"), FormBase.OKB); // @todo: language support
 					tmp.exec();
 				} catch (OutOfMemoryError e) {
-					(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+"\n"+fn,FormBase.OKB)).exec();
+					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(343, "Not enough free memory to load cache image") + "\n" + fn, FormBase.OKB)).exec();
 				}
 			}
 		}
@@ -311,15 +334,15 @@
 
 	/**
 	 * Create a "pen held down" event on hardware that does not support a right mouse key (e.g. Windows Mobile)
-	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate 
+	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate
 	 * between left and right mouse keys.
 	 */
 	public void onPenEvent(PenEvent ev) {
-		if (ev.type==PenEvent.PEN_DOWN) {
+		if (ev.type == PenEvent.PEN_DOWN) {
 			start = Vm.getTimeStampLong();
 		}
-		if (ev.type==PenEvent.PEN_UP) {
-			duration=Vm.getTimeStampLong()-start;
+		if (ev.type == PenEvent.PEN_UP) {
+			duration = Vm.getTimeStampLong() - start;
 		}
 		super.onPenEvent(ev);
 	}

Modified: branches/r1.2/src/CacheWolf/InfoBox.java
===================================================================
--- branches/r1.2/src/CacheWolf/InfoBox.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/InfoBox.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.ui.CellConstants;
 import ewe.ui.ControlConstants;
 import ewe.ui.ControlEvent;
@@ -37,7 +38,7 @@
 import ewe.ui.mInput;
 import ewe.ui.mLabel;
 
-public class InfoBox extends Form{
+public class InfoBox extends Form {
 	TextMessage msgArea;
 	mCheckBox mCB;
 	TextMessage warnings;
@@ -50,28 +51,21 @@
 	public final static int DISPLAY_ONLY = 3;
 	public final static int PROGRESS_WITH_WARNINGS = 4;
 	private int type = 0;
-	/** This variable is set to true if the user closed the Info window by
-	 *  clicking the "close" button. It can be used to check if a lengthy task needs to be
-	 *  aborted (i.e. spidering)
+	/**
+	 * This variable is set to true if the user closed the Info window by clicking the "close" button. It can be used to check if a lengthy task needs to be aborted (i.e. spidering)
 	 */
-	public boolean isClosed=false;
+	public boolean isClosed = false;
 
-	public InfoBox(String title, String info){
+	public InfoBox(String title, String info) {
 		this(title, info, DISPLAY_ONLY);
 
-		/*this.setPreferredSize(170,50);
-		this.title = title;
-		msgArea = new MessageArea(""), CellConstants.STRETCH, CellConstants.FILL)
-		this.addLast(scP = new ScrollBarPanel(msgArea));
-		msgArea.setText(info);
-		mB.setHotKey(0, IKeys.ACTION);
-		mB.setHotKey(0, IKeys.ENTER);
-		//mB.set(Control.Invisible, true);
-		//this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+		/*
+		 * this.setPreferredSize(170,50); this.title = title; msgArea = new MessageArea(""), CellConstants.STRETCH, CellConstants.FILL) this.addLast(scP = new ScrollBarPanel(msgArea)); msgArea.setText(info); mB.setHotKey(0, IKeys.ACTION); mB.setHotKey(0,
+		 * IKeys.ENTER); //mB.set(Control.Invisible, true); //this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
 		 */
 	}
 
-	public String getInput(){
+	public String getInput() {
 		return feedback.getText();
 	}
 
@@ -80,29 +74,43 @@
 		this.repaintNow();
 	}
 
-	public InfoBox(String title, String info, int ty){
-		this(title, info, ty, true);
-//		this.setPreferredSize(170, 50);
+	public InfoBox(String title, String info, int type) {
+		this(title, info, type, true);
+		// this.setPreferredSize(170, 50);
 		relayout(false);
 	}
 
 	public InfoBox(String title, String info, int ty, boolean autoWrap) {
 		type = ty;
-//		this.setPreferredSize(150,50);
+		// this.setPreferredSize(150,50);
 		// Resize InfoBox with Fontsize
-		Preferences pref=Global.getPref();
+		Preferences pref = Global.getPref();
 		int fs = pref.fontSize;
 		int sw = MyLocale.getScreenWidth();
-		int psx; int psy;
-		psx=170;psy=50;
-		if((fs > 11) && (sw >= 200)){psx=200;psy=70;}
-		if((fs > 16) && (sw >= 250)){psx=250;psy=90;}
-		if((fs > 21) && (sw >= 300)){psx=300;psy=110;}
-		if((fs > 24) && (sw >= 350)){psx=350;psy=130;}
+		int psx;
+		int psy;
+		psx = 170;
+		psy = 50;
+		if ((fs > 11) && (sw >= 200)) {
+			psx = 200;
+			psy = 70;
+		}
+		if ((fs > 16) && (sw >= 250)) {
+			psx = 250;
+			psy = 90;
+		}
+		if ((fs > 21) && (sw >= 300)) {
+			psx = 300;
+			psy = 110;
+		}
+		if ((fs > 24) && (sw >= 350)) {
+			psx = 350;
+			psy = 130;
+		}
 		this.setPreferredSize(psx, psy);
 		this.title = title;
 		switch (type) {
-		case CHECKBOX: 
+		case CHECKBOX:
 			mCB = new mCheckBox(info);
 			this.addLast(mCB, CellConstants.STRETCH, CellConstants.FILL);
 			break;
@@ -123,11 +131,11 @@
 			msgArea.autoWrap = autoWrap;
 			msgArea.alignment = CellConstants.CENTER;
 			msgArea.anchor = CellConstants.CENTER;
-			msgArea.setPreferredSize(psx-20, psy);
+			msgArea.setPreferredSize(psx - 20, psy);
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
 			warnings = new TextMessage("");
 			warnings.autoWrap = autoWrap;
-			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW);
+			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND | CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND | CellConstants.VGROW);
 			mB.set(ControlConstants.Disabled, true);
 			mB.setPreferredSize(40, 20);
 			addLast(mB, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
@@ -142,48 +150,52 @@
 		}
 	}
 
-	public void setInfo(String info){
+	public void setInfo(String info) {
 		msgArea.setText(info);
 		this.repaintNow();
 	}
-	
+
 	public void setInfoHeight(int heighti) {
 		msgArea.setPreferredSize(getPreferredSize(null).width, heighti);
 	}
+
 	public void setInfoWidth(int widthi) {
-		msgArea.setPreferredSize(widthi,getPreferredSize(null).height);
+		msgArea.setPreferredSize(widthi, getPreferredSize(null).height);
 	}
-	public String getInfo(){
+
+	public String getInfo() {
 		return msgArea.getText();
 	}
 
-	public void addWarning (String w) {
+	public void addWarning(String w) {
 		warnings.setText(warnings.text + w);
 	}
-	public void addOkButton() { //unfortunately this doesn't work
+
+	public void addOkButton() { // unfortunately this doesn't work
 		mB.set(ControlConstants.Disabled, false);
-		//addNext(mB);
-		//relayout(true);
-		//mB.set(Control.Invisible, false);
+		// addNext(mB);
+		// relayout(true);
+		// mB.set(Control.Invisible, false);
 		this.repaintNow();
 	}
 
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
-			if(ev.target == mB){
-				if(type == CHECKBOX) mCB_state = mCB.getState();
+			if (ev.target == mB) {
+				if (type == CHECKBOX)
+					mCB_state = mCB.getState();
 				this.close(FormBase.IDOK);
 			}
-			if(ev.target == mC){
+			if (ev.target == mC) {
 				this.close(FormBase.IDCANCEL);
 			}
 		}
 		super.onEvent(ev);
 	}
-	
+
 	protected boolean canExit(int exitCode) {
-		isClosed=true;
+		isClosed = true;
 		return true;
 	}
-	
+
 }
\ No newline at end of file

Modified: branches/r1.2/src/CacheWolf/LogList.java
===================================================================
--- branches/r1.2/src/CacheWolf/LogList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/LogList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,55 +1,56 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.util.Vector;
 
 public class LogList {
-	/** The Vector containing the Log objects 
-	 * The list is always sorted in descending order */
-	private Vector logList=new Vector(10);
+	/**
+	 * The Vector containing the Log objects The list is always sorted in descending order
+	 */
+	private Vector logList = new Vector(10);
 	private static final StringBuffer buffer = new StringBuffer();
 
 	/** Construct an empty Log list */
 	public LogList() { // Public constructor
 	}
-	
+
 	/** Get the Log at a certain position in the list */
 	public Log getLog(int i) {
-		if (logList.size()>i) {
-			return (Log) logList.elementAt(i);			
-		}
-		else return null;
+		if (logList.size() > i) {
+			return (Log) logList.elementAt(i);
+		} else
+			return null;
 	}
-	
+
 	/** Return the size of the list */
 	public int size() {
 		return logList.size();
 	}
-	
+
 	/** Clear the Log list */
 	public void clear() {
 		logList.clear();
@@ -57,9 +58,10 @@
 
 	/** Add a Log to the list */
 	public void add(Log log) {
-		if (log.getIcon()!=null) logList.add(log); // Don't add invalid logs
+		if (log.getIcon() != null)
+			logList.add(log); // Don't add invalid logs
 	}
-	
+
 	/** Remove a Log from the list */
 	public void remove(int i) {
 		logList.removeElementAt(i);
@@ -69,47 +71,49 @@
 	public void replace(int i, Log log) {
 		logList.set(i, log);
 	}
-	
-	/** Merge a log into the list at the appropriate position
+
+	/**
+	 * Merge a log into the list at the appropriate position
+	 * 
 	 * @param newLog
 	 * @return the position where the log was placed or -1 if it is already in the list
-	 */ 
-	 
+	 */
+
 	public int merge(Log newLog) {
-		String newDate=newLog.getDate();
-		int size=size();
+		String newDate = newLog.getDate();
+		int size = size();
 		int i;
-		for (i=0; i<size; i++) {
-			 int comp=newDate.compareTo(((Log) logList.elementAt(i)).getDate());
-			 if (comp>0) {
-				 logList.insertElementAt(newLog, i);
-				 return i;
-			 }
-			 if (comp==0) break;
+		for (i = 0; i < size; i++) {
+			int comp = newDate.compareTo(((Log) logList.elementAt(i)).getDate());
+			if (comp > 0) {
+				logList.insertElementAt(newLog, i);
+				return i;
+			}
+			if (comp == 0)
+				break;
 		}
 		// Now i points to the first log with same date as the new log or i==size()
-		if (i==size) {
+		if (i == size) {
 			add(newLog);
 			return size;
 		}
-		int firstLog=i;
+		int firstLog = i;
 		// Check whether we have any logs with same date by same user
-		String newLogger=newLog.getLogger();
-		String newIcon=newLog.getIcon();
-		while (i<size &&  newDate.equals(((Log) logList.elementAt(i)).getDate())) {
-			Log log=(Log) logList.elementAt(i);
-			if (log.getLogger().equals(newLogger) &&
-				log.getIcon().equals(newIcon)) {
+		String newLogger = newLog.getLogger();
+		String newIcon = newLog.getIcon();
+		while (i < size && newDate.equals(((Log) logList.elementAt(i)).getDate())) {
+			Log log = (Log) logList.elementAt(i);
+			if (log.getLogger().equals(newLogger) && log.getIcon().equals(newIcon)) {
 				// Has the log message changed vs. the one we have in cache.xml?
 				if (!log.getMessage().equals(newLog.getMessage())) {
-					replace(i,newLog);
+					replace(i, newLog);
 					return i;
 				} else
 					return -1; // Log already in list
 			}
 			i++;
 		}
-		if (i==size) {
+		if (i == size) {
 			add(newLog);
 			return i;
 		} else {
@@ -118,20 +122,18 @@
 		}
 	}
 
-	 /**
-	  *  Count the number of not-found logs
-	  */
+	/**
+	 * Count the number of not-found logs
+	 */
 	public byte countNotFoundLogs() {
 		byte countNoFoundLogs = 0;
 		int currentLog = 0;
 		String currentIcon;
-		while(currentLog < size() && countNoFoundLogs < 5){
+		while (currentLog < size() && countNoFoundLogs < 5) {
 			currentIcon = getLog(currentLog).getIcon();
-			if(currentIcon.startsWith("icon_sad")) {
+			if (currentIcon.startsWith("icon_sad")) {
 				countNoFoundLogs++;
-			}else if (currentIcon.startsWith("icon_smile") || currentIcon.startsWith("icon_camera")
-             || currentIcon.startsWith("icon_attended") || currentIcon.startsWith("icon_rsvp")
-             || currentIcon.startsWith("icon_maint")) {
+			} else if (currentIcon.startsWith("icon_smile") || currentIcon.startsWith("icon_camera") || currentIcon.startsWith("icon_attended") || currentIcon.startsWith("icon_rsvp") || currentIcon.startsWith("icon_maint")) {
 				break;
 			}
 			currentLog++;
@@ -139,51 +141,57 @@
 		return countNoFoundLogs;
 	}
 
-	 /** only valid after calling calcRecommendations() */
-	 int numRecommended = 0;
-	 /** only valid after calling calcRecommendations() */
-	 int foundsSinceRecommendation = 0;
-	 /** only valid after calling calcRecommendations() */
-	 int recommendationRating = 0;
-	 
-	 /**
-	  * call this to 
-	  *
-	  */
-	 public void calcRecommendations() {
-		 numRecommended = 0;
-		 foundsSinceRecommendation = 0;
-		 Log l;
-		 int s = size();
-		 int i;
-		 for (i= 0 ; i < s; i++){
-			 l = getLog(i);
-			 if (l.getDate().compareTo("2007-01-14") < 0) break; // this is the date when the recommendation system was introdueced in opencaching.de see: http://www.geoclub.de/viewtopic.php?t=14901&highlight=formel
-			 if (l.isRecomended()) numRecommended++;
-			 if (l.isFoundLog()) foundsSinceRecommendation++; 
-		 }
-		 recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
-	 }
-	 
-	 public static int getScore(int numrecommends, int numfoundlogs) {
-		 return Math.round((((float)numrecommends * (float)numrecommends +1f ) / (numfoundlogs / 10f +1f))*100f);
-	 }
-	 
-	 /**
-	  * Returns a simple concatenation of all Log texts of the list. Intended for text search in 
-	  * Logs.
+	/** only valid after calling calcRecommendations() */
+	int numRecommended = 0;
+	/** only valid after calling calcRecommendations() */
+	int foundsSinceRecommendation = 0;
+	/** only valid after calling calcRecommendations() */
+	int recommendationRating = 0;
+
+	/**
+	 * call this to
+	 * 
+	 */
+	public void calcRecommendations() {
+		numRecommended = 0;
+		foundsSinceRecommendation = 0;
+		Log l;
+		int s = size();
+		int i;
+		for (i = 0; i < s; i++) {
+			l = getLog(i);
+			// 2007-01-14 is the date when the recommendation system was introdueced in opencaching.de see:
+			// http://www.geoclub.de/viewtopic.php?t=14901&highlight=formel
+			if (l.getDate().compareTo("2007-01-14") < 0)
+				break;
+			if (l.isRecomended())
+				numRecommended++;
+			if (l.isFoundLog())
+				foundsSinceRecommendation++;
+		}
+		recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
+	}
+
+	public static int getScore(int numrecommends, int numfoundlogs) {
+		return Math.round((((float) numrecommends * (float) numrecommends + 1f) / (numfoundlogs / 10f + 1f)) * 100f);
+	}
+
+	/**
+	 * Returns a simple concatenation of all Log texts of the list. Intended for text search in Logs.
+	 * 
 	 * @return All log messages
 	 */
 	public String allMessages() {
-		 buffer.setLength(0);
-		 for (int i=0; i<logList.size(); i++) {
-			 buffer.append(((Log)logList.get(i)).getMessage());
-		 }
-		 return buffer.toString();
-	 }
+		buffer.setLength(0);
+		for (int i = 0; i < logList.size(); i++) {
+			buffer.append(((Log) logList.get(i)).getMessage());
+		}
+		return buffer.toString();
+	}
 
 	/**
 	 * trim down number of log to maximum number user wants to keep in database
+	 * 
 	 * @return number of removed logs
 	 */
 	public int purgeLogs() {
@@ -191,12 +199,12 @@
 		boolean keepOwn = Global.getPref().alwaysKeepOwnLogs;
 		int purgedLogs = 0;
 		for (int i = logList.size(); i > maxKeep; i--) {
-			if (!(keepOwn && getLog(i-1).isOwnLog())) {
-				this.remove(i-1);
+			if (!(keepOwn && getLog(i - 1).isOwnLog())) {
+				this.remove(i - 1);
 				purgedLogs++;
 			}
 		}
 		return purgedLogs;
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/MainForm.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainForm.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MainForm.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -83,6 +83,7 @@
 		pref.setPathToConfigFile(pathtoprefxml); // in case pathtoprefxml == null the preferences will determine the path itself
 		doIt();
 	}
+	
 	protected void checkButtons() {
 		if (pref.hasCloseButton) super.checkButtons();
 	}
@@ -189,8 +190,7 @@
 
 	private void addGuiFont(){
 		Font defaultGuiFont = mApp.findFont("gui");
-		int sz = (pref.fontSize);
-		Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+		Font newGuiFont = new Font(pref.fontName, defaultGuiFont.getStyle(), pref.fontSize);
 		mApp.addFont(newGuiFont, "gui");
 		mApp.fontsChanged();
 		mApp.mainApp.font = newGuiFont;

Modified: branches/r1.2/src/CacheWolf/MainMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainMenu.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MainMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.exp.ASCExporter;
@@ -32,6 +32,7 @@
 import CacheWolf.exp.KMLExporter;
 import CacheWolf.exp.LocExporter;
 import CacheWolf.exp.MSARCSVExporter;
+import CacheWolf.exp.OCLogExport;
 import CacheWolf.exp.OVLExporter;
 import CacheWolf.exp.OziExporter;
 import CacheWolf.exp.SpoilerPOIExporter;
@@ -41,12 +42,15 @@
 import CacheWolf.imp.GCVoteImporter;
 import CacheWolf.imp.GPXImporter;
 import CacheWolf.imp.LOCXMLImporter;
+import CacheWolf.imp.OCGPXfetch;
+import CacheWolf.imp.OCLinkImporter;
 import CacheWolf.imp.OCXMLImporter;
 import CacheWolf.imp.OCXMLImporterScreen;
 import CacheWolf.imp.SpiderGC;
 import CacheWolf.navi.MapImporter;
 import CacheWolf.navi.MapLoaderGui;
 import CacheWolf.navi.SelectMap;
+import CacheWolf.view.TravelbugJourneyScreenFactory;
 import ewe.filechooser.FileChooser;
 import ewe.filechooser.FileChooserBase;
 import ewe.fx.Font;
@@ -69,212 +73,198 @@
 import ewe.util.Vector;
 
 /**
- *	This class creates the menu for cachewolf. It is also responsible
- *	for reacting to user inputs in the menu.<br>
- *	This class id=100
- *	@see MainForm
- *	@see MainTab
- *   Last change:
- *     20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
+ * This class creates the menu for cachewolf. It is also responsible for reacting to user inputs in the menu.<br>
+ * This class id=100
+ * 
+ * @see MainForm
+ * @see MainTab Last change: 20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
  */
 public class MainMenu extends MenuBar {
-	private MenuItem preferences, mnuContext,loadcaches,loadOC, /* savenexit, */ savenoxit,exit,search,searchAll,searchClr;
+	private MenuItem preferences, mnuContext, loadcaches, loadOC, loadOCFinds, savenoxit, exit, search, searchAll, searchClr;
 	private MenuItem downloadmap, kalibmap, importmap, selectMapPath;
-	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, update, chkVersion;
+	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, fetchOCLink, update, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportGpxNg, exporthtml, exporttop50, exportASC, exportTomTom, exportMSARCSV, exportSpoilerPOI;
-	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist;
+	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist, exportOCLog;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
-	private MenuItem exportLOC, exportGPS, mnuSeparator=new MenuItem("-");
-	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete,orgRebuild,orgCheckNotesAndSolver;
+	private MenuItem exportLOC, exportGPS, mnuSeparator = new MenuItem("-");
+	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete, orgRebuild, orgCheckNotesAndSolver;
 	public MenuItem cacheTour, orgTravelbugs, mnuForceLogin;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuDeleteProfile, mnuRenameProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
-	private FilterScreen scnFilter=new FilterScreen();
+	private FilterScreen scnFilter = new FilterScreen();
 	private static boolean searchInDescriptionAndNotes = false;
 	private static boolean searchInLogs = false;
+	GCVoteImporter sGCV = null;
 
-	public MainMenu(Form f){
+	public MainMenu(Form f) {
 
 		Global.getPref().setgpsbabel();
 
 		father = f;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for profiles, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mnuProfile = {
-			mnuNewProfile = new MenuItem(MyLocale.getMsg(1107,"New")),
-			mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109,"Open")),
-			mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125,"Delete")),
-			mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126,"Rename")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] mnuProfile = { mnuNewProfile = new MenuItem(MyLocale.getMsg(1107, "New")), //
+				mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109, "Open")), //
+				mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125, "Delete")), //
+				mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126, "Rename")), //
 		};
-		Menu profileMenu = new Menu(mnuProfile,MyLocale.getMsg(121,"Profiles"));
+		Menu profileMenu = new Menu(mnuProfile, MyLocale.getMsg(121, "Profiles"));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for import, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		if (Global.getPref().spiderRoute) 
-			spiderRoute = new MenuItem(MyLocale.getMsg(137,"Download along a Route from geocaching.com"));
-		else spiderRoute = mnuSeparator;
-		MenuItem[] mnuImport = {				
-				loadcaches     = new MenuItem(MyLocale.getMsg(129,"Import GPX")),
-				loadOC         = new MenuItem(MyLocale.getMsg(130,"Download from opencaching")),
-				spider         = new MenuItem(MyLocale.getMsg(131,"Download from geocaching.com")),
-				spiderRoute,
-				spiderAllFinds = new MenuItem(MyLocale.getMsg(217,"Spider all finds from geocaching.com")),
-				spiderQuick    = new MenuItem(MyLocale.getMsg(138,"from GC quick")),
-				update         = new MenuItem(MyLocale.getMsg(1014,"Update cache data")),
-				mnuSeparator,
-				loadGCVotes    = new MenuItem(MyLocale.getMsg(1208,"Import ratings from GCVote")),
-				mnuSeparator,
-				mnuForceLogin  = new MenuItem(MyLocale.getMsg(216,"Always login to GC")),
+		// /////////////////////////////////////////////////////////////////////
+		if (Global.getPref().spiderRoute)
+			spiderRoute = new MenuItem(MyLocale.getMsg(137, "Download along a Route from geocaching.com"));
+		else
+			spiderRoute = mnuSeparator;
+		MenuItem[] mnuImport = { loadcaches = new MenuItem(MyLocale.getMsg(129, "Import GPX")), //
+				mnuSeparator, //
+				loadOC = new MenuItem(MyLocale.getMsg(130, "Download from opencaching")), //
+				loadOCFinds = new MenuItem(MyLocale.getMsg(163, "Finds from opencaching")), //
+				mnuSeparator, //
+				spider = new MenuItem(MyLocale.getMsg(131, "Download from geocaching.com")), //
+				spiderRoute, //
+				spiderAllFinds = new MenuItem(MyLocale.getMsg(217, "Spider all finds from geocaching.com")), //
+				spiderQuick = new MenuItem(MyLocale.getMsg(138, "from GC quick")), //
+				update = new MenuItem(MyLocale.getMsg(1014, "Update cache data")), //
+				mnuSeparator, //
+				loadGCVotes = new MenuItem(MyLocale.getMsg(1208, "Import ratings from GCVote")), //
+				fetchOCLink = new MenuItem(MyLocale.getMsg(1209, "Fetch link to OC - Cache")), //
+				mnuSeparator, //
+				mnuForceLogin = new MenuItem(MyLocale.getMsg(216, "Always login to GC")), //
 		};
-		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175,"Import"));
-		if (Global.getPref().forceLogin) mnuForceLogin.modifiers^=MenuItem.Checked;
+		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175, "Import"));
+		if (Global.getPref().forceLogin)
+			mnuForceLogin.modifiers ^= MenuItem.Checked;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] exitems = {
-				exporthtml = new MenuItem(MyLocale.getMsg(100,"to HTML")),
-				exportGpxNg = new MenuItem(MyLocale.getMsg(101,"to GPX Test")),
-				exporttop50 = new MenuItem(MyLocale.getMsg(102,"to TOP50 ASCII")),
-				exportASC = new MenuItem(MyLocale.getMsg(104,"to CSV")),
-				exportTomTom = new MenuItem(MyLocale.getMsg(105,"to TomTom")),
-				exportMSARCSV = new MenuItem(MyLocale.getMsg(106,"to MS AutoRoute CSV")),
-				exportLOC = new MenuItem(MyLocale.getMsg(215,"to LOC")),
-				exportGPS = new MenuItem(MyLocale.getMsg(122,"to GPS")),
-				exportOZI = new MenuItem(MyLocale.getMsg(124,"to OZI")),
-				exportKML = new MenuItem(MyLocale.getMsg(125,"to Google Earth")),
-				exportExplorist = new MenuItem(MyLocale.getMsg(132,"to Explorist")),
-				exportTPL = new MenuItem(MyLocale.getMsg(128,"via Template")),
-				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135,"to SpoilerPOI")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] exitems = { exporthtml = new MenuItem(MyLocale.getMsg(100, "to HTML")), //
+				exportGpxNg = new MenuItem(MyLocale.getMsg(101, "to GPX Test")), //
+				exporttop50 = new MenuItem(MyLocale.getMsg(102, "to TOP50 ASCII")), //
+				exportASC = new MenuItem(MyLocale.getMsg(104, "to CSV")), //
+				exportTomTom = new MenuItem(MyLocale.getMsg(105, "to TomTom")), //
+				exportMSARCSV = new MenuItem(MyLocale.getMsg(106, "to MS AutoRoute CSV")), //
+				exportLOC = new MenuItem(MyLocale.getMsg(215, "to LOC")), //
+				exportGPS = new MenuItem(MyLocale.getMsg(122, "to GPS")), //
+				exportOZI = new MenuItem(MyLocale.getMsg(124, "to OZI")), //
+				exportKML = new MenuItem(MyLocale.getMsg(125, "to Google Earth")), //
+				exportExplorist = new MenuItem(MyLocale.getMsg(132, "to Explorist")), //
+				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135, "to SpoilerPOI")), //
+				exportTPL = new MenuItem(MyLocale.getMsg(128, "via Template")), //
+				exportOCLog = new MenuItem(MyLocale.getMsg(1210, "logs to OC")), //
 		};
-		if ( Global.getPref().gpsbabel == null ) {
+		if (Global.getPref().gpsbabel == null) {
 			exportGPS.modifiers = MenuItem.Disabled;
-			exportGPS.setText(MyLocale.getMsg(136,"to GPS : gpsbabel missing."));
+			exportGPS.setText(MyLocale.getMsg(136, "to GPS : gpsbabel missing."));
 		}
+		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107, "Export"));
 
-		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107,"Export"));
-
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for maps, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mapMenuItems = {
-				downloadmap = new MenuItem(MyLocale.getMsg(162,"Download calibrated")),
-				importmap = new MenuItem(MyLocale.getMsg(150,"Import")),
-				kalibmap = new MenuItem(MyLocale.getMsg(151,"Calibrate")),
-				selectMapPath = new MenuItem(MyLocale.getMsg(4236, "Change map directory$c")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] mapMenuItems = { downloadmap = new MenuItem(MyLocale.getMsg(162, "Download calibrated")), //
+				importmap = new MenuItem(MyLocale.getMsg(150, "Import")), //
+				kalibmap = new MenuItem(MyLocale.getMsg(151, "Calibrate")), //
+				selectMapPath = new MenuItem(MyLocale.getMsg(4236, "Change map directory$c")), //
 		};
 		Menu mapsMenu = new Menu(mapMenuItems, null);
 
 		// Now we start with the horizontal menu bar "Application", "Search", "Filter", "Organise", "About"
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Application" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem [] appMenuItems={
-				new MenuItem(MyLocale.getMsg(121,"Profile"), 0, profileMenu),
-				preferences = new MenuItem(MyLocale.getMsg(108,"Preferences")),
-				mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,"Centre")),
-				mnuContext = new MenuItem(MyLocale.getMsg(134,"Current Cache")),
-				mnuSeparator,
-				new MenuItem(MyLocale.getMsg(175,"Import"),0,importMenu),
-				new MenuItem(MyLocale.getMsg(107,"Export"),0,exportMenu),
-				new MenuItem(MyLocale.getMsg(149,"Maps"),0,mapsMenu),
-				mnuSeparator,
-				savenoxit = new MenuItem(MyLocale.getMsg(127,"Save")),
-				// savenexit = new MenuItem(MyLocale.getMsg(110,"Save & Exit")),
-				exit = new MenuItem(MyLocale.getMsg(111,"Exit")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] appMenuItems = { new MenuItem(MyLocale.getMsg(121, "Profile"), 0, profileMenu), //
+				preferences = new MenuItem(MyLocale.getMsg(108, "Preferences")), //
+				mnuEditCenter = new MenuItem(MyLocale.getMsg(1110, "Centre")), //
+				mnuContext = new MenuItem(MyLocale.getMsg(134, "Current Cache")), //
+				mnuSeparator, new MenuItem(MyLocale.getMsg(175, "Import"), 0, importMenu), //
+				new MenuItem(MyLocale.getMsg(107, "Export"), 0, exportMenu), //
+				new MenuItem(MyLocale.getMsg(149, "Maps"), 0, mapsMenu), //
+				mnuSeparator, //
+				savenoxit = new MenuItem(MyLocale.getMsg(127, "Save")), //
+				exit = new MenuItem(MyLocale.getMsg(111, "Exit")), //
 		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(120,"Application"),new Menu(appMenuItems,null)));
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(120, "Application"), new Menu(appMenuItems, null)));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Search" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] searchMenuItems={
-				search = new MenuItem(MyLocale.getMsg(112,"Search$"+(char)6)),// char 6 = ctrl +f
-				searchAll = new MenuItem(MyLocale.getMsg(133,"Search All")),
-				searchClr = new MenuItem(MyLocale.getMsg(113,"Clear search")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] searchMenuItems = { search = new MenuItem(MyLocale.getMsg(112, "Search$" + (char) 6)), // char 6 = ctrl +f
+				searchAll = new MenuItem(MyLocale.getMsg(133, "Search All")), //
+				searchClr = new MenuItem(MyLocale.getMsg(113, "Clear search")), //
 		};
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Filter" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterMenuItems={
-				filtApply  = new MenuItem(MyLocale.getMsg(709,"Apply")),
-				filtCreate  = new MenuItem(MyLocale.getMsg(114,"Create")),
-				filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")),
-				filtClear   = new MenuItem(MyLocale.getMsg(116,"Clear")),
-				mnuSeparator,
-				filtSelected = new MenuItem(MyLocale.getMsg(160,"Filter selected")),
-				filtNonSelected = new MenuItem(MyLocale.getMsg(1011,"Filter out non selected")),
-				mnuSeparator,
-				filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] filterMenuItems = { filtApply = new MenuItem(MyLocale.getMsg(709, "Apply")), filtCreate = new MenuItem(MyLocale.getMsg(114, "Create")), filtInvert = new MenuItem(MyLocale.getMsg(115, "Invert")),
+				filtClear = new MenuItem(MyLocale.getMsg(116, "Clear")), //
+				mnuSeparator, //
+				filtSelected = new MenuItem(MyLocale.getMsg(160, "Filter selected")), //
+				filtNonSelected = new MenuItem(MyLocale.getMsg(1011, "Filter out non selected")), //
+				mnuSeparator, filtBlack = new MenuItem(MyLocale.getMsg(161, "Show Blacklist")), //
 		};
-        filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+		filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems={
-				filtApply,
-				filtCreate,
-				filtInvert,
-				filtClear,
-				mnuSeparator,
-				filtSelected,
-				filtNonSelected,
-				mnuSeparator,
-				filtBlack,
-				mnuSeparator,
-				search,
-				searchClr,
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] filterAndSearchMenuItems = { filtApply, //
+				filtCreate, //
+				filtInvert, //
+				filtClear, //
+				mnuSeparator, //
+				filtSelected, //
+				filtNonSelected, //
+				mnuSeparator, //
+				filtBlack, //
+				mnuSeparator, //
+				search, //
+				searchClr, //
 		};
 
 		// Depending on screen width display either filter and search menus or the combined menu
-		if (MyLocale.getScreenWidth()>300) {
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(112,"Search"),new Menu(searchMenuItems,null)));
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,"Filter"),new Menu(filterMenuItems,null)));
+		if (MyLocale.getScreenWidth() > 300) {
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(112, "Search"), new Menu(searchMenuItems, null)));
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159, "Filter"), new Menu(filterMenuItems, null)));
 		} else {
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,"Filter"),new Menu(filterAndSearchMenuItems,null)));
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159, "Filter"), new Menu(filterAndSearchMenuItems, null)));
 		}
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Organise" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] organiseMenuItems={				
-				orgNewWP = new MenuItem(MyLocale.getMsg(214,"New Waypoint")),
-				mnuSeparator,
-				orgCopy  = new MenuItem(MyLocale.getMsg(141,"Copy")),
-				orgMove  = new MenuItem(MyLocale.getMsg(142,"Move")),
-				orgDelete   = new MenuItem(MyLocale.getMsg(143,"Delete")),
-				orgRebuild   = new MenuItem(MyLocale.getMsg(208,"Rebuild Index")),
-				orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220,"Check Notes/Solver")),
-				mnuSeparator,
-				orgTravelbugs = new MenuItem(MyLocale.getMsg(139,"Manage travelbugs")),
-				cacheTour = new MenuItem(MyLocale.getMsg(198,"Cachetour")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] organiseMenuItems = { orgNewWP = new MenuItem(MyLocale.getMsg(214, "New Waypoint")), //
+				mnuSeparator, //
+				orgCopy = new MenuItem(MyLocale.getMsg(141, "Copy")), //
+				orgMove = new MenuItem(MyLocale.getMsg(142, "Move")), //
+				orgDelete = new MenuItem(MyLocale.getMsg(143, "Delete")), //
+				orgRebuild = new MenuItem(MyLocale.getMsg(208, "Rebuild Index")), //
+				orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220, "Check Notes/Solver")), //
+				mnuSeparator, //
+				orgTravelbugs = new MenuItem(MyLocale.getMsg(139, "Manage travelbugs")), //
+				cacheTour = new MenuItem(MyLocale.getMsg(198, "Cachetour")), //
 		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,"Organise"),new Menu(organiseMenuItems,null)));
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(140, "Organise"), new Menu(organiseMenuItems, null)));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "About" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] aboutMenuItems={
-				about = new MenuItem(MyLocale.getMsg(117,"About")),
-				legend = new MenuItem(MyLocale.getMsg(155,"Legend")),
-				wolflang = new MenuItem(MyLocale.getMsg(118,"WolfLanguage")),
-				sysinfo = new MenuItem(MyLocale.getMsg(157,"System")),
-				chkVersion = new MenuItem(MyLocale.getMsg(158,"Version Check")),
-		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(117,"About"),new Menu(aboutMenuItems,null)));
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] aboutMenuItems = { about = new MenuItem(MyLocale.getMsg(117, "About")), legend = new MenuItem(MyLocale.getMsg(155, "Legend")), wolflang = new MenuItem(MyLocale.getMsg(118, "WolfLanguage")),
+				sysinfo = new MenuItem(MyLocale.getMsg(157, "System")), chkVersion = new MenuItem(MyLocale.getMsg(158, "Version Check")), };
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(117, "About"), new Menu(aboutMenuItems, null)));
 	}
 
-	public void setTablePanel(TablePanel t){
+	public void setTablePanel(TablePanel t) {
 		tbp = t;
 		if (mnuContext.subMenu == null) {
-			if ((","+Global.getPref().listColMap+",").indexOf(",0,")>=0)
+			if (("," + Global.getPref().listColMap + ",").indexOf(",0,") >= 0)
 				mnuContext.subMenu = tbp.tc.getMenuFull();
 			else
 				mnuContext.subMenu = tbp.tc.getMenuSmall();
@@ -283,21 +273,17 @@
 
 	public void allowProfileChange(boolean profileChangeAllowed) {
 		if (profileChangeAllowed) {
-			mnuNewProfile.modifiers&=~MenuItem.Disabled;
-			mnuOpenProfile.modifiers&=~MenuItem.Disabled;
+			mnuNewProfile.modifiers &= ~MenuItem.Disabled;
+			mnuOpenProfile.modifiers &= ~MenuItem.Disabled;
 		} else {
-			mnuNewProfile.modifiers|=MenuItem.Disabled;
-			mnuOpenProfile.modifiers|=MenuItem.Disabled;
+			mnuNewProfile.modifiers |= MenuItem.Disabled;
+			mnuOpenProfile.modifiers |= MenuItem.Disabled;
 		}
 	}
 
-	public void setForceLogin() {
-		mnuForceLogin.modifiers=Global.getPref().forceLogin ? Global.mainTab.mnuMain.modifiers|MenuItem.Checked : Global.mainTab.mnuMain.modifiers&~MenuItem.Checked;
-	}
-
 	public static void search() {
-		SearchBox inp = new SearchBox(MyLocale.getMsg(119,"Search for:"));
-		String srch = inp.input(null,"",searchInDescriptionAndNotes,searchInLogs,10);
+		SearchBox inp = new SearchBox(MyLocale.getMsg(119, "Search for:"));
+		String srch = inp.input(null, "", searchInDescriptionAndNotes, searchInLogs, 10);
 		MyLocale.setSIPOff();
 		if (srch != null) {
 			searchInDescriptionAndNotes = inp.useNoteDesc();
@@ -307,332 +293,352 @@
 			Global.mainTab.tbP.refreshTable();
 		}
 	}
-	public void onEvent(Event ev){
-		Preferences pref=Global.getPref();
-		Profile profile=Global.getProfile();
-		CacheDB cacheDB=profile.cacheDB;
+
+	public void onEvent(Event ev) {
+		Preferences pref = Global.getPref();
+		Profile profile = Global.getProfile();
+		CacheDB cacheDB = profile.cacheDB;
 		Global.mainTab.updatePendingChanges();
-		if (ev instanceof MenuEvent){ //&& ev.type == MenuEvent.PRESSED
-			MenuEvent mev = (MenuEvent)ev;
-			///////////////////////////////////////////////////////////////////////
+		if (ev instanceof MenuEvent) { // && ev.type == MenuEvent.PRESSED
+			MenuEvent mev = (MenuEvent) ev;
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for profiles, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == mnuNewProfile){
-				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {
-					tbp.myMod.numRows=0;
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == mnuNewProfile) {
+				if (NewProfileWizard.startNewProfileWizard(getFrame())) {
+					tbp.myMod.numRows = 0;
 					pref.setCurCentrePt(profile.centre);
-		            filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+					filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 					tbp.refreshTable();
 				}
 			}
-			if(mev.selectedItem == mnuOpenProfile){
+			if (mev.selectedItem == mnuOpenProfile) {
 				Global.mainTab.saveUnsavedChanges(true);
-				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
-					tbp.myMod.sortedBy=-1;
-					tbp.myMod.numRows=0;
+				if (pref.selectProfile(profile, Preferences.PROFILE_SELECTOR_FORCED_ON, false)) {
+					tbp.myMod.sortedBy = -1;
+					tbp.myMod.numRows = 0;
 					CacheHolder.removeAllDetails();
 					profile.cacheDB.clear();
-					InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
+					InfoBox infB = new InfoBox("CacheWolf", MyLocale.getMsg(5000, "Loading Cache-List"));
 					infB.exec();
 					infB.waitUntilPainted(1000);
 					Vm.showWait(infB, true);
 					profile.readIndex(infB);
 					Vm.showWait(infB, false);
 					pref.setCurCentrePt(profile.centre);
-                    filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
-        			Global.mainForm.setTitle(profile.name + " - CW "+Version.getRelease());
+					filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
+					Global.mainForm.setTitle(profile.name + " - CW " + Version.getRelease());
 					infB.close(0);
 					tbp.resetModel();
 				}
 			}
-			if(mev.selectedItem == mnuDeleteProfile) {
-				pref.editProfile(2,227,226);
+			if (mev.selectedItem == mnuDeleteProfile) {
+				pref.editProfile(2, 227, 226);
 			}
-			if(mev.selectedItem == mnuRenameProfile) {
-				pref.editProfile(3,228,229);
+			if (mev.selectedItem == mnuRenameProfile) {
+				pref.editProfile(3, 228, 229);
 			}
-			if(mev.selectedItem == mnuEditCenter){
-				ProfileDataForm f=new ProfileDataForm(pref,profile);
+			if (mev.selectedItem == mnuEditCenter) {
+				ProfileDataForm f = new ProfileDataForm(pref, profile);
 				f.execute(getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 				f.close(0);
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for import, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == spider){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == spider) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doIt();
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == spiderRoute){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			if (mev.selectedItem == spiderRoute) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doItAlongARoute();
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == spiderQuick){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			if (mev.selectedItem == spiderQuick) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doItQuickFillFromMapList();
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == spiderAllFinds){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			if (mev.selectedItem == spiderAllFinds) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doIt(true);
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == loadGCVotes){
-                GCVoteImporter sGCV = new GCVoteImporter(pref, profile, true);
-                sGCV.doIt();
-                tbp.resetModel();
+			if (mev.selectedItem == loadGCVotes) {
+				if (sGCV == null)
+					sGCV = new GCVoteImporter(pref, profile);
+				sGCV.doIt();
+				tbp.resetModel();
 			}
-			if(mev.selectedItem == loadcaches){
+			if (mev.selectedItem == fetchOCLink) {
+				OCLinkImporter.doIt();
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == loadcaches) {
 				String dir = pref.getImporterPath("LocGpxImporter");
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN|FileChooserBase.MULTI_SELECT, dir);
+				FileChooser fc = new FileChooser(FileChooserBase.OPEN | FileChooserBase.MULTI_SELECT, dir);
 				fc.addMask("*.gpx,*.zip,*.loc,fieldnotes.txt,geocache_visits.txt,FieldNotes.log,newlogs.txt");
-				fc.setTitle(MyLocale.getMsg(909,"Select file(s)"));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.setTitle(MyLocale.getMsg(909, "Select file(s)"));
+				if (fc.execute() != FormBase.IDCANCEL) {
 					dir = fc.getChosenDirectory().toString();
 					pref.setImporterPath("LocGpxImporter", dir);
 					String files[] = fc.getAllChosen();
 					int how = GPXImporter.DOIT_ASK;
-					for (int i = 0; i < files.length; i++){
+					for (int i = 0; i < files.length; i++) {
 						String file = dir + "/" + files[i];
-						if (file.endsWith("txt")||file.endsWith("log")){
-							FieldnotesImporter fn=new FieldnotesImporter(pref, profile, file);
+						if (file.endsWith("txt") || file.endsWith("log")) {
+							FieldnotesImporter fn = new FieldnotesImporter(pref, profile, file);
 							fn.doIt();
-						}
-						else if (file.endsWith("loc")){
+						} else if (file.endsWith("loc")) {
 							LOCXMLImporter loc = new LOCXMLImporter(pref, profile, file);
 							loc.doIt();
-						}
-						else { //gpx + zip
+						} else { // gpx + zip
 							GPXImporter gpx = new GPXImporter(pref, profile, file);
 							gpx.doIt(how);
 							how = gpx.getHow();
 						}
 					}
 				}
-                Global.getProfile().setShowBlacklisted(false);
-                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == loadOC){
-				OCXMLImporter oc = new OCXMLImporter(pref,profile);
+			if (mev.selectedItem == loadOC) {
+				OCXMLImporter oc = new OCXMLImporter(pref, profile);
 				oc.doIt();
-                Global.getProfile().setShowBlacklisted(false);
-                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				tbp.resetModel();
 			}
-			if (mev.selectedItem == update)
+			if (mev.selectedItem == loadOCFinds) {
+				OCGPXfetch.doIt();
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == update) {
 				updateSelectedCaches(tbp);
-			if(mev.selectedItem == mnuForceLogin) {
-				mnuForceLogin.modifiers^=MenuItem.Checked;
-				Global.getPref().forceLogin=(mnuForceLogin.modifiers&MenuItem.Checked)!=0;
+				pref.setOldGCLanguage();
+			}
+			if (mev.selectedItem == mnuForceLogin) {
+				mnuForceLogin.modifiers ^= MenuItem.Checked;
+				Global.getPref().forceLogin = (mnuForceLogin.modifiers & MenuItem.Checked) != 0;
 				Global.getPref().savePreferences();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for export, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == exporthtml){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == exporthtml) {
 				HTMLExporter htm = new HTMLExporter(pref, profile);
 				htm.doIt();
 			}
-			if(mev.selectedItem == exportGpxNg){
+			if (mev.selectedItem == exportGpxNg) {
 				GpxExportNg gpx = new GpxExportNg();
 				gpx.doit();
 			}
-			if(mev.selectedItem == exporttop50){
+			if (mev.selectedItem == exporttop50) {
 				OVLExporter ovl = new OVLExporter(pref, profile);
 				ovl.doIt();
 			}
-			if(mev.selectedItem == exportASC){
-				ASCExporter asc = new ASCExporter(pref,profile);
+			if (mev.selectedItem == exportASC) {
+				ASCExporter asc = new ASCExporter(pref, profile);
 				asc.doIt();
 			}
-			if(mev.selectedItem == exportTomTom){
+			if (mev.selectedItem == exportTomTom) {
 				TomTomExporter tt = new TomTomExporter();
 				tt.doIt();
 			}
-			if(mev.selectedItem == exportMSARCSV){
-				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
+			if (mev.selectedItem == exportMSARCSV) {
+				MSARCSVExporter msar = new MSARCSVExporter(pref, profile);
 				msar.doIt();
 			}
-			if(mev.selectedItem == exportLOC){
+			if (mev.selectedItem == exportLOC) {
 				LocExporter loc = new LocExporter();
 				loc.doIt();
 			}
-			if(mev.selectedItem == exportGPS){
+			if (mev.selectedItem == exportGPS) {
 				String gpsBabelCommand;
 				Vm.showWait(true);
 				LocExporter loc = new LocExporter();
-				//String tmpFileName = FileBase.getProgramDirectory() + "/temp.loc";
-                //Must not contain special characters, because we don't quote below, because quoting causes problems on some platforms.
-				//Find another way, when CW can be started from outside the program directory.
+				// String tmpFileName = FileBase.getProgramDirectory() + "/temp.loc";
+				// Must not contain special characters, because we don't quote below, because quoting causes problems on some platforms.
+				// Find another way, when CW can be started from outside the program directory.
 				String tmpFileName = "temp.loc";
 				loc.setTmpFileName(tmpFileName);
 				loc.doIt(LocExporter.MODE_AUTO);
-				ProgressBarForm.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
-				gpsBabelCommand = pref.gpsbabel+" "+pref.garminGPSBabelOptions+" -i geo -f "+ tmpFileName +" -o garmin -F " + pref.garminConn +":";
-				pref.log("[MainMenu:onEvent] "+gpsBabelCommand);
+				ProgressBarForm.display(MyLocale.getMsg(950, "Transfer"), MyLocale.getMsg(951, "Sending to GPS"), null);
+				gpsBabelCommand = pref.gpsbabel + " " + pref.garminGPSBabelOptions + " -i geo -f " + tmpFileName + " -o garmin -F " + pref.garminConn + ":";
+				pref.log("[MainMenu:onEvent] " + gpsBabelCommand);
 				try {
 					// this will *only* work with ewe.jar at the moment
-					ewe.sys.Process p = Vm.exec( gpsBabelCommand );
+					ewe.sys.Process p = Vm.exec(gpsBabelCommand);
 					p.waitFor();
-				}catch(IOException ioex){
+				} catch (IOException ioex) {
 					Vm.showWait(false);
 					(new MessageBox("Error", "Garmin export unsuccessful", FormBase.OKB)).execute();
-					pref.log("Error exporting to Garmin",ioex,true);
-				};
+					pref.log("Error exporting to Garmin", ioex, true);
+				}
+				;
 				ProgressBarForm.clear();
 				Vm.showWait(false);
 			}
-			if(mev.selectedItem == exportOZI){
-				OziExporter ozi = new OziExporter( pref, profile);
+			if (mev.selectedItem == exportOZI) {
+				OziExporter ozi = new OziExporter(pref, profile);
 				ozi.doIt();
 			}
-			if(mev.selectedItem == exportKML){
-				KMLExporter kml = new KMLExporter( pref, profile);
+			if (mev.selectedItem == exportKML) {
+				KMLExporter kml = new KMLExporter(pref, profile);
 				kml.doIt();
 			}
-			if(mev.selectedItem == exportTPL){
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN, FileBase.getProgramDirectory()+FileBase.separator+"templates");
+			if (mev.selectedItem == exportTPL) {
+				FileChooser fc = new FileChooser(FileChooserBase.OPEN, FileBase.getProgramDirectory() + FileBase.separator + "templates");
 				fc.addMask("*.tpl");
-				fc.setTitle(MyLocale.getMsg(910,"Select Template file"));
-				if(fc.execute() != FormBase.IDCANCEL){
-					TPLExporter tpl = new TPLExporter( pref, profile, fc.getChosenFile().toString());
+				fc.setTitle(MyLocale.getMsg(910, "Select Template file"));
+				if (fc.execute() != FormBase.IDCANCEL) {
+					TPLExporter tpl = new TPLExporter(pref, profile, fc.getChosenFile().toString());
 					tpl.doIt();
 				}
 			}
-			if(mev.selectedItem == exportExplorist) {
-				ExploristExporter mag = new ExploristExporter( pref, profile);
+			//
+			if (mev.selectedItem == exportOCLog) {
+				OCLogExport.doit();
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == exportExplorist) {
+				ExploristExporter mag = new ExploristExporter(pref, profile);
 				mag.doIt();
 			}
-			if(mev.selectedItem == exportSpoilerPOI) {
-				SpoilerPOIExporter spoilerpoi = new SpoilerPOIExporter( pref, profile);
+			if (mev.selectedItem == exportSpoilerPOI) {
+				SpoilerPOIExporter spoilerpoi = new SpoilerPOIExporter(pref, profile);
 				spoilerpoi.doIt();
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for maps, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == downloadmap){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == downloadmap) {
 				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
 				mLG.exec(); // .execute doesn't work because the tcp-socket uses another thread which cannot be startet if here .execute() is used!
 			}
-			if(mev.selectedItem == importmap){
+			if (mev.selectedItem == importmap) {
 
 				MapImporter map = new MapImporter(pref);
 				map.importMap();
 			}
-			if(mev.selectedItem == kalibmap){
+			if (mev.selectedItem == kalibmap) {
 				SelectMap sM = new SelectMap();
 				sM.execute();
-				if((sM.getSelectedMap()).length()>0){
+				if ((sM.getSelectedMap()).length() > 0) {
 					try {
-						MapImporter map = new MapImporter(pref, sM.getSelectedMap(),sM.worldfileexists);
+						MapImporter map = new MapImporter(pref, sM.getSelectedMap(), sM.worldfileexists);
 						map.execute(null, Gui.CENTER_FRAME);
 					} catch (java.lang.OutOfMemoryError e) {
-						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(156,"Out of memory error, map to big"), FormBase.OKB);
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(156, "Out of memory error, map to big"), FormBase.OKB);
 						tmpMB.exec();
 					}
 				}
 			}
-			if (mev.selectedItem==selectMapPath) {
+			if (mev.selectedItem == selectMapPath) {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 				fc.addMask("*.wfl");
-				fc.setTitle(MyLocale.getMsg(4200,"Select map directory:"));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.setTitle(MyLocale.getMsg(4200, "Select map directory:"));
+				if (fc.execute() != FormBase.IDCANCEL) {
 					Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
-					//mm.loadMaps(Global.getPref().getCustomMapsPath(), mm.posCircle.where.latDec);
-					//mm.forceMapLoad();
+					// mm.loadMaps(Global.getPref().getCustomMapsPath(), mm.posCircle.where.latDec);
+					// mm.forceMapLoad();
 				}
 
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Application" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == preferences){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == preferences) {
 				tbp.saveColWidth(pref);
 				PreferencesScreen pfs = new PreferencesScreen(pref);
 				pfs.execute(father.getFrame(), Gui.CENTER_FRAME);
 				pref.readPrefFile();
 			}
-			if(mev.selectedItem == savenoxit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == savenoxit) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWidth(pref);
 			}
-/*
-			if(mev.selectedItem == savenexit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-				tbp.saveColWidth(pref);
-				ewe.sys.Vm.exit(0);
-			}
-*/
-			if(mev.selectedItem == exit){
+			/*
+			 * if(mev.selectedItem == savenexit){ profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR); tbp.saveColWidth(pref); ewe.sys.Vm.exit(0); }
+			 */
+			if (mev.selectedItem == exit) {
 				Global.mainTab.saveUnsavedChanges(true);
 				ewe.sys.Vm.exit(0);
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Search" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == search){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == search) {
 				search();
 			}
-			if(mev.selectedItem == searchAll){
+			if (mev.selectedItem == searchAll) {
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
 				tbp.refreshTable();
-                search();
+				search();
 			}
-			if(mev.selectedItem == searchClr){
+			if (mev.selectedItem == searchClr) {
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
 				tbp.refreshTable();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Filter" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == filtApply){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == filtApply) {
 				Filter flt = new Filter();
 				flt.setFilter();
 				flt.doFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtCreate){
+			if (mev.selectedItem == filtCreate) {
 				scnFilter.setData(profile.getCurrentFilter());
 				scnFilter.setPreferredSize(450, 480);
-				if(Vm.isMobile()) scnFilter.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight()); //Fullscreen
+				if (Vm.isMobile())
+					scnFilter.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight()); // Fullscreen
 				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtInvert){
+			if (mev.selectedItem == filtInvert) {
 				Filter flt = new Filter();
 				flt.invertFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtClear){
+			if (mev.selectedItem == filtClear) {
 				Filter flt = new Filter();
 				flt.clearFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtSelected){ // incremental filter
+			if (mev.selectedItem == filtSelected) { // incremental filter
 				Global.getProfile().selectionChanged = true;
 				CacheHolder ch;
 				boolean filterChanged = false;
-				for(int i = cacheDB.size()-1; i>=0; i--){
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					ch = cacheDB.get(i);
 					// This is an incremental filter, i.e. it keeps the existing filter
 					// status and only adds the marked caches to the filtered set
@@ -641,16 +647,16 @@
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+				if (filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
 					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
-			if (mev.selectedItem == filtNonSelected){
+			if (mev.selectedItem == filtNonSelected) {
 				Global.getProfile().selectionChanged = true;
 				CacheHolder ch;
 				boolean filterChanged = false;
-				for(int i = cacheDB.size()-1; i >=0; i--){
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					ch = cacheDB.get(i);
 					// incremental filter. Keeps status of all marked caches and
 					// adds unmarked caches to filtered list
@@ -659,102 +665,104 @@
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+				if (filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
 					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtBlack){
-				//filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
+			if (mev.selectedItem == filtBlack) {
+				// filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
 				Global.getProfile().setShowBlacklisted(!Global.getProfile().showBlacklisted());
-				filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();// Clear search & restore filter status
 				tbp.refreshTable();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Organise" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == orgNewWP){
-				if (Global.mainTab.tbP.getSelectedCache() >= 0) 
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == orgNewWP) {
+				if (Global.mainTab.tbP.getSelectedCache() >= 0)
 					Global.mainTab.lastselected = cacheDB.get(Global.mainTab.tbP.getSelectedCache()).getWayPoint();
-				else Global.mainTab.lastselected = "";
+				else
+					Global.mainTab.lastselected = "";
 				Global.mainTab.newWaypoint(new CacheHolder());
 			}
 
-			if(mev.selectedItem == orgCopy){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgCopy) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.copyCaches();
 				tbp.refreshTable();
 			}
 
-			if(mev.selectedItem == orgMove){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgMove) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.moveCaches();
 				tbp.refreshTable();
 			}
 
-			if(mev.selectedItem == orgDelete){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgDelete) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgRebuild){
-				Rebuild rb=new Rebuild();
+			if (mev.selectedItem == orgRebuild) {
+				Rebuild rb = new Rebuild();
 				rb.rebuild();
 				profile.updateBearingDistance();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgCheckNotesAndSolver){
+			if (mev.selectedItem == orgCheckNotesAndSolver) {
 				// Checking every cache if notes or solver data exist
-				CWProgressBar cwp = new CWProgressBar(MyLocale.getMsg(219,"Searching..."), 0, cacheDB.size(), true);
+				CWProgressBar cwp = new CWProgressBar(MyLocale.getMsg(219, "Searching..."), 0, cacheDB.size(), true);
 				cwp.exec();
 				cwp.allowExit(true);
-				for(int i = 0;i < cacheDB.size();i++){
+				for (int i = 0; i < cacheDB.size(); i++) {
 					cwp.setPosition(i);
 					CacheHolder ch = cacheDB.get(i);
-					if (ch.mainCache==null) {
+					if (ch.mainCache == null) {
 						ch.setHasNote(!ch.getCacheDetails(false).getCacheNotes().equals(""));
 						ch.setHasSolver(!ch.getCacheDetails(false).getSolver().equals(""));
 					}
-					if (cwp.isClosed()) break;
+					if (cwp.isClosed())
+						break;
 				} // for
 				cwp.exit(0);
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgTravelbugs){
-				TravelbugJourneyScreen tbs=new TravelbugJourneyScreen();
-				tbs.setPreferredSize(800,600);
-				tbs.execute(); //getFrame(), Gui.CENTER_FRAME);
+			if (mev.selectedItem == orgTravelbugs) {
+				Form tbs = TravelbugJourneyScreenFactory.createTravelbugJourneyScreen();
+				tbs.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
+				tbs.execute();
 				tbs.close(0);
 			}
-			if(mev.selectedItem == cacheTour){
-				cacheTour.modifiers^=MenuItem.Checked;
+			if (mev.selectedItem == cacheTour) {
+				cacheTour.modifiers ^= MenuItem.Checked;
 				Global.mainForm.toggleCacheListVisible();
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "About" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == about){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("info.html"), MyLocale.getMsg(117,"About"),true, pref);
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == about) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("info.html"), MyLocale.getMsg(117, "About"), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == legend){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("legende.html"), MyLocale.getMsg(155,"Legend"),true, pref);
+			if (mev.selectedItem == legend) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("legende.html"), MyLocale.getMsg(155, "Legend"), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == wolflang){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("wolflang.html"), MyLocale.getMsg(118,"WolfLanguage"), true, pref);
+			if (mev.selectedItem == wolflang) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("wolflang.html"), MyLocale.getMsg(118, "WolfLanguage"), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == sysinfo){
-				StringBuffer sb=new StringBuffer(400);
+			if (mev.selectedItem == sysinfo) {
+				StringBuffer sb = new StringBuffer(400);
 				Font f = mApp.guiFont;
-				sb.append(MyLocale.getMsg(121,"Profile"));
+				sb.append(MyLocale.getMsg(121, "Profile"));
 				sb.append(": ");
 				sb.append(profile.dataDir);
 				sb.append("<br>");
@@ -781,21 +789,22 @@
 				sb.append(MyLocale.getMsg(265, "Screen:"));
 				sb.append(' ');
 				sb.append(MyLocale.getScreenWidth());
-				sb.append(" x ");	 sb.append(MyLocale.getScreenHeight());
+				sb.append(" x ");
+				sb.append(MyLocale.getScreenHeight());
 				sb.append("<br>");
 				sb.append(MyLocale.getMsg(266, "Font size:"));
 				sb.append(' ');
 				sb.append(f.getSize());
 				sb.append("<br>");
 				sb.append(MyLocale.getMsg(267, "Entries in DB:"));
-				sb.append (' ');
+				sb.append(' ');
 				sb.append(cacheDB.size());
 				sb.append("<br>");
-				sb.append(MyLocale.getMsg (268, "File separator is:"));
-				sb.append (" \"");
-				sb.append(Vm.getProperty("file.separator","def"));
+				sb.append(MyLocale.getMsg(268, "File separator is:"));
+				sb.append(" \"");
+				sb.append(Vm.getProperty("file.separator", "def"));
 				sb.append("\"<br>");
-				sb.append(MyLocale.getMsg (269, "Programme directory is:"));
+				sb.append(MyLocale.getMsg(269, "Programme directory is:"));
 				sb.append(' ');
 				sb.append(FileBase.getProgramDirectory());
 				sb.append("<br>");
@@ -811,11 +820,11 @@
 				sb.append(' ');
 				sb.append(Version.getReleaseDetailed());
 				sb.append("<br>");
-				InfoScreen is = new InfoScreen(sb.toString(), "System", false,pref);
-				pref.log(STRreplace.replace(sb.toString(),"<br>",Preferences.NEWLINE),null);
+				InfoScreen is = new InfoScreen(sb.toString(), "System", false, pref);
+				pref.log(STRreplace.replace(sb.toString(), "<br>", Preferences.NEWLINE), null);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == chkVersion){
+			if (mev.selectedItem == chkVersion) {
 				(new MessageBox(MyLocale.getMsg(178, "Version Checking"), Version.getUpdateMessage(), FormBase.OKB)).execute();
 			}
 
@@ -831,15 +840,17 @@
 	}
 
 	public static void updateSelectedCaches(TablePanel tablePanel) {
-		Preferences pref=Global.getPref();
-		Profile profile=Global.getProfile();
-		CacheDB cacheDB=profile.cacheDB;
+		Preferences pref = Global.getPref();
+		Profile profile = Global.getProfile();
+		CacheDB cacheDB = profile.cacheDB;
 		CacheHolder ch;
 
-		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(1014,"updateSelectedCaches"), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.TRAVELBUGS| OCXMLImporterScreen.MAXLOGS| OCXMLImporterScreen.ALL);
-		if (options.execute() == FormBase.IDCANCEL) {	return; }
+		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(1014, "updateSelectedCaches"), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.ALL);
+		if (options.execute() == FormBase.IDCANCEL) {
+			return;
+		}
 
-		SpiderGC spider = new SpiderGC(pref, profile, false);
+		SpiderGC spider = new SpiderGC(pref, profile);
 		OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
 		Vm.showWait(true);
 		boolean alreadySaid = false;
@@ -850,27 +861,23 @@
 		boolean loadAllLogs = (pref.maxLogsToSpider > 5);
 
 		Vector cachesToUpdate = new Vector();
-		for(int i = 0; i <	cacheDB.size(); i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			if(ch.is_Checked == true && ch.isVisible()) {
-				String wpStart = ch.getWayPoint().substring(0,2);
-				if ( ch.getWayPoint().length()>1 && (wpStart.equalsIgnoreCase("GC") || ch.isOC()))
-//					Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
-//					Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+			if (ch.is_Checked == true && ch.isVisible()) {
+				// should work even if only the wayPoint is created
+				if ((ch.getWayPoint().toUpperCase().startsWith("GC") || ch.isOC()))
+				// Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+				// Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
 				{
 					cachesToUpdate.add(new Integer(i));
 				} else {
-					if (ch.isAddiWpt() && ch.mainCache!=null && !ch.mainCache.is_Checked && !alreadySaid2) { // Is the father ticked?
-						alreadySaid2=true;
-						(new MessageBox(MyLocale.getMsg(327,"Information"),
-								        MyLocale.getMsg(5001,"Can't spider additional waypoint directly. Please check main cache."), FormBase.OKB)).execute();
+					if (ch.isAddiWpt() && ch.mainCache != null && !ch.mainCache.is_Checked && !alreadySaid2) { // Is the father ticked?
+						alreadySaid2 = true;
+						(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(5001, "Can't spider additional waypoint directly. Please check main cache."), FormBase.OKB)).execute();
 					}
 					if (!ch.isAddiWpt() && !alreadySaid) {
 						alreadySaid = true;
-						(new MessageBox(MyLocale.getMsg(327,"Information"),
-					        ch.getWayPoint()+ MyLocale.getMsg(5002,
-					        	": At the moment this function is only applicable for geocaching.com and opencaching.de/.cz/.org.uk ."),
-					        FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(327, "Information"), ch.getWayPoint() + MyLocale.getMsg(5002, ": At the moment this function is only applicable for geocaching.com and opencaching.de/.cz/.org.uk ."), FormBase.OKB)).execute();
 					}
 				}
 
@@ -878,14 +885,14 @@
 		}
 
 		int spiderErrors = 0;
-		boolean forceLogin=Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
-		for(int j = 0; j <	cachesToUpdate.size(); j++){
-			int i = ((Integer)cachesToUpdate.get(j)).intValue();
+		boolean forceLogin = Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
+		for (int j = 0; j < cachesToUpdate.size(); j++) {
+			int i = ((Integer) cachesToUpdate.get(j)).intValue();
 			ch = cacheDB.get(i);
-//			infB.setInfo("Loading: " + ch.wayPoint);
-			infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.getWayPoint() +" (" + (j+1) + " / " + cachesToUpdate.size() + ")");
+			// infB.setInfo("Loading: " + ch.wayPoint);
+			infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + ch.getWayPoint() + " (" + (j + 1) + " / " + cachesToUpdate.size() + ")");
 			infB.redisplay();
-			if (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) {
+			if (ch.getWayPoint().substring(0, 2).equalsIgnoreCase("GC")) {
 				int test = spider.spiderSingle(i, infB, forceLogin, loadAllLogs || ch.is_found());
 				if (test == SpiderGC.SPIDER_CANCEL) {
 					infB.close(0);
@@ -893,30 +900,29 @@
 				} else if (test == SpiderGC.SPIDER_ERROR) {
 					spiderErrors++;
 				} else {
-					//profile.hasUnsavedChanges=true;
+					// profile.hasUnsavedChanges=true;
 				}
-				forceLogin=false;
-			}
-			else {
+				forceLogin = false;
+			} else {
 				if (!ocSync.syncSingle(i, infB)) {
 					infB.close(0);
 					break;
 				} else {
-					//profile.hasUnsavedChanges=true;
+					// profile.hasUnsavedChanges=true;
 				}
 			}
 
-//			cacheDB.clear();
-//			profile.readIndex();
+			// cacheDB.clear();
+			// profile.readIndex();
 		}
 		infB.close(0);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 		profile.restoreFilter();
 		profile.updateBearingDistance();
 		tablePanel.refreshTable();
 		Vm.showWait(false);
-		if ( spiderErrors > 0) {
-			new MessageBox(MyLocale.getMsg(5500,"Error"),spiderErrors + MyLocale.getMsg(5516," cache descriptions%0acould not be loaded."),FormBase.DEFOKB).execute();
+		if (spiderErrors > 0) {
+			new MessageBox(MyLocale.getMsg(5500, "Error"), spiderErrors + MyLocale.getMsg(5516, " cache descriptions%0acould not be loaded."), FormBase.DEFOKB).execute();
 		}
 	}
 

Modified: branches/r1.2/src/CacheWolf/MainTab.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainTab.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MainTab.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.GotoPanel;
@@ -41,90 +41,133 @@
 import ewe.ui.mTabbedPanel;
 
 /**
- *	This class creates the tabbed panel and sets the tabs to the respective
- *	other panels. Important is to have a look at the event handler!<br>
- *	Class ID = 1200
- *	@see MainForm
- *	@see MainMenu
+ * This class creates the tabbed panel and sets the tabs to the respective other panels. Important is to have a look at
+ * the event handler!<br>
+ * Class ID = 1200
+ * 
+ * @see MainForm
+ * @see MainMenu
  */
 public class MainTab extends mTabbedPanel {
-	DescriptionPanel descP= new DescriptionPanel();
+	static int LIST_CARD;
+	static int DETAILS_CARD;
+	static int DESCRIPTION_CARD;
+	static int IMAGES_CARD;
+	static int HINTSANDLOGS_CARD;
+	static int SOLVER_CARD;
+	static int CALC_CARD;
+	static int GOTO_CARD;
+	static int RADAR_CARD;
+	static int MAP_CARD;
+
+	TableForm listP;
+	public DetailsPanel detP = new DetailsPanel();
+	DescriptionPanel descP = new DescriptionPanel();
 	HintLogPanel hintLP = new HintLogPanel();
 	public TablePanel tbP;
-	CacheDB cacheDB;
-	public DetailsPanel detP = new DetailsPanel();
 	CalcPanel calcP;
-	Preferences pref;
-	Profile profile;
 	GotoPanel gotoP;
 	RadarPanel radarP = new RadarPanel();
 	ImagePanel imageP;
 	SolverPanel solverP;
+	ewe.ui.CellPanel mapP;
+
+	Preferences pref;
+	Profile profile;
+
+	CacheDB cacheDB;
 	String lastselected = "";
-	public CacheHolder ch=null, chMain=null;
-	CacheHolderDetail chD =null;
+	public CacheHolder ch = null, chMain = null;
+	CacheHolderDetail chD = null;
 	MainMenu mnuMain;
+
 	public StatusBar statBar;
 	public MovingMap mm;
 	public Navigate nav;
-	public String mainCache="";
-	int oldCard=0;
-	boolean cacheDirty=false;
+	public String mainCache = "";
+	int oldCard;
+	boolean cacheDirty = false;
 
-	public MainTab(MainMenu mainMenu,StatusBar statBar){
-		Global.mainTab=this;
-		mnuMain=mainMenu;
+	public MainTab(MainMenu mainMenu, StatusBar statBar) {
+		// Init here so that Global.MainT is already set
+		Global.mainTab = this;
+		mnuMain = mainMenu;
 		pref = Global.getPref();
-		profile=Global.getProfile();
-		if (!pref.tabsAtTop) tabLocation=SOUTH;
+		profile = Global.getProfile();
+		if (!pref.tabsAtTop)
+			tabLocation = SOUTH;
 		cacheDB = profile.cacheDB;
-		this.statBar=statBar;
+		this.statBar = statBar;
 		MyLocale.setSIPButton();
-		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
+		// Don't expand tabs if the screen is very narrow, i.e. HP IPAQ
+		// 65xx, 69xx
 		int sw = MyLocale.getScreenWidth();
-		if ( sw <= 240) this.dontExpandTabs=true;
-		String imagesize="";
-		if (pref.useBigIcons) imagesize="_vga";
-		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
+		if (sw <= 480)
+			this.dontExpandTabs = true;
+		String imagesize = "";
+		if (pref.useBigIcons)
+			imagesize = "_vga";
+
 		tbP = new TablePanel(pref, profile, statBar);
-		Card c = this.addCard(new TableForm(tbP), MyLocale.getMsg(1200,"List"), null);
+		Card c = this.addCard(listP = new TableForm(tbP), MyLocale.getMsg(1200, "List"), null);
+		LIST_CARD = this.cardPanel.cards.size() - 1;
+		oldCard = LIST_CARD;
 
-		c = this.addCard(detP, MyLocale.getMsg(1201,"Details"), null);
-		c.iconize(new Image("details"+imagesize+".gif"),true);
+		c = this.addCard(detP, MyLocale.getMsg(1201, "Details"), null);
+		DETAILS_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image("details" + imagesize + ".gif"), true);
 
-		c = this.addCard(descP, MyLocale.getMsg(1202,"Description"), null);
-		c.iconize(new Image("descr"+imagesize+".gif"),true);
+		c = this.addCard(descP, MyLocale.getMsg(1202, "Description"), null);
+		DESCRIPTION_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image("descr" + imagesize + ".gif"), true);
 
-		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203,"Images"), null);
-		c.iconize(new Image("images"+imagesize+".gif"),true);
+		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203, "Images"), null);
+		IMAGES_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image("images" + imagesize + ".gif"), true);
 
-		c = this.addCard(hintLP, MyLocale.getMsg(1204,"Hints & Logs"), null);
-		c.iconize(new Image("more"+imagesize+".gif"),true);
+		c = this.addCard(hintLP, MyLocale.getMsg(1204, "Hints & Logs"), null);
+		HINTSANDLOGS_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image("more" + imagesize + ".gif"), true);
 
-		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205,"Solver"), null);
-		c.iconize(new Image("solver"+imagesize+".gif"),true);
+		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205, "Solver"), null);
+		SOLVER_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image("solver" + imagesize + ".gif"), true);
 
-		c = this.addCard(calcP, MyLocale.getMsg(1206,"Calc"), null);
-		mImage imgCalc=new mImage("projecttab"+imagesize+".gif"); imgCalc.transparentColor=new Color(0,255,0);
-		c.iconize(imgCalc,true);
+		c = this.addCard(calcP = new CalcPanel(), MyLocale.getMsg(1206, "Calc"), null);
+		CALC_CARD = this.cardPanel.cards.size() - 1;
+		mImage imgCalc = new mImage("projecttab" + imagesize + ".gif");
+		imgCalc.transparentColor = new Color(0, 255, 0);
+		c.iconize(imgCalc, true);
 
 		nav = new Navigate();
-		c = this.addCard(gotoP = new GotoPanel(nav), "Goto", null);
-		c.iconize(new Image("goto"+imagesize+".gif"),true);
+		c = this.addCard(gotoP = new GotoPanel(nav), MyLocale.getMsg(345, "Goto these coordinates"), null);
+		GOTO_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image("goto" + imagesize + ".gif"), true);
 		nav.setGotoPanel(gotoP);
 
-		c = this.addCard(radarP, "Radar", null);
-		radarP.setMainTab(this);
-		c.iconize(new Image("radar"+imagesize+".gif"),true);
+		if (pref.isBigScreen || !pref.useRadar) {
+			c = this.addCard(mapP = new ewe.ui.CellPanel(), MyLocale.getMsg(347, "Show map"), null);
+			MAP_CARD = this.cardPanel.cards.size() - 1;
+			c.iconize(new Image("globe_small" + imagesize + ".gif"), true);
+		}
+
+		if (pref.isBigScreen || pref.useRadar) {
+			c = this.addCard(radarP, "Radar", null);
+			RADAR_CARD = this.cardPanel.cards.size() - 1;
+			radarP.setMainTab(this);
+			c.iconize(new Image("radar" + imagesize + ".gif"), true);
+		}
+
 		mnuMain.allowProfileChange(true);
-//		if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
+		// if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
 	}
 
-	public TablePanel getTablePanel(){
+	public TablePanel getTablePanel() {
 		return tbP;
 	}
 
-	public void selectAndActive(int rownum){// Called from myInteractivePanel.imageClicked
+	public void selectAndActive(int rownum) {// Called from
+		// myInteractivePanel.imageClicked
 		tbP.selectRow(rownum);
 		this.selectAndExpand(0);
 	}
@@ -138,79 +181,86 @@
 	}
 
 	public void onEvent(Event ev) {
-		// This section clears old data when a new line is selected in the table
+		// This section clears old data when a new line is selected in the
+		// table
 		if (ev instanceof TableEvent) {
 			clearDetails();
 		}
-		if(ev instanceof MultiPanelEvent){
-			// Check whether a profile change is allowed, if not disable the relevant options
+		if (ev instanceof MultiPanelEvent) {
+			// Check whether a profile change is allowed, if not disable the
+			// relevant options
 			checkProfileChange();
 			// Perform clean up actions for the panel we are leaving
 			onLeavingPanel(oldCard);
 			// Prepare actions for the panel we are about to enter
-			onEnteringPanel(((MultiPanelEvent)ev).selectedIndex);
-			oldCard=((MultiPanelEvent)ev).selectedIndex;
+			onEnteringPanel(((MultiPanelEvent) ev).selectedIndex);
 		}
-		super.onEvent(ev); //Make sure you call this.
-		// If we are in Listview update status
-//		if (this.getSelectedItem()==0 && statBar!=null) statBar.updateDisplay();
+		super.onEvent(ev); // Make sure you call this.
 	}
 
 	/**
 	 * Code to execute when leaving a panel (oldCard is the panel number)
-	 *
+	 * 
 	 */
 	private void onLeavingPanel(int panelNo) {
-		if (panelNo==0) { // Leaving the list view
+		if (panelNo == MainTab.LIST_CARD) { // Leaving the list view
 			// Get the cache for the current line (ch)
 			// Get the details for the current line (chD)
 			// If it is Addi get details of main Wpt (chMain)
-			chMain=null;
-			cacheDirty=false;
-			if (tbP.getSelectedCache()>=Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache()<0) {
-				ch=null;
-				chD=null;
-				lastselected="";
+			chMain = null;
+			cacheDirty = false;
+			if (tbP.getSelectedCache() >= Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache() < 0) {
+				ch = null;
+				chD = null;
+				lastselected = "";
 			} else {
 				ch = cacheDB.get(tbP.getSelectedCache());
-				lastselected=ch.getWayPoint();  // Used in Parser.Skeleton
+				lastselected = ch.getWayPoint(); // Used in
+				// Parser.Skeleton
 				chD = ch.getCacheDetails(true);
 			}
 		}
-		if (panelNo==1) { // Leaving the Details Panel
-			detP.evWaypointChanged=false;
+		if (panelNo == MainTab.DETAILS_CARD) { // Leaving the Details Panel
+			detP.evWaypointChanged = false;
 			// Update chD with Details
-			if(detP.isDirty()) {
-				cacheDirty=true;
+			if (detP.isDirty()) {
+				cacheDirty = true;
 				boolean needTableUpdate = detP.getNeedsTableUpdate();
 				detP.saveDirtyWaypoint();
 				if (needTableUpdate) {
-					tbP.myMod.updateRows();// This sorts the waypoint (if it is new) into the right position
+					tbP.myMod.updateRows();// This sorts the waypoint (if
+					// it is new) into the right
+					// position
 					tbP.selectRow(profile.getCacheIndex(detP.cache.getWayPoint()));
 				}
-				//was tbP.refreshTable();
+				// was tbP.refreshTable();
 				tbP.tc.update(true); // Update and repaint
-				if (statBar!=null) statBar.updateDisplay("");
+				if (statBar != null)
+					statBar.updateDisplay("");
 			}
 		}
-		if (panelNo==5) { // Leaving the Solver Panel
+		if (panelNo == MainTab.SOLVER_CARD) { // Leaving the Solver Panel
 			// Update chD or chMain with Solver
-			// If chMain is set (i.e. if it is an addi Wpt) save it immediately
-			if (chD!=null && solverP.isDirty()) {
-				if (chMain==null) {
-					cacheDirty=true;
+			// If chMain is set (i.e. if it is an addi Wpt) save it
+			// immediately
+			if (chD != null && solverP.isDirty()) {
+				if (chMain == null) {
+					cacheDirty = true;
 					boolean oldHasSolver = chD.getParent().hasSolver();
 					chD.setSolver(solverP.getInstructions());
-					if (oldHasSolver != chD.getParent().hasSolver()) tbP.tc.update(true);
-					// For safety reasons: Immediately save solver instructions when
+					if (oldHasSolver != chD.getParent().hasSolver())
+						tbP.tc.update(true);
+					// For safety reasons: Immediately save solver
+					// instructions when
 					// switching panels
 					updatePendingChanges();
 				} else {
 					boolean oldHasSolver = chMain.hasSolver();
 					chMain.getCacheDetails(true).setSolver(solverP.getInstructions());
-					if (oldHasSolver != chMain.hasSolver()) tbP.tc.update(true);
+					if (oldHasSolver != chMain.hasSolver())
+						tbP.tc.update(true);
 					chMain.save();
-					chMain=null;
+					chMain = null;
 				}
 			}
 		}
@@ -218,133 +268,145 @@
 
 	/**
 	 * Code to execute when entering a panel (getSelectedItem() is the panel number)
-	 *
+	 * 
 	 */
 	private void onEnteringPanel(int panelNo) {
-		switch (panelNo) {// Switch by panel number
-		case 0:  //MainPanel
-			MyLocale.setSIPOff();
+		MyLocale.setSIPOff();
+		if (panelNo == LIST_CARD) {
 			// If Solver or Details has changed, save Cache
 			updatePendingChanges();
 			if (detP.hasBlackStatusChanged()) {
 				tbP.refreshTable();
 			}
 			updateCurCentrePtFromGPS();
-			break;
-		case 1:  // DetailsPanel
+		} else if (panelNo == DETAILS_CARD) {
 			boolean newCache = false;
-			if (chD==null) { // Empty DB - show a dummy detail
-				newWaypoint(ch=new CacheHolder());
+			if (chD == null) { // Empty DB - show a dummy detail
+				newWaypoint(ch = new CacheHolder());
 				newCache = true;
 			}
-			MyLocale.setSIPOff();
 			detP.setDetails(ch, newCache);
-			break;
-		case 2: // Description Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == DESCRIPTION_CARD) {
 			descP.setText(ch);
-			break;
-		case 3: // Picture Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == IMAGES_CARD) {
 			if (ch.isAddiWpt()) {
 				imageP.setImages(ch.mainCache.getCacheDetails(true));
 			} else {
 				imageP.setImages(chD);
 			}
-			break;
-		case 4:  // Log Hint Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == HINTSANDLOGS_CARD) {
 			if (ch.isAddiWpt()) {
 				hintLP.setText(ch.mainCache.getCacheDetails(true));
 			} else {
 				hintLP.setText(chD);
 			}
-			break;
-		case 5:  // Solver Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == SOLVER_CARD) {
 			if (ch.isAddiWpt()) {
-				chMain=ch.mainCache;
+				chMain = ch.mainCache;
 				solverP.setInstructions(ch.mainCache);
 			} else {
 				solverP.setInstructions(ch);
 			}
-			break;
-		case 6:  // CalcPanel
-			MyLocale.setSIPOff();
-			if (ch != null) calcP.setFields(ch);
-			break;
-		case 7: // GotoPanel
-			MyLocale.setSIPOff();
-			break;
-		case 8:  // Cache Radar Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == CALC_CARD) {
+			if (ch != null)
+				calcP.setFields(ch);
+		} else if (panelNo == MAP_CARD) {
+			gotoP.switchToMovingMap();
+			if (oldCard == LIST_CARD) {
+				select(listP);
+			} else if (oldCard == DETAILS_CARD) {
+				select(detP);
+			} else if (oldCard == DESCRIPTION_CARD) {
+				select(descP);
+			} else if (oldCard == IMAGES_CARD) {
+				select(imageP);
+			} else if (oldCard == HINTSANDLOGS_CARD) {
+				select(hintLP);
+			} else if (oldCard == SOLVER_CARD) {
+				select(solverP);
+			} else if (oldCard == CALC_CARD) {
+				select(calcP);
+			} else if (oldCard == GOTO_CARD) {
+				select(gotoP);
+			} else if (oldCard == RADAR_CARD) {
+				select(radarP);
+			}
+		} else if (panelNo == RADAR_CARD) {
 			radarP.setParam(pref, cacheDB, ch);
 			radarP.drawThePanel();
 			updateCurCentrePtFromGPS();
-			break;
 		}
+		oldCard = panelNo;
 	}
+
 	/**
 	 * this is called from MovingMap Cache context menu
-	 * @param chi , the CacheHolder for the Cache to switch to
-	 * @param panelNo 1=DetailsPanel 2=Description Panel
+	 * 
+	 * @param chi
+	 *            ,
+	 *            the CacheHolder for the Cache to switch to
+	 * @param panelNo
+	 *            1=DetailsPanel 2=Description Panel
 	 */
 	public void openPanel(CacheHolder chi, int panelNo) {
-		MyLocale.setSIPOff();
-		// To change cache we need to be in panel 0
-		onLeavingPanel(oldCard); // is 7 or 1
-		onEnteringPanel(0); oldCard=0;
+		// To change cache we need to be in panel LIST_CARD
+		onLeavingPanel(oldCard);
+		onEnteringPanel(LIST_CARD);
 		int row = profile.getCacheIndex(chi.getWayPoint());
 		tbP.selectRow(row);
-	switch (panelNo) {// Switch by panel number
-		case 1:  // DetailsPanel
-			ch=chi; //possibly wrong (old) detail if map is called directly
-			onEnteringPanel(1);
-			oldCard=1;
+		if (panelNo == DETAILS_CARD) {
+			ch = chi; // possibly wrong (old) detail if map is called
+			// directly
+			onEnteringPanel(DETAILS_CARD);
 			select(detP);
-			break;
-		case 2: // Description Panel
+		} else if (panelNo == DESCRIPTION_CARD) {
+			onEnteringPanel(DESCRIPTION_CARD);
 			select(descP);
-			break;
-		}		
+		}
+
 	}
 
-
 	/**
-	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to
-	 * offer the user the possibility of entering an new waypoint
-	 * at a given position. pCh must already been preset with a valid
-	 * CacheHolder object
-	 *
+	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to offer the user the possibility of
+	 * entering an new waypoint at a given position. pCh must already been preset with a valid CacheHolder object
+	 * 
 	 * @param pCh
 	 */
-	public void newWaypoint(CacheHolder pCh){
-		//When creating a new waypoint, simulate a change to the list view
-		//if we are currently NOT in the list view
-		if (oldCard != 0)
-		{
+	public void newWaypoint(CacheHolder pCh) {
+		// When creating a new waypoint, simulate a change to the list view
+		// if we are currently NOT in the list view
+		if (oldCard != LIST_CARD) {
 			onLeavingPanel(oldCard);
 		}
 		updatePendingChanges(); // was: onEnteringPanel(0); oldCard=0;
 
-		mainCache=lastselected;
-		int selectedIndex = profile.getCacheIndex( lastselected );
+		mainCache = lastselected;
+		int selectedIndex = profile.getCacheIndex(lastselected);
 		if (selectedIndex >= 0) {
-			CacheHolder selectedCache = profile.cacheDB.get( selectedIndex );
-			if ( selectedCache.isAddiWpt() ) {
+			// why not using the target ???
+			CacheHolder selectedCache = profile.cacheDB.get(selectedIndex);
+			// try to start new waypoint with real coords
+			if (!pCh.getPos().isValid()) {
+				pCh.setPos(selectedCache.getPos());
+			}
+			if (selectedCache.isAddiWpt()) {
 				if (selectedCache.mainCache != null) {
 					mainCache = selectedCache.mainCache.getWayPoint();
+					// try to start new waypoint with real coords
+					if (!pCh.getPos().isValid()) {
+						pCh.setPos(selectedCache.mainCache.getPos());
+					}
 				} else {
 					mainCache = null;
 				}
 			}
 		}
-		if (CacheType.isAddiWpt(pCh.getType()) && mainCache!=null && mainCache.length()>2) {
+		if (CacheType.isAddiWpt(pCh.getType()) && mainCache != null && mainCache.length() > 2) {
 			pCh.setWayPoint(profile.getNewAddiWayPointName(mainCache));
 			profile.setAddiRef(pCh);
 		} else {
 			pCh.setWayPoint(profile.getNewWayPointName());
-			lastselected=pCh.getWayPoint();
+			lastselected = pCh.getWayPoint();
 		}
 		pCh.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 		chD = pCh.getCacheDetails(false);
@@ -353,18 +415,20 @@
 		Global.getProfile().notifyUnsavedChanges(true); // Just to be sure
 		tbP.myMod.numRows++;
 		detP.setDetails(pCh, true);
-		oldCard=1;
-		if (this.cardPanel.selectedItem != 1) select(detP);
+		oldCard = DETAILS_CARD;
+		if (this.cardPanel.selectedItem != 1)
+			select(detP);
 		solverP.setInstructions(pCh);
-		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
+		// tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
 	}
 
-
 	/**
 	 * sets posCircle Lat/Lon to centerTo
-	 *
-	 * @param centerTo true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the loaded map
+	 * 
+	 * @param centerTo
+	 *            true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the
+	 *            loaded map
 	 * @param forceCenter
 	 */
 	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
@@ -377,19 +441,29 @@
 				mm = new MovingMap(nav, profile.cacheDB);
 				nav.setMovingMap(mm);
 			}
-			
+
 			mm.myExec(centerTo, forceCenter);
-			
+
 			if (forceCenter) {
 				try {
 					int i = 0;
-					while (MapImage.screenDim.width == 0 && i < 10*60) { i++; ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
-					if (i >= 10*60) {(new MessageBox("Error", "MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de", FormBase.OKB)).execute(); return;}
-					//If white Areas are filled there is a problem with painting the image. We force painting here.
-					mm.repaint ();
-				}catch (InterruptedException e) {
+					while (MapImage.screenDim.width == 0 && i < 10 * 60) {
+						i++;
+						ewe.sys.mThread.sleep(100);
+					} // wait until the window size of the moving map is
+						// known note: ewe.sys.sleep() will pause the whole
+						// vm - no other thread will run
+					if (i >= 10 * 60) {
+						(new MessageBox("Error", "MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de", FormBase.OKB)).execute();
+						return;
+					}
+					// If white Areas are filled there is a problem with
+					// painting the image. We force painting here.
+					mm.repaint();
+				} catch (InterruptedException e) {
 					Global.getPref().log("Error starting mavoing map (1): ", e, true);
-					(new MessageBox("Error", "This must not happen please report to pfeffer how to produce this error message", FormBase.OKB)).execute(); }
+					(new MessageBox("Error", "This must not happen please report to pfeffer how to produce this error message", FormBase.OKB)).execute();
+				}
 			}
 		} catch (Exception e) { // TODO swith waiting indication clock off
 			Global.getPref().log("Error starting moving map (2): ", e, true);
@@ -405,39 +479,41 @@
 		}
 	}
 
-	/** Save the index file
-	 *
-	 * @param askForConfirmation is ignored, old: If true, the save can be cancelled by user
+	/**
+	 * Save the index file
+	 * 
+	 * @param askForConfirmation
+	 *            is ignored, old: If true, the save can be cancelled by user
 	 */
 	public void saveUnsavedChanges(boolean askForConfirmation) {
-		if (oldCard!=0) {
+		if (oldCard != LIST_CARD) {
 			onLeavingPanel(oldCard);
-			onEnteringPanel(0);
-			oldCard=0;
+			onEnteringPanel(LIST_CARD);
+			oldCard = LIST_CARD;
 		}
 		updatePendingChanges();
-		if (profile.hasUnsavedChanges()) profile.saveIndex(Global.getPref(),true);
-	    this.tbP.saveColWidth(pref);
+		if (profile.hasUnsavedChanges())
+			profile.saveIndex(Global.getPref(), true);
+		this.tbP.saveColWidth(pref);
 		Global.getPref().savePreferences();
 	}
 
 	private void checkProfileChange() {
 		// A panel is selected. Could be the same panel twice
 		mnuMain.allowProfileChange(false);
-		if(this.getSelectedItem() == 0){// List view selected
+		if (this.getSelectedItem() == 0) {// List view selected
 			mnuMain.allowProfileChange(true);
 			MyLocale.setSIPOff();
 		}
 	}
 
-	private void  updateCurCentrePtFromGPS() {
-		if (pref.setCurrentCentreFromGPSPosition){
+	private void updateCurCentrePtFromGPS() {
+		if (pref.setCurrentCentreFromGPSPosition) {
 			if (nav.gpsRunning) {
 				CWPoint whereAmI = nav.gpsPos;
 				if (whereAmI.isValid()) {
 					CWPoint curCentr = pref.getCurCentrePt();
-					if (whereAmI.latDec != curCentr.latDec ||
-						whereAmI.lonDec != curCentr.lonDec ) {
+					if (whereAmI.latDec != curCentr.latDec || whereAmI.lonDec != curCentr.lonDec) {
 						pref.setCurCentrePt(whereAmI);
 					}
 				}
@@ -447,7 +523,3 @@
 }
 //
 
-
-
-
-

Modified: branches/r1.2/src/CacheWolf/MyComparer.java
===================================================================
--- branches/r1.2/src/CacheWolf/MyComparer.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MyComparer.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,183 +1,189 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.util.Comparer;
 import ewe.util.Vector;
 
 /**
-*	This class handles the sorting for most of the sorting tasks. If a cache is 
-*	to be displayed in the table or not is handled in the table model
-*	@see MyTableModel
-*	@see DistComparer
-*/
-public class MyComparer implements Comparer{
+ * This class handles the sorting for most of the sorting tasks. If a cache is to be displayed in the table or not is handled in the table model
+ * 
+ * @see MyTableModel
+ * @see DistComparer
+ */
+public class MyComparer implements Comparer {
 	Vector cacheDB;
-	
-	public MyComparer(CacheDB cacheDB, int colToCompare, int visibleSize){
-		//visibleSize=Global.mainTab.tbP.myMod.numRows;
-		if (visibleSize<2) return;
-		for (int i=visibleSize; i<cacheDB.size(); i++) {
-			CacheHolder ch=cacheDB.get(i);
-			ch.sort="\uFFFF";
+
+	public MyComparer(CacheDB cacheDB, int colToCompare, int visibleSize) {
+		// visibleSize=Global.mainTab.tbP.myMod.numRows;
+		if (visibleSize < 2)
+			return;
+		for (int i = visibleSize; i < cacheDB.size(); i++) {
+			CacheHolder ch = cacheDB.get(i);
+			ch.sort = "\uFFFF";
 		}
-		if (colToCompare==1) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getType());
+		if (colToCompare == 1) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getType());
 			}
-		} else if (colToCompare==2) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getHard());
+		} else if (colToCompare == 2) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getHard());
 			}
-		} else if (colToCompare==3) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getTerrain());
+		} else if (colToCompare == 3) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getTerrain());
 			}
-		} else if (colToCompare==4) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getWayPoint().toUpperCase();
+		} else if (colToCompare == 4) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getWayPoint().toUpperCase();
 			}
-		} else if (colToCompare==5) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheName().trim().toLowerCase();
+		} else if (colToCompare == 5) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheName().trim().toLowerCase();
 			}
-		} else if (colToCompare==6) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getLatLon();
+		} else if (colToCompare == 6) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getPos().toString();
 			}
-		} else if (colToCompare==7) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheOwner().toLowerCase();
+		} else if (colToCompare == 7) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheOwner().toLowerCase();
 			}
-		} else if (colToCompare==8) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getDateHidden();
+		} else if (colToCompare == 8) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getDateHidden();
 			}
-		} else if (colToCompare==9) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheStatus();
+		} else if (colToCompare == 9) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheStatus();
 			}
-		} else if (colToCompare==10) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
+		} else if (colToCompare == 10) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
 				// CHECK Is the formatting correctly done?
-				if (ch.kilom==-1.0) {
-					ch.sort="\uFFFF";
+				if (ch.kilom == -1.0) {
+					ch.sort = "\uFFFF";
+				} else {
+					ch.sort = MyLocale.formatDouble(ch.kilom * 1000, "000000000000");
 				}
-				else {
-					ch.sort = MyLocale.formatDouble(ch.kilom*1000, "000000000000");
-				}
 			}
-		} else if (colToCompare==11) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
+		} else if (colToCompare == 11) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
 				if (ch.getBearing().equals("?")) {
-					ch.sort="\uFFFF";
+					ch.sort = "\uFFFF";
+				} else {
+					ch.sort = ch.getBearing();
 				}
+			}
+
+		} else if (colToCompare == 12) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = Integer.toString(ch.getCacheSize());
+			}
+		} else if (colToCompare == 13) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.isOC()) {
+					ch.sort = MyLocale.formatLong(ch.recommendationScore, "000") + MyLocale.formatLong(ch.getNumRecommended(), "00000");
+				} else {
+					int gcVote = ch.getNumRecommended();
+					if (gcVote < 100) {
+						ch.sort = MyLocale.formatLong(gcVote, "000") + "00000000";
+					} else {
+						int votes = gcVote / 100;
+						gcVote = gcVote - 100 * votes;
+						ch.sort = MyLocale.formatLong(gcVote, "000") + MyLocale.formatLong(votes, "00000000");
+					}
+				}
+			}
+		} else if (colToCompare == 14) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.getWayPoint().startsWith("GC"))
+					if (ch.getOcCacheID().length() == 0)
+						ch.sort = "\uFFFF";
+					else
+						ch.sort = ch.getOcCacheID();
 				else {
-					ch.sort=ch.getBearing();
-				}			
+					ch.sort = OC.getGCWayPoint(ch.getCacheOwner());
+					if (ch.sort.length() == 0)
+						ch.sort = "\uFFFF"; // ans Ende
+				}
 			}
-			
-		} else if (colToCompare==12) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=Integer.toString(ch.getCacheSize());
+		} else if (colToCompare == 15) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.hasSolver()) {
+					ch.sort = "1";
+				} else {
+					ch.sort = "2";
+				}
 			}
-		} else if (colToCompare==13) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				if ( ch.isOC() ) {
-  				ch.sort=MyLocale.formatLong(ch.getNumRecommended(),"00000");
-        } else {
-				  int gcVote = ch.getNumRecommended();
-				  if ( gcVote < 100 ) {
-				    ch.sort=MyLocale.formatLong(gcVote,"00") + "00000000";
-          } else {
-            int votes = gcVote / 100;
-            gcVote = gcVote - 100 * votes;
-            ch.sort = MyLocale.formatLong(gcVote,"00") + MyLocale.formatLong(votes,"00000000");
-          }
-        }
-			}			
-		} else if (colToCompare==14) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				if (ch.isOC())
-					ch.sort=MyLocale.formatLong(ch.recommendationScore,"00000");
-				else
-					ch.sort="\uFFFF";
-			}			
-		} else if (colToCompare==15) {
-		    for (int i=0; i<visibleSize; i++) {
-		        CacheHolder ch=cacheDB.get(i);
-		        if (ch.hasSolver()) {
-		            ch.sort="1";
-		        } else {
-		            ch.sort="2";
-		        }
-		    }
-		} else if (colToCompare==16) {
-		    for (int i=0; i<visibleSize; i++) {
-		        CacheHolder ch=cacheDB.get(i);
-		        if (ch.hasNote()) {
-		            ch.sort="1";
-		        } else {
-		            ch.sort="2";
-		        }
-		    }
-		} else if (colToCompare==17) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=MyLocale.formatLong(ch.addiWpts.size(),"000");
+		} else if (colToCompare == 16) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.hasNote()) {
+					ch.sort = "1";
+				} else {
+					ch.sort = "2";
+				}
 			}
-		} else if (colToCompare==18) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=MyLocale.formatLong(ch.getNoFindLogs(),"000");
+		} else if (colToCompare == 17) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = MyLocale.formatLong(ch.addiWpts.size(), "000");
 			}
-		} else if (colToCompare==19) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=ch.getLastSync();
+		} else if (colToCompare == 18) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = MyLocale.formatLong(ch.getNoFindLogs(), "000");
 			}
+		} else if (colToCompare == 19) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getLastSync();
+			}
 		}
- 	}
-	
-	public int compare(Object o1, Object o2){
-		CacheHolder oo1 = (CacheHolder)o1;
-		CacheHolder oo2 = (CacheHolder)o2;
+	}
+
+	public int compare(Object o1, Object o2) {
+		CacheHolder oo1 = (CacheHolder) o1;
+		CacheHolder oo2 = (CacheHolder) o2;
 		return oo1.sort.compareTo(oo2.sort);
 	}
 }

Modified: branches/r1.2/src/CacheWolf/OC.java
===================================================================
--- branches/r1.2/src/CacheWolf/OC.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/OC.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 public final class OC {
@@ -32,45 +32,62 @@
 		// Nothing to do
 	}
 
-	public final static int OC_HOSTNAME = 0; 
-	public final static int OC_PREFIX = 1; 
-	public final static String[][] OCSites = {
-		{"www.opencaching.de", "OC"},
-		{"www.opencaching.pl", "OP"},
-		{"www.opencaching.cz", "OZ"},
-		{"www.opencaching.org.uk", "OK"},
-		{"www.opencaching.se", "OS"},
-		{"www.opencaching.no", "ON"},
-		{"www.opencaching.us", "OU"}
-		};
+	public final static int OC_HOSTNAME = 0;
+	public final static int OC_PREFIX = 1;
+	public final static String[][] OCSites = {//
+	{ "www.opencaching.de", "OC" },// 1
+			{ "www.opencaching.pl", "OP" },// 2
+			{ "www.opencaching.cz", "OZ" },// 3
+			{ "www.opencaching.org.uk", "OK" },// 4
+			{ "www.opencaching.se", "OS" },// 5
+			{ "www.opencaching.no", "ON" },// 6
+			{ "www.opencaching.us", "OU" },// 7
+			{ "www.opencachingspain.es", "OC" },// 8 !!!
+			{ "www.opencaching.it", "OC" },// 9 !!!
+			{ "www.opencaching.jp", "OJ" },// 10
+			{ "www.opencaching.nl", "OB" },// 11
+	};
 
 	public final static String[] OCHostNames() {
-		String[] ret=new String[OCSites.length];
+		String[] ret = new String[OCSites.length];
 		for (int i = 0; i < OCSites.length; i++) {
-			ret[i]=OCSites[i][OC_HOSTNAME];
+			ret[i] = OCSites[i][OC_HOSTNAME];
 		}
 		return ret;
 	}
-	
-	public final static String getOCHostName(String wpName){
+
+	public final static String getOCHostName(String wpName) {
 		for (int i = 0; i < OCSites.length; i++) {
-			if(wpName.startsWith(OCSites[i][OC_PREFIX])) {
+			if (wpName.startsWith(OCSites[i][OC_PREFIX])) {
 				return OCSites[i][OC_HOSTNAME];
 			}
 		}
 		return null;
 	}
-	
+
 	public final static boolean isOC(String wpName) {
-		return (getOCHostName(wpName.toUpperCase()) != null);		
+		return (getOCHostName(wpName.toUpperCase()) != null);
 	}
-	
+
 	public final static int getSiteIndex(String site) {
 		for (int i = 0; i < OCSites.length; i++) {
-			if(site.equalsIgnoreCase(OCSites[i][OC_HOSTNAME])) {
+			if (site.equalsIgnoreCase(OCSites[i][OC_HOSTNAME])) {
 				return i;
 			}
 		}
 		return 0; // don't get a fault
 	}
+
+	public final static String getGCWayPoint(String owner) {
+		owner = owner + " ";
+		int l = owner.lastIndexOf('/');
+		if (l > 0) {
+			int i = owner.indexOf("GC", l);
+			if (i > -1) {
+				int j = owner.indexOf(" ", i);
+				return owner.substring(i, j);
+			}
+		}
+		return "";
+	}
 }

Modified: branches/r1.2/src/CacheWolf/Parser.java
===================================================================
--- branches/r1.2/src/CacheWolf/Parser.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Parser.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,72 +1,72 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 /* 
-A parser that parses the following grammar:
-EBNF Meta-Symbols:
-  {xx}        xx can occur any number of times incl 0
-  [xx]        xx or empty
-  |           or
-  "x"         x is terminal symbol
+ A parser that parses the following grammar:
+ EBNF Meta-Symbols:
+ {xx}        xx can occur any number of times incl 0
+ [xx]        xx or empty
+ |           or
+ "x"         x is terminal symbol
 
-command -> if |
-         simplecommand
+ command -> if |
+ simplecommand
 
-simplecommand -> "stop" | "st" |
-		   assign
-         stringexp |
+ simplecommand -> "stop" | "st" |
+ assign
+ stringexp |
 
-if -> "IF" stringexpr compop stringexpr "THEN" simplecommand { ";" simplecommand } "ENDIF"          // Nested IF's not allowed
+ if -> "IF" stringexpr compop stringexpr "THEN" simplecommand { ";" simplecommand } "ENDIF"          // Nested IF's not allowed
 
-compop -> "=" | "<" | ">" | "<=" | "==" | ">=" | "<>" | "!=" | "><"
+ compop -> "=" | "<" | ">" | "<=" | "==" | ">=" | "<>" | "!=" | "><"
 
-assign -> ident = [ stringexpr ]
+ assign -> ident = [ stringexpr ]
 
-stringexp -> (string | expr ) {string | tailexp }
+ stringexp -> (string | expr ) {string | tailexp }
 
-expr -> ["+" | "-"] tailexp [ formatstring ]
+ expr -> ["+" | "-"] tailexp [ formatstring ]
 
-tailexp -> term { ("+" | "-") term }
+ tailexp -> term { ("+" | "-") term }
 
-term -> factor { ("*" | "/") factor }
+ term -> factor { ("*" | "/") factor }
 
-factor -> expfactor { "^" expfactor }
+ factor -> expfactor { "^" expfactor }
 
-expfactor -> ident |
-        number |
-        "(" stringexpr ")" |
-        function "(" stringexpr { "," stringexpr }")"
+ expfactor -> ident |
+ number |
+ "(" stringexpr ")" |
+ function "(" stringexpr { "," stringexpr }")"
 
-function -> "sin" | "cos" | "tan" | "asin" | "acos" | "atan" | "goto" | "project" | "show"  | "crosstotal" |
-          "rot13" | "len" | "mid"
+ function -> "sin" | "cos" | "tan" | "asin" | "acos" | "atan" | "goto" | "project" | "show"  | "crosstotal" |
+ "rot13" | "len" | "mid"
 
-ident -> valid identifier
-number -> valid number
+ ident -> valid identifier
+ number -> valid number
 
 
-*/
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -82,196 +82,155 @@
 import ewe.util.mString;
 
 /**
-*	The wolf language parser. New version - January 2007
-*
-*   New features:
-*   - Improved error handling
-*   - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
-*   - Variables can store strings or doubles
-*   - Global variables (starting with $) are remembered across multiple calls to parser
-*   - Global variables are initialised with "", local variables result in error if used before setting value
-*   - IF statement added
-*   - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
-*   - less typing
-*   	- Function aliases
-*   	- Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
-*   	- show no longer needed
-*   	- Command terminator ; no longer compulsory (only between multiple commands on same line)
-*   - New functions can easily be added
-*   - Can select whether variable names are case sensitive
-*
-*   To add a new function:
-*     1) Add its name and alias and allowed number of args to array functions
-*     2) Add a new private method in the "functions" section
-*     3) Add call to private method in executeFunction
-*   @author salzkammergut Januay 2007
-*/
-public class Parser{
+ * The wolf language parser. New version - January 2007
+ * 
+ * New features:
+ * - Improved error handling
+ * - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
+ * - Variables can store strings or doubles
+ * - Global variables (starting with $) are remembered across multiple calls to parser
+ * - Global variables are initialised with "", local variables result in error if used before setting value
+ * - IF statement added
+ * - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
+ * - less typing
+ * - Function aliases
+ * - Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
+ * - show no longer needed
+ * - Command terminator ; no longer compulsory (only between multiple commands on same line)
+ * - New functions can easily be added
+ * - Can select whether variable names are case sensitive
+ * 
+ * To add a new function:
+ * 1) Add its name and alias and allowed number of args to array functions
+ * 2) Add a new private method in the "functions" section
+ * 3) Add call to private method in executeFunction
+ * 
+ * @author salzkammergut Januay 2007
+ */
+public class Parser {
 
 	private class fnType {
-		public String funcName; 	 // the function name in the user input
-		public String alias;         // the funcName is mapped to this alias
-		public int nargs;            // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
-									 // i.e. 1<<nargs ORed together
+		public String funcName; // the function name in the user input
+		public String alias; // the funcName is mapped to this alias
+		public int nargs; // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+							// i.e. 1<<nargs ORed together
+
 		fnType(String funcName, String alias, int nargs) {
-			this.funcName=funcName; this.alias=alias; this.nargs=nargs;
+			this.funcName = funcName;
+			this.alias = alias;
+			this.nargs = nargs;
 		}
-		boolean nargsValid(int testNargs){
-			return ((1<<testNargs)&this.nargs)!=0;
+
+		boolean nargsValid(int testNargs) {
+			return ((1 << testNargs) & this.nargs) != 0;
 		}
 	}
-    fnType[] functions=new fnType[]{ // in alphabetical order
-    	new fnType("abs","abs",2),
-    	new fnType("acos","acos",2),
-    	new fnType("asin","asin",2),
-    	new fnType("atan","atan",2),
-      	new fnType("bearing","bearing",4),
-    	new fnType("cb","cb",16),
-     	new fnType("centre","center",3),
-    	new fnType("center","center",3),
-    	new fnType("cls","cls",1),
-    	new fnType("clearscreen","cls",1),
-    	new fnType("cos","cos",2),
-    	new fnType("count","count",4),
-     	new fnType("cp","cp",1),
-    	new fnType("crossbearing","cb",16),
-    	new fnType("crosstotal","ct",6),
-    	new fnType("ct","ct",2),
-     	new fnType("curpos","cp",1),
-     	new fnType("d2r","deg2rad",2),
-     	new fnType("deg","deg",1),
-     	new fnType("deg2rad","deg2rad",2),
-     	new fnType("distance","distance",4),
-     	new fnType("encode","encode",8),
-    	new fnType("format","format",12),
-    	new fnType("goto","goto",6),
-    	new fnType("ic","ic",3),
-    	new fnType("ignorecase","ic",3),
-    	new fnType("instr","instr",12),
-    	new fnType("int","int",2),
-    	new fnType("lcase","lc",2),
-    	new fnType("length","len",2),
-    	new fnType("mid","mid",12),
-    	new fnType("mod","mod",4),
-     	new fnType("pc","pz",3),
-     	new fnType("profilecenter","pz",3),
-     	new fnType("profilecentre","pz",3),
-     	new fnType("profilzentrum","pz",3),
-    	new fnType("project","project",8),
-     	new fnType("pz","pz",3),
-    	new fnType("quersumme","ct",6),
-    	new fnType("r2d","rad2deg",2),
-    	new fnType("rad","rad",1),
-    	new fnType("rad2deg","rad2deg",2),
-    	new fnType("replace","replace",8),
-    	new fnType("reverse","reverse",2),
-    	new fnType("rot13","rot13",2),
-    	new fnType("show","show",2),
-    	new fnType("sin","sin",2),
-    	new fnType("skeleton","skeleton",3),
-    	new fnType("sqrt","sqrt",2),
-    	new fnType("sval","sval",2),
-    	new fnType("tolowercase","lc",2),
-    	new fnType("touppercase","uc",2),
-    	new fnType("tan","tan",2),
-    	new fnType("ucase","uc",2),
-    	new fnType("val","val",2),
-     	new fnType("zentrum","center",3)
-     	    	};
+
+	fnType[] functions = new fnType[] { // in alphabetical order
+	new fnType("abs", "abs", 2), new fnType("acos", "acos", 2), new fnType("asin", "asin", 2), new fnType("atan", "atan", 2), new fnType("bearing", "bearing", 4), new fnType("cb", "cb", 16), new fnType("centre", "center", 3),
+			new fnType("center", "center", 3), new fnType("cls", "cls", 1), new fnType("clearscreen", "cls", 1), new fnType("cos", "cos", 2), new fnType("count", "count", 4), new fnType("cp", "cp", 1), new fnType("crossbearing", "cb", 16),
+			new fnType("crosstotal", "ct", 6), new fnType("ct", "ct", 2), new fnType("curpos", "cp", 1), new fnType("d2r", "deg2rad", 2), new fnType("deg", "deg", 1), new fnType("deg2rad", "deg2rad", 2), new fnType("distance", "distance", 4),
+			new fnType("encode", "encode", 8), new fnType("format", "format", 12), new fnType("goto", "goto", 6), new fnType("ic", "ic", 3), new fnType("ignorecase", "ic", 3), new fnType("instr", "instr", 12), new fnType("int", "int", 2),
+			new fnType("lcase", "lc", 2), new fnType("length", "len", 2), new fnType("mid", "mid", 12), new fnType("mod", "mod", 4), new fnType("pc", "pz", 3), new fnType("profilecenter", "pz", 3), new fnType("profilecentre", "pz", 3),
+			new fnType("profilzentrum", "pz", 3), new fnType("project", "project", 8), new fnType("pz", "pz", 3), new fnType("quersumme", "ct", 6), new fnType("r2d", "rad2deg", 2), new fnType("rad", "rad", 1), new fnType("rad2deg", "rad2deg", 2),
+			new fnType("replace", "replace", 8), new fnType("reverse", "reverse", 2), new fnType("rot13", "rot13", 2), new fnType("show", "show", 2), new fnType("sin", "sin", 2), new fnType("skeleton", "skeleton", 3), new fnType("sqrt", "sqrt", 2),
+			new fnType("sval", "sval", 2), new fnType("tolowercase", "lc", 2), new fnType("touppercase", "uc", 2), new fnType("tan", "tan", 2), new fnType("ucase", "uc", 2), new fnType("val", "val", 2), new fnType("zentrum", "center", 3) };
 	private static int scanpos = 0;
-	CWPoint cwPt=new CWPoint();
-	Vector calcStack=new Vector();
+	CWPoint cwPt = new CWPoint();
+	Vector calcStack = new Vector();
 	Hashtable symbolTable = new Hashtable(50);
 	TokenObj thisToken = new TokenObj();
 	Vector tokenStack;
 	Vector messageStack;
 
-	public Parser(){ // Global constructor
+	public Parser() { // Global constructor
 	}
 
-///////////////////////////////////////////
-//  Utility functions
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// Utility functions
+	// /////////////////////////////////////////
 
-	/* All errors are handled via function 'err'. Rather than creating many different Exceptions,
+	/*
+	 * All errors are handled via function 'err'. Rather than creating many different Exceptions,
 	 * only the standard Exception is used. err raises this exception and thereby causes the stack to be
 	 * unwound until 'parse' eventually catches the exception and returns to SolverPanel, which displays
 	 * the messageStack containing the error message.
 	 */
 
 	/**
-     * Add an error message to the message stack and raise an Exception.
-    */
+	 * Add an error message to the message stack and raise an Exception.
+	 */
 	private void err(String str) throws Exception {
-    	messageStack.add(MyLocale.getMsg(1700,"Error on line: ") + thisToken.line + "  "+MyLocale.getMsg(1701,"position: ") + thisToken.position);
-    	messageStack.add(str);
-    	// move cursor to error location
-    	if (Global.mainTab.solverP.mText.setSelectionRange(0,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1))Global.mainTab.solverP.mText.repaintNow();
-    	throw new Exception("Error "+str);
-    }
+		messageStack.add(MyLocale.getMsg(1700, "Error on line: ") + thisToken.line + "  " + MyLocale.getMsg(1701, "position: ") + thisToken.position);
+		messageStack.add(str);
+		// move cursor to error location
+		if (Global.mainTab.solverP.mText.setSelectionRange(0, thisToken.line - 1, thisToken.position + thisToken.token.length() - 1, thisToken.line - 1))
+			Global.mainTab.solverP.mText.repaintNow();
+		throw new Exception("Error " + str);
+	}
 
-    /** Shows global symbols */
-    private void showVars(boolean globals) throws Exception {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
-    		if (globals == varName.startsWith("$")) {
-    			String value=(String) getVariable(varName);
-    			if (java.lang.Double.isNaN(toNumber(value)))
-    				messageStack.add(varName+" = \""+STRreplace.replace(value.toString(),"\"","\"\"")+"\"");
-    			else
-    				messageStack.add(varName+" = "+value);
-    		}
-    	}
-    }
+	/** Shows global symbols */
+	private void showVars(boolean globals) throws Exception {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			String varName = ((String) ((ewe.util.Map.MapEntry) it.next()).getKey());
+			if (globals == varName.startsWith("$")) {
+				String value = (String) getVariable(varName);
+				if (java.lang.Double.isNaN(toNumber(value)))
+					messageStack.add(varName + " = \"" + STRreplace.replace(value.toString(), "\"", "\"\"") + "\"");
+				else
+					messageStack.add(varName + " = " + value);
+			}
+		}
+	}
 
 	/** Clears the symbol table of all non-global symbols (those not starting with $) */
-    private void clearLocalSymbols() {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		ewe.util.Map.MapEntry sym=(ewe.util.Map.MapEntry) it.next();
-    		if (!((String)sym.getKey()).startsWith("$"))
-    			symbolTable.remove(sym.getKey());
-    	}
-    	Double pi=new Double(java.lang.Math.PI);
-    	symbolTable.put("PI",pi);
-    	symbolTable.put("pi",pi); // To make it easier for the user we also add a lowercase version of pi
-    }
+	private void clearLocalSymbols() {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			ewe.util.Map.MapEntry sym = (ewe.util.Map.MapEntry) it.next();
+			if (!((String) sym.getKey()).startsWith("$"))
+				symbolTable.remove(sym.getKey());
+		}
+		Double pi = new Double(java.lang.Math.PI);
+		symbolTable.put("PI", pi);
+		symbolTable.put("pi", pi); // To make it easier for the user we also add a lowercase version of pi
+	}
 
 	private boolean isVariable(String varName) {
-		return varName.startsWith("$") ||  // Global variables exist per default
-		       symbolTable.containsKey(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+		return varName.startsWith("$") || // Global variables exist per default
+				symbolTable.containsKey(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
 	}
 
 	private boolean isInteger(double d) {
-		return java.lang.Math.ceil(d)==d && java.lang.Math.floor(d)==d;
+		return java.lang.Math.ceil(d) == d && java.lang.Math.floor(d) == d;
 	}
 
-    private boolean isValidCoord(String coord) {
-    	cwPt.set(coord);
-    	return cwPt.isValid();
-    }
+	private boolean isValidCoord(String coord) {
+		cwPt.set(coord);
+		return cwPt.isValid();
+	}
 
 	private Object getVariable(String varName) throws Exception {
 		if (varName.startsWith("$")) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Found it!
 				// Check whether coordinates are valid
-				cwPt.set(ch.pos);
-				if (cwPt.isValid() )
+				cwPt.set(ch.getPos());
+				if (cwPt.isValid())
 					return cwPt.toString();
 				else
 					return ""; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
 			}
 		}
-		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-		if(result == null) {
+		Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+		if (result == null) {
 			// If it is a global variable, add it with a default value
 			if (varName.startsWith("$")) {
-				result="";
-				symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName,"");
+				result = "";
+				symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, "");
 			} else
-				err (MyLocale.getMsg(1702,"Variable not defined: ")+varName);
+				err(MyLocale.getMsg(1702, "Variable not defined: ") + varName);
 		}
 		return result;
 	}
@@ -281,66 +240,68 @@
 			if (MyLocale.getDigSeparator().equals(","))
 				str = str.replace('.', ',');
 			else
-				str = str.replace(',','.');
+				str = str.replace(',', '.');
 			return java.lang.Double.parseDouble(str);
 		} catch (NumberFormatException e) {
-			 return java.lang.Double.NaN;
+			return java.lang.Double.NaN;
 		}
 	}
 
 	private Double getNumber(String str) throws Exception {
-		double ret=toNumber(str);
+		double ret = toNumber(str);
 		if (java.lang.Double.isNaN(ret))
-			err(MyLocale.getMsg(1703,"Not a valid number: ") + str);
+			err(MyLocale.getMsg(1703, "Not a valid number: ") + str);
 		return new java.lang.Double(ret);
 	}
 
 	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
 	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
 		double num;
-		if (calcStack.get(calcStack.size()-1) instanceof String) {
-			if (((String)calcStack.get(calcStack.size()-1)).equals(""))
-				num=defaultForEmptyString;
+		if (calcStack.get(calcStack.size() - 1) instanceof String) {
+			if (((String) calcStack.get(calcStack.size() - 1)).equals(""))
+				num = defaultForEmptyString;
 			else
-				num = getNumber((String)calcStack.get(calcStack.size()-1)).doubleValue();
+				num = getNumber((String) calcStack.get(calcStack.size() - 1)).doubleValue();
 		} else {
-			num = ((java.lang.Double)calcStack.get(calcStack.size()-1)).doubleValue();
+			num = ((java.lang.Double) calcStack.get(calcStack.size() - 1)).doubleValue();
 		}
-		calcStack.removeElementAt(calcStack.size()-1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return num;
 	}
 
 	private String popCalcStackAsString() {
 		String s;
-		if (calcStack.get(calcStack.size()-1) instanceof Double) {
-			java.lang.Double D=((java.lang.Double)calcStack.get(calcStack.size()-1));
+		if (calcStack.get(calcStack.size() - 1) instanceof Double) {
+			java.lang.Double D = ((java.lang.Double) calcStack.get(calcStack.size() - 1));
 			// Double.toString() formats numbers > 1E7 and < 1E-3 with exponential notation
 			// For large integers we therefore use Longs
-			double d=D.doubleValue();
+			double d = D.doubleValue();
 			// If the double is an integer and within range of longs, use Long
-			if (java.lang.Math.floor(d)==d && d<java.lang.Long.MAX_VALUE && d>java.lang.Long.MIN_VALUE) {
-				java.lang.Long L=new java.lang.Long((long)d);
-				s=L.toString();
+			if (java.lang.Math.floor(d) == d && d < java.lang.Long.MAX_VALUE && d > java.lang.Long.MIN_VALUE) {
+				java.lang.Long L = new java.lang.Long((long) d);
+				s = L.toString();
 			} else { // Use the default Double format
-				s = D.toString().replace(',','.'); // always show numbers with decimal point;
-				if (s.endsWith(".0")) s=s.substring(0,s.length()-2);
+				s = D.toString().replace(',', '.'); // always show numbers with decimal point;
+				if (s.endsWith(".0"))
+					s = s.substring(0, s.length() - 2);
 			}
 		} else
-			s = (String)calcStack.get(calcStack.size()-1);
-		calcStack.removeElementAt(calcStack.size()-1);
+			s = (String) calcStack.get(calcStack.size() - 1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return s;
 	}
 
 	private void getToken() throws Exception {
-		if(scanpos < tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		if (scanpos < tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-		} else err(MyLocale.getMsg(1704,"Unexpected end of source"));
+		} else
+			err(MyLocale.getMsg(1704, "Unexpected end of source"));
 	}
 
 	private TokenObj peekToken() {
-		if(scanpos < tokenStack.size()){
-			return (TokenObj)tokenStack.get(scanpos);
+		if (scanpos < tokenStack.size()) {
+			return (TokenObj) tokenStack.get(scanpos);
 		} else
 			return new TokenObj();
 	}
@@ -352,54 +313,58 @@
 	}
 
 	private void skipPastEndif(TokenObj ifToken) throws Exception {
-		while(scanpos < tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		while (scanpos < tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-			if (thisToken.tt==TokenObj.TT_ENDIF) {
+			if (thisToken.tt == TokenObj.TT_ENDIF) {
 				getToken();
 				return;
 			}
 		}
-		thisToken=ifToken;
-		err(MyLocale.getMsg(1705,"Missing ENDIF"));
+		thisToken = ifToken;
+		err(MyLocale.getMsg(1705, "Missing ENDIF"));
 	}
+
 	private TokenObj lookAheadToken() {
-		return (TokenObj)tokenStack.get(scanpos);
+		return (TokenObj) tokenStack.get(scanpos);
 	}
 
 	private boolean checkNextSymIs(String str) throws Exception {
-		if(thisToken.token.toUpperCase().equals(str)){
+		if (thisToken.token.toUpperCase().equals(str)) {
 			return true;
 		} else {
-			err(MyLocale.getMsg(1706,"Expected ") + str + "  "+MyLocale.getMsg(1707,"Found: ")+thisToken.token);
-			return false; //Dummy as err does not return
+			err(MyLocale.getMsg(1706, "Expected ") + str + "  " + MyLocale.getMsg(1707, "Found: ") + thisToken.token);
+			return false; // Dummy as err does not return
 		}
 	}
 
 	private fnType getFunctionDefinition(String str) throws Exception {
-    	fnType fnd=null;
-    	str=str.toLowerCase();
-    	for (int i=functions.length-1; i>=0; i--) {
-    		// Return the function if there is an exact match
-    		if (functions[i].funcName.equals(str)) return functions[i];
-    		if (functions[i].funcName.startsWith(str)) { // Partial match?
-        		// Only one partial match allowed
-    			if (fnd!=null) err(MyLocale.getMsg(1708,"Ambiguous function name: ")+str);
-    			fnd=functions[i];
-    		}
-    	}
-    	if (fnd==null) err(MyLocale.getMsg(1709,"Unknown function: ")+str);
-    	return fnd;
-    }
+		fnType fnd = null;
+		str = str.toLowerCase();
+		for (int i = functions.length - 1; i >= 0; i--) {
+			// Return the function if there is an exact match
+			if (functions[i].funcName.equals(str))
+				return functions[i];
+			if (functions[i].funcName.startsWith(str)) { // Partial match?
+				// Only one partial match allowed
+				if (fnd != null)
+					err(MyLocale.getMsg(1708, "Ambiguous function name: ") + str);
+				fnd = functions[i];
+			}
+		}
+		if (fnd == null)
+			err(MyLocale.getMsg(1709, "Unknown function: ") + str);
+		return fnd;
+	}
 
-///////////////////////////////////////////
-//  FUNCTIONS
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// FUNCTIONS
+	// /////////////////////////////////////////
 
 	/** If we are in DEGree mode, convert the argument to RADiants, if not leave it unchanged */
 	private double makeRadiant(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg*java.lang.Math.PI/180.0;
+			return arg * java.lang.Math.PI / 180.0;
 		else
 			return arg;
 	}
@@ -407,30 +372,33 @@
 	/** If we are in DEGree mode, convert the argument to degrees */
 	private double makeDegree(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg/java.lang.Math.PI*180.0;
+			return arg / java.lang.Math.PI * 180.0;
 		else
 			return arg;
 	}
 
-    /** Calculate brearing from one point to the next */
-    private double funcBearing() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
- 		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
-	   	cwPt.set(coordA);
-	   	double angleDeg=cwPt.getBearing(new CWPoint(coordB));
-	   	// getBearing returns a result in degrees
-	   	return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI/180.0;
-    }
+	/** Calculate brearing from one point to the next */
+	private double funcBearing() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordB);
+		cwPt.set(coordA);
+		double angleDeg = cwPt.getBearing(new CWPoint(coordB));
+		// getBearing returns a result in degrees
+		return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI / 180.0;
+	}
 
-    /** Get or set the current centre */
+	/** Get or set the current centre */
 	private void funcCenter(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getPref().getCurCentrePt().toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
 			Global.getPref().setCurCentrePt(new CWPoint(coordA));
 		}
 	}
@@ -442,218 +410,246 @@
 	}
 
 	private int funcCountChar(String s, char c) {
-    	int count=0;
-    	for (int i=0; i<s.length(); i++)
-    		if (s.charAt(i)==c) count++;
-    	return count;
-    }
+		int count = 0;
+		for (int i = 0; i < s.length(); i++)
+			if (s.charAt(i) == c)
+				count++;
+		return count;
+	}
 
-    /** count(string1,string2)
-     * */
-    private void funcCount()throws Exception {
-       	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	if (s2.length()==0) err(MyLocale.getMsg(1710,"Cannot count empty string"));
-    	if (s2.length()==1) {
-    		calcStack.add(new Double(funcCountChar(s1,s2.charAt(0))));
-    	} else {
-    		String res="";
-    		for(int i=0; i<s2.length(); i++) {
-    			res+=s2.charAt(i)+"="+funcCountChar(s1,s2.charAt(i))+" ";
-    		}
-    		calcStack.add(res);
-    	}
-    }
+	/**
+	 * count(string1,string2)
+	 * */
+	private void funcCount() throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		if (s2.length() == 0)
+			err(MyLocale.getMsg(1710, "Cannot count empty string"));
+		if (s2.length() == 1) {
+			calcStack.add(new Double(funcCountChar(s1, s2.charAt(0))));
+		} else {
+			String res = "";
+			for (int i = 0; i < s2.length(); i++) {
+				res += s2.charAt(i) + "=" + funcCountChar(s1, s2.charAt(i)) + " ";
+			}
+			calcStack.add(res);
+		}
+	}
 
-    private String funcCp(){
-    	return Global.mainTab.nav.gpsPos.toString();
-    }
+	private String funcCp() {
+		return Global.mainTab.nav.gpsPos.toString();
+	}
 
-    /**
-     *  Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
-     *  Warning: When the number is non-integer or > 9223372036854775807, it is formatted using the E
-     *  notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
-     */
-    private double funcCrossTotal(int nargs) throws Exception {
-    	int cycles=1;
-		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
-		String aString=popCalcStackAsString().replace('-','0').trim();
-		double a=0;
-		if (cycles<0) cycles=1;
-    	if (cycles>5) cycles=5;
-    	while (cycles-->0) {
-	    	// Cross total = Quersumme berechnen
-			a=0;
-			for (int i=0; i<aString.length(); i++) {
-			   if (aString.charAt(i)>='0' && aString.charAt(i)<='9')
-			      a += aString.charAt(i)-'0';
+	/**
+	 * Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
+	 * Warning: When the number is non-integer or > 9223372036854775807, it is formatted using the E
+	 * notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
+	 */
+	private double funcCrossTotal(int nargs) throws Exception {
+		int cycles = 1;
+		if (nargs == 2)
+			cycles = (int) popCalcStackAsNumber(1);
+		String aString = popCalcStackAsString().replace('-', '0').trim();
+		double a = 0;
+		if (cycles < 0)
+			cycles = 1;
+		if (cycles > 5)
+			cycles = 5;
+		while (cycles-- > 0) {
+			// Cross total = Quersumme berechnen
+			a = 0;
+			for (int i = 0; i < aString.length(); i++) {
+				if (aString.charAt(i) >= '0' && aString.charAt(i) <= '9')
+					a += aString.charAt(i) - '0';
 			}
-			aString=Convert.toString(a);
-    	}
-    	return a;
-    }
+			aString = Convert.toString(a);
+		}
+		return a;
+	}
 
-    private void funcDeg(boolean arg) {
-    	Global.getPref().solverDegMode=arg;
-    	Global.mainTab.solverP.showSolverMode();
-    }
+	private void funcDeg(boolean arg) {
+		Global.getPref().solverDegMode = arg;
+		Global.mainTab.solverP.showSolverMode();
+	}
 
-    /** Convert degrees into Radiants */
-    private double funcDeg2Rad() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a/180.0*java.lang.Math.PI;
-    }
+	/** Convert degrees into Radiants */
+	private double funcDeg2Rad() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a / 180.0 * java.lang.Math.PI;
+	}
 
-    	/** Calculate distance between 2 points */
-    private double funcDistance() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
-    	double result = 0;
+	/** Calculate distance between 2 points */
+	private double funcDistance() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		double result = 0;
 		// Attention: isValidCoord has sideeffect of setting cwPt
-    	if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
-    	cwPt.set(coordA);
-    	double distKM = cwPt.getDistance(new CWPoint(coordB));
-    	result = distKM*1000.0;
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
-    	}
-    	return result;
-    }
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordB);
+		cwPt.set(coordA);
+		double distKM = cwPt.getDistance(new CWPoint(coordB));
+		result = distKM * 1000.0;
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
+		}
+		return result;
+	}
 
-    /**
-     * Encode a string by replacing all characters in a string with their corresponding characters in
-     * another string
-     * @throws Exception
-     */
-    private String funcEncode() throws Exception {
-    	String newChars=popCalcStackAsString();
-    	String oldChars=popCalcStackAsString();
-    	if (newChars.length()!=oldChars.length()) err(MyLocale.getMsg(1711,"Replacement characters strings must be of equal length"));
-    	String s=popCalcStackAsString();
-    	String encodedStr="";
-    	for (int i=0; i<s.length(); i++) {
-    		int pos;
-    		if ((pos=oldChars.indexOf(s.charAt(i)))!=-1) {
-    			encodedStr+=newChars.charAt(pos);
-    		} else
-    			encodedStr+=s.charAt(i);
-    	}
-    	 return encodedStr;
-    }
+	/**
+	 * Encode a string by replacing all characters in a string with their corresponding characters in
+	 * another string
+	 * 
+	 * @throws Exception
+	 */
+	private String funcEncode() throws Exception {
+		String newChars = popCalcStackAsString();
+		String oldChars = popCalcStackAsString();
+		if (newChars.length() != oldChars.length())
+			err(MyLocale.getMsg(1711, "Replacement characters strings must be of equal length"));
+		String s = popCalcStackAsString();
+		String encodedStr = "";
+		for (int i = 0; i < s.length(); i++) {
+			int pos;
+			if ((pos = oldChars.indexOf(s.charAt(i))) != -1) {
+				encodedStr += newChars.charAt(pos);
+			} else
+				encodedStr += s.charAt(i);
+		}
+		return encodedStr;
+	}
 
-    /** Format a valid coordinate
-     *  If called with one args, format the argument on the stack to CW standard
-     *  The optional second argument is one of these strings "UTM","DMS","DD","DMM" or "CW"
-     * @param nargs 1 or 2 args
-     */
-    private String funcFormat(int nargs) throws Exception {
-    	int spart=0;
-    	if (nargs==3) spart=(int) popCalcStackAsNumber(0);
-    	String fmtStr="";
-    	if (nargs>=2)fmtStr=popCalcStackAsString().toLowerCase();
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
-    	cwPt.set(coord);
-    	int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
-    	if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED) err(MyLocale.getMsg(1713,"Invalid coordinate format. Allowed are cw / dd / dmm / dms / ") + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), " / "));
-    	String ret = cwPt.toString(fmt);
-    	if (nargs==3){
-    		String[] parts=mString.split(ret, ' ');
-    		if (spart>0 && parts.length>=spart)
-    		ret = parts[spart-1];
-    		else err("Param 3 !!! "+MyLocale.getMsg(1713,"Invalid coordinate format."));
-    	}
-    	return ret;
-    }
+	/**
+	 * Format a valid coordinate
+	 * If called with one args, format the argument on the stack to CW standard
+	 * The optional second argument is one of these strings "UTM","DMS","DD","DMM" or "CW"
+	 * 
+	 * @param nargs
+	 *            1 or 2 args
+	 */
+	private String funcFormat(int nargs) throws Exception {
+		int spart = 0;
+		if (nargs == 3)
+			spart = (int) popCalcStackAsNumber(0);
+		String fmtStr = "";
+		if (nargs >= 2)
+			fmtStr = popCalcStackAsString().toLowerCase();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
+		cwPt.set(coord);
+		int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
+		if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED)
+			err(MyLocale.getMsg(1713, "Invalid coordinate format. Allowed are cw / dd / dmm / dms / ") + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), " / "));
+		String ret = cwPt.toString(fmt);
+		if (nargs == 3) {
+			String[] parts = mString.split(ret, ' ');
+			if (spart > 0 && parts.length >= spart)
+				ret = parts[spart - 1];
+			else
+				err("Param 3 !!! " + MyLocale.getMsg(1713, "Invalid coordinate format."));
+		}
+		return ret;
+	}
 
-    /** Implements a goto command goto(coordinate,optionalWaypointName).
-     */
-    private void funcGoto(int nargs) throws Exception {
-    	Navigate nav=Global.mainTab.nav;
-		String waypointName=null;
-        if (nargs==2) waypointName=popCalcStackAsString();
-		String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
+	/**
+	 * Implements a goto command goto(coordinate,optionalWaypointName).
+	 */
+	private void funcGoto(int nargs) throws Exception {
+		Navigate nav = Global.mainTab.nav;
+		String waypointName = null;
+		if (nargs == 2)
+			waypointName = popCalcStackAsString();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
 		// Don't want to switch to goto panel, just set the values
 		nav.setDestination(coord);
-		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
-    		cwPt.set(coord);
-    		CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-    		if (ch == null) {
-    			err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
-    			return;
-    		}
-    		ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-    		ch.pos.set(cwPt);
-    		ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
-    		nav.setDestination(ch);
-    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-    	}
-    }
+		if (nargs == 2) { // Now set the value of the addi waypoint (it must exist already)
+			cwPt.set(coord);
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, "Goto: Waypoint does not exist: ") + waypointName);
+				return;
+			}
+			ch.setPos(cwPt);
+			ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
+			nav.setDestination(ch);
+			Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+		}
+	}
 
-    /** Display or change the case sensitivity of variable names */
-    private void funcIgnoreVariableCase(int nargs) throws Exception {
-    	if (nargs==0)
-    		calcStack.add(""+Global.getPref().solverIgnoreCase);
-    	else {
-    		Global.getPref().solverIgnoreCase=(popCalcStackAsNumber(0)!=0)?true:false;
-    	}
-    }
+	/** Display or change the case sensitivity of variable names */
+	private void funcIgnoreVariableCase(int nargs) throws Exception {
+		if (nargs == 0)
+			calcStack.add("" + Global.getPref().solverIgnoreCase);
+		else {
+			Global.getPref().solverIgnoreCase = (popCalcStackAsNumber(0) != 0) ? true : false;
+		}
+	}
 
-    /** VB instr function
-     * instr([start],string1,string2)
-     * */
-    private int funcInstr(int nargs) throws Exception {
-    	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	int start=1;
-    	if (nargs==3) start=(int) popCalcStackAsNumber(1);
-    	if (start>s1.length()) err(MyLocale.getMsg(1715,"instr: Start position not in string"));
-    	if(s2.equals("")) {
-    		if (s1.equals(""))
-    			return 0;
-    		else
-    			return 1;
-    	}
-    	return s1.indexOf(s2,start-1)+1;
-    }
+	/**
+	 * VB instr function
+	 * instr([start],string1,string2)
+	 * */
+	private int funcInstr(int nargs) throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		int start = 1;
+		if (nargs == 3)
+			start = (int) popCalcStackAsNumber(1);
+		if (start > s1.length())
+			err(MyLocale.getMsg(1715, "instr: Start position not in string"));
+		if (s2.equals("")) {
+			if (s1.equals(""))
+				return 0;
+			else
+				return 1;
+		}
+		return s1.indexOf(s2, start - 1) + 1;
+	}
 
-    /** MID function as in Basic */
-    private String funcMid(int nargs) throws Exception {
-    	if (nargs==2) {
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err(MyLocale.getMsg(1716,"mid: Integer argument expected"));
-    		if (start<1 || start>s.length()) err(MyLocale.getMsg(1717,"mid: Argument out of range"));
-    		return s.substring((int)start-1);
-    	} else {
-        	double len=popCalcStackAsNumber(0);
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,"mid: Integer argument expected"));
-    		int end=(int)(start+len-1);
-    		if (start>s.length() || start<1 || end>s.length()) err(MyLocale.getMsg(1717,"mid: Argument out of range"));
-    		return s.substring((int)start-1,end);
-    	}
-    }
+	/** MID function as in Basic */
+	private String funcMid(int nargs) throws Exception {
+		if (nargs == 2) {
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start))
+				err(MyLocale.getMsg(1716, "mid: Integer argument expected"));
+			if (start < 1 || start > s.length())
+				err(MyLocale.getMsg(1717, "mid: Argument out of range"));
+			return s.substring((int) start - 1);
+		} else {
+			double len = popCalcStackAsNumber(0);
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start) || !isInteger(len))
+				err(MyLocale.getMsg(1716, "mid: Integer argument expected"));
+			int end = (int) (start + len - 1);
+			if (start > s.length() || start < 1 || end > s.length())
+				err(MyLocale.getMsg(1717, "mid: Argument out of range"));
+			return s.substring((int) start - 1, end);
+		}
+	}
 
-    /** MOD function as in Basic */
-    private Double funcMod() throws Exception {
-    	double b=popCalcStackAsNumber(0);
-    	double a=popCalcStackAsNumber(0);
-		if (b==0.0)
-			err(MyLocale.getMsg(1729,"Division by 0"));
+	/** MOD function as in Basic */
+	private Double funcMod() throws Exception {
+		double b = popCalcStackAsNumber(0);
+		double a = popCalcStackAsNumber(0);
+		if (b == 0.0)
+			err(MyLocale.getMsg(1729, "Division by 0"));
 		return new java.lang.Double(a % b);
-    }
+	}
 
 	/** Get or set the profile centre */
 	private void funcPz(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getProfile().centre.toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
 			Global.getProfile().centre.set(coordA);
 		}
 	}
@@ -662,266 +658,281 @@
 	 * Calculates the crossbearing from point1 with bearing 1 and point2 with bearing2
 	 * point1 and point 2 must be different.
 	 * Not very well tested. No guarantee for correct result if any of the distance is greater than 300 kilometers and / or any of the angles in the spherical triangle id greater then 90degrees
+	 * 
 	 * @return
 	 * @throws Exception
 	 */
-	private String funcCrossBearing () throws Exception{
-		//parameters come in reversed order!
+	private String funcCrossBearing() throws Exception {
+		// parameters come in reversed order!
 		double degrees2 = popCalcStackAsNumber(-1);
 		String coordinates2 = popCalcStackAsString();
 		double degrees1 = popCalcStackAsNumber(-1);
 		String coordinates1 = popCalcStackAsString();
-		if (!isValidCoord(coordinates1)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordinates1);
- 		if (!isValidCoord(coordinates2)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordinates2);
+		if (!isValidCoord(coordinates1))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordinates1);
+		if (!isValidCoord(coordinates2))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordinates2);
 
-		//Check parameters: Range
-    	if (degrees1<0 || degrees1>360 || degrees2 < 0 || degrees2 > 360){
-    		if (Global.getPref().solverDegMode){
-    			err(MyLocale.getMsg(1740,"Crossbearing degrees must be in interval [0;360]"));
-    		}
-    		else{
-    			err(MyLocale.getMsg(1741,"Crossbearing degrees must be in interval [0;2*PI]"));
-    		}
-    	}
-    	double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0
-				* java.lang.Math.PI : degrees1;
-		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0
-				* java.lang.Math.PI : degrees2;
+		// Check parameters: Range
+		if (degrees1 < 0 || degrees1 > 360 || degrees2 < 0 || degrees2 > 360) {
+			if (Global.getPref().solverDegMode) {
+				err(MyLocale.getMsg(1740, "Crossbearing degrees must be in interval [0;360]"));
+			} else {
+				err(MyLocale.getMsg(1741, "Crossbearing degrees must be in interval [0;2*PI]"));
+			}
+		}
+		double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0 * java.lang.Math.PI : degrees1;
+		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0 * java.lang.Math.PI : degrees2;
 
-		CWPoint point1=new CWPoint(coordinates1);
-		CWPoint point2=new CWPoint(coordinates2);
+		CWPoint point1 = new CWPoint(coordinates1);
+		CWPoint point2 = new CWPoint(coordinates2);
 
-    	//check Parameters: bearings to project must be different from the bearing between point1 and point2
-    	if (degrees1 == degrees2){
-    		double bearing1 = point1.getBearing(point2);
-    		double bearing2 = point1.getBearing(point1);
-    		if (bearing1 == degrees1 || bearing2 == degrees2){
-    			err(MyLocale.getMsg(1740,"Invalid crossbearing angles"));
-    		}
-    	}
+		// check Parameters: bearings to project must be different from the bearing between point1 and point2
+		if (degrees1 == degrees2) {
+			double bearing1 = point1.getBearing(point2);
+			double bearing2 = point1.getBearing(point1);
+			if (bearing1 == degrees1 || bearing2 == degrees2) {
+				err(MyLocale.getMsg(1740, "Invalid crossbearing angles"));
+			}
+		}
 
 		CWPoint result2 = crossbearingCalculation(point1, point2, rAN, rBN);
 		return result2.toString();
 	}
 
 	private CWPoint crossbearingCalculation(CWPoint point1, CWPoint point2, double rAN, double rBN) throws Exception {
-		//see german wikipedia keyword vorwaertsschnitt for the calculation.
-		//peilung von a->b
-		//Yes we will make an error, therefore we have to calculate the target-point iteratively.
-		//Testcode for crossbearing:
+		// see german wikipedia keyword vorwaertsschnitt for the calculation.
+		// peilung von a->b
+		// Yes we will make an error, therefore we have to calculate the target-point iteratively.
+		// Testcode for crossbearing:
 		// MP="S35 47.100 W089 43.200" # MP is centre of circle, could be any waypoint
 		// A=project(MP,0,1000); B=project(MP,120,1000) # Points of equilateral triangle on circle
 		// C1=project(MP,240,1000); C2=cb(A,210 ,B,270)
-		//	C1 "=" C2
+		// C1 "=" C2
 		final int maxRadius = 6378;
-    	double distance = point1.getDistance(point2);
-    	if (Math.abs (distance) <= 0.0000000001){
-    		err (MyLocale.getMsg(1742,"Crossbearing: distance between points to small"));
-    	}
-    	double distanceInRad = distance / maxRadius;
-	    double phiAB = point1.getBearing(point2);
-	    if (Global.getPref().solverDegMode) phiAB=phiAB / 180.0 * java.lang.Math.PI;
-	    double phiBA = point2.getBearing(point1);
-	    if (Global.getPref().solverDegMode) phiBA=phiBA / 180.0 * java.lang.Math.PI;
+		double distance = point1.getDistance(point2);
+		if (Math.abs(distance) <= 0.0000000001) {
+			err(MyLocale.getMsg(1742, "Crossbearing: distance between points to small"));
+		}
+		double distanceInRad = distance / maxRadius;
+		double phiAB = point1.getBearing(point2);
+		if (Global.getPref().solverDegMode)
+			phiAB = phiAB / 180.0 * java.lang.Math.PI;
+		double phiBA = point2.getBearing(point1);
+		if (Global.getPref().solverDegMode)
+			phiBA = phiBA / 180.0 * java.lang.Math.PI;
 
-	    double psi = phiAB - rAN;
-	    double phi = rBN - phiBA;
+		double psi = phiAB - rAN;
+		double phi = rBN - phiBA;
 
-	    //calculate projetiondistance
-	    double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi+psi);
-	    double b = bInRad * maxRadius ;//* (1-flattening);
-	    double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi+psi);
-	    double a = aInRad * maxRadius ;//* (1-flattening);
-	    double phiAN = phiAB - psi;
-	    double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
-	    double phiBN = phiBA + phi;
-	    double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
-	    CWPoint result2 = point2.project(phiBNDegrees, a);
-	    CWPoint result = point1.project(phiANDegrees, b);
-	    double errorDistance = result.getDistance(result2);
-	    //if the distance between the points is to large, we will restart the calculation with the new points found.
-	    //since the error is mostly very small these iterations are seldom used and the needed depth is very low.
-	    //First we will make sure, that this calculation will terminate
-	    if (distance < errorDistance){
-    		err (MyLocale.getMsg(1743,"Crossbearing calculation failed. Please inform the developers at geoclub.de"));
-	    }
-	    if (errorDistance * 1000 > 1){
-	    	return crossbearingCalculation(result, result2, rAN, rBN);
-	    }
+		// calculate projetiondistance
+		double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi + psi);
+		double b = bInRad * maxRadius;// * (1-flattening);
+		double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi + psi);
+		double a = aInRad * maxRadius;// * (1-flattening);
+		double phiAN = phiAB - psi;
+		double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
+		double phiBN = phiBA + phi;
+		double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
+		CWPoint result2 = point2.project(phiBNDegrees, a);
+		CWPoint result = point1.project(phiANDegrees, b);
+		double errorDistance = result.getDistance(result2);
+		// if the distance between the points is to large, we will restart the calculation with the new points found.
+		// since the error is mostly very small these iterations are seldom used and the needed depth is very low.
+		// First we will make sure, that this calculation will terminate
+		if (distance < errorDistance) {
+			err(MyLocale.getMsg(1743, "Crossbearing calculation failed. Please inform the developers at geoclub.de"));
+		}
+		if (errorDistance * 1000 > 1) {
+			return crossbearingCalculation(result, result2, rAN, rBN);
+		}
 		return result2;
 	}
 
-    /** Project a waypoint at some angle and some distance */
-    private String funcProject() throws Exception {
-    	double distance=popCalcStackAsNumber(0);
-    	if (distance<0) err(MyLocale.getMsg(1718,"Cannot project a negative distance"));
-    	double degrees=popCalcStackAsNumber(0);
-    	// If we are not in degree mode, arg is in radiants ==> convert it
-    	if (!Global.getPref().solverDegMode) degrees=degrees * 180.0 / java.lang.Math.PI;
-    	if (degrees<0 || degrees>360)
-    		if (Global.getPref().solverDegMode)
-    			err(MyLocale.getMsg(1719,"Projection degrees must be in interval [0;360]"));
-    		else
-    			err(MyLocale.getMsg(1739,"Projection degrees must be in interval [0;2*PI]"));
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
-    	cwPt.set(coord);
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
-    	} else {
-    		distance = distance / 1000.0;
-    	}
-    	return cwPt.project(degrees,distance).toString();
-    }
+	/** Project a waypoint at some angle and some distance */
+	private String funcProject() throws Exception {
+		double distance = popCalcStackAsNumber(0);
+		if (distance < 0)
+			err(MyLocale.getMsg(1718, "Cannot project a negative distance"));
+		double degrees = popCalcStackAsNumber(0);
+		// If we are not in degree mode, arg is in radiants ==> convert it
+		if (!Global.getPref().solverDegMode)
+			degrees = degrees * 180.0 / java.lang.Math.PI;
+		if (degrees < 0 || degrees > 360)
+			if (Global.getPref().solverDegMode)
+				err(MyLocale.getMsg(1719, "Projection degrees must be in interval [0;360]"));
+			else
+				err(MyLocale.getMsg(1739, "Projection degrees must be in interval [0;2*PI]"));
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
+		cwPt.set(coord);
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
+		} else {
+			distance = distance / 1000.0;
+		}
+		return cwPt.project(degrees, distance).toString();
+	}
 
-    /** Convert Radiants into degrees */
-    private double funcRad2Deg() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a*180.0/java.lang.Math.PI;
-    }
+	/** Convert Radiants into degrees */
+	private double funcRad2Deg() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a * 180.0 / java.lang.Math.PI;
+	}
 
-    /** Replace all occurrences of a string with another string */
-    private String funcReplace() throws Exception {
-    	String replaceWith=popCalcStackAsString();
-    	String whatToReplace=popCalcStackAsString();
-    	String s=popCalcStackAsString();
-        if (whatToReplace.equals("")) return s;
-        return STRreplace.replace(s,whatToReplace,replaceWith);
-    }
+	/** Replace all occurrences of a string with another string */
+	private String funcReplace() throws Exception {
+		String replaceWith = popCalcStackAsString();
+		String whatToReplace = popCalcStackAsString();
+		String s = popCalcStackAsString();
+		if (whatToReplace.equals(""))
+			return s;
+		return STRreplace.replace(s, whatToReplace, replaceWith);
+	}
 
-    /** Reverse a string */
-    private String funcReverse(String s) {
-    	String res="";
-    	for (int i=s.length()-1; i>=0; i--) res+=s.charAt(i);
-    	return res;
-    }
+	/** Reverse a string */
+	private String funcReverse(String s) {
+		String res = "";
+		for (int i = s.length() - 1; i >= 0; i--)
+			res += s.charAt(i);
+		return res;
+	}
 
-    /** Create a skeleton for multis. This function can be called in three ways:<br>
-     *  <pre>sk()                Create skeleton for current cache (must have addi wpts)
-     *  sk(number)          Create skeleton for number variables
-     */
-    private void funcSkeleton(int nargs) throws Exception {
-   		String waypointName=Global.mainTab.lastselected;
-    	CacheHolder c=Global.getProfile().cacheDB.get(waypointName);
-    	if (c == null) return;
-    	// If it is an addi, find its main cache
-    	if (c.isAddiWpt()) {
-    		waypointName=c.mainCache.getWayPoint();
-    	}
-   		int nStages=-1;
-    	if (nargs==1) {
-    		nStages=(int)popCalcStackAsNumber(-1.0);
-    	}
-    	// Remove the sk command from the instructions
-    	Regex rex=new Regex("sk\\(.*?\\)","");
-    	Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
-		StringBuffer op=new StringBuffer(1000);
-    	// Check for sk(number)
-    	if (nStages>0 && nStages<30) { // e.g. sk(3)
-			/*IF $01xxxx="" THEN
-			   $01xxxx=""
-			   "Station 1 = " $01xxxx
-			   goto($01xxxx); STOP
-			ENDIF*/
-			boolean didCreateWp=false;
-    		for (int i=0; i<nStages; i++) {
-				String stage=MyLocale.formatLong(i,"00");
-				String stageWpt="$"+stage+waypointName.substring(2);
-				String stageName = "Stage "+(i+1);
+	/**
+	 * Create a skeleton for multis. This function can be called in three ways:<br>
+	 * 
+	 * <pre>
+	 * sk()                Create skeleton for current cache (must have addi wpts)
+	 * sk(number)          Create skeleton for number variables
+	 */
+	private void funcSkeleton(int nargs) throws Exception {
+		String waypointName = Global.mainTab.lastselected;
+		CacheHolder c = Global.getProfile().cacheDB.get(waypointName);
+		if (c == null)
+			return;
+		// If it is an addi, find its main cache
+		if (c.isAddiWpt()) {
+			waypointName = c.mainCache.getWayPoint();
+		}
+		int nStages = -1;
+		if (nargs == 1) {
+			nStages = (int) popCalcStackAsNumber(-1.0);
+		}
+		// Remove the sk command from the instructions
+		Regex rex = new Regex("sk\\(.*?\\)", "");
+		Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
+		StringBuffer op = new StringBuffer(1000);
+		// Check for sk(number)
+		if (nStages > 0 && nStages < 30) { // e.g. sk(3)
+			/*
+			 * IF $01xxxx="" THEN
+			 * $01xxxx=""
+			 * "Station 1 = " $01xxxx
+			 * goto($01xxxx); STOP
+			 * ENDIF
+			 */
+			boolean didCreateWp = false;
+			for (int i = 0; i < nStages; i++) {
+				String stage = MyLocale.formatLong(i, "00");
+				String stageWpt = "$" + stage + waypointName.substring(2);
+				String stageName = "Stage " + (i + 1);
 				byte type = CacheType.CW_TYPE_STAGE;
 				if (i == nStages - 1) {
 					stageName = "Final";
 					type = CacheType.CW_TYPE_FINAL;
 				}
-				didCreateWp|=createWptIfNeeded(stage+waypointName.substring(2), stageName, type);
-				op.append("IF "+stageWpt+"=\"\" THEN\n");
-				op.append("  "+stageWpt+" = \"\"\n");
-				op.append("  \""+stageName+" = \" "+stageWpt+"\n");
-				op.append("  goto("+stageWpt+"); STOP\n");
+				didCreateWp |= createWptIfNeeded(stage + waypointName.substring(2), stageName, type);
+				op.append("IF " + stageWpt + "=\"\" THEN\n");
+				op.append("  " + stageWpt + " = \"\"\n");
+				op.append("  \"" + stageName + " = \" " + stageWpt + "\n");
+				op.append("  goto(" + stageWpt + "); STOP\n");
 				op.append("ENDIF\n");
 			}
-			Global.mainTab.solverP.mText.appendText(op.toString(),true);
+			Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			if (didCreateWp) {
-		    	Global.mainTab.updatePendingChanges();
+				Global.mainTab.updatePendingChanges();
 				Global.mainTab.tbP.refreshTable();
 			}
-    	} else {
-	   	    CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-	   	    if (ch == null) {
-	   	    	err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
-	   	    	return;
-	   	    }
+		} else {
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, "Goto: Waypoint does not exist: ") + waypointName);
+				return;
+			}
 			CacheHolder addiWpt;
-	   	    if (ch.hasAddiWpt()){
-	   	    	op.append("cls()\n");
-				for (int j=0; j<ch.addiWpts.getCount();j++){
-					addiWpt = (CacheHolder)ch.addiWpts.get(j);
+			if (ch.hasAddiWpt()) {
+				op.append("cls()\n");
+				for (int j = 0; j < ch.addiWpts.getCount(); j++) {
+					addiWpt = (CacheHolder) ch.addiWpts.get(j);
 					op.append("IF $");
 					op.append(addiWpt.getWayPoint());
 					op.append("=\"\" THEN\n   $");
 					op.append(addiWpt.getWayPoint());
 					op.append("=\"\"");
-					//op.append(addiWpt.pos.toString());
+					// op.append(addiWpt.pos.toString());
 					op.append("\n   \"Punkt ");
-					op.append(addiWpt.getWayPoint().substring(0,2));
+					op.append(addiWpt.getWayPoint().substring(0, 2));
 					op.append(" [");
 					op.append(addiWpt.getCacheName());
 					op.append("] = \" $");
 					op.append(addiWpt.getWayPoint());
-					if (addiWpt.getCacheDetails(true).LongDescription.trim().length()>0)
-						op.append("\n   \""+STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription,"\"","\"\"")+"\"");
+					if (addiWpt.getCacheDetails(true).LongDescription.trim().length() > 0)
+						op.append("\n   \"" + STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription, "\"", "\"\"") + "\"");
 					op.append("\n   goto($");
 					op.append(addiWpt.getWayPoint());
 					op.append("); STOP\nENDIF\n\n");
 				}
-				Global.mainTab.solverP.mText.appendText(op.toString(),true);
+				Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			}// if hasAddiWpt
-    	}
-    }
+		}
+	}
 
-    private double funcSqrt() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	if (a<0) err(MyLocale.getMsg(1720,"Cannot calculate square root of a negative number"));
-    	return java.lang.Math.sqrt(a);
-    }
+	private double funcSqrt() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		if (a < 0)
+			err(MyLocale.getMsg(1720, "Cannot calculate square root of a negative number"));
+		return java.lang.Math.sqrt(a);
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and put result into a string */
-    private String funcSval(String s) {
-       	s=s.toLowerCase();
-    	String res="";
-       	for (int i=0; i<s.length(); i++) {
-    		int pos="abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i));
-    		if (pos>=0)
-    			res+=(res==""?"":" ")+MyLocale.formatLong(pos+1,"00");
-    	}
-    	return res;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and put result into a string */
+	private String funcSval(String s) {
+		s = s.toLowerCase();
+		String res = "";
+		for (int i = 0; i < s.length(); i++) {
+			int pos = "abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i));
+			if (pos >= 0)
+				res += (res == "" ? "" : " ") + MyLocale.formatLong(pos + 1, "00");
+		}
+		return res;
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and sum them */
-    private double funcVal(String s) {
-    	s=s.toLowerCase();
-    	int sum=0;
-    	for (int i=0; i<s.length(); i++) {
-    		sum+="abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i))+1;
-    	}
-    	return sum;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and sum them */
+	private double funcVal(String s) {
+		s = s.toLowerCase();
+		int sum = 0;
+		for (int i = 0; i < s.length(); i++) {
+			sum += "abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i)) + 1;
+		}
+		return sum;
+	}
 
-///////////////////////////////////////////
-//  PARSER
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// PARSER
+	// /////////////////////////////////////////
 
+	/**
+	 * The following methods implement a recursive descent parser.
+	 * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
+	 * a valid token.
+	 */
 
-    /** The following methods implement a recursive descent parser.
-     * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
-     * a valid token.
-     */
-
-	private void parseCommand()  throws Exception {
-		while(scanpos < tokenStack.size()) {
+	private void parseCommand() throws Exception {
+		while (scanpos < tokenStack.size()) {
 			getToken();
-			if (thisToken.token.equals(";")) continue;  // skip an empty command
-			if (thisToken.tt==TokenObj.TT_IF)
+			if (thisToken.token.equals(";"))
+				continue; // skip an empty command
+			if (thisToken.tt == TokenObj.TT_IF)
 				parseIf();
 			else
 				parseSimpleCommand();
@@ -929,314 +940,385 @@
 		}
 	}
 
-	private void parseSimpleCommand() throws Exception{
-		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception("STOP");  // Terminate without error message
+	private void parseSimpleCommand() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STOP)
+			throw new Exception("STOP"); // Terminate without error message
 		if (thisToken.token.equals("$")) { // Show all global variables
 			showVars(true);
 			getToken();
 		} else if (thisToken.token.equals("?")) { // Show all local variables
 			showVars(false);
 			getToken();
-		} else if (thisToken.tt==TokenObj.TT_VARIABLE && lookAheadToken().tt==TokenObj.TT_EQ)
+		} else if (thisToken.tt == TokenObj.TT_VARIABLE && lookAheadToken().tt == TokenObj.TT_EQ)
 			parseAssign();
 		else {
 			parseStringExp();
-			while (calcStack.size()>0) messageStack.add(popCalcStackAsString());
+			while (calcStack.size() > 0)
+				messageStack.add(popCalcStackAsString());
 		}
 	}
 
-	private void parseIf() throws Exception{
+	private void parseIf() throws Exception {
 		int compOp;
-		boolean compRes=false;
-		TokenObj ifToken=thisToken;
+		boolean compRes = false;
+		TokenObj ifToken = thisToken;
 		getToken();
 		// Check for "IF varName THEN" construct to check whether a variable is defined
-		if (thisToken.tt==TokenObj.TT_VARIABLE && peekToken().token.toUpperCase().equals("THEN")) {
-			String varName=thisToken.token;
-			getToken(); //THEN
-			Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-			if(result == null) { // Var not found check whether it is a waypoint
+		if (thisToken.tt == TokenObj.TT_VARIABLE && peekToken().token.toUpperCase().equals("THEN")) {
+			String varName = thisToken.token;
+			getToken(); // THEN
+			Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+			if (result == null) { // Var not found check whether it is a waypoint
 				if (varName.startsWith("$")) { // Could be a cachename
-					varName=varName.substring(1);
-					compRes=Global.getProfile().getCacheIndex(varName)!=-1;
+					varName = varName.substring(1);
+					compRes = Global.getProfile().getCacheIndex(varName) != -1;
 				} else
-					compRes=false;
-			} else // Found the variable, it must have a value
-				compRes=true;
+					compRes = false;
+			} else
+				// Found the variable, it must have a value
+				compRes = true;
 			getNextTokenOtherThanSemi();
 		} else { // Normal: IF expression THEN
 			parseStringExp();
-			compOp=thisToken.tt;
-			if (compOp<TokenObj.TT_LT || compOp>TokenObj.TT_NE) err(MyLocale.getMsg(1723,"Comparison operator expected"));
+			compOp = thisToken.tt;
+			if (compOp < TokenObj.TT_LT || compOp > TokenObj.TT_NE)
+				err(MyLocale.getMsg(1723, "Comparison operator expected"));
 			getToken();
 			parseStringExp();
 			checkNextSymIs("THEN");
 			getNextTokenOtherThanSemi();
-			boolean compAsString=false; //calcStack.get(calcStack.size()-2) instanceof String;
+			boolean compAsString = false; // calcStack.get(calcStack.size()-2) instanceof String;
 			// If we can parse the first argument as a double, we will do a numeric comparison
 			try {
-				Common.parseDoubleException((String)calcStack.get(calcStack.size()-2) );
+				Common.parseDoubleException((String) calcStack.get(calcStack.size() - 2));
 			} catch (Exception ex) {
-				compAsString=true;
+				compAsString = true;
 			}
 			// If the first expression is not a double, compare as string.
 			if (compAsString) {
-				String b=popCalcStackAsString();
-				String a=popCalcStackAsString();
+				String b = popCalcStackAsString();
+				String a = popCalcStackAsString();
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a.equals(b); break;
-					case TokenObj.TT_NE: compRes=!a.equals(b); break;
-					case TokenObj.TT_LT: compRes=a.compareTo(b)<0; break;
-					case TokenObj.TT_GT: compRes=a.compareTo(b)>0; break;
-					case TokenObj.TT_LE: compRes=a.compareTo(b)<=0; break;
-					case TokenObj.TT_GE: compRes=a.compareTo(b)>=0; break;
+				case TokenObj.TT_EQ:
+					compRes = a.equals(b);
+					break;
+				case TokenObj.TT_NE:
+					compRes = !a.equals(b);
+					break;
+				case TokenObj.TT_LT:
+					compRes = a.compareTo(b) < 0;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a.compareTo(b) > 0;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a.compareTo(b) <= 0;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a.compareTo(b) >= 0;
+					break;
 				}
 			} else { // First expression is a number, compare as numbers
-				double b=popCalcStackAsNumber(0);
-				double a=popCalcStackAsNumber(0);
+				double b = popCalcStackAsNumber(0);
+				double a = popCalcStackAsNumber(0);
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a==b; break;
-					case TokenObj.TT_NE: compRes=a!=b; break;
-					case TokenObj.TT_LT: compRes=a<b; break;
-					case TokenObj.TT_GT: compRes=a>b; break;
-					case TokenObj.TT_LE: compRes=a<=b; break;
-					case TokenObj.TT_GE: compRes=a>=b; break;
+				case TokenObj.TT_EQ:
+					compRes = a == b;
+					break;
+				case TokenObj.TT_NE:
+					compRes = a != b;
+					break;
+				case TokenObj.TT_LT:
+					compRes = a < b;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a > b;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a <= b;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a >= b;
+					break;
 				}
 			}
 		}
 		if (compRes) { // comparison resulted in TRUE
-			if (thisToken.tt!=TokenObj.TT_ENDIF) {
+			if (thisToken.tt != TokenObj.TT_ENDIF) {
 				parseSimpleCommand();
 				while (thisToken.token.equals(";")) {
 					getNextTokenOtherThanSemi(); // Now we have either an ENDIF or the start of a simpleexpression
-					if (thisToken.tt==TokenObj.TT_ENDIF) break;
+					if (thisToken.tt == TokenObj.TT_ENDIF)
+						break;
 					parseSimpleCommand();
 				}
 				checkNextSymIs("ENDIF");
 			}
 			getToken();
-		} else // comparison failed
+		} else
+			// comparison failed
 			skipPastEndif(ifToken);
 	}
 
-	private void parseAssign() throws Exception  {
-		String varName=new String(thisToken.token);
-		getToken(); //=
+	private void parseAssign() throws Exception {
+		String varName = new String(thisToken.token);
+		getToken(); // =
 		getToken();
 		// Assigns of the format A=; are ignored so that they can stay as placeholders and
 		// we can fill the data progressively during a multicache
-		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(";")) return;
+		if (thisToken.tt == TokenObj.TT_ENDIF || thisToken.token.equals(";"))
+			return;
 		parseStringExp();
 		if (varName.startsWith("$")) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Yes, is a coordinate
 				// Check whether new coordinates are valid
-				String coord=popCalcStackAsString();
+				String coord = popCalcStackAsString();
 				cwPt.set(coord);
 				if (cwPt.isValid() || coord.equals("")) { // Can clear coord with empty string
-					ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-					ch.pos.set(cwPt);
+					ch.setPos(cwPt);
 					ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance and bearing
-		    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-				    return;
+					Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+					return;
 				} else
-					err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
+					err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
 			}
 			// Name starts with $ but is not a waypoint, fall through and set it as global variable
 		}
-		symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName, popCalcStackAsString());
+		symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, popCalcStackAsString());
 	}
 
-	private void parseStringExp()throws Exception {
-		if (thisToken.tt==TokenObj.TT_STRING) {
+	private void parseStringExp() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 			getToken();
 		} else {
 			parseExp();
 		}
-		//calcStack.add(popCalcStackAsString());
-		while (thisToken.tt==TokenObj.TT_STRING ||
-			   thisToken.tt==TokenObj.TT_NUMBER ||
-			   thisToken.tt==TokenObj.TT_VARIABLE ||
-			   thisToken.tt==TokenObj.TT_SYMBOL && thisToken.token.equals("(")) {
-			if (thisToken.tt==TokenObj.TT_STRING) {
+		// calcStack.add(popCalcStackAsString());
+		while (thisToken.tt == TokenObj.TT_STRING || thisToken.tt == TokenObj.TT_NUMBER || thisToken.tt == TokenObj.TT_VARIABLE || thisToken.tt == TokenObj.TT_SYMBOL && thisToken.token.equals("(")) {
+			if (thisToken.tt == TokenObj.TT_STRING) {
 				calcStack.add(thisToken.token);
 				getToken();
 			} else {
 				parseTailExp('+');
 			}
-			String b=popCalcStackAsString();
-			String a=popCalcStackAsString();
-			calcStack.add(a+b);
+			String b = popCalcStackAsString();
+			String a = popCalcStackAsString();
+			calcStack.add(a + b);
 		}
 	}
 
-	private void parseExp()throws Exception {
-		char unaryOp='+';
-		if (thisToken.token.equals("+") || thisToken.token.equals("-") ) {
-			unaryOp=thisToken.token.charAt(0);
+	private void parseExp() throws Exception {
+		char unaryOp = '+';
+		if (thisToken.token.equals("+") || thisToken.token.equals("-")) {
+			unaryOp = thisToken.token.charAt(0);
 			getToken();
 		}
 		parseTailExp(unaryOp);
 	}
 
-	private void parseTailExp(char unaryOp)throws Exception {
+	private void parseTailExp(char unaryOp) throws Exception {
 		parseTerm();
-		if (unaryOp=='-') { // Unary minus, negate the first term
+		if (unaryOp == '-') { // Unary minus, negate the first term
 			calcStack.add(new java.lang.Double(-popCalcStackAsNumber(0)));
 		}
-		while (thisToken.token.equals("+") || thisToken.token.equals("-") ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals("+") || thisToken.token.equals("-")) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseTerm();
-			double b=popCalcStackAsNumber(0);
-			double a=popCalcStackAsNumber(0);
-			if (op=='+')
-				calcStack.add(new java.lang.Double(a+b));
+			double b = popCalcStackAsNumber(0);
+			double a = popCalcStackAsNumber(0);
+			if (op == '+')
+				calcStack.add(new java.lang.Double(a + b));
 			else
-				calcStack.add(new java.lang.Double(a-b));
+				calcStack.add(new java.lang.Double(a - b));
 		}
 		// If expression is followed by a formatstring, format it
-		if (thisToken.tt==TokenObj.TT_FORMATSTR) {
-			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0),thisToken.token).replace(',','.'));
+		if (thisToken.tt == TokenObj.TT_FORMATSTR) {
+			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0), thisToken.token).replace(',', '.'));
 			getToken();
 		}
 	}
 
-	private void parseTerm() throws Exception{
+	private void parseTerm() throws Exception {
 		parseFactor();
-		while (thisToken.token.equals("*") || thisToken.token.equals("/") ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals("*") || thisToken.token.equals("/")) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseFactor();
-			double b=popCalcStackAsNumber(1);
-			double a=popCalcStackAsNumber(1);
-			if (op=='*')
-				calcStack.add(new java.lang.Double(a*b));
+			double b = popCalcStackAsNumber(1);
+			double a = popCalcStackAsNumber(1);
+			if (op == '*')
+				calcStack.add(new java.lang.Double(a * b));
+			else if (b == 0.0)
+				err(MyLocale.getMsg(1729, "Division by 0"));
 			else
-				if (b==0.0)
-					err(MyLocale.getMsg(1729,"Division by 0"));
-				else
-					calcStack.add(new java.lang.Double(a/b));
+				calcStack.add(new java.lang.Double(a / b));
 		}
 	}
 
-	private void parseFactor() throws Exception{
+	private void parseFactor() throws Exception {
 		parseExpFactor();
 		while (thisToken.token.equals("^")) {
 			getToken();
 			parseExpFactor();
-			double exp=popCalcStackAsNumber(0);
-			double base=popCalcStackAsNumber(0);
-			calcStack.add(new java.lang.Double(java.lang.Math.pow(base,exp)));
+			double exp = popCalcStackAsNumber(0);
+			double base = popCalcStackAsNumber(0);
+			calcStack.add(new java.lang.Double(java.lang.Math.pow(base, exp)));
 		}
 	}
 
 	private void parseExpFactor() throws Exception {
 		fnType funcDef;
-		if (thisToken.tt==TokenObj.TT_VARIABLE) {
-			if (isVariable(thisToken.token) && !lookAheadToken().token.equals("(") )
+		if (thisToken.tt == TokenObj.TT_VARIABLE) {
+			if (isVariable(thisToken.token) && !lookAheadToken().token.equals("("))
 				calcStack.add(getVariable(thisToken.token));
-			else if (!lookAheadToken().token.equals("(")) err(MyLocale.getMsg(1724,"Variable not set: ")+thisToken.token);
-			    else {// Must be a function definition
-				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
+			else if (!lookAheadToken().token.equals("("))
+				err(MyLocale.getMsg(1724, "Variable not set: ") + thisToken.token);
+			else {// Must be a function definition
+				funcDef = getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
 				parseFunction(funcDef);
-			    }
-		} else if (thisToken.tt==TokenObj.TT_NUMBER) {
+			}
+		} else if (thisToken.tt == TokenObj.TT_NUMBER) {
 			calcStack.add(getNumber(thisToken.token));
-		} else if (thisToken.tt==TokenObj.TT_STRING) {
+		} else if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 		} else if (thisToken.token.equals("(")) {
 			getToken();
 			parseStringExp();
 			checkNextSymIs(")");
-		}
-		else err(MyLocale.getMsg(1725,"Unexpected character(s): ")+thisToken.token);
+		} else
+			err(MyLocale.getMsg(1725, "Unexpected character(s): ") + thisToken.token);
 		getToken();
 	}
 
 	private void parseFunction(fnType funcDef) throws Exception {
-		String funcName=new String(thisToken.token);
-        int nargs=0;
+		String funcName = new String(thisToken.token);
+		int nargs = 0;
 		getToken();
 		checkNextSymIs("(");
 		getToken();
 		if (!thisToken.token.equals(")")) { // at least one argument
 			parseStringExp();
-			nargs=1;
+			nargs = 1;
 			while (thisToken.token.equals(",")) {
-				if (nargs==4) err(MyLocale.getMsg(1726,"Too many arguments for function ")+funcName);
+				if (nargs == 4)
+					err(MyLocale.getMsg(1726, "Too many arguments for function ") + funcName);
 				getToken();
 				parseStringExp();
 				nargs++;
 			}
 			checkNextSymIs(")");
 		}
-		//getToken(); done in parseFactor
-		executeFunction(funcName,nargs,funcDef);
+		// getToken(); done in parseFactor
+		executeFunction(funcName, nargs, funcDef);
 	}
 
 	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
-		if (!funcDef.nargsValid(nargs)) err(MyLocale.getMsg(1727,"Invalid number of arguments"));
-	         if (funcDef.alias.equals("asin")) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
-	 	else if (funcDef.alias.equals("abs")) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
-	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("atan")) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("bearing")) calcStack.add(new java.lang.Double(funcBearing()));
-	    else if (funcDef.alias.equals("center")) funcCenter(nargs);
-	    else if (funcDef.alias.equals("cls")) funcCls();
-	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("count")) funcCount();
-	    else if (funcDef.alias.equals("cp")) calcStack.add(funcCp());
-	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
-	    else if (funcDef.alias.equals("deg")) funcDeg(true);
-	    else if (funcDef.alias.equals("deg2rad")) calcStack.add(new java.lang.Double(funcDeg2Rad()));
-	    else if (funcDef.alias.equals("distance")) calcStack.add(new java.lang.Double(funcDistance()));
-	    else if (funcDef.alias.equals("encode")) calcStack.add(funcEncode());
-	    else if (funcDef.alias.equals("format")) calcStack.add(funcFormat(nargs));
-	    else if (funcDef.alias.equals("goto")) funcGoto(nargs);
-	    else if (funcDef.alias.equals("ic")) funcIgnoreVariableCase(nargs);
-	    else if (funcDef.alias.equals("instr")) calcStack.add(new Double(funcInstr(nargs)));
-	    else if (funcDef.alias.equals("int")) calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
-	    else if (funcDef.alias.equals("lc")) calcStack.add(popCalcStackAsString().toLowerCase());
-	    else if (funcDef.alias.equals("len")) calcStack.add(new Double(popCalcStackAsString().length()));
-	    else if (funcDef.alias.equals("mid")) calcStack.add(funcMid(nargs));
-	    else if (funcDef.alias.equals("mod")) calcStack.add(funcMod());
-	    else if (funcDef.alias.equals("project")) calcStack.add(funcProject());
-	    else if (funcDef.alias.equals("pz")) funcPz(nargs);
-	    else if (funcDef.alias.equals("rad")) funcDeg(false);
-	    else if (funcDef.alias.equals("rad2deg")) calcStack.add(new java.lang.Double(funcRad2Deg()));
-	    else if (funcDef.alias.equals("replace")) calcStack.add(funcReplace());
-	    else if (funcDef.alias.equals("reverse")) calcStack.add(funcReverse(popCalcStackAsString()));
-	    else if (funcDef.alias.equals("rot13")) calcStack.add(Common.rot13(popCalcStackAsString()));
-//	    else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);
-	    else if (funcDef.alias.equals("show"));
-	    else if (funcDef.alias.equals("sin")) calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("skeleton")) funcSkeleton(nargs);
-	    else if (funcDef.alias.equals("sqrt")) calcStack.add(new java.lang.Double(funcSqrt()));
-	    else if (funcDef.alias.equals("sval")) calcStack.add(funcSval(popCalcStackAsString()));
-	    else if (funcDef.alias.equals("tan")) calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("uc")) calcStack.add(popCalcStackAsString().toUpperCase());
-	    else if (funcDef.alias.equals("val")) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
-	    else if (funcDef.alias.equals("cb")) calcStack.add(funcCrossBearing ());
-	    else err(MyLocale.getMsg(1728,"Function not yet implemented: ")+funcName);
+		if (!funcDef.nargsValid(nargs))
+			err(MyLocale.getMsg(1727, "Invalid number of arguments"));
+		if (funcDef.alias.equals("asin"))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("abs"))
+			calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
+		else if (funcDef.alias.equals("acos"))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("atan"))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("bearing"))
+			calcStack.add(new java.lang.Double(funcBearing()));
+		else if (funcDef.alias.equals("center"))
+			funcCenter(nargs);
+		else if (funcDef.alias.equals("cls"))
+			funcCls();
+		else if (funcDef.alias.equals("cos"))
+			calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("count"))
+			funcCount();
+		else if (funcDef.alias.equals("cp"))
+			calcStack.add(funcCp());
+		else if (funcDef.alias.equals("ct"))
+			calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
+		else if (funcDef.alias.equals("deg"))
+			funcDeg(true);
+		else if (funcDef.alias.equals("deg2rad"))
+			calcStack.add(new java.lang.Double(funcDeg2Rad()));
+		else if (funcDef.alias.equals("distance"))
+			calcStack.add(new java.lang.Double(funcDistance()));
+		else if (funcDef.alias.equals("encode"))
+			calcStack.add(funcEncode());
+		else if (funcDef.alias.equals("format"))
+			calcStack.add(funcFormat(nargs));
+		else if (funcDef.alias.equals("goto"))
+			funcGoto(nargs);
+		else if (funcDef.alias.equals("ic"))
+			funcIgnoreVariableCase(nargs);
+		else if (funcDef.alias.equals("instr"))
+			calcStack.add(new Double(funcInstr(nargs)));
+		else if (funcDef.alias.equals("int"))
+			calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
+		else if (funcDef.alias.equals("lc"))
+			calcStack.add(popCalcStackAsString().toLowerCase());
+		else if (funcDef.alias.equals("len"))
+			calcStack.add(new Double(popCalcStackAsString().length()));
+		else if (funcDef.alias.equals("mid"))
+			calcStack.add(funcMid(nargs));
+		else if (funcDef.alias.equals("mod"))
+			calcStack.add(funcMod());
+		else if (funcDef.alias.equals("project"))
+			calcStack.add(funcProject());
+		else if (funcDef.alias.equals("pz"))
+			funcPz(nargs);
+		else if (funcDef.alias.equals("rad"))
+			funcDeg(false);
+		else if (funcDef.alias.equals("rad2deg"))
+			calcStack.add(new java.lang.Double(funcRad2Deg()));
+		else if (funcDef.alias.equals("replace"))
+			calcStack.add(funcReplace());
+		else if (funcDef.alias.equals("reverse"))
+			calcStack.add(funcReverse(popCalcStackAsString()));
+		else if (funcDef.alias.equals("rot13"))
+			calcStack.add(Common.rot13(popCalcStackAsString()));
+		// else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);
+		else if (funcDef.alias.equals("show"))
+			;
+		else if (funcDef.alias.equals("sin"))
+			calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("skeleton"))
+			funcSkeleton(nargs);
+		else if (funcDef.alias.equals("sqrt"))
+			calcStack.add(new java.lang.Double(funcSqrt()));
+		else if (funcDef.alias.equals("sval"))
+			calcStack.add(funcSval(popCalcStackAsString()));
+		else if (funcDef.alias.equals("tan"))
+			calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("uc"))
+			calcStack.add(popCalcStackAsString().toUpperCase());
+		else if (funcDef.alias.equals("val"))
+			calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
+		else if (funcDef.alias.equals("cb"))
+			calcStack.add(funcCrossBearing());
+		else
+			err(MyLocale.getMsg(1728, "Function not yet implemented: ") + funcName);
 	}
 
-	public void parse(Vector tck, Vector msgStack){
+	public void parse(Vector tck, Vector msgStack) {
 		calcStack.clear();
 		clearLocalSymbols();
 		tokenStack = tck;
 		messageStack = msgStack;
 		scanpos = 0;
-		try{
+		try {
 			parseCommand();
-		}catch(Exception ex){
+		} catch (Exception ex) {
 		}
 	}
 
-	private boolean createWptIfNeeded(String wayPoint, String name, byte type){
-	   	int ci=Global.getProfile().getCacheIndex(wayPoint);
-    	if (ci >= 0) return false;
+	private boolean createWptIfNeeded(String wayPoint, String name, byte type) {
+		int ci = Global.getProfile().getCacheIndex(wayPoint);
+		if (ci >= 0)
+			return false;
 
 		CacheHolder ch = new CacheHolder();
 		ch.setWayPoint(wayPoint);

Modified: branches/r1.2/src/CacheWolf/Preferences.java
===================================================================
--- branches/r1.2/src/CacheWolf/Preferences.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Preferences.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -46,34 +46,35 @@
 import ewe.ui.MessageBox;
 import ewe.ui.Window;
 import ewe.ui.WindowConstants;
+import ewe.ui.mApp;
 import ewe.util.Comparer;
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Map.MapEntry;
 import ewe.util.StringTokenizer;
 import ewe.util.Utils;
-import ewe.util.Map.MapEntry;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	A class to hold the preferences that were loaded upon start up of CacheWolf.
- *	This class is also capable of parsing the prefs.xml file as well as
- *	saving the current settings of preferences.
+ * A class to hold the preferences that were loaded upon start up of CacheWolf. This class is also capable of parsing
+ * the prefs.xml file as well as saving the current settings of preferences.
  */
-public class Preferences extends MinML{
+public class Preferences extends MinML {
 
-	public final int DEFAULT_MAX_LOGS_TO_SPIDER=250;
-	public final int DEFAULT_LOGS_PER_PAGE=5;
-	public final int DEFAULT_INITIAL_HINT_HEIGHT=10;
-	public final int DEFAULT_GPSD_PORT=2947;
-	public static final int GPSD_DISABLED   = 0; // do not use gpsd
+	public final int DEFAULT_MAX_LOGS_TO_SPIDER = 250;
+	public final int DEFAULT_LOGS_PER_PAGE = 5;
+	public final int DEFAULT_INITIAL_HINT_HEIGHT = 10;
+	public final int DEFAULT_GPSD_PORT = 2947;
+	public static final int GPSD_DISABLED = 0; // do not use gpsd
 	public static final int GPSD_FORMAT_OLD = 1; // use old protocol
-	public static final int GPSD_FORMAT_NEW = 2; // use new protocol (JSON)
+	public static final int GPSD_FORMAT_NEW = 2; // use new protocol
+	// (JSON)
 	public static final int YES = 0;
 	public static final int NO = 1;
 	public static final int ASK = 2;
-	public static String NEWLINE="\n";
+	public static String NEWLINE = "\n";
 	// Hashtable is saving filter data objects the user wants to save
 	private Hashtable filterList = new Hashtable(15);
 	/** screen is big enough to hold additional information like cache notes */
@@ -81,13 +82,15 @@
 	/** display big icons. default only true for VGA PDAs */
 	// TODO: make this configurable via pref.xml
 	public boolean useBigIcons;
+	public boolean useRadar;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-    // Constructor
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Constructor
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Singleton pattern - return reference to Preferences
+	 * 
 	 * @return Singleton Preferences object
 	 */
 	public static Preferences getPrefObject() {
@@ -103,82 +106,92 @@
 
 	/**
 	 * Call this method to set the path of the config file <br>
-	 * If you call it with null it defaults to [program-dir]/pref.xml
-	 * if p is a directory "pref.xml" will automatically appended
+	 * If you call it with null it defaults to [program-dir]/pref.xml if p is a directory "pref.xml" will automatically
+	 * appended
+	 * 
 	 * @param p
 	 */
 	public void setPathToConfigFile(String p) {
 		String p_;
 		if (p == null) {
 			/*
-			String test;
-			test = Vm.getenv("APPDATA", "/"); // returns in java-vm on win xp: c:\<dokumente und Einstellungen>\<username>\<application data>
-			log("Vm.getenv(APPDATA: " + test); // this works also in win32.exe (ewe-vm on win xp)
-			test = Vm.getenv("HOME", "/"); // This should return on *nix system the home dir
-			log("Vm.getenv(HOME: " + test);
-			test = System.getProperty("user.dir"); // return in java-vm on win xp: <working dir> or maybe <program dir>
-			log("System.getProperty(user.dir: " + test); // in win32.exe -> null
-			test = System.getProperty("user.home"); // in MS-java-VM env variable $HOME is ignored and always <windir>\java returned, see http://support.microsoft.com/kb/177181/en-us/
-			log("System.getProperty(user.home: " + test); // in win32.exe -> null
-			// "user.dir"              User's current working directory
-			// "user.home"             User home directory (taken from http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html )
+			 * String test; test = Vm.getenv("APPDATA", "/");
+			 * // returns in java-vm on win xp: c:\<dokumente und Einstellungen>\<username>\<application data> log("Vm.getenv(APPDATA: " + test);
+			 * // this works also in win32.exe (ewe-vm on win xp) test = Vm.getenv("HOME",
+			 * "/"); // This should return on *nix system the home dir
+			 * log("Vm.getenv(HOME: " + test); test =
+			 * System.getProperty("user.dir"); // return in java-vm on win
+			 * xp: <working dir> or maybe <program dir>
+			 * log("System.getProperty(user.dir: " + test); // in win32.exe ->
+			 * null test = System.getProperty("user.home"); // in MS-java-VM
+			 * env variable $HOME is ignored and always <windir>\java
+			 * returned, see http://support.microsoft.com/kb/177181/en-us/
+			 * log("System.getProperty(user.home: " + test); // in win32.exe ->
+			 * null // "user.dir" User's current working directory //
+			 * "user.home" User home directory (taken from
+			 * http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html )
 			 */
 			p_ = FileBase.makePath(FileBase.getProgramDirectory(), "pref.xml");
+		} else {
+			if (new FileBugfix(p).isDirectory())
+				p_ = FileBase.makePath(p, "pref.xml");
+			else
+				p_ = p;
 		}
-		else {
-			if (new FileBugfix(p).isDirectory()) p_ = FileBase.makePath(p, "pref.xml");
-			else p_ = p;
-		}
-		pathToConfigFile = STRreplace.replace(p_, "//", "/"); // this is necessary in case that the root dir is the dir where the pref.xml is stored
+		// this is necessary in case that the root dir is the dir where the pref.xml is stored
+		pathToConfigFile = STRreplace.replace(p_, "//", "/");
 		pathToConfigFile = pathToConfigFile.replace('\\', '/');
-		p=System.getProperty("os.name");
-		if (p==null || p.indexOf("indows")!=-1) {
+		p = System.getProperty("os.name");
+		if (p == null || p.indexOf("indows") != -1) {
 			NEWLINE = "\r\n";
-		} 
+		}
 	}
 
 	/**
 	 * Constructor is private for a singleton object
 	 */
-	private Preferences(){
+	private Preferences() {
 		mySPO.bits = 8;
 		mySPO.parity = SerialPort.NOPARITY;
 		mySPO.stopBits = 1;
 		mySPO.baudRate = 4800;
-		if ( ((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0))).height > 400) {
+		if (((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new ewe.fx.Rect(), 0))).height > 400) {
 			if (Vm.getPlatform().equals("Unix"))
 				fontSize = 12;
-			else{
+			else {
 				// Default on VGA-PDAs: fontSize 21 + adjust ColWidth
-				if (Vm.isMobile()){
+				if (Vm.isMobile()) {
 					fontSize = 21;
-					listColWidth="20,20,30,30,92,177,144,83,60,105,50,104,22,30,30";
-				}
-				else
+					listColWidth = "20,20,30,30,92,177,144,83,60,105,50,104,22,30,30";
+				} else
 					fontSize = 16;
 			}
 		} else
 			fontSize = 11;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	/** The base directory contains one subdirectory for each profile*/
+	/** The base directory contains one subdirectory for each profile */
 	private String baseDir = "";
 	public String absoluteBaseDir = "";
 	/** Name of last used profile */
-	public String lastProfile="";
-	/** If true, the last profile is reloaded automatically without a dialogue */
-	public boolean autoReloadLastProfile=false;
-	/** If true current cetre will be set from gps position	 */
-	public boolean setCurrentCentreFromGPSPosition=true;
+	public String lastProfile = "";
+	/**
+	 * If true, the last profile is reloaded automatically without a dialogue
+	 */
+	public boolean autoReloadLastProfile = false;
+	/** If true current cetre will be set from gps position */
+	public boolean setCurrentCentreFromGPSPosition = true;
 	/** This is the login alias for geocaching.com and opencaching.de */
 	public String myAlias = "";
 	/** Optional password */
-	public String password="";
-	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs) */
+	public String password = "";
+	/**
+	 * This is an alternative alias used to identify found caches (i.e. if using multiple IDs)
+	 */
 	public String myAlias2 = "";
 	/** The path to the browser */
 	public String browser = "";
@@ -187,7 +200,7 @@
 	/** HTTP proxy port when spidering */
 	public String myproxyport = "";
 	/** Flag whether proxy is to be used */
-	public boolean proxyActive=false;
+	public boolean proxyActive = false;
 	/** Serial port name and baudrate */
 	public SerialPortOptions mySPO = new SerialPortOptions();
 	/** True if the GPS data should be forwarded to an IP address */
@@ -205,67 +218,85 @@
 	/** Timer for logging GPS data */
 	public String logGPSTimer = "5";
 	/** The default font size */
-	public int fontSize; 
-	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
+	public int fontSize;
+	public String fontName;
+	// These settings govern where the menu and the tabs are displayed and
+	// whether the statusbas is shown
 	/** True if the menu is to be displayed at the top of the screen */
-	public boolean menuAtTop=true;
+	public boolean menuAtTop = true;
 	/** True if the tabs are to be displayed at the top of the screen */
-	public boolean tabsAtTop=true;
+	public boolean tabsAtTop = true;
 	/** True if the status bar is to be displayed (hidden if false) */
-	public boolean showStatus=true;
-	//public boolean noTabs=false;
-	/** True if the application can be closed by clicking on the close button in the top line.
-	 * This can be set to avoid accidental closing of the application */
-	public boolean hasCloseButton=true;
+	public boolean showStatus = true;
+	// public boolean noTabs=false;
+	/**
+	 * True if the application can be closed by clicking on the close button in the top line. This can be set to avoid
+	 * accidental closing of the application
+	 */
+	public boolean hasCloseButton = true;
 	/** True if the SIP is always visible */
 	public boolean fixSIP = false;
 	/** The list of visible columns in the list view */
-	public String listColMap="0,1,2,3,4,5,6,7,8,9,10,11,12";
+	public String listColMap = "0,1,2,3,4,5,6,7,8,9,10,11,12";
 	/** The widths for each column in list view */
-	public String listColWidth="15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30";
-	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
-	public String travelbugColMap="1,4,5,6,8,9,10,7";
+	public String listColWidth = "15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30";
+	/**
+	 * The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney
+	 */
+	public String travelbugColMap = "1,4,5,6,8,9,10,7";
 	/** The column widths for the travelbug journeys. */
-	public String travelbugColWidth="212,136,62,90,50,56,90,38,50,50,94,50";
-	/** If this flag is true, only non-logged travelbug journeys will be shown */
-	public boolean travelbugShowOnlyNonLogged=false;
+	public String travelbugColWidth = "212,136,62,90,50,56,90,38,50,50,94,50";
+	/**
+	 * If this flag is true, only non-logged travelbug journeys will be shown
+	 */
+	public boolean travelbugShowOnlyNonLogged = false;
 	/** If this is true, deleted images are shown with a ? in the imagepanel */
-	public boolean showDeletedImages=true;
-	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
-	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
+	public boolean showDeletedImages = true;
+	/**
+	 * This setting determines how many logs are shown per page of hintlogs (default 5)
+	 */
+	public int logsPerPage = DEFAULT_LOGS_PER_PAGE;
 	/** Initial height of hints field (set to 0 to hide them initially) */
-	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT;
+	public int initialHintHeight = DEFAULT_INITIAL_HINT_HEIGHT;
 	/** Maximum logs to spider */
 	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
 	/** True if the Solver should ignore the case of variables */
-	public boolean solverIgnoreCase=true;
-	/** True if the solver expects arguments for trigonometric functions in degrees */
-	public boolean solverDegMode=true;
+	public boolean solverIgnoreCase = true;
+	/**
+	 * True if the solver expects arguments for trigonometric functions in degrees
+	 */
+	public boolean solverDegMode = true;
 	/** True if the description panel should show images */
-	public boolean descShowImg=true;
+	public boolean descShowImg = true;
 	/** The type of connection which GPSBABEL uses: com1 OR usb. */
-	public String garminConn="com1";
+	public String garminConn = "com1";
 	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
-	public String garminGPSBabelOptions="";
-	/** Max. length for Garmin waypoint names (for etrex which can only accept 6 chars) */
-	public int garminMaxLen=0;
-	public boolean downloadMissingOC = false;
-	public String lastOCSite=OC.OCSites[0][OC.OC_HOSTNAME];
-	/** The currently used centre point, can be different from the profile's centrepoint. This is used
-	 *  for spidering */
-	private CWPoint curCentrePt=new CWPoint();
+	public String garminGPSBabelOptions = "";
+	/**
+	 * Max. length for Garmin waypoint names (for etrex which can only accept 6 chars)
+	 */
+	public int garminMaxLen = 0;
+	/** OC true = alle neu Laden false = wenn ?nderungsdatum neuer */
+	public boolean downloadAllOC = false;
+	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
+	/**
+	 * The currently used centre point, can be different from the profile's centrepoint. This is used for spidering
+	 */
+	private CWPoint curCentrePt = new CWPoint();
 	/** True if a login screen is displayed on each spider operation */
-	public boolean forceLogin=true;
+	public boolean forceLogin = true;
 	/** True if the goto panel is North centered */
 	public boolean northCenteredGoto = true;
 	/** If not null, a customs map path has been specified by the user */
-	private String customMapsPath=null;
+	private String customMapsPath = null;
 	/** Number of CacheHolder details that are kept in memory */
-	public int maxDetails=50;
-	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
-	public int deleteDetails=5;
+	public int maxDetails = 50;
+	/**
+	 * Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails
+	 */
+	public int deleteDetails = 5;
 	/** The locale code (DE, EN, ...) */
-	public String language="";
+	public String language = "";
 	/** The metric system to use */
 	public int metricSystem = Metrics.METRIC;
 	/** Load updated caches while spidering */
@@ -279,24 +310,27 @@
 	/** The own GC member ID */
 	public String gcMemberId = "";
 	/** Premium Member ? */
-	public boolean isPremium=true;
+	public boolean isPremium = true;
 	/** The maximum number of logs to export */
 	public int numberOfLogsToExport = 5;
 	/** Add Travelbugs when exporting */
 	public boolean exportTravelbugs = false;
 	/** Try to make a MyFinds GPX when exporting to GPX */
 	public boolean exportGpxAsMyFinds = true;
-	/** Check if lastFound is newer than saved log*/
-	public boolean checkLog=false;
-	/** Check if presence of TBs changed*/
-	public boolean checkTBs=true;
-	/** menu of spider along a route exists*/
-	public boolean spiderRoute=false;
+	/** Check if lastFound is newer than saved log */
+	public boolean checkLog = false;
+	/** Check if presence of TBs changed */
+	public boolean checkTBs = true;
+	/** Check if presence of DTS changed */
+	public boolean checkDTS = true;
+	/** menu of spider along a route exists */
+	public boolean spiderRoute = false;
 	/** Download images when loading cache data */
 	public boolean downloadPics = true;
 	/** Download TB information when loading cache data */
 	public boolean downloadTBs = true;
-	/** Last mode select in the DataMover for processing cache*/
+	public String userID = "";
+	/** Last mode select in the DataMover for processing cache */
 	public int processorMode = 0;
 	/** maximum number of logs to store in cache details */
 	public int maxLogsToKeep = DEFAULT_MAX_LOGS_TO_SPIDER;
@@ -304,40 +338,51 @@
 	public boolean alwaysKeepOwnLogs = true;
 
 	/** Determines whether to fill the white areas on the map */
-	public boolean fillWhiteArea=false;
+	public boolean fillWhiteArea = false;
 
-    /** Selected Size of map tiles */
-    public int mapTileSize=1;
-    /** How many should maptiles overlap */
-    public int mapOverlapping=100;
-    /** Width and height of free defined tile size */
-    public int tilewidth;
-    public int tileheight;
-    
-    /** ShowCachesOnMap */
-    public boolean showCachesOnMap=true;
+	/** Selected Size of map tiles */
+	public int mapTileSize = 1;
+	/** How many should maptiles overlap */
+	public int mapOverlapping = 100;
+	/** Width and height of free defined tile size */
+	public int tilewidth;
+	public int tileheight;
+	/** ShowCachesOnMap */
+	public boolean showCachesOnMap = true;
+	/** SortingGroupedByCache */
+	public boolean SortingGroupedByCache = true;
+	/** useOwnSymbols */
+	public boolean useOwnSymbols = true;
+	/** TRUE if we want automatic sorting * */
+	public boolean sortAutomatic = true;
+	//
+	public String oldLanguageCtl = "";
+	public boolean doNotGetFound = true;
 
-    /** SortingGroupedByCache */
-    public boolean SortingGroupedByCache=true;
-
-    /** useOwnSymbols */
-    public boolean useOwnSymbols=true;
-
-    /** TRUE if we want automatic sorting **/
-    public boolean sortAutomatic = true;
-
-	//////////////////////////////////////////////
-	/** The debug switch (Can be used to activate dormant code) by adding
-	 * the line: <pre><debug value="true" /></pre>
+	// ////////////////////////////////////////////
+	/**
+	 * The debug switch (Can be used to activate dormant code) by adding the line:
+	 * 
+	 * <pre>
+	 * &lt;debug value=&quot;true&quot; /&gt;
+	 * </pre>
+	 * 
 	 * to the pref.xml file.
 	 */
 	public boolean debug = false;
-	//////////////////////////////////////////////
+	// ////////////////////////////////////////////
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields not stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	/**
+	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms. It can
+	 * only be set in the Preference-File directly, not by user-interaction now. Add <MobileGui value="true"/> to your
+	 * pref.xml
+	 */
+	public boolean mobileGUI = false;
 
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields not stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
+
 	/** The height of the application */
 	public int myAppHeight = 600;
 	/** The width of the application */
@@ -347,66 +392,62 @@
 
 	private String pathToProfile;
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Read pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Read pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
-	 * Method to open and parse the config file (pref.xml). Results are stored in the
-	 * public variables of this class.
-	 * If you want to specify a non default config file call setPathToConfigFile() first.
+	 * Method to open and parse the config file (pref.xml). Results are stored in the public variables of this class. If
+	 * you want to specify a non default config file call setPathToConfigFile() first.
 	 */
-	public void readPrefFile(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
+	public void readPrefFile() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
 			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(pathToConfigFile));
 			parse(r);
 			r.close();
-		}catch(IOException e){
+		} catch (IOException e) {
 			log("IOException reading config file: " + pathToConfigFile, e, true);
 			browser = getDefaultBrowser();
 			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(176, "First start - using default preferences \n For experts only: \n Could not read preferences file:\n") + pathToConfigFile, FormBase.OKB)).execute();
-		}catch(Exception e){
+		} catch (Exception e) {
 			if (e instanceof NullPointerException)
-				log("Error reading pref.xml: NullPointerException in Element "+lastName +". Wrong attribute?",e,true);
+				log("Error reading pref.xml: NullPointerException in Element " + lastName + ". Wrong attribute?", e, true);
 			else
 				log("Error reading pref.xml: ", e);
 		}
-		useBigIcons = Vm.isMobile() && MyLocale.getScreenWidth() >= 400;
 		isBigScreen = (MyLocale.getScreenWidth() >= 400) && (MyLocale.getScreenHeight() >= 600);
 	}
 
-/**
- * Tries to find a executable browser
- * return "" if no browser found
- * @return
- */
+	/**
+	 * Tries to find a executable browser return "" if no browser found
+	 * 
+	 * @return
+	 */
 	private String getDefaultBrowser() {
 		String pf = Vm.getPlatform();
 		String testlist[] = null;
 		if (pf.equals("Java") || pf.equals("Win32")) {
-			String progdir = Vm.getenv("ProgramFiles", null); // at least in java-Win XP this is set
-			String homedir=Vm.getenv("HOMEPATH", "");
+			// at least in java-Win XP this is set
+			String progdir = Vm.getenv("ProgramFiles", null);
+			String homedir = Vm.getenv("HOMEPATH", "");
 			if (progdir != null) {
-				String test[] = {
-						homedir+"/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe",
-						progdir+"/Firefox/firefox.exe",
-						progdir+"/Opera/opera.exe",
-						progdir+"/Internet Explorer/iexplore.exe"};
+				String test[] = { homedir + "/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe", progdir + "/Firefox/firefox.exe", progdir + "/Opera/opera.exe", progdir + "/Internet Explorer/iexplore.exe" };
 				testlist = test;
 			} else {
 				String test[] = { // this part is not tested
-						"/opt/firefox/firefox", // default path in ubuntu
-						"/usr/bin/firefox"};
+				"/opt/firefox/firefox", // default path in ubuntu
+						"/usr/bin/firefox" };
 				testlist = test;
 			}
 		}
 		if (pf.equals("WinCE")) {
-			String test[] = {"/windows/iexplore.exe"};
+			String test[] = { "/windows/iexplore.exe" };
 			testlist = test;
 		}
 		if (testlist != null) {
-			for (int i=0; i < testlist.length; i++)
+			for (int i = 0; i < testlist.length; i++)
 				if ((new FileBugfix(testlist[i])).exists()) {
 					return testlist[i];
 				}
@@ -415,10 +456,12 @@
 	}
 
 	/** Helper variables for XML parser */
-	private StringBuffer collectElement=null;
-	private String lastName; // The string to the last XML that was processed
+	private StringBuffer collectElement = null;
+	// The string to the last XML that was processed
+	private String lastName;
+
 	private long getLongAttr(AttributeList atts, String name) {
-		String stmp=atts.getValue(name);
+		String stmp = atts.getValue(name);
 		long ret = 0l;
 		if (stmp != null) {
 			ret = Convert.parseLong(stmp);
@@ -429,176 +472,192 @@
 	/**
 	 * Method that gets called when a new element has been identified in pref.xml
 	 */
-	public void startElement(String name, AttributeList atts){
-		lastName=name;
+	public void startElement(String name, AttributeList atts) {
+		lastName = name;
 		String tmp;
-		if(name.equals("browser")) {
+		if (name.equals("browser")) {
 			browser = atts.getValue("name");
-			if (browser == null || browser.length() == 0) browser = getDefaultBrowser();
-		}
-		else if(name.equals("fixedsip")) {
-			if(atts.getValue("state").equals("true")) {
+			if (browser == null || browser.length() == 0)
+				browser = getDefaultBrowser();
+		} else if (name.equals("fixedsip")) {
+			if (atts.getValue("state").equals("true")) {
 				fixSIP = true;
 			}
-		}
-		else if(name.equals("font")) fontSize = Convert.toInt(atts.getValue("size"));
-		else if(name.equals("alias")) {
+		} else if (name.equals("font")) {
+			fontSize = Convert.toInt(atts.getValue("size"));
+			fontName = atts.getValue("name");
+			if (fontName == null)
+				fontName = mApp.findFont("gui").getName();
+		} else if (name.equals("alias")) {
 			myAlias = SafeXML.cleanback(atts.getValue("name"));
 			tmp = SafeXML.cleanback(atts.getValue("password"));
-			if (tmp != null) password=tmp;
-		}
-		else if(name.equals("alias2")) myAlias2 = SafeXML.cleanback(atts.getValue("name"));
-		else if(name.equals("gcmemberid")) {
+			if (tmp != null)
+				password = tmp;
+		} else if (name.equals("alias2"))
+			myAlias2 = SafeXML.cleanback(atts.getValue("name"));
+		else if (name.equals("gcmemberid")) {
 			gcMemberId = atts.getValue("name");
-			tmp=atts.getValue("Premium");
-			if (tmp != null) isPremium=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if(name.equals("location")){
-			curCentrePt.set(atts.getValue("lat")+" "+atts.getValue("long"));
-		}
-		else if(name.equals("port")){
+			tmp = atts.getValue("Premium");
+			if (tmp != null)
+				isPremium = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("location")) {
+			curCentrePt.set(atts.getValue("lat") + " " + atts.getValue("long"));
+		} else if (name.equals("port")) {
 			mySPO.portName = atts.getValue("portname");
 			mySPO.baudRate = Convert.toInt(atts.getValue("baud"));
-		}
-		else if(name.equals("portforward")) {
+		} else if (name.equals("portforward")) {
 			forwardGPS = Convert.toBoolean(atts.getValue("active"));
 			forwardGpsHost = atts.getValue("destinationHost");
-		}
-		else if(name.equals("gpsd")) {
+		} else if (name.equals("gpsd")) {
 			useGPSD = Convert.toInt(atts.getValue("active"));
 			gpsdHost = atts.getValue("host");
 			gpsdPort = Convert.toInt(atts.getValue("port"));
-		}
-		else if(name.equals("portlog")) {
+		} else if (name.equals("portlog")) {
 			logGPS = Convert.toBoolean(atts.getValue("active"));
 			logGPSTimer = atts.getValue("logTimer");
-		}
-		else if (name.equals("lastprofile")) {
-			collectElement=new StringBuffer(50);
-			if (atts.getValue("autoreload").equals("true")) autoReloadLastProfile=true;
-		}
-		else if (name.equals("CurrentCentre")) {
-			setCurrentCentreFromGPSPosition=Boolean.valueOf(atts.getValue("FromGPSPosition")).booleanValue();
-		}
-		else if(name.equals("basedir")) {
+		} else if (name.equals("lastprofile")) {
+			collectElement = new StringBuffer(50);
+			if (atts.getValue("autoreload").equals("true"))
+				autoReloadLastProfile = true;
+		} else if (name.equals("CurrentCentre")) {
+			setCurrentCentreFromGPSPosition = Boolean.valueOf(atts.getValue("FromGPSPosition")).booleanValue();
+		} else if (name.equals("basedir")) {
 			setBaseDir(atts.getValue("dir"));
-		}
-		else if (name.equals("opencaching")) {
-			tmp=atts.getValue("lastSite");
-			if (!(tmp == null) && OC.getSiteIndex(tmp)>=0 ) lastOCSite=tmp;
-			tmp=atts.getValue("downloadMissing");
-			if (!(tmp == null)) downloadMissingOC = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("listview")) {
-			listColMap=atts.getValue("colmap");
-			listColWidth=atts.getValue("colwidths");
-			while ((new StringTokenizer(listColWidth,",")).countTokens()<myTableModel.N_COLUMNS) listColWidth+=",30"; // for older versions
-		}
-		else if(name.equals("proxy")) {
+		} else if (name.equals("opencaching")) {
+			tmp = atts.getValue("lastSite");
+			if (!(tmp == null) && OC.getSiteIndex(tmp) >= 0)
+				lastOCSite = tmp;
+			tmp = atts.getValue("downloadMissing");
+			if (!(tmp == null))
+				downloadAllOC = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("listview")) {
+			listColMap = atts.getValue("colmap");
+			listColWidth = atts.getValue("colwidths");
+			while ((new StringTokenizer(listColWidth, ",")).countTokens() < myTableModel.N_COLUMNS)
+				listColWidth += ",30"; // for older versions
+		} else if (name.equals("proxy")) {
 			myproxy = atts.getValue("prx");
 			myproxyport = atts.getValue("prt");
 			tmp = atts.getValue("active");
-			if (tmp != null) proxyActive=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("garmin")) {
-			garminConn=atts.getValue("connection");
+			if (tmp != null)
+				proxyActive = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("garmin")) {
+			garminConn = atts.getValue("connection");
 			tmp = atts.getValue("GPSBabelOptions");
-			if (tmp != null) garminGPSBabelOptions=tmp;
+			if (tmp != null)
+				garminGPSBabelOptions = tmp;
 			tmp = atts.getValue("MaxWaypointLength");
-			if (tmp != null) garminMaxLen=Convert.toInt(tmp);
+			if (tmp != null)
+				garminMaxLen = Convert.toInt(tmp);
 			tmp = atts.getValue("addDetailsToWaypoint");
-			if (tmp != null) addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue("addDetailsToName");
-			if (tmp != null) addDetailsToName = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("imagepanel")) {
+			if (tmp != null)
+				addDetailsToName = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("imagepanel")) {
 			showDeletedImages = Boolean.valueOf(atts.getValue("showdeletedimages")).booleanValue();
-		}
-		else if (name.equals("descpanel")) {
+		} else if (name.equals("descpanel")) {
 			descShowImg = Boolean.valueOf(atts.getValue("showimages")).booleanValue();
-		}
-		else if (name.equals("screen")) {
-			menuAtTop=Boolean.valueOf(atts.getValue("menuattop")).booleanValue();
-			tabsAtTop=Boolean.valueOf(atts.getValue("tabsattop")).booleanValue();
-			showStatus=Boolean.valueOf(atts.getValue("showstatus")).booleanValue();
-			if (atts.getValue("hasclosebutton")!=null)
-				hasCloseButton=Boolean.valueOf(atts.getValue("hasclosebutton")).booleanValue();
-			if (atts.getValue("h")!=null) {
-				myAppHeight=Convert.toInt(atts.getValue("h"));
-				myAppWidth=Convert.toInt(atts.getValue("w"));
+		} else if (name.equals("screen")) {
+			menuAtTop = Boolean.valueOf(atts.getValue("menuattop")).booleanValue();
+			tabsAtTop = Boolean.valueOf(atts.getValue("tabsattop")).booleanValue();
+			showStatus = Boolean.valueOf(atts.getValue("showstatus")).booleanValue();
+			if (atts.getValue("hasclosebutton") != null)
+				hasCloseButton = Boolean.valueOf(atts.getValue("hasclosebutton")).booleanValue();
+			if (atts.getValue("h") != null) {
+				myAppHeight = Convert.toInt(atts.getValue("h"));
+				myAppWidth = Convert.toInt(atts.getValue("w"));
 			}
-		}
-		else if (name.equals("hintlogpanel")) {
+			if (atts.getValue("useBigIcons") != null)
+				useBigIcons = Boolean.valueOf(atts.getValue("useBigIcons")).booleanValue();
+			else {
+				useBigIcons = MyLocale.getScreenWidth() >= 400 && Vm.isMobile();
+			}
+			if (atts.getValue("useRadar") != null)
+				useRadar = Boolean.valueOf(atts.getValue("useRadar")).booleanValue();
+			else {
+				useRadar = MyLocale.getScreenWidth() >= 400 && Vm.isMobile();
+			}
+		} else if (name.equals("hintlogpanel")) {
 			logsPerPage = Convert.parseInt(atts.getValue("logsperpage"));
-			String strInitialHintHeight=atts.getValue("initialhintheight");
-			if (strInitialHintHeight!=null) initialHintHeight=Convert.parseInt(strInitialHintHeight);
-			String strMaxLogsToSpider=atts.getValue("maxspiderlogs");
-			if (strMaxLogsToSpider!=null) maxLogsToSpider=Convert.parseInt(strMaxLogsToSpider);
-		}
-		else if (name.equals("solver")) {
-			solverIgnoreCase=Boolean.valueOf(atts.getValue("ignorevariablecase")).booleanValue();
+			String strInitialHintHeight = atts.getValue("initialhintheight");
+			if (strInitialHintHeight != null)
+				initialHintHeight = Convert.parseInt(strInitialHintHeight);
+			String strMaxLogsToSpider = atts.getValue("maxspiderlogs");
+			if (strMaxLogsToSpider != null)
+				maxLogsToSpider = Convert.parseInt(strMaxLogsToSpider);
+		} else if (name.equals("solver")) {
+			solverIgnoreCase = Boolean.valueOf(atts.getValue("ignorevariablecase")).booleanValue();
 			tmp = atts.getValue("degMode");
-			if (tmp != null) solverDegMode=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("mapspath")) {
-			customMapsPath=SafeXML.cleanback(atts.getValue("dir")).replace('\\', '/');
-		}
-		else if (name.equals("debug")) debug=Boolean.valueOf(atts.getValue("value")).booleanValue();
+			if (tmp != null)
+				solverDegMode = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("mapspath")) {
+			customMapsPath = SafeXML.cleanback(atts.getValue("dir")).replace('\\', '/');
+		} else if (name.equals("debug"))
+			debug = Boolean.valueOf(atts.getValue("value")).booleanValue();
 
-		else if (name.equals("expPath")){
-			exporterPaths.put(atts.getValue("key"),atts.getValue("value"));
-		}
-		else if (name.equals("impPath")) {
+		else if (name.equals("expPath")) {
+			exporterPaths.put(atts.getValue("key"), atts.getValue("value"));
+		} else if (name.equals("impPath")) {
 			importerPaths.put(atts.getValue("key"), atts.getValue("value"));
-		}
-		else if (name.equals("travelbugs")) {
-			travelbugColMap=atts.getValue("colmap");
-			travelbugColWidth=atts.getValue("colwidths");
-			travelbugShowOnlyNonLogged=Boolean.valueOf(atts.getValue("shownonlogged")).booleanValue();
-		}
-		else if (name.equals("gotopanel")) {
+		} else if (name.equals("travelbugs")) {
+			travelbugColMap = atts.getValue("colmap");
+			travelbugColWidth = atts.getValue("colwidths");
+			travelbugShowOnlyNonLogged = Boolean.valueOf(atts.getValue("shownonlogged")).booleanValue();
+		} else if (name.equals("gotopanel")) {
 			northCenteredGoto = Boolean.valueOf(atts.getValue("northcentered")).booleanValue();
-		}
-		else if (name.equals("spider")) {
+		} else if (name.equals("spider")) {
+			doNotGetFound = !Boolean.valueOf(atts.getValue("getFinds")).booleanValue();
 			forceLogin = Boolean.valueOf(atts.getValue("forcelogin")).booleanValue();
 			checkLog = Boolean.valueOf(atts.getValue("checkLog")).booleanValue();
-      tmp = atts.getValue("checkTBs");
-			if (tmp != null) Boolean.valueOf(atts.getValue("checkTBs")).booleanValue();
+			tmp = atts.getValue("checkTBs");
+			if (tmp != null)
+				checkTBs = Boolean.valueOf(atts.getValue("checkTBs")).booleanValue();
+			tmp = atts.getValue("checkDTS");
+			if (tmp != null)
+				checkDTS = Boolean.valueOf(atts.getValue("checkDTS")).booleanValue();
 			spiderRoute = Boolean.valueOf(atts.getValue("spiderRoute")).booleanValue();
 			tmp = atts.getValue("spiderUpdates");
-			if (tmp != null) spiderUpdates=Convert.parseInt(tmp);
+			if (tmp != null)
+				spiderUpdates = Convert.parseInt(tmp);
 			tmp = atts.getValue("maxSpiderNumber");
-			if (tmp != null) maxSpiderNumber=Convert.parseInt(tmp);
+			if (tmp != null)
+				maxSpiderNumber = Convert.parseInt(tmp);
 			tmp = atts.getValue("downloadPics");
-			if (tmp != null) downloadPics=Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				downloadPics = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue("downloadTBs");
-			if (tmp != null) downloadTBs=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("details")) {
-			maxDetails=Common.parseInt(atts.getValue("cacheSize"));
-			deleteDetails=Common.parseInt(atts.getValue("delete"));
-			if (maxDetails<2) maxDetails=2;
-			if (deleteDetails<1) deleteDetails=1;
-		}
-		else if (name.equals("metric")) {
-			metricSystem=Common.parseInt(atts.getValue("type"));
-			if (metricSystem != Metrics.METRIC &&
-					metricSystem != Metrics.IMPERIAL) {
+			if (tmp != null)
+				downloadTBs = Boolean.valueOf(tmp).booleanValue();
+			userID = atts.getValue("UserID");
+			if (userID == null)
+				userID = "";
+		} else if (name.equals("details")) {
+			maxDetails = Common.parseInt(atts.getValue("cacheSize"));
+			deleteDetails = Common.parseInt(atts.getValue("delete"));
+			if (maxDetails < 2)
+				maxDetails = 2;
+			if (deleteDetails < 1)
+				deleteDetails = 1;
+		} else if (name.equals("metric")) {
+			metricSystem = Common.parseInt(atts.getValue("type"));
+			if (metricSystem != Metrics.METRIC && metricSystem != Metrics.IMPERIAL) {
 				metricSystem = Metrics.METRIC;
 			}
-		}
-		else if (name.equals("export")) {
+		} else if (name.equals("export")) {
 			tmp = atts.getValue("numberOfLogsToExport");
-			if (tmp != null) numberOfLogsToExport=Convert.parseInt(tmp);
+			if (tmp != null)
+				numberOfLogsToExport = Convert.parseInt(tmp);
 			tmp = atts.getValue("exportTravelbugs");
-			if (tmp != null) exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue("exportGpxAsMyFinds");
-			if (tmp != null) exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("locale")) {
+			if (tmp != null)
+				exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("locale")) {
 			language = atts.getValue("language");
-		}
-		else if (name.equals("FILTERDATA")) {
+		} else if (name.equals("FILTERDATA")) {
 			// Creating a filter object and reading the saved data
 			String id = SafeXML.cleanback(atts.getValue("id"));
 			FilterData data = new FilterData();
@@ -609,7 +668,7 @@
 			data.setFilterDiff(atts.getValue("diff"));
 			data.setFilterTerr(atts.getValue("terr"));
 			data.setFilterSize(atts.getValue("size"));
-			long[] filterAttr = { 0l,0l,0l,0l };
+			long[] filterAttr = { 0l, 0l, 0l, 0l };
 			filterAttr[0] = getLongAttr(atts, "attributesYes");
 			filterAttr[1] = getLongAttr(atts, "attributesYes1");
 			filterAttr[2] = getLongAttr(atts, "attributesNo");
@@ -620,178 +679,272 @@
 			data.setUseRegexp(Boolean.valueOf(atts.getValue("useRegexp")).booleanValue());
 			tmp = atts.getValue("noCoord");
 			if (tmp != null) {
-			  data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
-      } else {
-			  data.setFilterNoCoord(true);
-      }
+				data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
+			} else {
+				data.setFilterNoCoord(true);
+			}
 			// Filter object is remembered under the given ID
 			this.addFilter(id, data);
-		}
-		else if (name.equals ("datamover")){
+		} else if (name.equals("datamover")) {
 			tmp = atts.getValue("processorMode");
-			if (tmp != null){
-				processorMode=Convert.parseInt(tmp);
+			if (tmp != null) {
+				processorMode = Convert.parseInt(tmp);
 			}
-		}
-		else if (name.equals("logkeeping")) {
+		} else if (name.equals("logkeeping")) {
 			tmp = atts.getValue("maximum");
 			if (tmp != null)
 				maxLogsToKeep = Convert.parseInt(tmp);
-			if (maxLogsToKeep < 0) maxLogsToKeep = 0;
+			if (maxLogsToKeep < 0)
+				maxLogsToKeep = 0;
 
 			tmp = atts.getValue("keepown");
 			if (tmp != null)
 				alwaysKeepOwnLogs = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("fillWhiteArea")){
+		} else if (name.equals("fillWhiteArea")) {
 			tmp = atts.getValue("on");
 			fillWhiteArea = tmp != null && tmp.equalsIgnoreCase("true");
-		}
-		else if (name.equals("mapLoader")){
-			     tmp = atts.getValue("tileSize");
-			     if (tmp == null || tmp.length() == 0) tmp = "1";
-			     mapTileSize = Convert.parseInt(tmp);
-                 tmp = atts.getValue("overlapping");
-			     if (tmp == null || tmp.length() == 0) tmp = "100";
-			     mapOverlapping = Convert.parseInt(tmp);
-			     tmp = atts.getValue("tilewidth");
-			     tilewidth= (tmp != null && tmp.length() > 0)?Convert.parseInt(tmp):0;
-			     tmp = atts.getValue("tileheight");
-			     tileheight= (tmp != null && tmp.length() > 0)?Convert.parseInt(tmp):0;			    	 
-		}
-		else if (name.equals("showCachesOnMap")){
+		} else if (name.equals("mapLoader")) {
+			tmp = atts.getValue("tileSize");
+			if (tmp == null || tmp.length() == 0)
+				tmp = "1";
+			mapTileSize = Convert.parseInt(tmp);
+			tmp = atts.getValue("overlapping");
+			if (tmp == null || tmp.length() == 0)
+				tmp = "100";
+			mapOverlapping = Convert.parseInt(tmp);
+			tmp = atts.getValue("tilewidth");
+			tilewidth = (tmp != null && tmp.length() > 0) ? Convert.parseInt(tmp) : 0;
+			tmp = atts.getValue("tileheight");
+			tileheight = (tmp != null && tmp.length() > 0) ? Convert.parseInt(tmp) : 0;
+		} else if (name.equals("showCachesOnMap")) {
 			tmp = atts.getValue("on");
 			showCachesOnMap = tmp != null && tmp.equalsIgnoreCase("true");
-		}
-		else if (name.equals("SortingGroupedByCache")){
+		} else if (name.equals("SortingGroupedByCache")) {
 			tmp = atts.getValue("on");
 			SortingGroupedByCache = tmp != null && tmp.equalsIgnoreCase("true");
-		}
-		else if (name.equals("Symbols")) {
-			useOwnSymbols=Boolean.valueOf(atts.getValue("useOwnSymbols")).booleanValue();
-		}
+		} else if (name.equals("Symbols")) {
+			useOwnSymbols = Boolean.valueOf(atts.getValue("useOwnSymbols")).booleanValue();
+		} else if (name.equals("MobileGui"))
+			mobileGUI = Boolean.valueOf(atts.getValue("value")).booleanValue();
 	}
 
-	public void characters( char ch[], int start, int length ) {
-		if (collectElement!=null) {
-			collectElement.append(ch,start,length); // Collect the name of the last profile
+	public void characters(char ch[], int start, int length) {
+		if (collectElement != null) {
+			// Collect the name of the last profile
+			collectElement.append(ch, start, length);
 		}
 	}
 
 	/**
 	 * Method that gets called when the end of an element has been identified in pref.xml
 	 */
-	public void endElement(String tag){
+	public void endElement(String tag) {
 		if (tag.equals("lastprofile")) {
-			if (collectElement!=null) lastProfile=collectElement.toString();
+			if (collectElement != null)
+				lastProfile = collectElement.toString();
 		}
-		collectElement=null;
+		collectElement = null;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Write pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Write pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Method to save current preferences in the pref.xml file
 	 */
-	public void savePreferences(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
-			outp.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
-			outp.print("<preferences>\n");
-			outp.print("    <locale language=\"" + SafeXML.clean(language) + "\"/>\n");
-			outp.print("    <basedir dir = \"" + SafeXML.clean(getBaseDir()) + "\"/>\n");
-			outp.print("    <lastprofile autoreload=\"" + SafeXML.strxmlencode(autoReloadLastProfile) + "\">" + SafeXML.clean(lastProfile) + "</lastprofile>\n"); //RB
-			outp.print("    <CurrentCentre FromGPSPosition=\"" + SafeXML.clean(Convert.toString(setCurrentCentreFromGPSPosition)) + "\"/>\n");
-			outp.print("    <alias name =\""+ SafeXML.clean(myAlias) +"\" password=\""+SafeXML.clean(password)+"\" />\n");
-			outp.print("    <alias2 name =\""+ SafeXML.clean(myAlias2) +"\"/>\n");
-			outp.print("    <gcmemberid name =\""+ SafeXML.clean(gcMemberId) + "\"" + " Premium =\""+ SafeXML.strxmlencode(isPremium) +"\"/>\n");
-			outp.print("    <browser name = \"" + SafeXML.clean(browser) + "\"/>\n");
-			outp.print("    <proxy prx = \"" + SafeXML.clean(myproxy) + "\" prt = \"" + SafeXML.clean(myproxyport) + "\" active = \"" + SafeXML.strxmlencode(proxyActive) + "\" />\n");
-			outp.print("    <port portname = \"" + SafeXML.clean(mySPO.portName) + "\" baud = \"" + SafeXML.strxmlencode(mySPO.baudRate) + "\"/>\n");
-			outp.print("    <portforward active= \"" + SafeXML.clean(Convert.toString(forwardGPS)) + "\" destinationHost = \"" + SafeXML.clean(forwardGpsHost) + "\"/>\n");
-			outp.print("    <gpsd active= \"" + SafeXML.strxmlencode(useGPSD) + "\" host = \"" + SafeXML.clean(gpsdHost) + "\" port = \"" + SafeXML.strxmlencode(gpsdPort) + "\"/>\n");
-			outp.print("    <portlog active= \"" + SafeXML.clean(Convert.toString(logGPS)) + "\" logTimer = \"" + SafeXML.clean(logGPSTimer) + "\"/>\n");
-			outp.print("    <font size =\"" + SafeXML.strxmlencode(fontSize) + "\"/>\n");
-			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\" hasclosebutton=\""+hasCloseButton+
-	                "\" h=\""+myAppHeight+"\" w=\""+myAppWidth+"\" />\n");
-			outp.print("    <fixedsip state = \"" + SafeXML.strxmlencode(fixSIP) + "\"/>\n");
-			outp.print("    <listview colmap=\"" + SafeXML.clean(listColMap) + "\" colwidths=\"" + SafeXML.clean(listColWidth) + "\" />\n");
-			outp.print("    <travelbugs colmap=\"" + SafeXML.clean(travelbugColMap) + "\" colwidths=\"" + SafeXML.clean(travelbugColWidth) + "\" shownonlogged=\"" + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + "\" />\n");
+	public void savePreferences() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
+			outp.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" //
+					+ "<preferences>\n" //
+					+ "    <locale language=\"" + SafeXML.clean(language) + "\" />\n" //
+
+					+ "    <basedir dir=\"" + SafeXML.clean(getBaseDir()) + "\" />\n"//
+
+					+ "    <lastprofile" //
+					+ " autoreload=\"" + SafeXML.strxmlencode(autoReloadLastProfile) + "\"" //
+					+ ">" //
+					+ SafeXML.clean(lastProfile) + "</ lastprofile>\n" //
+
+					+ "    <CurrentCentre" //
+					+ " FromGPSPosition=\"" + SafeXML.strxmlencode(setCurrentCentreFromGPSPosition) + "\"" //
+					+ " />\n" //
+
+					+ "    <alias" //
+					+ " name=\"" + SafeXML.clean(myAlias) + "\"" //
+					+ " password=\"" + SafeXML.clean(password) + "\"" //
+					+ " />\n" //
+
+					+ "    <alias2 name=\"" + SafeXML.clean(myAlias2) + "\" />\n" //
+
+					+ "    <gcmemberid" //
+					+ " name=\"" + SafeXML.clean(gcMemberId) + "\"" //
+					+ " Premium=\"" + SafeXML.strxmlencode(isPremium) + "\"" //
+					+ " />\n" //
+
+					+ "    <browser name=\"" + SafeXML.clean(browser) + "\" />\n" //
+
+					+ "    <proxy" //
+					+ " prx=\"" + SafeXML.clean(myproxy) + "\"" //
+					+ " prt=\"" + SafeXML.clean(myproxyport) + "\"" //
+					+ " active=\"" + SafeXML.strxmlencode(proxyActive) + "\"" //
+					+ " />\n" //
+
+					+ "    <port" //
+					+ " portname=\"" + SafeXML.clean(mySPO.portName) + "\"" //
+					+ " baud=\"" + SafeXML.strxmlencode(mySPO.baudRate) + "\"" //
+					+ " />\n" //
+
+					+ "    <portforward" //
+					+ " active=\"" + SafeXML.strxmlencode(forwardGPS) + "\"" //
+					+ " destinationHost=\"" + SafeXML.clean(forwardGpsHost) + "\"" //
+					+ " />\n" //
+
+					+ "    <gpsd" //
+					+ " active=\"" + SafeXML.strxmlencode(useGPSD) + "\"" //
+					+ " host=\"" + SafeXML.clean(gpsdHost) + "\"" //
+					+ " port=\"" + SafeXML.strxmlencode(gpsdPort) + "\"" //
+					+ " />\n" //
+
+					+ "    <portlog" //
+					+ " active=\"" + SafeXML.strxmlencode(logGPS) + "\"" //
+					+ " logTimer=\"" + SafeXML.clean(logGPSTimer) + "\"" //
+					+ " />\n" //
+
+					+ "    <font" //
+					+ " name=\"" + fontName + "\"" //
+					+ " size=\"" + SafeXML.strxmlencode(fontSize) + "\"" //
+					+ " />\n" //
+
+					+ "    <screen" //
+					+ " menuattop=\"" + menuAtTop + "\"" //
+					+ " tabsattop=\"" + tabsAtTop + "\"" //
+					+ " showstatus=\"" + showStatus + "\"" //
+					+ " hasclosebutton=\"" + hasCloseButton + "\"" //
+					+ " h=\"" + myAppHeight + "\"" //
+					+ " w=\"" + myAppWidth + "\"" //
+					+ " useBigIcons=\"" + useBigIcons + "\"" //
+					+ " useRadar=\"" + useRadar + "\"" //
+					+ " />\n" //
+
+					+ "    <fixedsip state=\"" + SafeXML.strxmlencode(fixSIP) + "\" />\n" //
+
+					+ "    <listview" //
+					+ " colmap=\"" + SafeXML.clean(listColMap) + "\"" //
+					+ " colwidths=\"" + SafeXML.clean(listColWidth) + "\"" //
+					+ " />\n" //
+
+					+ "    <travelbugs" //
+					+ " colmap=\"" + SafeXML.clean(travelbugColMap) + "\"" //
+					+ " colwidths=\"" + SafeXML.clean(travelbugColWidth) + "\"" //
+					+ " shownonlogged=\"" + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + "\"" //
+					+ " />\n");
+
 			outp.print("    <descpanel showimages=\"" + SafeXML.strxmlencode(descShowImg) + "\" />\n");
-			outp.print("    <imagepanel showdeletedimages=\"" + SafeXML.strxmlencode(showDeletedImages) + "\"/>\n");
-			outp.print("    <hintlogpanel logsperpage=\"" + SafeXML.strxmlencode(logsPerPage) + "\" initialhintheight=\"" + SafeXML.strxmlencode(initialHintHeight) + "\"  maxspiderlogs=\"" + SafeXML.strxmlencode(maxLogsToSpider) + "\" />\n");
+			outp.print("    <imagepanel showdeletedimages=\"" + SafeXML.strxmlencode(showDeletedImages) + "\" />\n");
+			outp.print("    <hintlogpanel"//
+					+ " logsperpage=\"" + SafeXML.strxmlencode(logsPerPage) + "\"" //
+					+ " initialhintheight=\"" + SafeXML.strxmlencode(initialHintHeight) + "\"" //
+					+ " maxspiderlogs=\"" + SafeXML.strxmlencode(maxLogsToSpider) + "\"" //
+					+ " />\n");
 			outp.print("    <solver ignorevariablecase=\"" + SafeXML.strxmlencode(solverIgnoreCase) + "\" degMode=\"" + SafeXML.strxmlencode(solverDegMode) + "\" />\n");
-			outp.print("    <garmin connection = \"" + SafeXML.clean(garminConn) + "\" GPSBabelOptions = \"" + SafeXML.clean(garminGPSBabelOptions) + "\" MaxWaypointLength = \"" + SafeXML.strxmlencode(garminMaxLen) +
-					        "\" addDetailsToWaypoint = \"" + SafeXML.strxmlencode(addDetailsToWaypoint) + "\" addDetailsToName = \"" + SafeXML.strxmlencode(addDetailsToName) + "\" />\n");
-			outp.print("    <opencaching lastSite=\""+lastOCSite+"\" downloadMissing=\"" + SafeXML.strxmlencode(downloadMissingOC) + "\"/>\n");
-			outp.print("    <location lat = \"" + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + "\" long = \"" + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + "\"/>\n");
-			outp.print("    <spider forcelogin=\"" + SafeXML.strxmlencode(forceLogin) + "\" spiderUpdates=\"" + SafeXML.strxmlencode(spiderUpdates) + "\" checkLog=\"" + SafeXML.strxmlencode(checkLog) + "\" checkTBs=\"" + SafeXML.strxmlencode(checkTBs) + "\" spiderRoute=\"" + SafeXML.strxmlencode(spiderRoute) + "\" maxSpiderNumber=\"" + SafeXML.strxmlencode(maxSpiderNumber) + "\" downloadPics=\"" + SafeXML.strxmlencode(downloadPics) + "\" downloadTBs=\"" + SafeXML.strxmlencode(downloadTBs) +"\"/>\n");
+			outp.print("    <garmin" //
+					+ " connection=\"" + SafeXML.clean(garminConn) + "\"" //
+					+ " GPSBabelOptions=\"" + SafeXML.clean(garminGPSBabelOptions) + "\"" //
+					+ " MaxWaypointLength=\"" + SafeXML.strxmlencode(garminMaxLen) + "\"" //
+					+ " addDetailsToWaypoint=\"" + SafeXML.strxmlencode(addDetailsToWaypoint) + "\"" //
+					+ " addDetailsToName=\"" + SafeXML.strxmlencode(addDetailsToName) + "\"" //
+					+ " />\n");
+			outp.print("    <opencaching lastSite=\"" + lastOCSite + "\" downloadMissing=\"" + SafeXML.strxmlencode(downloadAllOC) + "\" />\n");
+			outp.print("    <location lat=\"" + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + "\" long=\"" + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + "\" />\n");
+			outp.print("    <spider" //
+					+ " forcelogin=\"" + SafeXML.strxmlencode(forceLogin) + "\"" //
+					+ " spiderUpdates=\"" + SafeXML.strxmlencode(spiderUpdates) + "\"" //
+					+ " checkLog=\"" + SafeXML.strxmlencode(checkLog) + "\"" //
+					+ " checkTBs=\"" + SafeXML.strxmlencode(checkTBs) + "\"" //
+					+ " checkDTS=\"" + SafeXML.strxmlencode(checkDTS) + "\"" //
+					+ " spiderRoute=\"" + SafeXML.strxmlencode(spiderRoute) + "\"" //
+					+ " maxSpiderNumber=\"" + SafeXML.strxmlencode(maxSpiderNumber) + "\"" //
+					+ " downloadPics=\"" + SafeXML.strxmlencode(downloadPics) + "\"" //
+					+ " downloadTBs=\"" + SafeXML.strxmlencode(downloadTBs) + "\"" //
+					+ " UserID=\"" + SafeXML.clean(userID) + "\"" //
+					+ " getFinds=\"" + SafeXML.strxmlencode(!doNotGetFound) + "\"" //
+					+ " />\n");
 			outp.print("    <gotopanel northcentered=\"" + SafeXML.strxmlencode(northCenteredGoto) + "\" />\n");
-			outp.print("    <details cacheSize=\"" + SafeXML.strxmlencode(maxDetails) + "\" delete=\"" + SafeXML.strxmlencode(deleteDetails) + "\"/>\n");
-			outp.print("    <metric type=\"" + SafeXML.strxmlencode(metricSystem) + "\"/>\n");
-			outp.print("    <export numberOfLogsToExport=\"" + SafeXML.strxmlencode(numberOfLogsToExport) + "\" exportTravelbugs=\"" + SafeXML.strxmlencode(exportTravelbugs) + "\" exportGpxAsMyFinds=\"" + SafeXML.strxmlencode(exportGpxAsMyFinds) + "\"/>\n");
+			outp.print("    <details cacheSize=\"" + SafeXML.strxmlencode(maxDetails) + "\" delete=\"" + SafeXML.strxmlencode(deleteDetails) + "\" />\n");
+			outp.print("    <metric type=\"" + SafeXML.strxmlencode(metricSystem) + "\" />\n");
+			outp.print("    <export numberOfLogsToExport=\"" + SafeXML.strxmlencode(numberOfLogsToExport) + "\" exportTravelbugs=\"" + SafeXML.strxmlencode(exportTravelbugs) + "\" exportGpxAsMyFinds=\"" + SafeXML.strxmlencode(exportGpxAsMyFinds)
+					+ "\" />\n");
 			outp.print("    <datamover processorMode=\"" + SafeXML.strxmlencode(processorMode) + "\" />\n");
-			if (customMapsPath!=null) outp.print("    <mapspath dir = \"" + SafeXML.clean(customMapsPath.replace('\\','/')) + "\"/>\n");
+			if (customMapsPath != null)
+				outp.print("    <mapspath dir=\"" + SafeXML.clean(customMapsPath.replace('\\', '/')) + "\" />\n");
 			// Saving filters
 			String[] filterIDs = this.getFilterIDs();
-			for (int i=0; i<filterIDs.length; i++){
+			for (int i = 0; i < filterIDs.length; i++) {
 				outp.print(this.getFilter(filterIDs[i]).toXML(filterIDs[i]));
 			}
-			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set
+			if (debug)
+				// Keep the debug switch if it is set
+				outp.print("    <debug value=\"true\" />\n");
 			// save last path of different exporters
 			Iterator itPath = exporterPaths.entries();
 			MapEntry entry;
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
-				outp.print("    <expPath key = \"" + SafeXML.clean(entry.getKey().toString()) + "\" value = \"" + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + "\"/>\n");
+				outp.print("    <expPath key = \"" + SafeXML.clean(entry.getKey().toString()) + "\" value = \"" + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + "\" />\n");
 			}
 			itPath = importerPaths.entries();
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
-				outp.print("    <impPath key = \"" + SafeXML.clean(entry.getKey().toString()) + "\" value = \"" + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + "\"/>\n");
+				outp.print("    <impPath key = \"" + SafeXML.clean(entry.getKey().toString()) + "\" value = \"" + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + "\" />\n");
 			}
-			outp.print("    <logkeeping maximum=\""+SafeXML.strxmlencode(maxLogsToKeep)+"\" keepown=\""+SafeXML.strxmlencode(alwaysKeepOwnLogs)+"\" />\n");
-			outp.print("    <fillWhiteArea on=\""+SafeXML.strxmlencode(fillWhiteArea)+"\"/>\n");
-			outp.print("    <mapLoader tileSize=\""+SafeXML.strxmlencode(mapTileSize)+"\" overlapping=\""+SafeXML.strxmlencode(mapOverlapping)+"\" tilewidth=\""+SafeXML.strxmlencode(tilewidth)+"\" tileheight=\""+SafeXML.strxmlencode(tileheight)+"\"/>\n");
-			outp.print("    <showCachesOnMap on=\""+SafeXML.strxmlencode(showCachesOnMap)+"\"/>\n");
-			outp.print("    <SortingGroupedByCache on=\""+SafeXML.strxmlencode(SortingGroupedByCache)+"\"/>\n");
-			outp.print("    <Symbols useOwnSymbols=\"" + SafeXML.strxmlencode(useOwnSymbols) + "\"/>\n");
+			outp.print("    <logkeeping maximum=\"" + SafeXML.strxmlencode(maxLogsToKeep) + "\" keepown=\"" + SafeXML.strxmlencode(alwaysKeepOwnLogs) + "\" />\n");
+			outp.print("    <fillWhiteArea on=\"" + SafeXML.strxmlencode(fillWhiteArea) + "\" />\n");
+			outp.print("    <mapLoader tileSize=\"" + SafeXML.strxmlencode(mapTileSize) + "\" overlapping=\"" + SafeXML.strxmlencode(mapOverlapping) + "\" tilewidth=\"" + SafeXML.strxmlencode(tilewidth) + "\" tileheight=\""
+					+ SafeXML.strxmlencode(tileheight) + "\" />\n");
+			outp.print("    <showCachesOnMap on=\"" + SafeXML.strxmlencode(showCachesOnMap) + "\" />\n");
+			outp.print("    <SortingGroupedByCache on=\"" + SafeXML.strxmlencode(SortingGroupedByCache) + "\" />\n");
+			outp.print("    <Symbols useOwnSymbols=\"" + SafeXML.strxmlencode(useOwnSymbols) + "\" />\n");
+			if (mobileGUI)
+				// Keep the vmgui switch if it is set
+				outp.print("    <MobileGui value=\"true\" />\n");
 			outp.print("</preferences>");
 			outp.close();
 		} catch (Exception e) {
-			log("Problem saving: " +pathToConfigFile,e,true);
+			log("Problem saving: " + pathToConfigFile, e, true);
 		}
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Maps
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Maps
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	private static final String mapsPath = "maps/standard";
 
 	/**
 	 * custom = set by the user
+	 * 
 	 * @return custom Maps Path, null if not set
 	 */
 	public String getCustomMapsPath() {
-	   String rCMP = Global.getProfile().getRelativeCustomMapsPath();
-	   if (rCMP.equals("")) {
-		   return customMapsPath;
+		String rCMP = Global.getProfile().getRelativeCustomMapsPath();
+		if (rCMP.equals("")) {
+			return customMapsPath;
 		} else {
-			return absoluteBaseDir+"maps"+rCMP;
+			return absoluteBaseDir + "maps" + rCMP;
 		}
 	}
 
 	public void saveCustomMapsPath(String mapspath_) {
 		if (customMapsPath == null || !customMapsPath.equals(mapspath_)) {
-			customMapsPath=new String(mapspath_).replace('\\', '/');
+			customMapsPath = new String(mapspath_).replace('\\', '/');
 			savePreferences();
-			String s = absoluteBaseDir+"maps";
-			if (customMapsPath.indexOf(s)==0) {
-				String t=customMapsPath.substring(s.length(), customMapsPath.length());
+			String s = absoluteBaseDir + "maps";
+			if (customMapsPath.indexOf(s) == 0) {
+				String t = customMapsPath.substring(s.length(), customMapsPath.length());
 				Global.getProfile().setRelativeCustomMapsPath(t);
 			} else {
 				Global.getProfile().setRelativeCustomMapsPath("");
@@ -800,34 +953,38 @@
 	}
 
 	private myTableModel tableMod;
-	public void setMyTableModel(myTableModel myTableModel) {tableMod=myTableModel;}
-	public CWPoint getCurCentrePt() {return curCentrePt;}
+
+	public void setMyTableModel(myTableModel myTableModel) {
+		tableMod = myTableModel;
+	}
+
+	public CWPoint getCurCentrePt() {
+		return curCentrePt;
+	}
+
 	public void setCurCentrePt(CWPoint newCentre) {
 		Vm.showWait(true);
 		curCentrePt.set(newCentre);
 		Global.getProfile().updateBearingDistance();
 		if (tableMod != null) {
 			// corresponding column for "distance" is column 10
-			if (tableMod.sortedBy == 10) tableMod.isSorted = false;
+			if (tableMod.sortedBy == 10)
+				tableMod.isSorted = false;
 			if (tableMod.sortedBy == 10 && this.sortAutomatic) {
 				tableMod.sortTable(tableMod.sortedBy, tableMod.sortAscending);
 				// or ??? TablePanel.refreshTable();
-			}
-			else tableMod.tcControl.repaint();
+			} else
+				tableMod.tcControl.repaint();
 		}
 		Vm.showWait(false);
 	}
 
 	/**
-	 * gets the path to the calibrated maps
-	 * it first tries if there are manually imported maps
-	 * in <baseDir>/maps/standard then it tries
-	 * the legacy dir: <program-dir>/maps
-	 * In case in both locations are no .wfl-files
-	 * it returns  <baseDir>/maps/expedia - the place where
-	 * the automatically downloaded maps are placed.
-	 *
-	 *
+	 * gets the path to the calibrated maps it first tries if there are manually imported maps in
+	 * <baseDir>/maps/standard then it tries the legacy dir: <program-dir>/maps In case in both locations are no
+	 * .wfl-files it returns <baseDir>/maps/expedia - the place where the automatically downloaded maps are placed.
+	 * 
+	 * 
 	 */
 	public String getMapLoadPath() {
 		saveCustomMapsPath(getMapLoadPathInternal());
@@ -838,18 +995,23 @@
 		// here could also a list of map-types displayed...
 		// standard dir
 		String ret = getCustomMapsPath();
-		if (ret != null) return ret;
+		if (ret != null)
+			return ret;
 		ret = getMapManuallySavePath(false);
 		File t = new FileBugfix(ret);
 		String[] f = t.list("*.wfl", FileBase.LIST_FILES_ONLY);
-		if (f != null && f.length > 0) return  absoluteBaseDir + mapsPath;
+		if (f != null && f.length > 0)
+			return absoluteBaseDir + mapsPath;
 		f = t.list("*.wfl", FileBase.LIST_DIRECTORIES_ONLY | FileBase.LIST_ALWAYS_INCLUDE_DIRECTORIES);
-		if (f != null && f.length > 0) { // see if in a subdir of <baseDir>/maps/standard are .wfl files
+		if (f != null && f.length > 0) { // see if in a subdir of
+			// <baseDir>/maps/standard are
+			// .wfl files
 			String[] f2;
-			for (int i = 0; i< f.length; i++) {
-				t.set(null, ret+"/"+f[i]);
+			for (int i = 0; i < f.length; i++) {
+				t.set(null, ret + "/" + f[i]);
 				f2 = t.list("*.wfl", FileBase.LIST_FILES_ONLY);
-				if (f2 != null && f2.length > 0) return  ret;
+				if (f2 != null && f2.length > 0)
+					return ret;
 			}
 		}
 		// lagacy dir
@@ -857,45 +1019,49 @@
 		t.set(null, ret);
 		f = t.list("*.wfl", FileBase.LIST_FILES_ONLY);
 		if (f != null && f.length > 0) {
-			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", FormBase.YESB | FormBase.NOB);
+			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", FormBase.YESB
+					| FormBase.NOB);
 			if (inf.execute() == FormBase.IDYES) {
 				String sp = getMapManuallySavePath(false);
 				FileBugfix spF = new FileBugfix(sp);
-				if (!spF.exists()) spF.mkdirs();
+				if (!spF.exists())
+					spF.mkdirs();
 				String image;
 				String lagacypath = ret;
-				for (int i=0; i<f.length; i++) {
-					t.set(null, lagacypath+f[i]);
-					spF.set(null, sp+"/"+f[i]);
+				for (int i = 0; i < f.length; i++) {
+					t.set(null, lagacypath + f[i]);
+					spF.set(null, sp + "/" + f[i]);
 					t.move(spF);
-					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(".")));
+					image = Common.getImageName(lagacypath + f[i].substring(0, f[i].lastIndexOf(".")));
 					t.set(null, image);
-					spF.set(null, sp+"/"+t.getFileExt());
+					spF.set(null, sp + "/" + t.getFileExt());
 					t.move(spF);
 				}
 				t.set(null, lagacypath);
 				t.delete();
 				return sp;
-			}
-			else return  ret;
+			} else
+				return ret;
 		}
 		// expedia dir
 		// return getMapExpediaLoadPath();
 
-		//whole maps directory
+		// whole maps directory
 		return Global.getPref().absoluteBaseDir.replace('\\', '/') + "maps";
 	}
 
 	/**
-	 * @param create if true the directory if it doesn't exist will be created
-	 * @return the path where manually imported maps should be stored
-	 * this should be adjustable in preferences...
+	 * @param create
+	 *            if true the directory if it doesn't exist will be created
+	 * @return the path where manually imported maps should be stored this should be adjustable in preferences...
 	 */
 	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = absoluteBaseDir + mapsPath;
-		if (create && !(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
-			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation failed?
-				(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+mapsDir, FormBase.OKB)).exec();
+		if (create && !(new FileBugfix(mapsDir).isDirectory())) { // dir
+			// exists?
+			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation
+				// failed?
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(172, "Error: cannot create maps directory: \n") + mapsDir, FormBase.OKB)).exec();
 				return null;
 			}
 		}
@@ -907,113 +1073,130 @@
 	 */
 	public String getMapDownloadSavePath(String mapkind) {
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().absoluteBaseDir.length()).replace('\\', '/');
-		String mapsDir = Global.getPref().absoluteBaseDir + "maps/" + Common.ClearForFileName(mapkind)+ "/" + subdir;
+		String mapsDir = Global.getPref().absoluteBaseDir + "maps/" + Common.ClearForFileName(mapkind) + "/" + subdir;
 		if (!(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
-			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation failed?
-			{(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
-			return null;
+			if (new FileBugfix(mapsDir).mkdirs() == false) {
+				// dir creation failed?
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(172, "Error: cannot create maps directory: \n") + new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
+				return null;
 			}
 		}
 		return mapsDir;
 	}
 
 	public String getMapExpediaLoadPath() {
-		return Global.getPref().absoluteBaseDir.replace('\\', '/') + "maps/expedia"; // baseDir has trailing /
+		// baseDir has trailing /
+		return Global.getPref().absoluteBaseDir.replace('\\', '/') + "maps/expedia";
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Profile Selector
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Profile Selector
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
-	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
-	static protected final int PROFILE_SELECTOR_ONOROFF=2;
+	static protected final int PROFILE_SELECTOR_FORCED_ON = 0;
+	static protected final int PROFILE_SELECTOR_FORCED_OFF = 1;
+	static protected final int PROFILE_SELECTOR_ONOROFF = 2;
 
 	/**
-	 * tries to get the home data dir of the user
-	 * e.g. "c:\documents and...\<user>\my documents" or "/home/<user>" in linux
-	 * if none could be identified, "/" is returned.
+	 * tries to get the home data dir of the user e.g. "c:\documents and...\<user>\my documents" or "/home/<user>" in
+	 * linux if none could be identified, "/" is returned.
+	 * 
 	 * @return
 	 */
 	public String getHomeDir() {
 		String test;
-		test = Vm.getenv("HOMEDRIVE", ""); // returns in java-vm on win xp: c:\<dokumente und Einstellungen>\<username>\<application data>
-		log("[Preferences:getHomeDir]" + test); // this works also in win32.exe (ewe-vm on win xp)
-		test += Vm.getenv("HOMEPATH", ""); // returns in java-vm on win xp: c:\<dokumente und Einstellungen>\<username>\<application data>
-		log("[Preferences:getHomeDir]" + test); // this works also in win32.exe (ewe-vm on win xp)
-		if (test.length() == 0)	test = Vm.getenv("HOME", ""); // This should return on *nix system the home dir
-		if (test.length() == 0)	test = "/";
+		// returns in java-vm on win xp:
+		// c:\<dokumente und Einstellungen>\<username>\<application data>
+		test = Vm.getenv("HOMEDRIVE", "");
+		log("[Preferences:getHomeDir]" + test);
+		// this works also in win32.exe (ewe-vm on win xp)
+		test += Vm.getenv("HOMEPATH", "");
+		// returns in java-vm on win xp:
+		// c:\<dokumente und Einstellungen>\<username>\<application data>
+		log("[Preferences:getHomeDir]" + test);
+		// this works also in win32.exe (ewe-vm on win xp)
+		if (test.length() == 0)
+			// This should return on *nix system the home dir
+			test = Vm.getenv("HOME", "");
+		if (test.length() == 0)
+			test = "/";
 		return test;
 	}
 
 	private void checkAbsoluteBaseDir() {
 		// If datadir is empty, ask for one
-		if (absoluteBaseDir.length()==0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
+		if (absoluteBaseDir.length() == 0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
 			do {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, getHomeDir());
-				fc.title = MyLocale.getMsg(170,"Select base directory for cache data");
+				fc.title = MyLocale.getMsg(170, "Select base directory for cache data");
 				// If no base directory given, terminate
-				if (fc.execute() == FormBase.IDCANCEL) ewe.sys.Vm.exit(0);
+				if (fc.execute() == FormBase.IDCANCEL)
+					ewe.sys.Vm.exit(0);
 				setBaseDir(fc.getChosenFile().toString());
-			}while (!(new FileBugfix(absoluteBaseDir)).exists());
+			} while (!(new FileBugfix(absoluteBaseDir)).exists());
 		}
 	}
 
 	/**
 	 * Open Profile selector screen
+	 * 
 	 * @param prof
 	 * @param showProfileSelector
 	 * @return True if a profile was selected
 	 */
 	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
 		checkAbsoluteBaseDir();
-		boolean profileExists=true;  // Assume that the profile exists
+		boolean profileExists = true; // Assume that the profile exists
 		do {
-			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) ||
-					(showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
-				ProfilesForm f = new ProfilesForm(absoluteBaseDir,lastProfile,!profileExists || hasNewButton ? 0 : 1);
+			if (!profileExists//
+					|| (showProfileSelector == PROFILE_SELECTOR_FORCED_ON)//
+					|| (showProfileSelector == PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)//
+			) {
+				ProfilesForm f = new ProfilesForm(absoluteBaseDir, lastProfile, !profileExists || hasNewButton ? 0 : 1);
 				int code = f.execute();
 				// If no profile chosen (includes a new one), terminate
-				if (code==-1) return false; // Cancel pressed
+				if (code == -1)
+					return false; // Cancel pressed
 				CWPoint savecenter = new CWPoint(prof.centre);
 				prof.clearProfile();
 				prof.setCenterCoords(savecenter);
-				//prof.hasUnsavedChanges = true;
-				//curCentrePt.set(0,0); // No centre yet
-				lastProfile=f.newSelectedProfile;
+				// prof.hasUnsavedChanges = true;
+				// curCentrePt.set(0,0);
+				// No centre yet
+				lastProfile = f.newSelectedProfile;
 			}
-			profileExists=(new FileBugfix(absoluteBaseDir+lastProfile)).exists();
-			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,"Warning"),
-					           MyLocale.getMsg(171,"Profile does not exist: ")+lastProfile,FormBase.MBOK)).execute();
-		} while (profileExists==false);
+			profileExists = (new FileBugfix(absoluteBaseDir + lastProfile)).exists();
+			if (!profileExists)
+				(new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(171, "Profile does not exist: ") + lastProfile, FormBase.MBOK)).execute();
+		} while (profileExists == false);
 		// Now we are sure that baseDir exists and basDir+profile exists
-		prof.name=lastProfile;
-		prof.dataDir=absoluteBaseDir+lastProfile;
-		prof.dataDir=prof.dataDir.replace('\\','/');
-		if (!prof.dataDir.endsWith("/")) prof.dataDir+='/';
-		pathToProfile=prof.dataDir;
+		prof.name = lastProfile;
+		prof.dataDir = absoluteBaseDir + lastProfile;
+		prof.dataDir = prof.dataDir.replace('\\', '/');
+		if (!prof.dataDir.endsWith("/"))
+			prof.dataDir += '/';
+		pathToProfile = prof.dataDir;
 		savePreferences();
 		return true;
 	}
 
 	static public boolean deleteDirectory(FileBugfix path) {
-	    if( path.exists() ) {
-	    	String[] files = path.list();
-	    	for(int i=0; i<files.length; i++) {
-	    		FileBugfix f = new FileBugfix(path.getFullPath() + "/" + files[i]);
-		        if(f.isDirectory()) {
-		        	deleteDirectory(f);
-		        }
-		        else {
-		        	f.delete();
-		        }
-		     }
-		    }
-	    return( path.delete() );
+		if (path.exists()) {
+			String[] files = path.list();
+			for (int i = 0; i < files.length; i++) {
+				FileBugfix f = new FileBugfix(path.getFullPath() + "/" + files[i]);
+				if (f.isDirectory()) {
+					deleteDirectory(f);
+				} else {
+					f.delete();
+				}
+			}
+		}
+		return (path.delete());
 	}
 
 	static public boolean renameDirectory(FileBugfix OldPath, FileBugfix NewPath) {
-	    return OldPath.renameTo(NewPath);
+		return OldPath.renameTo(NewPath);
 	}
 
 	/*
@@ -1022,147 +1205,169 @@
 	public void editProfile(int operation, int ErrorMsgActive, int ErrorMsg) {
 		checkAbsoluteBaseDir(); // perhaps not necessary
 		// select profile
-		ProfilesForm f = new ProfilesForm(absoluteBaseDir,"",operation);
-		if (f.execute()==-1) return ; // no select
+		ProfilesForm f = new ProfilesForm(absoluteBaseDir, "", operation);
+		if (f.execute() == -1)
+			return; // no select
 		// check selection
 		if (lastProfile.equals(f.newSelectedProfile)) {
 			// aktives Profil kann nicht gel?scht / umbenannt werden;
-			new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(ErrorMsgActive,"[Profile active...]"),FormBase.MBOK).execute();
-		}
-		else {
-			boolean err=true;
-			if (operation==3) {
-				String newName = new InputBox("Bitte neuen Verzeichnisnamen eingeben : ").input("",50);
+			new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(ErrorMsgActive, "[Profile active...]"), FormBase.MBOK).execute();
+		} else {
+			boolean err = true;
+			if (operation == 3) {
+				String newName = new InputBox("Bitte neuen Verzeichnisnamen eingeben : ").input("", 50);
 				if (!newName.equals(null)) {
-					err=!renameDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile),new FileBugfix(absoluteBaseDir+newName));
+					err = !renameDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile), new FileBugfix(absoluteBaseDir + newName));
 				}
-			}
-			else
-			if (operation==2){
+			} else if (operation == 2) {
 				Profile p = new Profile();
-				p.dataDir=absoluteBaseDir+f.newSelectedProfile+"/";
+				p.dataDir = absoluteBaseDir + f.newSelectedProfile + "/";
 				p.readIndex();
-				String mapsPath=absoluteBaseDir+"maps"+p.getRelativeCustomMapsPath();
-				int answer=new MessageBox("",mapsPath+" "+MyLocale.getMsg(143,"l?schen ?"),FormBase.MBYESNO).execute();
-				if (answer==1) {
+				String mapsPath = absoluteBaseDir + "maps" + p.getRelativeCustomMapsPath();
+				int answer = new MessageBox("", mapsPath + " " + MyLocale.getMsg(143, "l?schen ?"), FormBase.MBYESNO).execute();
+				if (answer == 1) {
 					deleteDirectory(new FileBugfix(mapsPath));
 				}
-				err=!deleteDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile));
+				err = !deleteDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile));
 				// ? wait until deleted ?
 			}
-			if (err) {new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(ErrorMsg,"[Profile Error...]"),FormBase.MBOK).execute();}
+			if (err) {
+				new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(ErrorMsg, "[Profile Error...]"), FormBase.MBOK).execute();
+			}
 		}
 	}
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Log functions
-	//////////////////////////////////////////////////////////////////////////////////////
 
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Log functions
+	// ////////////////////////////////////////////////////////////////////////////////////
+
 	// FIXME: should use path to config file instead of program directory
 	/** Log file is in program directory and called log.txt */
-	private final String LOGFILENAME=FileBase.getProgramDirectory()+"/log.txt";
+	private final String LOGFILENAME = FileBase.getProgramDirectory() + "/log.txt";
 
 	/**
-	 * Method to delete an existing log file. Called on every SpiderGC.
-	 * The log file is also cleared when Preferences is created and the filesize > 60KB
+	 * Method to delete an existing log file. Called on every SpiderGC. The log file is also cleared when Preferences is
+	 * created and the filesize > 60KB
 	 */
-	public void logInit(){
+	public void logInit() {
 		File logFile = new FileBugfix(LOGFILENAME);
 		logFile.delete();
-		log("CW Version "+Version.getReleaseDetailed(),null,true);
-		
-		if (System.getProperty("os.name")!=null) log("Operating system: "+System.getProperty("os.name")+"/"+System.getProperty("os.arch"),null,true);
-		if (System.getProperty("java.vendor")!=null) log("Java: "+System.getProperty("java.vendor")+"/"+System.getProperty("java.version"),null,true);
-		
+		log("CW Version " + Version.getReleaseDetailed(), null, true);
+
+		if (System.getProperty("os.name") != null)
+			log("Operating system: " + System.getProperty("os.name") + "/" + System.getProperty("os.arch"), null, true);
+		if (System.getProperty("java.vendor") != null)
+			log("Java: " + System.getProperty("java.vendor") + "/" + System.getProperty("java.version"), null, true);
+
 	}
 
 	boolean forceLog = false;
-	
+
 	/**
-	 * Method to log messages to a file called log.txt
-	 * It will always append to an existing file.
-	 * To show the message on the console, the global variable debug must be set.
-	 * This can be done by adding
-	 * <pre>&lt;debug value="true"&gt;</pre>
+	 * Method to log messages to a file called log.txt It will always append to an existing file. To show the message on
+	 * the console, the global variable debug must be set. This can be done by adding
+	 * 
+	 * <pre>
+	 * &lt;debug value=&quot;true&quot;&gt;
+	 * </pre>
+	 * 
 	 * to the pref.xml file
-	 * @param text to log
+	 * 
+	 * @param text
+	 *            to log
 	 */
-	public void log(String text){
+	public void log(String text) {
 		if (debug || forceLog) {
-			if (debug) Vm.debug(text);
+			if (debug)
+				Vm.debug(text);
 			Time dtm = new Time();
 			dtm.getTime();
 			dtm.setFormat("dd.MM.yyyy'/'HH:mm:ss.SSS");
-			text = dtm.toString()+ ": "+ text;
+			text = dtm.toString() + ": " + text;
 			FileWriter logFile = null;
-			try{
+			try {
 				logFile = new FileWriter(LOGFILENAME, true);
-				//Stream strout = null;
-				//strout = logFile.toWritableStream(true);
-				logFile.print(text+NEWLINE);
-			}catch(Exception ex){
+				// Stream strout = null;
+				// strout = logFile.toWritableStream(true);
+				logFile.print(text + NEWLINE);
+			} catch (Exception ex) {
 				Vm.debug("Error writing to log file!");
-			}finally{
-				if (logFile != null) try {logFile.close(); } catch (IOException ioe) {
-					// log("Ignored Exception", ioe, true);
-				}
+			} finally {
+				if (logFile != null)
+					try {
+						logFile.close();
+					} catch (IOException ioe) {
+						// log("Ignored Exception", ioe, true);
+					}
 			}
 		}
 	}
 
-	/** Log an exception to the log file with or without a stack trace
-	 *
-	 * @param text Optional message (Can be empty string)
-	 * @param e The exception
-	 * @param withStackTrace If true and the debug switch is true, the stack trace is appended to the log
-	 * The debug switch can be set by including the line <i>&lt;debug value="true"&gt;&lt;/debug&gt;</i> in the pref.xml file
-	 * or by manually setting it (i.e. in BE versions or RC versions) by including the line
-	 * <pre>Global.getPref().debug=true;</pre>
-	 * in Version.getRelease()
+	/**
+	 * Log an exception to the log file with or without a stack trace
+	 * 
+	 * @param text
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
+	 * @param withStackTrace
+	 *            If true and the debug switch is true, the stack trace is appended to the log The debug switch can be
+	 *            set by including the line <i>&lt;debug value="true"&gt;&lt;/debug&gt;</i> in the pref.xml file or by
+	 *            manually setting it (i.e. in BE versions or RC versions) by including the line
+	 * 
+	 *            <pre>
+	 * Global.getPref().debug = true;
+	 * </pre>
+	 * 
+	 *            in Version.getRelease()
 	 */
-	public void log(String text,Throwable e, boolean withStackTrace) {
-		if (e!=null) {
-			text+=Preferences.NEWLINE;
+	public void log(String text, Throwable e, boolean withStackTrace) {
+		if (e != null) {
+			text += Preferences.NEWLINE;
 			if (withStackTrace)
-				text+=ewe.sys.Vm.getAStackTrace(e);
+				text += ewe.sys.Vm.getAStackTrace(e);
 			else
-				text+=e.toString();
+				text += e.toString();
 		}
-		forceLog=true;
+		forceLog = true;
 		log(text);
-		forceLog=false;
+		forceLog = false;
 	}
 
-	/** Log an exception to the log file without a stack trace, i.e.
-	 * where a stack trace is not needed because the location/cause of the error is clear
-	 *
-	 * @param message Optional message (Can be empty string)
-	 * @param e The exception
+	/**
+	 * Log an exception to the log file without a stack trace, i.e. where a stack trace is not needed because the
+	 * location/cause of the error is clear
+	 * 
+	 * @param message
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
 	 */
-	public void log(String message,Exception e) {
-		log (message,e,false);
+	public void log(String message, Exception e) {
+		log(message, e, false);
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Exporter path functions
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Exporter path functions
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/** Hashtable for storing the last export path */
 	private Hashtable exporterPaths = new Hashtable();
 
-	public void setExportPath(String exporter,String path){
+	public void setExportPath(String exporter, String path) {
 		exporterPaths.put(exporter, path);
 		savePreferences();
 	}
 
-	public void setExportPathFromFileName(String exporter,String filename){
-		File tmpfile = new FileBugfix (filename);
+	public void setExportPathFromFileName(String exporter, String filename) {
+		File tmpfile = new FileBugfix(filename);
 		exporterPaths.put(exporter, tmpfile.getPath());
 		savePreferences();
 	}
 
-	public String getExportPath(String exporter){
+	public String getExportPath(String exporter) {
 		String dir = (String) exporterPaths.get(exporter);
-		if (dir == null){
+		if (dir == null) {
 			dir = Global.getProfile().dataDir;
 		}
 		return dir;
@@ -1177,14 +1382,17 @@
 
 	public String getImporterPath(String importer) {
 		String dir = (String) importerPaths.get(importer);
-		if (null == dir) dir = Global.getProfile().dataDir;
+		if (null == dir)
+			dir = Global.getProfile().dataDir;
 		return dir;
 	}
 
 	/**
-	 * <code>True</code> or <code>false</code>, depending if a filter with the given ID is
-	 * saved in the preferences.
-	 * @param filterID ID of the filter to check
+	 * <code>True</code> or <code>false</code>, depending if a filter with the given ID is saved in the
+	 * preferences.
+	 * 
+	 * @param filterID
+	 *            ID of the filter to check
 	 * @return True or false
 	 */
 	public boolean hasFilter(String filterID) {
@@ -1192,29 +1400,36 @@
 	}
 
 	/**
-	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object,
-	 * so it may be resaved under another ID.
-	 * @param filterID ID of the FilterData object
+	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, so it may be resaved
+	 * under another ID.
+	 * 
+	 * @param filterID
+	 *            ID of the FilterData object
 	 * @return FilterData object
 	 */
 	public FilterData getFilter(String filterID) {
-		return (FilterData)this.filterList.get(filterID);
+		return (FilterData) this.filterList.get(filterID);
 	}
 
 	/**
-	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the
-	 * given ID, the old object is removed and the new one is set at its place.
-	 * @param filterID ID to associate with the filter object
-	 * @param filter FilterData object
+	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the given ID, the old object
+	 * is removed and the new one is set at its place.
+	 * 
+	 * @param filterID
+	 *            ID to associate with the filter object
+	 * @param filter
+	 *            FilterData object
 	 */
 	public void addFilter(String filterID, FilterData filter) {
 		this.filterList.put(filterID, filter);
 	}
 
 	/**
-	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object
-	 * exists, nothing happens.
-	 * @param filterID ID of FilterData object to remove
+	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object exists, nothing
+	 * happens.
+	 * 
+	 * @param filterID
+	 *            ID of FilterData object to remove
 	 */
 	public void removeFilter(String filterID) {
 		this.filterList.remove(filterID);
@@ -1222,13 +1437,14 @@
 
 	/**
 	 * Returns a alphabetically sorted array of ID of saved FilterData objects.
+	 * 
 	 * @return Array of IDs
 	 */
 	public String[] getFilterIDs() {
 		String[] result;
 		result = new String[this.filterList.size()];
 		Enumeration en = this.filterList.keys();
-		int i=0;
+		int i = 0;
 		while (en.hasMoreElements()) {
 			result[i++] = (String) en.nextElement();
 		}
@@ -1245,26 +1461,24 @@
 	public String gpsbabel = null;
 
 	public void setgpsbabel() {
-		try{
+		try {
 			ewe.sys.Process p = Vm.exec("gpsbabel -V");
 			p.waitFor();
-			gpsbabel="gpsbabel";
-		}catch(IOException ioex){
-			// Most of the time there will be an exception, so don't complain
-		}
-		if ( gpsbabel == null ) {
-			try{
+			gpsbabel = "gpsbabel";
+		} catch (IOException ioex) {
+			try {
 				ewe.sys.Process p = Vm.exec("gpsbabel.exe -V");
 				p.waitFor();
 				gpsbabel = "gpsbabel.exe";
-			}catch(IOException ioex){
-				// Most of the time there will be an exception, so don't complain
+			} catch (IOException io_ex) {
 			}
 		}
 	}
 
-	/** get directory where pref.xml is stored<br>
-	 *  use this if you need a path where the user has sufficient rights to create a file */
+	/**
+	 * get directory where pref.xml is stored<br>
+	 * use this if you need a path where the user has sufficient rights to create a file
+	 */
 	public String getPathToConfigFile() {
 		return pathToConfigFile;
 	}
@@ -1275,11 +1489,21 @@
 
 	public void setBaseDir(String dir) {
 		baseDir = dir;
-		baseDir=baseDir.replace('\\','/');
-		if (!baseDir.endsWith("/")) baseDir+="/";
+		baseDir = baseDir.replace('\\', '/');
+		if (!baseDir.endsWith("/"))
+			baseDir += "/";
 		absoluteBaseDir = new FileBugfix(baseDir).getAbsolutePath();
-		absoluteBaseDir=absoluteBaseDir.replace('\\','/');
-		if (!absoluteBaseDir.endsWith("/")) absoluteBaseDir+="/";
+		absoluteBaseDir = absoluteBaseDir.replace('\\', '/');
+		if (!absoluteBaseDir.endsWith("/"))
+			absoluteBaseDir += "/";
 	}
 
+	public void setOldGCLanguage() {
+		if (oldLanguageCtl.length() != 0)
+			try {
+				UrlFetcher.fetch(oldLanguageCtl);
+			} catch (IOException e) {
+				// dann halt nicht
+			}
+	}
 }

Modified: branches/r1.2/src/CacheWolf/PreferencesScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/PreferencesScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/PreferencesScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -54,347 +54,336 @@
 import ewe.ui.mTabbedPanel;
 
 /**
-*	This class displays a user interface allowing the user to change and set
-*	preferences. It also provides a method to save the changed preferences that
-*	are saved immediatly when the user presses "Apply".
-*	Class ID=600
-*/
+ * This class displays a user interface allowing the user to change and set preferences. It also provides a method to
+ * save the changed preferences that are saved immediatly when the user presses "Apply". Class ID=600
+ */
 public class PreferencesScreen extends Form {
 	mButton cancelB, applyB, brwBt, gpsB;
 	mChoice inpLanguage, inpMetric, inpSpiderUpdates;
-	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, 
-	       inpLogsPerPage,inpMaxLogsToSpider,inpPassword,inpGcMemberID;
-	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus,chkHasCloseButton,
-	          chkSynthShort,chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, 
-	          chkSetCurrentCentreFromGPSPosition,chkSortingGroupedByCache,chkuseOwnSymbols,chkDebug,chkPM;
+	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, inpLogsPerPage, inpMaxLogsToSpider, inpPassword, inpGcMemberID, inpUserID;
+	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkUseBigIcons, chkUseRadar, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName,
+			chkSetCurrentCentreFromGPSPosition, chkSortingGroupedByCache, chkuseOwnSymbols, chkDebug, chkPM;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
 	mLabel lblGarmin;
-	TableColumnChooser tccBugs,tccList;
-	
+	TableColumnChooser tccBugs, tccList;
+
 	Preferences pref;
-	
+
 	CellPanel pnlGeneral = new CellPanel();
 	CellPanel pnlDisplay = new CellPanel();
 	CellPanel pnlMore = new CellPanel();
 	CellPanel pnlTB = new CellPanel();
 
 	// ScrollBarPanel scp;
-	String [] garminPorts= new String[]{"com1","com2","com3","com4","com5","com6","com7","usb"};
-	
-	public PreferencesScreen (Preferences p){
+	String[] garminPorts = new String[] { "com1", "com2", "com3", "com4", "com5", "com6", "com7", "usb" };
+
+	public PreferencesScreen(Preferences p) {
 		int sw = MyLocale.getScreenWidth();
 		int sh = MyLocale.getScreenHeight();
 
-		mTab=new mTabbedPanel();
-		
+		mTab = new mTabbedPanel();
+
 		pref = p;
-		this.title = MyLocale.getMsg(600,"Preferences");
+		this.title = MyLocale.getMsg(600, "Preferences");
 		if ((sw > 240) && (sh > 240))
 			this.resizable = true;
-		//this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		// this.moveable = true;
+		// this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 
 		// set dialog-width according to fontsize
-		if((pref.fontSize <= 13)||(sw <= 240)||(sh <= 240)){
-			setPreferredSize(240,240);
-		}
-		else if(pref.fontSize <= 28){
+		if ((pref.fontSize <= 13) || (sw <= 240) || (sh <= 240)) {
+			setPreferredSize(240, 240);
+		} else if (pref.fontSize <= 28) {
 			// was for <=16 setPreferredSize(288,252);
-			setPreferredSize(pref.fontSize*20,pref.fontSize*18);
+			setPreferredSize(pref.fontSize * 20, pref.fontSize * 18);
+		} else if (pref.fontSize <= 20) {
+			setPreferredSize(352, 302);
+		} else if (pref.fontSize <= 24) {
+			setPreferredSize(420, 350);
+		} else if (pref.fontSize <= 28) {
+			setPreferredSize(480, 390);
+		} else {
+			setPreferredSize(576, 512);
 		}
-		else if(pref.fontSize <= 20){
-			setPreferredSize(352,302);
-		}
-		else if(pref.fontSize <= 24){
-			setPreferredSize(420,350);
-		}
-		else if(pref.fontSize <= 28){
-			setPreferredSize(480,390);
-		}
-		else{
-			setPreferredSize(576,512);
-		}
-		
-		//scp = new ScrollBarPanel(pnlGeneral);
-		
-		/////////////////////////////////////////////////////////
+
+		// scp = new ScrollBarPanel(pnlGeneral);
+
+		// ///////////////////////////////////////////////////////
 		// First panel - General
-		/////////////////////////////////////////////////////////
-		CellPanel cpDataDir=new CellPanel();
-		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603,"Data Directory:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		// ///////////////////////////////////////////////////////
+		CellPanel cpDataDir = new CellPanel();
+		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603, "Data Directory:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		DataDir = new mInput();
 		DataDir.setText(pref.getBaseDir());
-		cpDataDir.addNext(DataDir,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.LEFT));
-		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604,"Browse")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629,"Autoload last profile")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
-		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646,"centre from GPS")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		if (pref.setCurrentCentreFromGPSPosition) chkSetCurrentCentreFromGPSPosition.setState(true);
-		pnlGeneral.addLast(separator(cpDataDir),HSTRETCH,HFILL);
-		
-		CellPanel cpBrowser=new CellPanel();
-		cpBrowser.addNext(new mLabel("Browser:"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addLast(Browser = new mInput(pref.browser),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601,"Your Alias:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		cpBrowser.addNext(Alias = new mInput(pref.myAlias),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594,"Pwd")));
-		cpBrowser.addLast(inpPassword=new mInput(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		inpPassword.setToolTip(MyLocale.getMsg(593,"Password is optional here.\nEnter only if you want to store it in pref.xml"));
-		inpPassword.isPassword=true;
-		cpBrowser.addNext(chkPM=new mCheckBox("PM"));
-		if (pref.isPremium) chkPM.setState(true);
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650,"GcMemberID:")));
-		cpBrowser.addLast(inpGcMemberID=new mInput(pref.gcMemberId),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		pnlGeneral.addLast(separator(cpBrowser),HSTRETCH,HFILL);
-		
-		CellPanel cpGPS=new CellPanel();
-		cpGPS.addNext(new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600,"Preferences")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		// "GPS: " + (pref.useGPSD ? "gpsd " + pref.gpsdHost : pref.mySPO.portName+"/"+pref.mySPO.baudRate) 
-		pnlGeneral.addLast(separator(cpGPS),HSTRETCH,HFILL);
+		cpDataDir.addNext(DataDir, CellConstants.STRETCH, (CellConstants.FILL | CellConstants.LEFT));
+		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604, "Browse")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629, "Autoload last profile")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		if (pref.autoReloadLastProfile)
+			chkAutoLoad.setState(true);
+		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646, "centre from GPS")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		if (pref.setCurrentCentreFromGPSPosition)
+			chkSetCurrentCentreFromGPSPosition.setState(true);
+		pnlGeneral.addLast(separator(cpDataDir), HSTRETCH, HFILL);
 
+		CellPanel cpBrowser = new CellPanel();
+		cpBrowser.addNext(new mLabel("Browser:"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addLast(Browser = new mInput(pref.browser), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601, "Your Alias:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(Alias = new mInput(pref.myAlias), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594, "Pwd")));
+		cpBrowser.addLast(inpPassword = new mInput(pref.password), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		inpPassword.setToolTip(MyLocale.getMsg(593, "Password is optional here.\nEnter only if you want to store it in pref.xml"));
+		inpPassword.isPassword = true;
+		cpBrowser.addNext(chkPM = new mCheckBox("PM"));
+		if (pref.isPremium)
+			chkPM.setState(true);
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650, "GcMemberID:")));
+		cpBrowser.addLast(inpGcMemberID = new mInput(pref.gcMemberId), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel("UserID"));
+		cpBrowser.addLast(inpUserID = new mInput(pref.userID), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+
+		pnlGeneral.addLast(separator(cpBrowser), HSTRETCH, HFILL);
+
+		CellPanel cpGPS = new CellPanel();
+		cpGPS.addNext(new mLabel("GPS: "), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600, "Preferences")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		// "GPS: " + (pref.useGPSD ? "gpsd " + pref.gpsdHost : pref.mySPO.portName+"/"+pref.mySPO.baudRate)
+		pnlGeneral.addLast(separator(cpGPS), HSTRETCH, HFILL);
+
 		// Garmin and GPSBabel
-		CellPanel cpBabel=new CellPanel();
-		cpBabel.addNext(lblGarmin=new mLabel(MyLocale.getMsg(173,"Garmin:  PC Port:")),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chcGarminPort=new mChoice(garminPorts,0),DONTSTRETCH,RIGHT);
+		CellPanel cpBabel = new CellPanel();
+		cpBabel.addNext(lblGarmin = new mLabel(MyLocale.getMsg(173, "Garmin:  PC Port:")), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chcGarminPort = new mChoice(garminPorts, 0), DONTSTRETCH, RIGHT);
 		chcGarminPort.selectItem(pref.garminConn);
-		cpBabel.addLast(chkSynthShort=new mCheckBox(MyLocale.getMsg(174,"Short Names")),STRETCH,LEFT);
+		cpBabel.addLast(chkSynthShort = new mCheckBox(MyLocale.getMsg(174, "Short Names")), STRETCH, LEFT);
 		chkSynthShort.setState(!pref.garminGPSBabelOptions.equals(""));
-		cpBabel.addNext(new mLabel(MyLocale.getMsg(643,"Append cache details to:")),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chkAddDetailsToWaypoint=new mCheckBox(MyLocale.getMsg(644,"waypoints")),DONTSTRETCH,RIGHT);
+		cpBabel.addNext(new mLabel(MyLocale.getMsg(643, "Append cache details to:")), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chkAddDetailsToWaypoint = new mCheckBox(MyLocale.getMsg(644, "waypoints")), DONTSTRETCH, RIGHT);
 		chkAddDetailsToWaypoint.setState(pref.addDetailsToWaypoint);
-		cpBabel.addLast(chkAddDetailsToName=new mCheckBox(MyLocale.getMsg(645,"names")),STRETCH,LEFT);
+		cpBabel.addLast(chkAddDetailsToName = new mCheckBox(MyLocale.getMsg(645, "names")), STRETCH, LEFT);
 		chkAddDetailsToName.setState(pref.addDetailsToName);
-		pnlGeneral.addLast(cpBabel,HSTRETCH,HFILL);
-		
-		/////////////////////////////////////////////////////////
+		pnlGeneral.addLast(cpBabel, HSTRETCH, HFILL);
+
+		// ///////////////////////////////////////////////////////
 		// Second panel - Screen
-		/////////////////////////////////////////////////////////
-		
-		CellPanel pnlScreen=new CellPanel();
-		Frame frmScreen=new Frame();
-		frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER;
-		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625,"Screen (needs restart):")));
-		pnlScreen.addNext(new mLabel("Font"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlScreen.addLast(fontSize = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		fontSize.maxLength=2;
-		fontSize.setPreferredSize(40,-1);
-		frmScreen.addLast(pnlScreen,HSTRETCH,HFILL);
+		// ///////////////////////////////////////////////////////
+
+		CellPanel pnlScreen = new CellPanel();
+		Frame frmScreen = new Frame();
+		frmScreen.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER;
+		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625, "Screen (needs restart):")));
+		pnlScreen.addNext(new mLabel("Font"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlScreen.addNext(fontName = new mInput(), CellConstants.STRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontName.maxLength = 50;
+		fontName.setText(pref.fontName);
+		pnlScreen.addLast(fontSize = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontSize.maxLength = 2;
+		fontSize.setPreferredSize(2 * pref.fontSize, -1);
 		fontSize.setText(Convert.toString(pref.fontSize));
-		
-		frmScreen.addLast(chkHasCloseButton=new mCheckBox(MyLocale.getMsg(631,"PDA has close Button")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
-    	//lblTitle.setTag(INSETS,new Insets(2,0,0,0));
-        chkHasCloseButton.setState(pref.hasCloseButton);
-		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,"Menu top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkMenuAtTop.setTag(INSETS,new Insets(0,0,2,0));
+		frmScreen.addLast(pnlScreen, HSTRETCH, HFILL);
+
+		frmScreen.addLast(chkHasCloseButton = new mCheckBox(MyLocale.getMsg(631, "PDA has close Button")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkHasCloseButton.setState(pref.hasCloseButton);
+		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626, "Menu top")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkMenuAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
 		chkMenuAtTop.setState(pref.menuAtTop);
-		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,"Tabs top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627, "Tabs top")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkTabsAtTop.setState(pref.tabsAtTop);
-		chkTabsAtTop.setTag(INSETS,new Insets(0,0,2,0));
-		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,"Status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		chkTabsAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
+		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628, "Status")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkShowStatus.setState(pref.showStatus);
-		chkShowStatus.setTag(INSETS,new Insets(0,0,2,0));
-		pnlDisplay.addLast(frmScreen,CellConstants.HSTRETCH,CellConstants.FILL);
-		
-		Frame frmImages=new Frame();
-		frmImages.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP|UIConstants.BF_BOTTOM;
-		//frmImages.addNext(new mLabel(MyLocale.getMsg(623,"Images:")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,"Show deleted images")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkShowDeletedImg.setTag(INSETS,new Insets(2,0,0,0));
-		if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
-		//mLabel dummy;
-		//frmImages.addNext(dummy=new mLabel(""),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		//dummy.setTag(INSETS,new Insets(0,0,2,0));
-		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638,"Show pictures in description")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		chkDescShowImg.setTag(INSETS,new Insets(0,0,2,0));
-		if (pref.descShowImg) chkDescShowImg.setState(true);
-		pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+		chkShowStatus.setTag(INSETS, new Insets(0, 0, 2, 0));
+		frmScreen.addNext(chkUseBigIcons = new mCheckBox("use big Icons"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkUseBigIcons.setState(pref.useBigIcons);
+		frmScreen.addLast(chkUseRadar = new mCheckBox("Radartab on small screen"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkUseRadar.setState(pref.useRadar);
+		pnlDisplay.addLast(frmScreen, CellConstants.HSTRETCH, CellConstants.FILL);
 
-		Frame frmHintLog=new Frame();
-		//frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630,"HintLogPanel:  Logs per page ")),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpLogsPerPage=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		Frame frmImages = new Frame();
+		frmImages.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_TOP | UIConstants.BF_BOTTOM;
+		// frmImages.addNext(new mLabel(MyLocale.getMsg(623,"Images:")),CellConstants.VSTRETCH,
+		// (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624, "Show deleted images")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkShowDeletedImg.setTag(INSETS, new Insets(2, 0, 0, 0));
+		if (pref.showDeletedImages)
+			chkShowDeletedImg.setState(true);
+		// mLabel dummy;
+		// frmImages.addNext(dummy=new mLabel(""),CellConstants.VSTRETCH,
+		// (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
+		// dummy.setTag(INSETS,new Insets(0,0,2,0));
+		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638, "Show pictures in description")), CellConstants.VSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT | CellConstants.NORTH));
+		chkDescShowImg.setTag(INSETS, new Insets(0, 0, 2, 0));
+		if (pref.descShowImg)
+			chkDescShowImg.setState(true);
+		pnlDisplay.addLast(frmImages, CellConstants.STRETCH, CellConstants.FILL);
+
+		Frame frmHintLog = new Frame();
+		// frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630, "HintLogPanel:  Logs per page ")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpLogsPerPage = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
-		inpLogsPerPage.setPreferredSize(40,-1);
-		//inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
-		//lblHlP.setTag(INSETS,new Insets(6,0,2,0));
+		inpLogsPerPage.setPreferredSize(40, -1);
+		// inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
+		// lblHlP.setTag(INSETS,new Insets(6,0,2,0));
 
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633,"Max. logs to spider")),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpMaxLogsToSpider=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633, "Max. logs to spider")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpMaxLogsToSpider = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpMaxLogsToSpider.setText(Convert.toString(pref.maxLogsToSpider));
-		inpMaxLogsToSpider.setPreferredSize(40,-1);
-		
-		String [] spiderUpdateOptions = { MyLocale.getMsg(640,"Yes"), MyLocale.getMsg(641,"No"), MyLocale.getMsg(642,"Ask") };
-		frmHintLog.addNext(new mLabel( MyLocale.getMsg(639,"Update caches when spidering?") ),DONTSTRETCH,DONTFILL|LEFT);
-		frmHintLog.addLast(inpSpiderUpdates=new mChoice(spiderUpdateOptions, pref.spiderUpdates),DONTSTRETCH,DONTFILL|LEFT);
-		pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
+		inpMaxLogsToSpider.setPreferredSize(40, -1);
 
-		/////////////////////////////////////////////////////////
+		String[] spiderUpdateOptions = { MyLocale.getMsg(640, "Yes"), MyLocale.getMsg(641, "No"), MyLocale.getMsg(642, "Ask") };
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(639, "Update caches when spidering?")), DONTSTRETCH, DONTFILL | LEFT);
+		frmHintLog.addLast(inpSpiderUpdates = new mChoice(spiderUpdateOptions, pref.spiderUpdates), DONTSTRETCH, DONTFILL | LEFT);
+		pnlDisplay.addLast(frmHintLog, CellConstants.STRETCH, CellConstants.FILL);
+
+		// ///////////////////////////////////////////////////////
 		// Third panel - More
-		/////////////////////////////////////////////////////////
-		CellPanel pnlProxy=new CellPanel();
-		pnlProxy.addNext(new mLabel("Proxy"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(Proxy = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT)).setTag(SPAN,new Dimension(2,1));
+		// ///////////////////////////////////////////////////////
+		CellPanel pnlProxy = new CellPanel();
+		pnlProxy.addNext(new mLabel("Proxy"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(Proxy = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT)).setTag(SPAN, new Dimension(2, 1));
 		Proxy.setText(pref.myproxy);
-		pnlProxy.addNext(new mLabel("Port"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		pnlProxy.addNext(new mLabel("Port"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(ProxyPort = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		ProxyPort.setText(pref.myproxyport);
-		pnlProxy.addNext(new mLabel(""),HSTRETCH,HFILL);
-		pnlProxy.addLast(chkProxyActive=new mCheckBox(MyLocale.getMsg(634,"use Proxy")));
+		pnlProxy.addNext(new mLabel(""), HSTRETCH, HFILL);
+		pnlProxy.addLast(chkProxyActive = new mCheckBox(MyLocale.getMsg(634, "use Proxy")));
 		chkProxyActive.setState(pref.proxyActive);
-		pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(592,"Language (needs restart)")),DONTSTRETCH,DONTFILL|LEFT);
-		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory()+"/languages").list("*.cfg", FileBase.LIST_FILES_ONLY)); //"*.xyz" doesn't work on some systems -> use FileBugFix
-		if (tmp == null) tmp = new String[0];
-		String [] langs = new String[tmp.length +1];
+		pnlMore.addLast(pnlProxy, HSTRETCH, HFILL);
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(592, "Language (needs restart)")), DONTSTRETCH, DONTFILL | LEFT);
+		// "*.xyz" doesn't work on some systems -> use FileBugFix
+		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory() + "/languages").list("*.cfg", FileBase.LIST_FILES_ONLY));
+		if (tmp == null)
+			tmp = new String[0];
+		String[] langs = new String[tmp.length + 1];
 		langs[0] = "auto";
 		int curlang = 0;
 		for (int i = 0; i < tmp.length; i++) {
-			langs[i+1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
-			if (langs[i+1].equalsIgnoreCase(MyLocale.language)) curlang = i+1 ;
+			langs[i + 1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
+			if (langs[i + 1].equalsIgnoreCase(MyLocale.language))
+				curlang = i + 1;
 		}
-		//ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
-		pnlMore.addLast(inpLanguage=new mChoice(langs, curlang),DONTSTRETCH,DONTFILL|LEFT);
-		//inpLanguage.setPreferredSize(20,-1);
-		inpLanguage.setToolTip(MyLocale.getMsg(591,"Select \"auto\" for system language or select your preferred language, e.g. DE or EN"));
-		String [] metriken = {MyLocale.getMsg(589, "Metric (km)"), 
-				              MyLocale.getMsg(590, "Imperial (mi)")};
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, "Length units")),DONTSTRETCH,DONTFILL|LEFT);
+		// ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
+		pnlMore.addLast(inpLanguage = new mChoice(langs, curlang), DONTSTRETCH, DONTFILL | LEFT);
+		// inpLanguage.setPreferredSize(20,-1);
+		inpLanguage.setToolTip(MyLocale.getMsg(591, "Select \"auto\" for system language or select your preferred language, e.g. DE or EN"));
+		String[] metriken = { MyLocale.getMsg(589, "Metric (km)"), MyLocale.getMsg(590, "Imperial (mi)") };
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, "Length units")), DONTSTRETCH, DONTFILL | LEFT);
 		int currMetrik = pref.metricSystem == Metrics.METRIC ? 0 : 1;
-		pnlMore.addLast(inpMetric=new mChoice(metriken, currMetrik),DONTSTRETCH,DONTFILL|LEFT);
-		pnlMore.addLast(chkSortingGroupedByCache=new mCheckBox(MyLocale.getMsg(647,"Sorting grouped by Cache")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(inpMetric = new mChoice(metriken, currMetrik), DONTSTRETCH, DONTFILL | LEFT);
+		pnlMore.addLast(chkSortingGroupedByCache = new mCheckBox(MyLocale.getMsg(647, "Sorting grouped by Cache")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkSortingGroupedByCache.setState(pref.SortingGroupedByCache);
-		pnlMore.addLast(chkuseOwnSymbols=new mCheckBox(MyLocale.getMsg(649,"use own symbols")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkuseOwnSymbols = new mCheckBox(MyLocale.getMsg(649, "use own symbols")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkuseOwnSymbols.setState(pref.useOwnSymbols);
-		pnlMore.addLast(chkDebug=new mCheckBox(MyLocale.getMsg(648,"Debug Mode")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkDebug = new mCheckBox(MyLocale.getMsg(648, "Debug Mode")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkDebug.setState(pref.debug);
 
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 		// Fourth/Fifth panel - Listview and Travelbugs
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 
-        mTab.addCard(pnlGeneral,MyLocale.getMsg(621,"General"),null);
-		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,"Screen"),null);
-		mTab.addCard(pnlMore,MyLocale.getMsg(632,"More"),null);
-		mTab.addCard(tccList=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(599,"checkbox"),
-				MyLocale.getMsg(598,"type"),
-				MyLocale.getMsg(606,"Difficulty"),
-				MyLocale.getMsg(607,"Terrain"),
-				MyLocale.getMsg(597,"waypoint"),
-				MyLocale.getMsg(596,"name"),
-				MyLocale.getMsg(608,"Location"),
-				MyLocale.getMsg(609,"Owner"),
-				MyLocale.getMsg(610,"Hidden"),
-				MyLocale.getMsg(611,"Status"),
-				MyLocale.getMsg(612,"Distance"),
-				MyLocale.getMsg(613,"Bearing"),
-				MyLocale.getMsg(635,"Size"),
-				MyLocale.getMsg(636,"OC Empfehlungen"),
-				MyLocale.getMsg(637,"OC Index"),
-				MyLocale.getMsg(1039,"Solver exists"),
-				MyLocale.getMsg(1041,"Note exists"),
-				MyLocale.getMsg(1046,"# Additionals"),
-				MyLocale.getMsg(1048, "# DNF Logs"),
-				MyLocale.getMsg(1051, "Last sync date")
-				},pref.listColMap),MyLocale.getMsg(595,"List"),null);
+		mTab.addCard(pnlGeneral, MyLocale.getMsg(621, "General"), null);
+		mTab.addCard(pnlDisplay, MyLocale.getMsg(622, "Screen"), null);
+		mTab.addCard(pnlMore, MyLocale.getMsg(632, "More"), null);
+		mTab.addCard(tccList = new TableColumnChooser(new String[] { MyLocale.getMsg(599, "checkbox"), MyLocale.getMsg(598, "type"), MyLocale.getMsg(606, "Difficulty"), MyLocale.getMsg(607, "Terrain"), MyLocale.getMsg(597, "waypoint"),
+				MyLocale.getMsg(596, "name"), MyLocale.getMsg(608, "Location"), MyLocale.getMsg(609, "Owner"), MyLocale.getMsg(610, "Hidden"), MyLocale.getMsg(611, "Status"), MyLocale.getMsg(612, "Distance"), MyLocale.getMsg(613, "Bearing"),
+				MyLocale.getMsg(635, "Size"), MyLocale.getMsg(636, "OC Empfehlungen"), MyLocale.getMsg(637, "OC Index"), MyLocale.getMsg(1039, "Solver exists"), MyLocale.getMsg(1041, "Note exists"), MyLocale.getMsg(1046, "# Additionals"),
+				MyLocale.getMsg(1048, "# DNF Logs"), MyLocale.getMsg(1051, "Last sync date") }, pref.listColMap), MyLocale.getMsg(595, "List"), null);
 
-		mTab.addCard(tccBugs=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(6000,"Guid"),
-				MyLocale.getMsg(6001,"Name"),
-				MyLocale.getMsg(6002,"track#"),
-				MyLocale.getMsg(6003,"Mission"),
-				MyLocale.getMsg(6004,"From Prof"),
-				MyLocale.getMsg(6005,"From Wpt"),
-				MyLocale.getMsg(6006,"From Date"),
-				MyLocale.getMsg(6007,"From Log"),
-				MyLocale.getMsg(6008,"To Prof"),
-				MyLocale.getMsg(6009,"To Wpt"),
-				MyLocale.getMsg(6010,"To Date"),
-				MyLocale.getMsg(6011,"To Log")},pref.travelbugColMap),"T-bugs",null);
-		
+		mTab.addCard(tccBugs = new TableColumnChooser(new String[] { MyLocale.getMsg(6000, "Guid"), MyLocale.getMsg(6001, "Name"), MyLocale.getMsg(6002, "track#"), MyLocale.getMsg(6003, "Mission"), MyLocale.getMsg(6004, "From Prof"),
+				MyLocale.getMsg(6005, "From Wpt"), MyLocale.getMsg(6006, "From Date"), MyLocale.getMsg(6007, "From Log"), MyLocale.getMsg(6008, "To Prof"), MyLocale.getMsg(6009, "To Wpt"), MyLocale.getMsg(6010, "To Date"),
+				MyLocale.getMsg(6011, "To Log") }, pref.travelbugColMap), "T-bugs", null);
+
 		this.addLast(mTab);
-		cancelB = new mButton(MyLocale.getMsg(614,"Cancel"));
+		cancelB = new mButton(MyLocale.getMsg(614, "Cancel"));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		applyB = new mButton(MyLocale.getMsg(615,"Apply"));
+		addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		applyB = new mButton(MyLocale.getMsg(615, "Apply"));
 		applyB.setHotKey(0, IKeys.ACTION);
-		addLast(applyB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		addLast(applyB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 	}
-	
+
 	private CellPanel separator(CellPanel pnl) {
 		CellPanel outerPnl = new CellPanel();
-		pnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
-		outerPnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.addLast(pnl,HSTRETCH,HFILL);
+		pnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_BOTTOM;
+		outerPnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.addLast(pnl, HSTRETCH, HFILL);
 		return outerPnl;
 	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB) {
 				this.close(0);
 			}
-			if (ev.target == applyB){
+			if (ev.target == applyB) {
 				pref.setBaseDir(DataDir.getText());
 				pref.fontSize = Convert.toInt(fontSize.getText());
-				if (pref.fontSize<6) pref.fontSize=11;
-				pref.logsPerPage=Common.parseInt(inpLogsPerPage.getText());
-				if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
-				pref.maxLogsToSpider=Common.parseInt(inpMaxLogsToSpider.getText());
-				if (pref.maxLogsToSpider==0) pref.maxLogsToSpider=pref.DEFAULT_MAX_LOGS_TO_SPIDER;
-				
+				if (pref.fontSize < 6)
+					pref.fontSize = 11;
+				pref.fontName = fontName.getText();
+				pref.logsPerPage = Common.parseInt(inpLogsPerPage.getText());
+				if (pref.logsPerPage == 0)
+					pref.logsPerPage = pref.DEFAULT_LOGS_PER_PAGE;
+				pref.maxLogsToSpider = Common.parseInt(inpMaxLogsToSpider.getText());
+				if (pref.maxLogsToSpider == 0)
+					pref.maxLogsToSpider = pref.DEFAULT_MAX_LOGS_TO_SPIDER;
+
 				Font defaultGuiFont = mApp.findFont("gui");
 				int sz = (pref.fontSize);
-				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 
-				mApp.addFont(newGuiFont, "gui"); 
+				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+				mApp.addFont(newGuiFont, "gui");
 				mApp.fontsChanged();
 				mApp.mainApp.font = newGuiFont;
-				
+
 				pref.myAlias = Alias.getText().trim();
-				pref.password= inpPassword.getText().trim();
-				pref.gcMemberId=inpGcMemberID.getText().trim();
-				MyLocale.saveLanguage(MyLocale.language=inpLanguage.getText().toUpperCase().trim());
+				pref.password = inpPassword.getText().trim();
+				pref.gcMemberId = inpGcMemberID.getText().trim();
+				pref.userID = inpUserID.getText().trim();
+				MyLocale.saveLanguage(MyLocale.language = inpLanguage.getText().toUpperCase().trim());
 				pref.browser = Browser.getText();
 				pref.myproxy = Proxy.getText();
 				pref.myproxyport = ProxyPort.getText();
-				pref.proxyActive=chkProxyActive.getState();
-				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
-				pref.autoReloadLastProfile=chkAutoLoad.getState();
-				pref.isPremium=chkPM.getState();
-				pref.setCurrentCentreFromGPSPosition=chkSetCurrentCentreFromGPSPosition.getState();
-				pref.showDeletedImages=chkShowDeletedImg.getState();
-				pref.garminConn=chcGarminPort.getSelectedItem().toString();
-				pref.garminGPSBabelOptions=chkSynthShort.state?"-s":"";
-				pref.menuAtTop=chkMenuAtTop.getState();
-				pref.tabsAtTop=chkTabsAtTop.getState();
-				pref.showStatus=chkShowStatus.getState();
-				pref.hasCloseButton=chkHasCloseButton.getState();
-				pref.travelbugColMap=tccBugs.getSelectedCols();
-				pref.listColMap=tccList.getSelectedCols();
-				pref.descShowImg=chkDescShowImg.getState();
+				pref.proxyActive = chkProxyActive.getState();
+				// TODO generate an error message if proxy port is not a number
+				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive);
+				pref.autoReloadLastProfile = chkAutoLoad.getState();
+				pref.isPremium = chkPM.getState();
+				pref.setCurrentCentreFromGPSPosition = chkSetCurrentCentreFromGPSPosition.getState();
+				pref.showDeletedImages = chkShowDeletedImg.getState();
+				pref.garminConn = chcGarminPort.getSelectedItem().toString();
+				pref.garminGPSBabelOptions = chkSynthShort.state ? "-s" : "";
+				pref.menuAtTop = chkMenuAtTop.getState();
+				pref.tabsAtTop = chkTabsAtTop.getState();
+				pref.showStatus = chkShowStatus.getState();
+				pref.hasCloseButton = chkHasCloseButton.getState();
+				pref.useBigIcons = chkUseBigIcons.getState();
+				pref.useRadar = chkUseRadar.getState();
+				pref.travelbugColMap = tccBugs.getSelectedCols();
+				pref.listColMap = tccList.getSelectedCols();
+				pref.descShowImg = chkDescShowImg.getState();
 				Global.mainTab.tbP.myMod.setColumnNamesAndWidths();
 				pref.metricSystem = inpMetric.getInt() == 0 ? Metrics.METRIC : Metrics.IMPERIAL;
 				pref.spiderUpdates = inpSpiderUpdates.getInt();
 				pref.addDetailsToWaypoint = chkAddDetailsToWaypoint.getState();
 				pref.addDetailsToName = chkAddDetailsToName.getState();
-				pref.SortingGroupedByCache=chkSortingGroupedByCache.getState();
-				pref.useOwnSymbols=chkuseOwnSymbols.getState();
-				pref.debug=chkDebug.getState();
+				pref.SortingGroupedByCache = chkSortingGroupedByCache.getState();
+				pref.useOwnSymbols = chkuseOwnSymbols.getState();
+				pref.debug = chkDebug.getState();
 
 				pref.savePreferences();
 				pref.dirty = true; // Need to update table in case columns were enabled/disabled
 				this.close(0);
 			}
-			if(ev.target == brwBt){
+			if (ev.target == brwBt) {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getBaseDir());
-				fc.setTitle(MyLocale.getMsg(616,"Select directory"));
-				if(fc.execute() != FormBase.IDCANCEL)	DataDir.setText(fc.getChosen()+"/");
+				fc.setTitle(MyLocale.getMsg(616, "Select directory"));
+				if (fc.execute() != FormBase.IDCANCEL)
+					DataDir.setText(fc.getChosen() + "/");
 			}
-			if (ev.target == gpsB){
+			if (ev.target == gpsB) {
 				GPSPortOptions gpo = new GPSPortOptions();
 				gpo.portName = pref.mySPO.portName;
 				gpo.baudRate = pref.mySPO.baudRate;
@@ -402,36 +391,36 @@
 				gpo.forwardGpsChkB.setState(pref.forwardGPS);
 				gpo.inputBoxForwardHost.setText(pref.forwardGpsHost);
 				gpo.chcUseGpsd.select(pref.useGPSD);
-				if(pref.gpsdPort!=pref.DEFAULT_GPSD_PORT){
+				if (pref.gpsdPort != pref.DEFAULT_GPSD_PORT) {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost + ":" + Convert.toString(pref.gpsdPort));
-				}else{
+				} else {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost);
 				}
 				gpo.logGpsChkB.setState(pref.logGPS);
 				gpo.inputBoxLogTimer.setText(pref.logGPSTimer);
 				Gui.setOKCancel(s);
-				if (s.execute()== FormBase.IDOK) {
-					pref.mySPO.portName = gpo.portName; 
+				if (s.execute() == FormBase.IDOK) {
+					pref.mySPO.portName = gpo.portName;
 					pref.mySPO.baudRate = gpo.baudRate;
 					pref.forwardGPS = gpo.forwardGpsChkB.getState();
 					pref.forwardGpsHost = gpo.inputBoxForwardHost.getText();
 					pref.useGPSD = gpo.chcUseGpsd.getInt();
-					String gpsdHostString = gpo.inputBoxGpsdHost.getText();	// hostname[:port]
+					String gpsdHostString = gpo.inputBoxGpsdHost.getText(); // hostname[:port]
 					int posColon = gpsdHostString.indexOf(':');
-					if(posColon>=0){
-						pref.gpsdHost=gpsdHostString.substring(0,posColon);
-						pref.gpsdPort=Convert.toInt(gpsdHostString.substring(posColon+1));
-					}else{
-						pref.gpsdHost=gpsdHostString;
-						pref.gpsdPort=pref.DEFAULT_GPSD_PORT;
+					if (posColon >= 0) {
+						pref.gpsdHost = gpsdHostString.substring(0, posColon);
+						pref.gpsdPort = Convert.toInt(gpsdHostString.substring(posColon + 1));
+					} else {
+						pref.gpsdHost = gpsdHostString;
+						pref.gpsdPort = pref.DEFAULT_GPSD_PORT;
 					}
 					pref.logGPS = gpo.logGpsChkB.getState();
 					pref.logGPSTimer = gpo.inputBoxLogTimer.getText();
-					gpsB.setText("GPS: " + pref.mySPO.portName+"/"+pref.mySPO.baudRate);
+					gpsB.setText("GPS: " + pref.mySPO.portName + "/" + pref.mySPO.baudRate);
 				}
 			}
 		}
 		super.onEvent(ev);
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/Profile.java
===================================================================
--- branches/r1.2/src/CacheWolf/Profile.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Profile.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Area;
@@ -44,22 +44,25 @@
 
 /**
  * This class holds a profile, i.e. a group of caches with a centre location
- *
+ * 
  * @author salzkammergut
- *
+ * 
  */
 public class Profile {
 
-	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
-	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
+	/**
+	 * The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
+	 * this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
 	 */
-	public CacheDB cacheDB=new CacheDB();
+	public CacheDB cacheDB = new CacheDB();
 	/** The centre point of this group of caches. Read from ans stored to index.xml file */
-	public CWPoint centre=new CWPoint();
-	/** The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
-	 *  the index.xml and cache files live. (Excuse the English spelling of centre)     */
-	public String name="";
-	/** This is the directory for the profile. It contains a closing /.   	 */
+	public CWPoint centre = new CWPoint();
+	/**
+	 * The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
+	 * the index.xml and cache files live. (Excuse the English spelling of centre)
+	 */
+	public String name = "";
+	/** This is the directory for the profile. It contains a closing /. */
 	public String dataDir = "";
 
 	/** Last sync date for opencaching caches */
@@ -73,11 +76,11 @@
 	private String minDistGC = "";
 	/** Direction for geocaching caches */
 	private String directionGC = "";
-	
-	private String gpxStyle =new String(); 
-	private String gpxTarget =new String(); 
-	private String gpxId =new String(); 
 
+	private String gpxStyle = new String();
+	private String gpxTarget = new String();
+	private String gpxId = new String();
+
 	/** path to the maps of the profile relative to the maps root */
 	private String relativeCustomMapsPath = "";
 
@@ -91,7 +94,8 @@
 	private boolean showSearchResult = false;
 
 	public boolean selectionChanged = true; // ("H?ckchen") used by movingMap to get to knao if it should update the caches in the map
-	/** True if the profile has been modified and not saved
+	/**
+	 * True if the profile has been modified and not saved
 	 * The following modifications set this flag: New profile centre, Change of waypoint data
 	 */
 	private boolean hasUnsavedChanges = false;
@@ -100,21 +104,19 @@
 	/** version number of current format for index.xml and waypoint.xml */
 	protected static int CURRENTFILEFORMAT = 3;
 
-	//TODO Add other settings, such as max. number of logs to spider
-	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
+	// TODO Add other settings, such as max. number of logs to spider
+	// TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 
 	/**
 	 * Constructor for a profile
-	 *
+	 * 
 	 */
-	public Profile(){ // public constructor
+	public Profile() { // public constructor
 	}
 
-
 	/**
-	 * Returns <code>true</code> if profile needs to be changed when profile is left. Returns
-	 * <code>false</code> if no relevant changes have been made.
-	 *
+	 * Returns <code>true</code> if profile needs to be changed when profile is left. Returns <code>false</code> if no relevant changes have been made.
+	 * 
 	 * @return hasUnsavedChanges
 	 */
 	public boolean hasUnsavedChanges() {
@@ -125,7 +127,7 @@
 	 * Remember that profile needs to be saved. Flag is set <code>true</code> when parameter is
 	 * true, but it's not set to <code>false</code> when parameter is <code>false</code>.<br>
 	 * This is only done internally on saving the cache.
-	 *
+	 * 
 	 * @param hasUnsavedChanges
 	 *            the hasUnsavedChanges to set
 	 */
@@ -161,58 +163,58 @@
 	}
 
 	/**
-	 *	Method to save the index.xml file that holds the total information
-	 *	on available caches in the database. The database is nothing else
-	 *	than the collection of caches in a directory.
-	 *
-	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
-	 *
-	 *   Saves the index with the filter settings from Filter
+	 * Method to save the index.xml file that holds the total information
+	 * on available caches in the database. The database is nothing else
+	 * than the collection of caches in a directory.
+	 * 
+	 * Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
+	 * 
+	 * Saves the index with the filter settings from Filter
 	 */
-//	public void saveIndex(Preferences pref, boolean showprogress){
-//		saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
-//	}
+	// public void saveIndex(Preferences pref, boolean showprogress){
+	// saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
+	// }
 
-
 	/** Save index with filter settings given */
 	public void saveIndex(Preferences pref, boolean showprogress) {
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
-		if(showprogress){
-			pbf.showMainTask = true;//false;
-			pbf.setTask(h,"Saving Index");
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
+		if (showprogress) {
+			pbf.showMainTask = true;// false;
+			pbf.setTask(h, "Saving Index");
 			pbf.exec();
 		}
 		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
 		PrintWriter detfile;
 		CacheHolder ch;
 		try {
-			File backup=new File(dataDir+"index.bak");
+			File backup = new File(dataDir + "index.bak");
 			if (backup.exists()) {
 				backup.delete();
 			}
-			File index=new File(dataDir+"index.xml");
+			File index = new File(dataDir + "index.xml");
 			index.rename("index.bak");
 		} catch (Exception ex) {
 			pref.log("[Profile:saveIndex]Error deleting backup or renaming index.xml");
 		}
-		try{
+		try {
 			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dataDir + "index.xml").getAbsolutePath())));
 		} catch (Exception e) {
-			pref.log("Problem creating index.xml " + dataDir,e);
+			pref.log("Problem creating index.xml " + dataDir, e);
 			return;
 		}
-		CWPoint savedCentre=centre;
-		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 && savedCentre.lonDec==0.0)) savedCentre=pref.getCurCentrePt();
+		CWPoint savedCentre = centre;
+		if (centre == null || !centre.isValid() || (savedCentre.latDec == 0.0 && savedCentre.lonDec == 0.0))
+			savedCentre = pref.getCurCentrePt();
 
-		try{
+		try {
 			detfile.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
 			detfile.print("<CACHELIST format=\"decimal\">\n");
 			detfile.print("    <VERSION value = \"3\"/>\n");
 			if (savedCentre.isValid())
-				detfile.print("    <CENTRE lat=\""+savedCentre.latDec+"\" lon=\""+savedCentre.lonDec+"\"/>\n");
-			if(getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith("null") || getLast_sync_opencaching().equals("")){
+				detfile.print("    <CENTRE lat=\"" + savedCentre.latDec + "\" lon=\"" + savedCentre.lonDec + "\"/>\n");
+			if (getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith("null") || getLast_sync_opencaching().equals("")) {
 				setLast_sync_opencaching("20050801000000");
 			}
 			if (getDistOC() == null || getDistOC().endsWith("null") || getDistOC().equals("")) {
@@ -232,15 +234,14 @@
 			// normal filter, because after loading there is no cache tour defined
 			// which could be used as filter criterium.
 			int activeFilterForSave;
-			if (getFilterActive()==Filter.FILTER_CACHELIST) {
+			if (getFilterActive() == Filter.FILTER_CACHELIST) {
 				activeFilterForSave = Filter.FILTER_ACTIVE;
 			} else {
 				activeFilterForSave = getFilterActive();
 			}
-			detfile.print("    <FILTERCONFIG status = \""+activeFilterForSave+
-					(isFilterInverted()?"T":"F")+"\" showBlacklist = \""+showBlacklisted()+"\" />\n");
+			detfile.print("    <FILTERCONFIG status = \"" + activeFilterForSave + (isFilterInverted() ? "T" : "F") + "\" showBlacklist = \"" + showBlacklisted() + "\" />\n");
 			detfile.print(this.getCurrentFilter().toXML(""));
-			detfile.print("    <SYNCOC date = \""+getLast_sync_opencaching()+"\" dist = \""+getDistOC()+"\"/>\n");
+			detfile.print("    <SYNCOC date = \"" + getLast_sync_opencaching() + "\" dist = \"" + getDistOC() + "\"/>\n");
 			detfile.print("    <SPIDERGC dist = \"" + getDistGC() + "\" mindist = \"" + getMinDistGC() + "\" direction = \"" + getDirectionGC() + "\"/>\n");
 			detfile.print("    <EXPORT style = \"" + getGpxStyle() + "\" target = \"" + getGpxTarget() + "\" id = \"" + getGpxId() + "\"/>\n");
 			detfile.print("    <mapspath relativeDir = \"" + SafeXML.clean(relativeCustomMapsPath) + "\"/>\n");
@@ -248,7 +249,8 @@
 			for (int i = 0; i < size; i++) {
 				if (showprogress) {
 					h.progress = (float) i / (float) size;
-					if ((i%updFrequ)==0) h.changed();
+					if ((i % updFrequ) == 0)
+						h.changed();
 				}
 				ch = cacheDB.get(i);
 				if (ch.getWayPoint().length() > 0) {
@@ -257,12 +259,14 @@
 			}
 			detfile.print("</CACHELIST>\n");
 			detfile.close();
-			buildReferences(); //TODO Why is this needed here?
-			if(showprogress) pbf.exit(0);
-		}catch(Exception e){
-			pref.log("Problem writing to index file ",e);
+			buildReferences(); // TODO Why is this needed here?
+			if (showprogress)
+				pbf.exit(0);
+		} catch (Exception e) {
+			pref.log("Problem writing to index file ", e);
 			detfile.close();
-			if(showprogress) pbf.exit(0);
+			if (showprogress)
+				pbf.exit(0);
 		}
 		resetUnsavedChanges();
 	}
@@ -270,19 +274,20 @@
 	public void readIndex() {
 		readIndex(null);
 	}
+
 	/**
-	 *	Method to read the index.xml file that holds the total information
-	 *	on available caches in the database. The database in nothing else
-	 *	than the collection of caches in a directory.
+	 * Method to read the index.xml file that holds the total information
+	 * on available caches in the database. The database in nothing else
+	 * than the collection of caches in a directory.
 	 */
 	public void readIndex(InfoBox infoBox) {
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
 		try {
 			selectionChanged = true;
 			boolean fmtDec = false;
-			String mainInfoText = MyLocale.getMsg(5000,"Loading Cache-List");
-			int wptNo=1;
-			int lastShownWpt=0;
+			String mainInfoText = MyLocale.getMsg(5000, "Loading Cache-List");
+			int wptNo = 1;
+			int lastShownWpt = 0;
 			char decSep = MyLocale.getDigSeparator().charAt(0);
 			char notDecSep = decSep == '.' ? ',' : '.';
 			FileBugfix indexFile = new FileBugfix(dataDir + "index.xml");
@@ -290,92 +295,106 @@
 			indexXmlVersion = 1; // Initial guess
 			in.readLine(); // <?xml version= ...
 			String text = in.readLine(); // <CACHELIST>
-			if (text!=null && text.indexOf("decimal")>0) fmtDec=true;
+			if (text != null && text.indexOf("decimal") > 0)
+				fmtDec = true;
 			Extractor ex = new Extractor(null, " = \"", "\" ", 0, true);
 
-			//ewe.sys.Time startT=new ewe.sys.Time();
+			// ewe.sys.Time startT=new ewe.sys.Time();
 			boolean convertWarningDisplayed = false;
-			while ((text = in.readLine()) != null){
+			while ((text = in.readLine()) != null) {
 				// Check for Line with cache data
-				if (text.indexOf("<CACHE ")>=0){
+				if (text.indexOf("<CACHE ") >= 0) {
 					if (indexXmlVersion < CURRENTFILEFORMAT && !convertWarningDisplayed) {
 						if (indexXmlVersion < CURRENTFILEFORMAT) {
 							convertWarningDisplayed = true;
-							int res=new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(4407, "The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done."), FormBase.YESB|FormBase.NOB).execute();
+							int res = new MessageBox(
+									MyLocale.getMsg(144, "Warning"),
+									MyLocale.getMsg(4407,
+											"The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done."),
+									FormBase.YESB | FormBase.NOB).execute();
 							if (res == MessageBox.NOB) {
 								ewe.sys.Vm.exit(0);
 							}
 						}
 					}
-					if (infoBox!=null) {
+					if (infoBox != null) {
 						if (wptNo - updFrequ >= lastShownWpt) {
-							infoBox.setInfo(mainInfoText+"\n"+String.valueOf(wptNo));
+							infoBox.setInfo(mainInfoText + "\n" + String.valueOf(wptNo));
 							lastShownWpt = wptNo;
 						}
 						wptNo++;
 					}
-					CacheHolder ch=new CacheHolder(text,indexXmlVersion);
+					CacheHolder ch = new CacheHolder(text, indexXmlVersion);
 					cacheDB.add(ch);
-				} else if (text.indexOf("<CENTRE")>=0) { // lat=  lon=
+				} else if (text.indexOf("<CENTRE") >= 0) { // lat= lon=
 					if (fmtDec) {
-						int start=text.indexOf("lat=\"")+5;
-						String lat=text.substring(start,text.indexOf("\"",start)).replace(notDecSep,decSep);
-						start=text.indexOf("lon=\"")+5;
-						String lon=text.substring(start,text.indexOf("\"",start)).replace(notDecSep,decSep);
-						centre.set(Convert.parseDouble(lat),Convert.parseDouble(lon));
+						int start = text.indexOf("lat=\"") + 5;
+						String lat = text.substring(start, text.indexOf("\"", start)).replace(notDecSep, decSep);
+						start = text.indexOf("lon=\"") + 5;
+						String lon = text.substring(start, text.indexOf("\"", start)).replace(notDecSep, decSep);
+						centre.set(Convert.parseDouble(lat), Convert.parseDouble(lon));
 					} else {
-						int start=text.indexOf("lat=\"")+5;
-						String lat=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
-						start=text.indexOf("long=\"")+6;
-						String lon=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
-						centre.set(lat+" "+lon,TransformCoordinates.CW); // Fast parse
+						int start = text.indexOf("lat=\"") + 5;
+						String lat = SafeXML.cleanback(text.substring(start, text.indexOf("\"", start)));
+						start = text.indexOf("long=\"") + 6;
+						String lon = SafeXML.cleanback(text.substring(start, text.indexOf("\"", start)));
+						centre.set(lat + " " + lon, TransformCoordinates.CW); // Fast parse
 					}
-				} else if (text.indexOf("<VERSION")>=0) {
-					int start=text.indexOf("value = \"")+9;
-					indexXmlVersion  = Integer.valueOf(text.substring(start,text.indexOf("\"",start))).intValue();
+				} else if (text.indexOf("<VERSION") >= 0) {
+					int start = text.indexOf("value = \"") + 9;
+					indexXmlVersion = Integer.valueOf(text.substring(start, text.indexOf("\"", start))).intValue();
 					if (indexXmlVersion > CURRENTFILEFORMAT) {
 						Global.getPref().log("[Profile:readIndex]unsupported file format");
 						clearProfile();
 						return;
 					}
-				} else if (text.indexOf("<SYNCOC")>=0) {
-					int start=text.indexOf("date = \"")+8;
-					setLast_sync_opencaching(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("dist = \"")+8;
-					setDistOC(text.substring(start,text.indexOf("\"",start)));
-				} else if (text.indexOf("mapspath")>=0) {
-					int start=text.indexOf("relativeDir = \"")+15;
-					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start,text.indexOf("\"",start))).replace('\\','/'));
-				} else if (text.indexOf("<SPIDERGC")>=0) {
-					int start=text.indexOf("dist = \"")+8;
-					setDistGC(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("mindist = \"")+11;
-					if (start==10) {setMinDistGC("0");}
-					else setMinDistGC(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("direction = \"")+13;
-					if (start==12) {setDirectionGC("");}
-					else setDirectionGC(text.substring(start,text.indexOf("\"",start)));
-				} else if (text.indexOf("<EXPORT")>=0) {
-					int start=text.indexOf("style = \"")+9;
-					if (start==8) {setGpxStyle("0");}
-					else setGpxStyle(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("target = \"")+10;
-					if (start==9) {setGpxTarget("0");}
-					else setGpxTarget(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("id = \"")+6;
-					if (start==5) {setGpxId("0");}
-					else setGpxId(text.substring(start,text.indexOf("\"",start)));
-				} else if (indexXmlVersion <=2 && text.indexOf("<FILTER")>=0){
+				} else if (text.indexOf("<SYNCOC") >= 0) {
+					int start = text.indexOf("date = \"") + 8;
+					setLast_sync_opencaching(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("dist = \"") + 8;
+					setDistOC(text.substring(start, text.indexOf("\"", start)));
+				} else if (text.indexOf("mapspath") >= 0) {
+					int start = text.indexOf("relativeDir = \"") + 15;
+					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start, text.indexOf("\"", start))).replace('\\', '/'));
+				} else if (text.indexOf("<SPIDERGC") >= 0) {
+					int start = text.indexOf("dist = \"") + 8;
+					setDistGC(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("mindist = \"") + 11;
+					if (start == 10) {
+						setMinDistGC("0");
+					} else
+						setMinDistGC(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("direction = \"") + 13;
+					if (start == 12) {
+						setDirectionGC("");
+					} else
+						setDirectionGC(text.substring(start, text.indexOf("\"", start)));
+				} else if (text.indexOf("<EXPORT") >= 0) {
+					int start = text.indexOf("style = \"") + 9;
+					if (start == 8) {
+						setGpxStyle("0");
+					} else
+						setGpxStyle(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("target = \"") + 10;
+					if (start == 9) {
+						setGpxTarget("0");
+					} else
+						setGpxTarget(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("id = \"") + 6;
+					if (start == 5) {
+						setGpxId("0");
+					} else
+						setGpxId(text.substring(start, text.indexOf("\"", start)));
+				} else if (indexXmlVersion <= 2 && text.indexOf("<FILTER") >= 0) {
 					// Read filter data of file versions 1 and 2. (Legacy code)
-					ex.setSource(text.substring(text.indexOf("<FILTER")));
-					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
-					if (temp.length()==2) {
+					String temp = ex.findFirst(text.substring(text.indexOf("<FILTER"))); // Filter status is now first, need to deal with old versions which don't have filter status
+					if (temp.length() == 2) {
 						// Compatibility with previous versions
-						if (temp.charAt(0)=='T')
+						if (temp.charAt(0) == 'T')
 							setFilterActive(Filter.FILTER_ACTIVE);
 						else
-							setFilterActive(Common.parseInt(temp.substring(0,1)));
-						setFilterInverted(temp.charAt(1)=='T');
+							setFilterActive(Common.parseInt(temp.substring(0, 1)));
+						setFilterInverted(temp.charAt(1) == 'T');
 						setFilterRose(ex.findNext());
 					} else
 						setFilterRose(temp);
@@ -386,20 +405,19 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null && !attr.equals(""))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
 					if (attr != null && !attr.equals(""))
 						filterAttr[2] = Convert.parseLong(attr);
 					attr = ex.findNext();
-					setFilterAttr(filterAttr);					
+					setFilterAttr(filterAttr);
 					if (attr != null && !attr.equals(""))
 						setFilterAttrChoice(Convert.parseInt(attr));
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
-				} else if (text.indexOf("<FILTERDATA")>=0){
-					ex.setSource(text.substring(text.indexOf("<FILTERDATA")));
-					setFilterRose(ex.findNext());
+				} else if (text.indexOf("<FILTERDATA") >= 0) {
+					setFilterRose(ex.findFirst(text.substring(text.indexOf("<FILTERDATA"))));
 					setFilterType(ex.findNext());
 					setFilterVar(ex.findNext());
 					setFilterDist(ex.findNext());
@@ -407,7 +425,7 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null && !attr.equals(""))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
@@ -418,69 +436,68 @@
 					setFilterAttrChoice(Convert.parseInt(attr));
 					setFilterStatus(SafeXML.cleanback(ex.findNext()));
 					setFilterUseRegexp(Boolean.valueOf(ex.findNext()).booleanValue());
-					attr = ex.findNext();					
-	  				if (attr != null && !attr.equals("")) {
-	  					setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
+					attr = ex.findNext();
+					if (attr != null && !attr.equals("")) {
+						setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
 
-	  				}
-	  				else {
-	  					setFilterNoCoord(true);
-	  				}
-	  				attr = ex.findNext();					
-	  				if (attr != null && !attr.equals(""))
-	  					filterAttr[1] = Convert.parseLong(attr);
-	  				attr = ex.findNext();
-	  				if (attr != null && !attr.equals(""))
-	  					filterAttr[3] = Convert.parseLong(attr);
-	  				setFilterAttr(filterAttr);
-				} else if (text.indexOf("<FILTERCONFIG")>=0){
-					ex.setSource(text.substring(text.indexOf("<FILTERCONFIG")));
-					String temp=ex.findNext();
-					setFilterActive(Common.parseInt(temp.substring(0,1)));
-					setFilterInverted(temp.charAt(1)=='T');
+					} else {
+						setFilterNoCoord(true);
+					}
+					attr = ex.findNext();
+					if (attr != null && !attr.equals(""))
+						filterAttr[1] = Convert.parseLong(attr);
+					attr = ex.findNext();
+					if (attr != null && !attr.equals(""))
+						filterAttr[3] = Convert.parseLong(attr);
+					setFilterAttr(filterAttr);
+				} else if (text.indexOf("<FILTERCONFIG") >= 0) {
+					String temp = ex.findFirst(text.substring(text.indexOf("<FILTERCONFIG")));
+					setFilterActive(Common.parseInt(temp.substring(0, 1)));
+					setFilterInverted(temp.charAt(1) == 'T');
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
 				}
 			}
 			in.close();
 			// Build references between caches and addi wpts
-			if (infoBox!=null) {
-				infoBox.setInfo(MyLocale.getMsg(5004,"Building references..."));
+			if (infoBox != null) {
+				infoBox.setInfo(MyLocale.getMsg(5004, "Building references..."));
 			}
 			buildReferences();
 			if (indexXmlVersion < CURRENTFILEFORMAT) {
 				saveIndex(Global.getPref(), true);
 			}
 		} catch (FileNotFoundException e) {
-			Global.getPref().log("index.xml not found in directory "+dataDir,e);
-		} catch (IOException e){
-			Global.getPref().log("Problem reading index.xml in dir: "+dataDir,e,true);
+			Global.getPref().log("index.xml not found in directory " + dataDir, e);
+		} catch (IOException e) {
+			Global.getPref().log("Problem reading index.xml in dir: " + dataDir, e, true);
 		}
 		this.getCurrentFilter().normaliseFilters();
 		resetUnsavedChanges();
 	}
 
-	/** Restore the filter to the values stored in this profile
-	 *  Called from Main Form and MainMenu
-	 *  The values of Filter.isActive and Filter.isInactive are set by the filter
+	/**
+	 * Restore the filter to the values stored in this profile
+	 * Called from Main Form and MainMenu
+	 * The values of Filter.isActive and Filter.isInactive are set by the filter
 	 **/
 	public void restoreFilter() {
-		restoreFilter( true );
+		restoreFilter(true);
 	}
 
 	void restoreFilter(boolean clearIfInactive) {
-		boolean inverted=isFilterInverted(); // Save it as doFilter will clear filterInverted
-		Filter flt=new Filter();
-		if (getFilterActive()==Filter.FILTER_ACTIVE) {
+		boolean inverted = isFilterInverted(); // Save it as doFilter will clear filterInverted
+		Filter flt = new Filter();
+		if (getFilterActive() == Filter.FILTER_ACTIVE) {
 			flt.setFilter();
 			flt.doFilter();
 			if (inverted) {
 				flt.invertFilter();
 				setFilterInverted(true); // Needed because previous line inverts filterInverted
 			}
-		} else if (getFilterActive()==Filter.FILTER_CACHELIST) {
+		} else if (getFilterActive() == Filter.FILTER_CACHELIST) {
 			Global.mainForm.cacheList.applyCacheList();
-			//flt.filterActive=filterActive;
-		} else if (getFilterActive()==Filter.FILTER_INACTIVE) {
+			// flt.filterActive=filterActive;
+		} else if (getFilterActive() == Filter.FILTER_INACTIVE) {
 			if (clearIfInactive) {
 				flt.clearFilter();
 			}
@@ -507,8 +524,9 @@
 	}
 
 	/**
-	 *
-	 * @param forcache maincache
+	 * 
+	 * @param forcache
+	 *            maincache
 	 * @return
 	 */
 	public String getNewAddiWayPointName(String forcache) {
@@ -522,7 +540,7 @@
 
 	/**
 	 * Call this after getNewAddiWayPointName to set the references between main and addi correctly
-	 *
+	 * 
 	 * @param ch
 	 */
 	public void setAddiRef(CacheHolder ch) {
@@ -530,15 +548,15 @@
 		int mainindex = getCacheIndex("GC" + mainwpt);
 		if (mainindex < 0 || !cacheDB.get(mainindex).isCacheWpt()) {
 			for (int i = 0; i < OC.OCSites.length; i++) {
-				mainindex=getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
-				if (mainindex >= 0 && cacheDB.get(mainindex).isCacheWpt()){
+				mainindex = getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
+				if (mainindex >= 0 && cacheDB.get(mainindex).isCacheWpt()) {
 					break;
 				}
 			}
 		}
 		if (mainindex < 0 || !cacheDB.get(mainindex).isCacheWpt())
 			mainindex = getCacheIndex("CW" + mainwpt);
-		if (mainindex < 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */ )  {
+		if (mainindex < 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */) {
 			ch.setIncomplete(true);
 		} else {
 			CacheHolder mainch = cacheDB.get(mainindex);
@@ -553,8 +571,7 @@
 	}
 
 	public String toString() {
-		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
-		getLast_sync_opencaching()+"\ndistOC="+getDistOC()+"\ndistGC="+getDistGC();
+		return "Profile: Name=" + name + "\nCentre=" + centre.toString() + "\ndataDir=" + dataDir + "\nlastSyncOC=" + getLast_sync_opencaching() + "\ndistOC=" + getDistOC() + "\ndistGC=" + getDistGC();
 	}
 
 	public void setSelectForAll(boolean selectStatus) {
@@ -570,29 +587,34 @@
 	public int numCachesInArea; // only valid after calling getSourroundingArea
 
 	public Area getSourroundingArea(boolean onlyOfSelected) {
-		if (cacheDB == null || cacheDB.size() == 0) return null;
+		if (cacheDB == null || cacheDB.size() == 0)
+			return null;
 		CacheHolder ch;
 		CWPoint topleft = null;
 		CWPoint bottomright = null;
-		CWPoint tmpca = new CWPoint();
 		numCachesInArea = 0;
 		boolean isAddi = false;
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
-				if (ch.pos == null) { // this can not happen
-					tmpca.set(ch.getLatLon());
-					ch.pos = new CWPoint(tmpca);
-				}
-				if (ch.pos.isValid() ){ // done: && ch.pos.latDec != 0 && ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
+				if (ch.getPos().isValid()) { // done: && ch.pos.latDec != 0 && ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
 					isAddi = ch.isAddiWpt();
-				if (!isAddi || (isAddi && ch.mainCache != null && ch.pos.getDistance(ch.mainCache.pos) < 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -> ignore it // && ch.mainCache != null is only necessary because the data base may be corrupted
-						if (topleft == null) topleft = new CWPoint(ch.pos);
-						if (bottomright == null) bottomright = new CWPoint(ch.pos);
-						if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
-						if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
-						if (bottomright.latDec > ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
-						if (bottomright.lonDec < ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
+					// test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible ->
+					// ignore it //
+					// && ch.mainCache != null is only necessary because the data base may be corrupted
+					if (!isAddi || (isAddi && ch.mainCache != null && ch.getPos().getDistance(ch.mainCache.getPos()) < 1000)) {
+						if (topleft == null)
+							topleft = new CWPoint(ch.getPos());
+						if (bottomright == null)
+							bottomright = new CWPoint(ch.getPos());
+						if (topleft.latDec < ch.getPos().latDec)
+							topleft.latDec = ch.getPos().latDec;
+						if (topleft.lonDec > ch.getPos().lonDec)
+							topleft.lonDec = ch.getPos().lonDec;
+						if (bottomright.latDec > ch.getPos().latDec)
+							bottomright.latDec = ch.getPos().latDec;
+						if (bottomright.lonDec < ch.getPos().lonDec)
+							bottomright.lonDec = ch.getPos().lonDec;
 						numCachesInArea++;
 					}
 				}
@@ -600,35 +622,38 @@
 		}
 		if (topleft != null && bottomright != null)
 			return new Area(topleft, bottomright);
-		else return null;
+		else
+			return null;
 	}
 
 	/**
-	 *	Method to calculate bearing and distance of a cache in the index
-	 *	list.
-	 *	@see	CacheHolder
-	 *	@see	Extractor
+	 * Method to calculate bearing and distance of a cache in the index
+	 * list.
+	 * 
+	 * @see CacheHolder
+	 * @see Extractor
 	 */
-	public void updateBearingDistance(){
+	public void updateBearingDistance() {
 		CWPoint centerPoint = new CWPoint(Global.getPref().getCurCentrePt()); // Clone current centre to be sure
 		int anz = cacheDB.size();
 		CacheHolder ch;
 		// Jetzt durch die CacheDaten schleifen
-		while(--anz >= 0){
+		while (--anz >= 0) {
 			ch = cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 			ch.calcDistance(centerPoint);
 		}
 		// The following call is not very clean as it mixes UI with base classes
 		// However, calling it from here allows us to recenter the
 		// radar panel with only one call
-		if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
-	} //updateBearingDistance
+		if (Global.mainTab != null)
+			Global.mainTab.radarP.recenterRadar();
+	} // updateBearingDistance
 
 	/**
 	 * Method to build the reference between addi wpt
 	 * and main cache.
 	 */
-	public void buildReferences(){
+	public void buildReferences() {
 		CacheHolder ch;
 		MyComparer myComparer = new MyComparer();
 
@@ -752,6 +777,7 @@
 	/**
 	 * If <code>true</code> then the cache list will only display the
 	 * caches that are result of a search.
+	 * 
 	 * @return <code>True</code> if list should only display search results
 	 */
 	public boolean showSearchResult() {
@@ -761,10 +787,12 @@
 	/**
 	 * Sets parameter if cache list should only display the caches that are
 	 * results of a search.
-	 * @param showSearchResult <code>True</code>: List should only display search
-	 * results.
+	 * 
+	 * @param showSearchResult
+	 *            <code>True</code>: List should only display search
+	 *            results.
 	 */
-	public void setShowSearchResult(boolean showSearchResult){
+	public void setShowSearchResult(boolean showSearchResult) {
 		this.showSearchResult = showSearchResult;
 	}
 
@@ -787,31 +815,31 @@
 	}
 
 	public String getFilterStatus() {
-    	return currentFilter.getFilterStatus();
-    }
+		return currentFilter.getFilterStatus();
+	}
 
 	public void setFilterStatus(String filterStatus) {
 		this.notifyUnsavedChanges(filterStatus != this.getFilterStatus());
-    	this.currentFilter.setFilterStatus(filterStatus);
-    }
+		this.currentFilter.setFilterStatus(filterStatus);
+	}
 
 	public boolean getFilterUseRegexp() {
-    	return currentFilter.useRegexp();
-    }
+		return currentFilter.useRegexp();
+	}
 
 	public void setFilterUseRegexp(boolean useRegexp) {
 		this.notifyUnsavedChanges(useRegexp != this.getFilterUseRegexp());
-    	this.currentFilter.setUseRegexp(useRegexp);
-    }
+		this.currentFilter.setUseRegexp(useRegexp);
+	}
 
 	public boolean getFilterNoCoord() {
-    	return currentFilter.getFilterNoCoord();
-    }
+		return currentFilter.getFilterNoCoord();
+	}
 
 	public void setFilterNoCoord(boolean filterNoCoord) {
 		this.notifyUnsavedChanges(filterNoCoord != this.getFilterNoCoord());
-    	this.currentFilter.setFilterNoCoord(filterNoCoord);
-    }
+		this.currentFilter.setFilterNoCoord(filterNoCoord);
+	}
 
 	public String getLast_sync_opencaching() {
 		return last_sync_opencaching;
@@ -854,7 +882,8 @@
 	public int getGpxId() {
 		return Convert.toInt(gpxId);
 	}
-//
+
+	//
 	public void setMinDistGC(String minDistGC) {
 		this.notifyUnsavedChanges(!minDistGC.equals(this.minDistGC));
 		this.minDistGC = minDistGC;
@@ -893,23 +922,24 @@
 		this.notifyUnsavedChanges(!rCMPath.equals(this.relativeCustomMapsPath));
 		this.relativeCustomMapsPath = rCMPath;
 	}
+
 	/**
 	 * Returns the currently active FilterData object for the profile.
+	 * 
 	 * @return Object representing the setting of the filter
 	 */
 	public FilterData getCurrentFilter() {
-    	return currentFilter;
-    }
+		return currentFilter;
+	}
 
 	public void setCurrentFilter(FilterData currentFilter) {
-    	this.currentFilter = currentFilter;
-    }
+		this.currentFilter = currentFilter;
+	}
 
 	private class MyComparer implements ewe.util.Comparer {
 
 		public int compare(Object o1, Object o2) {
-			return ((CacheHolder) o1).getWayPoint().compareTo(
-			        ((CacheHolder) o2).getWayPoint());
+			return ((CacheHolder) o1).getWayPoint().compareTo(((CacheHolder) o2).getWayPoint());
 		}
 
 	}

Modified: branches/r1.2/src/CacheWolf/RadarPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/RadarPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/RadarPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Font;
@@ -40,16 +41,16 @@
 import ewe.ui.mButton;
 
 /**
-*	The radar panel. Displays the caches around a centre point.<br>
-*	Handles scaling as well as toggling the different views in the radar panel.<br>
-*	Also handles clicking on a cache.<br>
-*	Class ID=500
-*/
-public class RadarPanel extends CellPanel{
+ * The radar panel. Displays the caches around a centre point.<br>
+ * Handles scaling as well as toggling the different views in the radar panel.<br>
+ * Also handles clicking on a cache.<br>
+ * Class ID=500
+ */
+public class RadarPanel extends CellPanel {
 	mButton btMinus = new mButton("   -   ");
 	mButton btToggle = new mButton("Toggle");
 	mButton btPlus = new mButton("   +   ");
-	int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
+	int toggleMod = 0; // 0 = cacheicons, 1= cacheWP, 2 = cacheNames
 	Preferences pref;
 	CacheDB cacheDB;
 	myInteractivePanel iActP;
@@ -60,54 +61,55 @@
 	CacheHolder selectedWaypoint = null;
 	MainTab mt;
 	boolean penMoving = false;
-	int x1,y1,x2,y2 = 0;
-	boolean reCenterImage=true;
+	int x1, y1, x2, y2 = 0;
+	boolean reCenterImage = true;
+
 	/**
-	* Constructor for the radar panel.
-	* Loads images, sets up the interactive panel and
-	* "navigation" buttons.
-	*/
-	public RadarPanel(){
+	 * Constructor for the radar panel.
+	 * Loads images, sets up the interactive panel and
+	 * "navigation" buttons.
+	 */
+	public RadarPanel() {
 		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		CellPanel cp = new CellPanel();
-		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
-		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
-		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
+		final CellPanel cp = new CellPanel();
+		cp.addNext(btMinus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.WEST));
+		cp.addNext(btToggle, CellConstants.HSTRETCH, CellConstants.FILL);
+		cp.addLast(btPlus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.EAST));
 		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
 	}
-	
-	public void setMainTab(MainTab tb){
+
+	public void setMainTab(MainTab tb) {
 		mt = tb;
 		iActP.setMainTab(tb);
 	}
-	
+
 	/**
-	* Informs the radar panel on preferences and currently loaded cache
-	* database. It also calculates the maximum size available for drawing 
-	* the radar.
-	*/
-	public void setParam(Preferences p, CacheDB db, CacheHolder sWp){
+	 * Informs the radar panel on preferences and currently loaded cache
+	 * database. It also calculates the maximum size available for drawing
+	 * the radar.
+	 */
+	public void setParam(Preferences p, CacheDB db, CacheHolder sWp) {
 		selectedWaypoint = sWp;
 		pref = p;
 		cacheDB = db;
-		height = (pref.myAppHeight)*6/5; // add 10% each at top/bottom 
-		width = (pref.myAppWidth)*6/5;
+		height = (pref.myAppHeight) * 6 / 5; // add 10% each at top/bottom
+		width = (pref.myAppWidth) * 6 / 5;
 	}
-	
+
 	// Call this after the centre has changed to re-center the radar panel
 	public void recenterRadar() {
-		reCenterImage=true;
+		reCenterImage = true;
 	}
-	
+
 	/**
-	* Public method to draw the different caches and the
-	* radar background
-	*/
-	public void drawThePanel(){
+	 * Public method to draw the different caches and the
+	 * radar background
+	 */
+	public void drawThePanel() {
 		// If there are any images remove them!
-		int anz = iActP.images.size();
-		for(int i = 0; i<anz;i++){
-			iActP.removeImage((AniImage)iActP.images.get(0));
+		final int anz = iActP.images.size();
+		for (int i = 0; i < anz; i++) {
+			iActP.removeImage((AniImage) iActP.images.get(0));
 		}
 		iActP.refresh();
 		drawBackground();
@@ -116,157 +118,163 @@
 		if (reCenterImage) {
 			// Hack to scroll to left origin for a defined position for subsequent
 			// scroll which centers the image
-			iActP.scroll(-1000,-1000); 
-			Dimension dispSize=getDisplayedSize(null);
-			iActP.scroll((width-dispSize.width)/2,(height-dispSize.height+btMinus.getSize(null).height)/2);
-			reCenterImage=false;
+			iActP.scroll(-1000, -1000);
+			final Dimension dispSize = getDisplayedSize(null);
+			iActP.scroll((width - dispSize.width) / 2, (height - dispSize.height + btMinus.getSize(null).height) / 2);
+			reCenterImage = false;
 		}
 	}
-	
+
 	/**
-	* Private method to draw the caches.
-	*/
-	private void drawCaches(){
-		Font radarFont = new Font("Gui", Font.BOLD,Global.getPref().fontSize);
-		FontMetrics fm = getFontMetrics(radarFont);
+	 * Private method to draw the caches.
+	 */
+	private void drawCaches() {
+		final Font radarFont = new Font("Gui", Font.BOLD, Global.getPref().fontSize);
+		final FontMetrics fm = getFontMetrics(radarFont);
 		AniImage aImg;
 		RadarPanelImage rpi;
-		int drX,drY = 0;
+		int drX, drY = 0;
 		CacheHolder holder;
 		double degrees;
-		double pi180=java.lang.Math.PI / 180.0;
-		for(int i = cacheDB.size()-1; i >=0 ; i--){
+		final double pi180 = java.lang.Math.PI / 180.0;
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			holder = cacheDB.get(i);
-			if(holder.isVisible() && holder.pos.isValid()) {
+			if (holder.isVisible() && holder.getPos().isValid()) {
 				degrees = holder.degrees * pi180;
-				drX =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
-				drY = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
-				if(centerX+drX>=0 && centerY+drY>=0 && centerX+drX<=width && centerY+drY <= height){
-					if (toggleMod>0) {
+				drX = new Float(holder.kilom / scale * java.lang.Math.sin(degrees)).intValue();
+				drY = -new Float(holder.kilom / scale * java.lang.Math.cos(degrees)).intValue();
+				if (centerX + drX >= 0 && centerY + drY >= 0 && centerX + drX <= width && centerY + drY <= height) {
+					if (toggleMod > 0) {
 						String s;
-						if (toggleMod==1)
-							s=holder.getWayPoint();
+						if (toggleMod == 1)
+							s = holder.getWayPoint();
 						else
-							s=holder.getCacheName();
-						if (s.length()>0) { 
+							s = holder.getCacheName();
+						if (s.length() > 0) {
 							int tw;
-							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
-							Graphics g = new Graphics(img);
+							final Image img = new Image(tw = fm.getTextWidth(s), fm.getHeight());
+							final Graphics g = new Graphics(img);
 							g.setFont(radarFont);
 							g.setColor(Color.Black);
-							g.fillRect(0,0,tw, fm.getHeight());
+							g.fillRect(0, 0, tw, fm.getHeight());
 							g.setColor(Color.White);
-							g.drawText(s, 0,0);
+							g.drawText(s, 0, 0);
 							aImg = new AniImage(img);
-							aImg.setLocation(centerX+drX+5,centerY+drY);
+							aImg.setLocation(centerX + drX + 5, centerY + drY);
 							aImg.transparentColor = Color.Black;
 							aImg.properties = mImage.IsNotHot;
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=GuiImageBroker.getTypeImage(holder.getType(),true);
-					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=GuiImageBroker.getTypeImage(CacheType.CW_TYPE_UNKNOWN,true); 
+					Image imgCache = CacheType.getMapImage(holder);
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;
-					int dx = imgCache.getWidth();
-					int dy = imgCache.getHeight();
-					rpi.setLocation(centerX+drX-dx/2,centerY+drY-dy/2);
+					final int dx = imgCache.getWidth();
+					final int dy = imgCache.getHeight();
+					rpi.setLocation(centerX + drX - dx / 2, centerY + drY - dy / 2);
 					iActP.addImage(rpi);
-					if(holder == selectedWaypoint){ // Draw red circle around selected wpt
-						int diag = (int) (java.lang.Math.sqrt(dx*dx+dy*dy)+0.5);
-						Image imgCircle = new Image(diag, diag);
-						Graphics gCircle = new Graphics(imgCircle);
+					if (holder == selectedWaypoint) { // Draw red circle around selected wpt
+						final int diag = (int) (java.lang.Math.sqrt(dx * dx + dy * dy) + 0.5);
+						final Image imgCircle = new Image(diag, diag);
+						final Graphics gCircle = new Graphics(imgCircle);
 						gCircle.setColor(Color.Black);
-						gCircle.fillRect(0,0,diag,diag);
-						gCircle.setColor(new Color(255,0,0));
-						gCircle.drawEllipse(0,0, diag,diag);
+						gCircle.fillRect(0, 0, diag, diag);
+						gCircle.setColor(new Color(255, 0, 0));
+						gCircle.drawEllipse(0, 0, diag, diag);
 						aImg = new AniImage(imgCircle);
-						aImg.setLocation(centerX+drX-diag/2,centerY+drY-diag/2);
-						aImg.transparentColor = new Color(0,0,0);
+						aImg.setLocation(centerX + drX - diag / 2, centerY + drY - diag / 2);
+						aImg.transparentColor = new Color(0, 0, 0);
 						aImg.properties = mImage.IsNotHot;
 						iActP.addImage(aImg);
 					}
-				}//if center...
+				}// if center...
 			}// if is_black...
 		}
 	}
-	
+
 	/**
-	* Private method to draw the black background and green radar.
-	* Also calculates some other parameters.
-	* Always call this before calling drawCaches().
-	*/
-	private void drawBackground(){
-		Rect r = new Rect(new Dimension(width, height));
+	 * Private method to draw the black background and green radar.
+	 * Also calculates some other parameters.
+	 * Always call this before calling drawCaches().
+	 */
+	private void drawBackground() {
+		final Rect r = new Rect(new Dimension(width, height));
 		iActP.virtualSize = r;
 		iActP.refresh();
-		Image img = new Image(width, height);
-		Graphics g = new Graphics(img);
+		final Image img = new Image(width, height);
+		final Graphics g = new Graphics(img);
 		g.setColor(Color.Black);
-		g.fillRect(0,0,width, height);
-		
-		
-		if(width < height) {
-			scale = (double)scaleKm / (double)height;
+		g.fillRect(0, 0, width, height);
+
+		if (width < height) {
+			scale = (double) scaleKm / (double) height;
 		} else {
-			scale = (double)scaleKm / (double)width;
+			scale = (double) scaleKm / (double) width;
 		}
 		centerX = (width / 2);
 		centerY = (height / 2);
-		//centerY = (int)(centerY-centerY*0.15);
-		g.setColor(new Color(0,255,0));
-		int radstep= 0, steps=0, radius = 0;
-		
-		if(width > height){
-			radstep = (int)(10 / scale);
+		// centerY = (int)(centerY-centerY*0.15);
+		g.setColor(new Color(0, 255, 0));
+		int radstep = 0, steps = 0, radius = 0;
+
+		if (width > height) {
+			radstep = (int) (10 / scale);
 			steps = (width / radstep);
-		}else{
-			radstep = (int)(10 / scale);
+		} else {
+			radstep = (int) (10 / scale);
 			steps = (height / radstep);
 		}
-		for(int i = 1; i <= steps; i++){
-			radius = (radstep * i)*2;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		for (int i = 1; i <= steps; i++) {
+			radius = (radstep * i) * 2;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 		}
-		g.drawLine(centerX,0,centerX,height);
-		g.drawLine(0,centerY,width,centerY);
+		g.drawLine(centerX, 0, centerX, height);
+		g.drawLine(0, centerY, width, centerY);
 
 		// Show 1 KM radius only if we have zoomed in (useful for cities with high density of caches)
-		if (scaleKm<=20) {
-			g.setColor(new Color(255,255,0)); // Yellow for 1km circle
-			radius = radstep/5;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		if (scaleKm <= 20) {
+			g.setColor(new Color(255, 255, 0)); // Yellow for 1km circle
+			radius = radstep / 5;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 			g.free();
-		}	
-		AniImage aImg = new AniImage(img);
-		//iActP.addImage(aImg);
+		}
+		final AniImage aImg = new AniImage(img);
+		// iActP.addImage(aImg);
 		iActP.backgroundImage = img;
-		int xPos = (pref.myAppWidth/2 - width/2);
-		aImg.setLocation(xPos,0);
+		final int xPos = (pref.myAppWidth / 2 - width / 2);
+		aImg.setLocation(xPos, 0);
 		aImg.refresh();
 	}
-	
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == btPlus){
-				if (scaleKm>10) scaleKm = scaleKm - 10;
-				else if (scaleKm==10) scaleKm=5;
-				else if (scaleKm==5) scaleKm=2;
-				else scaleKm=1;
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == btPlus) {
+				if (scaleKm > 10)
+					scaleKm = scaleKm - 10;
+				else if (scaleKm == 10)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 2;
+				else
+					scaleKm = 1;
 				drawThePanel();
 			}
-			if (ev.target == btMinus){
-				if (scaleKm==1) scaleKm=2;
-				else if(scaleKm==2) scaleKm=5;
-				else if(scaleKm==5) scaleKm=10;
-				else scaleKm = scaleKm + 10;
+			if (ev.target == btMinus) {
+				if (scaleKm == 1)
+					scaleKm = 2;
+				else if (scaleKm == 2)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 10;
+				else
+					scaleKm = scaleKm + 10;
 				drawThePanel();
 			}
-			if (ev.target == btToggle){
+			if (ev.target == btToggle) {
 				toggleMod++;
-				if(toggleMod > 2) toggleMod = 0;
+				if (toggleMod > 2)
+					toggleMod = 0;
 				drawThePanel();
 			}
 		}

Modified: branches/r1.2/src/CacheWolf/SafeXML.java
===================================================================
--- branches/r1.2/src/CacheWolf/SafeXML.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/SafeXML.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,155 +1,59 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
-*	A class to replace unsafe XML characters with characters that a user
-*	"can read", and vice versa
-* 20061222: skg Modified cleanback to speed up the new index.xml reader
-*/
+ *	A class to replace unsafe XML characters with characters that a user
+ *	"can read", and vice versa
+ * 20061222: skg Modified cleanback to speed up the new index.xml reader
+ */
 
 import ewe.util.Hashtable;
 
-public final class SafeXML{
+public final class SafeXML {
 	private static final char ENTITY_START = '&';
 	private static final char ENTITY_END = ';';
-	
+
 	private final static Hashtable iso2htmlMappings = new Hashtable(300);
 	static {
 		final String[] mappingArray = new String[] {
-				"&apos;",   "'",		// Added 20061227 - not a valid HTML entity but used in XML
-				"&quot;",   "\"",
-				"&amp;",    "&",
-				"&lt;",     "<",
-				"&gt;",     ">",
-				"&nbsp;",   " ",
-				"&iexcl;",  "?",
-				"&cent;",   "?",
-				"&pound;",  "?",
-				"&curren;", "?",
-				"&yen;",    "?",
-				"&brvbar;", "?",
-				"&sect;",   "?",
-				"&uml;",    "?",
-				"&copy;",   "?",
-				"&ordf;",   "?",
-				"&laquo;",  "?",
-				"&not;",    "?",
-				"&shy;",    "?",
-				"&reg;",    "?",
-				"&macr;",   "?",
-				"&deg;",    "?",
-				"&plusmn;", "?",
-				"&sup2;",   "?",
-				"&sup3;",   "?",
-				"&acute;",  "?",
-				"&micro;",  "?",
-				"&para;",   "?",
-				"&middot;", "?",
-				"&cedil;",  "?",
-				"&sup1;",   "?",
-				"&ordm;",   "?",
-				"&raquo;",  "?",
-				"&frac14;", "?",
-				"&frac12;", "?",
-				"&frac34;", "?",
-				"&iquest;", "?",
-				"&Agrave;", "?",
-				"&Aacute;", "?",
-				"&Acirc;",  "?",
-				"&Atilde;", "?",
-				"&Auml;",   "?",
-				"&Aring;",  "?",
-				"&AElig;",  "?",
-				"&Ccedil;", "?",
-				"&Egrave;", "?",
-				"&Eacute;", "?",
-				"&Ecirc;",  "?",
-				"&Euml;",   "?",
-				"&Igrave;", "?",
-				"&Iacute;", "?",
-				"&Icirc;",  "?",
-				"&Iuml;",   "?",
-				"&ETH;",    "?",
-				"&Ntilde;", "?",
-				"&Ograve;", "?",
-				"&Oacute;", "?",
-				"&Ocirc;",  "?",
-				"&Otilde;", "?",
-				"&Ouml;",   "?",
-				"&times;",  "?",
-				"&Oslash;", "?",
-				"&Ugrave;", "?",
-				"&Uacute;", "?",
-				"&Ucirc;",  "?",
-				"&Uuml;",   "?",
-				"&Yacute;", "?",
-				"&THORN;",  "?",
-				"&szlig;",  "?",
-				"&agrave;", "?",
-				"&aacute;", "?",
-				"&acirc;",  "?",
-				"&atilde;", "?",
-				"&auml;",   "?",
-				"&aring;",  "?",
-				"&aelig;",  "?",
-				"&ccedil;", "?",
-				"&egrave;", "?",
-				"&eacute;", "?",
-				"&ecirc;",  "?",
-				"&euml;",   "?",
-				"&igrave;", "?",
-				"&iacute;", "?",
-				"&icirc;",  "?",
-				"&iuml;",   "?",
-				"&eth;",    "?",
-				"&ntilde;", "?",
-				"&ograve;", "?",
-				"&oacute;", "?",
-				"&ocirc;",  "?",
-				"&otilde;", "?",
-				"&ouml;",   "?",
-				"&divide;", "?",
-				"&oslash;", "?",
-				"&ugrave;", "?",
-				"&uacute;", "?",
-				"&ucirc;",  "?",
-				"&uuml;",   "?",
-				"&yacute;", "?",
-				"&thorn;",  "?",
-				"&yuml;",   "?",
-				"&ndash;",  "?"
-				};
+				"&apos;",
+				"'", // Added 20061227 - not a valid HTML entity but used in XML
+				"&quot;", "\"", "&amp;", "&", "&lt;", "<", "&gt;", ">", "&nbsp;", " ", "&iexcl;", "?", "&cent;", "?", "&pound;", "?", "&curren;", "?", "&yen;", "?", "&brvbar;", "?", "&sect;", "?", "&uml;", "?", "&copy;", "?", "&ordf;", "?", "&laquo;",
+				"?", "&not;", "?", "&shy;", "?", "&reg;", "?", "&macr;", "?", "&deg;", "?", "&plusmn;", "?", "&sup2;", "?", "&sup3;", "?", "&acute;", "?", "&micro;", "?", "&para;", "?", "&middot;", "?", "&cedil;", "?", "&sup1;", "?", "&ordm;", "?",
+				"&raquo;", "?", "&frac14;", "?", "&frac12;", "?", "&frac34;", "?", "&iquest;", "?", "&Agrave;", "?", "&Aacute;", "?", "&Acirc;", "?", "&Atilde;", "?", "&Auml;", "?", "&Aring;", "?", "&AElig;", "?", "&Ccedil;", "?", "&Egrave;", "?",
+				"&Eacute;", "?", "&Ecirc;", "?", "&Euml;", "?", "&Igrave;", "?", "&Iacute;", "?", "&Icirc;", "?", "&Iuml;", "?", "&ETH;", "?", "&Ntilde;", "?", "&Ograve;", "?", "&Oacute;", "?", "&Ocirc;", "?", "&Otilde;", "?", "&Ouml;", "?", "&times;",
+				"?", "&Oslash;", "?", "&Ugrave;", "?", "&Uacute;", "?", "&Ucirc;", "?", "&Uuml;", "?", "&Yacute;", "?", "&THORN;", "?", "&szlig;", "?", "&agrave;", "?", "&aacute;", "?", "&acirc;", "?", "&atilde;", "?", "&auml;", "?", "&aring;", "?",
+				"&aelig;", "?", "&ccedil;", "?", "&egrave;", "?", "&eacute;", "?", "&ecirc;", "?", "&euml;", "?", "&igrave;", "?", "&iacute;", "?", "&icirc;", "?", "&iuml;", "?", "&eth;", "?", "&ntilde;", "?", "&ograve;", "?", "&oacute;", "?",
+				"&ocirc;", "?", "&otilde;", "?", "&ouml;", "?", "&divide;", "?", "&oslash;", "?", "&ugrave;", "?", "&uacute;", "?", "&ucirc;", "?", "&uuml;", "?", "&yacute;", "?", "&thorn;", "?", "&yuml;", "?", "&ndash;", "?" };
 		for (int i = 0; i < mappingArray.length; i = i + 2) {
-			iso2htmlMappings.put( mappingArray[i], mappingArray[i+1]);
+			iso2htmlMappings.put(mappingArray[i], mappingArray[i + 1]);
 		}
 	}
-		
-	
-	
+
 	/**
 	 * Converts a <code>String</code> containing HTML entities to
 	 * a <code>String</code> containing only ISO8859-1 characters.
@@ -158,47 +62,48 @@
 	 * 8859-1 table by Martin Ramsch</a>.
 	 * 
 	 * @author <a href="mailto:ey at inweb.de">Christian Ey</a>
-	 *
+	 * 
 	 * @version 1.0
-	 * @param htmlString The <code>String</code> containing HTML
-	 * 	entities
+	 * @param htmlString
+	 *            The <code>String</code> containing HTML
+	 *            entities
 	 * @return A <code>String</code> containing only ISO8859-1
-	 * 	characters
+	 *         characters
 	 */
-	public final static String cleanback( String htmlString) {
+	public final static String cleanback(String htmlString) {
 		int indexStart;
 		// return immediately if string is null or does not contain &
-		if (htmlString != null && (indexStart = htmlString.indexOf( ENTITY_START))>=0) {
+		if (htmlString != null && (indexStart = htmlString.indexOf(ENTITY_START)) >= 0) {
 			// copy everything from the beginning to entity start into buffer
-			StringBuffer isoBuffer = new StringBuffer( htmlString.substring( 0, indexStart));
+			StringBuffer isoBuffer = new StringBuffer(htmlString.substring(0, indexStart));
 			while (indexStart >= 0) {
-				int indexEnd = htmlString.indexOf( ENTITY_END, indexStart + 1);
+				int indexEnd = htmlString.indexOf(ENTITY_END, indexStart + 1);
 				if (indexEnd >= 0) {
-					int alternativeStart = htmlString.indexOf( ENTITY_START, indexStart + 1);
+					int alternativeStart = htmlString.indexOf(ENTITY_START, indexStart + 1);
 					if ((alternativeStart > indexStart) && (alternativeStart < indexEnd)) {
 						// a second index start is found inbetween current index start
 						// and index end
-						
+
 						// flush the html string inbetween
-						isoBuffer.append( htmlString.substring( indexStart, alternativeStart));
-						
+						isoBuffer.append(htmlString.substring(indexStart, alternativeStart));
+
 						// use the second index start and loop again
 						indexStart = alternativeStart;
 					} else {
-						String entity = htmlString.substring( indexStart, indexEnd + 1);
-						appendEntityAsIsoChar(entity, isoBuffer); 
-						indexStart = htmlString.indexOf( ENTITY_START, indexEnd + 1);
+						String entity = htmlString.substring(indexStart, indexEnd + 1);
+						appendEntityAsIsoChar(entity, isoBuffer);
+						indexStart = htmlString.indexOf(ENTITY_START, indexEnd + 1);
 						if (indexStart >= 0) {
 							// another entity start detected, flush the html string inbetween
-							isoBuffer.append( htmlString.substring( indexEnd + 1, indexStart));
+							isoBuffer.append(htmlString.substring(indexEnd + 1, indexStart));
 						} else {
 							// no further entity start detected, flush rest of html string
-							isoBuffer.append( htmlString.substring( indexEnd + 1));
+							isoBuffer.append(htmlString.substring(indexEnd + 1));
 						}
 					}
 				} else {
 					// entity start without matching entity end detected, ignore gracefully
-					isoBuffer.append( htmlString.substring( indexStart));
+					isoBuffer.append(htmlString.substring(indexStart));
 					break;
 				}
 			}
@@ -211,17 +116,18 @@
 
 	private final static void appendEntityAsIsoChar(String entity, StringBuffer addto) {
 		if (entity.startsWith("&#")) {
-			try{
-				if (entity.charAt(2)== 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
-					addto.append((char)Integer.parseInt(entity.substring(3, entity.length()-1), 16)); 
-				else // number is decimal
-					addto.append((char)Integer.parseInt(entity.substring(2, entity.length()-1)));
+			try {
+				if (entity.charAt(2) == 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
+					addto.append((char) Integer.parseInt(entity.substring(3, entity.length() - 1), 16));
+				else
+					// number is decimal
+					addto.append((char) Integer.parseInt(entity.substring(2, entity.length() - 1)));
 			} catch (NumberFormatException e) {
 				addto.append(entity); // not a valid number, insert original text
 			}
 
 		} // number format exception
-		else { // entity with a name like "&quot"						
+		else { // entity with a name like "&quot"
 			String isoCharacter = (String) iso2htmlMappings.get(entity);
 			if (isoCharacter != null) {
 				// insert iso character instead of html entity
@@ -232,127 +138,136 @@
 			}
 		}
 	}
-	
+
 	/**
-     * convert a single char to its equivalent HTML entity. Ordinary chars are
-     * not changed. 160 -> &nbsp;
-     *
-     * @param c Char to convert
-     *
-     * @return equivalent string eg. &amp;, null means leave char as is.
-     */
-    private final static String charToEntity( char c )
-        {
-        switch ( c ) {
-	        case '"' : return "&quot;";
-	        case '&' : return "&amp;";
-	        case '<' : return "&lt;";
-	        case '>' : return "&gt;";
-	        case '\'': return "&apos;";
-            default :
-                if ( c < 127 ) {
-                    // leave alone as equivalent string.
-                    return null;
-                    // faster than String.valueOf( c ).intern();
-                } else {
-                    // use the &#nnn; form
-                    return "&#" + Integer.toString( c ) + ";";
-                }
-            } // end switch
-        } // end charToEntity
+	 * convert a single char to its equivalent HTML entity. Ordinary chars are
+	 * not changed. 160 -> &nbsp;
+	 * 
+	 * @param c
+	 *            Char to convert
+	 * 
+	 * @return equivalent string eg. &amp;, null means leave char as is.
+	 */
+	private final static String charToEntity(char c) {
+		switch (c) {
+		case '"':
+			return "&quot;";
+		case '&':
+			return "&amp;";
+		case '<':
+			return "&lt;";
+		case '>':
+			return "&gt;";
+		case '\'':
+			return "&apos;";
+		default:
+			if (c < 127) {
+				// leave alone as equivalent string.
+				return null;
+				// faster than String.valueOf( c ).intern();
+			} else {
+				// use the &#nnn; form
+				return "&#" + Integer.toString(c) + ";";
+			}
+		} // end switch
+	} // end charToEntity
 
-    /**
-     * Converts text to HTML by quoting dangerous characters. Text must not
-     * already contain entities. e.g. " ==> &quot; < ==> &lt; ordinary text
-     * passes unchanged. Does not convert space to &nbsp;
-     *
-     * @param text raw text to be processed. Must not be null.
-     *
-     * @return translated text, or null if input is null.
-     */
-    public final static String clean( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( originalTextLength * 110 / 100 );
-        int charsToAppend = 0;
-        for ( int i = 0; i < originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = charToEntity( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
+	/**
+	 * Converts text to HTML by quoting dangerous characters. Text must not
+	 * already contain entities. e.g. " ==> &quot; < ==> &lt; ordinary text
+	 * passes unchanged. Does not convert space to &nbsp;
+	 * 
+	 * @param text
+	 *            raw text to be processed. Must not be null.
+	 * 
+	 * @return translated text, or null if input is null.
+	 */
+	public final static String clean(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(originalTextLength * 110 / 100);
+		int charsToAppend = 0;
+		for (int i = 0; i < originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = charToEntity(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
 
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
-	
-	
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
 	/**
 	 * Converts a data string to something that is safe to use inside
 	 * an XML file (like prefs.xml) - entities like &amp; are *NOT*
 	 * valid XML unless declared specially, so we must use the numerical
 	 * values here.
-	 *
-	 * @param src (String) raw text to be processed
-	 *
+	 * 
+	 * @param src
+	 *            (String) raw text to be processed
+	 * 
 	 * @return (String) translated text, or null if input is null
 	 */
-	public final static String cleanGPX(String str){
-		String dummy = STRreplace.replace(str, "&","&amp;");
-		//"&amp;#" --> "&#"); //Darstellung Umlaute etc : siehe  http://www.geoclub.de/viewtopic.php?f=40&t=50635&p=798796#p798796
+	public final static String cleanGPX(String str) {
+		String dummy = STRreplace.replace(str, "&", "&amp;");
+		// "&amp;#" --> "&#"); //Darstellung Umlaute etc : siehe http://www.geoclub.de/viewtopic.php?f=40&t=50635&p=798796#p798796
 		// aber so etwas nicht "&amp;#entry15063" --> !!not!! "&#entry15063" (Cache GCPB5P export -> gpx, import -> mapsource)
-		int pos=0;
-		while (pos>-1) {
-			pos=dummy.indexOf("&amp;#",pos);
-			int pos1=dummy.indexOf(";",pos+6);
-			int k = pos1-pos; // wann kommt das ; als Ende eines numerischen entities?
-			if (pos>-1) {
-				if ( k < 12) {
-					String s = dummy.substring(pos+6,pos+8).toLowerCase();
-					char c=s.charAt(0);
-					char c1=s.charAt(1);
-					if ((c=='x' && ((c1>='0' && c1<='9') || (c1>='a' && c1<='f'))) || (c>='0' && c<='9')) {
-						dummy=dummy.substring(0, pos+1) + dummy.substring(pos+5, dummy.length());
+		int pos = 0;
+		while (pos > -1) {
+			pos = dummy.indexOf("&amp;#", pos);
+			int pos1 = dummy.indexOf(";", pos + 6);
+			int k = pos1 - pos; // wann kommt das ; als Ende eines numerischen entities?
+			if (pos > -1) {
+				if (pos1 > -1) {
+					if (k < 12) {
+						String s = dummy.substring(pos + 6, pos + 8).toLowerCase();
+						char c = s.charAt(0);
+						char c1 = s.charAt(1);
+						if ((c == 'x' && ((c1 >= '0' && c1 <= '9') || (c1 >= 'a' && c1 <= 'f'))) || (c >= '0' && c <= '9')) {
+							dummy = dummy.substring(0, pos + 1) + dummy.substring(pos + 5, dummy.length());
+						}
 					}
 				}
 				pos++;
 			}
 		}
-		dummy = STRreplace.replace(dummy, "&amp;amp;","&amp;"); //falls schon &amp; im str war 
-			
+		dummy = STRreplace.replace(dummy, "&amp;amp;", "&amp;"); // falls schon &amp; im str war
+
 		dummy = STRreplace.replace(dummy, "<", "&lt;");
 		dummy = STRreplace.replace(dummy, ">", "&gt;");
 		dummy = STRreplace.replace(dummy, "\"", "&quot;");
-		dummy = STRreplace.replace(dummy, "'","&apos;");
+		dummy = STRreplace.replace(dummy, "'", "&apos;");
 		// why
-		dummy = STRreplace.replace(dummy, "\u0004","");
-		// this means changing content, 
+		dummy = STRreplace.replace(dummy, "\u0004", "");
+		// this means changing content,
 		// but it is the easiest way of avoiding ]]> to be interpreted as endmark of CDATA-section
-		dummy = STRreplace.replace(dummy, "]]>","]] >");
+		dummy = STRreplace.replace(dummy, "]]>", "]] >");
 		// \ in gpx is not imported by mapsource, basecamp, garmin?...(there is no replacement)
-		dummy = STRreplace.replace(dummy, "\\","BkSlsh;");
+		dummy = STRreplace.replace(dummy, "\\", "BkSlsh;");
 
 		return dummy;
 	}
+
 	public final static String strxmlencode(boolean src) {
 		/* bools are always safe */
 		return (src ? "true" : "false");
 	}
+
 	public final static String strxmlencode(int src) {
 		/* numbers are always safe */
 		return (Integer.toString(src));

Modified: branches/r1.2/src/CacheWolf/Travelbug.java
===================================================================
--- branches/r1.2/src/CacheWolf/Travelbug.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Travelbug.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,59 +1,63 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 /**
  * This contains the basic information of a GC travelbug.
+ * 
  * @author salzkammergut
- *
+ * 
  */
 public class Travelbug {
-	/** GC unique id or guid (both are used depending on how the TB is picked up).
+	/**
+	 * GC unique id or guid (both are used depending on how the TB is picked up).
 	 * Travelbugs retrieved from a cache use the guid, travelbugs entered manually
-	 * use the id */
-	private String guid;       //0
+	 * use the id
+	 */
+	private String guid; // 0
 	/** GC Name i.e. "First Roman Geocoin" */
-	private String name;       //1
+	private String name; // 1
 	/** GC tracking no i.e. 652345, needed for logging */
-	private String trackingNo; //2 
+	private String trackingNo; // 2
 	/** GC Mission */
-	private String mission;    //3
+	private String mission; // 3
 
 	/** Construct a travelbug with a given name */
 	public Travelbug(String name) {
-		this("",name,"");
+		this("", name, "");
 	}
 
 	/** Construct a travelbug with id, name and mission */
 	public Travelbug(String guid, String name, String mission) {
-		setGuid(guid);
-		setName(name);
-		setMission(mission);
+		this.guid = guid;
+		this.name = SafeXML.cleanback(name);
+		this.mission = mission;
 		setTrackingNo("");
 	}
-	
+
 	public String getGuid() {
 		return guid;
 	}
@@ -85,10 +89,10 @@
 	public String getMission() {
 		return this.mission;
 	}
-	
+
 	/** Return XML representation of travelbug for storing in cache.xml */
-	public String toXML(){
-		StringBuffer s=new StringBuffer(300);
+	public String toXML() {
+		StringBuffer s = new StringBuffer(300);
 		s.append("  <tb guid=\"");
 		s.append(guid);
 		s.append("\"><name><![CDATA[");
@@ -98,10 +102,10 @@
 		s.append("]]></tb>\n");
 		return s.toString();
 	}
-	
+
 	/** Return HTML representation of travelbug for display on screen */
-	public String toHtml(){
-		StringBuffer s=new StringBuffer(300);
+	public String toHtml() {
+		StringBuffer s = new StringBuffer(300);
 		s.append("<b>Name:</b> ");
 		s.append(name);
 		s.append("<br>");

Modified: branches/r1.2/src/CacheWolf/TravelbugJourneyList.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugJourneyList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugJourneyList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -40,9 +40,15 @@
 
 public class TravelbugJourneyList extends MinML {
 
-	/** The Vector holdin the travelbug journeys */
+	/** The Vector holding the travelbug journeys */
 	private Vector tbJourneyList=new Vector(10);
 	
+	/**
+	 * Public constructor
+	 */
+	public TravelbugJourneyList() {
+	}
+
 	/** Return a TravelbugJourney */
 	public TravelbugJourney getTBJourney(int i) {
 		return (TravelbugJourney) tbJourneyList.elementAt(i);
@@ -101,9 +107,6 @@
 		return count;
 	}
 	
-	TravelbugJourneyList() { // Public constructor
-	}
-	
 	/**
 	 * Return a list of the travelbugs still in my possession
 	 * @return 

Modified: branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
@@ -78,8 +78,8 @@
 import ewe.ui.mLabel;
 import ewe.ui.mTabbedPanel;
 
-public class TravelbugJourneyScreen extends Form  {
-	
+public class TravelbugJourneyScreen extends Form {
+
 	/** The list control */
 	private tbListControl tcTbJourneyList;
 	/** The list model */
@@ -88,588 +88,612 @@
 	private TravelbugJourneyList tblMyTravelbugJourneys;
 	/** The panel for the lower half of the screen */
 	private CellPanel lowerpane;
-	private mInput inpName,inpTrackingNo, 
-		   inpFromDate, inpFromProfile, inpFromWaypoint, 
-	       inpToDate, inpToProfile, inpToWaypoint;
+	private mInput inpName, inpTrackingNo, inpFromDate, inpFromProfile, inpFromWaypoint, inpToDate, inpToProfile, inpToWaypoint;
 	private mLabel lblId;
-	private mButton btnFromDate,btnToDate;
+	private mButton btnFromDate, btnToDate;
 	private mCheckBox chkFromLogged, chkToLogged;
 	private HtmlDisplay txtMission;
 	private mTabbedPanel pnlTab;
-    /**	 List of TBs in the current cache */
-	private TravelbugList tblSrcCache; 
+	/** List of TBs in the current cache */
+	private TravelbugList tblSrcCache;
 	/** The currently selected row */
-	private int selectedRow=-1;
-	/** A label which holds the number of currently displayed travelbug journeys*/
+	private int selectedRow = -1;
+	/** A label which holds the number of currently displayed travelbug journeys */
 	private mLabel lblNumVisibleJourneys;
-	private final Color RED=new Color(255,0,0);
-	private int exitKeys[]={75009};
-	/** A flag to track whether the current cache has to be saved because a travelbug
+	private final Color RED = new Color(255, 0, 0);
+	private int exitKeys[] = { 75009 };
+	/**
+	 * A flag to track whether the current cache has to be saved because a travelbug
 	 * was added to or taken from it.
 	 */
-	private boolean chDmodified=false;
-	
+	private boolean chDmodified = false;
+
 	/** The current cache */
 	private CacheHolderDetail chD;
 	/** The base data of the current cache */
 	private CacheHolder ch;
 	/** The name of the current waypoint */
-	private String waypoint="";
-	
+	private String waypoint = "";
+
 	public TravelbugJourneyScreen() {
-		CacheDB cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB = Global.getProfile().cacheDB;
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
 		CellPanel tablepane = split.getNextPanel();
-		int curCacheNo=Global.mainTab.tbP.getSelectedCache();
-		String cache="";
-		if (curCacheNo>=0 && curCacheNo<cacheDB.size()) {
-			ch=cacheDB.get(curCacheNo);
-			cache=MyLocale.getMsg(6022,": Current cache: ")+ch.getWayPoint()+" - "+ch.getCacheName();
-			waypoint=ch.getWayPoint();
-			chD=ch.getCacheDetails(true);
-			tblSrcCache=ch.getCacheDetails(true).Travelbugs;
+		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+		String cache = "";
+		if (curCacheNo >= 0 && curCacheNo < cacheDB.size()) {
+			ch = cacheDB.get(curCacheNo);
+			cache = MyLocale.getMsg(6022, ": Current cache: ") + ch.getWayPoint() + " - " + ch.getCacheName();
+			waypoint = ch.getWayPoint();
+			chD = ch.getCacheDetails(true);
+			tblSrcCache = ch.getCacheDetails(true).Travelbugs;
 		}
-		title="Travelbugs"+cache;
-		tcTbJourneyList=new tbListControl();
-		tcTbJourneyList.setTableModel(modTbJourneyList=new tbListTableModel());
-		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList,ScrollablePanel.AlwaysShowVerticalScrollers),STRETCH,FILL);
-	
+		title = "Travelbugs" + cache;
+		tcTbJourneyList = new tbListControl();
+		tcTbJourneyList.setTableModel(modTbJourneyList = new tbListTableModel());
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList, ScrollablePanel.AlwaysShowVerticalScrollers), STRETCH, FILL);
+
 		lowerpane = split.getNextPanel();
-		
-		pnlTab=new mTabbedPanel();
-		pnlTab.extraControlsRight=lblNumVisibleJourneys=new mLabel("  0");
-		//------------------------------------------------
+
+		pnlTab = new mTabbedPanel();
+		pnlTab.extraControlsRight = lblNumVisibleJourneys = new mLabel("  0");
+		// ------------------------------------------------
 		// First Tab - Name & Tracking #
-		//------------------------------------------------
-		CellPanel pnlName=new CellPanel();
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6025,"Name:")),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpName=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6026,"Tracking #:")),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpTrackingNo=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6027,"ID/GUID:")),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(lblId=new mLabel(""),HSTRETCH,HFILL);
-		pnlTab.addCard(pnlName,MyLocale.getMsg(6028,"Name"),"Name");
-		
-		//------------------------------------------------
+		// ------------------------------------------------
+		CellPanel pnlName = new CellPanel();
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6025, "Name:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpName = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6026, "Tracking #:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpTrackingNo = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6027, "ID/GUID:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(lblId = new mLabel(""), HSTRETCH, HFILL);
+		pnlTab.addCard(pnlName, MyLocale.getMsg(6028, "Name"), "Name");
+
+		// ------------------------------------------------
 		// Second Tab - Where was the TB picked up from
-		//------------------------------------------------
-		CellPanel pnlFrom=new CellPanel();
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029,"Profile/Cache:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromProfile=new mInput(),HSTRETCH,HFILL);
-		pnlFrom.addLast(inpFromWaypoint=new mInput(),HSTRETCH,HFILL);
-		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030,"Date found:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		pnlFrom.addLast(btnFromDate=new mButton(new mImage("calendar.png")),DONTSTRETCH,DONTFILL|WEST);
-		btnFromDate.modify(0,ControlConstants.TakesKeyFocus);
-		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031,"Logged:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addLast(chkFromLogged=new mCheckBox(""),DONTSTRETCH,DONTFILL|WEST);
-		chkFromLogged.exitKeys=exitKeys;
+		// ------------------------------------------------
+		CellPanel pnlFrom = new CellPanel();
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromProfile = new mInput(), HSTRETCH, HFILL);
+		pnlFrom.addLast(inpFromWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030, "Date found:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate = new mButton(new mImage("calendar.png")), DONTSTRETCH, DONTFILL | WEST);
+		btnFromDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addLast(chkFromLogged = new mCheckBox(""), DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged.exitKeys = exitKeys;
 		pnlFrom.addLast(new mLabel(""));
-		
-		pnlTab.addCard(pnlFrom,MyLocale.getMsg(6032,"From"),"From");
 
-		//------------------------------------------------
+		pnlTab.addCard(pnlFrom, MyLocale.getMsg(6032, "From"), "From");
+
+		// ------------------------------------------------
 		// Third Tab - Where was the TB dropped
-		//------------------------------------------------
-		CellPanel pnlTo=new CellPanel();
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029,"Profile/Cache:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToProfile=new mInput(),HSTRETCH,HFILL);
-		pnlTo.addLast(inpToWaypoint=new mInput(),HSTRETCH,HFILL);
-		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033,"Date dropped:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//inpToDate.modifyAll(DisplayOnly,0);
-		pnlTo.addLast(btnToDate=new mButton(new mImage("calendar.png")),DONTSTRETCH,DONTFILL|WEST);
-		btnToDate.modify(0,ControlConstants.TakesKeyFocus);
-		//pnlTo.addLast(new mLabel(""));
-		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031,"Logged:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addLast(chkToLogged=new mCheckBox(""),DONTSTRETCH,DONTFILL|WEST);
-		chkToLogged.exitKeys=exitKeys;
+		// ------------------------------------------------
+		CellPanel pnlTo = new CellPanel();
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToProfile = new mInput(), HSTRETCH, HFILL);
+		pnlTo.addLast(inpToWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033, "Date dropped:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpToDate.modifyAll(DisplayOnly,0);
+		pnlTo.addLast(btnToDate = new mButton(new mImage("calendar.png")), DONTSTRETCH, DONTFILL | WEST);
+		btnToDate.modify(0, ControlConstants.TakesKeyFocus);
+		// pnlTo.addLast(new mLabel(""));
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addLast(chkToLogged = new mCheckBox(""), DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged.exitKeys = exitKeys;
 		pnlTo.addLast(new mLabel(""));
-		
-		pnlTab.addCard(pnlTo,MyLocale.getMsg(6034,"To"),"To");
-		
-		//------------------------------------------------
+
+		pnlTab.addCard(pnlTo, MyLocale.getMsg(6034, "To"), "To");
+
+		// ------------------------------------------------
 		// Last Panel - TB Mission
-		//------------------------------------------------
-		CellPanel pnlDest=new CellPanel();
-		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035,"Mission:")));
-		pnlDest.addLast(txtMission=new HtmlDisplay(),STRETCH,FILL);
-		txtMission.rows=3;
-		pnlTab.addCard(pnlDest,MyLocale.getMsg(6036,"Mission"),"Mission");
+		// ------------------------------------------------
+		CellPanel pnlDest = new CellPanel();
+		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035, "Mission:")));
+		pnlDest.addLast(txtMission = new HtmlDisplay(), STRETCH, FILL);
+		txtMission.rows = 3;
+		pnlTab.addCard(pnlDest, MyLocale.getMsg(6036, "Mission"), "Mission");
 
-		
-		lowerpane.addLast(pnlTab,STRETCH,FILL);
-		
-		
-		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
-		addLast(split,STRETCH,FILL);
-		//setPreferredSize(MyLocale.getScreenWidth()<=240?240:MyLocale.getScreenWidth()*2/3,240);
-		
-		tblMyTravelbugJourneys=new TravelbugJourneyList();
+		lowerpane.addLast(pnlTab, STRETCH, FILL);
+
+		split.setSplitter(PanelSplitter.AFTER | PanelSplitter.HIDDEN, PanelSplitter.BEFORE | PanelSplitter.HIDDEN, 0);
+		addLast(split, STRETCH, FILL);
+		// setPreferredSize(MyLocale.getScreenWidth()<=240?240:MyLocale.getScreenWidth()*2/3,240);
+
+		tblMyTravelbugJourneys = new TravelbugJourneyList();
 		tblMyTravelbugJourneys.readTravelbugsFile();
-		modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
 		// Get the columns to display and their widths from preferences
-		modTbJourneyList.columnMap=
-			TableColumnChooser.str2Array(Global.getPref().travelbugColMap,0,11,0, -1);
-		modTbJourneyList.colWidth=
-			TableColumnChooser.str2Array(Global.getPref().travelbugColWidth,10,1024,50, -1);
-		modTbJourneyList.numCols=modTbJourneyList.columnMap.length;
-		
-		modTbJourneyList.select(0,12,true);
+		modTbJourneyList.columnMap = TableColumnChooser.str2Array(Global.getPref().travelbugColMap, 0, 11, 0, -1);
+		modTbJourneyList.colWidth = TableColumnChooser.str2Array(Global.getPref().travelbugColWidth, 10, 1024, 50, -1);
+		modTbJourneyList.numCols = modTbJourneyList.columnMap.length;
+
+		modTbJourneyList.select(0, 12, true);
 		/* Restore the saved setting about showing only non-logged bugs */
 		if (Global.getPref().travelbugShowOnlyNonLogged) {
 			tcTbJourneyList.toggleNonLogged();
 		}
 		updateNumBugs();
 	}
-	
+
 	/** Indicate the number of journeys currently displayed */
 	private void updateNumBugs() {
-		lblNumVisibleJourneys.setText(""+modTbJourneyList.numRows);
+		lblNumVisibleJourneys.setText("" + modTbJourneyList.numRows);
 		lblNumVisibleJourneys.repaint();
 	}
-	
+
 	/** The control which had the last focus */
 	private Control currentControl;
-	
-	public void onEvent(Event ev){
-		// Update the table from the input form  
-		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) && selectedRow!=-1 &&
-				selectedRow<tblMyTravelbugJourneys.size()){
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			if (currentControl==inpName) 			tbj.getTb().setName(inpName.getText());
-			else if (currentControl==inpTrackingNo)  tbj.getTb().setTrackingNo(inpTrackingNo.getText());
-			else if (currentControl==inpFromProfile) tbj.setFromProfile(inpFromProfile.getText());
-			else if (currentControl==inpFromWaypoint)tbj.setFromWaypoint(inpFromWaypoint.getText());
-			else if (currentControl==inpFromDate)    tbj.setFromDate(inpFromDate.getText());
-			else if (currentControl==chkFromLogged)  tbj.setFromLogged(chkFromLogged.state);
-			else if (currentControl==inpToProfile)   tbj.setToProfile(inpToProfile.getText());
-			else if (currentControl==inpToWaypoint)  tbj.setToWaypoint(inpToWaypoint.getText());
-			else if (currentControl==inpToDate)      tbj.setToDate(inpToDate.getText());
-			else if (currentControl==chkToLogged)    tbj.setToLogged(chkToLogged.state);
-			//else if (ev.target==txtMission)     tb.setMission(txtMission.getText());
+
+	public void onEvent(Event ev) {
+		// Update the table from the input form
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) && selectedRow != -1 && selectedRow < tblMyTravelbugJourneys.size()) {
+			TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			if (currentControl == inpName)
+				tbj.getTb().setName(inpName.getText());
+			else if (currentControl == inpTrackingNo)
+				tbj.getTb().setTrackingNo(inpTrackingNo.getText());
+			else if (currentControl == inpFromProfile)
+				tbj.setFromProfile(inpFromProfile.getText());
+			else if (currentControl == inpFromWaypoint)
+				tbj.setFromWaypoint(inpFromWaypoint.getText());
+			else if (currentControl == inpFromDate)
+				tbj.setFromDate(inpFromDate.getText());
+			else if (currentControl == chkFromLogged)
+				tbj.setFromLogged(chkFromLogged.state);
+			else if (currentControl == inpToProfile)
+				tbj.setToProfile(inpToProfile.getText());
+			else if (currentControl == inpToWaypoint)
+				tbj.setToWaypoint(inpToWaypoint.getText());
+			else if (currentControl == inpToDate)
+				tbj.setToDate(inpToDate.getText());
+			else if (currentControl == chkToLogged)
+				tbj.setToLogged(chkToLogged.state);
+			// else if (ev.target==txtMission) tb.setMission(txtMission.getText());
 			tcTbJourneyList.repaint();
 		}
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED && selectedRow!=-1){
-			if (ev.target==inpTrackingNo) {pnlTab.selectNextTab(true,true); Gui.takeFocus(inpFromProfile,ControlConstants.ByKeyboard);pnlTab.repaint(); }
-			if (ev.target==inpFromDate) Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
-			if (ev.target==inpToDate) Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
-			if (ev.target==btnFromDate || ev.target==btnToDate) {
-				mInput inpDate=ev.target==btnFromDate ? inpFromDate : inpToDate;
-				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale());
-				dc.title=MyLocale.getMsg(328,"Date found"); 
-				dc.setPreferredSize(240,240);
-				String foundDate=inpDate.getText();
-				Time t=new Time();
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED && selectedRow != -1) {
+			if (ev.target == inpTrackingNo) {
+				pnlTab.selectNextTab(true, true);
+				Gui.takeFocus(inpFromProfile, ControlConstants.ByKeyboard);
+				pnlTab.repaint();
+			}
+			if (ev.target == inpFromDate)
+				Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+			if (ev.target == inpToDate)
+				Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+			if (ev.target == btnFromDate || ev.target == btnToDate) {
+				mInput inpDate = ev.target == btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, "Date found");
+				dc.setPreferredSize(240, 240);
+				String foundDate = inpDate.getText();
+				Time t = new Time();
 				try {
-					t.parse(foundDate,"y-M-d H:m");
-				} catch(IllegalArgumentException e) {
+					t.parse(foundDate, "y-M-d H:m");
+				} catch (IllegalArgumentException e) {
 					try {
-						t.parse(foundDate,"y-M-d");
-					} catch(IllegalArgumentException e1) {
+						t.parse(foundDate, "y-M-d");
+					} catch (IllegalArgumentException e1) {
 						// Can't parse date - should not happen
 					}
-				};
+				}
+				;
 				dc.reset(t);
-				if (dc.execute()==ewe.ui.FormBase.IDOK) {
-				  inpDate.setText(Convert.toString(dc.year)+"-"+MyLocale.formatLong(dc.month,"00")+"-"+MyLocale.formatLong(dc.day,"00")+" "+dc.time);
-				  if (ev.target==btnFromDate){ 
-					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
-					  Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
-				  } else {
-					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
-					  Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
-				  } tcTbJourneyList.repaint();
-				}				
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpDate.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time);
+					if (ev.target == btnFromDate) {
+						tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
+						Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+					} else {
+						tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
+						Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+					}
+					tcTbJourneyList.repaint();
+				}
 			}
 		}
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.EXITED){
-			pnlTab.selectNextTab(true,true); 
-			if (ev.target==chkFromLogged) Gui.takeFocus(inpToProfile,ControlConstants.ByKeyboard);
-			if (ev.target==chkToLogged) Gui.takeFocus(txtMission,ControlConstants.ByKeyboard);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.EXITED) {
+			pnlTab.selectNextTab(true, true);
+			if (ev.target == chkFromLogged)
+				Gui.takeFocus(inpToProfile, ControlConstants.ByKeyboard);
+			if (ev.target == chkToLogged)
+				Gui.takeFocus(txtMission, ControlConstants.ByKeyboard);
 		}
 		// The user closed the travelbugs screen
-		if (ev instanceof FormEvent && ev.type==FormEvent.CLOSED  && chD!=null) {
+		if (ev instanceof FormEvent && ev.type == FormEvent.CLOSED && chD != null) {
 			tblMyTravelbugJourneys.saveTravelbugsFile();
 			tblMyTravelbugJourneys.clear();
 			// Save the flag about showing non-logged journeys only
-			boolean old=Global.getPref().travelbugShowOnlyNonLogged;
-			Global.getPref().travelbugShowOnlyNonLogged=(tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked;
-			String travelbugColWidth=modTbJourneyList.getColWidths();
+			boolean old = Global.getPref().travelbugShowOnlyNonLogged;
+			Global.getPref().travelbugShowOnlyNonLogged = (tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked;
+			String travelbugColWidth = modTbJourneyList.getColWidths();
 			// If the preferences changed, save the pref.xml file
 			Vm.showWait(true);
-			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) ||
-				old!=Global.getPref().travelbugShowOnlyNonLogged) {
-				Global.getPref().travelbugColWidth=travelbugColWidth;
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) || old != Global.getPref().travelbugShowOnlyNonLogged) {
+				Global.getPref().travelbugColWidth = travelbugColWidth;
 				Global.getPref().savePreferences();
 			}
 			// If the list of travelbugs in the cache was modified, we need to save the cache too
 			if (chDmodified) {
-				ch.setHas_bugs(chD.Travelbugs.size()>0);
+				ch.setHas_bugs(chD.Travelbugs.size() > 0);
 				ch.save();
 			}
 			Vm.showWait(false);
-			chD=null;
+			chD = null;
 		}
 		updateNumBugs();
-		currentControl=Gui.focusedControl();
+		currentControl = Gui.focusedControl();
 	}
-	
-	
-//==============================================================
-// tbListTableModel
-//==============================================================
-class tbListTableModel extends TableModel {
-	private FontMetrics fm;
-	private Image imgRed;
-	tbListTableModel() {
-		
-		fillToEqualHeights=true;
-		allRowsSameSize=true;
-		hasRowHeaders=false;
-		//shadeAlternateRows=true;
-		cursorSize=new Dimension(12,1);
-		clipData=true;
-		fm=getFontMetrics();
-		// A red dot indicates that the journey has not been completely logged
-		imgRed = new Image("red.png");
-	}
-    private int colWidth[];
-	private int columnMap[];
-	
-	public Object getCellText(int row, int col) {
-		return null;
-	}
 
-	public Object getCellData(int row, int col){
-		if(row == -1){
-			return TravelbugJourney.getElementNameByNumber(columnMap[col]);
-		} else {
-			int map=columnMap[col];
-			// If we have not yet logged the from or the to, a red dot is placed in front of the first item
-			if (col==0 && (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() ||
-				!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) { 
-				// Is it a column with a checkbox?
-				if (map!=7 && map!=11) 
-					return new IconAndText((IImage)imgRed,(String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map),fm);
-				else { // Checkbox - special treatment
-					IconAndText iat=new IconAndText(imgRed,"",fm);
-					iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
-					return iat;
-				}
-			} else 
-				return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
-		}	
-	}
-	public int calculateRowHeight(int row) {
-		return charHeight+2;
-	}
-	
-	public int calculateColWidth(int col){
-		if(col == -1) 
-        	return 0;
-        else if (col<numCols)
-        	return colWidth[columnMap[col]];
-        else return 0;
-	}
-	
-	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
-		ta=super.getCellAttributes(row,col,isSelected,ta);
-		ta.alignment = CellConstants.LEFT;
-		ta.anchor = CellConstants.LEFT;
-		// Color the elements red, if we have not yet logged
-		if (row>=0)
-		switch (columnMap[col]) {
-		case 6: // fromDate
-				if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged()) ta.foreground=RED;
-				break;
-		case 10: // toDate
-				if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged()) ta.foreground=RED;
-				break;
+	// ==============================================================
+	// tbListTableModel
+	// ==============================================================
+	class tbListTableModel extends TableModel {
+		private FontMetrics fm;
+		private Image imgRed;
+
+		tbListTableModel() {
+
+			fillToEqualHeights = true;
+			allRowsSameSize = true;
+			hasRowHeaders = false;
+			// shadeAlternateRows=true;
+			cursorSize = new Dimension(12, 1);
+			clipData = true;
+			fm = getFontMetrics();
+			// A red dot indicates that the journey has not been completely logged
+			imgRed = new Image("red.png");
 		}
-		return ta;
-	}
 
-	private void showFields(TravelbugJourney tbj) {
-	   	inpName.setText(tbj.getTb().getName());
-		inpTrackingNo.setText(tbj.getTb().getTrackingNo());
-		lblId.setText(tbj.getTb().getGuid());
-		inpFromProfile.setText(tbj.getFromProfile());
-		inpFromWaypoint.setText(tbj.getFromWaypoint());
-		inpFromDate.setText(tbj.getFromDate());
-		chkFromLogged.setState(tbj.getFromLogged());
-		inpToProfile.setText(tbj.getToProfile());
-		inpToWaypoint.setText(tbj.getToWaypoint());
-		inpToDate.setText(tbj.getToDate());
-		chkToLogged.setState(tbj.getToLogged());
-		txtMission.setHtml(tbj.getTb().getMission());
-	}
-	
-	private boolean sortAsc=false;
-	private int sortedBy = -1;
-	private int lastRow=-1;
-	public int penEventModifiers; 
+		private int colWidth[];
+		private int columnMap[];
 
-	public boolean penPressed(Point onTable,Point cell){
-		boolean retval=false;
-		if(cell!=null && cell.y == -1){ // Hit a header => sort the table accordingly
-			Vm.showWait(true);
-			if (cell.x == sortedBy) sortAsc=!sortAsc;
-			else sortAsc = false;
-			sortedBy = cell.x;
-			// Check whether the list only shows non-logged journeys. If so, a subset
-			// of the table must be sorted
-			if ((tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
-				tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc,modTbJourneyList.numRows);
-			} else { // Showing all journeys - sort the full table
-				tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+		public Object getCellText(int row, int col) {
+			return null;
+		}
+
+		public Object getCellData(int row, int col) {
+			if (row == -1) {
+				return TravelbugJourney.getElementNameByNumber(columnMap[col]);
+			} else {
+				int map = columnMap[col];
+				// If we have not yet logged the from or the to, a red dot is placed in front of the first item
+				if (col == 0 && (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() || !tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) {
+					// Is it a column with a checkbox?
+					if (map != 7 && map != 11)
+						return new IconAndText((IImage) imgRed, (String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map), fm);
+					else { // Checkbox - special treatment
+						IconAndText iat = new IconAndText(imgRed, "", fm);
+						iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+						return iat;
+					}
+				} else
+					return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
 			}
-			tcTbJourneyList.repaint();
-			Vm.showWait(false);
-			retval = true;
-		} else if (cell!=null && cell.y>=0 && (penEventModifiers & IKeys.SHIFT)>0) {
-			// A range of rows can be marked by shift-click on the first and last row
-			if (lastRow!=-1) { // Second row being marked with shift key pressed
-				if (lastRow<cell.y)
-					toggleSelect(lastRow,cell.y);
-				else
-					toggleSelect(cell.y,lastRow);
-				lastRow=-1;
-				retval=true;
-			} else { // Remember this row as start of range, but don't toggle yet
-				lastRow=cell.y;
-			}
-		} else { // Single row marked
-			lastRow=-1;
 		}
-		return retval;
-	}
 
-	/** Select a range of rows */
-	private void toggleSelect(int fromRow, int toRow) {
-		tcTbJourneyList.clearSelection(null);
-		tcTbJourneyList.addToSelection(new Rect(0,fromRow,numCols,toRow-fromRow+1),false,true);
-	}
-	
-	/**
-	 * Return the column widths as a comma delimited string for storing in the preferences
-	 * @return
-	 */
-	private String getColWidths() {
-		// Update the list with the current widths
-		for (int col=0; col<numCols; col++) {
-			colWidth[columnMap[col]]=getColWidth(col);
+		public int calculateRowHeight(int row) {
+			return charHeight + 2;
 		}
-		// Convert to string
-		StringBuffer sb=new StringBuffer(40);
-		for (int i=0; i<colWidth.length; i++) {
-			if (sb.length()!=0) sb.append(',');
-			sb.append(colWidth[i]);
-		}
-		return sb.toString();
-	}
-}
 
-//==============================================================
-//tbListControl
-//==============================================================
-class tbListControl extends TableControl {
-	private MenuItem mnuNewTB, mnuDeleteTB,mnuGetMission,mnuOpenOnline,mnuDropTB,mnuPickupTB,mnuDeleteTBs;
-	public MenuItem mnuToggleList;
-	private Menu mnuFullMenu,mnuDeleteMenu;
-	
-	tbListControl() {
-		MenuItem[] TBMenuItems=new MenuItem[10];
-		TBMenuItems[0]= mnuPickupTB = new MenuItem(MyLocale.getMsg(6040,"Pick up TB from current cache"));
-		TBMenuItems[1]= mnuDropTB = new MenuItem(MyLocale.getMsg(6041,"Drop TB in cache"));
-		TBMenuItems[2]= new MenuItem("-");
-		TBMenuItems[3]= mnuNewTB = new MenuItem(MyLocale.getMsg(6042,"New Travelbug"));
-		TBMenuItems[4]= mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043,"Delete Travelbug"));
-		TBMenuItems[5]= new MenuItem("-");
-		TBMenuItems[6]= mnuGetMission = new MenuItem(MyLocale.getMsg(6044,"Get Mission"));
-		TBMenuItems[7]= mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045,"Open on-line"));
-		TBMenuItems[8]= new MenuItem("-");
-		TBMenuItems[9]= mnuToggleList = new MenuItem(MyLocale.getMsg(6046,"Show only not logged"));
-		mnuFullMenu=new Menu(TBMenuItems,"");
-		// A second pop-up menu with only one entry, if a range of rows is selected
-		MenuItem[] TBMenuItemsDel=new MenuItem[1];
-		TBMenuItemsDel[0]=mnuDeleteTBs=new MenuItem(MyLocale.getMsg(6047,"Delete selected Travelbugs"));
-		mnuDeleteMenu=new Menu(TBMenuItemsDel,"");
-		mnuDropTB.modifiers|=MenuItem.Disabled;
-		mnuDeleteTB.modifiers|=MenuItem.Disabled;
-		mnuGetMission.modifiers|=MenuItem.Disabled;
-		mnuOpenOnline.modifiers|=MenuItem.Disabled;
-	}
-	
-	public void onEvent(Event ev) {
-		Rect sel=getSelection(null);
-		if (sel.y<tblMyTravelbugJourneys.size()) {
-			mnuDeleteTB.modifiers&=~MenuItem.Disabled;
-			mnuGetMission.modifiers&=~MenuItem.Disabled;
-			mnuOpenOnline.modifiers&=~MenuItem.Disabled;
-			if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession()) 
-				mnuDropTB.modifiers&=~MenuItem.Disabled;
+		public int calculateColWidth(int col) {
+			if (col == -1)
+				return 0;
+			else if (col < numCols)
+				return colWidth[columnMap[col]];
 			else
-				mnuDropTB.modifiers|=MenuItem.Disabled;
-		} else {
-			mnuDeleteTB.modifiers|=MenuItem.Disabled;
-			mnuGetMission.modifiers|=MenuItem.Disabled;
-			mnuOpenOnline.modifiers|=MenuItem.Disabled;
+				return 0;
 		}
-		// If more than one row is selected, show the limited pop-up menu
-		if (sel.height>1)
-			setMenu(mnuDeleteMenu);
-		else
-			setMenu(mnuFullMenu);
-	    if (ev instanceof PenEvent) modTbJourneyList.penEventModifiers=((PenEvent)ev).modifiers;
-		super.onEvent(ev);
-	}
 
-	public void penRightReleased(Point p){
-		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
-	}
+		public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
+			ta = super.getCellAttributes(row, col, isSelected, ta);
+			ta.alignment = CellConstants.LEFT;
+			ta.anchor = CellConstants.LEFT;
+			// Color the elements red, if we have not yet logged
+			if (row >= 0)
+				switch (columnMap[col]) {
+				case 6: // fromDate
+					if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged())
+						ta.foreground = RED;
+					break;
+				case 10: // toDate
+					if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())
+						ta.foreground = RED;
+					break;
+				}
+			return ta;
+		}
 
-	public void penHeld(Point p){
-		menuState.doShowMenu(p,true,null); 
-	}
+		private void showFields(TravelbugJourney tbj) {
+			inpName.setText(tbj.getTb().getName());
+			inpTrackingNo.setText(tbj.getTb().getTrackingNo());
+			lblId.setText(tbj.getTb().getGuid());
+			inpFromProfile.setText(tbj.getFromProfile());
+			inpFromWaypoint.setText(tbj.getFromWaypoint());
+			inpFromDate.setText(tbj.getFromDate());
+			chkFromLogged.setState(tbj.getFromLogged());
+			inpToProfile.setText(tbj.getToProfile());
+			inpToWaypoint.setText(tbj.getToWaypoint());
+			inpToDate.setText(tbj.getToDate());
+			chkToLogged.setState(tbj.getToLogged());
+			txtMission.setHtml(tbj.getTb().getMission());
+		}
 
-	public void popupMenuEvent(Object selectedItem){
-		if (selectedItem==mnuPickupTB) {
-			Travelbug tb=TravelbugPickup.pickupTravelbug(tblSrcCache);	
-			if (tb!=null) {
-				chDmodified=true;
-				tblMyTravelbugJourneys.addTbPickup(tb,Global.getProfile().name,waypoint);
-				modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		private boolean sortAsc = false;
+		private int sortedBy = -1;
+		private int lastRow = -1;
+		public int penEventModifiers;
+
+		public boolean penPressed(Point onTable, Point cell) {
+			boolean retval = false;
+			if (cell != null && cell.y == -1) { // Hit a header => sort the table accordingly
+				Vm.showWait(true);
+				if (cell.x == sortedBy)
+					sortAsc = !sortAsc;
+				else
+					sortAsc = false;
+				sortedBy = cell.x;
+				// Check whether the list only shows non-logged journeys. If so, a subset
+				// of the table must be sorted
+				if ((tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
+					tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc, modTbJourneyList.numRows);
+				} else { // Showing all journeys - sort the full table
+					tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+				}
 				tcTbJourneyList.repaint();
+				Vm.showWait(false);
+				retval = true;
+			} else if (cell != null && cell.y >= 0 && (penEventModifiers & IKeys.SHIFT) > 0) {
+				// A range of rows can be marked by shift-click on the first and last row
+				if (lastRow != -1) { // Second row being marked with shift key pressed
+					if (lastRow < cell.y)
+						toggleSelect(lastRow, cell.y);
+					else
+						toggleSelect(cell.y, lastRow);
+					lastRow = -1;
+					retval = true;
+				} else { // Remember this row as start of range, but don't toggle yet
+					lastRow = cell.y;
+				}
+			} else { // Single row marked
+				lastRow = -1;
 			}
+			return retval;
 		}
-		if (selectedItem==mnuDropTB) {
-			if (selectedRow>=0 && selectedRow<modTbJourneyList.numRows) {
-				Travelbug tb=tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
-				chD.Travelbugs.add(tb);
-				tblMyTravelbugJourneys.addTbDrop(tb,Global.getProfile().name,waypoint);
-				chDmodified=true;
-				ch.setHas_bugs(true);
+
+		/** Select a range of rows */
+		private void toggleSelect(int fromRow, int toRow) {
+			tcTbJourneyList.clearSelection(null);
+			tcTbJourneyList.addToSelection(new Rect(0, fromRow, numCols, toRow - fromRow + 1), false, true);
+		}
+
+		/**
+		 * Return the column widths as a comma delimited string for storing in the preferences
+		 * 
+		 * @return
+		 */
+		private String getColWidths() {
+			// Update the list with the current widths
+			for (int col = 0; col < numCols; col++) {
+				colWidth[columnMap[col]] = getColWidth(col);
 			}
-			repaint();
+			// Convert to string
+			StringBuffer sb = new StringBuffer(40);
+			for (int i = 0; i < colWidth.length; i++) {
+				if (sb.length() != 0)
+					sb.append(',');
+				sb.append(colWidth[i]);
+			}
+			return sb.toString();
 		}
-		if (selectedItem==mnuNewTB) {
-			TravelbugJourney tbj=new TravelbugJourney("New");
-			tbj.setFromProfile(Global.getProfile().name);
-			tbj.setFromWaypoint(waypoint);
-			tblMyTravelbugJourneys.add(tbj);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			cursorTo(tblMyTravelbugJourneys.size()-1,1,true);
-			tcTbJourneyList.repaint();
+	}
+
+	// ==============================================================
+	// tbListControl
+	// ==============================================================
+	class tbListControl extends TableControl {
+		private MenuItem mnuNewTB, mnuDeleteTB, mnuGetMission, mnuOpenOnline, mnuDropTB, mnuPickupTB, mnuDeleteTBs;
+		public MenuItem mnuToggleList;
+		private Menu mnuFullMenu, mnuDeleteMenu;
+
+		tbListControl() {
+			MenuItem[] TBMenuItems = new MenuItem[10];
+			TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, "Pick up TB from current cache"));
+			TBMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6041, "Drop TB in cache"));
+			TBMenuItems[2] = new MenuItem("-");
+			TBMenuItems[3] = mnuNewTB = new MenuItem(MyLocale.getMsg(6042, "New Travelbug"));
+			TBMenuItems[4] = mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043, "Delete Travelbug"));
+			TBMenuItems[5] = new MenuItem("-");
+			TBMenuItems[6] = mnuGetMission = new MenuItem(MyLocale.getMsg(6044, "Get Mission"));
+			TBMenuItems[7] = mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045, "Open on-line"));
+			TBMenuItems[8] = new MenuItem("-");
+			TBMenuItems[9] = mnuToggleList = new MenuItem(MyLocale.getMsg(6046, "Show only not logged"));
+			mnuFullMenu = new Menu(TBMenuItems, "");
+			// A second pop-up menu with only one entry, if a range of rows is selected
+			MenuItem[] TBMenuItemsDel = new MenuItem[1];
+			TBMenuItemsDel[0] = mnuDeleteTBs = new MenuItem(MyLocale.getMsg(6047, "Delete selected Travelbugs"));
+			mnuDeleteMenu = new Menu(TBMenuItemsDel, "");
+			mnuDropTB.modifiers |= MenuItem.Disabled;
+			mnuDeleteTB.modifiers |= MenuItem.Disabled;
+			mnuGetMission.modifiers |= MenuItem.Disabled;
+			mnuOpenOnline.modifiers |= MenuItem.Disabled;
 		}
-		if (selectedItem==mnuDeleteTB && selectedRow>=0) {
-			tblMyTravelbugJourneys.remove(selectedRow);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			if (selectedRow>0) 
-				cursorTo(selectedRow-1,0,true);
+
+		public void onEvent(Event ev) {
+			Rect sel = getSelection(null);
+			if (sel.y < tblMyTravelbugJourneys.size()) {
+				mnuDeleteTB.modifiers &= ~MenuItem.Disabled;
+				mnuGetMission.modifiers &= ~MenuItem.Disabled;
+				mnuOpenOnline.modifiers &= ~MenuItem.Disabled;
+				if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession())
+					mnuDropTB.modifiers &= ~MenuItem.Disabled;
+				else
+					mnuDropTB.modifiers |= MenuItem.Disabled;
+			} else {
+				mnuDeleteTB.modifiers |= MenuItem.Disabled;
+				mnuGetMission.modifiers |= MenuItem.Disabled;
+				mnuOpenOnline.modifiers |= MenuItem.Disabled;
+			}
+			// If more than one row is selected, show the limited pop-up menu
+			if (sel.height > 1)
+				setMenu(mnuDeleteMenu);
 			else
-				modTbJourneyList.showFields(new TravelbugJourney(""));
-			tcTbJourneyList.repaint();
+				setMenu(mnuFullMenu);
+			if (ev instanceof PenEvent)
+				modTbJourneyList.penEventModifiers = ((PenEvent) ev).modifiers;
+			super.onEvent(ev);
 		}
-		/* Delete a group of travelbugs which have been marked with Shift-Click */
-		if (selectedItem==mnuDeleteTBs) {  
-			Rect sel=getSelection(null);
-			for (int i=0; i<sel.height; i++)
-				tblMyTravelbugJourneys.remove(sel.y);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			if (sel.y<modTbJourneyList.numRows) 
-				cursorTo(sel.y,0,true);
-			else
-				modTbJourneyList.showFields(new TravelbugJourney(""));
-			tcTbJourneyList.repaint();
+
+		public void penRightReleased(Point p) {
+			menuState.doShowMenu(p, true, null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 		}
-		if (selectedItem==mnuGetMission && selectedRow>-1) {
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
-			Vm.showWait(true);
-			
-			//if we have an ID, get mission by ID
-			if (tbj.getTb().getGuid().length()!=0) {
-				tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
-			} else {
-				//try to get mission and name by tracking number
-				boolean suceeded = false;
-				if (tbj.getTb().getTrackingNo().length() != 0) {
-					suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+
+		public void penHeld(Point p) {
+			menuState.doShowMenu(p, true, null);
+		}
+
+		public void popupMenuEvent(Object selectedItem) {
+			if (selectedItem == mnuPickupTB) {
+				Travelbug tb = TravelbugPickup.pickupTravelbug(tblSrcCache);
+				if (tb != null) {
+					chDmodified = true;
+					tblMyTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, waypoint);
+					modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+					tcTbJourneyList.repaint();
 				}
-				//if this has't worked, try to get ID by name
-				if (!suceeded) {
-					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
-					//if we have an ID now, get mission by ID
-					if (tbj.getTb().getGuid().length()!=0) {
-						tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+			}
+			if (selectedItem == mnuDropTB) {
+				if (selectedRow >= 0 && selectedRow < modTbJourneyList.numRows) {
+					Travelbug tb = tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
+					chD.Travelbugs.add(tb);
+					tblMyTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, waypoint);
+					chDmodified = true;
+					ch.setHas_bugs(true);
+				}
+				repaint();
+			}
+			if (selectedItem == mnuNewTB) {
+				TravelbugJourney tbj = new TravelbugJourney("New");
+				tbj.setFromProfile(Global.getProfile().name);
+				tbj.setFromWaypoint(waypoint);
+				tblMyTravelbugJourneys.add(tbj);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				cursorTo(tblMyTravelbugJourneys.size() - 1, 1, true);
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuDeleteTB && selectedRow >= 0) {
+				tblMyTravelbugJourneys.remove(selectedRow);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				if (selectedRow > 0)
+					cursorTo(selectedRow - 1, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(""));
+				tcTbJourneyList.repaint();
+			}
+			/* Delete a group of travelbugs which have been marked with Shift-Click */
+			if (selectedItem == mnuDeleteTBs) {
+				Rect sel = getSelection(null);
+				for (int i = 0; i < sel.height; i++)
+					tblMyTravelbugJourneys.remove(sel.y);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				if (sel.y < modTbJourneyList.numRows)
+					cursorTo(sel.y, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(""));
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuGetMission && selectedRow > -1) {
+				TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+
+				// if we have an ID, get mission by ID
+				if (tbj.getTb().getGuid().length() != 0) {
+					tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+				} else {
+					// try to get mission and name by tracking number
+					boolean suceeded = false;
+					if (tbj.getTb().getTrackingNo().length() != 0) {
+						suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
 					}
+					// if this has't worked, try to get ID by name
+					if (!suceeded) {
+						tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+						// if we have an ID now, get mission by ID
+						if (tbj.getTb().getGuid().length() != 0) {
+							tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+						}
+					}
 				}
+
+				Vm.showWait(false);
+				tcTbJourneyList.repaint();
+				txtMission.setHtml(tbj.getTb().getMission());
+				inpName.setText(tbj.getTb().getName());
+				lblId.setText(tbj.getTb().getGuid());
+				lowerpane.repaint();
+				Global.getPref().setOldGCLanguage();
 			}
-			
-			Vm.showWait(false);
-			tcTbJourneyList.repaint();
-			txtMission.setHtml(tbj.getTb().getMission());
-			inpName.setText(tbj.getTb().getName());
-			lblId.setText(tbj.getTb().getGuid());
-			lowerpane.repaint();
-		}
-		if (selectedItem==mnuOpenOnline && selectedRow>=0) {
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
-			Vm.showWait(true);
-			// First check whether ID is set, if not get it
-			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
-			if (tbj.getTb().getGuid().length()!=0) {
-				Vm.showWait(false);
-				try {
-					String s;
-					if (tbj.getTb().getGuid().length()>10)
-						s = "http://www.geocaching.com/track/details.aspx?guid="+tbj.getTb().getGuid();
-					else
-						s = "http://www.geocaching.com/track/details.aspx?id="+tbj.getTb().getGuid();
+			if (selectedItem == mnuOpenOnline && selectedRow >= 0) {
+				TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+				// First check whether ID is set, if not get it
+				if (tbj.getTb().getGuid().length() == 0)
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+				if (tbj.getTb().getGuid().length() != 0) {
+					Vm.showWait(false);
+					try {
+						String s;
+						if (tbj.getTb().getGuid().length() > 10)
+							s = "http://www.geocaching.com/track/details.aspx?guid=" + tbj.getTb().getGuid();
+						else
+							s = "http://www.geocaching.com/track/details.aspx?id=" + tbj.getTb().getGuid();
 
-					CWWrapper.exec(Global.getPref().browser, s);
-					Global.getPref().log("Executed: \""+Global.getPref().browser+"\" \""+s+"\"");
-				} catch (Exception ioex) {
-					// Global.getPref().log("Ignored Exception", ioex, true);
+						CWWrapper.exec(Global.getPref().browser, s);
+						Global.getPref().log("Executed: \"" + Global.getPref().browser + "\" \"" + s + "\"");
+					} catch (Exception ioex) {
+						// Global.getPref().log("Ignored Exception", ioex, true);
+					}
 				}
+				Global.getPref().setOldGCLanguage();
 			}
+			if (selectedItem == mnuToggleList) {
+				toggleNonLogged();
+			}
+			updateNumBugs();
 		}
-		if (selectedItem==mnuToggleList) {
-			toggleNonLogged();
+
+		/** Toggle between displaying all journeys or just those which still need to be logged */
+		public void toggleNonLogged() {
+			mnuToggleList.modifiers ^= MenuItem.Checked;
+			if ((mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
+				// First sort the non-logged items to the top
+				tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
+				// modListTable.numRows=tblMyTravelbugJourneys.size();
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.countNonLogged();
+			} else {
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+			}
+			tcTbJourneyList.repaint();
 		}
-		updateNumBugs();
-	}
-	
-	/** Toggle between displaying all journeys or just those which still need to be logged */
-	public void toggleNonLogged() {
-		mnuToggleList.modifiers^=MenuItem.Checked;
-		if ((mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
-			// First sort the non-logged items to the top
-			tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
-			// 		modListTable.numRows=tblMyTravelbugJourneys.size();
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.countNonLogged();
-		} else {
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+
+		public void cursorTo(int row, int col, boolean selectNew) {
+			super.cursorTo(row, col, selectNew);
+			selectedRow = row;
+			if (row >= 0) {
+				modTbJourneyList.showFields(tblMyTravelbugJourneys.getTBJourney(row));
+			} else {
+				modTbJourneyList.showFields(new TravelbugJourney(""));
+			}
 		}
-		tcTbJourneyList.repaint();
 	}
-	
-	
-	public void cursorTo(int row,int col,boolean selectNew) {
-		super.cursorTo(row,col,selectNew);
-		selectedRow=row;
-		if (row>=0) { 
-			modTbJourneyList.showFields(tblMyTravelbugJourneys.getTBJourney(row));
-		} else {
-			modTbJourneyList.showFields(new TravelbugJourney(""));
-		}
-	}
-}
 
 }

Modified: branches/r1.2/src/CacheWolf/TravelbugPickup.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugPickup.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugPickup.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,59 +1,66 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import CacheWolf.view.ITravelbugScreen;
+import CacheWolf.view.TravelBugScreenFactory;
 import ewe.ui.InputBox;
 
 public class TravelbugPickup {
 
 	/**
-	 * Choose a travelbug from those listed in the travelbug list and delete it, if
-	 * the operation was not cancelled.
-	 * @param tbl List of travelbugs from where a bug is picked up
+	 * Choose a travelbug from those listed in the travelbug list and delete it,
+	 * if the operation was not cancelled.
+	 * 
+	 * @param tbl
+	 *            List of travelbugs from where a bug is picked up
 	 */
 	public static Travelbug pickupTravelbug(TravelbugList tbl) {
-		Travelbug tb=null;
-		TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,"Pick up travelbug"),true);
+		Travelbug tb = null;
+		// TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,"Pick up travelbug"),true);
+		ITravelbugScreen tbs = TravelBugScreenFactory.createTravelbugScreen(tbl, MyLocale.getMsg(6016, "Pick up travelbug"), new Boolean(true));
 		tbs.execute(); // Select TB to pick up
-		if (tbs.selectedItem>=0) { // Was a TB selected ?
+		if (tbs.getSelectedItem() >= 0) { // Was a TB selected ?
 			// If the returned item is bigger than number of bugs in cache
-			// we have found a new unlisted bug. 
-			if (tbs.selectedItem==tbl.size()) {
-				InputBox ibox=new InputBox(MyLocale.getMsg(6018,"Travelbug name"));
-				String name=ibox.input("",240);
-				if (name==null) return null; // No name given
-				tb=new Travelbug(name);
+			// we have found a new unlisted bug.
+			if (tbs.getSelectedItem() == tbl.size()) {
+				InputBox ibox = new InputBox(MyLocale.getMsg(6018, "Travelbug name"));
+				String name = ibox.input("", 240);
+				if (name == null)
+					return null; // No name given
+				tb = new Travelbug(name);
 			} else { // A bug in the list was chosen
-				tb=tbl.getTB(tbs.selectedItem);
+				tb = tbl.getTB(tbs.getSelectedItem());
 				// Remove the tb from the list
-				tbl.remove(tbs.selectedItem);
+				tbl.remove(tbs.getSelectedItem());
 			}
-			InputBox ibox=new InputBox(MyLocale.getMsg(6019,"Tracking number"));
-			String trackingNo=ibox.input("",240);
-			if (trackingNo==null) trackingNo="";
+			InputBox ibox = new InputBox(MyLocale.getMsg(6019, "Tracking number"));
+			String trackingNo = ibox.input("", 240);
+			if (trackingNo == null)
+				trackingNo = "";
 			tb.setTrackingNo(trackingNo);
 		}
 		return tb;

Modified: branches/r1.2/src/CacheWolf/TravelbugScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -25,6 +25,7 @@
     */
 package CacheWolf;
 
+import CacheWolf.view.ITravelbugScreen;
 import ewe.ui.CellConstants;
 import ewe.ui.ControlEvent;
 import ewe.ui.Event;
@@ -40,19 +41,23 @@
  * Choose a travelbug to pick up or drop
  * @author salzkammergut
  */ 
-public class TravelbugScreen extends Form {
+public class TravelbugScreen extends Form implements ITravelbugScreen {
 	private myList disp;
 	private mButton btCancel,btAccept;
 	/** The index into the list of travelbugs indicating the selected bug */
 	public int selectedItem=-1;
 	
+	public int getSelectedItem() {
+		return selectedItem;
+	}
+
 	/**
 	 * A screen to choose a travelbug from a list of bugs
 	 * @param tbl The list of travelbugs from which to choose
 	 * @param title The title of the screen
 	 * @param allowNew True if a travelbug not on the list can be selected
 	 */
-	TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
+	public TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
 		this.setTitle(title);
 		this.setPreferredSize(240, -1);
 		disp=new myList(tbl,allowNew);
@@ -104,7 +109,4 @@
 				return SafeXML.cleanback(tbl.getTB(idx).getName());
 		}
 	}
-
-
-
 }

Modified: branches/r1.2/src/CacheWolf/UrlFetcher.java
===================================================================
--- branches/r1.2/src/CacheWolf/UrlFetcher.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/UrlFetcher.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,143 +1,232 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import ewe.data.PropertyList;
 import ewe.io.AsciiCodec;
-import ewe.io.ByteArrayInputStream;
+import ewe.io.File;
+import ewe.io.FileBase;
+import ewe.io.FileOutputStream;
 import ewe.io.IOException;
 import ewe.io.JavaUtf8Codec;
-import ewe.net.Socket;
-import ewe.net.URL;
-import ewe.sys.Handle;
-import ewe.sys.HandleStoppedException;
 import ewe.util.ByteArray;
 import ewe.util.CharArray;
-import ewe.util.Properties;
 
 public class UrlFetcher {
-	public static String fetchString(String address) throws IOException
-	{
-		ByteArray daten = fetchByteArray(address, null);
+	static HttpConnection conn;
+	static int maxRedirections = 5;
+	static PropertyList requestorProperties = null;
+	static PropertyList permanentRequestorProperties = null;
+	static String postData = null;
+	static String urltmp = null;
+	static String realUrl = null;
+	static boolean forceRedirect = false;
+
+	public static PropertyList getDocumentProperties() {
+		if (conn != null)
+			return conn.documentProperties;
+		else
+			return null;
+	}
+
+	public static String getRealUrl() {
+		return realUrl;
+	};
+
+	public static void setMaxRedirections(int value) {
+		maxRedirections = value;
+	};
+
+	public static void setForceRedirect() {
+		forceRedirect = true;
+	};
+
+	public static void setRequestorProperties(PropertyList value) {
+		requestorProperties = value;
+	};
+
+	public static void setRequestorProperty(String name, String property) {
+		if (requestorProperties == null)
+			requestorProperties = new PropertyList();
+		requestorProperties.set(name, property);
+	}
+
+	private static void initPermanentRequestorProperty() {
+		permanentRequestorProperties = new PropertyList();
+		permanentRequestorProperties.add("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
+		// permanentRequestorProperties.add("Connection", "close");
+		permanentRequestorProperties.add("Connection", "keep-alive");
+	}
+
+	public static void setPermanentRequestorProperty(String name, String property) {
+		if (permanentRequestorProperties == null)
+			initPermanentRequestorProperty();
+		if (property != null)
+			permanentRequestorProperties.set(name, property);
+		else {
+			int index = permanentRequestorProperties.find(name);
+			if (index >= 0)
+				permanentRequestorProperties.del(index);
+		}
+	}
+
+	public static void setpostData(String value) {
+		postData = value;
+	};
+
+	public static String fetch(String address) throws IOException {
+		ByteArray daten = fetchByteArray(address);
 		JavaUtf8Codec codec = new JavaUtf8Codec();
 		CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
 		return c_data.toString();
 	}
 
-	public static Properties fetchPropertyList(String url) throws IOException {
-		CharArray t = new CharArray();
-		ByteArray doc = fetchByteArray(url, t);
-		Properties props = new Properties();
-		props.load(new ByteArrayInputStream(doc));
-		return props; 
+	public static ByteArray fetchData(String address) throws IOException {
+		return fetchByteArray(address);
 	}
 
-	public static ByteArray fetchByteArray(String url, CharArray realurl) throws IOException {
-		Handle[] hndl = new Handle[1];
-		try {
-		return fetchByteArray(url, realurl, hndl);
-		} catch ( InterruptedException e) {
-			throw new IOException("Error reading data. i :"+url);
-		} catch ( HandleStoppedException e) {
-			throw new IOException("Error reading data. s :"+url);
-		}
+	public static void fetchDataFile(String address, String target) throws IOException {
+		FileOutputStream outp = new FileOutputStream(new File(target));
+		outp.write(fetchByteArray(address).toBytes());
+		outp.close();
 	}
 
 	/**
-	 * @param url - if url-not-allowed chars are contained, they will be automatically encoded
-	 * @param if non null, realurl will be filled with the real url, which can differ from the given url, in case url returns a http-redirect
-	 * @return
+	 * @param url
+	 * @return ByteArray
 	 * @throws IOException
-	 * @throws InterruptedException 
-	 * @throws HandleStoppedException 
 	 */
-	public static ByteArray fetchByteArray(String url, CharArray realurl, Handle[] hndl) 
-	throws IOException, HandleStoppedException, InterruptedException {	
-		final int maxRedirections = 5;
-		HttpConnection conn = null;
-		Socket sock = null;
-		int i=0;
-		String urltmp = new String(url);
-		do  { // allow max 5 redirections (http 302 location)
-			if (realurl != null) realurl.copyFrom(new String(urltmp));
+	public static ByteArray fetchByteArray(String url) throws IOException {
+		int i = 0;
+		conn = new HttpConnection(url); // todo reuse: don#t reuse, some params are not correctly reset with SetUrl
+		urltmp = url;
+		do { // allow max 5 redirections (http 302 location)
 			i++;
-			conn = new HttpConnection(urltmp);
-			conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-			conn.setRequestorProperty("Connection", "close");
+			if (urltmp == null) {
+				// hack for expedia, doing the original url again.
+				// expedia always must redirect >=1 time, but sometimes that is missed
+				// see also: http://www.geoclub.de/viewtopic.php?p=305071#305071
+				urltmp = url;
+				i = i - 1;
+			}
+			realUrl = urltmp;
+			if (!urltmp.startsWith("http")) {
+				url = FileBase.fixupPath(url);
+				String uu = url.toLowerCase();
+				String host;
+				uu = url.replace('\\', '/');
+				host = uu.substring(7);
+				int first = host.indexOf('/');
+				if (first != -1) {
+					host = host.substring(0, first);
+				}
+				if (!urltmp.startsWith("/"))
+					host = host + "/";
+				urltmp = "http://" + host + urltmp;
+			}
+			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
-			hndl[0] = conn.connectAsync();
-			hndl[0].waitOn(Handle.Success);
-			sock = (Socket)hndl[0].returnValue; //"Could not connect.");
-			if (conn.responseCode >= 400) throw new IOException("URL: "+ urltmp + "\nhttp response code: " + conn.responseCode);
+			if (permanentRequestorProperties == null)
+				initPermanentRequestorProperty();
+			if (postData != null) {
+				conn.setPostData(postData);
+				conn.setRequestorProperty("Content-Type", "application/x-www-form-urlencoded");
+			}
+			conn.setRequestorProperty(permanentRequestorProperties);
+			if (requestorProperties != null)
+				conn.setRequestorProperty(requestorProperties);
+			conn.connect();
+			if (conn.responseCode >= 400) {
+				maxRedirections = 5;
+				requestorProperties = null;
+				postData = null;
+				forceRedirect = false;
+				throw new IOException("URL: " + urltmp + "\nhttp response code: " + conn.responseCode);
+			}
 			urltmp = conn.getRedirectTo();
-			if(urltmp!=null){
-				URL eweUrl = new URL(url);
-				if(urltmp.indexOf(eweUrl.getHost())<0){
-					urltmp = new URL(eweUrl.getProtocol(), eweUrl.getHost(),eweUrl.getPort(), urltmp).url;
+			if (urltmp != null) {
+				conn.disconnect();
+				// mainly implemented for opencaching.de ... login
+				final PropertyList pl = UrlFetcher.getDocumentProperties();
+				if (pl != null) {
+					String cookie = (String) pl.getValue("Set-Cookie", "");
+					if (cookie.length() > 0) {
+						if (postData == null)
+							// do not overwrite existing cookie (mostly for geocaching.com)
+							// normally a cookie exists for a website
+							// we do not handle that correct
+							setRequestorProperty("Cookie", cookie);
+						else
+							// needed for opencaching.de ... login
+							setPermanentRequestorProperty("Cookie", cookie);
+					}
 				}
-				urltmp = STRreplace.replace(urltmp, eweUrl.getHost() + "/\\.\\./", eweUrl.getHost() + "/");
+				conn = conn.getRedirectedConnection(urltmp);
+				forceRedirect = false; // one time or more redirected
 			}
-		} while (urltmp != null && i <= maxRedirections ); 
-		if (i > maxRedirections) throw new IOException("too many http redirections while trying to fetch: "+url + " only "+maxRedirections+" are allowed");
-		hndl[0] = conn.readInData();
+		} while (((urltmp != null) || (urltmp == null) && forceRedirect) && i <= maxRedirections);
+		if (i > maxRedirections)
+			throw new IOException("too many http redirections while trying to fetch: " + url + " only " + maxRedirections + " are allowed");
 		ByteArray daten;
-		try{
-			hndl[0].waitOn(Handle.Success);
-		}finally {
-			sock.close();
-		}
-		daten = (ByteArray)hndl[0].returnValue;
-		// ByteArray daten = conn.readData(sock);
+		if (conn.isOpen()) {
+			daten = conn.readData();
+			conn.disconnect();
+		} else
+			daten = null;
+		maxRedirections = 5;
+		requestorProperties = null;
+		postData = null;
+		forceRedirect = false;
 		return daten;
 	}
 
 	/**
 	 * @param url
-	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false otherwise
+	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false
+	 *         otherwise
 	 */
-	public static boolean isUrlEncoded(String url) {
-		final String allowed = new String ("-_.~!*'();:@&=+$,/?%#[]");
-		char [] src = ewe.sys.Vm.getStringChars(url);
+	private static boolean isUrlEncoded(String url) {
+		final String allowed = new String("-_.~!*'();:@&=+$,/?%#[]");
+		char[] src = ewe.sys.Vm.getStringChars(url);
 		char c;
-		for (int i = 0; i<src.length; i++){
+		for (int i = 0; i < src.length; i++) {
 			c = src[i];
-			if (       (c >= 'A' && c <= 'Z') 
-					|| (c >= 'a' && c <= 'z') 
-					|| (c >= '0' && c <= '9')
-					|| (allowed.indexOf(c) >= 0)
-			) continue;
-			else return false;
+			if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (allowed.indexOf(c) >= 0))
+				continue;
+			else
+				return false;
 		}
 		return true;
 	}
+
 	/**
-	 * This method encodes an URL containing special characters
-	 * using the UTF-8 codec in %nn%nn notation<br>
-	 * Note that the encoding for URLs is not generally defined. Usually
-	 * cp1252 or UTF-8 is used. It depends on what the server expects,
-	 * what encoding you must use.
+	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation<br>
+	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the
+	 * server expects, what encoding you must use.
+	 * 
 	 * @param cc
 	 * @return
 	 * @throws IOException
@@ -149,36 +238,40 @@
 		AsciiCodec asciicod = new AsciiCodec();
 		CharArray utf8bytes = new CharArray();
 		asciicod.decodeText(utf8.data, 0, utf8.length, true, utf8bytes);
-		return encodeURL(utf8bytes.toString(), false);
+		return encodeURL(utf8bytes.toString(), true);
 	}
-	
+
 	final static String hex = ewe.util.TextEncoder.hex;
+
 	/**
-	 * Encode the URL using %## notation.
-	 * Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine
-	 * assumes all chars to be < 127.
-	 * This method is mainly copied from there
-	 * @param url The unencoded URL.
-	 * @param spaceToPlus true if you wish a space to be encoded as a '+', false to encode it as %20
+	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all
+	 * chars to be < 127. This method is mainly copied from there
+	 * 
+	 * @param url
+	 *            The unencoded URL.
+	 * @param spaceToPlus
+	 *            true if you wish a space to be encoded as a '+', false to encode it as %20
 	 * @return The encoded URL.
 	 */
-	//===================================================================
+	// ===================================================================
 	public static String encodeURL(String url, boolean spaceToPlus)
-	//===================================================================
+	// ===================================================================
 	{
-		char [] what = ewe.sys.Vm.getStringChars(url);
+		char[] what = ewe.sys.Vm.getStringChars(url);
 		int max = what.length;
-		char [] dest = new char[max+max/2];
+		char[] dest = new char[max + max / 2];
 		char d = 0;
-		for (int i = 0; i<max; i++){
-			if (d >= dest.length-2) {
-				char [] n = new char[dest.length+dest.length/2+3];
-				ewe.sys.Vm.copyArray(dest,0,n,0,d);
+		for (int i = 0; i < max; i++) {
+			if (d >= dest.length - 2) {
+				char[] n = new char[dest.length + dest.length / 2 + 3];
+				ewe.sys.Vm.copyArray(dest, 0, n, 0, d);
 				dest = n;
 			}
 			char c = what[i];
-			if (spaceToPlus && c == ' ') c = '+';
-			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}'){
+			// added || c == '$' || c == '/' || c == ','
+			if (spaceToPlus && c == ' ')
+				c = '+';
+			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/' || c == ',') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);
@@ -186,7 +279,7 @@
 			}
 			dest[d++] = c;
 		}
-		return new String(dest,0,d);
+		return new String(dest, 0, d);
 	}
 
 }
\ No newline at end of file

Modified: branches/r1.2/src/CacheWolf/exp/DistanceComparer.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/DistanceComparer.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/DistanceComparer.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -30,21 +30,21 @@
 import ewe.util.Comparer;
 
 public class DistanceComparer implements Comparer {
-	
+
 	CWPoint centre;
-	
+
 	public DistanceComparer(CWPoint centre) {
 		this.centre = centre;
 	}
 
 	public int compare(Object one, Object two) {
-		if ((! (one instanceof CacheHolder)) && (!(two instanceof CacheHolder))) {
+		if ((!(one instanceof CacheHolder)) && (!(two instanceof CacheHolder))) {
 			return 0;
 		} else {
 			CacheHolder a = (CacheHolder) one;
 			CacheHolder b = (CacheHolder) two;
-			return (int) ((a.pos.getDistance(centre) - b.pos.getDistance(centre)) * 1000);
+			return (int) ((a.getPos().getDistance(centre) - b.getPos().getDistance(centre)) * 1000);
 		}
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/exp/ExploristExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/ExploristExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/ExploristExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -95,19 +95,19 @@
 	public void doIt() {
 		File configFile = new File("magellan.cfg");
 		if (configFile.exists()) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName+"Dir"));
+			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName + "Dir"));
 			fc.setTitle(MyLocale.getMsg(2104, "Choose directory for exporting .gs files"));
 			String targetDir;
-			if(fc.execute() != FormBase.IDCANCEL){
+			if (fc.execute() != FormBase.IDCANCEL) {
 				targetDir = fc.getChosen() + "/";
-				pref.setExportPath(expName+"Dir", targetDir);
+				pref.setExportPath(expName + "Dir", targetDir);
 
 				CWPoint centre = profile.centre;
 				try {
 					LineNumberReader reader = new LineNumberReader(new BufferedReader(new FileReader(configFile)));
 					String line, fileName, coordinate;
-					while ((line = reader.readLine()) != null)  {
-						StringTokenizer tokenizer = new StringTokenizer(line,"=");
+					while ((line = reader.readLine()) != null) {
+						StringTokenizer tokenizer = new StringTokenizer(line, "=");
 						fileName = targetDir + tokenizer.nextToken().trim() + ".gs";
 						coordinate = tokenizer.nextToken().trim();
 						CWPoint point = new CWPoint(coordinate);
@@ -117,17 +117,16 @@
 					}
 					reader.close();
 				} catch (FileNotFoundException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"),MyLocale.getMsg(2101, "Failure at loading magellan.cfg\n" + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"), MyLocale.getMsg(2101, "Failure at loading magellan.cfg\n" + e.getMessage()));
 					info.show();
 				} catch (IOException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"),MyLocale.getMsg(2103, "Failure at reading magellan.cfg\n" + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"), MyLocale.getMsg(2103, "Failure at reading magellan.cfg\n" + e.getMessage()));
 					info.show();
 				} finally {
-					cacheDB.sort(new DistanceComparer(centre),false);
+					cacheDB.sort(new DistanceComparer(centre), false);
 				}
 			}
-		}
-		else {
+		} else {
 			doIt(null);
 		}
 	}
@@ -164,18 +163,14 @@
 
 		try {
 			// Set initial value for outp to calm down compiler
-			PrintWriter outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + ".gs"))));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + ".gs"))));
 			for (int i = 0; i < cacheDB.size(); i++) {
 				ch = cacheDB.get(i);
 				if (ch.isVisible()) {
 					// all 200 caches we need a new file
 					if (expCount % 200 == 0 && expCount > 0) {
 						outp.close();
-						outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + ".gs"))));
+						outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + ".gs"))));
 					}
 
 					expCount++;
@@ -195,20 +190,19 @@
 			outp.close();
 			pbf.exit(0);
 		} catch (IOException ioE) {
-			pref.log("Error opening " + outFile.getName(),ioE);
+			pref.log("Error opening " + outFile.getName(), ioE);
 		}
 		// try
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
-	 *
+	 * 
 	 * @return
 	 */
 	public File getOutputFile() {
 		File file;
-		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref
-				.getExportPath(expName));
+		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle(MyLocale.getMsg(2102, "Select target file:"));
 		fc.addMask(mask);
 		if (fc.execute() != FormBase.IDCANCEL) {
@@ -222,7 +216,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @param ch
 	 *            cachedata
 	 * @return formated cache data
@@ -230,21 +224,21 @@
 	public String record(CacheHolder ch) {
 		CacheHolderDetail det = ch.getCacheDetails(true);
 		/*
-		static protected final int GC_AW_PARKING = 50;
-		static protected final int GC_AW_STAGE_OF_MULTI = 51;
-		static protected final int GC_AW_QUESTION = 52;
-		static protected final int GC_AW_FINAL = 53;
-		static protected final int GC_AW_TRAILHEAD = 54;
-		static protected final int GC_AW_REFERENCE = 55;
-		*/
+		 * static protected final int GC_AW_PARKING = 50;
+		 * static protected final int GC_AW_STAGE_OF_MULTI = 51;
+		 * static protected final int GC_AW_QUESTION = 52;
+		 * static protected final int GC_AW_FINAL = 53;
+		 * static protected final int GC_AW_TRAILHEAD = 54;
+		 * static protected final int GC_AW_REFERENCE = 55;
+		 */
 		StringBuffer sb = new StringBuffer();
 		sb.append("$PMGNGEO,");
-		sb.append(ch.pos.getLatDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLatMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLatDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLatMin(CWPoint.DMM));
 		sb.append(",");
 		sb.append("N,");
-		sb.append(ch.pos.getLonDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLonMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLonDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLonMin(CWPoint.DMM));
 		sb.append(",");
 		sb.append("E,");
 		sb.append("0000,"); // Height
@@ -281,11 +275,11 @@
 			sb.append(CacheType.type2GSTypeTag(ch.getType()));
 		}
 		sb.append(",");
-		sb.append(toGsDateFormat(ch.getDateHidden()));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(toGsDateFormat(ch.getDateHidden())); // created - DDMMYYY, YYY = year - 1900
 		sb.append(",");
 		String lastFound = "0000";
 		for (int i = 0; i < det.CacheLogs.size(); i++) {
-			if (det.CacheLogs.getLog(i).isFoundLog() && det.CacheLogs.getLog(i).getDate().compareTo(lastFound) > 0 ) {
+			if (det.CacheLogs.getLog(i).isFoundLog() && det.CacheLogs.getLog(i).getDate().compareTo(lastFound) > 0) {
 				lastFound = det.CacheLogs.getLog(i).getDate();
 			}
 		}
@@ -301,7 +295,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @return formated trailer data
 	 */
 	public String trailer() {
@@ -310,6 +304,7 @@
 
 	/**
 	 * Changes "," in "." in the input String
+	 * 
 	 * @param input
 	 * @return changed String
 	 */
@@ -319,14 +314,15 @@
 
 	/**
 	 * change the Dateformat from "yyyy-mm-dd" to ddmmyyy, where yyy is years after 1900
-	 * @param input Date in yyyy-mm-dd
- 	 * @return Date in ddmmyyy
+	 * 
+	 * @param input
+	 *            Date in yyyy-mm-dd
+	 * @return Date in ddmmyyy
 	 */
 	private String toGsDateFormat(String input) {
 		if (input.length() >= 10) {
 			return input.substring(8, 10) + input.substring(5, 7) + "1" + input.substring(2, 4);
-		}
-		else {
+		} else {
 			return "";
 		}
 	}

Modified: branches/r1.2/src/CacheWolf/exp/Exporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/Exporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/Exporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -48,11 +48,11 @@
 
 /**
  * @author Kalle
- * Base class for exporter, handles basic things like selecting
- * outputfile, display a counter etc.
- * A new Exporter must only override the header(), record() and 
- * trailer() methods. The member howManyParams must be set to identify
- * which ethod should be called  
+ *         Base class for exporter, handles basic things like selecting
+ *         outputfile, display a counter etc.
+ *         A new Exporter must only override the header(), record() and
+ *         trailer() methods. The member howManyParams must be set to identify
+ *         which ethod should be called
  */
 
 public class Exporter {
@@ -60,12 +60,12 @@
 	final static int TMP_FILE = 0;
 	// brings up a screen to select a file
 	final static int ASK_FILE = 1;
-	
+
 	// selection, which method should be called
-	final static int NO_PARAMS 	= 0;
-	final static int LAT_LON 	= 1;
-	final static int COUNT 		= 2;
-	
+	final static int NO_PARAMS = 0;
+	final static int LAT_LON = 1;
+	final static int COUNT = 2;
+
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
@@ -74,97 +74,100 @@
 	// file name, if no file chooser is used
 	String tmpFileName;
 	// decimal separator for lat- and lon-String
-	char decimalSeparator='.';
-	// if  true, the complete cache details are read
-	// before a call to the record method is made 
+	char decimalSeparator = '.';
+	// if true, the complete cache details are read
+	// before a call to the record method is made
 	boolean needCacheDetails = false;
 	// selection, which method should be called
 	int howManyParams = 0;
-	
-	//name of exporter for saving pathname
+
+	// name of exporter for saving pathname
 	String expName;
-	
+
 	public Exporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 		howManyParams = LAT_LON;
-		expName = this.getClass().getName(); 
+		expName = this.getClass().getName();
 		// remove package
 		expName = expName.substring(expName.indexOf(".") + 1);
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		this.doIt(ASK_FILE);
 	}
 
 	/**
 	 * Does the most work for exporting data
-	 * @param variant 0, if no filechooser
-	 *                1, if filechooser
+	 * 
+	 * @param variant
+	 *            0, if no filechooser
+	 *            1, if filechooser
 	 */
-	public void doIt(int variant){
+	public void doIt(int variant) {
 		File outFile;
 		String str;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
-
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
-			if (outFile == null) return;
+			if (outFile == null)
+				return;
 		} else {
 			outFile = new File(tmpFileName);
 		}
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
+		pbf.setTask(h, "Exporting ...");
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			int incompleteWaypoints = 0;
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
 			str = this.header();
-			if (str != null) outp.print(str);
-			for(int i = 0; i<cacheDB.size(); i++){
-				ch=cacheDB.get(i);
-				if(ch.isVisible()){
+			if (str != null)
+				outp.print(str);
+			for (int i = 0; i < cacheDB.size(); i++) {
+				ch = cacheDB.get(i);
+				if (ch.isVisible()) {
 					if (ch.is_incomplete()) {
-						Global.getPref().log("skipping export of incomplete waypoint "+ch.getWayPoint());
+						Global.getPref().log("skipping export of incomplete waypoint " + ch.getWayPoint());
 						incompleteWaypoints++;
 						continue;
 					}
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
 					switch (this.howManyParams) {
 					case NO_PARAMS:
 						str = record(ch);
 						break;
 					case LAT_LON:
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
-					case LAT_LON|COUNT: 
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-									 ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											 i);
+					case LAT_LON | COUNT:
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator), i);
 						break;
 					default:
 						str = null;
 						break;
 					}
-					if (str != null) outp.print(str);
-				}//if
-			}//for
+					if (str != null)
+						outp.print(str);
+				}// if
+			}// for
 			switch (this.howManyParams & COUNT) {
-			case NO_PARAMS: 
+			case NO_PARAMS:
 				str = trailer();
 				break;
 			case COUNT:
@@ -174,64 +177,75 @@
 				str = null;
 				break;
 			}
-			if (str != null) outp.print(str);
+			if (str != null)
+				outp.print(str);
 			outp.close();
 			pbf.exit(0);
 			if (incompleteWaypoints > 0) {
-				new MessageBox("Export Error", incompleteWaypoints+" incomplete waypoints have not been exported. See log for details.", FormBase.OKB).execute();
+				new MessageBox("Export Error", incompleteWaypoints + " incomplete waypoints have not been exported. See log for details.", FormBase.OKB).execute();
 			}
-		} catch (IOException ioE){
-			pref.log("Error opening " + outFile.getName(),ioE);
+		} catch (IOException ioE) {
+			pref.log("Error opening " + outFile.getName(), ioE);
 		}
-		//try
+		// try
 	}
+
 	/**
 	 * sets mask for filechooser
-	 * @param mask 
+	 * 
+	 * @param mask
 	 */
-	public void setMask(String mask){
+	public void setMask(String mask) {
 		this.mask = mask;
 	}
+
 	/**
 	 * sets decimal separator for lat/lon-string
+	 * 
 	 * @param sep
 	 */
-	public void setDecimalSeparator (char sep){
+	public void setDecimalSeparator(char sep) {
 		this.decimalSeparator = sep;
 	}
+
 	/**
-	 *  sets needCacheDetails
+	 * sets needCacheDetails
+	 * 
 	 * @param how
 	 */
-	public void setNeedCacheDetails(boolean how){
+	public void setNeedCacheDetails(boolean how) {
 		this.needCacheDetails = how;
 	}
-	
+
 	/**
 	 * sets howManyParams
+	 * 
 	 * @param paramBits
 	 */
-	public void setHowManyParams(int paramBits){
+	public void setHowManyParams(int paramBits) {
 		this.howManyParams = paramBits;
 	}
+
 	/**
 	 * sets tmpFileName
+	 * 
 	 * @param fName
 	 */
-	public void setTmpFileName(String fName){
+	public void setTmpFileName(String fName) {
 		this.tmpFileName = fName;
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
+	 * 
 	 * @return
 	 */
-	public File getOutputFile (){
+	public File getOutputFile() {
 		File file;
 		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle("Select target file:");
 		fc.addMask(mask);
-		if(fc.execute() != FormBase.IDCANCEL){
+		if (fc.execute() != FormBase.IDCANCEL) {
 			file = fc.getChosenFile();
 			pref.setExportPath(expName, file.getPath());
 			return file;
@@ -239,226 +253,145 @@
 			return null;
 		}
 	}
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated header data
-	 */	
-	public String header () {
+	 */
+	public String header() {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
+	 * 
+	 * @param ch
+	 *            cachedata
 	 * @return formated cache data
-	 */	
-	public String record(CacheHolder chD){
+	 */
+	public String record(CacheHolder chD) {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon){
+	public String record(CacheHolder ch, String lat, String lon) {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
-	 * @param count of actual record
+	 * @param count
+	 *            of actual record
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon, int count){
+	public String record(CacheHolder ch, String lat, String lon, int count) {
 		return null;
 	}
-	
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated trailer data
-	 */	
-	public String trailer(){
+	 */
+	public String trailer() {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param total count of exported caches
+	 * 
+	 * @param total
+	 *            count of exported caches
 	 * @return
 	 */
-	public String trailer(int total){
+	public String trailer(int total) {
 		return null;
 	}
 
-///////////////////////////////////////////////////
-//  Helper functions for string sanitisation
-///////////////////////////////////////////////////
-	
+	// /////////////////////////////////////////////////
+	// Helper functions for string sanitisation
+	// /////////////////////////////////////////////////
+
 	private static Hashtable iso2simpleMappings = new Hashtable(250);
 	static {
-		String[] mappingArray = new String[] {
-				"34",  "'",
-				"160", " ",
-				"161", "i",
-				"162", "c",
-				"163", "$",
-				"164", "o",
-				"165", "$",
-				"166", "!",
-				"167", "$",
-				"168", " ",
-				"169", " ",
-				"170", " ",
-				"171", "<",
-				"172", " ",
-				"173", "-",
-				"174", " ",
-				"175", "-",
-				"176", " ",
-				"177", "+/-",
-				"178", "2",
-				"179", "3",
-				"180", "'",
-				"181", " ",
-				"182", " ",
-				"183", " ",
-				"184", ",",
-				"185", "1",
-				"186", " ",
-				"187", ">",
-				"188", "1/4",
-				"189", "1/2",
-				"190", "3/4",
-				"191", "?",
-				"192", "A",
-				"193", "A",
-				"194", "A",
-				"195", "A",
-				"196", "Ae",
-				"197", "A",
-				"198", "AE",
-				"199", "C",
-				"200", "E",
-				"201", "E",
-				"202", "E",
-				"203", "E",
-				"204", "I",
-				"205", "I",
-				"206", "I",
-				"207", "I",
-				"208", "D",
-				"209", "N",
-				"210", "O",
-				"211", "O",
-				"212", "O",
-				"213", "O",
-				"214", "Oe",
-				"215", "x",
-				"216", "O",
-				"217", "U",
-				"218", "U",
-				"219", "U",
-				"220", "Ue",
-				"221", "Y",
-				"222", " ",
-				"223", "ss",
-				"224", "a",
-				"225", "a",
-				"226", "a",
-				"227", "a",
-				"228", "ae",
-				"229", "a",
-				"230", "ae",
-				"231", "c",
-				"232", "e",
-				"233", "e",
-				"234", "e",
-				"235", "e",
-				"236", "i",
-				"237", "i",
-				"238", "i",
-				"239", "i",
-				"240", "o",
-				"241", "n",
-				"242", "o",
-				"243", "o",
-				"244", "o",
-				"245", "o",
-				"246", "oe",
-				"247", "/",
-				"248", "o",
-				"249", "u",
-				"250", "u",
-				"251", "u",
-				"252", "ue",
-				"253", "y",
-				"254", "p",
-				"255", "y"
-		};
+		String[] mappingArray = new String[] { "34", "'", "160", " ", "161", "i", "162", "c", "163", "$", "164", "o", "165", "$", "166", "!", "167", "$", "168", " ", "169", " ", "170", " ", "171", "<", "172", " ", "173", "-", "174", " ", "175", "-",
+				"176", " ", "177", "+/-", "178", "2", "179", "3", "180", "'", "181", " ", "182", " ", "183", " ", "184", ",", "185", "1", "186", " ", "187", ">", "188", "1/4", "189", "1/2", "190", "3/4", "191", "?", "192", "A", "193", "A", "194", "A",
+				"195", "A", "196", "Ae", "197", "A", "198", "AE", "199", "C", "200", "E", "201", "E", "202", "E", "203", "E", "204", "I", "205", "I", "206", "I", "207", "I", "208", "D", "209", "N", "210", "O", "211", "O", "212", "O", "213", "O", "214",
+				"Oe", "215", "x", "216", "O", "217", "U", "218", "U", "219", "U", "220", "Ue", "221", "Y", "222", " ", "223", "ss", "224", "a", "225", "a", "226", "a", "227", "a", "228", "ae", "229", "a", "230", "ae", "231", "c", "232", "e", "233", "e",
+				"234", "e", "235", "e", "236", "i", "237", "i", "238", "i", "239", "i", "240", "o", "241", "n", "242", "o", "243", "o", "244", "o", "245", "o", "246", "oe", "247", "/", "248", "o", "249", "u", "250", "u", "251", "u", "252", "ue", "253",
+				"y", "254", "p", "255", "y" };
 		for (int i = 0; i < mappingArray.length; i = i + 2) {
-			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
+			iso2simpleMappings.put(Integer.valueOf(mappingArray[i]), mappingArray[i + 1]);
 		}
 	}
 
-	
-	protected static String char2simpleChar( char c )
-    {
-        if ( c < 127 ) {
-            // leave alone as equivalent string.
-            return null;
-        } else {
-            String s=(String) iso2simpleMappings.get( new Integer(c));
-            if (s==null) // not in table, replace with empty string just to be sure
-            	return "";
-            else
-            	return s;
-        }
-    } // end charToEntity
-	
-    public static String simplifyString( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( 50 );
-        int charsToAppend = 0;
-        for ( int i = 0; i < originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = char2simpleChar( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
+	protected static String char2simpleChar(char c) {
+		if (c < 127) {
+			// leave alone as equivalent string.
+			return null;
+		} else {
+			String s = (String) iso2simpleMappings.get(new Integer(c));
+			if (s == null) // not in table, replace with empty string just to be sure
+				return "";
+			else
+				return s;
+		}
+	} // end charToEntity
 
-    public static String getShortDetails( CacheHolder ch ) {
-    	StringBuffer strBuf = new StringBuffer(7);
-    	strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());			
-    	if (!ch.isAddiWpt()) {
-   			strBuf.append(ch.getHard());
-   			strBuf.append("/");
-   			strBuf.append(ch.getTerrain());
-    		strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
-    	}
+	public static String simplifyString(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(50);
+		int charsToAppend = 0;
+		for (int i = 0; i < originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = char2simpleChar(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
-    	return strBuf.toString();
-    }
+	public static String getShortDetails(CacheHolder ch) {
+		StringBuffer strBuf = new StringBuffer(7);
+		strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());
+		if (!ch.isAddiWpt()) {
+			strBuf.append(ch.getHard());
+			strBuf.append("/");
+			strBuf.append(ch.getTerrain());
+			strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
+		}
 
+		return strBuf.toString();
+	}
+
 }

Modified: branches/r1.2/src/CacheWolf/exp/GpxExportNg.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/GpxExportNg.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/GpxExportNg.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.Attribute;
@@ -85,12 +85,11 @@
 import ewe.util.zip.ZipFile;
 
 /**
- * experimental GPX exporter that should better handle the various tasks that
- * can be accomplished with GPX
+ * experimental GPX exporter that should better handle the various tasks that can be accomplished with GPX
  */
 public class GpxExportNg {
 	/** new line */
-	final static String newLine="\r\n";
+	final static String newLine = "\r\n";
 	/** decimal separator for lat- and lon-String */
 	// final static char decimalSeparator='.';
 	/** export is in compact format */
@@ -119,7 +118,7 @@
 	final static String FALSE = "False";
 	/** object used to determine custom symbols and POI categories */
 	private static GarminMap poiMapper = new GarminMap();
-	/** maximum number of logs to export. can be overwritten with preferences, default unlimited*/
+	/** maximum number of logs to export. can be overwritten with preferences, default unlimited */
 	private int maxLogs = ewe.math.Number.INTEGER_MAX_VALUE;
 	/** number of errors / warnings during export */
 	private int exportErrors = 0;
@@ -127,35 +126,48 @@
 	private String finderid;
 
 	// we need to fake desc to make clients like GSAK accept additional waypoints together with caches
-	final static String GPXHEADER = "<?xml version=\"1.0\" encoding=\"utf-8\"?>"+(newLine)
-			+("<gpx xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" version=\"1.0\" creator=\"CacheWolf\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0 http://www.groundspeak.com/cache/1/0/cache.xsd\" xmlns=\"http://www.topografix.com/GPX/1/0\">")+(newLine)
-			+("<name>@@NAME@@</name>")+(newLine)
-			+("<desc>This is an individual cache generated from Geocaching.com</desc>")+(newLine)
-			+("<author>Various users from geocaching.com and/or opencaching.de</author>")+(newLine)
-			+("<email>contact at cachewolf.de</email>")+(newLine)
-			+("<url>http://www.cachewolf.de/</url>")+(newLine)
-			+("<urlname>CacheWolf - Paperless Geocaching</urlname>")+(newLine)
-			+("<time>@@CREATEDATE@@T07:00:00Z</time>")+(newLine)
-			+("<keywords>cache, geocache, waypoints</keywords>")+(newLine)
+	final static String GPXHEADER = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" + (newLine)//
+			+ ("<gpx")//
+			+ (" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"")//
+			+ (" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"")//
+			+ (" version=\"1.0\"")//
+			+ (" creator=\"CacheWolf\"")//
+			+ (" xsi:schemaLocation=\"")//
+			+ ("http://www.topografix.com/GPX/1/0 ")//
+			+ ("http://www.topografix.com/GPX/1/0/gpx.xsd ")//
+			+ ("http://www.groundspeak.com/cache/1/0/1 ")//
+			+ ("http://www.groundspeak.com/cache/1/0/1/cache.xsd")//
+			+ ("\"")//
+			+ (" xmlns=\"http://www.topografix.com/GPX/1/0\"")//
+			+ (">")//
+			+ (newLine)//
+			+ ("<name>@@NAME@@</name>") + (newLine)//
+			+ ("<desc>This is an individual cache generated from Geocaching.com</desc>") + (newLine)//
+			+ ("<author>Various users from geocaching.com and/or opencaching.de</author>") + (newLine)//
+			+ ("<email>contact at cachewolf.de</email>") + (newLine)//
+			+ ("<url>http://www.cachewolf.de/</url>") + (newLine)//
+			+ ("<urlname>CacheWolf - Paperless Geocaching</urlname>") + (newLine)//
+			+ ("<time>@@CREATEDATE@@T07:00:00Z</time>") + (newLine)//
+			+ ("<keywords>cache, geocache, waypoints</keywords>") + (newLine)//
 	// TODO: is it worth a second loop?
 	// +("<bounds minlat=\"50.91695\" minlon=\"6.876383\" maxlat=\"50.935183\" maxlon=\"6.918817\" />")
 	;
 
-	final static String GPXLOG = "\t\t\t\t<groundspeak:log id=\"@@LOGID@@\">"+(newLine)
-			+("\t\t\t\t\t<groundspeak:date>@@LOGDATE@@T00:00:00</groundspeak:date>")+(newLine)
-			+("\t\t\t\t\t<groundspeak:type>@@LOGTYPE@@</groundspeak:type>")+(newLine)
-			+("\t\t\t\t\t<groundspeak:finder id=\"@@LOGFINDERID@@\">@@LOGFINDER@@</groundspeak:finder>")+(newLine)
-			+("\t\t\t\t\t<groundspeak:text encoded=\"@@LOGENCODE@@\">@@LOGTEXT@@</groundspeak:text>")+(newLine)
-			+("\t\t\t\t</groundspeak:log>")+(newLine);
+	final static String GPXLOG = "\t\t\t\t<groundspeak:log id=\"@@LOGID@@\">" + (newLine)//
+			+ ("\t\t\t\t\t<groundspeak:date>@@LOGDATE@@T00:00:00</groundspeak:date>") + (newLine)//
+			+ ("\t\t\t\t\t<groundspeak:type>@@LOGTYPE@@</groundspeak:type>") + (newLine)//
+			+ ("\t\t\t\t\t<groundspeak:finder id=\"@@LOGFINDERID@@\">@@LOGFINDER@@</groundspeak:finder>") + (newLine)//
+			+ ("\t\t\t\t\t<groundspeak:text encoded=\"@@LOGENCODE@@\">@@LOGTEXT@@</groundspeak:text>") + (newLine)//
+			+ ("\t\t\t\t</groundspeak:log>") + (newLine);//
 
-	final static String GPXTB = "\t\t\t\t<groundspeak:travelbug id=\"@@TBID@@\" ref=\"@@TBREF@@\">"+(newLine)
-			+("\t\t\t\t\t<groundspeak:name>@@TBNAME@@</groundspeak:name>")+(newLine)
-			+("\t\t\t\t</groundspeak:travelbug>")+(newLine);
+	final static String GPXTB = "\t\t\t\t<groundspeak:travelbug id=\"@@TBID@@\" ref=\"@@TBREF@@\">" + (newLine)//
+			+ ("\t\t\t\t\t<groundspeak:name>@@TBNAME@@</groundspeak:name>") + (newLine)//
+			+ ("\t\t\t\t</groundspeak:travelbug>") + (newLine);//
 
 	// FIXME: don't use this until GPX import can strip this off as well
-	final static String GPXADDIINMAIN = "@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@"
-			+("@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@")
-			+("@@ADDILONG@@@@ADDIDELIM@@");
+	final static String GPXADDIINMAIN = "@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@"//
+			+ ("@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@")//
+			+ ("@@ADDILONG@@@@ADDIDELIM@@");//
 
 	private static boolean customIcons;
 	private static boolean sendToGarmin;
@@ -171,16 +183,18 @@
 	private static String bitmapFileName;
 
 	public GpxExportNg() {
-		bitmapFileName = FileBase.getProgramDirectory() + "/exporticons/GarminPOI.zip"; //own version
-		if (!(hasBitmaps=new File(bitmapFileName).exists())) {
-			bitmapFileName=FileBase.getProgramDirectory() + "/exporticons/exporticons/GarminPOI.zip"; //cw default version
-			hasBitmaps=new File(bitmapFileName).exists();			
+		bitmapFileName = FileBase.getProgramDirectory() + "/exporticons/GarminPOI.zip"; // own version
+		if (!(hasBitmaps = new File(bitmapFileName).exists())) {
+			// cw default version
+			bitmapFileName = FileBase.getProgramDirectory() + "/exporticons/exporticons/GarminPOI.zip";
+			hasBitmaps = new File(bitmapFileName).exists();
 		}
 
 		hasGpsbabel = Global.getPref().gpsbabel != null;
 
 		finderid = Global.getPref().gcMemberId;
-		if (finderid.equals("")) Global.getPref().log("GPX Export: warning gcmemberid not set, check pref.xml",null);
+		if (finderid.equals(""))
+			Global.getPref().log("GPX Export: warning gcmemberid not set, check pref.xml", null);
 	}
 
 	public void doit() {
@@ -211,11 +225,9 @@
 			ZipFile poiZip = null;
 
 			if (exportTarget == OUTPUT_POI) {
-				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,
-						Global.getPref().getExportPath(expName + "-POI"));
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getExportPath(expName + "-POI"));
 			} else {
-				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,
-						Global.getPref().getExportPath(expName + "-GPI"));
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getExportPath(expName + "-GPI"));
 			}
 
 			fc.setTitle("Select target directory:");
@@ -231,9 +243,8 @@
 			}
 
 			if (!poiMapper.exists) {
-				Global.getPref().log("GPX Export: unable to load garminmap.xml",null);
-				new MessageBox("Export Error", "unable to load garminmap.xml",
-						FormBase.OKB).execute();
+				Global.getPref().log("GPX Export: unable to load garminmap.xml", null);
+				new MessageBox("Export Error", "unable to load garminmap.xml", FormBase.OKB).execute();
 				return;
 			}
 
@@ -245,12 +256,12 @@
 				tempDir = outDir;
 				String tmp[] = new FileBugfix(tempDir).list(prefix + "*.gpx", ewe.io.FileBase.LIST_FILES_ONLY);
 				for (int i = 0; i < tmp.length; i++) {
-					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+					FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 					tmpFile.delete();
 				}
 				tmp = new FileBugfix(tempDir).list(prefix + "*.bmp", ewe.io.FileBase.LIST_FILES_ONLY);
 				for (int i = 0; i < tmp.length; i++) {
-					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+					FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 					tmpFile.delete();
 				}
 			}
@@ -273,30 +284,22 @@
 					if (!ch.isVisible()) {
 						continue;
 					} else if (ch.is_incomplete()) {
-						Global.getPref().log(
-								"skipping export of incomplete waypoint "
-								+ ch.getWayPoint(),null);
+						Global.getPref().log("skipping export of incomplete waypoint " + ch.getWayPoint(), null);
 					} else {
 						String poiId = poiMapper.getPoiId(ch);
 						if (null == poiId) {
-							Global.getPref().log(
-									"GPX Export: unmatched POI ID for "
-									+ ch.getWayPoint() + " of type "
-									+ ch.getType(),null);
+							Global.getPref().log("GPX Export: unmatched POI ID for " + ch.getWayPoint() + " of type " + ch.getType(), null);
 							exportErrors++;
 						} else {
 							PrintWriter writer;
 							if (fileHandles.containsKey(poiId)) {
 								writer = (PrintWriter) fileHandles.get(poiId);
 							} else {
-								writer = new PrintWriter(new BufferedWriter(
-										new FileWriter(new File(tempDir
-												+ FileBase.separator + prefix
-												+ poiId + ".gpx"))));
+								writer = new PrintWriter(new BufferedWriter(new FileWriter(new File(tempDir + FileBase.separator + prefix + poiId + ".gpx"))));
 								fileHandles.put(poiId, writer);
 								writer.print(formatHeader());
 							}
-							String strOut=formatCache(ch);
+							String strOut = formatCache(ch);
 							if (!strOut.equals("")) {
 								writer.print(strOut);
 							}
@@ -318,16 +321,15 @@
 				if (exportTarget == OUTPUT_POI) {
 					// only clean up output directory if user has chosen non empty prefix,
 					// since otherwise all present POI would be deleted
-					if (! prefix.equals("")) {
-						String tmp[] = new FileBugfix(outDir).list(
-								prefix + "*.gpi", ewe.io.FileBase.LIST_FILES_ONLY);
+					if (!prefix.equals("")) {
+						String tmp[] = new FileBugfix(outDir).list(prefix + "*.gpi", ewe.io.FileBase.LIST_FILES_ONLY);
 						for (int i = 0; i < tmp.length; i++) {
 							FileBugfix tmpFile = new FileBugfix(outDir + FileBase.separator + tmp[i]);
 							tmpFile.delete();
 						}
 					}
 					pbf.exit(0);
-					poiCategories=fileHandles.size();
+					poiCategories = fileHandles.size();
 					pbf.setTask(h, "Transfer");
 					pbf.exec();
 				}
@@ -338,7 +340,7 @@
 					String key = (String) keys.nextElement();
 					PrintWriter writer = (PrintWriter) fileHandles.get(key);
 
-					writer.print("</gpx>"+newLine);
+					writer.print("</gpx>" + newLine);
 					writer.close();
 					if (exportTarget == OUTPUT_POI) {
 						poiCounter++;
@@ -353,42 +355,35 @@
 
 						if (exportTarget == OUTPUT_POI) {
 							String[] cmdStack = new String[9];
-							cmdStack[0]=Global.getPref().gpsbabel;
-							cmdStack[1]="-i";
-							cmdStack[2]="gpx";
-							cmdStack[3]="-f";
-							cmdStack[4]=tempDir + FileBase.separator + prefix + key + ".gpx";
-							cmdStack[5]="-o";
-							cmdStack[6]="garmin_gpi,sleep=1,category="+prefix + key+",bitmap="+tempDir + FileBase.separator + prefix + key	+ ".bmp";
-							cmdStack[7]="-F";
-							cmdStack[8]=outDir + FileBase.separator + prefix + key + ".gpi";
+							cmdStack[0] = Global.getPref().gpsbabel;
+							cmdStack[1] = "-i";
+							cmdStack[2] = "gpx";
+							cmdStack[3] = "-f";
+							cmdStack[4] = tempDir + FileBase.separator + prefix + key + ".gpx";
+							cmdStack[5] = "-o";
+							cmdStack[6] = "garmin_gpi,sleep=1,category=" + prefix + key + ",bitmap=" + tempDir + FileBase.separator + prefix + key + ".bmp";
+							cmdStack[7] = "-F";
+							cmdStack[8] = outDir + FileBase.separator + prefix + key + ".gpi";
 
-							Process babelProcess = startProcess(cmdStack);
+							Process babelProcess = null;
+							babelProcess = startProcess(cmdStack);
 							StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
-							while (errorStream.isOpen()) {
-								String errorMsg = errorStream.readALine();
-								if (errorMsg != null) {
-									Global.getPref().log("GPX Export: " + errorMsg,null);
-									exportErrors++;
-								}
-								try {
-									babelProcess.exitValue();
-									errorStream.close();
-								} catch (IllegalThreadStateException e) {
-									// still running
-								}
+							babelProcess.waitFor();
+							String errorMsg = errorStream.readALine();
+							if (errorMsg != null) {
+								Global.getPref().log("GPX Export: " + errorMsg, null);
+								exportErrors++;
 							}
+							errorStream.close();
 						}
-
 					}
 				}
 
 				if (exportTarget == OUTPUT_POI) {
 					FileBugfix tmpdir = new FileBugfix(tempDir);
-					String tmp[] = new FileBugfix(tempDir).list(prefix + "*.*",
-							ewe.io.FileBase.LIST_FILES_ONLY);
+					String tmp[] = new FileBugfix(tempDir).list(prefix + "*.*", ewe.io.FileBase.LIST_FILES_ONLY);
 					for (int i = 0; i < tmp.length; i++) {
-						FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+						FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 						tmpFile.delete();
 					}
 					tmpdir.delete();
@@ -405,7 +400,7 @@
 			if (customIcons) {
 				if (!poiMapper.exists) {
 					customIcons = false;
-					Global.getPref().log("unable to load garminmap.xml",null);
+					Global.getPref().log("unable to load garminmap.xml", null);
 				}
 			}
 
@@ -420,8 +415,7 @@
 			final File file;
 
 			if (!sendToGarmin) {
-				final FileChooser fc = new FileChooser(FileChooserBase.SAVE,
-						Global.getPref().getExportPath(expName + "-GPX"));
+				final FileChooser fc = new FileChooser(FileChooserBase.SAVE, Global.getPref().getExportPath(expName + "-GPX"));
 
 				fc.setTitle("Select target GPX file:");
 				fc.addMask("*.gpx");
@@ -430,8 +424,7 @@
 					return;
 
 				file = fc.getChosenFile();
-				Global.getPref()
-						.setExportPath(expName + "-GPX", file.getPath());
+				Global.getPref().setExportPath(expName + "-GPX", file.getPath());
 			} else {
 				file = new File("").createTempFile("gpxexport", null, null);
 			}
@@ -446,12 +439,12 @@
 
 				outp.print(formatHeader());
 
-				//pbf.showMainTask = false;
-				//pbf.setTask(h, "Exporting ...");
-				//pbf.exec();
-				//h.progressResolution=0;
+				// pbf.showMainTask = false;
+				// pbf.setTask(h, "Exporting ...");
+				// pbf.exec();
+				// h.progressResolution=0;
 
-				Global.getPref().log("start: "+new Time().getTime());
+				Global.getPref().log("start: " + new Time().getTime());
 				CacheDB cDB = Global.getProfile().cacheDB;
 				for (int i = 0; i < cDB.size(); i++) {
 					CacheHolder ch = cDB.get(i);
@@ -459,68 +452,60 @@
 						continue;
 					} else if (ch.is_incomplete()) {
 						exportErrors++;
-						Global.getPref().log("GPX Export: skipping export of incomplete waypoint " + ch.getWayPoint(),null);
+						Global.getPref().log("GPX Export: skipping export of incomplete waypoint " + ch.getWayPoint(), null);
 					} else {
-						String strOut=formatCache(ch);
+						String strOut = formatCache(ch);
 						if (!strOut.equals("")) {
 							outp.print(strOut);
 							expCount++;
 						}
 					}
-					
-					//h.progress = expCount / totalCount;
-					//h.changed();
-					
-					if (Global.mainTab.statBar!=null) Global.mainTab.statBar.updateDisplay(" "+((expCount * 100) / totalCount)+"% ");
+
+					// h.progress = expCount / totalCount;
+					// h.changed();
+
+					if (Global.mainTab.statBar != null)
+						Global.mainTab.statBar.updateDisplay(" " + ((expCount * 100) / totalCount) + "% ");
 				}
 
-				Global.getPref().log("stop: "+new Time().getTime());
-				if (Global.mainTab.statBar!=null) Global.mainTab.statBar.updateDisplay("done:"+expCount);
+				Global.getPref().log("stop: " + new Time().getTime());
+				if (Global.mainTab.statBar != null)
+					Global.mainTab.statBar.updateDisplay("done:" + expCount);
 				// pbf.exit(0);
 
-				outp.print("</gpx>"+newLine);
+				outp.print("</gpx>" + newLine);
 				outp.close();
 			} catch (Exception ex) {
 				exportErrors++;
 				Global.getPref().log("GPX Export: unable to write output to " + file.toString(), ex, true);
-				new MessageBox("Export Error", "unable to write output to "	+ file.toString(), FormBase.OKB).execute();
+				new MessageBox("Export Error", "unable to write output to " + file.toString(), FormBase.OKB).execute();
 				return;
-			}
-			finally {
+			} finally {
 				Vm.showWait(false);
 			}
 
-
 			if (sendToGarmin) {
 				try {
 					String[] cmdStack = new String[9];
-					cmdStack[0]=Global.getPref().gpsbabel;
-					cmdStack[1]="-i";
-					cmdStack[2]="gpx";
-					cmdStack[3]="-f";
-					cmdStack[4]=file.getCreationName();
-					cmdStack[5]="-o";
-					cmdStack[6]="garmin";
-					cmdStack[7]="-F";
-					cmdStack[8]=Global.getPref().garminConn+(":");
-
-					Process babelProcess = this.startProcess(cmdStack);
-					if (babelProcess != null) {
-						StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
-						while (errorStream.isOpen()) {
-							String errorMsg = errorStream.readALine();
-							if (errorMsg != null) {
-								Global.getPref().log("[GPX Export:sendToGarmin] " + errorMsg,null);
-								exportErrors++;
-							}
-							try {
-								babelProcess.exitValue();
-								errorStream.close();
-							} catch (IllegalThreadStateException e) {
-								// still running
-							}
-						}
+					cmdStack[0] = Global.getPref().gpsbabel;
+					cmdStack[1] = "-i";
+					cmdStack[2] = "gpx";
+					cmdStack[3] = "-f";
+					cmdStack[4] = file.getCreationName();
+					cmdStack[5] = "-o";
+					cmdStack[6] = "garmin";
+					cmdStack[7] = "-F";
+					cmdStack[8] = Global.getPref().garminConn + (":");
+					Process babelProcess = null;
+					babelProcess = startProcess(cmdStack);
+					StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
+					babelProcess.waitFor();
+					String errorMsg = errorStream.readALine();
+					if (errorMsg != null) {
+						Global.getPref().log("GPX Export: " + errorMsg, null);
+						exportErrors++;
 					}
+					errorStream.close();
 				} catch (Exception ex) {
 					Global.getPref().log("GPX Export error :", ex, true);
 				}
@@ -528,13 +513,13 @@
 			}
 		}
 		if (exportErrors > 0) {
-			new MessageBox("Export Error", exportErrors	+ " errors during export. Check log for details.",
-					FormBase.OKB).execute();
+			new MessageBox("Export Error", exportErrors + " errors during export. Check log for details.", FormBase.OKB).execute();
 		}
 	}
 
 	/**
 	 * wrapper for formatting a cache. will call some subroutines to do the actual work
+	 * 
 	 * @param ch
 	 * @return
 	 */
@@ -543,7 +528,7 @@
 		if ((STYLE_GPX_MYFINDS == exportStyle) && (ch.isCustomWpt() || ch.isAddiWpt() || !ch.is_found()))
 			return "";
 
-		if (!ch.pos.isValid()) {
+		if (!ch.getPos().isValid()) {
 			Global.getPref().log("[GPX Export:formatCache] " + ch.getWayPoint() + " has invalid coords.");
 			return "";
 		}
@@ -560,12 +545,12 @@
 			ret.append("  </wpt>").append(newLine);
 		} catch (IllegalArgumentException e) {
 			exportErrors++;
-			ch.checkIncomplete();  // ch.setIncomplete(true);
-			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " check incomplete ",	e, true);
+			ch.checkIncomplete(); // ch.setIncomplete(true);
+			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " check incomplete ", e, true);
 			return "";
 		} catch (Exception e) {
 			exportErrors++;
-			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " caused ", e,	true);
+			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " caused ", e, true);
 			return "";
 		}
 
@@ -574,6 +559,7 @@
 
 	/**
 	 * generate minimal waypoint information according to GPX specification
+	 * 
 	 * @param ch
 	 * @return
 	 */
@@ -581,23 +567,23 @@
 
 		StringBuffer ret = new StringBuffer();
 
-//			.append("\t\t<desc>@@WPDESC@@</desc>").append(newLine)
+		// .append("\t\t<desc>@@WPDESC@@</desc>").append(newLine)
 
-		ret.append("  <wpt lat=\""+ch.pos.getLatDeg(CWPoint.DD)+"\" lon=\""+ch.pos.getLonDeg(CWPoint.DD)+"\">").append(newLine);
+		ret.append("  <wpt lat=\"" + ch.getPos().getLatDeg(CWPoint.DD) + "\" lon=\"" + ch.getPos().getLonDeg(CWPoint.DD) + "\">").append(newLine);
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
 			if (ch.isAddiWpt()) {
 				try {
-					ret.append("    <time>"+ch.mainCache.getDateHidden()+"T07:00:00Z</time>").append(newLine);
+					ret.append("    <time>" + ch.mainCache.getDateHidden() + "T07:00:00Z</time>").append(newLine);
 				} catch (Exception e) {
-					Global.getPref().log(ch.getWayPoint() + " has no parent",null);
+					Global.getPref().log(ch.getWayPoint() + " has no parent", null);
 					exportErrors++;
 					ret.append("    <time>1970-01-01T00:00:00</time>").append(newLine);
 				}
 			} else if (ch.isCustomWpt()) {
 				ret.append("    <time>1970-01-01T00:00:00</time>").append(newLine);
 			} else {
-				ret.append("    <time>"+ch.getDateHidden()+"T00:00:00</time>").append(newLine);
+				ret.append("    <time>" + ch.getDateHidden() + "T00:00:00</time>").append(newLine);
 			}
 		}
 
@@ -607,13 +593,13 @@
 			} else if (ch.isCustomWpt()) {
 				ret.append("    <name>").append(SafeXML.cleanGPX(ch.getWayPoint())).append("</name>").append(newLine);
 			} else {
-				ret.append("    <name>").append(SafeXML.cleanGPX(ch.getWayPoint()))
-						.append(" ")
-						.append(CacheType.getExportShortId(ch.getType()))
-						.append(String.valueOf(ch.getHard()))
-						.append(String.valueOf(ch.getTerrain()))
-						.append(CacheSize.getExportShortId(ch.getCacheSize()))
-						.append(String.valueOf(ch.getNoFindLogs()))
+				ret.append("    <name>").append(SafeXML.cleanGPX(ch.getWayPoint()))//
+						.append(" ")//
+						.append(CacheType.getExportShortId(ch.getType()))//
+						.append(String.valueOf(ch.getHard()))//
+						.append(String.valueOf(ch.getTerrain()))//
+						.append(CacheSize.getExportShortId(ch.getCacheSize()))//
+						.append(String.valueOf(ch.getNoFindLogs()))//
 						.append("</name>").append(newLine);
 			}
 		} else if (exportIds == WPNAME_NAME_SMART) {
@@ -642,17 +628,17 @@
 		if (ch.isAddiWpt() || ch.isCustomWpt()) {
 			ret.append("    <desc>").append(SafeXML.cleanGPX(ch.getCacheName())).append("</desc>").append(newLine);
 		} else {
-			ret.append("    <desc>").append(SafeXML.cleanGPX(ch.getCacheName()))
-					.append(" by ")
-					.append(SafeXML.cleanGPX(ch.getCacheOwner()))
-					.append(", ")
-					.append(CacheType.type2GSTypeTag(ch.getType()))
-					.append(" (")
-					.append(CacheTerrDiff.shortDT(ch.getHard()))
-					.append("/")
-					.append(CacheTerrDiff.shortDT(ch.getTerrain()))
-					.append(")")
-					.append("</desc>").append(newLine);					
+			ret.append("    <desc>").append(SafeXML.cleanGPX(ch.getCacheName()))//
+					.append(" by ")//
+					.append(SafeXML.cleanGPX(ch.getCacheOwner()))//
+					.append(", ")//
+					.append(CacheType.type2GSTypeTag(ch.getType()))//
+					.append(" (")//
+					.append(CacheTerrDiff.shortDT(ch.getHard()))//
+					.append("/")//
+					.append(CacheTerrDiff.shortDT(ch.getTerrain()))//
+					.append(")")//
+					.append("</desc>").append(newLine);
 		}
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
@@ -685,40 +671,47 @@
 
 	/**
 	 * format gc.com extended cache information as found in a PQ
-	 * @param ch cacheholder
-	 * @return formatted cache information for cache waypoints or emty string for all other waypoints (additional / custom)
+	 * 
+	 * @param ch
+	 *            cacheholder
+	 * @return formatted cache information for cache waypoints or emty string for all other waypoints (additional /
+	 *         custom)
 	 */
 	private String formatPqExtensions(CacheHolder ch) {
 
-		// no  details for addis or custom waypoints
+		// no details for addis or custom waypoints
 		if (ch.isCustomWpt() || ch.isAddiWpt())
 			return "";
 		StringBuffer ret = new StringBuffer();
-		ret.append("    <groundspeak:cache id=\"").append(ch.GetCacheID()).append("\" available=\"").append(ch.is_available() ? TRUE : FALSE).append("\" archived=\"").append(ch.is_archived() ? TRUE : FALSE).append("\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">").append(newLine)
-		.append("      <groundspeak:name>").append(SafeXML.cleanGPX(ch.getCacheName())).append("</groundspeak:name>").append(newLine)
-		.append("      <groundspeak:placed_by>").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</groundspeak:placed_by>").append(newLine)
-		.append("      <groundspeak:owner id=\"").append("31415").append("\">").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</groundspeak:owner>").append(newLine)
-		.append("      <groundspeak:type>").append(CacheType.type2GSTypeTag(ch.getType())).append("</groundspeak:type>").append(newLine)
-		.append("      <groundspeak:container>").append(CacheSize.cw2ExportString(ch.getCacheSize())).append("</groundspeak:container>").append(newLine)
-		.append("      <groundspeak:attributes>").append(newLine)
-		.append(formatAttributes(ch))
-		.append("      </groundspeak:attributes>").append(newLine)
-		.append("      <groundspeak:difficulty>").append(CacheTerrDiff.shortDT(ch.getHard())).append("</groundspeak:difficulty>").append(newLine)
-		.append("      <groundspeak:terrain>").append(CacheTerrDiff.shortDT(ch.getTerrain())).append("</groundspeak:terrain>").append(newLine)
-		.append("      <groundspeak:country>").append(SafeXML.cleanGPX(ch.getCacheDetails(true).Country)).append("</groundspeak:country>").append(newLine)
-		.append("      <groundspeak:state>").append(SafeXML.cleanGPX(ch.getCacheDetails(true).State)).append("</groundspeak:state>").append(newLine)
-		.append("      <groundspeak:short_description html=\"").append(ch.is_HTML() ? TRUE : FALSE).append("\"></groundspeak:short_description>").append(newLine)
-		.append("      <groundspeak:long_description html=\"").append(ch.is_HTML() ? TRUE : FALSE).append("\">").append(SafeXML.cleanGPX(formatLongDescription(ch))).append("</groundspeak:long_description>").append(newLine)
-		.append("      <groundspeak:encoded_hints>").append(SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints))).append("</groundspeak:encoded_hints>").append(newLine)
-		.append("      <groundspeak:logs>").append(newLine)
-		.append(formatLogs(ch))
-		.append("      </groundspeak:logs>").append(newLine)
-		.append("      <groundspeak:travelbugs>").append(newLine)
-		.append(formatTbs(ch))
-		.append("      </groundspeak:travelbugs>").append(newLine)
-		.append("    </groundspeak:cache>").append(newLine);
+		ret.append("    <groundspeak:cache id=\"").append(ch.GetCacheID())//
+				.append("\" available=\"").append(ch.is_available() ? TRUE : FALSE)//
+				.append("\" archived=\"").append(ch.is_archived() ? TRUE : FALSE)//
+				.append("\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">").append(newLine)//
+				.append("      <groundspeak:name>").append(SafeXML.cleanGPX(ch.getCacheName())).append("</groundspeak:name>").append(newLine)//
+				.append("      <groundspeak:placed_by>").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</groundspeak:placed_by>").append(newLine)//
+				.append("      <groundspeak:owner id=\"").append("31415").append("\">").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</groundspeak:owner>").append(newLine)//
+				.append("      <groundspeak:type>").append(CacheType.type2GSTypeTag(ch.getType())).append("</groundspeak:type>").append(newLine)//
+				.append("      <groundspeak:container>").append(CacheSize.cw2ExportString(ch.getCacheSize())).append("</groundspeak:container>").append(newLine)//
+				.append("      <groundspeak:attributes>").append(newLine)//
+				.append(formatAttributes(ch))//
+				.append("      </groundspeak:attributes>").append(newLine)//
+				.append("      <groundspeak:difficulty>").append(CacheTerrDiff.shortDT(ch.getHard())).append("</groundspeak:difficulty>").append(newLine)//
+				.append("      <groundspeak:terrain>").append(CacheTerrDiff.shortDT(ch.getTerrain())).append("</groundspeak:terrain>").append(newLine)//
+				.append("      <groundspeak:country>").append(SafeXML.cleanGPX(ch.getCacheDetails(true).Country)).append("</groundspeak:country>").append(newLine)//
+				.append("      <groundspeak:state>").append(SafeXML.cleanGPX(ch.getCacheDetails(true).State)).append("</groundspeak:state>").append(newLine)//
+				.append("      <groundspeak:short_description html=\"").append(ch.is_HTML() ? TRUE : FALSE).append("\"></groundspeak:short_description>").append(newLine)//
+				.append("      <groundspeak:long_description html=\"").append(ch.is_HTML() ? TRUE : FALSE).append("\">").append(SafeXML.cleanGPX(formatLongDescription(ch))).append("</groundspeak:long_description>").append(newLine)//
+				.append("      <groundspeak:encoded_hints>").append(SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints))).append("</groundspeak:encoded_hints>").append(newLine)//
+				.append("      <groundspeak:logs>").append(newLine)//
+				.append(formatLogs(ch))//
+				.append("      </groundspeak:logs>").append(newLine)//
+				.append("      <groundspeak:travelbugs>").append(newLine)//
+				.append(formatTbs(ch))//
+				.append("      </groundspeak:travelbugs>").append(newLine)//
+				.append("    </groundspeak:cache>").append(newLine);//
 		return ret.toString();
 	}
+
 	/**
 	 * 
 	 */
@@ -726,93 +719,97 @@
 		StringBuffer ret = new StringBuffer();
 		Travelbug Tb;
 		for (int i = 0; i < ch.getCacheDetails(true).Travelbugs.size(); i++) {
-			Tb=ch.getCacheDetails(true).Travelbugs.getTB(i);
-			ret.append("        <groundspeak:travelbug id=\"").
-			append(Integer.toString(i)).
-			append("\" ref=\"TB\">").
-			// append(newLine).
-			// append("          <groundspeak:name>").
-			append("<groundspeak:name>").
-			append(SafeXML.cleanGPX(Tb.getName())).
-			append("</groundspeak:name>").
-			// append(newLine).
-			// append("        </groundspeak:travelbug>\r\n");
-			append("</groundspeak:travelbug>\r\n");
+			Tb = ch.getCacheDetails(true).Travelbugs.getTB(i);
+			ret.append("        <groundspeak:travelbug id=\"").//
+					append(Integer.toString(i)).//
+					append("\" ref=\"TB\">").//
+					// append(newLine).//
+					// append(" <groundspeak:name>").//
+					append("<groundspeak:name>").//
+					append(SafeXML.cleanGPX(Tb.getName())).//
+					append("</groundspeak:name>").//
+					// append(newLine).//
+					// append(" </groundspeak:travelbug>\r\n");//
+					append("</groundspeak:travelbug>\r\n");//
 		}
 		return ret.toString();
 	}
+
 	/**
 	 * 
 	 */
-	private String formatAttributes(CacheHolder ch){
+	private String formatAttributes(CacheHolder ch) {
 		StringBuffer ret = new StringBuffer();
 		Attribute attrib;
 		for (int i = 0; i < ch.getCacheDetails(true).attributes.count(); i++) {
 			// <groundspeak:attribute id="X" inc="Y">text f?r X</groundspeak:attribute>
-			attrib=ch.getCacheDetails(true).attributes.getAttribute(i);
-			ret.append("        <groundspeak:attribute id=\"").
-			append(attrib.getGCId()).
-			append("\" inc=\"").
-			append(attrib.getInc()).
-			append("\">").
-			append(attrib.getGCText()).
-			append("</groundspeak:attribute>").
-			append(newLine);
+			attrib = ch.getCacheDetails(true).attributes.getAttribute(i);
+			if (attrib.getGCId().length() > 0) {
+				ret.append("        <groundspeak:attribute id=\"").//
+						append(attrib.getGCId()).//
+						append("\" inc=\"").//
+						append(attrib.getInc()).//
+						append("\">").//
+						append(attrib.getGCText()).//
+						append("</groundspeak:attribute>").//
+						append(newLine);//
+			}
 		}
 		return ret.toString();
 	}
+
 	/**
 	 * format cache logs as found in a gc.com GPX file
-	 * @param ch CacheHolder containing the logs
+	 * 
+	 * @param ch
+	 *            CacheHolder containing the logs
 	 * @return formatted logs or empty string if no logs are present
 	 */
 	private String formatLogs(CacheHolder ch) {
-		CacheHolderDetail chD=ch.getCacheDetails(false);
+		CacheHolderDetail chD = ch.getCacheDetails(false);
 		LogList logs = chD.CacheLogs;
 		StringBuffer ret = new StringBuffer();
 		int exportlogs;
-		if (exportStyle == STYLE_GPX_PQLIKE && maxLogs < logs.size())
-			{exportlogs = maxLogs;}
-		else {exportlogs = logs.size();}
+		if (exportStyle == STYLE_GPX_PQLIKE && maxLogs < logs.size()) {
+			exportlogs = maxLogs;
+		} else {
+			exportlogs = logs.size();
+		}
 		if (exportStyle == STYLE_GPX_MYFINDS) {
 			// only own log
 			if (chD.OwnLogId.equals("") || chD.OwnLog == null) {
-				Global.getPref().log(chD.getParent().getWayPoint()+" missing own LogID", null);
-				return "";				
+				Global.getPref().log(chD.getParent().getWayPoint() + " missing own LogID", null);
+				return "";
 			}
-			addLog(chD.OwnLogId, chD.OwnLog, finderid ,ret);
-		}
-		else {
+			addLog(chD.OwnLogId, chD.OwnLog, finderid, ret);
+		} else {
 			// add log with attributes
-			if (attrib2Log){
-				addLog (ch.GetCacheID()+Integer.toString(exportlogs), createAttrLog(ch),"",ret);
+			if (attrib2Log) {
+				addLog(ch.GetCacheID() + Integer.toString(exportlogs), createAttrLog(ch), "", ret);
 			}
 			for (int i = 0; i < exportlogs; i++) {
-				addLog(ch.GetCacheID()+Integer.toString(i), logs.getLog(i),"" ,ret);
+				addLog(ch.GetCacheID() + Integer.toString(i), logs.getLog(i), "", ret);
 			}
 		}
 		return ret.toString();
 	}
+
 	private Log createAttrLog(CacheHolder ch) {
 		Attribute attrib;
 		StringBuffer logText = new StringBuffer();
 		for (int i = 0; i < ch.getCacheDetails(true).attributes.count(); i++) {
-			attrib=ch.getCacheDetails(true).attributes.getAttribute(i);
-			logText.append(attrib.getInc()==1?"Yes: ":"No: ").
-			append(attrib.getMsg()).
-			append("<br />").
-			append(newLine);
+			attrib = ch.getCacheDetails(true).attributes.getAttribute(i);
+			logText.append(attrib.getInc() == 1 ? "Yes: " : "No: ").append(attrib.getMsg()).append("<br />").append(newLine);
 		}
 		if (ch.hasNote()) {
-			logText.append(SafeXML.cleanGPX(ch.getCacheDetails(true).getCacheNotes())).
-			append("<br />").
-			append(newLine);
+			logText.append(SafeXML.cleanGPX(ch.getCacheDetails(true).getCacheNotes())).append("<br />").append(newLine);
 		}
-		if (logText.length() == 0 && !ch.getLastSync().equals("")) logText.append(MyLocale.getMsg(1051,"Last sync date"));
+		if (logText.length() == 0 && !ch.getLastSync().equals(""))
+			logText.append(MyLocale.getMsg(1051, "Last sync date"));
 		Log log = new Log("icon_note.gif", DateFormat.yyyyMMddHHmmss2gpxLogdate(ch.getLastSync()), "CacheWolf", logText.toString());
 		return log;
 	}
-	
+
 	private StringBuffer addLog(String logId, Log log, String FinderID, StringBuffer ret) {
 		Transformer trans = new Transformer(true);
 		trans.add(new Regex("@@LOGID@@", logId));
@@ -828,29 +825,35 @@
 
 	/**
 	 * format the header of the GPX file
+	 * 
 	 * @return
 	 */
 	private String formatHeader() {
-		//FIXME: extend profile to add <bounds minlat=\"50.91695\" minlon=\"6.876383\" maxlat=\"50.935183\" maxlon=\"6.918817\" />
-		//Global.getProfile().getSourroundingArea(false);
+		// FIXME: extend profile to add <bounds minlat=\"50.91695\" minlon=\"6.876383\" maxlat=\"50.935183\"
+		// maxlon=\"6.918817\" />
+		// Global.getProfile().getSourroundingArea(false);
 		Transformer trans = new Transformer(true);
 		trans.add(new Regex("@@CREATEDATE@@", new Date().setToCurrentTime().setFormat("yyyy-MM-dd").toString()));
-		if (exportStyle==STYLE_GPX_MYFINDS)
-			 {trans.add(new Regex("@@NAME@@","My Finds Pocket Query"));}
-		else {trans.add(new Regex("@@NAME@@","Waypoints for Cache Listings, Generated by CacheWolf"));}
+		if (exportStyle == STYLE_GPX_MYFINDS) {
+			trans.add(new Regex("@@NAME@@", "My Finds Pocket Query"));
+		} else {
+			trans.add(new Regex("@@NAME@@", "Waypoints for Cache Listings, Generated by CacheWolf"));
+		}
 		return trans.replaceFirst(GPXHEADER);
 		/*
-		String ret = STRreplace.replace(GPXHEADER,"@@CREATEDATE@@", new Date().setToCurrentTime().setFormat("yyyy-MM-dd").toString());
-		if (exportStyle==STYLE_GPX_MYFINDS)
-			 { ret=STRreplace.replace(ret,"@@NAME@@","My Finds Pocket Query");}
-		else { ret=STRreplace.replace(ret,"@@NAME@@","Waypoints for Cache Listings, Generated by CacheWolf");}
-		return ret;
-		*/
+		 * String ret = STRreplace.replace(GPXHEADER,"@@CREATEDATE@@", new Date().setToCurrentTime().setFormat("yyyy-MM-dd").toString());
+		 * if (exportStyle==STYLE_GPX_MYFINDS)
+		 * { ret=STRreplace.replace(ret,"@@NAME@@","My Finds Pocket Query");}
+		 * else { ret=STRreplace.replace(ret,"@@NAME@@","Waypoints for Cache Listings, Generated by CacheWolf");}
+		 * return ret;
+		 */
 	}
 
 	/**
 	 * format a long description as found in the gc.com GPX files
-	 * @param ch CacheHolder to format
+	 * 
+	 * @param ch
+	 *            CacheHolder to format
 	 * @return formatted output
 	 */
 	private String formatLongDescription(CacheHolder ch) {
@@ -881,9 +884,9 @@
 					trans.add(new Regex("@@ADDIID@@", addi.getWayPoint()));
 					trans.add(new Regex("@@ADDISHORT@@", addi.getCacheName()));
 					trans.add(new Regex("@@ADDIDELIM@@", delim));
-					trans.add(new Regex("@@ADDILAT@@",formatAddiLatLon(addi.pos)));
+					trans.add(new Regex("@@ADDILAT@@", formatAddiLatLon(addi.getPos())));
 					trans.add(new Regex("@@ADDILON@@", ""));
-					trans.add(new Regex("@@ADDILONG@@",addi.getCacheDetails(true).LongDescription));
+					trans.add(new Regex("@@ADDILONG@@", addi.getCacheDetails(true).LongDescription));
 					ret.append(trans.replaceAll(GPXADDIINMAIN));
 				}
 				ret.append(delim).append(newLine);
@@ -894,11 +897,10 @@
 
 	/**
 	 * create a position information suitable for a gc.com PQlike export
-	 *
+	 * 
 	 * @param pos
 	 *            position
-	 * @return if position is valid return the cachewolf formatted position,
-	 *         otherwise return teh string used in PQs
+	 * @return if position is valid return the cachewolf formatted position, otherwise return teh string used in PQs
 	 */
 	private String formatAddiLatLon(CWPoint pos) {
 		if (pos.isValid()) {
@@ -910,6 +912,7 @@
 
 	/**
 	 * copy the bitmap identified by <code>prefix</code> and <code>type</code> from <code>poiZip</code> to <code>outdir</code>
+	 * 
 	 * @param outdir
 	 * @param type
 	 * @param prefix
@@ -928,7 +931,7 @@
 
 			buff = new byte[icon.getSize()];
 			InputStream fis = poiZip.getInputStream(icon);
-			FileOutputStream fos = new FileOutputStream(outdir+(FileBase.separator)+prefix+type+".bmp");
+			FileOutputStream fos = new FileOutputStream(outdir + (FileBase.separator) + prefix + type + ".bmp");
 			while (0 < (len = fis.read(buff)))
 				fos.write(buff, 0, len);
 			fos.flush();
@@ -946,28 +949,31 @@
 
 	/**
 	 * Execute the command defined by cmd
-	 * @param cmd command and options to execute. if command or options include a space quatation marks are added. this will not wirk with the java version on unix systems
+	 * 
+	 * @param cmd
+	 *            command and options to execute. if command or options include a space quatation marks are added. this
+	 *            will not wirk with the java version on unix systems
 	 * @return a handle to the process on success or null otherwise
 	 */
 	Process startProcess(String[] cmd) {
 		String command = "";
 		if (cmd.length == 0) {
 			exportErrors++;
-			Global.getPref().log("GPX Export: empty gpsbabel command",null);
+			Global.getPref().log("GPX Export: empty gpsbabel command", null);
 			return null;
 		}
 
 		for (int i = 0; i < cmd.length; i++) {
 			if (cmd[i].indexOf(" ") > -1) {
-				cmd[i]="\""+cmd[i]+"\"";
+				cmd[i] = "\"" + cmd[i] + "\"";
 			}
-			command = command+cmd[i]+" ";
+			command = command + cmd[i] + " ";
 		}
 
 		try {
 			return Vm.exec(command);
 		} catch (IOException e) {
-			Global.getPref().log("error excuting "+command, e, true);
+			Global.getPref().log("error excuting " + command, e, true);
 			exportErrors++;
 			return null;
 		}
@@ -1005,32 +1011,32 @@
 			this.setTitle("GPX Export");
 			this.resizable = false;
 
-			btnOk = new mButton(MyLocale.getMsg(1605,"OK"));
-			btnCancel = new mButton(MyLocale.getMsg(1604,"Cancel"));
+			btnOk = new mButton(MyLocale.getMsg(1605, "OK"));
+			btnCancel = new mButton(MyLocale.getMsg(1604, "Cancel"));
 
 			chIds = new mChoice();
 			chIds.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chIds.addItem(MyLocale.getMsg(31415,"Classic IDs")); // index 0
-			chIds.addItem(MyLocale.getMsg(31415,"Smart IDs")); // index 1
-//			chIds.addItem(MyLocale.getMsg(31415,"Smart Names")); // index 2
+			chIds.addItem(MyLocale.getMsg(31415, "Classic IDs")); // index 0
+			chIds.addItem(MyLocale.getMsg(31415, "Smart IDs")); // index 1
+			// chIds.addItem(MyLocale.getMsg(31415,"Smart Names")); // index 2
 			chIds.select(chosenIds);
 
 			chStyle = new mChoice();
 			chStyle.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chStyle.addItem(MyLocale.getMsg(31415,"Compact")); // index 0
-			chStyle.addItem(MyLocale.getMsg(31415,"PQ like")); // index 1
-			chStyle.addItem(MyLocale.getMsg(31415,"MyFinds")); // index 2
+			chStyle.addItem(MyLocale.getMsg(31415, "Compact")); // index 0
+			chStyle.addItem(MyLocale.getMsg(31415, "PQ like")); // index 1
+			chStyle.addItem(MyLocale.getMsg(31415, "MyFinds")); // index 2
 			chStyle.select(chosenStyle);
 
 			chTarget = new mChoice();
 			chTarget.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chTarget.addItem(MyLocale.getMsg(31415,"Single GPX")); // index 0
-			chTarget.addItem(MyLocale.getMsg(31415,"Separate GPX")); // index 1
+			chTarget.addItem(MyLocale.getMsg(31415, "Single GPX")); // index 0
+			chTarget.addItem(MyLocale.getMsg(31415, "Separate GPX")); // index 1
 			if (hasBitmaps && hasGarminMap && hasGpsbabel) {
-				chTarget.addItem(MyLocale.getMsg(31415,"POI")); // index 2
+				chTarget.addItem(MyLocale.getMsg(31415, "POI")); // index 2
 			}
 			chTarget.select(chosenTarget);
 
@@ -1040,39 +1046,41 @@
 			ibMaxLogs = new mInput(String.valueOf(Global.getPref().numberOfLogsToExport));
 			ibMaxLogs.modify(ControlConstants.Disabled, 0);
 
-			cbSeperateHints = new mCheckBox(MyLocale.getMsg(31415,"Separate Hints"));
+			cbSeperateHints = new mCheckBox(MyLocale.getMsg(31415, "Separate Hints"));
 			cbSeperateHints.modify(ControlConstants.Disabled, 0);
 
-			cbSendToGarmin = new mCheckBox(MyLocale.getMsg(31415,"send to Garmin"));
-			if (!hasGpsbabel) cbSendToGarmin.modify(ControlConstants.Disabled, 0);
+			cbSendToGarmin = new mCheckBox(MyLocale.getMsg(31415, "send to Garmin"));
+			if (!hasGpsbabel)
+				cbSendToGarmin.modify(ControlConstants.Disabled, 0);
 
-			cbCustomIcons = new mCheckBox(MyLocale.getMsg(31415,"Custom Icons"));
-			if (!hasGarminMap) cbCustomIcons.modify(ControlConstants.Disabled, 0);
+			cbCustomIcons = new mCheckBox(MyLocale.getMsg(31415, "Custom Icons"));
+			if (!hasGarminMap)
+				cbCustomIcons.modify(ControlConstants.Disabled, 0);
 
-			cbAttrib2Log = new mCheckBox(MyLocale.getMsg(31415,"Attrib.->Log"));
-			
-			addNext(new mLabel(MyLocale.getMsg(31415,"GPX Style")));
+			cbAttrib2Log = new mCheckBox(MyLocale.getMsg(31415, "Attrib.->Log"));
+
+			addNext(new mLabel(MyLocale.getMsg(31415, "GPX Style")));
 			addLast(chStyle);
 
-			addNext(new mLabel(MyLocale.getMsg(31415,"WP Names")));
+			addNext(new mLabel(MyLocale.getMsg(31415, "WP Names")));
 			addLast(chIds);
 
-			addNext(new mLabel(MyLocale.getMsg(31415,"Output")));
+			addNext(new mLabel(MyLocale.getMsg(31415, "Output")));
 			addLast(chTarget);
 
 			addNext(cbCustomIcons);
 			addLast(cbSendToGarmin);
 
-//			addLast(cbSeperateHints);
+			// addLast(cbSeperateHints);
 
-            addNext(new mLabel(MyLocale.getMsg(31415,"Prefix")));
-            addLast(ibPrefix);
-            
-            addLast(cbAttrib2Log);
-            
-            addNext(new mLabel(MyLocale.getMsg(31415,"Max Logs")));
-            addLast(ibMaxLogs);
+			addNext(new mLabel(MyLocale.getMsg(31415, "Prefix")));
+			addLast(ibPrefix);
 
+			addLast(cbAttrib2Log);
+
+			addNext(new mLabel(MyLocale.getMsg(31415, "Max Logs")));
+			addLast(ibMaxLogs);
+
 			addButton(btnOk);
 			addButton(btnCancel);
 
@@ -1080,10 +1088,9 @@
 			checkTarget();
 			checkIds();
 		}
-		
+
 		/**
-		 * in  : chStyle.selectedIndex;
-		 * out : chosenStyle
+		 * in : chStyle.selectedIndex; out : chosenStyle
 		 */
 		private void checkStyle() {
 			if (chStyle.selectedIndex == 2) { // my finds export
@@ -1112,7 +1119,7 @@
 				cbAttrib2Log.state = false;
 				if (cbAttrib2Log.change(ControlConstants.Disabled, 0))
 					cbAttrib2Log.repaint();
-				
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1138,7 +1145,7 @@
 
 				if (cbAttrib2Log.change(0, ControlConstants.Disabled))
 					cbAttrib2Log.repaint();
-				
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1163,7 +1170,7 @@
 
 				if (cbAttrib2Log.change(ControlConstants.Disabled, 0))
 					cbAttrib2Log.repaint();
-		
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1177,8 +1184,7 @@
 		}
 
 		/**
-		 * in : chTarget.selectedIndex
-		 * out: chosenTarget
+		 * in : chTarget.selectedIndex out: chosenTarget
 		 */
 		private void checkTarget() {
 			if (chTarget.selectedIndex == 2) { // POI
@@ -1215,7 +1221,7 @@
 				if (hasGarminMapFrm && cbCustomIcons.change(0, ControlConstants.Disabled))
 					cbCustomIcons.repaint();
 
-				cbSeperateHints.state=false;
+				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
 
@@ -1232,10 +1238,10 @@
 			chosenTarget = chTarget.selectedIndex;
 			chosenIds = chIds.selectedIndex;
 		}
-		
+
 		/**
-		 * react to GUI events and toogle access to the checkboxes according to
-		 * radio button settings pass everything else to <code>super()</code>
+		 * react to GUI events and toogle access to the checkboxes according to radio button settings pass everything
+		 * else to <code>super()</code>
 		 */
 		public void onEvent(Event ev) {
 			if (ev instanceof DataChangeEvent && ev.type == DataChangeEvent.DATA_CHANGED) {
@@ -1279,14 +1285,16 @@
 
 		/**
 		 * amount of data to be exported
+		 * 
 		 * @return 0 Compact, 1 PQ like, 2 MyFinds
 		 */
-		private int getExportStyle () {
+		private int getExportStyle() {
 			return chosenStyle;
 		}
 
 		/**
 		 * style of waypoint identifiers
+		 * 
 		 * @return 0 Classic IDs, 1 Smart IDs, 3 Smart Names (should only be used with gpsbabel)
 		 */
 		private int getWpNameStyle() {
@@ -1295,6 +1303,7 @@
 
 		/**
 		 * what kind of output should be generated
+		 * 
 		 * @return 0 single file, 1 separate files, 2 POI (GPI) files
 		 */
 		private int getOutputTarget() {
@@ -1303,7 +1312,7 @@
 
 		/**
 		 * check if user wants to send output straight to a Garmin GPSr
-		 *
+		 * 
 		 * @return true for GPSr transfer, false otherwise
 		 */
 		private boolean getSendToGarmin() {
@@ -1312,7 +1321,7 @@
 
 		/**
 		 * check if user wants custom icons
-		 *
+		 * 
 		 * @return true if user wants custom icons, false otherwise
 		 */
 		private boolean getCustomIcons() {
@@ -1321,7 +1330,7 @@
 
 		/**
 		 * get the number of logs to export. used in PQlike export.
-		 *
+		 * 
 		 * @return number of logs to export
 		 */
 		private int getMaxLogs() {
@@ -1330,19 +1339,19 @@
 
 		/**
 		 * get prefix for separate file export
-		 *
+		 * 
 		 * @return prefix for separate file export
 		 */
 		private String getPrefix() {
 			return ibPrefix.getText();
 		}
-		
+
 		/**
 		 * check if user wants to export attributes as log
 		 * 
 		 * @return true if attributes should exported as log, false otherwise
 		 */
-		private boolean getAttrib2Log (){
+		private boolean getAttrib2Log() {
 			return cbAttrib2Log.state;
 		}
 	}

Modified: branches/r1.2/src/CacheWolf/exp/KMLExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/KMLExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/KMLExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -45,49 +45,40 @@
 import ewe.ui.ProgressBarForm;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Map.MapEntry;
 import ewe.util.Vector;
-import ewe.util.Map.MapEntry;
 import ewe.util.zip.ZipEntry;
 import ewe.util.zip.ZipException;
 import ewe.util.zip.ZipFile;
 
 /**
-*	Class to export the cache database (index) to an KML-File
-*	which can be read by Google Earth
-*
-*/
+ * Class to export the cache database (index) to an KML-File
+ * which can be read by Google Earth
+ * 
+ */
 public class KMLExporter extends Exporter {
 	private static final String COLOR_FOUND = "ff98fb98";
 	private static final String COLOR_OWNED = "ffffaa55";
 	private static final String COLOR_AVAILABLE = "ffffffff";
 	private static final String COLOR_NOT_AVAILABLE = "ff0000ff";
 
-
 	static final int AVAILABLE = 0;
 	static final int FOUND = 1;
 	static final int OWNED = 2;
 	static final int NOT_AVAILABLE = 3;
 	static final int UNKNOWN = 4;
 
-
-	String []categoryNames = {"Available","Found", "Owned", "Not Available", "UNKNOWN"};
-	Hashtable [] outCacheDB = new Hashtable[categoryNames.length];
+	String[] categoryNames = { "Available", "Found", "Owned", "Not Available", "UNKNOWN" };
+	Hashtable[] outCacheDB = new Hashtable[categoryNames.length];
 	private Profile prof;
 
-	public KMLExporter(){
+	public KMLExporter(Preferences p, Profile _prof) {
 		super();
 		this.setMask("*.kml");
-		this.setHowManyParams(LAT_LON);
+		prof = _prof;
 	}
 
-
-	public KMLExporter(Preferences p, Profile _prof){
-			super();
-			this.setMask("*.kml");
-			prof=_prof;
-	}
-
-	public void doIt(int variant){
+	public void doIt(int variant) {
 		File outFile;
 		String str;
 		CacheHolder ch;
@@ -97,13 +88,14 @@
 
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
-			if (outFile == null) return;
+			if (outFile == null)
+				return;
 		} else {
 			outFile = new File(tmpFileName);
 		}
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
+		pbf.setTask(h, "Exporting ...");
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
@@ -111,51 +103,55 @@
 		copyIcons(outFile.getParent());
 		buildOutDB();
 
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
-			str = STRreplace.replace(this.header(),"CacheWolf",prof.name);
-			if (str != null) outp.print(str);
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			str = STRreplace.replace(this.header(), "CacheWolf", prof.name);
+			if (str != null)
+				outp.print(str);
 			for (int cat = 0; cat < categoryNames.length; cat++) {
 				// skip over empty categories
-				if (outCacheDB[cat]==null) continue;
+				if (outCacheDB[cat] == null)
+					continue;
 
 				Iterator outLoop = outCacheDB[cat].entries();
 				outp.print(startFolder(categoryNames[cat]));
 
 				Vector tmp;
 				MapEntry entry;
-				while (outLoop.hasNext()){
+				while (outLoop.hasNext()) {
 					entry = (MapEntry) outLoop.next();
-					tmp = (Vector)entry.getValue();
+					tmp = (Vector) entry.getValue();
 					// skip over empty cachetypes
-					if (tmp.size() == 0) continue;
+					if (tmp.size() == 0)
+						continue;
 					outp.print(startFolder(CacheType.type2Gui(Integer.valueOf(entry.getKey().toString()).byteValue())));
 
-					for(int i = 0; i<tmp.size(); i++){
+					for (int i = 0; i < tmp.size(); i++) {
 						ch = (CacheHolder) tmp.get(i);
-						if (ch.isAddiWpt()) continue;
+						if (ch.isAddiWpt())
+							continue;
 						expCount++;
-						h.progress = (float)expCount/(float)counter;
+						h.progress = (float) expCount / (float) counter;
 						h.changed();
 
-						if (ch.pos.isValid()){
-							str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
-							if (str != null) outp.print(str);
+						if (ch.getPos().isValid()) {
+							str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+							if (str != null)
+								outp.print(str);
 						}
-						if (ch.hasAddiWpt()){
+						if (ch.hasAddiWpt()) {
 							boolean createdAdditionalWaypointsFolder = false;
-							for(int j = 0; j<ch.addiWpts.size(); j++){
+							for (int j = 0; j < ch.addiWpts.size(); j++) {
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
 								expCount++;
-								if (ch.pos.isValid() &&  addiWpt.isVisible()){
-									if (! createdAdditionalWaypointsFolder) {
+								if (ch.getPos().isValid() && addiWpt.isVisible()) {
+									if (!createdAdditionalWaypointsFolder) {
 										outp.print(startFolder("Additional Waypoints", false));
 										createdAdditionalWaypointsFolder = true;
 									}
-									str = record(addiWpt, addiWpt.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											addiWpt.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
-									if (str != null) outp.print(str);
+									str = record(addiWpt, addiWpt.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), addiWpt.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+									if (str != null)
+										outp.print(str);
 								}
 
 							}
@@ -170,17 +166,18 @@
 			}
 
 			str = trailer();
-			if (str != null) outp.print(str);
+			if (str != null)
+				outp.print(str);
 			outp.close();
 			pbf.exit(0);
-		} catch (IOException ioE){
-			pref.log("Error opening " + outFile.getName(),ioE);
+		} catch (IOException ioE) {
+			pref.log("Error opening " + outFile.getName(), ioE);
 		}
-		//try
+		// try
 
 	}
 
-	private void buildOutDB(){
+	private void buildOutDB() {
 		CacheHolder ch;
 		Vector tmp;
 		Iterator categoryLoop;
@@ -197,49 +194,54 @@
 		}
 
 		// fill structure with data from cacheDB
-		for(int i = 0; i<cacheDB.size(); i++){
-			ch=cacheDB.get(i);
+		for (int i = 0; i < cacheDB.size(); i++) {
+			ch = cacheDB.get(i);
 			// TODO Das Argument nach STring zu casten gef???llt mir nicht ganz...
-			if(ch.isVisible() && !ch.isAddiWpt()){
-				if (ch.is_found()) { tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));}
-				else if (ch.is_owned()) { tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));}
-				else if (ch.is_archived() || !ch.is_available()){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.getType()));}
-				else if (ch.is_available()){ tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.getType()));}
-				else { tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.getType()));}
-
+			if (ch.isVisible() && !ch.isAddiWpt()) {
+				if (ch.is_found()) {
+					tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));
+				} else if (ch.is_owned()) {
+					tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));
+				} else if (ch.is_archived() || !ch.is_available()) {
+					tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.getType()));
+				} else if (ch.is_available()) {
+					tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.getType()));
+				} else {
+					tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.getType()));
+				}
 				tmp.add(ch);
 			}
 		}
 
-		//eleminate empty categories
+		// eleminate empty categories
 		for (int i = 0; i < categoryNames.length; i++) {
 			categoryLoop = outCacheDB[i].entries();
 			foundOne = false;
-			//look if all vectors for cachetypes are filled
-			while (categoryLoop.hasNext()){
+			// look if all vectors for cachetypes are filled
+			while (categoryLoop.hasNext()) {
 				entry = (MapEntry) categoryLoop.next();
-				tmp = (Vector)entry.getValue();
-				if (tmp.size()> 0){
+				tmp = (Vector) entry.getValue();
+				if (tmp.size() > 0) {
 					foundOne = true;
 					break;
 				}
 			}
 			// set hashtable for that category to null
-			if (!foundOne)outCacheDB[i] = null;
+			if (!foundOne)
+				outCacheDB[i] = null;
 		}
 
-
 	}
 
-	private String startFolder(String name){
+	private String startFolder(String name) {
 		return startFolder(name, true);
 	}
 
-	private String startFolder(String name, boolean open){
+	private String startFolder(String name, boolean open) {
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append("<Folder>\r\n");
 		strBuf.append("<name>" + name + "</name>\r\n");
-		strBuf.append("<open>" + (open?"1":"0") + "</open>\r\n");
+		strBuf.append("<open>" + (open ? "1" : "0") + "</open>\r\n");
 
 		return strBuf.toString();
 	}
@@ -249,15 +251,15 @@
 		return "</Folder>\r\n";
 	}
 
-	public void copyIcons(String dir){
-		ZipFile zif=null;
+	public void copyIcons(String dir) {
+		ZipFile zif = null;
 		try {
-			zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
+			zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
 		} catch (IOException e) {
 		}
 		try {
-      if (zif == null) {
-			  zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
+			if (zif == null) {
+				zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
 			}
 			ZipEntry zipEnt;
 			int len;
@@ -266,27 +268,29 @@
 			for (int i = 0; i < CacheType.guiTypeStrings().length; i++) {
 				fileName = CacheType.typeImageForId(CacheType.guiSelect2Cw(i));
 				zipEnt = zif.getEntry(fileName);
-				if (zipEnt == null) continue;
-			    byte[] buff = new byte[ zipEnt.getSize() ];
-			    InputStream  fis = zif.getInputStream(zipEnt);
-			    FileOutputStream fos = new FileOutputStream( dir + "/" + fileName);
-			    while( 0 < (len = fis.read( buff )) )
-			      fos.write( buff, 0, len );
-			    fos.flush();
-			    fos.close();
-			    fis.close();
+				if (zipEnt == null)
+					continue;
+				byte[] buff = new byte[zipEnt.getSize()];
+				InputStream fis = zif.getInputStream(zipEnt);
+				FileOutputStream fos = new FileOutputStream(dir + "/" + fileName);
+				while (0 < (len = fis.read(buff)))
+					fos.write(buff, 0, len);
+				fos.flush();
+				fos.close();
+				fis.close();
 			}
 
-			} catch (ZipException e) {
-				pref.log("Problem copying Icon",e,true);
-			} catch (IOException e) {
-				pref.log("Problem copying Icon",e,true);
-			}
+		} catch (ZipException e) {
+			pref.log("Problem copying Icon", e, true);
+		} catch (IOException e) {
+			pref.log("Problem copying Icon", e, true);
+		}
 	}
 
+	StringBuffer strBuf = new StringBuffer(200);
 
-	public String header () {
-		StringBuffer strBuf = new StringBuffer(200);
+	public String header() {
+		strBuf.setLength(0);
 
 		strBuf.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n");
 		strBuf.append("<kml xmlns=\"http://earth.google.com/kml/2.0\">\r\n");
@@ -297,29 +301,28 @@
 		return strBuf.toString();
 	}
 
-
-	public String record(CacheHolder ch, String lat, String lon){
-		StringBuffer strBuf = new StringBuffer(200);
+	public String record(CacheHolder ch, String lat, String lon) {
+		strBuf.setLength(0);
 		CacheHolderDetail det = ch.getCacheDetails(true);
 
 		strBuf.append("   <Placemark>\r\n");
-		if (det.URL != null){
-			strBuf.append("      <description>"+SafeXML.clean(det.URL)+"</description>\r\n");
+		if (det.URL != null) {
+			strBuf.append("      <description>" + SafeXML.clean(det.URL) + "</description>\r\n");
 		}
-		strBuf.append("      <name>"+ ch.getWayPoint() + " - " + SafeXML.clean(ch.getCacheName()) +"</name>\r\n");
+		strBuf.append("      <name>" + ch.getWayPoint() + " - " + SafeXML.clean(ch.getCacheName()) + "</name>\r\n");
 		strBuf.append("      <LookAt>\r\n");
 		strBuf.append("         <latitude>" + lat + "</latitude>\r\n");
 		strBuf.append("         <longitude>" + lon + "</longitude>\r\n");
 		strBuf.append("         <range>10000</range><tilt>0</tilt><heading>0</heading>\r\n");
 		strBuf.append("      </LookAt>\r\n");
 		strBuf.append("      <Point>\r\n");
-		strBuf.append("         <coordinates>"  + lon + "," + lat + "</coordinates>\r\n");
+		strBuf.append("         <coordinates>" + lon + "," + lat + "</coordinates>\r\n");
 		strBuf.append("      </Point>\r\n");
 		strBuf.append("      <Style>\r\n");
 		strBuf.append("      <IconStyle>\r\n");
 		strBuf.append("         <Icon>\r\n");
-//		strBuf.append("            <href>"+ File.getProgramDirectory()+ "/" + CacheType.type2pic(Convert.parseInt(ch.type))+ "</href>\r\n");
-		strBuf.append("            <href>"+ CacheType.typeImageForId(ch.getType())+ "</href>\r\n");
+		// strBuf.append("            <href>"+ File.getProgramDirectory()+ "/" + CacheType.type2pic(Convert.parseInt(ch.type))+ "</href>\r\n");
+		strBuf.append("            <href>" + CacheType.typeImageForId(ch.getType()) + "</href>\r\n");
 		strBuf.append("         </Icon>\r\n");
 		strBuf.append("      </IconStyle>\r\n");
 		strBuf.append("      <LabelStyle>\r\n");
@@ -331,8 +334,8 @@
 		return strBuf.toString();
 	}
 
-	public String trailer(){
-		StringBuffer strBuf = new StringBuffer(50);
+	public String trailer() {
+		strBuf.setLength(0);
 
 		strBuf.append("</Folder>\r\n");
 		strBuf.append("</kml>\r\n");
@@ -340,10 +343,13 @@
 		return strBuf.toString();
 	}
 
-	private String getColor(CacheHolder ch){
-		if (ch.is_found()) return COLOR_FOUND;
-		if (ch.is_owned()) return COLOR_OWNED;
-		if (ch.is_archived() || !ch.is_available()) return COLOR_NOT_AVAILABLE;
+	private String getColor(CacheHolder ch) {
+		if (ch.is_found())
+			return COLOR_FOUND;
+		if (ch.is_owned())
+			return COLOR_OWNED;
+		if (ch.is_archived() || !ch.is_available())
+			return COLOR_NOT_AVAILABLE;
 
 		return COLOR_AVAILABLE;
 	}

Modified: branches/r1.2/src/CacheWolf/exp/LocExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/LocExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/LocExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,104 +1,106 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CWPoint;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheHolderDetail;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import ewe.io.File;
-import ewe.io.FileBase;
 
-
 /**
-*	Class to export the cache database into an geocaching .loc file that may be exported
-*	by GPSBabel to a Garmin GPS.
-*
-*	Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
-*/
-public class LocExporter extends Exporter{
+ * Class to export the cache database into an geocaching .loc file that may be exported
+ * by GPSBabel to a Garmin GPS.
+ * 
+ * Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
+ */
+public class LocExporter extends Exporter {
 	public static int MODE_AUTO = TMP_FILE;
 	/**
 	 * Defines how certain cachetypes are mapped to user icons
 	 */
-	private static GarminMap gm=null;
+	private static GarminMap gm = null;
 
-	public LocExporter(){
+	public LocExporter() {
 		super();
 		this.setMask("*.loc");
 		this.setHowManyParams(NO_PARAMS);
 		if (Global.getPref().addDetailsToName) {
 			this.setNeedCacheDetails(true);
 		}
-		gm=new GarminMap();
+		gm = new GarminMap();
 	}
 
-	public String header () {
+	public String header() {
 		return "<?xml version=\"1.0\"?><loc version=\"1.0\" src=\"EasyGPS\">\r\n";
 	}
 
-	public String record(CacheHolder ch){
+	public String record(CacheHolder ch) {
 
 		// filter out not valid coords
-		if (!ch.pos.isValid()) return null;
+		if (!ch.getPos().isValid())
+			return null;
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append("<waypoint>\r\n   <name id=\"");
-		String wptName=simplifyString(ch.getWayPoint());
+		String wptName = simplifyString(ch.getWayPoint());
 		if (Global.getPref().addDetailsToWaypoint) {
-			wptName += getShortDetails( ch );
+			wptName += getShortDetails(ch);
 		}
-		if (Global.getPref().garminMaxLen==0)
+		if (Global.getPref().garminMaxLen == 0)
 			strBuf.append(wptName);
 		else {
 			try {
-				strBuf.append(wptName.substring(wptName.length()-Global.getPref().garminMaxLen));
-			} catch (Exception ex){ pref.log("[LocExporter:record]Invalid value for garmin.MaxWaypointLength",ex); }
+				strBuf.append(wptName.substring(wptName.length() - Global.getPref().garminMaxLen));
+			} catch (Exception ex) {
+				pref.log("[LocExporter:record]Invalid value for garmin.MaxWaypointLength", ex);
+			}
 		}
 		strBuf.append("\"><![CDATA[");
 		strBuf.append(simplifyString(ch.getCacheName()));
 		if (Global.getPref().addDetailsToName) {
-			if ( !Global.getPref().addDetailsToWaypoint ) {
-				strBuf.append( getShortDetails( ch ) );
+			if (!Global.getPref().addDetailsToWaypoint) {
+				strBuf.append(getShortDetails(ch));
 			}
 			CacheHolderDetail det = ch.getCacheDetails(true);
-			if ( (!det.Hints.equals("null")) && (det.Hints.length() > 0) ) {
+			if ((!det.Hints.equals("null")) && (det.Hints.length() > 0)) {
 				strBuf.append(":");
-				strBuf.append( simplifyString(Common.rot13(det.Hints)) );
+				strBuf.append(simplifyString(Common.rot13(det.Hints)));
 			}
 		}
 		strBuf.append("]]></name>\r\n   <coord lat=\"");
-		strBuf.append(ch.pos.getLatDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLatDeg(CWPoint.DD));
 		strBuf.append("\" lon=\"");
-		strBuf.append(ch.pos.getLonDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLonDeg(CWPoint.DD));
 		strBuf.append("\"/>\r\n   <type>");
 		strBuf.append(gm.getIcon(ch));
 		strBuf.append("</type>\r\n</waypoint>\r\n");
 		return strBuf.toString();
 	}
-	public String trailer(){
+
+	public String trailer() {
 		return "</loc>\r\n";
 	}
 }

Added: branches/r1.2/src/CacheWolf/exp/OCLogExport.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/OCLogExport.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/exp/OCLogExport.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,100 @@
+package CacheWolf.exp;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.CacheType;
+import CacheWolf.DateFormat;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import CacheWolf.OC;
+import CacheWolf.UrlFetcher;
+import CacheWolf.imp.OCGPXfetch;
+import CacheWolf.imp.OCLinkImporter;
+import ewe.io.IOException;
+import ewe.sys.Handle;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.ProgressBarForm;
+
+public final class OCLogExport {
+	private static boolean loggedIn = false;
+	private static CacheDB cacheDB = null;
+
+	public static void doit() {
+
+		if (cacheDB == null)
+			cacheDB = Global.getProfile().cacheDB;
+		int totalWaypoints = cacheDB.countVisible();
+		int updated = 0;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h, "logging opencaching ...");
+		pbf.exec();
+		if (OCGPXfetch.login()) {
+			for (int o = 0; o < cacheDB.size(); o += 1) {
+				if (pbf.exitValue == -1)
+					break;
+				CacheHolder ch = cacheDB.get(o);
+				if (ch.isVisible()) {
+					doOneLog(ch);
+					updated++;
+					h.progress = (float) updated / (float) totalWaypoints;
+					h.changed();
+				}
+			}
+		}
+		pbf.exit(0);
+	}
+
+	public static void doOneLog(CacheHolder ch) {
+		if (!ch.is_found())
+			return;
+		// take GC log direct to OC, needs valid ch
+		Vm.showWait(true);
+		String wpName = ch.getOcCacheID();
+		if (wpName.length() > 1) {
+			if (!loggedIn)
+				loggedIn = OCGPXfetch.login();
+			if (loggedIn) {
+				if (wpName.charAt(0) < 65) {
+					// noch nicht bei OC gelogged
+					wpName = ch.getOcCacheID().substring(1);
+					String url = "http://" + OC.getOCHostName(wpName) + "/log.php?wp=" + wpName;
+					String page = "";
+					try {
+						CacheHolderDetail chD = ch.getCacheDetails(false);
+						if (chD.OwnLog != null) {
+							page = UrlFetcher.fetch(url);
+							loggedIn = page.indexOf("Eingeloggt als") > -1; // next time perhaps
+							String ocCacheId = new Extractor(page, "viewcache.php?cacheid=", "\">", 0, true).findNext();
+							String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3";
+							if (ch.getType() == CacheType.CW_TYPE_EVENT || ch.getType() == CacheType.CW_TYPE_EVENT)
+								postData = postData + "&logtype=7";
+							else
+								postData = postData + "&logtype=1";
+							Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
+							postData += "&logday=" + logDate.day;
+							postData += "&logmonth=" + logDate.month;
+							postData += "&logyear=" + logDate.year;
+							postData += "&logtext=" + UrlFetcher.toUtf8Url(chD.OwnLog.getMessage());
+							postData += "&submitform=Log+eintragen"; // todo for other opencaching sites
+							UrlFetcher.setpostData(postData);
+							page = UrlFetcher.fetch(url);
+							OCLinkImporter.updateOCLink(ch);
+							if (ch.getOcCacheID().startsWith("-")) {
+								ch.setOcCacheID("!" + ch.getOcCacheID().substring(1));
+								ch.save();
+							}
+						}
+					} catch (IOException e) {
+						// dann nicht
+					}
+				}
+			}
+		}
+		Vm.showWait(false);
+	}
+}

Modified: branches/r1.2/src/CacheWolf/exp/OziExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/OziExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/OziExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -29,8 +29,6 @@
 import CacheWolf.CacheType;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
-import ewe.io.File;
-import ewe.io.FileBase;
 
 /**
 *	Class to export the cache database (index) to an OziExplorer File

Modified: branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheImages;
 import CacheWolf.Common;
@@ -35,18 +36,18 @@
 import ewe.sys.Time;
 import ewe.ui.FormBase;
 
-/** 
+/**
  * 
  * @author Kalle
- * Class to create a gpx-File with links to the pictures of a 
- * cache, which is used as input for the POILoader from Garmin.
+ *         Class to create a gpx-File with links to the pictures of a
+ *         cache, which is used as input for the POILoader from Garmin.
  */
 
 public class SpoilerPOIExporter extends Exporter {
 	private SpoilerPOIExporterScreen infoScreen;
 	private boolean onlySpoiler;
-	
-	public SpoilerPOIExporter(Preferences p, Profile prof){
+
+	public SpoilerPOIExporter(Preferences p, Profile prof) {
 		super();
 		this.setMask("*.gpx");
 		this.setHowManyParams(LAT_LON);
@@ -55,19 +56,19 @@
 
 	public void doIt() {
 		infoScreen = new SpoilerPOIExporterScreen("SpoilerPOIExport");
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		onlySpoiler = infoScreen.getOnlySpoiler();
 		super.doIt();
 	}
-	
-	public String header () {
+
+	public String header() {
 		StringBuffer strBuf = new StringBuffer(200);
 		Time tim = new Time();
 
 		strBuf.append("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\r\n");
-		strBuf.append("<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" creator=\"CacheWolf\" version=\"1.1\"" +
-				      " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " +
-				      "xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\">\r\n");
+		strBuf.append("<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" creator=\"CacheWolf\" version=\"1.1\"" + " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
+				+ "xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\">\r\n");
 		strBuf.append("  <metadata>\r\n");
 		strBuf.append("    <link href=\"http://www.cachewolf.de\">\r\n");
 		strBuf.append("      <text>CacheWolf</text>\r\n");
@@ -78,48 +79,54 @@
 		strBuf.append("  </metadata>\r\n");
 		return strBuf.toString();
 	}
-	
+
 	public String record(CacheHolder ch, String lat, String lon) {
 		StringBuffer strBuf = new StringBuffer(1000);
-		String comment,filename, url;
+		String comment, filename, url;
 		CacheImages images;
 		int picCounter;
-		
+
 		// Makes only sense for main waypoints
-		if (ch.isAddiWpt()) return null;
-		
+		if (ch.isAddiWpt())
+			return null;
+
 		// First check, if there a any pictures in the db for the wpt
 		ch.getCacheDetails(true);
-		if (! ch.detailsLoaded()) return null;
-		if (ch.getCacheDetails(true).images.size() == 0) return null;
-		
+		if (!ch.detailsLoaded())
+			return null;
+		if (ch.getCacheDetails(true).images.size() == 0)
+			return null;
+
 		images = ch.getCacheDetails(true).images.getDisplayImages(ch.getWayPoint());
 		picCounter = 0;
-		for (int i=0; i < images.size(); i++ ) {
+		for (int i = 0; i < images.size(); i++) {
 			filename = images.get(i).getFilename();
 			comment = images.get(i).getTitle();
 			url = profile.dataDir + filename;
-			
+
 			// POILoader can only work with JPG-Files
-			if ( !filename.endsWith(".jpg")) continue;
+			if (!filename.endsWith(".jpg"))
+				continue;
 			// Try to export only Spoiler
-			if ( onlySpoiler && (comment.indexOf("oiler") < 1)) continue;
+			if (onlySpoiler && (comment.indexOf("oiler") < 1))
+				continue;
 			// check if the file is not deleted
-			if (!(new FileBugfix(url)).exists()) continue;
-			
+			if (!(new FileBugfix(url)).exists())
+				continue;
+
 			picCounter++;
 			strBuf.append("<wpt lat=\"" + lat + "\" lon=\"" + lon + "\">\r\n");
-			strBuf.append("  <name>Sp " + picCounter + ": " + SafeXML.cleanGPX(ch.cacheName) + "</name>\r\n");
+			strBuf.append("  <name>Sp " + picCounter + ": " + SafeXML.cleanGPX(ch.getCacheName()) + "</name>\r\n");
 			strBuf.append("  <cmt>\r\n");
-			if (ch.getCacheDetails(true).Hints.length()> 0){
+			if (ch.getCacheDetails(true).Hints.length() > 0) {
 				strBuf.append("  Hint: " + SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints)) + "\r\n");
 			}
-			if (comment != null){
+			if (comment != null) {
 				strBuf.append("  Comment: " + SafeXML.cleanGPX(SafeXML.cleanback(comment)) + "\r\n");
 			}
 			strBuf.append("  </cmt>\r\n");
 			strBuf.append("  <desc>GCcode: " + ch.getWayPoint() + " </desc>\r\n");
-			strBuf.append("   <link href=\"" + URLUTF8Encoder.encode(url, false)  + "\"/>\r\n");
+			strBuf.append("   <link href=\"" + URLUTF8Encoder.encode(url, false) + "\"/>\r\n");
 			strBuf.append("  <sym>Scenic Area</sym>\r\n");
 			strBuf.append("  <extensions>\r\n");
 			strBuf.append("     <gpxx:WaypointExtension xmlns:gpxx=\"http://www.garmin.com/xmlschemas/GpxExtensions/v3\">\r\n");
@@ -129,10 +136,10 @@
 			strBuf.append("</wpt>\r\n");
 			strBuf.append("\r\n");
 		}
-	
+
 		return strBuf.toString();
 	}
-	
+
 	public String trailer() {
 		return "</gpx>\r\n";
 	}

Modified: branches/r1.2/src/CacheWolf/exp/TPLExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/TPLExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/TPLExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,11 +21,12 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
+import CacheWolf.CacheType;
 import CacheWolf.Global;
 import CacheWolf.InfoBox;
 import CacheWolf.Preferences;
@@ -54,31 +55,29 @@
 import ewe.util.Vector;
 
 /**
- * @author Kalle
- * class to export cachedata using a template
+ * @author Kalle class to export cachedata using a template
  */
-class TplFilter implements HTML.Tmpl.Filter
-{
-	private int type=SCALAR;
-	private String newLine="\n";
+class TplFilter implements HTML.Tmpl.Filter {
+	private int type = SCALAR;
+	private String newLine = "\n";
 	TextCodec codec = new AsciiCodec(); // codec = new AsciiCodec(AsciiCodec.STRIP_CR);
 	String badChars;
 	String decSep = ".";
-	int shortNameLength=30;
-	int shortWaypointLength=3;
-	int noOfLogs=-1; // means all
+	int shortNameLength = 30;
+	int shortWaypointLength = 3;
+	int noOfLogs = -1; // means all
 	boolean single = true;
 	int formatModifier = 0;
 	int sortedBy = -1;
-	boolean getAddiWp = true;
-	boolean getMainWp = true;
+	boolean getAddiWp = false;
+	boolean getMainWp = false;
+	boolean getParking = false;
 	boolean copyCacheImages = false;
 	Hashtable additionalVarParams = new Hashtable();
 	String userValue = "";
-	String out="*.gpx";
+	String out = "*.gpx";
 
-
-	public TplFilter(){
+	public TplFilter() {
 		return;
 	}
 
@@ -94,7 +93,7 @@
 		// search for parameters
 		rex = new Regex("(?i)<tmpl_par.*>");
 		rex.search(t);
-		if (rex.didMatch()){
+		if (rex.didMatch()) {
 			// get parameter
 			rex1 = new Regex("(?i)name=\"(.*)\"\\svalue=\"(.*)\"[?\\s>]");
 			rex1.search(t);
@@ -102,83 +101,77 @@
 			value = rex1.stringMatched(2);
 
 			if (param.equals("charset")) {
-				if (value.equals("ASCII")) {codec = new AsciiCodec();}
-				else if (value.equals("UTF8")) {codec = new JavaUtf8Codec();}
-				else {codec = new NoCodec();}
-			}
-			else if (param.equals("badchars")) {
+				if (value.equals("ASCII")) {
+					codec = new AsciiCodec();
+				} else if (value.equals("UTF8")) {
+					codec = new JavaUtf8Codec();
+				} else {
+					codec = new NoCodec();
+				}
+			} else if (param.equals("badchars")) {
 				badChars = value;
-			}
-			else if (param.equals("newline")){
+			} else if (param.equals("newline")) {
 				newLine = "";
-				if (value.indexOf("CR") >= 0) newLine += "\r";
-				if (value.indexOf("LF") >= 0) newLine += "\n";
-			}
-			else if (param.equals("decsep")) {
+				if (value.indexOf("CR") >= 0)
+					newLine += "\r";
+				if (value.indexOf("LF") >= 0)
+					newLine += "\n";
+			} else if (param.equals("decsep")) {
 				decSep = value;
-			}
-			else if (param.equals("ShortNameLength")) {
+			} else if (param.equals("ShortNameLength")) {
 				shortNameLength = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals("WaypointLength")) {
+			} else if (param.equals("WaypointLength")) {
 				shortWaypointLength = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals("NrLogs")) {
+			} else if (param.equals("NrLogs")) {
 				noOfLogs = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals("singleFile")) {
-				single = value.equals("yes") ? true : false ;
-			}
-			else if (param.equals("formatModifier")) {
+			} else if (param.equals("singleFile")) {
+				single = value.equals("yes") ? true : false;
+			} else if (param.equals("formatModifier")) {
 				formatModifier = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals("Out")) {
+			} else if (param.equals("Out")) {
 				out = value;
-			}
-			else if (param.equals("takeOnlyWp")) {
+			} else if (param.equals("takeOnlyWp")) {
 				if (value.equals("main")) {
-					getAddiWp=false;
+					getMainWp = true;
+				} else if (value.equals("addi")) {
+					getAddiWp = true;
+				} else if (value.equals("parking")) {
+					getParking = true;
 				}
-				else if (value.equals("addi")) {
-					getMainWp=false;
-				}
-			}
-			else if (param.equals("sortedBy")) {
-				sortedBy=Integer.valueOf(value).intValue();
-			}
-			else if (param.equals("CopyCacheImages")) {
-				if (value.equals("yes")) copyCacheImages=true;
-			}
-			else if (param.startsWith("input")) {
+			} else if (param.equals("sortedBy")) {
+				sortedBy = Integer.valueOf(value).intValue();
+			} else if (param.equals("CopyCacheImages")) {
+				if (value.equals("yes"))
+					copyCacheImages = true;
+			} else if (param.startsWith("input")) {
 				String par = param.substring(5);
 				InfoBox inf = new InfoBox("Eingabe", par, InfoBox.INPUT);
 				inf.feedback.setText(value);
 				String res;
 				if (inf.execute() == FormBase.IDOK) {
 					res = inf.getInput();
-					additionalVarParams.put(par,res);
+					additionalVarParams.put(par, res);
 				}
+			} else if (param.startsWith("const")) {
+				additionalVarParams.put(param.substring(5), value);
 			}
-			else if (param.startsWith("const")) {
-				additionalVarParams.put(param.substring(5),value);
-			}
 			return "";
 		}
 
 		if (formatModifier == 0) {
 			// for gpx output
 			// Filter newlines
-			rex = new Regex("(?m)\n$","");
+			rex = new Regex("(?m)\n$", "");
 			t = rex.replaceAll(t);
 
 			// Filter comments <#-- and -->
-			rex = new Regex("<#--.*-->","");
+			rex = new Regex("<#--.*-->", "");
 			t = rex.replaceAll(t);
 
 			// replace <br> or <br /> with newline
-			rex = new Regex("<br.*>","");
+			rex = new Regex("<br.*>", "");
 			rex.search(t);
-			if (rex.didMatch()){
+			if (rex.didMatch()) {
 				t = rex.replaceAll(t);
 				t += newLine;
 			}
@@ -187,46 +180,44 @@
 		return t;
 	}
 
-
-	public String [] parse(String [] t) {
+	public String[] parse(String[] t) {
 		throw new UnsupportedOperationException();
 	}
 }
 
-
 public class TPLExporter {
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 	String tplFile;
 	String expName;
-	Regex rex=null;
-	private static GarminMap gm=null;
+	Regex rex = null;
+	private static GarminMap gm = null;
 
-	public TPLExporter(Preferences p, Profile prof, String tpl){
+	public TPLExporter(Preferences p, Profile prof, String tpl) {
 		pref = p;
-		profile=prof;
+		profile = prof;
 		cacheDB = profile.cacheDB;
 		tplFile = tpl;
 		File tmpFile = new File(tpl);
 		expName = tmpFile.getName();
 		expName = expName.substring(0, expName.indexOf("."));
-		gm=new GarminMap();
+		gm = new GarminMap();
 	}
 
-	public void doIt(){
+	public void doIt() {
 
 		ProgressBarForm pbf = new ProgressBarForm();
 		ewe.sys.Handle h = new ewe.sys.Handle();
 		int counter = cacheDB.countVisible();
 		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
+		pbf.setTask(h, "Exporting ...");
 		pbf.exec();
 
 		try {
-			TplFilter myFilter = new TplFilter();			
+			TplFilter myFilter = new TplFilter();
 			Hashtable args = new Hashtable();
-			//args.put("debug", "true");
+			// args.put("debug", "true");
 			args.put("filename", tplFile);
 			args.put("case_sensitive", "true");
 			args.put("loop_context_vars", Boolean.TRUE);
@@ -237,50 +228,64 @@
 			FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 			fc.setTitle("Select target file:");
 			fc.addMask(myFilter.out);
-			if(fc.execute() == FormBase.IDCANCEL) {pbf.exit(0); return; }
+			if (fc.execute() == FormBase.IDCANCEL) {
+				pbf.exit(0);
+				return;
+			}
 			File saveTo = fc.getChosenFile();
 			pref.setExportPath(expName, saveTo.getPath());
 
-			if (myFilter.sortedBy!=-1) {
+			if (myFilter.sortedBy != -1) {
 				Global.mainTab.tbP.myMod.sortTable(myFilter.sortedBy, true);
 			}
-			
-			Regex dec = new Regex("[,.]",myFilter.decSep);
-			if (myFilter.badChars != null) rex = new Regex("["+myFilter.badChars+"]","");
-			
+
+			Regex dec = new Regex("[,.]", myFilter.decSep);
+			if (myFilter.badChars != null)
+				rex = new Regex("[" + myFilter.badChars + "]", "");
+
 			Vector cache_index = new Vector();
-			String imgExpName="";
-			if (myFilter.copyCacheImages) imgExpName=expName;
-			for(int i = 0; i<counter;i++){
+			String imgExpName = "";
+			if (myFilter.copyCacheImages)
+				imgExpName = expName;
+			for (int i = 0; i < counter; i++) {
 				CacheHolder ch = cacheDB.get(i);
-				if (ch.isVisible() && (ch.pos.isValid() || myFilter.formatModifier>0) ){
-					if (myFilter.getAddiWp == ch.isAddiWpt() || myFilter.getMainWp == !ch.isAddiWpt()) {
-						h.progress = (float)i/(float)counter;
+				if (ch.isVisible() && (ch.getPos().isValid() || myFilter.formatModifier > 0)) {
+					boolean get = true;
+					if (myFilter.getAddiWp) {
+						get = ch.isAddiWpt();
+					} else if (myFilter.getMainWp) {
+						get = !ch.isAddiWpt();
+					} else if (myFilter.getParking) {
+						get = (ch.getType() == CacheType.CW_TYPE_PARKING)// parking
+								|| (!ch.isAddiWpt() && !hasParking(ch));// oder main ohne Parkplatz
+					}
+					if (get) {
+						h.progress = (float) i / (float) counter;
 						h.changed();
 						try {
-							Hashtable varParams=ch.toHashtable(dec, rex, myFilter.shortWaypointLength, myFilter.shortNameLength, myFilter.noOfLogs, myFilter.codec, gm, false, myFilter.formatModifier, imgExpName);
-							
+							Hashtable varParams = ch.toHashtable(dec, rex, myFilter.shortWaypointLength, myFilter.shortNameLength, myFilter.noOfLogs, myFilter.codec, gm, false, myFilter.formatModifier, imgExpName);
+
 							Enumeration e = myFilter.additionalVarParams.keys();
-							while(e.hasMoreElements()) {
-								String key = (String)e.nextElement();
+							while (e.hasMoreElements()) {
+								String key = (String) e.nextElement();
 								Object value = myFilter.additionalVarParams.get(key);
 								varParams.put(key, value);
 							}
-							
+
 							if (myFilter.single) {
 								cache_index.add(varParams);
 							}
 
 							else {
 								tpl.setParams(varParams);
-								String ext = (myFilter.out.substring(myFilter.out.lastIndexOf(".")).toLowerCase()+"    ").trim();
+								String ext = (myFilter.out.substring(myFilter.out.lastIndexOf(".")).toLowerCase() + "    ").trim();
 								FileWriter fw = new FileWriter(saveTo.getPath() + ch.getWayPoint() + ext);
 								fw.codec = myFilter.codec;
 								PrintWriter detfile = new PrintWriter(new BufferedWriter(fw));
 								tpl.printTo(detfile);
 								detfile.close();
 							}
-						}catch(Exception e){
+						} catch (Exception e) {
 							pref.log("[TplExporter:doIt]" + ch.getWayPoint(), e, true);
 						}
 					}
@@ -298,91 +303,106 @@
 		} catch (Exception e) {
 			pref.log("[TplExporter:doIt]", e, true);
 		} catch (OutOfMemoryError e) {
-			(new MessageBox("Error", "Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now", FormBase.OKB)).execute();
+			(new MessageBox("Error", "Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now", FormBase.OKB))
+					.execute();
 		}
 		pbf.exit(0);
 	}
+
+	private boolean hasParking(CacheHolder ch) {
+		boolean ret = false;
+		if (ch.hasAddiWpt()) {
+			for (int i = 0; i < ch.addiWpts.size(); i++) {
+				CacheHolder chwp = (CacheHolder) ch.addiWpts.get(i);
+				if (chwp.getType() == CacheType.CW_TYPE_PARKING)
+					return true;
+			}
+		}
+		return ret;
+	}
 }
 
-//##################################################################
-class NoCodec implements TextCodec{
-//##################################################################
+// ##################################################################
+class NoCodec implements TextCodec {
+	// ##################################################################
 
-/**
-* This is a creation option. It specifies that CR characters should be removed when
-* encoding text into UTF.
-**/
-public static final int STRIP_CR_ON_DECODE = 0x1;
-/**
-* This is a creation option. It specifies that CR characters should be removed when
-* decoding text from UTF.
-**/
-public static final int STRIP_CR_ON_ENCODE = 0x2;
-/**
-* This is a creation option. It specifies that CR characters should be removed when
-* decoding text from UTF AND encoding text to UTF.
-**/
-public static final int STRIP_CR = STRIP_CR_ON_DECODE|STRIP_CR_ON_ENCODE;
+	/**
+	 * This is a creation option. It specifies that CR characters should be removed when encoding text into UTF.
+	 */
+	public static final int STRIP_CR_ON_DECODE = 0x1;
+	/**
+	 * This is a creation option. It specifies that CR characters should be removed when decoding text from UTF.
+	 */
+	public static final int STRIP_CR_ON_ENCODE = 0x2;
+	/**
+	 * This is a creation option. It specifies that CR characters should be removed when decoding text from UTF AND encoding text to UTF.
+	 */
+	public static final int STRIP_CR = STRIP_CR_ON_DECODE | STRIP_CR_ON_ENCODE;
 
-private int flags = 0;
+	private int flags = 0;
 
-//===================================================================
-public NoCodec(int options)
-//===================================================================
-{
-	flags = options;
-}
-//===================================================================
-public NoCodec()
-//===================================================================
-{
-	this(0);
-}
-//===================================================================
-public ByteArray encodeText(char [] text, int start, int length, boolean endOfData, ByteArray dest) throws IOException
-//===================================================================
-{
-	if (dest == null) dest = new ByteArray();
-	int size = length == 0 ? 2 : 2+text.length*2;
-	if (dest.data == null || dest.data.length < size)
-		dest.data = new byte[size];
-	byte [] destination = dest.data;
-	int s = 0;
-	if (length>0){
-		destination[s++] = (byte) 0xFF;
-		destination[s++] = (byte) 0xFE;
+	// ===================================================================
+	public NoCodec(int options)
+	// ===================================================================
+	{
+		flags = options;
 	}
-	for (int i = 0; i<length; i++){
-		char c = text[i+start];
-		if (c == 13 && ((flags & STRIP_CR_ON_ENCODE) != 0)) continue;
-		destination[s++] = (byte)(c & 0xFF);
-		destination[s++] = (byte)((c>>8) & 0xFF);
+
+	// ===================================================================
+	public NoCodec()
+	// ===================================================================
+	{
+		this(0);
 	}
-	dest.length = s;
-	return dest;
-}
 
-//===================================================================
-public CharArray decodeText(byte [] encoded, int start, int length, boolean endOfData, CharArray dest) throws IOException
-//===================================================================
-{
-	if (dest == null) dest = new CharArray();
-	dest.length = 0;
-	return dest;
-}
+	// ===================================================================
+	public ByteArray encodeText(char[] text, int start, int length, boolean endOfData, ByteArray dest) throws IOException
+	// ===================================================================
+	{
+		if (dest == null)
+			dest = new ByteArray();
+		int size = length == 0 ? 2 : 2 + text.length * 2;
+		if (dest.data == null || dest.data.length < size)
+			dest.data = new byte[size];
+		byte[] destination = dest.data;
+		int s = 0;
+		if (length > 0) {
+			destination[s++] = (byte) 0xFF;
+			destination[s++] = (byte) 0xFE;
+		}
+		for (int i = 0; i < length; i++) {
+			char c = text[i + start];
+			if (c == 13 && ((flags & STRIP_CR_ON_ENCODE) != 0))
+				continue;
+			destination[s++] = (byte) (c & 0xFF);
+			destination[s++] = (byte) ((c >> 8) & 0xFF);
+		}
+		dest.length = s;
+		return dest;
+	}
 
-//===================================================================
-public void closeCodec() throws IOException
-//===================================================================
-{
-}
+	// ===================================================================
+	public CharArray decodeText(byte[] encoded, int start, int length, boolean endOfData, CharArray dest) throws IOException
+	// ===================================================================
+	{
+		if (dest == null)
+			dest = new CharArray();
+		dest.length = 0;
+		return dest;
+	}
 
-//===================================================================
-public Object getCopy()
-//===================================================================
-{
-	return new NoCodec(flags);
+	// ===================================================================
+	public void closeCodec() throws IOException
+	// ===================================================================
+	{
+	}
+
+	// ===================================================================
+	public Object getCopy()
+	// ===================================================================
+	{
+		return new NoCodec(flags);
+	}
+	// ##################################################################
 }
-//##################################################################
-}
-//##################################################################
+// ##################################################################

Modified: branches/r1.2/src/CacheWolf/exp/TomTomExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/TomTomExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/TomTomExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -60,46 +60,51 @@
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
-	
+
 	public TomTomExporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		String fileName, dirName, prefix;
 		int fileFormat;
 
 		TomTomExporterScreen infoScreen = new TomTomExporterScreen("TomTomExport");
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		fileFormat = infoScreen.getFormat();
 
 		dirName = pref.getExportPath(expName);
-		
-		if (infoScreen.oneFilePerType()){
+
+		if (infoScreen.oneFilePerType()) {
 			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, dirName);
 			fc.setTitle("Select target dir:");
-			if(fc.execute() == FormBase.IDCANCEL) return;
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			dirName = fc.getChosen();
 			pref.setExportPath(expName, dirName);
 			prefix = infoScreen.getPrefix();
 			writeOneFilePerType(fileFormat, dirName, prefix);
-		} else{
+		} else {
 			FileChooser fc = new FileChooser(FileChooserBase.SAVE, dirName);
 			fc.setTitle("Select target file:");
-	
-			if (fileFormat == TT_ASC) fc.addMask("*.asc");
-			else fc.addMask("*.ov2");
-			
-			if(fc.execute() == FormBase.IDCANCEL) return;
+
+			if (fileFormat == TT_ASC)
+				fc.addMask("*.asc");
+			else
+				fc.addMask("*.ov2");
+
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			fileName = fc.getChosen();
 			pref.setExportPathFromFileName(expName, fileName);
 			writeSingleFile(fileFormat, fileName);
 		}
 	}
-	
-	public void writeOneFilePerType(int format, String dirName, String prefix){
+
+	public void writeOneFilePerType(int format, String dirName, String prefix) {
 		RandomAccessFile out = null;
 		File dfile;
 		String ext, fileName = null;
@@ -108,63 +113,64 @@
 		ProgressBarForm progressForm = new ProgressBarForm();
 		Handle h = new Handle();
 		int currExp, counter;
-		
+
 		progressForm.showMainTask = false;
-		progressForm.setTask(h,"Exporting ...");
+		progressForm.setTask(h, "Exporting ...");
 		progressForm.exec();
-		
+
 		currExp = 0;
 		counter = cacheDB.countVisible();
-		
-		ext = format==TT_ASC?".asc":".ov2";
 
-		try{
-			//loop through type
-			for(int j = 0; j < CacheType.guiTypeStrings().length; j++){
+		ext = format == TT_ASC ? ".asc" : ".ov2";
+
+		try {
+			// loop through type
+			for (int j = 0; j < CacheType.guiTypeStrings().length; j++) {
 				/*
-				String typeName = CacheType.guiTypeStrings()[j];
-				if (typeName.startsWith("Addi: ")) {
-					typeName = typeName.substring(6);
-				}
-				*/
+				 * String typeName = CacheType.guiTypeStrings()[j];
+				 * if (typeName.startsWith("Addi: ")) {
+				 * typeName = typeName.substring(6);
+				 * }
+				 */
 				String typeName = CacheType.typeImageForId(CacheType.guiSelect2Cw(j));
-				typeName=typeName.substring(0, typeName.length()-4);		
-				
+				typeName = typeName.substring(0, typeName.length() - 4);
+
 				fileName = dirName + "/" + prefix + typeName + ext;
 				dfile = new File(fileName);
 				dfile.delete();
-				out =  new RandomAccessFile(fileName,"rw");
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=cacheDB.get(i);
+				out = new RandomAccessFile(fileName, "rw");
+				for (int i = 0; i < cacheDB.size(); i++) {
+					holder = cacheDB.get(i);
 
-					if(holder.getType() == CacheType.guiSelect2Cw(j) && holder.isVisible()){
+					if (holder.getType() == CacheType.guiSelect2Cw(j) && holder.isVisible()) {
 						currExp++;
-						h.progress = (float)currExp/(float)counter;
+						h.progress = (float) currExp / (float) counter;
 						h.changed();
-						if (holder.pos.isValid() == false) continue;
-						if (format == TT_ASC){
-							writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						if (holder.getPos().isValid() == false)
+							continue;
+						if (format == TT_ASC) {
+							writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						} else {
-							writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+							writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						}
-					}//if
-				}//for cacheDB
+					}// if
+				}// for cacheDB
 				out.close();
 				// check for empty files and delete them
 				dfile = new File(fileName);
-				if (dfile.length()==0) {
+				if (dfile.length() == 0) {
 					dfile.delete();
 				} else {
-					copyIcon(j, dirName + "/" + prefix,typeName); 
+					copyIcon(j, dirName + "/" + prefix, typeName);
 				}
-			}//for wayType
+			}// for wayType
 			progressForm.exit(0);
-		} catch (IOException e){
-			pref.log("Problem creating file! " + fileName,e,true);
-		}//try
+		} catch (IOException e) {
+			pref.log("Problem creating file! " + fileName, e, true);
+		}// try
 	}
-	
-	public void writeSingleFile(int format, String fileName){
+
+	public void writeSingleFile(int format, String fileName) {
 		RandomAccessFile out = null;
 		File dfile;
 
@@ -173,53 +179,53 @@
 		Handle h = new Handle();
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
+		pbf.setTask(h, "Exporting ...");
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			dfile = new File(fileName);
 			dfile.delete();
-			out =  new RandomAccessFile(fileName,"rw");
-			for(int i = 0; i<cacheDB.size(); i++){
-				holder=cacheDB.get(i);
-				if(holder.isVisible()){
+			out = new RandomAccessFile(fileName, "rw");
+			for (int i = 0; i < cacheDB.size(); i++) {
+				holder = cacheDB.get(i);
+				if (holder.isVisible()) {
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
-					if (holder.pos.isValid() == false) continue;
-					if (format == TT_ASC){
-						writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+					if (holder.getPos().isValid() == false)
+						continue;
+					if (format == TT_ASC) {
+						writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					} else {
-						writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					}
-				}//if
-			}//for
+				}// if
+			}// for
 			out.close();
-			copyIcon(0, fileName.substring(0,fileName.indexOf(".")),"");
+			copyIcon(0, fileName.substring(0, fileName.indexOf(".")), "");
 			pbf.exit(0);
-		}catch (Exception e){
-			pref.log("Problem writing to file! " + fileName,e,true);
-		}//try
+		} catch (Exception e) {
+			pref.log("Problem writing to file! " + fileName, e, true);
+		}// try
 	}
-	
-	
-	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+
+	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
 		try {
 			outp.writeBytes(lon);
 			outp.writeBytes(",");
 			outp.writeBytes(lat);
 			outp.writeBytes(",");
-			//outp.writeBytes("\"" + ch.CacheName.replace(',',' ') + "\"\r\n");
+			// outp.writeBytes("\"" + ch.CacheName.replace(',',' ') + "\"\r\n");
 			outp.writeBytes("\"");
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(" - ");
-			outp.writeBytes(ch.getCacheName().replace(',',' '));
+			outp.writeBytes(ch.getCacheName().replace(',', ' '));
 			outp.writeBytes(" by ");
 			outp.writeBytes(ch.getCacheOwner());
-			outp.writeBytes("- ");             
+			outp.writeBytes("- ");
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes("/");
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
@@ -227,52 +233,53 @@
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			outp.writeBytes("\"\r\n");
 		} catch (IOException e) {
-			pref.log("Error writing to file",e,true);
+			pref.log("Error writing to file", e, true);
 		}
 		return;
 	}
 
-	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
-		int d,data;
+	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
+		int d, data;
 		double latlon;
-		
+
 		try {
 			d = 2;
-			outp.writeByte((byte)d);
-			data = ch.getWayPoint().length()+ch.getCacheName().length()+ch.getCacheOwner().length()+String.valueOf(ch.getHard()).length()+String.valueOf(ch.getTerrain()).length()+CacheSize.cw2ExportString(ch.getCacheSize()).length()+27;
+			outp.writeByte((byte) d);
+			data = ch.getWayPoint().length() + ch.getCacheName().length() + ch.getCacheOwner().length() + String.valueOf(ch.getHard()).length() + String.valueOf(ch.getTerrain()).length() + CacheSize.cw2ExportString(ch.getCacheSize()).length() + 27;
 			writeIntBinary(outp, data);
 			latlon = Common.parseDouble(lon);
-			latlon *=100000;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
-			latlon = Common.parseDouble(lat);;
-			latlon *=100000;
+			latlon = Common.parseDouble(lat);
+			;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(" - ");
 			outp.writeBytes(ch.getCacheName());
 			outp.writeBytes(" by ");
 			outp.writeBytes(ch.getCacheOwner());
-			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
-			//Hier wieder einf?gen
-			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
-			//wider um 1 erh?hen
-			outp.writeBytes("- ");             
+			// Wenn Leerzeichen am Ende von Cache.Owner entfernt:
+			// Hier wieder einf?gen
+			// und data = holder.wayPoint.length()+holder.CacheName.length()+.....
+			// wider um 1 erh?hen
+			outp.writeBytes("- ");
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes("/");
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
 			outp.writeBytes(" - ");
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			d = 0;
-			outp.writeByte((byte)d);
+			outp.writeByte((byte) d);
 		} catch (IOException e) {
-			pref.log("Error writing to file",e,true);
+			pref.log("Error writing to file", e, true);
 		}
 
 		return;
 	}
 
-	public void writeIntBinary(RandomAccessFile outp, int data){
-		
+	public void writeIntBinary(RandomAccessFile outp, int data) {
+
 		ByteArray buf = new ByteArray();
 		buf.appendInt(data);
 		try {
@@ -281,42 +288,44 @@
 			outp.writeByte(buf.data[1]);
 			outp.writeByte(buf.data[0]);
 		} catch (IOException e) {
-			pref.log("Error writing to file",e,true);
+			pref.log("Error writing to file", e, true);
 		}
 
 		return;
 	}
-	
-	public void copyIcon(int intWayType, String prefix, String typeName){
-		ZipFile zif=null;
+
+	public void copyIcon(int intWayType, String prefix, String typeName) {
+		ZipFile zif = null;
 		try {
-			zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+"exporticons"+FileBase.separator+"TomTom.zip");
-		} catch (IOException e) {}
+			zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "TomTom.zip");
+		} catch (IOException e) {
+		}
 		try {
 			if (zif == null) {
-				zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+"exporticons"+ FileBase.separator+"exporticons"+FileBase.separator+"TomTom.zip");
+				zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "exporticons" + FileBase.separator + "TomTom.zip");
 			}
 			ZipEntry zipEnt;
 			int len;
-			String entName; 
-			
+			String entName;
+
 			entName = "GC-" + typeName + ".bmp";
 			zipEnt = zif.getEntry(entName);
-			if (zipEnt == null) return;
-			
-		    byte[] buff = new byte[ zipEnt.getSize() ];
-		    InputStream  fis = zif.getInputStream(zipEnt);
-		    FileOutputStream fos = new FileOutputStream( prefix + typeName + ".bmp");
-		    while( 0 < (len = fis.read( buff )) )
-		      fos.write( buff, 0, len );
-		    fos.flush();
-		    fos.close();
-		    fis.close();
+			if (zipEnt == null)
+				return;
+
+			byte[] buff = new byte[zipEnt.getSize()];
+			InputStream fis = zif.getInputStream(zipEnt);
+			FileOutputStream fos = new FileOutputStream(prefix + typeName + ".bmp");
+			while (0 < (len = fis.read(buff)))
+				fos.write(buff, 0, len);
+			fos.flush();
+			fos.close();
+			fis.close();
 		} catch (ZipException e) {
-			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp" ,e,true);
+			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp", e, true);
 		} catch (IOException e) {
-			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp" ,e,true);
+			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp", e, true);
 		}
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -28,21 +28,16 @@
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.Common;
-import CacheWolf.HttpConnection;
 import CacheWolf.MyLocale;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
-import CacheWolf.imp.SpiderGC.SpiderProperties;
-import ewe.io.IOException;
-import ewe.io.JavaUtf8Codec;
+import CacheWolf.UrlFetcher;
 import ewe.io.Reader;
 import ewe.io.StringReader;
-import ewe.net.Socket;
 import ewe.sys.Handle;
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
 import ewe.ui.ProgressBarForm;
-import ewe.util.CharArray;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
@@ -58,19 +53,15 @@
 	private String GCVWaypoints;
 	private String GCVResults;
 	private static Preferences pref;
-	private static SpiderProperties p=null;
 
 	/**
 	*	Constructor initalizing profile and cacheDB
 	*/
-	public GCVoteImporter(Preferences prf, Profile _profile, boolean bypass){
+	public GCVoteImporter(Preferences prf, Profile _profile){
 		this.profile=_profile;
 		this.cacheDB = profile.cacheDB;
 		pref = prf;
-		if (p == null) {
-			pref.logInit();
-		}
-		// initialiseProperties();
+		// pref.logInit();
 	}
 
 	/**
@@ -108,9 +99,7 @@
 
 			try {
 				pref.log("[GCVote]:Requesting ratings");
-
-				// request web page http://gcvote.de/getVotes.php
-				GCVResults = getResponse(GCVURL);
+				GCVResults = UrlFetcher.fetch(GCVURL);
 				if (GCVResults.equals("")) {
 					(new MessageBox(MyLocale.getMsg(0,"Error"), MyLocale.getMsg(0,"Error loading GCVote page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 					pref.log("[GCVote]:Could not fetch: getVotes.php page",null);
@@ -143,34 +132,4 @@
 			cb.setNumRecommended( 100*voteCnt + (int)(voteAvg + 0.5));
 		}
 	}
-
-	/**
-	*	Perform an request to fetch the GCVote results
-	*/
-	public static String getResponse(String address) {
-		CharArray c_data;
-		try{
-			HttpConnection conn;
-			if(pref.myproxy.length() > 0 && pref.proxyActive){
-				pref.log("[GCVote]:Using proxy: " + pref.myproxy + " / " +pref.myproxyport);
-			}
-			conn = new HttpConnection(address);
-			conn.setRequestorProperty("User-Agent", "Mozilla/5.0 (compatible; Cachewolf; GCVoteImporter)");
-			conn.setRequestorProperty("Connection", "close");
-			conn.documentIsEncoded = true;
-			pref.log("[GCVote]:Connecting "+address);
-			Socket sock = conn.connect();
-			pref.log("[GCVote]:Connect ok! "+address);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			c_data = conn.readText(sock, codec);
-			sock.close();
-			pref.log("[GCVote]:Read data ok "+address);
-			return c_data.toString();
-		}catch(IOException ioex){
-			pref.log("IOException in fetch", ioex);
-		}finally{
-			//continue
-		}
-		return "";
-	}
 }

Modified: branches/r1.2/src/CacheWolf/imp/GPXImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/GPXImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/GPXImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,32 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-import com.stevesoft.ewe_pat.Regex;
-
+import CacheWolf.Attribute;
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheSize;
@@ -35,20 +34,31 @@
 import CacheWolf.Common;
 import CacheWolf.Extractor;
 import CacheWolf.Filter;
+import CacheWolf.ImageInfo;
 import CacheWolf.InfoBox;
 import CacheWolf.Log;
 import CacheWolf.MyLocale;
+import CacheWolf.OC;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
 import CacheWolf.STRreplace;
 import CacheWolf.SafeXML;
 import CacheWolf.Travelbug;
+import CacheWolf.UrlFetcher;
 import CacheWolf.imp.SpiderGC.SpiderProperties;
+import CacheWolf.navi.TrackPoint;
+import CacheWolf.utils.FileBugfix;
+
+import com.stevesoft.ewe_pat.Regex;
+
+import ewe.io.File;
 import ewe.io.FileInputStream;
+import ewe.io.IOException;
+import ewe.net.MalformedURLException;
+import ewe.net.URL;
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
 import ewe.util.Enumeration;
 import ewe.util.Vector;
 import ewe.util.zip.ZipEntry;
@@ -58,12 +68,12 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
-*	Class to import Data from an GPX File. If cache data exists, the data from 
-*	the GPX-File is ignored.
-*	Class ID = 4000
-*/
+ * Class to import Data from an GPX File. If cache data exists, the data from
+ * the GPX-File is ignored.
+ * Class ID = 4000
+ */
 public class GPXImporter extends MinML {
-	
+
 	static Preferences pref;
 	Profile profile;
 	CacheDB cacheDB;
@@ -72,7 +82,7 @@
 	boolean inWpt, inCache, inLogs, inBug;
 	public XMLElement document;
 	private Vector files = new Vector();
-	private boolean debugGPX = false; 
+	private boolean debugGPX = false;
 	InfoBox infB;
 	boolean spiderOK = true;
 	boolean doSpider = false;
@@ -88,16 +98,17 @@
 	SpiderProperties propsSpider;
 	StringBuffer strBuf;
 	private int doitHow;
-	
-	public GPXImporter(Preferences p, Profile prof, String f )
-	{
-		profile=prof;
+	private String attID;
+	private String attInc;
+
+	public GPXImporter(Preferences p, Profile prof, String f) {
+		profile = prof;
 		pref = p;
 		cacheDB = profile.cacheDB;
-		//file = f;
+		// file = f;
 		files.add(f);
 		saveDir = profile.dataDir;
-		//msgA = msgArea;
+		// msgA = msgArea;
 		inWpt = false;
 		inCache = false;
 		inLogs = false;
@@ -105,17 +116,19 @@
 		doitHow = DOIT_ASK;
 	}
 
-	public void doIt(int how){
+	public void doIt(int how) {
 		doitHow = how;
 		Filter flt = new Filter();
-		boolean wasFiltered = (profile.getFilterActive()==Filter.FILTER_ACTIVE);
+		boolean wasFiltered = (profile.getFilterActive() == Filter.FILTER_ACTIVE);
 		flt.clearFilter();
-		try{
+		try {
 			ewe.io.Reader r;
 			String file;
 			if (how == DOIT_ASK) {
-				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,"Spider Options"), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
-				if (options.execute() == FormBase.IDCANCEL) { return; }
+				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510, "Spider Options"), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ISGC);
+				if (options.execute() == FormBase.IDCANCEL) {
+					return;
+				}
 				doSpider = options.imagesCheckBox.getState();
 				options.close(0);
 			} else if (how == DOIT_NOSPOILER) {
@@ -124,28 +137,27 @@
 				doSpider = true;
 			}
 			if (doSpider) {
-				imgSpider = new SpiderGC(pref, profile, false);
+				imgSpider = new SpiderGC(pref, profile);
 				doitHow = DOIT_WITHSPOILER;
 			} else {
 				doitHow = DOIT_NOSPOILER;
 			}
-			
+
 			Vm.showWait(true);
-			for (int i=0; i<files.size();i++){
-				//Test for zip.file
-				file = (String)files.get(i);
-				if (file.indexOf(".zip") > 0){
-					ZipFile zif = new ZipFile (file);
+			for (int i = 0; i < files.size(); i++) {
+				// Test for zip.file
+				file = (String) files.get(i);
+				if (file.indexOf(".zip") > 0) {
+					ZipFile zif = new ZipFile(file);
 					ZipEntry zipEnt;
 					Enumeration zipEnum = zif.entries();
 					// there could be more than one file in the archive
-					while (zipEnum.hasMoreElements())
-					{
+					while (zipEnum.hasMoreElements()) {
 						zipEnt = (ZipEntry) zipEnum.nextElement();
 						// skip over PRC-files
-						if (zipEnt.getName().endsWith("gpx")){
+						if (zipEnt.getName().endsWith("gpx")) {
 							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel));
+							infB = new InfoBox(zipEnt.toString(), (MyLocale.getMsg(4000, "Loaded caches: ") + zaehlerGel));
 							infB.exec();
 							if (r.read() != 65279)
 								r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
@@ -154,11 +166,11 @@
 							infB.close(0);
 						}
 					}
-				}
-				else {
+					zif.close();
+				} else {
 					FileInputStream rFIS = new ewe.io.FileInputStream(file);
 					r = new ewe.io.InputStreamReader(rFIS);
-					infB = new InfoBox("Info",(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel));
+					infB = new InfoBox("Info", (MyLocale.getMsg(4000, "Loaded caches: ") + zaehlerGel));
 					infB.show();
 					if (r.read() != 65279) {
 						r.close();
@@ -171,47 +183,59 @@
 					rFIS.close();
 					infB.close(0);
 				}
-				// save Index 
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				// save Index
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				infB.close(0);
 			}
-				Vm.showWait(false);
-			}catch(Exception e){
-				pref.log("[GPXExporter:DoIt]",e,true);
-				Vm.showWait(false);
+			Vm.showWait(false);
+		} catch (Exception e) {
+			if (holder.getWayPoint().length() > 0) {
+				pref.log("[GPXImporter:DoIt] " + holder.getWayPoint() + " LogID=" + logId, e, true);
+			} else {
+				pref.log("[GPXImporter:DoIt] " + holder.getPos().toString() + " LogID=" + logId, e, true);
 			}
-		if(wasFiltered){
+			infB.close(0);
+			Vm.showWait(false);
+		}
+		if (wasFiltered) {
 			flt.setFilter();
 			flt.doFilter();
 		}
 	}
-	public void startElement(String name, AttributeList atts){
-		strBuf=new StringBuffer(300);
-		if(infB.isClosed)  return;
-		if (name.equals("gpx")){
+
+	public void startElement(String name, AttributeList atts) {
+		strBuf = new StringBuffer(300);
+		if (infB.isClosed)
+			return;
+		if (name.equals("gpx")) {
 			// check for opencaching
-			if (atts.getValue("creator").indexOf("opencaching")> 0) fromOC = true;
-			else fromOC = false;
-			if (atts.getValue("creator").startsWith("TerraCaching")) fromTC = true;
-			else fromTC = false;
+			if (atts.getValue("creator").indexOf("opencaching") > 0)
+				fromOC = true;
+			else
+				fromOC = false;
+			if (atts.getValue("creator").startsWith("TerraCaching"))
+				fromTC = true;
+			else
+				fromTC = false;
 
-			if (fromOC && doSpider) (new MessageBox("Warnung", MyLocale.getMsg(4001, "GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching"), FormBase.OKB)).execute();
+			// if (fromOC && doSpider) (new MessageBox("Warnung", MyLocale.getMsg(4001,
+			// "GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching"), FormBase.OKB)).execute();
 			zaehlerGel = 0;
 		}
 		if (name.equals("wpt")) {
 			holder = new CacheHolder();
-			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon"))));
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
 			nameFound = false;
 			zaehlerGel++;
-			infB.setInfo(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel);
+			infB.setInfo(MyLocale.getMsg(4000, "Loaded caches: ") + zaehlerGel);
+			logId = "";
 			return;
 		}
-		
-		if (name.equals("link")&& inWpt){
+
+		if (name.equals("link") && inWpt) {
 			holder.getCacheDetails(false).URL = atts.getValue("href");
 			return;
 		}
@@ -220,42 +244,51 @@
 			inCache = true;
 			holder.setAvailable(atts.getValue("available").equals("True"));
 			holder.setArchived(atts.getValue("archived").equals("True"));
+			// OC now has GC - Format, get CacheID -- missing p.ex. on GcTour gpx
+			for (int i = 0; i < atts.getLength(); i++) {
+				if (atts.getName(i).equals("id")) {
+					holder.setOcCacheID(atts.getValue("id"));
+					break;
+				}
+			}
 			return;
 		}
 		// OC
-		if (name.equals("geocache")|| name.equals("cache")) {
+		if (name.equals("geocache") || name.equals("cache")) {
 			boolean available = false;
-			boolean archived  = false;
-			inCache=true;
+			boolean archived = false;
+			inCache = true;
 			// get CacheID -- missing p.ex. on GcTour gpx
 			for (int i = 0; i < atts.getLength(); i++) {
 				if (atts.getName(i).equals("id")) {
-					String ocCacheID = atts.getValue("id");
-					holder.setOcCacheID(ocCacheID);
+					holder.setOcCacheID(atts.getValue("id"));
 					break;
 				}
 			}
 			// get status
-			String status = new String(atts.getValue("status"));
-			if (status.equals("Available")) available = true;
-			else if (status.equals("Unavailable")) available = false;
-			else if (status.equals("Draft")) available = false;
-			else if (status.equals("Archived")) archived = true;
+			String status = atts.getValue("status");
+			if (status.equals("Available"))
+				available = true;
+			else if (status.equals("Unavailable"))
+				available = false;
+			else if (status.equals("Draft"))
+				available = false;
+			else if (status.equals("Archived"))
+				archived = true;
 			holder.setArchived(archived);
 			holder.setAvailable(available);
 			return;
 		}
-		
+
 		if (name.equals("terra:terracache")) {
-			inCache=true;
+			inCache = true;
 		}
 
-		
 		if (name.indexOf("long_description") > -1) {
 			holder.setHTML(atts.getValue("html").toLowerCase().equals("true"));
 		}
-		if (name.equals("description") || name.equals("terra:description") ) {
-			//set HTML always to true if from oc.de or TC
+		if (name.equals("description") || name.equals("terra:description")) {
+			// set HTML always to true if from oc.de or TC
 			holder.setHTML(true);
 		}
 
@@ -273,105 +306,105 @@
 			holder.getCacheDetails(false).Travelbugs.clear();
 			return;
 		}
-		if (debugGPX){
+		if (name.equals("groundspeak:attribute")) {
+			attID = atts.getValue("id");
+			attInc = atts.getValue("inc");
+			return;
+		}
+		if (debugGPX) {
 			for (int i = 0; i < atts.getLength(); i++) {
-				pref.log("[GPXExporter:startElement]Type: " + atts.getType(i) + " Name: " + atts.getName(i)+ " Value: "+atts.getValue(i),null);
+				pref.log("[GPXExporter:startElement]Type: " + atts.getType(i) + " Name: " + atts.getName(i) + " Value: " + atts.getValue(i), null);
 			}
-		}	
-		if (name.equals("groundspeak:attribute")) {
-			int id = Integer.parseInt(atts.getValue("id"));
-			holder.getCacheDetails(false).attributes.add(id,atts.getValue("inc")); // from GC!
-			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
+		}
+	}
+
+	public void endElement(String name) {
+		strData = strBuf.toString();
+		if (infB.isClosed)
 			return;
-		}		
-	}
-	
-	public void endElement(String name){
-		strData=strBuf.toString();
-		if(infB.isClosed) return;
 		// logs
-		if (inLogs){
-			if (name.equals("groundspeak:date")|| name.equals("time")|| name.equals("date")|| name.equals("terra:date"))  {
-				logDate = new String(strData.substring(0,10));
+		if (inLogs) {
+			if (name.equals("groundspeak:date") || name.equals("time") || name.equals("date") || name.equals("terra:date")) {
+				logDate = new String(strData.substring(0, 10));
 				return;
 			}
-			if (name.equals("groundspeak:type") || name.equals("type") || name.equals("terra:type")){
+			if (name.equals("groundspeak:type") || name.equals("type") || name.equals("terra:type")) {
 				logIcon = new String(Log.typeText2Image(strData));
 				return;
 			}
-			if (name.equals("groundspeak:finder")|| name.equals("geocacher")|| name.equals("finder")|| name.equals("terra:user")){
+			if (name.equals("groundspeak:finder") || name.equals("geocacher") || name.equals("finder") || name.equals("terra:user")) {
 				logFinder = new String(strData);
 				return;
 			}
-			if (name.equals("groundspeak:text") || name.equals("text") || name.equals("terra:entry")){ 
+			if (name.equals("groundspeak:text") || name.equals("text") || name.equals("terra:entry")) {
 				logData = new String(strData);
 				return;
 			}
-			if (name.equals("groundspeak:log") || name.equals("log") || name.equals("terra:log") ) {
-				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
-				if((logIcon.equals("icon_smile.gif") || logIcon.equals("icon_camera.gif") || logIcon.equals("icon_attended.gif")) && 
-						  (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
-							holder.setCacheStatus(logDate);
-							holder.setFound(true);
-							holder.getCacheDetails(false).OwnLogId = logId;
-							holder.getCacheDetails(false).OwnLog = new Log(logIcon,logDate,logFinder,logData);
+			if (name.equals("groundspeak:log") || name.equals("log") || name.equals("terra:log")) {
+				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon, logDate, logFinder, logData));
+				if ((logIcon.equals("icon_smile.gif") || logIcon.equals("icon_camera.gif") || logIcon.equals("icon_attended.gif"))
+						&& (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() > 0 && SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
+					holder.setCacheStatus(logDate);
+					holder.setFound(true);
+					holder.getCacheDetails(false).OwnLogId = logId;
+					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData);
 				}
 				return;
 			}
 		}
-		
-		if (name.equals("wpt")){
-			
-			int index=cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){// Add cache Data only, if waypoint not already in database
+
+		if (name.equals("wpt")) {
+
+			int index = cacheDB.getIndex(holder.getWayPoint());
+			if (index == -1) {// Add cache Data only, if waypoint not already in database
 				holder.setNoFindLogs(holder.getCacheDetails(false).CacheLogs.countNotFoundLogs());
 				holder.setNew(true);
 				cacheDB.add(holder);
 				// don't spider additional waypoints, so check
 				// if waypoint starts with "GC"
-				if(doSpider) {
-					if(spiderOK && holder.is_archived() == false){
-							if(holder.getLatLon().length() > 1){
+				if (doSpider) {
+					if (spiderOK && holder.is_archived() == false) {
+						// spiderImages();
+						spiderImagesUsingSpider();
+						// Rename image sources
+						String text;
+						String orig;
+						String imgName;
+						orig = holder.getCacheDetails(false).LongDescription;
+
+						Extractor ex = new Extractor(orig, "<img src=\"", ">", 0, false);
+						int num = 0;
+						while ((text = ex.findNext()).length() > 0 && spiderOK) {
+							if (num >= holder.getCacheDetails(false).images.size())
+								break;
+							imgName = holder.getCacheDetails(false).images.get(num).getTitle();
+							holder.getCacheDetails(false).LongDescription = STRreplace.replace(holder.getCacheDetails(false).LongDescription, text, "[[Image: " + imgName + "]]");
+							num++;
 						}
-						if(holder.getWayPoint().startsWith("GC")|| fromTC) {
-							//spiderImages();
-							spiderImagesUsingSpider();
-							//Rename image sources
-							String text;
-							String orig;
-							String imgName;
-							orig = holder.getCacheDetails(false).LongDescription;
-							Extractor ex = new Extractor(orig, "<img src=\"", ">", 0, false);
-							text = ex.findNext();
-							int num = 0;
-							while(ex.endOfSearch() == false && spiderOK){
-								if (num >= holder.getCacheDetails(false).images.size())break;
-								imgName = holder.getCacheDetails(false).images.get(num).getTitle();
-								holder.getCacheDetails(false).LongDescription = STRreplace.replace(holder.getCacheDetails(false).LongDescription, text, "[[Image: " + imgName + "]]");
-								num++;
-								text = ex.findNext();
-							}
-						}
 					}
 				}
 				holder.save();
-				//crw.saveIndex(cacheDB,saveDir);
+				// crw.saveIndex(cacheDB,saveDir);
 			}
-			//Update cache data
+			// Update cache data
 			else {
-				CacheHolder oldCh= cacheDB.get(index);
+				CacheHolder oldCh = cacheDB.get(index);
 				// Preserve images: Copy images from old cache version because here we didn't add
 				// any image information to the holder object.
-				holder.getCacheDetails(false).images = oldCh.getCacheDetails(true).images;
+				if (pref.downloadPics && holder.isOC()) {
+					spiderImagesUsingSpider();
+				} else {
+					holder.getCacheDetails(false).images = oldCh.getCacheDetails(true).images;
+				}
 				oldCh.initStates(false);
 				oldCh.update(holder);
 				oldCh.save();
 			}
-			
+
 			inWpt = false;
 			return;
 		}
-		if (name.equals("sym")&& strData.endsWith("Found")) {
+		if (name.equals("sym") && strData.endsWith("Found")) {
 			holder.setFound(true);
 			holder.setCacheStatus(holder.getFoundText());
 			return;
@@ -381,88 +414,86 @@
 			return;
 		}
 
-		if (name.equals("groundspeak:name")&& inBug) {
-			Travelbug tb=new Travelbug(strData);
+		if (name.equals("groundspeak:name") && inBug) {
+			Travelbug tb = new Travelbug(strData);
 			holder.getCacheDetails(false).Travelbugs.add(tb);
 			holder.setHas_bugs(true);
 			return;
 		}
-		
-		if (name.equals("time") && !inWpt) {		    
+
+		if (name.equals("time") && !inWpt) {
 			try {
-			    gpxDate.parse(strData.substring(0,19),"yyyy-MM-dd'T'HH:mm:ss");
+				gpxDate.parse(strData.substring(0, 19), "yyyy-MM-dd'T'HH:mm:ss");
 			} catch (IllegalArgumentException e) {
-			    gpxDate.setTime(0);
-			    pref.log("[GPXImporter:endElement]Error parsing Element time: '"+strData+"'. Ignoring.");
+				gpxDate.setTime(0);
+				pref.log("[GPXImporter:endElement]Error parsing Element time: '" + strData + "'. Ignoring.");
 			}
 			return;
 		}
 
 		if (name.equals("time") && inWpt) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
 		// cache information
-		if (name.equals("groundspeak:cache") || name.equals("geocache")|| name.equals("cache")|| name.equals("terra:terracache")) {
+		if (name.equals("groundspeak:cache") || name.equals("geocache") || name.equals("cache") || name.equals("terra:terracache")) {
 			inCache = false;
 		}
-		
+
 		if (name.equals("name") && inWpt && !inCache) {
 			holder.setWayPoint(strData);
-			if (gpxDate.getTime()!=0) {
-			    holder.setLastSync(gpxDate.format("yyyyMMddHHmmss"));
+			if (gpxDate.getTime() != 0) {
+				holder.setLastSync(gpxDate.format("yyyyMMddHHmmss"));
 			} else {
-			    holder.setLastSync("");
-			}    
-			//msgA.setText("import " + strData);
+				holder.setLastSync("");
+			}
+			// msgA.setText("import " + strData);
 			return;
 		}
 
 		// fill name with contents of <desc>, in case of gc.com the name is
 		// later replaced by the contents of <groundspeak:name> which is shorter
-		if (name.equals("desc")&& inWpt ) {
+		if (name.equals("desc") && inWpt) {
 			holder.setCacheName(strData);
-			//msgA.setText("import " + strData);
+			// msgA.setText("import " + strData);
 			return;
 		}
-		if (name.equals("url")&& inWpt){
+		if (name.equals("url") && inWpt) {
 			holder.getCacheDetails(false).URL = strData;
 			return;
 		}
-		
+
 		// Text for additional waypoints, no HTML
-		if (name.equals("cmt")&& inWpt){
+		if (name.equals("cmt") && inWpt) {
 			holder.getCacheDetails(false).LongDescription = strData;
 			holder.setHTML(false);
 			return;
 		}
-		
+
 		// aditional wapypoint
-		if (name.equals("type")&& inWpt && !inCache && strData.startsWith("Waypoint")){
+		if (name.equals("type") && inWpt && !inCache && strData.startsWith("Waypoint")) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 			holder.setHard(CacheTerrDiff.CW_DT_UNSET);
 			holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
 			holder.setLastSync("");
 		}
-		
-		if (name.indexOf("name")>-1 && inCache) {
+
+		if (name.indexOf("name") > -1 && inCache) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if (name.equals("groundspeak:owner") || name.equals("owner")||name.equals("terra:owner")) {
+		if (name.equals("groundspeak:owner") || name.equals("owner") || name.equals("terra:owner")) {
 			holder.setCacheOwner(strData);
-			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-				(pref.myAlias2.length()>0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() > 0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
 				holder.setOwned(true);
 			return;
 		}
 		if (name.equals("groundspeak:placed_by")) {
-			if(holder.getCacheOwner().equals("")) {
+			if (holder.getCacheOwner().equals("")) {
 				holder.setCacheOwner(strData);
-				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-						(pref.myAlias2.length()>0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
-						holder.setOwned(true);
+				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() > 0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+					holder.setOwned(true);
 			}
 			return;
 		}
@@ -470,11 +501,11 @@
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if (name.equals("groundspeak:terrain")|| name.equals("terrain")|| name.equals("terra:physical_challenge")) {
+		if (name.equals("groundspeak:terrain") || name.equals("terrain") || name.equals("terra:physical_challenge")) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if ((name.equals("groundspeak:type") || name.equals("type")|| name.equals("terra:style"))&& inCache){
+		if ((name.equals("groundspeak:type") || name.equals("type") || name.equals("terra:style")) && inCache) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			if (holder.isCustomWpt()) {
 				holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
@@ -483,95 +514,258 @@
 			}
 			return;
 		}
-		if (name.equals("groundspeak:container")|| name.equals("container")){
+		if (name.equals("groundspeak:container") || name.equals("container")) {
 			holder.setCacheSize(CacheSize.gcGpxString2Cw(strData));
 			return;
 		}
-		if (name.equals("groundspeak:country")|| name.equals("country")){
+		if (name.equals("groundspeak:country") || name.equals("country")) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
-		if (name.equals("groundspeak:state")|| name.equals("state")){
+		if (name.equals("groundspeak:state") || name.equals("state")) {
 			holder.getCacheDetails(false).State = strData;
 			return;
 		}
-		if (name.equals("terra:size")){
+		if (name.equals("terra:size")) {
 			holder.setCacheSize(CacheSize.tcGpxString2Cw(strData));
 		}
 
-		if (name.indexOf("short_description") > -1|| name.equals("summary")) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
-			else holder.getCacheDetails(false).LongDescription =strData+"\n";
+		if (name.indexOf("short_description") > -1 || name.equals("summary")) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription = SafeXML.cleanback(strData) + "<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
+			else
+				holder.getCacheDetails(false).LongDescription = strData + "\n";
 			return;
 		}
 
-		if (name.indexOf("long_description") > -1 || name.equals("description")|| name.equals("terra:description")) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.indexOf("long_description") > -1 || name.equals("description") || name.equals("terra:description")) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
 		if (name.indexOf("encoded_hints") > -1 || name.equals("hints")) {
-			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData),"\n","<br>"),"\t","");
+			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData), "\n", "<br>"), "\t", "");
 			return;
 		}
-		
+
 		if (name.equals("terra:hint")) {
 			// remove "&lt;br&gt;<br>" from the end
 			int indexTrash = strData.indexOf("&lt;br&gt;<br>");
-			if (indexTrash > 0)	holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0,indexTrash)),"\n","<br>"),"\t","");
+			if (indexTrash > 0)
+				holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0, indexTrash)), "\n", "<br>"), "\t", "");
 			return;
 		}
 
+		if (name.equals("groundspeak:attribute")) {
+			if (attID.equals("")) {
+				attID = Attribute.getIdFromGCText(strData);
+			}
+			int id = Integer.parseInt(attID);
+			holder.getCacheDetails(false).attributes.add(id, attInc);
+			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
+			return;
+		}
 
 	}
-	public void characters(char[] ch,int start,int length){
-		strBuf.append(ch,start,length);
-		if (debugGPX) pref.log("Char: " + strBuf.toString(),null);
+
+	public void characters(char[] ch, int start, int length) {
+		strBuf.append(ch, start, length);
+		if (debugGPX)
+			pref.log("Char: " + strBuf.toString(), null);
 	}
-	
-	public static String TCSizetoText(String size){
-		if (size.equals("1")) return "Micro";
-		if (size.equals("2")) return "Medium";
-		if (size.equals("3")) return "Regular";
-		if (size.equals("4")) return "Large";
-		if (size.equals("5")) return "Very Large";
 
+	public static String TCSizetoText(String size) {
+		if (size.equals("1"))
+			return "Micro";
+		if (size.equals("2"))
+			return "Medium";
+		if (size.equals("3"))
+			return "Regular";
+		if (size.equals("4"))
+			return "Large";
+		if (size.equals("5"))
+			return "Very Large";
+
 		return "None";
 	}
-	
-	private void spiderImagesUsingSpider(){
-		String addr;
+
+	private void spiderImagesUsingSpider() {
+		String addresse;
 		String cacheText;
-		
+
 		// just to be sure to have a spider object
-		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
-		if (propsSpider == null) {propsSpider = imgSpider.new SpiderProperties();	}
-		
+		if (imgSpider == null)
+			imgSpider = new SpiderGC(pref, profile);
+		if (propsSpider == null) {
+			propsSpider = imgSpider.new SpiderProperties();
+		}
+
 		try {
-				if (fromTC) {
-						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
-				}
-				else {
-					addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + holder.getWayPoint() ;
-					cacheText = SpiderGC.fetchText(addr,false);
+			if (fromTC) {
+				imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+			} else {
+				if (fromOC) {
+					holder.getCacheDetails(false).images.clear();
+					addresse = holder.getCacheDetails(false).URL;
+					cacheText = UrlFetcher.fetch(addresse);
+					Extractor exBeschreibung = new Extractor(cacheText, "<!-- Beschreibung -->", "<!-- End Beschreibung -->", 0, false);
+					String beschreibung = exBeschreibung.findNext();
+					getOCPictures(beschreibung);
+					Extractor exBilder = new Extractor(cacheText, "<!-- Bilder -->", "<!-- End Bilder -->", 0, false);
+					String bilder = exBilder.findNext();
+					getOCPictures(bilder);
+				} else {
+					addresse = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + holder.getWayPoint();
+					cacheText = UrlFetcher.fetch(addresse);
 					if (cacheText.indexOf(propsSpider.getProp("premiumCachepage")) > 0) {
 						// Premium cache spidered by non premium member
-						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
+						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+					} else {
+						imgSpider.getImages(cacheText, holder.getCacheDetails(false), true);
 					}
-					else {
-						imgSpider.getImages(cacheText, holder.getCacheDetails(false),true);
-					}
 					try {
 						imgSpider.getAttributes(cacheText, holder.getCacheDetails(false));
 					} catch (Exception e) {
-						pref.log("unable to fetch attrivbutes for"+holder.getWayPoint(), e);
+						pref.log("unable to fetch attributes for" + holder.getWayPoint(), e);
 					}
 				}
+			}
 		} catch (Exception e1) {
 			// e1.printStackTrace();
 		}
 	}
-	
+
+	private void getOCPictures(String html) {
+		Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)");
+		imgRegexUrl.setIgnoreCase(true);
+		int descIndex = 0;
+		while (imgRegexUrl.searchFrom(html, descIndex)) {
+			descIndex = imgRegexUrl.matchedTo();
+			String fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anf?hrungszeichen in (2)
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			} // falls ohne in (3)
+			if (fetchUrl == null) {
+				continue;
+			} // schlechtes html
+				// fetchUrl ist auf jeden Fall ohne Anf?hrungszeichen
+			if (fetchUrl.startsWith("resource"))
+				continue; //
+			if (fetchUrl.startsWith("images")) // z.B. Flaggen
+				if (!fetchUrl.startsWith("images/uploads"))
+					continue;
+			if (fetchUrl.startsWith("thumbs"))
+				continue; // z.B. Flaggen
+			try {
+				// TODO this is not quite correct: actually the "base" URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
+				String hostname = OC.getOCHostName(holder.getWayPoint());
+				if (!fetchUrl.startsWith("http://")) {
+					fetchUrl = new URL(new URL("http://" + hostname + "/"), fetchUrl).toString();
+				}
+			} catch (MalformedURLException e) {
+				continue;
+			} // auch egal
+			ImageInfo imageInfo = new ImageInfo();
+			imageInfo.setURL(fetchUrl);
+			imageInfo.setTitle(makeTitle(imgRegexUrl.stringMatched(1), fetchUrl));
+			getPic(imageInfo);
+		}
+
+		Extractor exHref = new Extractor(html, "<a href=", "</a>", 0, true);
+		String href = "";
+		Extractor exHttp = new Extractor(href, "http://", "\"", 0, true);
+		while ((href = exHref.findNext()).length() > 0) {
+			exHttp.set(href, "http://", "\"", 0, true);
+			String fetchUrl = exHttp.findNext();
+			if (fetchUrl.length() > 0) {
+				try {
+					String imgType = (fetchUrl.substring(fetchUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
+					fetchUrl = "http://" + fetchUrl.substring(0, fetchUrl.lastIndexOf('.') + imgType.length());
+					if (imgType.startsWith(".jpg") || imgType.startsWith(".bmp") || imgType.startsWith(".png") || imgType.startsWith(".gif")) {
+						ImageInfo imageInfo = new ImageInfo();
+						imageInfo.setURL(fetchUrl);
+						imageInfo.setTitle(makeTitle(href, fetchUrl));
+						getPic(imageInfo);
+					}
+				} catch (IndexOutOfBoundsException e) {
+				}
+			}
+		}
+	}
+
+	private String makeTitle(String imgTag, String fetchUrl) {
+		Regex imgRegexAlt = new Regex("(?:alt=[\"\']([^>^\"^\']*)|alt=([^>^\"^\'^ ]*))");
+		imgRegexAlt.setIgnoreCase(true);
+		String imgAltText;
+		if (imgRegexAlt.search(imgTag)) {
+			imgAltText = imgRegexAlt.stringMatched(1);
+			if (imgAltText == null)
+				imgAltText = imgRegexAlt.stringMatched(2);
+		} else { // no alternative text as image title -> use --- or filename
+			// wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+			if (fetchUrl.toLowerCase().indexOf("opencaching.") > 0 || fetchUrl.toLowerCase().indexOf("geocaching.com") > 0)
+				imgAltText = "---"; // no image title
+			else
+				imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
+		}
+		return imgAltText;
+	}
+
+	private void getPic(ImageInfo imageInfo) {
+		String fileName = holder.getWayPoint() + "_" + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
+		fileName = Common.ClearForFileName(fileName).toLowerCase();
+		String target = profile.dataDir + fileName;
+		imageInfo.setFilename(fileName);
+		try {
+			File ftest = new FileBugfix(target);
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
+				if (pref.downloadPics) {
+					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
+					ftest = new FileBugfix(target);
+					if (ftest.exists()) {
+						if (ftest.length() > 0) {
+							holder.getCacheDetails(false).images.add(imageInfo);
+						} else {
+							ftest.delete();
+						}
+					}
+				}
+			}
+		} catch (IOException e) {
+			String ErrMessage;
+			String wp, n;
+			if (holder != null && holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = "WP???";
+			if (holder != null && holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = "name???";
+
+			if (e == null)
+				ErrMessage = "Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: " + fileName + " from URL:" + imageInfo.getURL();
+			else {
+				if (e.getMessage().equalsIgnoreCase("could not connect") || e.getMessage().equalsIgnoreCase("unkown host")) {
+					// is there a better way to find out what happened?
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + ")" + MyLocale.getMsg(1619, ": could not download image from URL: ") + imageInfo.getURL();
+				} else
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + "): ignoring IOException: " + e.getMessage() + " while downloading picture:" + fileName + " from URL:" + imageInfo.getURL();
+			}
+			pref.log(ErrMessage, e, true);
+		}
+
+	}
+
 	public int getHow() {
 		return doitHow;
 	}

Modified: branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheSize;
@@ -34,6 +33,7 @@
 import CacheWolf.Common;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
+import CacheWolf.navi.TrackPoint;
 import ewe.io.FileReader;
 import ewe.io.Reader;
 import ewe.sys.Vm;
@@ -80,7 +80,7 @@
 	public void startElement(String name, AttributeList atts) {
 		if (debugXML) {
 			for (int i = 0; i < atts.getLength(); i++) {
-				pref.log(" Name: " + atts.getName(i) + " Value: " + atts.getValue(i),null);
+				pref.log(" Name: " + atts.getName(i) + " Value: " + atts.getValue(i), null);
 			}
 		}
 		strData = "";
@@ -89,8 +89,7 @@
 			return;
 		}
 		if (name.equals("coord")) {
-			holder.pos.set(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon")));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon"))));
 			return;
 		}
 	}
@@ -127,7 +126,7 @@
 		String chars = new String(ch, start, length);
 		strData += chars;
 		if (debugXML)
-			pref.log(strData,null);
+			pref.log(strData, null);
 	}
 
 	private CacheHolder getHolder(String wpt) {

Added: branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,82 @@
+package CacheWolf.imp;
+
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import CacheWolf.UrlFetcher;
+import CacheWolf.utils.FileBugfix;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.ui.FormBase;
+
+public class OCGPXfetch {
+	static Preferences pref = Global.getPref();
+	static Profile prof = Global.getProfile();;
+
+	public static void doIt() {
+		String hostname = pref.lastOCSite;
+		boolean oldDownloadAllOC = pref.downloadAllOC;
+		boolean onlyListedAtOC = false;
+		OCXMLImporterScreen importOpt = new OCXMLImporterScreen(MyLocale.getMsg(130, "Download from opencaching"), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL | OCXMLImporterScreen.HOST);
+		importOpt.missingCheckBox.setText(MyLocale.getMsg(164, "only listed at OC"));
+		importOpt.missingCheckBox.setState(onlyListedAtOC);
+		if (importOpt.execute() == FormBase.IDCANCEL) {
+			return;
+		}
+		onlyListedAtOC = pref.downloadAllOC;
+		pref.downloadAllOC = oldDownloadAllOC;
+		if (importOpt.domains.getSelectedItem() != null) {
+			hostname = (String) importOpt.domains.getSelectedItem();
+			pref.lastOCSite = hostname;
+		}
+
+		try {
+			String address = "http://" + hostname + "/search.php?";
+			address += "searchto=searchbyfinder"; // searchbydistance
+			address += "&showresult=1&expert=0&sort=bydistance&orderRatingFirst=0";
+			address += "&f_userowner=0&f_userfound=0&f_inactive=0&f_ignored=0";
+			address += "&f_otherPlatforms="; // 0 = all 1 = nur OC
+			if (onlyListedAtOC)
+				address += "1";
+			else
+				address += "0";
+			address += "&country=&difficultymin=0&difficultymax=0&terrainmin=0&terrainmax=0&cachetype=1;2;3;4;5;6;7;8;9;10&cachesize=1;2;3;4;5;6;7&cache_attribs=&cache_attribs_not=";
+			address += "&logtype=1,7";
+			address += "&utf8=1&output=gpx&zip=1";
+			address += "&count=max";
+			address += "&finder=" + pref.myAlias;
+			String tmpFile = prof.dataDir + "dummy.zip";
+			login();
+			UrlFetcher.fetchDataFile(address, tmpFile);
+			File ftmp = new FileBugfix(tmpFile);
+			if (ftmp.exists() && ftmp.length() > 0) {
+				GPXImporter gpx = new GPXImporter(pref, prof, tmpFile);
+				if (pref.downloadPics)
+					gpx.doIt(GPXImporter.DOIT_WITHSPOILER);
+				else
+					gpx.doIt(GPXImporter.DOIT_NOSPOILER);
+			}
+			ftmp.delete();
+		} catch (IOException e) {
+		}
+	}
+
+	public static boolean login() {
+		// TODO this is only a preliminary Version of login
+		// todo for other opencaching sites
+		boolean loggedIn = false;
+		String page;
+		try {
+			String loginDaten = "target=myhome.php&action=login&email=" + pref.myAlias + "&password=" + pref.password;
+			UrlFetcher.setpostData(loginDaten);
+			page = UrlFetcher.fetch("http://www.opencaching.de/login.php");
+			// final PropertyList pl = UrlFetcher.getDocumentProperties();
+			page = UrlFetcher.fetch("http://www.opencaching.de/myhome.php");
+			loggedIn = page.indexOf("Eingeloggt als") > -1;
+		} catch (IOException e) {
+			pref.log("Fehler", e);
+		}
+		return loggedIn;
+	}
+}

Added: branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,152 @@
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
+
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+package CacheWolf.imp;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.Common;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import CacheWolf.OC;
+import CacheWolf.SafeXML;
+import CacheWolf.UrlFetcher;
+import ewe.sys.Handle;
+import ewe.sys.Vm;
+import ewe.ui.ProgressBarForm;
+
+public final class OCLinkImporter {
+	private static CacheDB cacheDB = null;
+
+	public static void doIt() {
+
+		if (cacheDB == null)
+			cacheDB = Global.getProfile().cacheDB;
+		int totalWaypoints = cacheDB.countVisible();
+		int updated = 0;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h, "Import OC names ...");
+		pbf.exec();
+		if (OCGPXfetch.login()) {
+			for (int o = 0; o < cacheDB.size(); o += 1) {
+				if (pbf.exitValue == -1)
+					break;
+				CacheHolder ch = cacheDB.get(o);
+				if (ch.isVisible()) {
+					updateOCLink(ch);
+					updated++;
+					h.progress = (float) updated / (float) totalWaypoints;
+					h.changed();
+				}
+			}
+		}
+		pbf.exit(0);
+	}
+
+	public static void updateOCLink(CacheHolder ch) {
+		// todo other OC sites
+		Vm.showWait(true);
+		boolean save = false;
+		String wp = ch.getWayPoint();
+		if (wp.startsWith("GC")) {
+			String wpName = ch.getOcCacheID();
+			if (wpName.length() > 0) {
+				if (wpName.charAt(0) < 65)
+					wp = wpName.substring(1);
+				else {
+					if (wpName.startsWith("OC")) // other OC sites
+						wp = wpName;
+				}
+				if (!wp.startsWith("OC")) {
+					// other OC sites
+					ch.setOcCacheID(""); // there may be a value from gpx - import
+					save = true;
+				}
+			}
+			// other OC sites
+			String baseurl = "http://" + OC.getOCHostName("OC") + "/map2.php?";
+			boolean hasOC = false;
+			try {
+				String url = baseurl + "mode=wpsearch&wp=" + wp;
+				String result = UrlFetcher.fetch(url);
+				if (result.indexOf("wpoc=\"") > -1)
+					hasOC = true;
+				else {
+					// check over coordinates
+					// getting a cache next to the coordinates
+					String nLat = ch.getPos().getLatDeg(CWPoint.DD);
+					String nLon = ch.getPos().getLonDeg(CWPoint.DD);
+					url = baseurl + "mode=locate&lat=" + nLat + "&lon=" + nLon;
+					result = SafeXML.cleanback(UrlFetcher.fetch(url));
+					String ocCacheName = new Extractor(result, "name=\"", "\"", 0, true).findNext();
+					if (ch.getCacheName().equals(ocCacheName)) {
+						hasOC = true;
+					} else {
+						int start = result.indexOf("coords=\"") + 8;
+						int lonend = result.indexOf(",", start);
+						int latend = result.indexOf("\"", lonend);
+						double lon = Common.parseDouble(result.substring(start, lonend));
+						double lat = Common.parseDouble(result.substring(lonend + 1, latend));
+						boolean sameCoord = lon == ch.getPos().lonDec && lat == ch.getPos().latDec;
+						if (sameCoord) {
+							start = result.indexOf("username=\"") + 10;
+							int end = result.indexOf("\"", start);
+							if (ch.getCacheOwner().toLowerCase().equals(result.substring(start, end).toLowerCase()))
+								hasOC = true;
+						}
+					}
+				}
+				if (hasOC) {
+					boolean found = false;
+					if (result.substring(result.indexOf("found=\"") + 7).startsWith("1"))
+						found = true;
+					int start = result.indexOf("wpoc=\"") + 6;
+					if (start > 5) {
+						int idend = result.indexOf("\"", start);
+						String ocwp = result.substring(start, idend);
+						if (!found)
+							ocwp = "-" + ocwp;
+						if (!ocwp.equals(ch.getOcCacheID())) {
+							ch.setOcCacheID(ocwp);
+							save = true;
+						}
+					}
+				}
+				if (save)
+					ch.save();
+
+			} catch (Exception e) {
+				// dann halt nicht
+			}
+		}
+		// return ch;
+		Vm.showWait(false);
+	}
+
+}

Modified: branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
 import CacheWolf.CWPoint;
@@ -41,6 +41,7 @@
 import CacheWolf.Profile;
 import CacheWolf.SafeXML;
 import CacheWolf.UrlFetcher;
+import CacheWolf.navi.TrackPoint;
 import CacheWolf.navi.TransformCoordinates;
 import CacheWolf.utils.FileBugfix;
 
@@ -48,7 +49,6 @@
 
 import ewe.io.BufferedReader;
 import ewe.io.File;
-import ewe.io.FileOutputStream;
 import ewe.io.IO;
 import ewe.io.IOException;
 import ewe.io.InputStreamReader;
@@ -60,8 +60,6 @@
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
-import ewe.util.ByteArray;
-import ewe.util.CharArray;
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.zip.ZipEntry;
@@ -71,11 +69,11 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	Class to import Data from opencaching.
- *	It uses the lastmodified parameter to identify new or changed caches.
- *	See here: http://www.opencaching.com/phpBB2/viewtopic.php?t=281 (out-dated)
- *   See here: http://www.opencaching.de/doc/xml/xml11.htm and http://develforum.opencaching.de/viewtopic.php?t=135&postdays=0&postorder=asc&start=0
- *	for more information.
+ * Class to import Data from opencaching.
+ * It uses the lastmodified parameter to identify new or changed caches.
+ * See here: http://www.opencaching.com/phpBB2/viewtopic.php?t=281 (out-dated)
+ * See here: http://www.opencaching.de/doc/xml/xml11.htm and http://develforum.opencaching.de/viewtopic.php?t=135&postdays=0&postorder=asc&start=0
+ * for more information.
  */
 public class OCXMLImporter extends MinML {
 	static protected final int STAT_INIT = 0;
@@ -87,12 +85,13 @@
 	String hostname;
 
 	int state = STAT_INIT;
-	int numCacheImported, numDescImported, numLogImported= 0;
+	int numCacheImported, numDescImported, numLogImported = 0;
+	int numCacheUpdated, numDescUpdated, numLogUpdated = 0;
 
 	boolean debugGPX = false;
 	CacheDB cacheDB;
 	InfoBox inf;
-	//CacheHolder ch;
+	// CacheHolder ch;
 	CacheHolder holder;
 	Preferences pref;
 	Profile profile;
@@ -100,12 +99,13 @@
 	String strData = "";
 	int picCnt;
 	boolean incUpdate = true; // complete or incremental Update
+	boolean incFinds = true;
 	Hashtable DBindexID = new Hashtable();
 
 	String picUrl = "";
-	String picTitle =  "";
-	String picID = new String();
-	String cacheID = new String();
+	String picTitle = "";
+	String picID;
+	String cacheID;
 
 	String logData, logIcon, logDate, logFinder, logId;
 	boolean loggerRecommended;
@@ -116,116 +116,119 @@
 	double longitude;
 	/** Temporarly save the values from XML: set to the language of the description which is currently parsed */
 	String processingDescLang;
+	boolean isHTML;
+	boolean isSyncSingle; // to load archieved
 
-	public OCXMLImporter(Preferences p,Profile prof)
-	{
+	public OCXMLImporter(Preferences p, Profile prof) {
 		pref = p;
-		profile=prof;
+		profile = prof;
 		cacheDB = profile.cacheDB;
-		if(profile.getLast_sync_opencaching() == null ||
-				profile.getLast_sync_opencaching().length() < 12){
+		incUpdate = true;
+		if (profile.getLast_sync_opencaching() == null || profile.getLast_sync_opencaching().length() < 12) {
 			profile.setLast_sync_opencaching("20050801000000");
 			incUpdate = false;
 		}
 		user = p.myAlias.toLowerCase();
 		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size();i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (!ch.getOcCacheID().equals(""))
-				DBindexID.put(ch.getOcCacheID(), new Integer(i));
-		}//for
+				DBindexID.put(ch.getOcCacheID(), ch.getWayPoint());
+		}// for
 
 	}
 
 	/**
-	 *
+	 * 
 	 * @param number
 	 * @param infB
 	 * @return true, if some change was made to the cacheDB
 	 */
 	public boolean syncSingle(int number, InfoBox infB) {
+
 		CacheHolder ch;
 		ch = cacheDB.get(number);
-		hostname=OC.getOCHostName(ch.getWayPoint());
-		holder= null;
+		hostname = OC.getOCHostName(ch.getWayPoint());
+		holder = null;
 
 		if (infB.isClosed) {
 			// there could have been an update before
 			return true;
 		}
 
-		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from " + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608, "downloading data\n from " + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
 		String lastS;
-		/** pref.downloadmissingOC = true, if not the last syncdate shall be used,
-		 *  but the caches shall be reloaded
-		 *  only used in syncSingle  */
-		if (pref.downloadMissingOC)  lastS = "20050801000000";
+		/**
+		 * pref.downloadmissingOC = true, if not the last syncdate shall be used,
+		 * but the caches shall be reloaded
+		 * only used in syncSingle
+		 */
+		incUpdate = false;
+		if (pref.downloadAllOC)
+			lastS = "20050801000000";
 		else {
-			if (ch.getLastSync().length() < 14) lastS = "20050801000000";
-			else lastS = ch.getLastSync();
+			if (ch.getLastSync().length() < 14)
+				lastS = "20050801000000";
+			else {
+				lastS = ch.getLastSync();
+				incUpdate = true;
+			}
 		}
 		dateOfthisSync = new Time();
 		dateOfthisSync.parse(lastS, "yyyyMMddHHmmss");
 
-
-		String url = new String();
 		picCnt = 0;
-		//Build url
-		url = "http://" + hostname + "/xml/ocxml11.php?"
-			+ "modifiedsince=" + lastS
-			+ "&cache=1"
-			+ "&cachedesc=1";
+		// Build url
+		String url = "http://" + hostname + "/xml/ocxml11.php?" + "modifiedsince=" + lastS + "&cache=1" + "&cachedesc=1";
 
-		if (pref.downloadPics) url += "&picture=1";
-		else url += "&picture=0";
-		url += "&cachelog=1"
-			+ "&removedobject=0"
-			+ "&wp=" + ch.getWayPoint()
-			+ "&charset=utf-8"
-			+ "&cdata=0"
-			+ "&session=0";
+		if (pref.downloadPics)
+			url += "&picture=1";
+		else
+			url += "&picture=0";
+		url += "&cachelog=1" + "&removedobject=0" + "&wp=" + ch.getWayPoint() + "&charset=utf-8" + "&cdata=0" + "&session=0";
 		ch.setUpdated(false);
+		isSyncSingle = true;
 		syncOC(url);
 		inf.close(0);
 		return true;
 	}
 
-	public void doIt(){
-		boolean success=true;
+	public void doIt() {
+		boolean success = true;
 		String finalMessage;
 
-		String url = new String();
-
-		String lastS =  profile.getLast_sync_opencaching();
-		CWPoint centre = pref.getCurCentrePt(); // No need to clone curCentrePt as centre is only read
+		String lastS = profile.getLast_sync_opencaching();
+		final CWPoint centre = pref.getCurCentrePt(); // No need to clone curCentrePt as centre is only read
 		if (!centre.isValid()) {
 			(new MessageBox("Error", "Coordinates for centre must be set", FormBase.OKB)).execute();
 			return;
 		}
-		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(130,"Download from opencaching"),
-																 OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES
-																 | OCXMLImporterScreen.HOST);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
+		final OCXMLImporterScreen importOpt = new OCXMLImporterScreen(MyLocale.getMsg(130, "Download from opencaching"), OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.INCLUDEFOUND
+				| OCXMLImporterScreen.HOST);
+		if (importOpt.execute() == FormBase.IDCANCEL) {
+			return;
+		}
 		Vm.showWait(true);
 		String dist = importOpt.maxDistanceInput.getText();
-
-		if (importOpt.domains.getSelectedItem()!=null) {
-			hostname = (String)importOpt.domains.getSelectedItem();
-			pref.lastOCSite=hostname;
+		incFinds = !importOpt.foundCheckBox.getState();
+		if (importOpt.domains.getSelectedItem() != null) {
+			hostname = (String) importOpt.domains.getSelectedItem();
+			pref.lastOCSite = hostname;
 		}
 
-		if (dist.length()== 0) return;
+		if (dist.length() == 0)
+			return;
 
-		Double distDouble = new Double();
+		final Double distDouble = new Double();
 		distDouble.value = Common.parseDouble(dist);
 		dist = distDouble.toString(0, 1, 0).replace(',', '.');
-		//check, if distance is greater than before
-		if (Convert.toInt(dist) > Convert.toInt(profile.getDistOC()) ||
-				pref.downloadMissingOC  ){
+		// check, if distance is greater than before
+		incUpdate = true;
+		if (Convert.toInt(dist) > Convert.toInt(profile.getDistOC()) || pref.downloadAllOC) {
 			// resysnc
 			lastS = "20050801000000";
 			incUpdate = false;
@@ -233,135 +236,130 @@
 		profile.setDistOC(dist);
 		// Clear status of caches in db
 		CacheHolder ch;
-		for(int i = cacheDB.size()-1; i>=0 ;i--){
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
 			ch.setUpdated(false);
 			ch.setNew(false);
 			ch.setLog_updated(false);
 		}
 		picCnt = 0;
-		//Build url
-		url = "http://" + hostname + "/xml/ocxml11.php?"
-			+ "modifiedsince=" + lastS
-			+ "&cache=1"
-			+ "&cachedesc=1";
-		if (pref.downloadPics) url += "&picture=1";
-		else url += "&picture=0";
-		url += "&cachelog=1"
-			+ "&removedobject=0"
-			+ "&lat=" + centre.getLatDeg(TransformCoordinates.DD)
-			+ "&lon=" + centre.getLonDeg(TransformCoordinates.DD)
-			+ "&distance=" + dist
-			+ "&charset=utf-8"
-			+ "&cdata=0"
-			+ "&session=0";
-		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// Build url
+		String url = "http://" + hostname + "/xml/ocxml11.php?" + "modifiedsince=" + lastS + "&cache=1" + "&cachedesc=1";
+		if (pref.downloadPics)
+			url += "&picture=1";
+		else
+			url += "&picture=0";
+		url += "&cachelog=1" + "&removedobject=0" + "&lat=" + centre.getLatDeg(TransformCoordinates.DD) + "&lon=" + centre.getLonDeg(TransformCoordinates.DD) + "&distance=" + dist + "&charset=utf-8" + "&cdata=0" + "&session=0";
+		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608, "downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
+		isSyncSingle = false;
 		success = syncOC(url);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 		Vm.showWait(false);
 		if (success) {
 			profile.setLast_sync_opencaching(dateOfthisSync.format("yyyyMMddHHmmss"));
-			//pref.savePreferences();
-			finalMessage = MyLocale.getMsg(1607,"Update from opencaching successful");
-			inf.addWarning("\nNumber of"+
-			"\n...caches new/updated: " + numCacheImported +
-			"\n...cache descriptions new/updated: " + numDescImported +
-			"\n...logs new/updated: " + numLogImported);
+			// pref.savePreferences();
+			finalMessage = MyLocale.getMsg(1607, "Update from opencaching successful");
+			inf.addWarning("\nNumber of" + "\n...caches new/updated: " + numCacheImported + " / " + numCacheUpdated + "\n...cache descriptions new/updated: " + numDescImported + "\n...logs new/updated: " + numLogImported);
 			inf.setInfo(finalMessage);
 		}
 		inf.addOkButton();
 	}
 
-	private boolean syncOC(String url) {
-		String finalMessage = new String();
-		boolean success=true;
+	private boolean syncOC(String address) {
+		boolean success = true;
 		File tmpFile = null;
 		BufferedReader r;
-		String file = new String();
 
-		//inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
 
 		picCnt = 0;
-		try{
+		String finalMessage = "";
+		try {
 			holder = null;
-			pref.log(url+"fetching");
-			file = fetch(url, "dummy");
+			final String target = profile.dataDir + "dummy.zip";
+			UrlFetcher.fetchDataFile(address, target);
 
-			//parse
-			tmpFile = new FileBugfix(profile.dataDir + file);
-			if (tmpFile.getLength() == 0 ) {
+			// parse
+			tmpFile = new FileBugfix(target);
+			if (tmpFile.getLength() == 0) {
 				throw new IOException("no updates available");
 			}
 
-			ZipFile zif = new ZipFile (profile.dataDir + file);
+			final ZipFile zif = new ZipFile(target);
 			ZipEntry zipEnt;
-			Enumeration zipEnum = zif.entries();
+			final Enumeration zipEnum = zif.entries();
 			inf.setInfo("...unzipping update file");
-			while (zipEnum.hasMoreElements())
-			{
+			while (zipEnum.hasMoreElements()) {
 				zipEnt = (ZipEntry) zipEnum.nextElement();
 				// skip over PRC-files and empty files
-				if (zipEnt.getSize()> 0 && zipEnt.getName().endsWith("xml")){
-					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
+				if (zipEnt.getSize() > 0 && zipEnt.getName().endsWith("xml")) {
+					r = new BufferedReader(new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
 					parse(r);
 					r.close();
 				}
 			}
 			zif.close();
-		}catch (ZipException e){
-			finalMessage = MyLocale.getMsg(1614,"Error while unzipping udpate file");
+		} catch (final ZipException e) {
+			finalMessage = MyLocale.getMsg(1614, "Error while unzipping udpate file");
 			success = false;
-		}catch (IOException e){
-			if (e.getMessage().equalsIgnoreCase("no updates available")) { finalMessage = "No updates available"; success = false; }
-			else {
-				if (e.getMessage().equalsIgnoreCase("could not connect") ||
-						e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-					finalMessage = MyLocale.getMsg(1616,"Error: could not download update file from " + hostname);
-				} else { finalMessage = "IOException: "+e.getMessage(); }
+		} catch (final IOException e) {
+			if (e.getMessage().equalsIgnoreCase("no updates available")) {
+				finalMessage = "No updates available";
 				success = false;
+			} else {
+				if (e.getMessage().equalsIgnoreCase("could not connect") || e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
+					finalMessage = MyLocale.getMsg(1616, "Error: could not download update file from " + hostname);
+				} else {
+					finalMessage = "IOException: " + e.getMessage();
+				}
+				success = false;
 			}
-		}catch (IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in " + hostname + "\nplease try again later\n, state:")+" "+state+", waypoint: "+ holder.getWayPoint();
+		} catch (final IllegalArgumentException e) {
+			finalMessage = MyLocale.getMsg(1621, "Error parsing update file\n this is likely a bug in " + hostname + "\nplease try again later\n, state:") + " " + state + ", waypoint: " + holder.getWayPoint();
 			success = false;
-			pref.log("Parse error: " + state + " " + holder.getWayPoint(),e,true);
-		}catch (Exception e){ // here should be used the correct exception
-			if (holder != null)	finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.getWayPoint();
-			else finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: <unkown>";
+			pref.log("Parse error: " + state + " " + holder.getWayPoint(), e, true);
+		} catch (final Exception e) { // here should be used the correct exception
+			if (holder != null)
+				finalMessage = MyLocale.getMsg(1615, "Error parsing update file, state:") + " " + state + ", waypoint: " + holder.getWayPoint();
+			else
+				finalMessage = MyLocale.getMsg(1615, "Error parsing update file, state:") + " " + state + ", waypoint: <unkown>";
 			success = false;
-			pref.log("",e,true);
+			pref.log("", e, true);
 		} finally {
-			if (tmpFile != null) tmpFile.delete();
+			if (tmpFile != null)
+				tmpFile.delete();
 		}
 		/*
-		for (int i=cacheDB.size()-1; i >=0; i--) {
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.wayPoint.toUpperCase().startsWith("OC")) { //TODO only handle changed caches
-				ch.calcRecommendationScore();
-			}
-		} */
+		 * for (int i=cacheDB.size()-1; i >=0; i--) {
+		 * ch = (CacheHolder)cacheDB.get(i);
+		 * if (ch.wayPoint.toUpperCase().startsWith("OC")) { //TODO only handle changed caches
+		 * ch.calcRecommendationScore();
+		 * }
+		 * }
+		 */
 		inf.setInfo(finalMessage);
 
 		return success;
 	}
 
-	public void startElement(String name, AttributeList atts){
-		if (debugGPX){
+	public void startElement(String name, AttributeList atts) {
+		if (debugGPX) {
 			for (int i = 0; i < atts.getLength(); i++) {
-				pref.log(" Name: " + atts.getName(i)+ " Value: "+atts.getValue(i));
+				pref.log(" Name: " + atts.getName(i) + " Value: " + atts.getValue(i));
 			}
 		}
-		strData ="";
+		strData = "";
 
-		if (name.equals("oc11xml")){
-			Time lastSync = new Time();
+		if (name.equals("oc11xml")) {
+			final Time lastSync = new Time();
 			try {
-				lastSync.parse(atts.getValue("date"),"yyyy-MM-dd HH:mm:ss");
-			}catch (IllegalArgumentException e){
-				pref.log("",e,true);
+				lastSync.parse(atts.getValue("date"), "yyyy-MM-dd HH:mm:ss");
+			} catch (final IllegalArgumentException e) {
+				pref.log("", e, true);
 			}
 			// reduce time at 1 second to avoid sync problems
 			lastSync.setTime(lastSync.getTime() - 1000);
@@ -370,96 +368,140 @@
 		}
 
 		// look for changes in the state
-		if (name.equals("cache")) 		{ state = STAT_CACHE; numCacheImported++;}
-		if (name.equals("cachedesc")) 	{ state = STAT_CACHE_DESC; numDescImported++;}
-		if (name.equals("cachelog")) 	{ state = STAT_CACHE_LOG; numLogImported++; logtype = 0;}
-		if (name.equals("picture")) 	{ state = STAT_PICTURE; }
+		if (name.equals("cache")) {
+			state = STAT_CACHE;
+		}
+		if (name.equals("cachedesc")) {
+			state = STAT_CACHE_DESC;
+		}
+		if (name.equals("cachelog")) {
+			state = STAT_CACHE_LOG;
+			logtype = 0;
+		}
+		if (name.equals("picture")) {
+			state = STAT_PICTURE;
+		}
 
-		//examine data
+		// examine data
 		switch (state) {
-		case STAT_CACHE: startCache(name, atts); break;
-		case STAT_CACHE_DESC: startCacheDesc(name, atts); break;
-		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
-		case STAT_PICTURE: startPicture(name,atts); break;
+		case STAT_CACHE:
+			startCache(name, atts);
+			break;
+		case STAT_CACHE_DESC:
+			startCacheDesc(name, atts);
+			break;
+		case STAT_CACHE_LOG:
+			startCacheLog(name, atts);
+			break;
+		case STAT_PICTURE:
+			startPicture(name, atts);
+			break;
 		}
 
 	}
 
-	public void endElement(String name){
-		//examine data
+	public void endElement(String name) {
+		// examine data
 		switch (state) {
-		case STAT_CACHE: endCache(name); break;
-		case STAT_CACHE_DESC: endCacheDesc(name);break;
-		case STAT_CACHE_LOG: endCacheLog(name); break;
-		case STAT_PICTURE: endPicture(name); break;
+		case STAT_CACHE:
+			endCache(name);
+			break;
+		case STAT_CACHE_DESC:
+			endCacheDesc(name);
+			break;
+		case STAT_CACHE_LOG:
+			endCacheLog(name);
+			break;
+		case STAT_PICTURE:
+			endPicture(name);
+			break;
 		}
 
 		// look for changes in the state
-		if (name.equals("cache")) 		state = STAT_INIT;
-		if (name.equals("cachedesc")) 	state = STAT_INIT;
-		if (name.equals("cachelog")) 	state = STAT_INIT;
-		if (name.equals("picture")) 	state = STAT_INIT;
+		if (name.equals("cache"))
+			state = STAT_INIT;
+		if (name.equals("cachedesc"))
+			state = STAT_INIT;
+		if (name.equals("cachelog"))
+			state = STAT_INIT;
+		if (name.equals("picture"))
+			state = STAT_INIT;
 
 	}
 
-	public void characters(char[] ch2,int start,int length){
-		String chars = new String(ch2,start,length);
+	public void characters(char[] ch2, int start, int length) {
+		final String chars = new String(ch2, start, length);
 		strData += chars;
-		if (debugGPX) pref.log(strData,null);
+		if (debugGPX)
+			pref.log(strData, null);
 	}
 
-	private void startCache(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1609,"Importing Cache:")+" " + numCacheImported + "\n");
-		if(name.equals("id")){
+	private void startCache(String name, AttributeList atts) {
+		if (name.equals("id")) {
 			cacheID = atts.getValue("id");
+			return;
 		}
-		if(name.equals("type")){
+		if (holder == null)
+			return;
+		inf.setInfo(MyLocale.getMsg(1609, "Importing Cache:") + " " + numCacheImported + " / " + numCacheUpdated + "\n");
+		if (name.equals("type")) {
 			holder.setType(CacheType.ocType2CwType(atts.getValue("id")));
 			holder.getCacheDetails(false).attributes.clear();
 			return;
 		}
-		if(name.equals("status")){
-            // meaning of OC status :
-			//  1=Kann gesucht werden ;
-			//  2=Momentan nicht verf?gbar ;
-			//  3=Archiviert ;
-			//  4= ;
-			//  5= ;
-			//  6=Gesperrt ;
-			//  are there more ? ;
+		if (name.equals("status")) {
+			// meaning of OC status :
+			// 1=Kann gesucht werden ;
+			// 2=Momentan nicht verf?gbar ;
+			// 3=Archiviert ;
+			// 4= ;
+			// 5= ;
+			// 6=Gesperrt ;
+			// are there more ? ;
 			if (atts.getValue("id").equals("1")) {
 				holder.setAvailable(true);
+				holder.setArchived(false);
 			} else {
 				holder.setAvailable(false);
-				if( (atts.getValue("id").equals("3")) || (atts.getValue("id").equals("6")) ) {
-					holder.setArchived(true);
+				if ((atts.getValue("id").equals("3")) || (atts.getValue("id").equals("6")) || (atts.getValue("id").equals("7"))) {
+					if (!isSyncSingle) {
+						holder = null;
+						numCacheImported--;
+					} else {
+						// Umsetzung wie in gpx f?r Status 6
+						if (atts.getValue("id").equals("6")) {
+							holder.setArchived(false);
+						} else {
+							holder.setArchived(true);
+						}
+					}
 				}
 			}
 			return;
 		}
-		if(name.equals("size")){
+		if (name.equals("size")) {
 			holder.setCacheSize(CacheSize.ocXmlString2Cw(atts.getValue("id")));
 			return;
 		}
 
-		if(name.equals("waypoints")){
+		if (name.equals("waypoints")) {
 			holder.setWayPoint(atts.getValue("oc"));
-			String CName = atts.getValue("nccom") + " " + atts.getValue("gccom");
+			final String CName = atts.getValue("nccom") + " " + atts.getValue("gccom");
 			if (!CName.equals(" ")) {
 				holder.setCacheOwner(holder.getCacheOwner() + " / " + CName.trim());
 				holder.getCacheDetails(false).attributes.add(7); // wwwlink
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
-			}
-			else {
+			} else {
 				holder.getCacheDetails(false).attributes.add(6); // oconly
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			}
-			if (holder.getWayPoint().length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
+			if (holder.getWayPoint().length() == 0)
+				throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
 			return;
 		}
-		
+
 		if (name.equals("attribute")) {
-			int id = Integer.parseInt(atts.getValue("id"));
+			final int id = Integer.parseInt(atts.getValue("id"));
 			holder.getCacheDetails(false).attributes.add(id);
 			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			return;
@@ -467,74 +509,97 @@
 
 	}
 
+	private void startCacheDesc(String name, AttributeList atts) {
+		inf.setInfo(MyLocale.getMsg(1611, "Importing cache description:") + " " + numDescImported);
 
-	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported);
-		if (name.equals("cacheid")){
-			String ocCacheID = new String(atts.getValue("id"));
-			holder.setOcCacheID(ocCacheID);
+		if (name.equals("cacheid")) {
+			cacheID = atts.getValue("id");
+			holder = getHolder(cacheID, false);
+			return;
 		}
 
-		if (name.equals("desc")){
-			holder.setHTML(atts.getValue("html").equals("1")?true:false);
+		if (name.equals("desc")) {
+			isHTML = atts.getValue("html").equals("1") ? true : false;
+			return;
 		}
 
 		if (name.equals("language")) {
 			processingDescLang = atts.getValue("id");
+			return;
 		}
 	}
 
-	private void startPicture(String name, AttributeList atts){
-		if(name.equals("picture")){
-			inf.setInfo(MyLocale.getMsg(1613,"Pictures:")+" " + ++picCnt);
+	private void startCacheLog(String name, AttributeList atts) {
+		if (name.equals("id")) {
+			logId = atts.getValue("id");
+			return;
 		}
-	}
 
-	private void startCacheLog(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1612,"Importing Cachlog:")+" " + numLogImported);
-		if (name.equals("logtype")){
+		if (name.equals("cacheid")) {
+			holder = getHolder(atts.getValue("id"), false);
+			return;
+		}
+		if (holder == null)
+			return;
+
+		inf.setInfo(MyLocale.getMsg(1612, "Importing Cachlog:") + " " + numLogImported);
+
+		if (name.equals("logtype")) {
 			logtype = Convert.toInt(atts.getValue("id"));
 			switch (logtype) {
 			case 1:
 				logIcon = Log.typeText2Image("Found");
 				break;
-			case 2:	
+			case 2:
 				logIcon = Log.typeText2Image("Not Found");
-				holder.setNoFindLogs((byte)(holder.getNoFindLogs()+1));
+				holder.setNoFindLogs((byte) (holder.getNoFindLogs() + 1));
 				break;
-			case 3: 
+			case 3:
 				logIcon = Log.typeText2Image("Note");
 			}
 			loggerRecommended = atts.getValue("recommended").equals("1");
 			return;
 		}
+	}
 
-		if (name.equals("id")){
-			logId = atts.getValue("id");
+	private void startPicture(String name, AttributeList atts) {
+		if (name.equals("object")) {
+			cacheID = atts.getValue("id"); // are there picture without cacheID?
+			holder = getHolder(cacheID, false);
+			return;
 		}
 	}
 
-	private void endCache(String name){
-		if (name.equals("cache")){
+	private void endCache(String name) {
+		if (name.equals("id")) { // </id>
+			// the guid (=strData) is not part of gpx , so we use id of cacheID
+			holder = getHolder(cacheID, true); // Allocate a new CacheHolder object
+			holder.setOcCacheID(cacheID);
+			holder.getCacheDetails(false).URL = "http://" + hostname + "/viewcache.php?cacheid=" + cacheID;
+			return;
+		}
+		if (holder == null)
+			return; // id should always be the first for a <cache>
+		if (name.equals("cache")) {
 			holder.setLastSync(dateOfthisSync.format("yyyyMMddHHmmss"));
 			int index;
 			index = cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){
+			if (index == -1) {
+				numCacheImported++;
 				holder.setNew(true);
 				cacheDB.add(holder);
-				Integer indexInt = new Integer(cacheDB.size()-1);
-				DBindexID.put(holder.getOcCacheID(), indexInt);
+				DBindexID.put(holder.getOcCacheID(), holder.getWayPoint());
 			}
 			// update (overwrite) data
 			else {
+				numCacheUpdated++;
 				holder.setNew(false);
 				holder.setIncomplete(false);
 				cacheDB.get(index).update(holder);
-				// save ocCacheID, in case, the previous data is from GPX
-				DBindexID.put(holder.getOcCacheID(), new Integer(index));
+				DBindexID.put(holder.getOcCacheID(), holder.getWayPoint());
 			}
 			// clear data (picture, logs) if we do a complete Update
-			if (incUpdate == false){
+			if (!incUpdate) {
 				holder.getCacheDetails(false).CacheLogs.clear();
 				holder.getCacheDetails(false).images.clear();
 			}
@@ -543,277 +608,289 @@
 			holder.getCacheDetails(false).hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
 			// chD.saveCacheDetails(profile.dataDir);
 			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
+
+			holder = null;
 			return;
 		}
-		if(name.equals("id")){ // </id>
-			holder = getHolder(strData); // Allocate a new CacheHolder object
-			holder.setOcCacheID(strData);
-			String ocSeekUrl = new String("http://" + hostname + "/viewcache.php?cacheid=");
-			holder.getCacheDetails(false).URL = ocSeekUrl + cacheID;
-			return;
-		}
 
-		if(name.equals("name")){
+		if (name.equals("name")) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if(name.equals("userid")) {
+		if (name.equals("userid")) {
 			holder.setCacheOwner(strData);
-			if(holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) holder.setOwned(true);
+			if (holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() > 0 && holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2)))
+				holder.setOwned(true);
 			return;
 		}
 
-		if(name.equals("longitude")){
+		if (name.equals("longitude")) {
 			longitude = Common.parseDouble(strData);
 			return;
 		}
-		if(name.equals("latitude")) {
-			holder.pos.set(Common.parseDouble(strData),longitude);
-			holder.setLatLon(holder.pos.toString());
+		if (name.equals("latitude")) {
+			holder.setPos(new TrackPoint(Common.parseDouble(strData), longitude));
 			return;
 		}
-		if(name.equals("difficulty")) {
+		if (name.equals("difficulty")) {
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals("terrain")) {
+		if (name.equals("terrain")) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals("datehidden")) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+		if (name.equals("datehidden")) {
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
-		if (name.equals("country")){
+		if (name.equals("country")) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
 	}
 
-	private void endCacheDesc(String name){
-		if (name.equals("cachedesc")){
-			if (pref.downloadPics && holder.is_HTML()) {
-				String fetchUrl, imgTag, imgAltText;
-				Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)"); //  Ergebnis enthlt keine Anfhrungszeichen
-				Regex imgRegexAlt = new Regex("(?:alt=[\"\']([^>^\"^\']*)|alt=([^>^\"^\'^ ]*))"); // get alternative text for Pic
-				imgRegexAlt.setIgnoreCase(true);
-				imgRegexUrl.setIgnoreCase(true);
-				int descIndex=0;
-				int numDownloaded=1;
-				while (imgRegexUrl.searchFrom(holder.getCacheDetails(false).LongDescription, descIndex)) { // "img" found
-					imgTag=imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte <img ...>-tag
-					fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
-					if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
-					if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-						inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+holder.getWayPoint()));
-						continue;
-					}
-					inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
-					if (imgRegexAlt.search(imgTag)) {
-						imgAltText=imgRegexAlt.stringMatched(1);
-						if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
-						// no alternative text as image title -> use filename
-					} else {
-						if (fetchUrl.toLowerCase().indexOf("opencaching.") > 0 || fetchUrl.toLowerCase().indexOf("geocaching.com") > 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
-							imgAltText = new String("No image title");
-						else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/')+1);
-					}
-					descIndex = imgRegexUrl.matchedTo();
-					getPic(fetchUrl, imgAltText);
-				}
+	private void endCacheDesc(String name) {
+		if (holder == null)
+			return;
+		if (name.equals("cachedesc")) {
+			numDescImported++;
+			holder.setHTML(isHTML);
+			if (pref.downloadPics && isHTML) {
+				getImageNamesFromDescription();
 			}
 			holder.getCacheDetails(false).hasUnsavedChanges = true;
 			return;
 		}
 
+		if (name.equals("shortdesc")) {
+			String linebraek;
 
-		if (name.equals("cacheid")){
-			// load cachedata
-			holder = getHolder(strData);
-			return;
-		}
+			if (isHTML)
+				linebraek = "<br>\n";
+			else
+				linebraek = "\n";
 
-		if (name.equals("shortdesc")){
-			String linebraek;
-
-			if (holder.is_HTML())	linebraek = "<br>\n";
-			else 					linebraek = "\n";
-			
-			     // this is set by "hint" a few lines down: if a long description is already updated, then this one is likely to be in another language
-			if (holder.is_updated())	holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + ":" +  linebraek + strData  +  linebraek;
-			else 					 	holder.getCacheDetails(false).LongDescription =              processingDescLang + ":" +  linebraek + strData  +  linebraek;
+			// this is set by "hint" a few lines down: if a long description is already updated, then this one is likely to be in another language
+			if (holder.is_updated())
+				holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + ":" + linebraek + strData + linebraek;
+			else
+				holder.getCacheDetails(false).LongDescription = processingDescLang + ":" + linebraek + strData + linebraek;
 			return;
 		}
 
-		if (name.equals("desc")){ // </desc>
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.equals("desc")) { // </desc>
+			if (isHTML)
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
-		if (name.equals("hint")){
+		if (name.equals("hint")) {
 			String linebreak;
-			if (holder.is_HTML())	linebreak = "<br>\n";
-			else 					linebreak = "\n";
-			if (holder.is_updated())	holder.getCacheDetails(false).Hints += linebreak + "[" + processingDescLang + ":]" +  linebreak + Common.rot13(strData)  +  linebreak;
-			else 					 	holder.getCacheDetails(false).Hints =              "[" + processingDescLang + ":]" +  linebreak + Common.rot13(strData)  +  linebreak;
+			if (isHTML)
+				linebreak = "<br>\n";
+			else
+				linebreak = "\n";
+			if (holder.is_updated())
+				holder.getCacheDetails(false).Hints += linebreak + "[" + processingDescLang + ":]" + linebreak + Common.rot13(strData) + linebreak;
+			else
+				holder.getCacheDetails(false).Hints = "[" + processingDescLang + ":]" + linebreak + Common.rot13(strData) + linebreak;
 			holder.setUpdated(true); // remark: this is used in "shortdesc" to decide weather the description should be appended or replaced
 			return;
 		}
 	}
 
-	private String createPicFilename(String fetchURL) {
-		String fileName = holder.getWayPoint() + "_" + fetchURL.substring(fetchURL.lastIndexOf('/')+1);
-		return Common.ClearForFileName(fileName).toLowerCase();
-	}
-
-	private void getPic(String fetchURL, String picDesc) { // TODO handling of relativ URLs
-		try {
-			//TODO this is not quite correct: actually the "base" URL must be known...
-			// but anyway a different baseURL should not happen very often  - it doesn't in my area
-			if (!fetchURL.startsWith("http://")) fetchURL = new URL(
-				new URL("http://" + hostname+"/"), fetchURL).toString();
-			String fileName = createPicFilename(fetchURL);
-			ImageInfo imageInfo = new ImageInfo();
-			imageInfo.setURL(fetchURL);
-			// add title
-			imageInfo.setTitle(picDesc);
-			holder.getCacheDetails(false).images.add(imageInfo);
-			try {
-				File ftest = new FileBugfix(profile.dataDir + fileName);
-				if (ftest.exists()){
-					imageInfo.setFilename(fileName);
+	private void endCacheLog(String name) {
+		if (holder == null)
+			return;
+		if (name.equals("cachelog")) { // </cachelog>
+			if (holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended)) > -1) {
+				numLogImported++;
+				holder.getCacheDetails(false).hasUnsavedChanges = true; // chD.saveCacheDetails(profile.dataDir);
+			}
+			//
+			if ((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) && logtype == 1) {
+				if (incFinds || !holder.is_new()) {
+					// aber vorhandene werden mit gefunden aktualisiert
+					holder.setCacheStatus(logDate);
+					holder.setFound(true);
+					holder.getCacheDetails(false).OwnLogId = logId;
+					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
+				} else {
+					// if (holder.is_new())
+					cacheDB.removeElementAt(cacheDB.getIndex(holder));
+					DBindexID.remove(holder.GetCacheID());
+					// und Dateien l?schen?
+					final File tmpFile = new File(profile.dataDir + holder.getWayPoint() + ".xml");
+					tmpFile.delete();
+					// todo: was ist mit den schon heruntergeladenen Bildern?
 				}
-				else {
-					if (pref.downloadPics) {
-						imageInfo.setFilename(fetch(fetchURL, fileName));
-					}
-				}
-			} catch (IOException e) {
-				String ErrMessage;
-				String wp, n;
-				if (holder != null && holder.getWayPoint() != null) wp = holder.getWayPoint();
-				else 												wp = new String("WP???");
-				if (holder != null && holder.getCacheName() != null) n = holder.getCacheName();
-				else 												 n = new String("name???");
-
-				if (e == null) ErrMessage = "Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: "+fileName+" from URL:"+fetchURL;
-				else {
-					if (e.getMessage().equalsIgnoreCase("could not connect") ||
-							e.getMessage().equalsIgnoreCase("unkown host")) {
-						// is there a better way to find out what happened?
-						ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+ n + " ("+wp+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
-					} else
-						ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ")+ n + " ("+wp+"): ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+fetchURL);
-				}
-				inf.addWarning("\n"+ErrMessage);
-				pref.log(ErrMessage,e,true);
 			}
-		} catch (MalformedURLException e) {
-			String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + holder.getWayPoint() + ": ignoring MalformedUrlException: " + e.getMessage()+ " while downloading from URL:" + fetchURL);
-			inf.addWarning("\n"+ErrMessage);
-			pref.log(ErrMessage,e);
-		}
-
-	}
-
-
-	private void endPicture(String name){
-
-		if(name.equals("id")){
-			picID = strData;
 			return;
 		}
 
-		if (name.equals("url")){
-			picUrl = strData;
+		if (name.equals("date")) {
+			logDate = strData;
 			return;
 		}
-		if (name.equals("title")){
-			picTitle = strData;
+		if (name.equals("userid")) {
+			logFinder = strData;
 			return;
 		}
-		if(name.equals("object")){
-			// get cachedata
-			holder = getHolder(strData);
+		if (name.equals("text")) {
+			logData = strData;
 			return;
 		}
-		if(name.equals("picture")){
-			//String fileName = holder.wayPoint + "_" + picUrl.substring(picUrl.lastIndexOf("/")+1);
-			getPic(picUrl,picTitle);
-			holder.getCacheDetails(false).hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
-			return;
-		}
+
 	}
 
-	private void endCacheLog(String name){
-		if (name.equals("cachelog")){ // </cachelog>
-			holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
-			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) && logtype == 1) {
-						holder.setCacheStatus(logDate);
-						holder.setFound(true);
-						holder.getCacheDetails(false).OwnLogId = logId;
-						holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
-			}
-			holder.getCacheDetails(false).hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
+	private void endPicture(String name) {
+		if (holder == null)
 			return;
-		}
 
-		if (name.equals("cacheid")){ // </cacheid>
-			// load cachedata
-			holder = getHolder(strData);
+		if (name.equals("id")) {
+			picID = strData;
 			return;
 		}
 
-		if (name.equals("date"))  {
-			logDate = new String(strData);
+		if (name.equals("url")) {
+			picUrl = strData;
 			return;
 		}
-		if (name.equals("userid")){
-			logFinder = new String(strData);
+		if (name.equals("title")) {
+			picTitle = strData;
 			return;
 		}
-		if (name.equals("text")){
-			logData = new String(strData);
+		if (name.equals("picture")) {
+			inf.setInfo(MyLocale.getMsg(1613, "Pictures:") + " " + ++picCnt);
+			// String fileName = holder.wayPoint + "_" + picUrl.substring(picUrl.lastIndexOf("/")+1);
+			final ImageInfo ii = new ImageInfo();
+			ii.setTitle(picTitle);
+			ii.setURL(picUrl);
+			getPic(ii);
+			holder.getCacheDetails(false).hasUnsavedChanges = true; // saveCacheDetails(profile.dataDir);
 			return;
 		}
-
 	}
 
-	private String fetch(String addr, String fileName ) throws IOException
-	{
-		CharArray realurl = new CharArray();
-		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
-		FileOutputStream outp =  new FileOutputStream(profile.dataDir + fileName);
-		outp.write(daten.toBytes());
-		outp.close();
-		return fileName;
+	private CacheHolder getHolder(String guid, boolean create) {// See also LOCXMLImporter
+		CacheHolder ch = null;
+		// Integer INTR = (Integer)DBindexID.get(guid);
+		final String wp = (String) DBindexID.get(guid);
+		// if(INTR != null){
+		if (wp != null) {
+			// ch = cacheDB.get(INTR.intValue());
+			ch = cacheDB.get(wp);
+		} else {
+			if (create)
+				ch = new CacheHolder();
+		}
+		return ch;
 	}
 
-
-	/**
-	 * Method to iterate through cache database and look for cacheID.
-	 * Returns value >= 0 if cacheID is found, else -1
-	 */
-	private int searchID(String cacxheID){
-		Integer INTR = (Integer)DBindexID.get(cacxheID);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
+	private void getImageNamesFromDescription() {
+		String fetchUrl;
+		String imgTag;
+		String imgAltText;
+		final Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)"); // Ergebnis enthlt keine Anfhrungszeichen
+		final Regex imgRegexAlt = new Regex("(?:alt=[\"\']([^>^\"^\']*)|alt=([^>^\"^\'^ ]*))"); // get alternative text for Pic
+		imgRegexAlt.setIgnoreCase(true);
+		imgRegexUrl.setIgnoreCase(true);
+		int descIndex = 0;
+		int numDownloaded = 1;
+		while (imgRegexUrl.searchFrom(holder.getCacheDetails(false).LongDescription, descIndex)) { // "img" found
+			imgTag = imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte <img ...>-tag
+			fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			}
+			if (fetchUrl == null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
+				inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache " + holder.getWayPoint()));
+				continue;
+			}
+			inf.setInfo(MyLocale.getMsg(1611, "Importing cache description:") + " " + numDescImported + "\n" + MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
+			if (imgRegexAlt.search(imgTag)) {
+				imgAltText = imgRegexAlt.stringMatched(1);
+				if (imgAltText == null)
+					imgAltText = imgRegexAlt.stringMatched(2);
+				// no alternative text as image title -> use filename
+			} else {
+				if (fetchUrl.toLowerCase().indexOf("opencaching.") > 0 || fetchUrl.toLowerCase().indexOf("geocaching.com") > 0) // wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+					imgAltText = "No image title";
+				else
+					imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
+			}
+			descIndex = imgRegexUrl.matchedTo();
+			try {
+				// TODO this is not quite correct: actually the "base" URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
+				if (!fetchUrl.startsWith("http://")) {
+					fetchUrl = new URL(new URL("http://" + hostname + "/"), fetchUrl).toString();
+				}
+			} catch (final MalformedURLException e) {
+				final String ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + holder.getWayPoint() + ": ignoring MalformedUrlException: " + e.getMessage() + " while downloading from URL:" + fetchUrl;
+				inf.addWarning("\n" + ErrMessage);
+				pref.log(ErrMessage, e);
+			}
+			final ImageInfo imageInfo = new ImageInfo();
+			imageInfo.setURL(fetchUrl);
+			imageInfo.setTitle(imgAltText);
+			getPic(imageInfo);
+		}
 	}
 
+	private void getPic(ImageInfo imageInfo) { // TODO handling of relativ URLs
+		String fileName = holder.getWayPoint() + "_" + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
+		fileName = Common.ClearForFileName(fileName).toLowerCase();
+		final String target = profile.dataDir + fileName;
+		imageInfo.setFilename(fileName);
+		try {
+			File ftest = new FileBugfix(target);
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
+				if (pref.downloadPics) {
+					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
+					ftest = new FileBugfix(target);
+					if (ftest.exists()) {
+						if (ftest.length() > 0) {
+							holder.getCacheDetails(false).images.add(imageInfo);
+						} else {
+							ftest.delete();
+						}
+					}
+				}
+			}
+		} catch (final IOException e) {
+			String ErrMessage;
+			String wp, n;
+			if (holder != null && holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = "WP???";
+			if (holder != null && holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = "name???";
 
-	private CacheHolder getHolder(String wpt){// See also LOCXMLImporter
-		CacheHolder chx;
-		int index;
+			if (e == null)
+				ErrMessage = "Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: " + fileName + " from URL:" + imageInfo.getURL();
+			else {
+				if (e.getMessage().equalsIgnoreCase("could not connect") || e.getMessage().equalsIgnoreCase("unkown host")) {
+					// is there a better way to find out what happened?
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + ")" + MyLocale.getMsg(1619, ": could not download image from URL: ") + imageInfo.getURL();
+				} else
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + "): ignoring IOException: " + e.getMessage() + " while downloading picture:" + fileName + " from URL:" + imageInfo.getURL();
+			}
+			inf.addWarning("\n" + ErrMessage);
+			pref.log(ErrMessage, e, true);
+		}
 
-		index = cacheDB.getIndex(wpt);
-		if (index == -1) index = searchID(wpt);
-		if (index == -1) {
-			chx = new CacheHolder();
-		} else {
-			chx = cacheDB.get(index);
-		}
-		return chx;
 	}
 
 }

Modified: branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
 import CacheWolf.CacheType;
@@ -49,9 +49,9 @@
 
 /**
  * @author pfeffer
- * This Class is the Dialog for Download from Opencaching.de
- * is called from OCXMLImporter
- * 20061209 Bugfix: Checking for uninitialised missingCheckBox
+ *         This Class is the Dialog for Download from Opencaching.de
+ *         is called from OCXMLImporter
+ *         20061209 Bugfix: Checking for uninitialised missingCheckBox
  */
 public class OCXMLImporterScreen extends Form {
 	mButton cancelB, okB;
@@ -63,7 +63,7 @@
 	mInput maxNumberInput;
 	mInput maxNumberUpdates;
 	mInput maxLogsInput;
-	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox, travelbugsCheckBox;
+	mCheckBox imagesCheckBox, /* mapsCheckBox, */missingCheckBox, foundCheckBox, travelbugsCheckBox;
 	ewe.ui.mChoice domains;
 	String fileName;
 
@@ -86,7 +86,6 @@
 	public static final int MAXUPDATE = 4096;
 	public static final int FILENAME = 8192; // track or route gpx
 
-
 	public OCXMLImporterScreen(String title, int options) {
 		super();
 		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
@@ -95,39 +94,28 @@
 
 		this.title = title;
 
-		if((options & HOST) > 0){
-			domains = new mChoice(OC.OCHostNames(),OC.getSiteIndex(pref.lastOCSite));
+		if ((options & HOST) > 0) {
+			domains = new mChoice(OC.OCHostNames(), OC.getSiteIndex(pref.lastOCSite));
 			domains.setTextSize(25, 1);
-			this.addLast(domains, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(domains, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options & TYPE) > 0) {
-			this.addLast( chcType = new mChoice(new String[] {
-					MyLocale.getMsg(1627,"All caches"),
-					MyLocale.getMsg(2,"Tradi"),
-					MyLocale.getMsg(3,"Multi"),
-					MyLocale.getMsg(4,"Virtual"),
-					MyLocale.getMsg(5,"Letterbox"),
-					MyLocale.getMsg(6,"Event"),
-					MyLocale.getMsg(14,"Mega Event"),
-					MyLocale.getMsg(11,"Webcam"),
-					MyLocale.getMsg(8,"Mysterie"),
-					MyLocale.getMsg(13,"CITO"),
-					MyLocale.getMsg(18,"Earth"),
-					MyLocale.getMsg(15,"WhereIGo"),
-				},0), CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+			this.addLast(chcType = new mChoice(new String[] { MyLocale.getMsg(1627, "All caches"), MyLocale.getMsg(2, "Tradi"), MyLocale.getMsg(3, "Multi"), MyLocale.getMsg(4, "Virtual"), MyLocale.getMsg(5, "Letterbox"), MyLocale.getMsg(6, "Event"),
+					MyLocale.getMsg(14, "Mega Event"), MyLocale.getMsg(11, "Webcam"), MyLocale.getMsg(8, "Mysterie"), MyLocale.getMsg(13, "CITO"), MyLocale.getMsg(18, "Earth"), MyLocale.getMsg(15, "WhereIGo"), }, 0), CellConstants.STRETCH,
+					(CellConstants.FILL | CellConstants.WEST));
 		}
 
 		if ((options & MINDIST) > 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1628,"min. Distance:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1628, "min. Distance:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			minDistanceInput = new mInput();
 			minDistanceInput.setText(Global.getProfile().getMinDistGC());
-			this.addNext(minDistanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(new mLabel(" km/mi."),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(minDistanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(" km/mi."), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & DIST) > 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,"Distance:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601, "Distance:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxDistanceInput = new mInput();
 			String dist1;
 			String dist2;
@@ -138,150 +126,154 @@
 				dist1 = Global.getProfile().getDistOC();
 				dist2 = Global.getProfile().getDistGC();
 			}
-			if ( dist1.equals("") || dist1.equals("0") || dist1.equals("0.0") ) {
+			if (dist1.equals("") || dist1.equals("0") || dist1.equals("0.0")) {
 				dist1 = dist2;
 			}
 			maxDistanceInput.setText(dist1);
-			this.addNext(maxDistanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(distUnit = new mLabel(" km/mi."),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxDistanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(distUnit = new mLabel(" km/mi."), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & DIRECTION) > 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1629,"Richtung:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1629, "Richtung:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			directionInput = new mInput();
 			directionInput.setText(Global.getProfile().getDirectionGC());
-			directionInput.toolTip=MyLocale.getMsg(1630,"z.B. leer oder von-bis (Grad)");
-			this.addLast(directionInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			directionInput.toolTip = MyLocale.getMsg(1630, "z.B. leer oder von-bis (Grad)");
+			this.addLast(directionInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & MAXNUMBER) > 0) {
-			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623,"Max. number:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623, "Max. number:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxNumberInput = new mInput();
-			if ( pref.maxSpiderNumber < 0 || pref.maxSpiderNumber == Integer.MAX_VALUE) {
+			if (pref.maxSpiderNumber < 0 || pref.maxSpiderNumber == Integer.MAX_VALUE) {
 				maxNumberInput.setText("");
 			} else {
 				maxNumberInput.setText(Integer.toString(pref.maxSpiderNumber));
 			}
-			this.addNext(maxNumberInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast( new mLabel(MyLocale.getMsg(1624," caches")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(MyLocale.getMsg(1624, " caches")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & MAXUPDATE) > 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1631,"Max. Updates:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1631, "Max. Updates:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxNumberUpdates = new mInput();
 			maxNumberUpdates.setText("");
-			this.addNext(maxNumberUpdates,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast( new mLabel(MyLocale.getMsg(1624," caches")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberUpdates, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(MyLocale.getMsg(1624, " caches")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & MAXLOGS) > 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1626,"Max. logs:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1626, "Max. logs:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxLogsInput = new mInput();
 			maxLogsInput.setText(Convert.toString(pref.maxLogsToSpider));
-			this.addLast(maxLogsInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addLast(maxLogsInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & IMAGES) > 0) {
 			imagesCheckBox = new mCheckBox();
-			imagesCheckBox.setText(MyLocale.getMsg(1602,"Download Images"));
+			imagesCheckBox.setText(MyLocale.getMsg(1602, "Download Images"));
 			imagesCheckBox.setState(pref.downloadPics);
-			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options & TRAVELBUGS) > 0) {
 			travelbugsCheckBox = new mCheckBox();
-			travelbugsCheckBox.setText(MyLocale.getMsg(1625,"Download TBs"));
+			travelbugsCheckBox.setText(MyLocale.getMsg(1625, "Download TBs"));
 			travelbugsCheckBox.setState(pref.downloadTBs);
-			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
-		if((options & INCLUDEFOUND) > 0){
+		if ((options & INCLUDEFOUND) > 0) {
 			foundCheckBox = new mCheckBox();
-			foundCheckBox.setText(MyLocale.getMsg(1622,"Exclude found caches"));
-			foundCheckBox.setState(true);
-			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			foundCheckBox.setText(MyLocale.getMsg(1622, "Exclude found caches"));
+			foundCheckBox.setState(pref.doNotGetFound);
+			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
-		if((options & ALL) > 0){
+		if ((options & ALL) > 0) {
 			missingCheckBox = new mCheckBox();
-			missingCheckBox.setText(MyLocale.getMsg(1606,"Alle erneut downloaden"));
-			missingCheckBox.setState(pref.downloadMissingOC);
-			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			missingCheckBox.setText(MyLocale.getMsg(1606, "Alle erneut downloaden"));
+			missingCheckBox.setState(pref.downloadAllOC);
+			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options & FILENAME) > 0) {
 			String dir = pref.getImporterPath("LocGpxImporter");
 			FileChooser fc = new FileChooser(FileChooserBase.OPEN, dir);
 			fc.addMask("*.gpx");
-			fc.setTitle(MyLocale.getMsg(909,"Select file(s)"));
-			if(fc.execute() != FormBase.IDCANCEL){
+			fc.setTitle(MyLocale.getMsg(909, "Select file(s)"));
+			if (fc.execute() != FormBase.IDCANCEL) {
 				dir = fc.getChosenDirectory().toString();
 				pref.setImporterPath("LocGpxImporter", dir);
-				//String files[] = fc.getAllChosen();
-				fileName=fc.file;
+				// String files[] = fc.getAllChosen();
+				fileName = fc.file;
+			} else {
+				fileName = "";
 			}
-			else {
-				fileName="";
-			}
 		}
 
-		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB = new mButton(MyLocale.getMsg(1604, "Cancel"));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okB = new mButton(MyLocale.getMsg(1605,"OK"));
+		this.addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		okB = new mButton(MyLocale.getMsg(1605, "OK"));
 		okB.setHotKey(0, IKeys.ACTION);
 		okB.setHotKey(0, IKeys.ENTER);
-		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(okB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB) {
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okB){
-				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr?ft werden kann, ob es gr??er oder kleiner ist als vorher
-					if (missingCheckBox!=null) pref.downloadMissingOC = missingCheckBox.state;
-					if (imagesCheckBox!=null) pref.downloadPics = imagesCheckBox.state;
-					if (travelbugsCheckBox!=null) pref.downloadTBs = travelbugsCheckBox.state;
-					if (maxLogsInput!=null) pref.maxLogsToSpider=Common.parseInt(maxLogsInput.getText());
-					pref.savePreferences();
+			if (ev.target == okB) {
+				// distOC wird hier noch nicht in Pref eingetragen, damit noch gepr?ft werden kann, ob es gr??er oder kleiner ist als vorher
+				if (missingCheckBox != null)
+					pref.downloadAllOC = missingCheckBox.state;
+				if (imagesCheckBox != null)
+					pref.downloadPics = imagesCheckBox.state;
+				if (travelbugsCheckBox != null)
+					pref.downloadTBs = travelbugsCheckBox.state;
+				if (maxLogsInput != null)
+					pref.maxLogsToSpider = Common.parseInt(maxLogsInput.getText());
+				pref.savePreferences();
 				this.close(FormBase.IDOK);
-				}
+			}
 		}
 		super.onEvent(ev);
 	}
 
-	public String getCacheTypeRestriction(SpiderProperties p){
+	public String getCacheTypeRestriction(SpiderProperties p) {
 		String cacheTypeRestriction = "";
 
-		if (chcType!=null){
+		if (chcType != null) {
 			try {
 				switch (chcType.getInt()) {
-				case  0:
+				case 0:
 					cacheTypeRestriction = "";
 					break;
-				case  1:
+				case 1:
 					cacheTypeRestriction = p.getProp("onlyTraditional");
 					break;
-				case  2:
+				case 2:
 					cacheTypeRestriction = p.getProp("onlyMulti");
 					break;
-				case  3:
-					cacheTypeRestriction = p.getProp("onlyVirtual") ;
+				case 3:
+					cacheTypeRestriction = p.getProp("onlyVirtual");
 					break;
-				case  4:
+				case 4:
 					cacheTypeRestriction = p.getProp("onlyLetterboxHybrid");
 					break;
-				case  5:
+				case 5:
 					cacheTypeRestriction = p.getProp("onlyEvent");
 					break;
-				case  6:
+				case 6:
 					cacheTypeRestriction = p.getProp("onlyMegaEvent");
 					break;
-				case  7:
+				case 7:
 					cacheTypeRestriction = p.getProp("onlyWebcam");
 					break;
-				case  8:
+				case 8:
 					cacheTypeRestriction = p.getProp("onlyUnknown");
 					break;
 				case 9:
@@ -296,43 +288,43 @@
 				default:
 					cacheTypeRestriction = "";
 				}
-			}catch (Exception ex) { // Some tag missing from spider.def
+			} catch (Exception ex) { // Some tag missing from spider.def
 			}
 		}
 		return cacheTypeRestriction;
 	}
 
-	public byte getRestrictedCacheType(SpiderProperties p){
+	public byte getRestrictedCacheType(SpiderProperties p) {
 		byte RestrictedType = CacheType.CW_TYPE_ERROR;
 
-		if (chcType!=null){
+		if (chcType != null) {
 			try {
 				switch (chcType.getInt()) {
-				case  0:
+				case 0:
 					RestrictedType = CacheType.CW_TYPE_ERROR;
 					break;
-				case  1:
+				case 1:
 					RestrictedType = CacheType.CW_TYPE_TRADITIONAL;
 					break;
-				case  2:
+				case 2:
 					RestrictedType = CacheType.CW_TYPE_MULTI;
 					break;
-				case  3:
+				case 3:
 					RestrictedType = CacheType.CW_TYPE_VIRTUAL;
 					break;
-				case  4:
+				case 4:
 					RestrictedType = CacheType.CW_TYPE_LETTERBOX;
 					break;
-				case  5:
+				case 5:
 					RestrictedType = CacheType.CW_TYPE_EVENT;
 					break;
-				case  6:
+				case 6:
 					RestrictedType = CacheType.CW_TYPE_MEGA_EVENT;
 					break;
-				case  7:
+				case 7:
 					RestrictedType = CacheType.CW_TYPE_WEBCAM;
 					break;
-				case  8:
+				case 8:
 					RestrictedType = CacheType.CW_TYPE_UNKNOWN;
 					break;
 				case 9:
@@ -347,7 +339,7 @@
 				default:
 					RestrictedType = CacheType.CW_TYPE_ERROR;
 				}
-			}catch (Exception ex) { // Some tag missing from spider.def
+			} catch (Exception ex) { // Some tag missing from spider.def
 			}
 		}
 		return RestrictedType;

Modified: branches/r1.2/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/SpiderGC.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/SpiderGC.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -37,7 +37,6 @@
 import CacheWolf.DateFormat;
 import CacheWolf.Extractor;
 import CacheWolf.Global;
-import CacheWolf.HttpConnection;
 import CacheWolf.ImageInfo;
 import CacheWolf.InfoBox;
 import CacheWolf.Log;
@@ -48,6 +47,7 @@
 import CacheWolf.STRreplace;
 import CacheWolf.SafeXML;
 import CacheWolf.Travelbug;
+import CacheWolf.UrlFetcher;
 import CacheWolf.navi.Area;
 import CacheWolf.navi.Metrics;
 import CacheWolf.navi.MovingMap;
@@ -61,14 +61,10 @@
 import ewe.data.Property;
 import ewe.data.PropertyList;
 import ewe.fx.Image;
-import ewe.io.File;
 import ewe.io.FileBase;
 import ewe.io.FileInputStream;
-import ewe.io.FileOutputStream;
 import ewe.io.IOException;
 import ewe.io.InputStreamReader;
-import ewe.io.JavaUtf8Codec;
-import ewe.net.Socket;
 import ewe.net.URL;
 import ewe.net.UnknownHostException;
 import ewe.sys.Convert;
@@ -77,7 +73,6 @@
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
 import ewe.util.ByteArray;
-import ewe.util.CharArray;
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Properties;
@@ -111,19 +106,23 @@
 	/** no probs, but exmpl found und not want this */
 	public static int SPIDER_IGNORE = 2;
 
+	/**
+	 * This is the pattern for inlined smilies
+	 */
+	private static final String string = "<img src=\"/images/icons/";
+
 	private static int ERR_LOGIN = -10;
 	private static Preferences pref;
-	private Profile profile;
+	private final Profile profile;
 
-	private static String cookieID = "";
-	private static String cookieSession = "";
+	private static String cookie = "";
 	private static double minDistance = 0;
 	private static double maxDistance = 0;
 	private static String direction = "";
 	private static String[] directions;
 
-	private CacheDB cacheDB;
-	private Vector cachesToLoad = new Vector();
+	private final CacheDB cacheDB;
+	private final Vector cachesToLoad = new Vector();
 	private InfoBox infB;
 	private static SpiderProperties p = null;
 	// following filled at doit
@@ -137,13 +136,16 @@
 	private byte restrictedCacheType = 0;
 	private String fileName = "";
 	private String userToken = "";
+	private String sessionToken = "";
 
 	private static String propFirstPage;
 	private static String propFirstPage2;
 	private static String propFirstPageFinds;
 	private static String gotoNextPage = "ctl00$ContentBody$pgrTop$ctl08";
-	private static String gotoNextBlock = "ctl00$ContentBody$pgrTop$ctl06";  // change to the block (10pages) of the wanted page
-	private static String gotoPage = "ctl00$ContentBody$pgrTop$lbGoToPage_"; // add pagenumber
+	// change to the block (10pages) of the wanted page
+	private static String gotoNextBlock = "ctl00$ContentBody$pgrTop$ctl06";
+	// add pagenumber
+	private static String gotoPage = "ctl00$ContentBody$pgrTop$lbGoToPage_";
 	private static String propMaxDistance;
 	private static String propShowOnlyFound;
 	private static Regex RexPropListBlock;
@@ -182,10 +184,8 @@
 	private int numPrivate = 0;
 	private int page_number = 1;
 	private int num_added = 0;
-	
-	private static HttpConnection conn;
 
-	public SpiderGC(Preferences prf, Profile profile, boolean bypass) {
+	public SpiderGC(Preferences prf, Profile profile) {
 		this.profile = profile;
 		this.cacheDB = profile.cacheDB;
 		pref = prf;
@@ -205,15 +205,16 @@
 	public void doIt(boolean _spiderAllFinds) {
 		cachesToLoad.clear();
 		spiderAllFinds = _spiderAllFinds;
-		origin = pref.getCurCentrePt(); // No need to copy curCentrePt as it is only read and not written
+		// No need to copy curCentrePt as it is only read and not written
+		origin = pref.getCurCentrePt();
 		if (!spiderAllFinds && !origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5509,"Coordinates for centre must be set"), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
 			return;
 		}
 
 		// Reset states for all caches when spidering (http://tinyurl.com/dzjh7p)
 		for (int i = 0; i < cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
@@ -224,29 +225,23 @@
 			infB = new InfoBox("Status", MyLocale.getMsg(5502, "Fetching first page..."));
 			infB.exec();
 
-			pref.log("ListPages Properties : " + Preferences.NEWLINE
-					+ "minDistance: " + minDistance + Preferences.NEWLINE
-					+ "maxDistance: " + maxDistance + Preferences.NEWLINE
-					+ "directions: " + direction + Preferences.NEWLINE
-					+ "maxNew: " + pref.maxSpiderNumber + Preferences.NEWLINE
-					+ "maxUpdate: " + maxUpdate + Preferences.NEWLINE
-					+ "with Founds       : " + (doNotgetFound ? "no" : "yes")
-					+ Preferences.NEWLINE + "alias is premium m: "
-					+ (!pref.isPremium ? "no" : "yes") + Preferences.NEWLINE
-					+ "Update if new Logs: " + (!pref.checkLog ? "no" : "yes")
-					+ Preferences.NEWLINE, null);
+			pref.log("ListPages Properties : " + Preferences.NEWLINE + "minDistance          : " + minDistance + Preferences.NEWLINE + "maxDistance          : " + maxDistance + Preferences.NEWLINE + "directions           : " + direction
+					+ Preferences.NEWLINE + "maxNew               : " + pref.maxSpiderNumber + Preferences.NEWLINE + "maxUpdate            : " + maxUpdate + Preferences.NEWLINE + "with Founds          : " + (doNotgetFound ? "no" : "yes")
+					+ Preferences.NEWLINE + "alias is premium memb: " + (!pref.isPremium ? "no" : "yes") + Preferences.NEWLINE + "Update if new Log    : " + (pref.checkLog ? "yes" : "no") + Preferences.NEWLINE + "Update if TB changed : "
+					+ (pref.checkTBs ? "yes" : "no") + Preferences.NEWLINE + "Update if DTS changed: " + (pref.checkDTS ? "yes" : "no") + Preferences.NEWLINE, null);
 
 			Hashtable cachesToUpdate = new Hashtable(cacheDB.size());
 
-			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate,
-					maxDistance, minDistance, directions, cachesToUpdate);
-			if (cachesToUpdate == null) { cachesToUpdate = new Hashtable(); };
+			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate, maxDistance, minDistance, directions, cachesToUpdate);
+			if (cachesToUpdate == null) {
+				cachesToUpdate = new Hashtable();
+			}
+			;
 			if (!infB.isClosed) {
-				infB.setInfo(MyLocale.getMsg(5511, "Found ")
-						+ cachesToLoad.size()
-						+ MyLocale.getMsg(5512, " caches"));
+				infB.setInfo(MyLocale.getMsg(5511, "Found ") + cachesToLoad.size() + MyLocale.getMsg(5512, " caches"));
 			}
-			// continue to update index to changed cache.xml things (size,terrain,difficulty,...?) 
+			// continue to update index to changed cache.xml things
+			// (size,terrain,difficulty,...?)
 
 			// =======
 			// Now ready to spider each cache in the lists
@@ -258,7 +253,7 @@
 					cachesToUpdate.clear();
 					break;
 				case Preferences.ASK:
-					MessageBox mBox = new MessageBox(MyLocale.getMsg(5517,"Spider Updates?"), cachesToUpdate.size() + MyLocale.getMsg(5518," caches in database need an update. Update now?") , FormBase.IDYES |FormBase.IDNO);
+					final MessageBox mBox = new MessageBox(MyLocale.getMsg(5517, "Spider Updates?"), cachesToUpdate.size() + MyLocale.getMsg(5518, " caches in database need an update. Update now?"), FormBase.IDYES | FormBase.IDNO);
 					if (mBox.execute() != FormBase.IDOK) {
 						cachesToUpdate.clear();
 					}
@@ -267,17 +262,10 @@
 			}
 
 			int spiderErrors = 0;
-			int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
-			boolean loadAllLogs = (pref.maxLogsToSpider > 5) || spiderAllFinds;
-			pref.log("Download properties : " + Preferences.NEWLINE
-					+ "maxLogs: "
-					+ (loadAllLogs ? "completepage " : "shortpage") + "nr.:"
-					+ pref.maxLogsToSpider + Preferences.NEWLINE
-					+ "with pictures     : "
-					+ (!pref.downloadPics ? "no" : "yes") + Preferences.NEWLINE
-					+ "with tb           : "
-					+ (!pref.downloadTBs ? "no" : "yes") + Preferences.NEWLINE,
-					null);
+			final int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
+			final boolean loadAllLogs = (pref.maxLogsToSpider > 5) || spiderAllFinds;
+			pref.log("Download properties : " + Preferences.NEWLINE + "maxLogs: " + (loadAllLogs ? "completepage " : "shortpage") + "nr.:" + pref.maxLogsToSpider + Preferences.NEWLINE + "with pictures     : " + (!pref.downloadPics ? "no" : "yes")
+					+ Preferences.NEWLINE + "with tb           : " + (!pref.downloadTBs ? "no" : "yes") + Preferences.NEWLINE, null);
 
 			if (Global.mainTab.statBar != null)
 				Global.mainTab.statBar.updateDisplay("");
@@ -288,14 +276,11 @@
 			}
 
 			if (spiderErrors > 0) {
-				new MessageBox(MyLocale.getMsg(5500, "Error"),
-						spiderErrors + MyLocale.getMsg(5516," cache descriptions%0acould not be loaded."),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5500, "Error"), spiderErrors + MyLocale.getMsg(5516, " cache descriptions%0acould not be loaded."), FormBase.DEFOKB).execute();
 			}
 			if (maxNumberAbort) {
-				new MessageBox(MyLocale.getMsg(5519, "Information"),
-						MyLocale.getMsg(5520,"Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated."),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5519, "Information"), MyLocale.getMsg(5520, "Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated."), FormBase.DEFOKB)
+						.execute();
 			}
 			Global.getProfile().restoreFilter();
 			Global.getProfile().saveIndex(Global.getPref(), true);
@@ -310,81 +295,77 @@
 	public void doItAlongARoute() {
 		Area sq;
 		Vector points = null;
-		Navigate nav=Global.mainTab.nav;
-		MovingMap mm=Global.mainTab.mm;
+		final Navigate nav = Global.mainTab.nav;
+		MovingMap mm = Global.mainTab.mm;
 
 		if (!doDownloadGui(1))
 			return;
 
 		CWPoint startPos = pref.getCurCentrePt();
 		if (!fileName.equals("")) {
-			RouteImporter ri = new RouteImporter(fileName);
-			points = ri.doIt();			
+			final RouteImporter ri = new RouteImporter(fileName);
+			points = ri.doIt();
 			if (points.size() > 0) {
-				if (nav!=null) {
-					if (mm==null) {
+				if (nav != null) {
+					if (mm == null) {
 						Global.mainTab.mm = new MovingMap(nav, profile.cacheDB);
-						mm=Global.mainTab.mm;
+						mm = Global.mainTab.mm;
 						nav.setMovingMap(Global.mainTab.mm);
 					}
 					if (nav.curTrack == null) {
-						nav.curTrack=new Track(nav.trackColor);
+						nav.curTrack = new Track(nav.trackColor);
 						mm.addTrack(nav.curTrack);
 					}
 					for (int i = 0; i < points.size(); i++) {
 						try {
 							nav.curTrack.add((TrackPoint) points.get(i));
-						} catch (IndexOutOfBoundsException e) { // track full -> create a new one
-							nav.curTrack=new Track(nav.trackColor);
+						} catch (final IndexOutOfBoundsException e) {
+							// track full -> create a new one
+							nav.curTrack = new Track(nav.trackColor);
 							nav.curTrack.add((TrackPoint) points.get(i));
-							if (mm != null) mm.addTrack(nav.curTrack);
+							if (mm != null)
+								mm.addTrack(nav.curTrack);
 						}
 
 					}
 				}
-				TrackPoint tp = (TrackPoint) points.get(0);
+				final TrackPoint tp = (TrackPoint) points.get(0);
 				startPos = new CWPoint(tp.latDec, tp.lonDec);
 			} else
 				startPos = null;
 		}
 
-		int answer = new MessageBox(MyLocale.getMsg(651, "Question"),
-				MyLocale.getMsg(652,"Update caches with all details?"),
-				MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
-		boolean complete = answer == MessageBox.YESB;
-		if ( answer == MessageBox.IDCANCEL) {
-			if (startPos != null) pref.setCurCentrePt(startPos);
+		final int answer = new MessageBox(MyLocale.getMsg(651, "Question"), MyLocale.getMsg(652, "Update caches with all details?"), MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
+		final boolean complete = answer == MessageBox.YESB;
+		if (answer == MessageBox.IDCANCEL) {
+			if (startPos != null)
+				pref.setCurCentrePt(startPos);
 			return;
 		}
 
 		if (startPos != null && !startPos.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, "Error"),
-					MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB))
-					.execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
 			return; //
 		}
 
 		Vm.showWait(true);
-		infB = new InfoBox("Status", MyLocale.getMsg(5502,"Fetching pages..."));
+		infB = new InfoBox("Status", MyLocale.getMsg(5502, "Fetching pages..."));
 		infB.exec();
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		// Reset states for all caches when spidering
 		// (http://tinyurl.com/dzjh7p)
 		for (int i = 0; i < cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
 		double lateralDistance = maxDistance; // Seitenabstand in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 		cachesToLoad.clear();
 
@@ -396,9 +377,8 @@
 				nextPos = nextRoutePoint(startPos, lateralDistance);
 			} else {
 				double tmpDistance = 0;
-				while (tmpDistance < lateralDistance
-						&& pointsIndex < points.size()) {
-					TrackPoint tp = (TrackPoint) points.get(pointsIndex);
+				while (tmpDistance < lateralDistance && pointsIndex < points.size()) {
+					final TrackPoint tp = (TrackPoint) points.get(pointsIndex);
 					nextPos = new CWPoint(tp.latDec, tp.lonDec);
 					tmpDistance = nextPos.getDistance(startPos);
 					pointsIndex++;
@@ -407,33 +387,24 @@
 					nextPos = null;
 				else {
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay("GC pages: "
-								+ page_number + " Caches added to CW: "
-								+ num_added + " at "
-								+ pointsIndex+"("+points.size()+")"
-								+ nextPos
-								);
+						Global.mainTab.statBar.updateDisplay("GC pages: " + page_number + " Caches added to CW: " + num_added + " at " + pointsIndex + "(" + points.size() + ")" + nextPos);
 				}
 			}
 
-
 			if (nextPos != null) {
 				sq = getSquare(startPos, lateralDistance);
-				getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-						sq.buttomright.latDec, sq.buttomright.lonDec, complete);
+				getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 				// pref.log("next WP = " + startPos.toString(), null);
 
-				double degrees = startPos.getBearing(nextPos);
-				double distanceToNextCache = startPos.getDistance(nextPos);
-				double anzCheckPoints = distanceToNextCache / lateralDistance;
+				final double degrees = startPos.getBearing(nextPos);
+				final double distanceToNextCache = startPos.getDistance(nextPos);
+				final double anzCheckPoints = distanceToNextCache / lateralDistance;
 				for (int i = 1; i < anzCheckPoints; i++) {
-					CWPoint nextCheckPoint = startPos.project(degrees,
-							lateralDistance);
+					final CWPoint nextCheckPoint = startPos.project(degrees, lateralDistance);
 					startPos = nextCheckPoint;
 					origin = nextCheckPoint;
 					sq = getSquare(origin, lateralDistance);
-					getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-							sq.buttomright.latDec, sq.buttomright.lonDec, complete);
+					getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 					// pref.log("next CP = " + origin.toString(), null);
 					if (infB.isClosed) {
 						break;
@@ -446,42 +417,36 @@
 			}
 		}
 		sq = getSquare(startPos, lateralDistance);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.buttomright.latDec,
-				sq.buttomright.lonDec, complete);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 		// pref.log("last WP = " + startPos.toString(), null);
 		if (infB.isClosed) {
 			Vm.showWait(false);
 			return;
 		} // or ask for download of intermediate result
-		
+
 		int spiderErrors = 0;
 		if (complete) {
 			for (int i = 0; i < cachesToLoad.size(); i++) {
 				String wpt = (String) cachesToLoad.get(i);
-				boolean is_found = wpt.indexOf("found") != -1;
+				final boolean is_found = wpt.indexOf("found") != -1;
 				if (is_found)
 					wpt = wpt.substring(0, wpt.indexOf("found"));
-				int j = cacheDB.getIndex(wpt);
+				final int j = cacheDB.getIndex(wpt);
 				if (j != -1)
 					cacheDB.removeElementAt(j);
 			}
 			spiderErrors = downloadCaches(cachesToLoad, spiderErrors, cachesToLoad.size(), true);
 
+		} else {
 		}
-		else {
-		}
 
 		infB.close(0);
 		Vm.showWait(false);
 		if (spiderErrors > 0) {
-			new MessageBox(MyLocale.getMsg(5500, "Error"),
-					spiderErrors + MyLocale.getMsg(5516," cache descriptions%0acould not be loaded."),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5500, "Error"), spiderErrors + MyLocale.getMsg(5516, " cache descriptions%0acould not be loaded."), FormBase.DEFOKB).execute();
 		}
 		if (maxNumberAbort) {
-			new MessageBox(MyLocale.getMsg(5519,"Information"),
-					MyLocale.getMsg(5520,"Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated."),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5519, "Information"), MyLocale.getMsg(5520, "Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated."), FormBase.DEFOKB).execute();
 		}
 		Global.getProfile().restoreFilter();
 		Global.getProfile().saveIndex(Global.getPref(), true);
@@ -495,9 +460,9 @@
 		CacheHolder ch = null;
 		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			if (ch.is_Checked && ch.pos.isValid()) {
-				CWPoint tmpPos = ch.pos;
-				double tmpDistance = tmpPos.getDistance(startPos);
+			if (ch.is_Checked && ch.getPos().isValid()) {
+				final CWPoint tmpPos = ch.getPos();
+				final double tmpDistance = tmpPos.getDistance(startPos);
 				if (nextDistance == 0) {
 					// Startwert
 					index = i;
@@ -519,38 +484,36 @@
 			}
 		}
 		if (index > -1) {
-			return cacheDB.get(index).pos;
+			return cacheDB.get(index).getPos();
 		} else
 			return null;
 	}
 
 	private Area getSquare(CWPoint centre, double halfSideLengthKm) {
-		int north = 0;
-		int east = 1;
-		int south = 2;
-		int west = 3;
-		double halfSideLength = halfSideLengthKm * 1000.0; // in meters
-		Area ret = new Area();
+		final int north = 0;
+		final int east = 1;
+		final int south = 2;
+		final int west = 3;
+		final double halfSideLength = halfSideLengthKm * 1000.0; // in meters
+		final Area ret = new Area();
 		ret.topleft.latDec = centre.latDec;
 		ret.topleft.lonDec = centre.lonDec;
 		ret.topleft.shift(halfSideLength, north);
 		ret.topleft.shift(halfSideLength, west);
 
-		ret.buttomright.latDec = centre.latDec;
-		ret.buttomright.lonDec = centre.lonDec;
-		ret.buttomright.shift(halfSideLength, south);
-		ret.buttomright.shift(halfSideLength, east);
+		ret.bottomright.latDec = centre.latDec;
+		ret.bottomright.lonDec = centre.lonDec;
+		ret.bottomright.shift(halfSideLength, south);
+		ret.bottomright.shift(halfSideLength, east);
 
 		return ret;
 	}
 
-	public void doItQuickFillFromMapList() {
+	public void doItQuickFillFromOldMapList() {
 
-		CWPoint origin = pref.getCurCentrePt();
+		final CWPoint origin = pref.getCurCentrePt();
 		if (!origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, "Error"),
-					MyLocale.getMsg(5509, "Coordinates for centre must be set"),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
 			return; //
 		}
 		if (!doDownloadGui(2))
@@ -560,31 +523,27 @@
 		infB = new InfoBox("Status", MyLocale.getMsg(1609, "getting the caches."));
 		infB.exec();
 
-		// Reset states for all caches when spidering
-		// (http://tinyurl.com/dzjh7p)
+		// Reset states for all caches when spidering (http://tinyurl.com/dzjh7p)
 		for (int i = 0; i < cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl?nge eines Quadrats ums Zentrum in km
+		// halbe Seitenl?nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance;
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		page_number = 0;
 		num_added = 0;
 
-		Area sq = getSquare(origin, halfSideLength);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.buttomright.latDec,
-				sq.buttomright.lonDec, false);
+		final Area sq = getSquare(origin, halfSideLength);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, false);
 
 		if (!infB.isClosed)
 			infB.close(0);
@@ -595,22 +554,24 @@
 
 	}
 
-	private void getCaches(double north, double west, double south,
-			double east, boolean setCachesToLoad) {
+	private void getCaches(double north, double west, double south, double east, boolean setCachesToLoad) {
 		if (infB.isClosed)
 			return;
-		double lm = (north + south) / 2.0;
-		CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
-		CWPoint rm = new CWPoint(lm, east);
-		double len = middle.getDistance(rm) * 2.0;
+		final double lm = (north + south) / 2.0;
+		final CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
+		final CWPoint rm = new CWPoint(lm, east);
+		final double len = middle.getDistance(rm) * 2.0;
 		page_number++;
-		String listPage = getMapListPage(middle, north, west, south, east);
-		int i = listPage.indexOf("\"count\\\":"); // \"count\":
+		final String listPage = getMapListPage(middle, north, west, south, east);
+		final int i = listPage.indexOf("\"count\\\":"); // \"count\":
+		if (i == -1) {
+			pref.log("[getCaches:getMapListPage]got nothing!" + listPage, null);
+			return;
+		}
 		pref.log("" + north + " " + west + " " + south + " " + east + " " + listPage.substring(i) + "\n len=" + len);
-		if ((listPage.indexOf("\"count\\\":501") > -1)
-		||  (listPage.indexOf("\"count\\\":0") > -1 && len > 30)) {
-			double northsouthmiddle = (north + south) / 2.0;
-			double westeastmiddle = (west + east) / 2.0;
+		if ((listPage.indexOf("\"count\\\":501") > -1) || (listPage.indexOf("\"count\\\":0") > -1 && len > 30)) {
+			final double northsouthmiddle = (north + south) / 2.0;
+			final double westeastmiddle = (west + east) / 2.0;
 			getCaches(north, west, northsouthmiddle, westeastmiddle, setCachesToLoad);
 			getCaches(north, westeastmiddle, northsouthmiddle, east, setCachesToLoad);
 			getCaches(northsouthmiddle, west, south, westeastmiddle, setCachesToLoad);
@@ -621,51 +582,55 @@
 	}
 
 	private void addCaches(String listPage, boolean setCachesToLoad) {
-		String[] caches = mString.split(listPage, '{');
-		//int posId=0;        //id egal
-		//int posName=1;      //nn
-		
-		//positions decreased by 2, because we cut away the name to prevent parsing errors
-		int posWP=0;        //gc 
-		int posLat=1;       //lat
-		int posLon=2;       //lon
-		int posType=3;      //ctid
-		int posFound=4;     //f
-		int posOwn=5;       //o
-		int posAvailable=6; //ia
+		final String[] caches = mString.split(listPage, '{');
+		// int posId=0; //id egal
+		// int posName=1; //nn
+
+		// positions decreased by 2, because we cut away the name to prevent
+		// parsing errors
+		final int posWP = 0; // gc
+		final int posLat = 1; // lat
+		final int posLon = 2; // lon
+		final int posType = 3; // ctid
+		final int posFound = 4; // f
+		final int posOwn = 5; // o
+		final int posAvailable = 6; // ia
 		// ignoring first 3 lines
 		for (int i = 4; i < caches.length; i++) {
-			if (infB.isClosed) return;
-			
-			//cut away name to prevent parsing errors			
-			int WpIndex = caches[i].indexOf("\"gc\\\"");
-			String elements[] = mString.split(caches[i].substring(WpIndex), ',');
-			
-			boolean found = (elements[posFound].indexOf("true") > -1 ? true : false);
-			if (found && doNotgetFound)	continue;
-			
-			byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
+			if (infB.isClosed)
+				return;
+
+			// cut away name to prevent parsing errors
+			final int WpIndex = caches[i].indexOf("\"gc\\\"");
+			final String elements[] = mString.split(caches[i].substring(WpIndex), ',');
+
+			final boolean found = (elements[posFound].indexOf("true") > -1 ? true : false);
+			if (found && doNotgetFound)
+				continue;
+
+			final byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
 			if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
-				if (restrictedCacheType != cacheType) continue;
+				if (restrictedCacheType != cacheType)
+					continue;
 			}
 
 			String wp = mString.split(elements[posWP], '\"')[3];
-			wp=wp.substring(0, wp.length()-1);
+			wp = wp.substring(0, wp.length() - 1);
 			CacheHolder ch = cacheDB.get(wp);
 			if (ch == null) {
 
-				String lat = mString.split(elements[posLat], ':')[1];
-				String lon = mString.split(elements[posLon], ':')[1];
-				String own = mString.split(elements[posOwn], ':')[1];
-				boolean available = (elements[posAvailable].indexOf("true") > -1 ? true : false);
-				
-				int NameIndex = caches[i].indexOf("\"nn\\\"");
-				String cacheName = caches[i].substring (NameIndex + 8, WpIndex - 4 );
-				cacheName = STRreplace.replace(cacheName, "\\\"", "\"" );
+				final String lat = mString.split(elements[posLat], ':')[1];
+				final String lon = mString.split(elements[posLon], ':')[1];
+				final String own = mString.split(elements[posOwn], ':')[1];
+				final boolean available = (elements[posAvailable].indexOf("true") > -1 ? true : false);
 
+				final int NameIndex = caches[i].indexOf("\"nn\\\"");
+				String cacheName = caches[i].substring(NameIndex + 8, WpIndex - 4);
+				cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
+
 				ch = new CacheHolder();
 				ch.setWayPoint(wp);
-				ch.setLatLon(lat + " " + lon);
+				ch.setPos(new CWPoint(lat + " " + lon));
 				ch.setType(cacheType);
 				if (own.equals("true")) {
 					ch.setOwned(true);
@@ -682,13 +647,11 @@
 				if (setCachesToLoad) {
 					cachesToLoad.add(wp + "found");
 				} else {
-					ch.getCacheDetails(false).URL="http://www.geocaching.com/seek/cache_details.aspx?wp="+wp;
+					ch.getCacheDetails(false).URL = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + wp;
 					ch.save();
 				}
 				if (Global.mainTab.statBar != null)
-					Global.mainTab.statBar.updateDisplay("GC pages: "
-							+ page_number + " Caches added to CW: "
-							+ num_added);
+					Global.mainTab.statBar.updateDisplay("GC pages: " + page_number + " Caches added to CW: " + num_added);
 			} else {
 			}
 		}
@@ -699,13 +662,8 @@
 		OCXMLImporterScreen options;
 		direction = "";
 		if (menu == 0 && spiderAllFinds) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(217,
-					"Spider all finds from geocaching.com"),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER
-							| OCXMLImporterScreen.MAXUPDATE
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.MAXLOGS);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(217, "Spider all finds from geocaching.com"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.IMAGES
+					| OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS);
 			// setting defaults for input
 			options.maxNumberUpdates.setText("0");
 			// doing the input
@@ -716,16 +674,8 @@
 			maxDistance = 1.0;
 			minDistance = 0.0;
 		} else if (menu == 0) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(131,
-					"Download from geocaching.com"), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.MAXNUMBER
-					| OCXMLImporterScreen.MAXUPDATE
-					| OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.DIRECTION
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.IMAGES
-					| OCXMLImporterScreen.TRAVELBUGS
-					| OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(131, "Download from geocaching.com"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
+					| OCXMLImporterScreen.DIRECTION | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
 			// setting defaults for input
 			if (pref.spiderUpdates == Preferences.NO) {
 				options.maxNumberUpdates.setText("0");
@@ -736,29 +686,21 @@
 			}
 			// setting default values for options not used (if necessary)
 
-			String minDist = options.minDistanceInput.getText();
+			final String minDist = options.minDistanceInput.getText();
 			minDistance = Common.parseDouble(minDist);
 			profile.setMinDistGC(Double.toString(minDistance).replace(',', '.'));
 
 			direction = options.directionInput.getText();
 			directions = mString.split(direction, '-');
-			
+
 			doNotgetFound = options.foundCheckBox.getState();
 			profile.setDirectionGC(direction);
 
-		} else if (menu == 1) { // menu = 1 input values for get Caches along a
-								// route
-			options = new OCXMLImporterScreen(MyLocale.getMsg(137,
-					"Download along a Route from geocaching.com"),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST
-							| OCXMLImporterScreen.INCLUDEFOUND
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.MAXLOGS
-							| OCXMLImporterScreen.FILENAME
-							| OCXMLImporterScreen.TYPE);
-			// setting defaults for input
-			// doing the input
+		} else if (menu == 1) {
+			// menu = 1 input values for get Caches along a route
+			options = new OCXMLImporterScreen(MyLocale.getMsg(137, "Download along a Route from geocaching.com"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TRAVELBUGS
+					| OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.FILENAME | OCXMLImporterScreen.TYPE);
+			// setting defaults for input doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
 				return false;
 			}
@@ -768,22 +710,18 @@
 			maxUpdate = 0;
 			fileName = options.fileName;
 		} else { // if (menu == 2) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(138,
-					"Qick Import"), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(138, "Qick Import"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TYPE);
 			// setting defaults for input doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
 				return false;
 			}
 			doNotgetFound = options.foundCheckBox.getState();
 		}
-
+		pref.doNotGetFound = doNotgetFound;
 		if (menu == 0) {
 
 			int maxNew = -1;
-			String maxNumberString = options.maxNumberInput.getText();
+			final String maxNumberString = options.maxNumberInput.getText();
 			if (maxNumberString.length() != 0) {
 				maxNew = Common.parseInt(maxNumberString);
 			}
@@ -796,7 +734,7 @@
 			}
 
 			maxUpdate = -1;
-			String maxUpdateString = options.maxNumberUpdates.getText();
+			final String maxUpdateString = options.maxNumberUpdates.getText();
 			if (maxUpdateString.length() != 0) {
 				maxUpdate = Common.parseInt(maxUpdateString);
 			}
@@ -807,10 +745,14 @@
 		// options for all
 
 		if (options.maxDistanceInput != null) {
-			String maxDist = options.maxDistanceInput.getText();
+			final String maxDist = options.maxDistanceInput.getText();
 			maxDistance = Common.parseDouble(maxDist);
-			if (maxDistance == 0) return false;
-			if (maxDistance < 0.5) maxDistance = 0.5; // zur Sicherheit bei "along the route" mindenstens 500 meter Umkreis
+			if (maxDistance == 0)
+				return false;
+			// zur Sicherheit bei "along the route"
+			// mindenstens 500 meter Umkreis
+			if (maxDistance < 0.5)
+				maxDistance = 0.5;
 			profile.setDistGC(Double.toString(maxDistance));
 		}
 
@@ -824,13 +766,9 @@
 
 	}
 
-	private Hashtable fillDownloadLists(int maxNew, int maxUpdate,
-			double toDistance, double fromDistance, String[] directions,
-			Hashtable cExpectedForUpdate) {
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return null;
-		}
+	private Hashtable fillDownloadLists(int maxNew, int maxUpdate, double toDistance, double fromDistance, String[] directions, Hashtable cExpectedForUpdate) {
+		if (!login())
+			return null;
 
 		int numFinds;
 		int startPage = 1;
@@ -839,27 +777,25 @@
 			// distance in miles for URL
 			int fromDistanceInMiles = (int) java.lang.Math.ceil(fromDistance);
 			if (pref.metricSystem != Metrics.IMPERIAL) {
-				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics
-						.convertUnit(fromDistance, Metrics.KILOMETER,
-								Metrics.MILES));
+				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(fromDistance, Metrics.KILOMETER, Metrics.MILES));
 			}
 			// - a mile to be save to get a page with fromDistance
 			getFirstListPage(java.lang.Math.max(fromDistanceInMiles - 1, 1));
-			numFinds = getNumFound(htmlListPage); // Number of caches from gc Listpage
-			// calc the number of the startpage
+			// Number of caches from gc Listpage calc the number of the startpage
+			numFinds = getNumFound(htmlListPage);
 			startPage = (int) java.lang.Math.ceil(numFinds / 20);
 		}
 
 		// max distance in miles for URL, so we can get more than 80km
 		int toDistanceInMiles = (int) java.lang.Math.ceil(toDistance);
 		if (pref.metricSystem != Metrics.IMPERIAL) {
-			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(
-					toDistance, Metrics.KILOMETER, Metrics.MILES));
+			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(toDistance, Metrics.KILOMETER, Metrics.MILES));
 		}
 		// add a mile to be save from different distance calculations in CW and at GC
 		toDistanceInMiles++;
 		getFirstListPage(toDistanceInMiles);
-		numFinds = getNumFound(htmlListPage); // Number of caches from gc first Listpage
+		// Number of caches from gcfirst Listpage
+		numFinds = getNumFound(htmlListPage);
 
 		if (fromDistance > 0) {
 			// skip (most of) the pages with distance < fromDistance
@@ -873,9 +809,7 @@
 		int numFoundInDB = 0; // Number of GC-founds already in this profile
 		if (spiderAllFinds) {
 			numFoundInDB = getFoundInDB();
-			pref.log((spiderAllFinds ? "all Finds (DB/GC)" + numFoundInDB + "/"
-					+ numFinds : "new and update Caches")
-					+ Preferences.NEWLINE, null);
+			pref.log((spiderAllFinds ? "all Finds (DB/GC)" + numFoundInDB + "/" + numFinds : "new and update Caches") + Preferences.NEWLINE, null);
 			maxNew = java.lang.Math.min(numFinds - numFoundInDB, maxNew);
 			if (maxUpdate == 0 && maxNew == 0) {
 				Vm.showWait(false);
@@ -887,36 +821,28 @@
 		if (maxUpdate > 0) {
 			double distanceInKm = toDistance;
 			if (pref.metricSystem == Metrics.IMPERIAL) {
-				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES,
-						Metrics.KILOMETER);
+				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES, Metrics.KILOMETER);
 			}
 			// expecting all are changed (archived caches remain always)
 			for (int i = 0; i < cacheDB.size(); i++) {
-				CacheHolder ch = cacheDB.get(i);
+				final CacheHolder ch = cacheDB.get(i);
 				if (spiderAllFinds) {
-					if ((ch.getWayPoint().substring(0, 2)
-							.equalsIgnoreCase("GC"))
-							&& !ch.is_black()) {
+					if ((ch.getWayPoint().substring(0, 2).equalsIgnoreCase("GC")) && !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				} else {
-					if ((!ch.is_archived())
-							&& (ch.kilom <= distanceInKm)
-							&& !(doNotgetFound && (ch.is_found() || ch
-									.is_owned()))
-							&& (ch.getWayPoint().substring(0, 2)
-									.equalsIgnoreCase("GC"))
-							&& ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch
-									.getType() == restrictedCacheType))
-							&& !ch.is_black()) {
+					if ((!ch.is_archived()) && (ch.kilom <= distanceInKm) && !(doNotgetFound && (ch.is_found() || ch.is_owned())) && (ch.getWayPoint().substring(0, 2).equalsIgnoreCase("GC"))
+							&& ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch.getType() == restrictedCacheType)) && !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				}
 			}
 		}
-		int startSize = cExpectedForUpdate.size(); // for save reasons
+		// for save reasons
+		final int startSize = cExpectedForUpdate.size();
 
-		Hashtable cFoundForUpdate = new Hashtable(cacheDB.size()); // for don't loose the already done work
+		// for don't loose the already done work
+		final Hashtable cFoundForUpdate = new Hashtable(cacheDB.size());
 		page_number = 1;
 		int found_on_page = 0;
 		try {
@@ -927,41 +853,41 @@
 				if (RexPropListBlock.didMatch()) {
 					tableOfHtmlListPage = RexPropListBlock.stringMatched(1);
 				} else {
-					pref.log("check listBlockRex in spider.def" + Preferences.NEWLINE + htmlListPage);
+					pref.log("[SpiderGC.java:fillDownloadLists]check listBlockRex!");
 					tableOfHtmlListPage = "";
 				}
 				RexPropLine.search(tableOfHtmlListPage);
 				while (toDistance > 0) {
 					if (!RexPropLine.didMatch()) {
 						if (page_number == 1 && found_on_page == 0)
-							pref.log("check lineRex in spider.def");
+							pref.log("[SpiderGC.java:fillDownloadLists]check lineRex!");
 						break;
 					}
 					found_on_page++;
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay("working "
-								+ page_number + " / " + found_on_page);
-					String CacheDescriptionGC = RexPropLine.stringMatched(1);
-					double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
+						Global.mainTab.statBar.updateDisplay("working " + page_number + " / " + found_on_page);
+					final String CacheDescriptionGC = RexPropLine.stringMatched(1);
+					final double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
 					String chWaypoint = getWP(CacheDescriptionGC);
 					if (DistanceAndDirection[0] <= toDistance) {
-						CacheHolder ch = cacheDB.get(chWaypoint);
+						final CacheHolder ch = cacheDB.get(chWaypoint);
 						if (ch == null) { // not in DB
-							if (DistanceAndDirection[0] >= fromDistance
-									&& directionOK(directions, DistanceAndDirection[1])
-									&& doPMCache(chWaypoint, CacheDescriptionGC)
-									&& cachesToLoad.size() < maxNew) {
-								if (CacheDescriptionGC.indexOf(propFound) != -1) chWaypoint = chWaypoint + "found";
-								if (!cachesToLoad.contains(chWaypoint)) { cachesToLoad.add(chWaypoint);	}
+							if (DistanceAndDirection[0] >= fromDistance && directionOK(directions, DistanceAndDirection[1]) && doPMCache(chWaypoint, CacheDescriptionGC) && cachesToLoad.size() < maxNew) {
+								if (CacheDescriptionGC.indexOf(propFound) != -1)
+									chWaypoint = chWaypoint + "found";
+								if (!cachesToLoad.contains(chWaypoint)) {
+									cachesToLoad.add(chWaypoint);
+								}
 							} else {
-								// pref.log("no load of (Premium Cache/other direction/short Distance ?) " + chWaypoint);
+								// pref.log("no load of (Premium Cache/other direction/short
+								// Distance ?) " + chWaypoint);
 								cExpectedForUpdate.remove(chWaypoint);
 							}
 						} else {
-							if (maxUpdate > 0) { // regardless of fromDistance
+							if (maxUpdate > 0) {
+								// regardless of fromDistance
 								if (!ch.is_black()) {
-									if (doPMCache(chWaypoint, CacheDescriptionGC)
-										&& updateExists(ch, CacheDescriptionGC)) {
+									if (doPMCache(chWaypoint, CacheDescriptionGC) && updateExists(ch, CacheDescriptionGC)) {
 										if (cFoundForUpdate.size() < maxUpdate) {
 											cFoundForUpdate.put(chWaypoint, ch);
 										} else
@@ -977,25 +903,21 @@
 								toDistance = 0;
 								cExpectedForUpdate.clear();
 							} else {
-								if (cExpectedForUpdate.size() <= cFoundForUpdate
-										.size()) {
+								if (cExpectedForUpdate.size() <= cFoundForUpdate.size()) {
 									toDistance = 0;
 								}
 							}
 						}
 					} else
-						toDistance = 0; // finish listing
-					// get next row of table (next Cache Description) of this htmlListPage
-					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine
-							.matchedTo());
+						// finish listing get next row of table (next Cache Description) of this htmlListPage
+						toDistance = 0;
+					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine.matchedTo());
 					if (infB.isClosed) {
 						toDistance = 0;
 						break;
 					}
 				} // next Cache
-				infB.setInfo(MyLocale.getMsg(5511, "Found ")
-						+ cachesToLoad.size() + " / " + cFoundForUpdate.size()
-						+ MyLocale.getMsg(5512, " caches"));
+				infB.setInfo(MyLocale.getMsg(5511, "Found ") + cachesToLoad.size() + " / " + cFoundForUpdate.size() + MyLocale.getMsg(5512, " caches"));
 				if (found_on_page < 20) {
 					if (spiderAllFinds) {
 						// check all pages ( seen a gc-account with found_on_page less 20 and not on end )
@@ -1012,53 +934,42 @@
 				}
 			} // loop pages
 		} // try
-		catch (Exception ex) {
+		catch (final Exception ex) {
 			pref.log("Download error : ", ex, true);
 			infB.close(0);
 			Vm.showWait(false);
 			cExpectedForUpdate.clear();
 		}
-		pref.log("Checked " + page_number + " pages"+Preferences.NEWLINE+
-				"with " + ((page_number-1)*20+found_on_page) + " caches"+Preferences.NEWLINE+
-				"Found " + cachesToLoad.size() + " new caches"+Preferences.NEWLINE+
-				"Found " + cExpectedForUpdate.size() + "/" + cFoundForUpdate.size() + " caches for update"+Preferences.NEWLINE+
-				"Found " + numAvailableUpdates + " caches with changed available status."+Preferences.NEWLINE+
-				"Found " + numLogUpdates + " caches with new found in log."+Preferences.NEWLINE+
-				"Found " + (cExpectedForUpdate.size()-numAvailableUpdates-numLogUpdates) + " caches possibly archived."+Preferences.NEWLINE+
-				"Found " + cFoundForUpdate.size() + "?=" + (numFoundUpdates+numArchivedUpdates+numAvailableUpdates+numArchivedUpdates) + " caches to update."+Preferences.NEWLINE+
-				"Found " + numPrivate + " Premium Caches (for non Premium Member.)",null);
-		if(spiderAllFinds){
-			pref.log("Found " + numFoundUpdates + " caches with no found in profile."+Preferences.NEWLINE+
-			"Found " + numArchivedUpdates + " caches with changed archived status."+Preferences.NEWLINE,null);
+		pref.log("Checked " + page_number + " pages" + Preferences.NEWLINE + "with " + ((page_number - 1) * 20 + found_on_page) + " caches" + Preferences.NEWLINE + "Found " + cachesToLoad.size() + " new caches" + Preferences.NEWLINE + "Found "
+				+ cExpectedForUpdate.size() + "/" + cFoundForUpdate.size() + " caches for update" + Preferences.NEWLINE + "Found " + numAvailableUpdates + " caches with changed available status." + Preferences.NEWLINE + "Found " + numLogUpdates
+				+ " caches with new found in log." + Preferences.NEWLINE + "Found " + (cExpectedForUpdate.size() - numAvailableUpdates - numLogUpdates) + " caches possibly archived." + Preferences.NEWLINE + "Found " + cFoundForUpdate.size() + " ?= "
+				+ (numFoundUpdates + numArchivedUpdates + numAvailableUpdates + numArchivedUpdates) + " caches to update." + Preferences.NEWLINE + "Found " + numPrivate + " Premium Caches (for non Premium Member.)", null);
+		if (spiderAllFinds) {
+			pref.log("Found " + numFoundUpdates + " caches with no found in profile." + Preferences.NEWLINE + "Found " + numArchivedUpdates + " caches with changed archived status." + Preferences.NEWLINE, null);
 		}
 
 		if (cExpectedForUpdate.size() == startSize)
 			cExpectedForUpdate.clear(); // there must be something wrong
-		if (cExpectedForUpdate.size() == 0
-				|| cExpectedForUpdate.size() > maxUpdate)
+		if (cExpectedForUpdate.size() == 0 || cExpectedForUpdate.size() > maxUpdate)
 			cExpectedForUpdate = cFoundForUpdate;
 		return cExpectedForUpdate;
 
 	}
 
-	private int downloadCaches(Vector cachesToLoad, int spiderErrors,
-			int totalCachesToLoad, boolean loadAllLogs) {
+	private int downloadCaches(Vector cachesToLoad, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		for (int i = 0; i < cachesToLoad.size(); i++) {
 			if (infB.isClosed)
 				break;
 			String wpt = (String) cachesToLoad.get(i);
-			boolean is_found = wpt.indexOf("found") != -1;
+			final boolean is_found = wpt.indexOf("found") != -1;
 			if (is_found)
 				wpt = wpt.substring(0, wpt.indexOf("found"));
 			// Get only caches not already available in the DB
 			if (cacheDB.getIndex(wpt) == -1) {
-				infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + wpt + " ("
-						+ (i + 1) + " / " + totalCachesToLoad + ")");
-				CacheHolder holder = new CacheHolder();
+				infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + wpt + " (" + (i + 1) + " / " + totalCachesToLoad + ")");
+				final CacheHolder holder = new CacheHolder();
 				holder.setWayPoint(wpt);
-				int test = getCacheByWaypointName(holder, false,
-						pref.downloadPics, pref.downloadTBs, doNotgetFound,
-						loadAllLogs || is_found |!doNotgetFound);
+				final int test = getCacheByWaypointName(holder, false, pref.downloadPics, pref.downloadTBs, doNotgetFound, loadAllLogs || is_found | !doNotgetFound);
 				if (test == SPIDER_CANCEL) {
 					infB.close(0);
 					break;
@@ -1067,8 +978,7 @@
 				} else if (test == SPIDER_OK) {
 					cacheDB.add(holder);
 					holder.save();
-				} // For test == SPIDER_IGNORE_PREMIUM and SPIDER_IGNORE there
-					// is nothing to do
+				} // For test == SPIDER_IGNORE_PREMIUM and SPIDER_IGNORE there is nothing to do
 			}
 		}
 		return spiderErrors;
@@ -1076,18 +986,15 @@
 
 	private int updateCaches(Hashtable cachesToUpdate, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		int j = 1;
-		for (Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
+		for (final Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
 			if (infB.isClosed)
 				break;
-			CacheHolder ch = (CacheHolder) e.nextElement();
-			infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + ch.getWayPoint()
-					+ " (" + (cachesToLoad.size() + j) + " / "
-					+ totalCachesToLoad + ")");
-			int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
+			final CacheHolder ch = (CacheHolder) e.nextElement();
+			infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + ch.getWayPoint() + " (" + (cachesToLoad.size() + j) + " / " + totalCachesToLoad + ")");
+			final int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
 			if (test == SPIDER_CANCEL) {
 				break;
-			} 
-			else {
+			} else {
 				if (test == SPIDER_ERROR) {
 					spiderErrors++;
 					pref.log("[updateCaches] could not spider " + ch.getWayPoint(), null);
@@ -1100,60 +1007,47 @@
 	}
 
 	/**
-	 * Method to spider a single cache. It assumes a login has already been
-	 * performed!
+	 * Method to spider a single cache. It assumes a login has already been performed!
 	 * 
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing
-	 *         the infobox, 0 error, but continue with next cache
+	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with
+	 *         next cache
 	 */
-	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin,
-			boolean loadAllLogs) {
+	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin, boolean loadAllLogs) {
 		int ret = -1;
 		this.infB = pInfB;
-		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
+		final CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
 		ch.setWayPoint(cacheDB.get(number).getWayPoint());
 		if (ch.isAddiWpt())
-			return -1; // No point re-spidering an addi waypoint, comes with
-						// parent
+			return -1; // No point re-spidering an addi waypoint, comes with parent
 
-		// check if we need to login
-		if (!loggedIn || forceLogin) {
-			if (this.login() != FormBase.IDOK)
-				return -1;
-			// loggedIn is already set by this.login()
-		}
+		if (!login())
+			return -1;
 		try {
 			// Read the cache data from GC.COM and compare to old data
-			ret = getCacheByWaypointName(ch, true, pref.downloadPics,
-					pref.downloadTBs, false, loadAllLogs);
+			ret = getCacheByWaypointName(ch, true, pref.downloadPics, pref.downloadTBs, false, loadAllLogs);
 			// Save the spidered data
 			if (ret == SPIDER_OK) {
-				CacheHolder cacheInDB = cacheDB.get(number);
+				final CacheHolder cacheInDB = cacheDB.get(number);
 				cacheInDB.initStates(false);
 				if (cacheInDB.is_found() && !ch.is_found() && !loadAllLogs) {
-					// If the number of logs to spider is 5 or less, then the
-					// "not found" information
-					// of the spidered cache is not credible. In this case it
-					// should not overwrite
-					// the "found" state of an existing cache.
+					// If the number of logs to spider is 5 or less,
+					// then the "not found" information of the spidered cache is not credible.
+					// In this case it should not overwrite the "found" state of an existing cache.
 					ch.setFound(true);
 				}
 				// preserve rating information
 				ch.setNumRecommended(cacheInDB.getNumRecommended());
 				if (pref.downloadPics) {
 					// delete obsolete images when we have current set
-					CacheImages.cleanupOldImages(cacheInDB
-							.getCacheDetails(true).images, ch
-							.getCacheDetails(false).images);
+					CacheImages.cleanupOldImages(cacheInDB.getCacheDetails(true).images, ch.getCacheDetails(false).images);
 				} else {
 					// preserve images if not downloaded
-					ch.getCacheDetails(false).images = cacheInDB
-							.getCacheDetails(true).images;
+					ch.getCacheDetails(false).images = cacheInDB.getCacheDetails(true).images;
 				}
 				cacheInDB.update(ch);
 				cacheInDB.save();
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[spiderSingle] Error spidering " + ch.getWayPoint() + " in spiderSingle", ex);
 		}
 		return ret;
@@ -1168,21 +1062,18 @@
 	 */
 	public String getCacheCoordinates(String wayPoint) {
 		String completeWebPage;
-		// Check whether spider definitions could be loaded, if not issue
-		// appropriate message and terminate
+		// Check whether spider definitions could be loaded,
+		// if not issue appropriate message and terminate
 		// Try to login. If login fails, issue appropriate message and terminate
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK) {
-				return "";
-			}
-		}
-		InfoBox localInfB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
+		if (!login())
+			return "";
+		final InfoBox localInfB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
 		localInfB.exec();
 		try {
-			String doc = p.getProp("waypoint") + wayPoint;
-			completeWebPage = fetchText(doc, false);
+			final String doc = p.getProp("waypoint") + wayPoint;
+			completeWebPage = UrlFetcher.fetch(doc);
 			pref.log("Fetched " + wayPoint);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
 			pref.log("[getCacheCoordinates] Could not fetch " + wayPoint, ex);
 			return "";
@@ -1190,31 +1081,47 @@
 		localInfB.close(0);
 		try {
 			return getLatLon(completeWebPage);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			return "????";
 		}
 	} // getCacheCoordinates
 
 	/**
-	 * Method to login the user to gc.com It will request a password and use the
-	 * alias defined in preferences If the login page cannot be fetched, the
-	 * password is cleared. If the login fails, an appropriate message is
-	 * displayed.
+	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the
+	 * login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
 	 */
-	private int login() {
-		String passwort = pref.password;
+	private boolean login() {
+		if (loggedIn && !pref.forceLogin) {
+			return true;
+		}
+		if (pref.userID.length() > 0) {
+			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
+			loggedIn = switchToEnglish();
+			if (loggedIn)
+				return true;
+			else {
+				(new MessageBox("Login", "Check UserID in preferences | Einstellungen.\nsee http://cachewolf.aldos.de/userid.html", FormBase.OKB)).execute();
+				return false;
+			}
+		} else {
+			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
+			if (true) {
+				(new MessageBox("Login", "Check UserID in preferences| Einstellungen.\nsee http://cachewolf.aldos.de/userid.html", FormBase.OKB)).execute();
+				return false; // until SSL/https works
+			}
+		}
 		loggedIn = false;
-		String loginPage, loginPageUrl, loginSuccess, nextPage;
+		String loginPage, loginPageUrl, loginSuccess;
 		try {
 			loginPageUrl = p.getProp("loginPage");
 			loginSuccess = p.getProp("loginSuccess");
-			nextPage = p.getProp("nextPage");
-		} catch (Exception ex) { // Tag not found in spider.def
-			return ERR_LOGIN;
+		} catch (final Exception ex) { // Tag not found in spider.def
+			return false;
 		}
-		// Get password
-		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, "Password"),
-				MyLocale.getMsg(5505, "Enter Password"), InfoBox.INPUT);
+
+		// **0 Get password
+		String passwort = pref.password;
+		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, "Password"), MyLocale.getMsg(5505, "Enter Password"), InfoBox.INPUT);
 		localInfB.feedback.setText(passwort);
 		localInfB.feedback.isPassword = true;
 		int code = FormBase.IDOK;
@@ -1224,174 +1131,215 @@
 		}
 		localInfB.close(0);
 		if (code != FormBase.IDOK)
-			return code;
-		// Now start the login proper
+			return false;
+
+		// **1 now we have user and password for login
 		localInfB = new InfoBox(MyLocale.getMsg(5507, "Status"), MyLocale.getMsg(5508, "Logging in..."));
 		localInfB.exec();
 		try {
-			// Access the page once to get a viewstate
-			loginPage = fetchText(loginPageUrl, false); // http://www.geocaching.com/login/Default.aspx
-			pref.log("[login]:Fetched login page " + loginPageUrl);
+			loginPage = UrlFetcher.fetch(loginPageUrl); // http://www.geocaching.com/login/default.aspx
 			if (loginPage.equals("")) {
 				localInfB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(5499,"Error loading login page.%0aPlease check your internet connection."),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 				pref.log("[login]:Could not fetch: gc.com login page " + loginPageUrl, null);
-				return ERR_LOGIN;
+				return false;
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, "Error"),
-					MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 			pref.log("[login]:Could not fetch: gc.com login page", ex);
-			return ERR_LOGIN;
+			return false;
 		}
-		if (!localInfB.isClosed) { // If user has not aborted, we continue
-			Regex rexCookieID = new Regex("(?i)Set-Cookie: userid=(.*?);.*");
-			Regex rexViewstate = new Regex(
-					"id=\"__VIEWSTATE\" value=\"(.*?)\" />");
-			// Regex rexViewstate1 = new
-			// Regex("id=\"__VIEWSTATE1\" value=\"(.*?)\" />");
-			// Regex rexEventvalidation = new
-			// Regex("id=\"__EVENTVALIDATION\" value=\"(.*?)\" />");
-			Regex rexCookieSession = new Regex(
-					"(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*");
-			String viewstate = "";
-			rexViewstate.search(loginPage);
-			if (rexViewstate.didMatch()) {
-				viewstate = rexViewstate.stringMatched(1);
-			} else {
-				pref.log("[login]:rexViewstate not found before login", null);
-			}
 
-			if (loginPage.indexOf(loginSuccess) > 0)
-				pref.log("[login]:Already logged in" + pref.myAlias);
-			else {
-				/*
-				 * rexEventvalidation.search(loginPage);
-				 * if(rexEventvalidation.didMatch()){ // eventvalidation =
-				 * rexEventvalidation.stringMatched(1); } else
-				 * pref.log("[login]:rexEventvalidation not found before login"
-				 * ,null); //Ok now login!
-				 */
+		// **2 now we can check the loginpage if logged in else log in
+		if (!localInfB.isClosed) {
+			if (loginPage.indexOf(loginSuccess) > 0) {
+				if (loginPage.indexOf(pref.myAlias) > 0) {
+					loggedIn = true;
+					// assume language is already set to EN
+					pref.log("[login]:Already logged in as " + pref.myAlias);
+				} else {
+					// it is another user, whom we should logout
+					try {
+						loginPage = UrlFetcher.fetch("http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y");
+					} catch (final Exception ex) {
+						localInfB.close(0);
+						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
+						pref.log("[login]:Could not fetch: gc.com login page", ex);
+						return false;
+					}
+
+				}
+			}
+			if (!loggedIn) {
 				try {
-					StringBuffer sb = new StringBuffer(1000);
-					sb.append(URL.encodeURL("__VIEWSTATE", false));
-					sb.append("=");
-					sb.append(URL.encodeURL(viewstate, false));
+					final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
+					String viewstate = "";
+					rexViewstate.search(loginPage);
+					if (rexViewstate.didMatch()) {
+						viewstate = rexViewstate.stringMatched(1);
+					} else {
+						localInfB.close(0);
+						pref.log("[login]:__VIEWSTATE not found (before login): no login possible.", null);
+						// we need the __VIEWSTATE for sending loginData, so we should abort here
+						return false;
+					}
+					final StringBuffer sb = new StringBuffer(1000);
+					sb.append("__VIEWSTATE=" + URL.encodeURL(viewstate, false));
 					sb.append("&ctl00%24ContentBody%24");
-					sb.append(URL.encodeURL("myUsername", false));
-					sb.append("=");
-					sb.append(encodeUTF8URL(Utils
-							.encodeJavaUtf8String(pref.myAlias)));
+					sb.append("myUsername=" + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
 					sb.append("&ctl00%24ContentBody%24");
-					sb.append(URL.encodeURL("myPassword", false));
-					sb.append("=");
-					sb.append(encodeUTF8URL(Utils
-							.encodeJavaUtf8String(passwort)));
+					sb.append("myPassword=" + encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
 					sb.append("&ctl00%24ContentBody%24");
-					sb.append(URL.encodeURL("cookie", false));
-					sb.append("=");
-					sb.append(URL.encodeURL("on", false));
+					sb.append("cookie=on");
 					sb.append("&ctl00%24ContentBody%24");
-					sb.append(URL.encodeURL("Button1", false));
-					sb.append("=");
-					sb.append(URL.encodeURL("Login", false));
-					// sb.append("&");
-					// sb.append(URL.encodeURL("__EVENTVALIDATION",false));
-					// sb.append("=");
-					// sb.append(URL.encodeURL(eventvalidation,false));
-					loginPage = fetch_post(loginPageUrl, sb.toString(), true);
-					if (loginPage.indexOf(loginSuccess) > 0)
+					sb.append("Button1=Login");
+					UrlFetcher.setpostData(sb.toString());
+					loginPage = UrlFetcher.fetch(loginPageUrl);
+					if (loginPage.indexOf(loginSuccess) > 0) {
 						pref.log("Login successful: " + pref.myAlias);
-					else {
+						// **3 now we are logged in and get the Cookie (there are two)
+						final PropertyList pl = UrlFetcher.getDocumentProperties();
+						String docprops = "";
+						for (int i = 0; i < pl.size(); i++) {
+							final Property p = (Property) pl.get(i);
+							if (p.name.equalsIgnoreCase("Set-Cookie")) {
+								docprops += p.value;
+							}
+						}
+						final Regex rexCookieSession = new Regex("(?i)ASP.NET_SessionId=(.*?);.*");
+						rexCookieSession.search(docprops);
+						if (rexCookieSession.didMatch()) {
+							cookie = "ASP.NET_SessionId=" + rexCookieSession.stringMatched(1);
+						} else {
+							localInfB.close(0);
+							pref.log("[login]:SessionID not found.", null);
+							return false;
+						}
+						final Regex rexCookieID = new Regex("(?i)userid=(.*?);.*");
+						rexCookieID.search(docprops);
+						if (rexCookieID.didMatch()) {
+							cookie += "; userid=" + rexCookieID.stringMatched(1);
+						} else {
+							localInfB.close(0);
+							pref.log("[login]:userID not found.", null);
+							return false;
+						}
+						UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
+					} else {
 						pref.log("Login failed. Wrong Account or Password? " + pref.myAlias, null);
-						pref.log("[login.LoginUrl]:" + sb.toString(), null);
+						pref.log("[login.url]:" + loginPageUrl, null);
+						pref.log("[login.postData]:" + sb.toString(), null);
 						pref.log("[login.Answer]:" + loginPage, null);
 						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, "Error"),
-								MyLocale.getMsg(5501,"Login failed! Wrong account or password?"),
-								FormBase.OKB)).execute();
-						return ERR_LOGIN;
+						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed! Wrong account or password?"), FormBase.OKB)).execute();
+						return false;
 					}
-				} catch (Exception ex) {
+					if (!this.switchToEnglish())
+						return false;
+				} catch (final Exception ex) {
 					pref.log("[login]:Login failed with exception.", ex);
 					localInfB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500, "Error"),
-							MyLocale.getMsg(5501,"Login failed. Error loading page after login."),
-							FormBase.OKB)).execute();
-					return ERR_LOGIN;
+					(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed. Error loading page after login."), FormBase.OKB)).execute();
+					return false;
 				}
 			}
-
-			rexViewstate.search(loginPage);
-			if (!rexViewstate.didMatch()) {
-				pref.log("[login]:check rexViewstate in SpiderGC.java --> not found after login"
-						+ Preferences.NEWLINE + loginPage, null);
-			}
-			viewstate = rexViewstate.stringMatched(1);
-
-			rexCookieID.search(loginPage);
-			if (!rexCookieID.didMatch()) {
-				pref.log("[login]:check rexCookieID in SpiderGC.java --> CookieID not found. Using old one.", null);
-			} else
-				cookieID = rexCookieID.stringMatched(1);
-			rexCookieSession.search(loginPage);
-			if (!rexCookieSession.didMatch()) {
-				pref.log("[login]:check rexCookieSession in SpiderGC.java --> CookieSession not found. Using old one."
-						+ Preferences.NEWLINE + loginPage);
-			} else
-				cookieSession = rexCookieSession.stringMatched(1);
-
-			/*
-			 * String viewstate1; rexViewstate1.search(loginPage);
-			 * if(rexViewstate1.didMatch()){ viewstate1 =
-			 * rexViewstate1.stringMatched(1); } else { viewstate1 = "";
-			 * pref.log(
-			 * "[login]:check rexViewstate1 in SpiderGC.java --> not found after login"
-			 * +Preferences.NEWLINE+loginPage); }
-			 */
-
-			/*
-			 * rexEventvalidation.search(htmlPage);
-			 * if(rexEventvalidation.didMatch()){ eventvalidation =
-			 * rexEventvalidation.stringMatched(1); } else { eventvalidation =
-			 * ""; }
-			 */
-
-			String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem";
-			String postStr = URL.encodeURL("__EVENTTARGET", false) + "="
-					+ URL.encodeURL(strEnglishPage, false) + "&"
-					+ URL.encodeURL("__EVENTARGUMENT", false) + "="
-					+ URL.encodeURL("", false)
-					// + "&" + URL.encodeURL("__VIEWSTATEFIELDCOUNT",false)
-					// +"=2"
-					+ "&" + URL.encodeURL("__VIEWSTATE", false) + "="
-					+ URL.encodeURL(viewstate, false);
-			// + "&" + URL.encodeURL("__VIEWSTATE1",false) +"="+
-			// URL.encodeURL(viewstate1,false);
-			// + "&" + URL.encodeURL("__EVENTVALIDATION",false) +"="+
-			// URL.encodeURL(eventvalidation,false);
-			try {
-				loginPage = fetch_post(loginPageUrl, postStr, true);
-				pref.log("Switched to English");
-			} catch (Exception ex) {
-				pref.log("Error switching to English: check/n" + loginPageUrl
-						+ "/n" + postStr + "/n" + nextPage + "/n", ex);
-			}
 		}
-		boolean loginAborted = localInfB.isClosed;
+
+		final boolean loginAborted = localInfB.isClosed;
 		localInfB.close(0);
 		if (loginAborted)
-			return FormBase.IDCANCEL;
+			return false;
 		else {
 			loggedIn = true;
-			return FormBase.IDOK;
+			return true;
 		}
 	}
 
+	private boolean switchToEnglish() {
+		// change language to EN , further operations relay on English
+		String url = "http://www.geocaching.com/account/ManagePreferences.aspx";
+		String page = "";
+		String userID = "userid=" + pref.userID;
+		try {
+			UrlFetcher.setPermanentRequestorProperty("Cookie", userID);
+			page = UrlFetcher.fetch(url); // getting the sessionid
+			if (page.length() == 0)
+				return false;
+		} catch (final Exception ex) {
+			return false;
+		}
+		PropertyList pl = UrlFetcher.getDocumentProperties();
+		String docprops = "";
+		for (int i = 0; i < pl.size(); i++) {
+			final Property p = (Property) pl.get(i);
+			if (p.name.equalsIgnoreCase("Set-Cookie")) {
+				docprops += p.value;
+			}
+		}
+		final Regex rexCookieSession = new Regex("(?i)ASP.NET_SessionId=(.*?);.*");
+		rexCookieSession.search(docprops);
+		if (rexCookieSession.didMatch()) {
+			cookie = "ASP.NET_SessionId=" + rexCookieSession.stringMatched(1) + "; " + userID;
+			UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
+		} else {
+			pref.log("[switchToEnglish]:SessionID not found.", null);
+			return false;
+		}
+		try {
+			page = UrlFetcher.fetch(url);
+			if (page.length() == 0)
+				return false;
+		} catch (IOException e) {
+			return false;
+		}
+		Extractor ext = new Extractor(page, "ctl00$ContentBody$uxLanguagePreference", "</select>", 0, true);
+		String languageBlock = ext.findNext();
+		ext.set(ext.findNext("ctl00$ContentBody$uxDateTimeFormat"), "selected\" value=\"", "\">", 0, true);
+		DateFormat.GCDateFormat = ext.findNext();
+		// <option selected="selected" value="de-DE">Deutsch</option>
+		ext.set(languageBlock, "<option selected=", "/option>", 0, true);
+		ext.set(ext.findNext(), ">", "<", 0, true);
+		String oldLanguage = ext.findNext();
+		if (oldLanguage.equals("English")) {
+			pref.log("already English");
+			pref.oldLanguageCtl = ""; // nothing to reset
+			return true;
+		}
+		// switch to english now goes into gc account Display Preferences
+		// (is permanent, must be reset)
+		// todo as long as Textfile Encoding is CP1252 we compare with
+		// substring(1) and think koreanisch if no merge at all
+		String languages[] = { "English", "Deutsch", "Fran?ais", "Portugu?s", "Ce?tina", "Svenska", "Nederlands", "Catal?", "Polski", "Eesti", "Norsk, Bokm?l", "???", "Espa?ol" };
+		for (int i = 0; i < languages.length; i++) {
+			if (oldLanguage.substring(1).equals(languages[i].substring(1))) {
+				pref.oldLanguageCtl = url + "?__EVENTTARGET=" + UrlFetcher.encodeURL("ctl00$uxLocaleList$uxLocaleList$ctl" + MyLocale.formatLong(i, "00") + "$uxLocaleItem", false);
+				break;
+			}
+		}
+		if (pref.oldLanguageCtl.length() == 0) {
+			// koreanisch
+			pref.oldLanguageCtl = url + "?__EVENTTARGET=" + UrlFetcher.encodeURL("ctl00$uxLocaleList$uxLocaleList$ctl" + "11" + "$uxLocaleItem", false);
+		}
+		final String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem";
+		url += "?__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false);
+		try {
+			page = UrlFetcher.fetch(url);
+			ext.set(page, "<a href=\"#\">", "&#9660;", 0, true);
+			if (ext.findFirst(page).equals("English")) {
+				pref.log("Switched to English");
+				return true;
+			} else {
+				pref.log("couldn't switch to english", null);
+				return false;
+			}
+		} catch (final Exception ex) {
+			pref.log("[SpiderGC.java:switchToEnglish]Error switching to English: check " + url, ex);
+			return false;
+		}
+
+	}
+
 	/*
 	 *
 	 */
@@ -1430,7 +1378,7 @@
 			icon_camera = p.getProp("icon_camera");
 			icon_attended = p.getProp("icon_attended");
 			RexCacheType = new Regex(p.getProp("cacheTypeRex"));
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("Error fetching Properties.", ex);
 		}
 	}
@@ -1445,25 +1393,20 @@
 		if (spiderAllFinds) {
 			url = propFirstPageFinds + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias));
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
-		
+
 		try {
-			htmlListPage = fetchText(url, false);
+			htmlListPage = UrlFetcher.fetch(url);
 			pref.log("[getFirstListPage] Got first page " + url);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getFirstListPage] Error fetching first list page " + url, ex, true);
 			Vm.showWait(false);
 			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, "Error"), 
-					MyLocale.getMsg(5503, "Error fetching first list page."),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5503, "Error fetching first list page."), FormBase.OKB)).execute();
 			return;
 		}
 	}
@@ -1476,52 +1419,39 @@
 		if (spiderAllFinds) {
 			url = propFirstPage;
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
 
-		Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
+		final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
 		String viewstate;
 		rexViewstate.search(htmlListPage);
 		if (rexViewstate.didMatch()) {
 			viewstate = rexViewstate.stringMatched(1);
 		} else {
 			viewstate = "";
-			pref.log("[getAListPage] check rexViewstate in SpiderGC.java" + Preferences.NEWLINE + htmlListPage);
+			pref.log("[SpiderGC.java:getAListPage] check rexViewstate!", null);
 		}
 
-		Regex rexViewstate1 = new Regex("id=\"__VIEWSTATE1\" value=\"(.*?)\" />");
+		final Regex rexViewstate1 = new Regex("id=\"__VIEWSTATE1\" value=\"(.*?)\" />");
 		String viewstate1;
 		rexViewstate1.search(htmlListPage);
 		if (rexViewstate1.didMatch()) {
 			viewstate1 = rexViewstate1.stringMatched(1);
 		} else {
 			viewstate1 = "";
-			pref.log("[getAListPage] check rexViewstate1 in SpiderGC.java" + Preferences.NEWLINE + htmlListPage);
+			pref.log("[SpiderGC.java:getAListPage] check rexViewstate1!", null);
 		}
 
-		/*
-		 * rexEventvalidation.search(htmlPage);
-		 * if(rexEventvalidation.didMatch()){ 
-		 * eventvalidation = rexEventvalidation.stringMatched(1); } 
-		 * else { eventvalidation = ""; }
-		 */
-
-		String postData = "__EVENTTARGET=" + URL.encodeURL(whatPage, false) + "&" +
-						  "__EVENTARGUMENT=" + "&" +
-						  "__VIEWSTATEFIELDCOUNT=2" + "&" +
-						  "__VIEWSTATE=" + URL.encodeURL(viewstate, false) + "&" +
-						  "__VIEWSTATE1=" + URL.encodeURL(viewstate1, false); // + "&" +
-						  //"__EVENTVALIDATION=" + URL.encodeURL(eventvalidation,false);
+		final String postData = "__EVENTTARGET=" + URL.encodeURL(whatPage, false) + "&" + "__EVENTARGUMENT=" + "&" + "__VIEWSTATEFIELDCOUNT=2" + "&" + "__VIEWSTATE=" + URL.encodeURL(viewstate, false) + "&" + "__VIEWSTATE1="
+				+ URL.encodeURL(viewstate1, false);
 		try {
-			htmlListPage = fetch_post(url, postData, true);
-			pref.log("[getAListPage] Got list page: " + URL.encodeURL(whatPage, false));
-		} catch (Exception ex) {
+			UrlFetcher.setpostData(postData);
+			htmlListPage = UrlFetcher.fetch(url);
+			pref.log("[getAListPage] Got list page: " + url);
+		} catch (final Exception ex) {
 			pref.log("[getAListPage] Error getting a list page" + url, ex);
 		}
 	}
@@ -1529,79 +1459,292 @@
 	/* */
 	private String getMapListPage(CWPoint middle, double north, double west, double south, double east) {
 		String ret;
-		
-		String referer = "http://www.geocaching.com/map/default.aspx" + 
-		"?lat="	+ middle.getLatDeg(TransformCoordinates.DD) + 
-		"&lng="	+ middle.getLonDeg(TransformCoordinates.DD);
 
+		final String referer = "http://www.geocaching.com/map/default.aspx" + "?lat=" + middle.getLatDeg(TransformCoordinates.DD) + "&lng=" + middle.getLonDeg(TransformCoordinates.DD);
+
 		if (userToken.equals("")) {
-			ret = fetchText(referer, false);
+			try {
+				ret = UrlFetcher.fetch(referer);
+			} catch (final IOException e) {
+				ret = "";
+			}
 			int i = ret.indexOf("userToken = '");
-			i=i+13;
-			int j = ret.indexOf("'", i);
-			userToken = ret.substring(i,j);
+			i = i + 13;
+			final int j = ret.indexOf("'", i);
+			userToken = ret.substring(i, j);
 		}
-		
-		String url = "http://www.geocaching.com/map/default.aspx/MapAction";
 
-		String strLeft = MyLocale.formatDouble(west, "#0.00000").replace(',','.');
-		String strUp = MyLocale.formatDouble(north, "#0.00000").replace(',','.');
-		String strRight = MyLocale.formatDouble(east, "#0.00000").replace(',','.');
-		String strDown = MyLocale.formatDouble(south, "#0.00000").replace(',','.');
-		String param1 = "{\"dto\":{\"data\":{\"c\":1,\"m\":\"\",\"d\":\"";
-		String param2 = strUp + "|" + strDown + "|" + strRight + "|" + strLeft;
-		String param3 = "\"},\"ut\":\"";
-		String param4 = "\"}}";
-		String postData = param1+param2+param3+userToken+param4;
+		final String url = "http://www.geocaching.com/map/default.aspx/MapAction";
 
+		final String strLeft = MyLocale.formatDouble(west, "#0.00000").replace(',', '.');
+		final String strUp = MyLocale.formatDouble(north, "#0.00000").replace(',', '.');
+		final String strRight = MyLocale.formatDouble(east, "#0.00000").replace(',', '.');
+		final String strDown = MyLocale.formatDouble(south, "#0.00000").replace(',', '.');
+		final String param1 = "{\"dto\":{\"data\":{\"c\":1,\"m\":\"\",\"d\":\"";
+		final String param2 = strUp + "|" + strDown + "|" + strRight + "|" + strLeft;
+		final String param3 = "\"},\"ut\":\"";
+		final String param4 = "\"}}";
+		final String postData = param1 + param2 + param3 + userToken + param4;
+
 		try {
-		ret = post(url, postData, referer, false);
-		} catch (Exception ex) {
+			UrlFetcher.setpostData(postData);
+			UrlFetcher.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
 			ret = "";
 			pref.log("[SpiderGC:getMapListPage] Error getting map Cachepage" + url + postData, ex);
 		}
 		return ret;
- 	}
+	}
 
-	private static String post(String url, String postData, String referer, boolean withResponseHeaders) {
-		HttpConnection conn;
+	/* */
+	public void doItQuickFillFromMapList() {
+
+		final CWPoint origin = pref.getCurCentrePt();
+		if (!origin.isValid()) {
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
+			return; //
+		}
+		if (!doDownloadGui(2))
+			return;
+
+		Vm.showWait(true);
+		infB = new InfoBox("Status", MyLocale.getMsg(1609, "getting the caches."));
+		infB.exec();
+
+		// Reset states for all caches when spidering (http://tinyurl.com/dzjh7p)
+		for (int i = 0; i < cacheDB.size(); i++) {
+			final CacheHolder ch = cacheDB.get(i);
+			if (ch.mainCache == null)
+				ch.initStates(false);
+		}
+
+		// halbe Seitenl?nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance;
+		if (pref.metricSystem == Metrics.IMPERIAL) {
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
+		}
+		if (!login())
+			return;
+
+		page_number = 0;
+		num_added = 0;
+
+		final Area sq = getSquare(origin, halfSideLength);
+
+		getCachesNewMap(sq, false);
+
+		if (!infB.isClosed)
+			infB.close(0);
+		Vm.showWait(false);
+
+		Global.getProfile().restoreFilter();
+		Global.getProfile().saveIndex(Global.getPref(), true);
+
+	}
+
+	private void getCachesNewMap(Area square, boolean setCachesToLoad) {
+
+		if (userToken.equals("")) {
+			String url;
+			String ret;
+			try {
+				page_number++;
+				url = "http://www.geocaching.com/map/beta/default.aspx" + "?lat=" + square.topleft.getLatDeg(TransformCoordinates.DD) + "&lng=" + square.topleft.getLonDeg(TransformCoordinates.DD) + "&z=15";
+				ret = UrlFetcher.fetch(url);
+			} catch (final IOException e) {
+				ret = "";
+			}
+			int i = ret.indexOf("GSPK.UserSession('");
+			i = i + 18;
+			int j = ret.indexOf("'", i);
+			userToken = ret.substring(i, j);
+			i = ret.indexOf("sessionToken:'", i);
+			i = i + 14;
+			j = ret.indexOf("'", i);
+			sessionToken = ret.substring(i, j);
+		}
+		TrackPoint tl;
+		TrackPoint br;
+		int lonmin;
+		int lonmax;
+		int latmin;
+		int latmax;
+		int scale = 19;
+		do {
+			scale = scale - 1;
+			tl = getKachelLatLon(square.topleft, scale);
+			br = getKachelLatLon(square.bottomright, scale);
+			lonmin = (int) tl.lonDec;
+			lonmax = (int) br.lonDec;
+			latmin = (int) tl.latDec;
+			latmax = (int) br.latDec;
+		} while ((lonmax - lonmin > 1) && (latmax - latmin > 1) && (scale > 10));
+
+		String cachelist;
+
+		for (int i = lonmin; i <= lonmax; i++) {
+			for (int j = latmin; j <= latmax; j++) {
+				cachelist = getNewMapListPage("" + j, "" + i, scale);
+				if (cachelist.length() > 0) {
+					final String[] caches = mString.split(cachelist, '{');
+					final double baseX = Common.parseDouble(caches[1].substring(8, caches[1].indexOf(',')));
+					final double baseY = Common.parseDouble(caches[1].substring(caches[1].indexOf(',') + 1, caches[1].indexOf(']')));
+					for (int k = 2; k < caches.length; k++) {
+						final String[] cacheInfos = mString.split(STRreplace.replace(caches[k], "\\\"", ""), '\"');
+						final String cacheID = cacheInfos[3];
+						final String cacheXY = cacheInfos[10];
+						final String[] xy = mString.split(cacheXY, ',');
+						final int cacheX = Common.parseInt(xy[0].substring(2));
+						final int cacheY = Common.parseInt(xy[1].substring(0, xy[1].indexOf(']')));
+						final CWPoint p = getLatLon(baseX, baseY, cacheX, cacheY, scale);
+						if (square.isInBound(p)) {
+							String cachePage = getCacheInfoNewMap(cacheID);
+							addCacheNewMap(cachePage, p, setCachesToLoad);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	private TrackPoint getKachelLatLon(CWPoint p, int scale) {
+		double lat = p.latDec;
+		double lon = p.lonDec;
+		if (lon > 180.0) {
+			lon -= 360.0;
+		}
+		lat = 0.5 - Math.log(Math.tan((Math.PI / 4.0) + ((Math.PI * lat) / (2.0 * 180.0)))) / (2.0 * Math.PI);
+		lon = (180.0 + lon) / 360.0;
+
+		final int f = 1 << scale; // 2**scale
+		lat = lat * f;
+		lon = lon * f;
+		return new TrackPoint(lat, lon); // TrackPoint only for returning
+		// values
+	}
+
+	private CWPoint getLatLon(double basex, double basey, int offsetx, int offsety, int scale) {
+
+		double anzPixelX = basex + offsetx;
+		double anzPixelY = basey + offsety;
+
+		final CWPoint p = new CWPoint();
+
+		final double maxPixels = 1 << (scale + 8); // 2**scale*256
+		final double gpp = 360.0 / maxPixels; // Grad pro Pixel
+		final double leftLon = (anzPixelX * gpp); // Grad
+		p.lonDec = leftLon - 180.0; // 0 ist bei greenwich
+
+		final double lat = 1.0 / maxPixels;
+		final double latM = Math.PI * (1.0 + 2.0 * anzPixelY * lat);
+		p.latDec = (180.0 / Math.PI) * ((2.0 * Math.atan(Math.exp(latM))) - (Math.PI / 2.0));
+
+		return p;
+	}
+
+	private String getNewMapListPage(String strLat, String strLon, int scale) {
+		String ret;
+		String url = "";
+
 		try {
-			conn = new HttpConnection(url);
-			JavaUtf8Codec codec = new ewe.io.JavaUtf8Codec();
-			conn.documentIsEncoded = true;
-			conn.setRequestorProperty("User-Agent","Mozilla/5.0 (Windows; U; Windows NT 6.0; de; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12");
-			conn.setRequestorProperty("Accept","application/json, text/javascript, */*; q=0.01");
-			conn.setRequestorProperty("Accept-Language","de-de,de;q=0.8,en-us;q=0.5,en;q=0.3");
-			conn.setRequestorProperty("Accept-Encoding","gzip,deflate");
-			conn.setRequestorProperty("Accept-Charset","ISO-8859-1,utf-8;q=0.7,*;q=0.7");
-			conn.setRequestorProperty("Keep-Alive","115");
-			conn.setRequestorProperty("Proxy-Connection","keep-alive");
-			conn.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
-			conn.setRequestorProperty("X-Requested-With","XMLHttpRequest");
-			conn.setRequestorProperty("Referer",referer);
-			conn.setRequestorProperty("Pragma","no-cache");
-			conn.setRequestorProperty("Cache-Control","no-cache");
-			// if (cookieSession.length() > 0) { conn.setRequestorProperty("Cookie", "ASP.NET_SessionId=" + cookieSession + "; userid=" + cookieID); }
-			conn.setRequestorProperty("Connection", "close");
-			//conn.setPostData(codec.encodeText(postData.toCharArray(), 0, postData.length(), true, null));
-			conn.setPostData(postData);
-			Socket sock = conn.connect();
-			// CharArray c_data = conn.readText(sock, codec);
-			ByteArray daten = conn.readData(sock);
-			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			
-			sock.close();
-			
-			if (withResponseHeaders)
-				return getResponseHeaders(conn) + c_data.toString();
-			else
-				return c_data.toString();
-		} catch (Exception e) {
-			pref.log("[fetch_post] Ignored Exception", e, true);
+			page_number++;
+			url = "http://www.geocaching.com/map/beta/map.info?" + "x=" + strLon + "&y=" + strLat + "&z=" + scale + "&k=" + userToken + "&st=" + sessionToken + "&ep=1";
+			if (doNotgetFound) {
+				url = url + "&hf=1"; // do not get finds
+			}
+			url = url + "&hh=1"; // do not get own
+			UrlFetcher.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = "";
+			pref.log("[SpiderGC:getMapListPage] Error getting map Cachepage" + url + ex);
 		}
-		return "";
+		return ret;
 	}
 
+	private String getCacheInfoNewMap(String cacheID) {
+		String ret;
+		String url = "";
+
+		try {
+			page_number++;
+			url = "http://www.geocaching.com/map/beta/map.details?" + "wptid=" + cacheID + "&k=" + userToken + "&st=" + sessionToken + "&ep=1";
+			UrlFetcher.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = "";
+			pref.log("[SpiderGC:getCacheInfoNewMap] Error getting map Cachepage" + url + ex);
+		}
+		return ret;
+	}
+
+	private void addCacheNewMap(String page, CWPoint p, boolean setCachesToLoad) {
+
+		Extractor ext = new Extractor(page, "{\"name\":\"", "\",", 0, true);
+		String cacheName = ext.findNext(); // Text
+		String wp = ext.findNext("\"gc\":\""); // Text
+		String disabled = ext.findNext("\"disabled\":", ","); // true/false
+		String subrOnly = ext.findNext("\"subrOnly\":"); // true/false
+		ext.findNext("\"li\":"); // true/false (not used, what is that)
+		ext.findNext("\"fp\":"); // int (favorite points)
+		String difficulty = ext.findNext("\"text\":"); // double
+		String terrain = ext.findNext(); // double;
+		String hidden = ext.findNext("\"hidden\":\"", "\","); // string Datum
+		String container = ext.findNext("\"text\":\""); // Text (Micro,...)
+		ext.findNext("\"value\":", "}"); // int dont remove
+		String type = ext.findNext("\"value\":", "}"); // int
+		String owner = ext.findNext("text\":\"", "\","); // Text
+
+		final byte cacheType = CacheType.gcSpider2CwType(type);
+		if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
+			if (restrictedCacheType != cacheType)
+				return;
+		}
+		CacheHolder ch = cacheDB.get(wp);
+		if (ch == null) {
+			ch = new CacheHolder();
+			ch.setWayPoint(wp);
+			boolean pm = subrOnly.equals("false") ? false : true;
+			if (pm && !pref.isPremium)
+				ch.setCacheStatus("PM");
+			ch.setPos(p);
+			ch.setCacheOwner(owner);
+			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
+			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
+				ch.setOwned(true);
+			}
+			// DEAD CODE commented out
+			// else if (false) {
+			// ch.setFound(true);
+			// ch.setCacheStatus(ch.getFoundText());
+			// }
+
+			cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
+			ch.setCacheName(cacheName);
+			ch.setAvailable(disabled.equals("true") ? false : true);
+			ch.setDateHidden(DateFormat.toYYMMDD(hidden));
+			ch.setHard(CacheTerrDiff.v1Converter(difficulty));
+			ch.setTerrain(CacheTerrDiff.v1Converter(terrain));
+			ch.setCacheSize(CacheSize.gcGpxString2Cw(container));
+			ch.setType(cacheType);
+			num_added++;
+			cacheDB.add(ch);
+			if (setCachesToLoad) {
+				cachesToLoad.add(wp + "found");
+			} else {
+				ch.getCacheDetails(false).URL = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + wp;
+				ch.save();
+			}
+			if (Global.mainTab.statBar != null)
+				Global.mainTab.statBar.updateDisplay("GC pages: " + page_number + " Caches added to CW: " + num_added);
+		} else {
+		}
+	}
+
 	/**
 	 * check if new Update exists
 	 * 
@@ -1616,7 +1759,7 @@
 		boolean save = false;
 		boolean is_archived_GC = false;
 		boolean is_found_GC = false;
-		CacheHolderDetail chd = ch.getCacheDetails(false);
+		final CacheHolderDetail chd = ch.getCacheDetails(false);
 		if (spiderAllFinds) {
 			if (!ch.is_found()) {
 				ch.setFound(true);
@@ -1642,8 +1785,7 @@
 		if (ch.is_found() && chd.OwnLogId.equals("")) {
 			ret = true;
 		} // missing ownLogID
-		boolean is_available_GC = !is_archived_GC
-				&& CacheDescription.indexOf(propAvailable) == -1;
+		final boolean is_available_GC = !is_archived_GC && CacheDescription.indexOf(propAvailable) == -1;
 		if (is_available_GC != ch.is_available()) {
 			ch.setAvailable(is_available_GC);
 			save = true;
@@ -1654,28 +1796,29 @@
 			save = true;
 			ret = true;
 		}
-		String dts[]=mString.split(getDTS(CacheDescription),'/');
-		if (dts.length == 3) {
-			if (difficultyChanged(ch,  CacheTerrDiff.v1Converter(dts[0]))) {
-				save = true;
-				ret = true;
-				pref.log("difficultyChanged");
+		if (pref.checkDTS) {
+			final String dts[] = mString.split(getDTS(CacheDescription), '/');
+			if (dts.length == 3) {
+				if (difficultyChanged(ch, CacheTerrDiff.v1Converter(dts[0]))) {
+					save = true;
+					ret = true;
+					pref.log("difficultyChanged");
+				}
+				if (terrainChanged(ch, CacheTerrDiff.v1Converter(dts[1]))) {
+					save = true;
+					ret = true;
+					pref.log("terrainChanged");
+				}
+				if (sizeChanged(ch, (byte) Common.parseInt(dts[2]))) {
+					save = true;
+					ret = true;
+					pref.log("sizeChanged");
+				}
+			} else {
+				pref.log("[SpiderGC.java:updateExists]check DTS calculation!", null);
 			}
-			if (terrainChanged(ch, CacheTerrDiff.v1Converter(dts[1]))) {
-				save = true;
-				ret = true;
-				pref.log("terrainChanged");
-			}
-			if (sizeChanged(ch, (byte) Common.parseInt(dts[2]))) {
-				save = true;
-				ret = true;
-				pref.log("sizeChanged");
-			}
 		}
-		else {
-			pref.log("check DTS calculation", null);
-		}
-		if (newFoundExists(ch,  CacheDescription)) {
+		if (newFoundExists(ch, CacheDescription)) {
 			numLogUpdates++;
 			ret = true;
 		}
@@ -1699,8 +1842,7 @@
 		if (RexNumFinds.didMatch()) {
 			return Common.parseInt(RexNumFinds.stringMatched(1));
 		} else {
-			pref.log("check RexNumFinds in SpiderGC.java / initialiseProperties" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getNumFound]check RexNumFinds!", null);
 			return 0;
 		}
 	}
@@ -1717,48 +1859,56 @@
 		}
 		return counter;
 	}
-	
+
 	private String decodeXor(String input, String key) {
-	  byte ctmp[] = input.getBytes();
-		byte ckey[] = key.getBytes();
-		int codeLength = input.length();
-		int keyLength = key.length();
-		for (int i=0; i<codeLength; i++) {
-		  ctmp[i]^=ckey[i%keyLength];
-    }
+		final byte ctmp[] = input.getBytes();
+		final byte ckey[] = key.getBytes();
+		final int codeLength = input.length();
+		final int keyLength = key.length();
+		for (int i = 0; i < codeLength; i++) {
+			ctmp[i] ^= ckey[i % keyLength];
+		}
 		return new String(ctmp);
-  }
+	}
+
 	private double[] getDistanceAndDirection(String doc) {
-		double[] distanceAndDirection={(0.0),(0.0)};
-		if (spiderAllFinds) return distanceAndDirection;
+		final double[] distanceAndDirection = { (0.0), (0.0) };
+		if (spiderAllFinds)
+			return distanceAndDirection;
 		RexPropDistanceCode.search(doc);
 		if (!RexPropDistanceCode.didMatch()) {
-			pref.log("check distRex" + Preferences.NEWLINE + doc);
-			distanceAndDirection[0]=-1.0; // Abbruch
+			pref.log("[SpiderGC.java:getDistanceAndDirection]check distRex!", null);
+			distanceAndDirection[0] = -1.0; // Abbruch
 			return distanceAndDirection;
 		}
-		String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-		String ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
-		RexPropDistance.search(ret); // km oder mi oder ft		
+		final String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+		String ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
+		RexPropDistance.search(ret); // km oder mi oder ft
 		if (!RexPropDistance.didMatch()) {
-			if (ret.indexOf("ere") > -1) return distanceAndDirection; // zur Zeit " Here -1"
+			if (ret.indexOf("ere") > -1)
+				return distanceAndDirection; // zur Zeit " Here -1"
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
-			// da dieser von gc mal wieder ge?ndert wurde.
+			// da dieser von gc mal wieder ge????ndert wurde.
 			// todo Ben?tigt ev noch weitere Anpassungen: | am Anfang, and calc of keylength
-
 			// String thereitis="|0.34 km|102.698";
-			// String page = fetchText("http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&lng=009.26313&dist=2&f=1",false);
-			String thereitis="|0.08 km|223.968";
-			String page = fetchText("http://www.geocaching.com/seek/nearest.aspx?lat=45.29152&lng=-122.41262&dist=1",false);
-			//  
+			// String page =
+			// fetchText("http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&lng=009.26313&dist=2&f=1",false);
+			final String thereitis = "|0.08 km|223.968";
+			String page;
+			try {
+				page = UrlFetcher.fetch("http://www.geocaching.com/seek/nearest.aspx?lat=45.292&lng=-122.41262&dist=1");
+			} catch (final IOException e) {
+				page = "";
+			}
+			//
 			RexPropListBlock.search(page);
-			String table="";
+			String table = "";
 			if (RexPropListBlock.didMatch()) {
 				table = RexPropListBlock.stringMatched(1);
 			}
-			
+
 			RexPropLine.search(table);
-			String row="";
+			String row = "";
 			if (RexPropLine.didMatch()) {
 				row = RexPropLine.stringMatched(1);
 			}
@@ -1768,34 +1918,35 @@
 				pref.log("Didn't get DistanceCodeKey automaticly." + Preferences.NEWLINE);
 				return distanceAndDirection;
 			}
-			String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-			String newkey=decodeXor(coded,thereitis);
-			int keylength=13; // wenn nicht 13 dann newkey auf wiederholung pr?fen
-			DistanceCodeKey=newkey.substring(0, keylength);
-			ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
+			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+			final String newkey = decodeXor(coded, thereitis);
+			final int keylength = 13;
+			// wenn nicht 13 dann newkey auf wiederholung pr????fen
+			DistanceCodeKey = newkey.substring(0, keylength);
+			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
+			pref.log("Automatic key: " + DistanceCodeKey + " result: " + ret + Preferences.NEWLINE);
 			RexPropDistance.search(ret); // km oder mi
 		}
 
 		if (RexPropDistance.didMatch()) {
 			if (MyLocale.getDigSeparator().equals(",")) {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1).replace('.', ','));
-				String r = RexPropDistance.right(1).substring(3);  //3 expexts 2 char which are at moment "km" or "mi"
+				final String r = RexPropDistance.right(1).substring(3);
+				// 3 expexts 2 char which are at moment "km" or "mi"
 				distanceAndDirection[1] = Convert.toDouble(r.replace('.', ','));
-			}
-			else {
-				distanceAndDirection[0] =  Convert.toDouble(RexPropDistance.stringMatched(1));
-				String r = RexPropDistance.right(1).substring(3);
+			} else {
+				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1));
+				final String r = RexPropDistance.right(1).substring(3);
 				distanceAndDirection[1] = Convert.toDouble(r);
 			}
-			if (ret.indexOf("ft")>0) {
+			if (ret.indexOf("ft") > 0) {
 				// Umrechnung in miles
-				distanceAndDirection[0]=distanceAndDirection[0] / 5280.0;				
+				distanceAndDirection[0] = distanceAndDirection[0] / 5280.0;
 			}
+		} else {
+			pref.log("[SpiderGC.java:getDistanceAndDirection](gc Code change ?) check distCodeKey!", null);
 		}
-		else {
-			pref.log("(gc Code change ?) check distCodeKey in spider.def" + Preferences.NEWLINE + doc);
-		}
-		
+
 		return distanceAndDirection;
 	}
 
@@ -1809,7 +1960,7 @@
 	private String getWP(String doc) throws Exception {
 		RexPropWaypoint.search(doc);
 		if (!RexPropWaypoint.didMatch()) {
-			pref.log("check waypointRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getWP]check waypointRex!", null);
 			return "???";
 		}
 		return "GC" + RexPropWaypoint.stringMatched(1);
@@ -1826,7 +1977,7 @@
 		} else {
 			numPrivate = numPrivate + 1;
 			if (spiderAllFinds) {
-				pref.log(chWaypoint+" is private.",null);
+				pref.log(chWaypoint + " is private.", null);
 			}
 			return false;
 		}
@@ -1850,167 +2001,90 @@
 				return true;
 			}
 		}
-		pref.log("check TypeRex in spider.def" + Preferences.NEWLINE + toCheck);
+		pref.log("[SpiderGC.java:typeChanged]check TypeRex!", null);
 		return false;
 	}
-	
+
 	private String getDTS(String toCheck) {
 		RexPropDTS.search(toCheck);
 		if (RexPropDTS.didMatch()) {
-			String code=RexPropDTS.stringMatched(1);
+			final String code = RexPropDTS.stringMatched(1);
 			/* */
-			String url = "http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v="+code;
-			ByteArray doc=fetch(url);
-			Image idoc = new Image(doc,0,null,0,0);
-			/*
-			FileOutputStream fos;
+			final String address = "http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=" + code;
+			ByteArray doc;
 			try {
-				fos = new FileOutputStream(new File("temp.png"));
-				fos.write(doc.toBytes());
-				fos.close();
-			} catch (IOException e) {
+				doc = UrlFetcher.fetchData(address);
+			} catch (final IOException e) {
+				return "";
 			}
-			finally {
-			}
-			*/
-			String ret = getDTfromImage(idoc) + "/" + getSizeFromImage(idoc);
-			return ret; 
-			//*/
+			final Image idoc = new Image(doc, 0, null, 0, 0);
+			/*
+			 * FileOutputStream fos; try { fos = new FileOutputStream(new File("temp.png")); fos.write(doc.toBytes());
+			 * fos.close(); } catch (IOException e) { } finally { }
+			 */
+			final String ret = getDTfromImage(idoc) + "/" + getSizeFromImage(idoc);
+			return ret;
+			// */
 
 			/*
-			int decoded = 0;
-			int pwr = 1;
-			for (int i = code.length()-1 ; i >= 0; i--) {
-				decoded = decoded + DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr;
-				pwr = pwr * 42;
-			}
-			decoded = (decoded - 131586) % 16777216;
-			// size 0=not choosen 1=Micro 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small
-			int sizecode = decoded / 74088; // 42 ^ 3
-			int sizeremove;
-			byte size;
-			switch (sizecode) {
-			case 0: size=CacheSize.CW_SIZE_NOTCHOSEN; sizeremove=0; break;
-			case 1: size=CacheSize.CW_SIZE_MICRO; sizeremove=131072; break;
-			case 3: size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break;
-			case 5: size=CacheSize.CW_SIZE_LARGE; sizeremove=393217; break;
-			case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break;
-			case 8: size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break;
-			case 12: size=CacheSize.CW_SIZE_SMALL; sizeremove=917504; break;
-			default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break;
-			}
-			decoded = decoded - sizeremove;
-			int terraincode = decoded / 252;
-			// terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String terrain = "" + (1 + terraincode / 2.0 ); 
-			// difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String difficulty = "" + (1+((decoded % 42) - (terraincode * 4)) / 2.0);
-			if (difficulty.equals("0.5")) {
-				difficulty = "5";
-			}
-			return difficulty+"/"+terrain+"/"+size;
-			*/
+			 * int decoded = 0; int pwr = 1; for (int i = code.length()-1 ; i >= 0; i--) { decoded = decoded +
+			 * DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr; pwr = pwr * 42; } decoded = (decoded - 1386) % 16777216; //
+			 * size 0=not choosen 1=Micro 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small int sizecode = decoded / 74088; //
+			 * 42 ^ 3 int sizeremove; byte size; switch (sizecode) { case 0: size=CacheSize.CW_SIZE_NOTCHOSEN;
+			 * sizeremove=0; break; case 1: size=CacheSize.CW_SIZE_MICRO; sizeremove=131072; break; case 3:
+			 * size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break; case 5: size=CacheSize.CW_SIZE_LARGE;
+			 * sizeremove=393217; break; case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break; case 8:
+			 * size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break; case 12: size=CacheSize.CW_SIZE_SMALL;
+			 * sizeremove=917504; break; default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break; } decoded = decoded -
+			 * sizeremove; int terraincode = decoded / 252; // terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
+			 * String terrain = "" + (1 + terraincode / 2.0 ); // difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
+			 * String difficulty = "" + (1+((decoded % 42) - (terraincode * 4)) / 2.0); if (difficulty.equals("0.5")) {
+			 * difficulty = "5"; } return difficulty+"/"+terrain+"/"+size;
+			 */
 		}
-		pref.log("check DTSRex in spider.def" + Preferences.NEWLINE + toCheck);
+		pref.log("[SpiderGC.java:getDTS]check DTSRex!", null);
 		return "";
 	}
 
 	static Hashtable validChars = new Hashtable();
-	
+
 	static {
-		validChars.put(".", new int[][] {
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 1, 0 },
-				{0, 1, 0 }
-		});
-		validChars.put("/", new int[][] {
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0}
-		});
-		validChars.put("1", new int[][] {
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put("2", new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put("3", new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
-		validChars.put("4", new int[][] {
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 1, 0},
-				{0, 0, 1, 0, 1, 0},
-				{0, 1, 0, 0, 1, 0},
-				{1, 0, 0, 0, 1, 0},
-				{1, 1, 1, 1, 1, 1},
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 0, 1, 0}
-		});
-		validChars.put("5", new int[][] {
-				{1, 1, 1, 1, 1},
-				{1, 0, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
+		validChars.put(".", new int[][] { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 1, 0 }, { 0, 1, 0 } });
+		validChars.put("/", new int[][] { { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 } });
+		validChars.put("1", new int[][] { { 0, 0, 1, 0, 0 }, { 1, 1, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put("2", new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put("3", new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
+		validChars.put("4", new int[][] { { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 1, 0 }, { 0, 0, 1, 0, 1, 0 }, { 0, 1, 0, 0, 1, 0 }, { 1, 0, 0, 0, 1, 0 }, { 1, 1, 1, 1, 1, 1 }, { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 0, 1, 0 } });
+		validChars.put("5", new int[][] { { 1, 1, 1, 1, 1 }, { 1, 0, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
 	}
 
 	private static byte getSizeFromImage(Image bild) {
 		int[] argb = bild.getPixels(null, 0, 5, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_MICRO;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_MICRO;
 		argb = bild.getPixels(null, 0, 10, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_SMALL;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_SMALL;
 		argb = bild.getPixels(null, 0, 17, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_REGULAR;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_REGULAR;
 		argb = bild.getPixels(null, 0, 26, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_LARGE;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_LARGE;
 		argb = bild.getPixels(null, 0, 40, 23, 1, 1, 0);
-		if (argb[0] == -6735302) return CacheSize.CW_SIZE_NOTCHOSEN;
+		if (argb[0] == -6735302)
+			return CacheSize.CW_SIZE_NOTCHOSEN;
 		argb = bild.getPixels(null, 0, 41, 24, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_OTHER;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_OTHER;
 		return CacheSize.CW_SIZE_ERROR;
 	}
 
 	private static String getDTfromImage(Image bild) {
-		StringBuffer sb = new StringBuffer();
+		final StringBuffer sb = new StringBuffer();
 		for (int startX = 0; startX < bild.getWidth(); startX++) {
-			for (Enumeration e = validChars.keys(); e.hasMoreElements();) {
-				String key=(String) e.nextElement();
+			for (final Enumeration e = validChars.keys(); e.hasMoreElements();) {
+				final String key = (String) e.nextElement();
 				if (testValidChar(bild, startX, 4, (int[][]) validChars.get(key))) {
 					sb.append(key);
 				}
@@ -2021,17 +2095,16 @@
 
 	private static boolean testValidChar(Image bild, int startX, int startY, int[][] validChar) {
 		for (int y = 0; y < validChar.length; y++) {
-			if (bild.getHeight() > startY+y) {
+			if (bild.getHeight() > startY + y) {
 				for (int x = 0; x < validChar[0].length; x++) {
-					if (bild.getWidth() > startX+x) {
+					if (bild.getWidth() > startX + x) {
 						// int[] alpha = bild.getAlphaRaster().getPixel(startX+x, startY+y, new int[1]);
-						int[] argb = bild.getPixels(null, 0, startX+x, startY+y, 1, 1, 0);
-						if ((argb[0] == 0 && validChar[y][x] == 0) ||
-								(argb[0] != 0 && validChar[y][x] > 0)) {
+						final int[] argb = bild.getPixels(null, 0, startX + x, startY + y, 1, 1, 0);
+						if ((argb[0] == 0 && validChar[y][x] == 0) || (argb[0] != 0 && validChar[y][x] > 0)) {
 							// matches
 						} else {
 							return false;
-						} 
+						}
 					} else {
 						return false;
 					}
@@ -2054,6 +2127,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed Terrain
 	 */
@@ -2065,6 +2139,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed CacheSize
 	 */
@@ -2083,18 +2158,21 @@
 	private boolean directionOK(String[] directions, double toCheck) {
 		if (directions == null || directions.length == 0)
 			return true; // nothing means all
-		int lowerLimit = Common.parseInt(directions[0]);
-		int upperLimit = Common.parseInt(directions[1]);
+		final int lowerLimit = Common.parseInt(directions[0]);
+		final int upperLimit = Common.parseInt(directions[1]);
 		if (lowerLimit <= upperLimit) {
-			if ((toCheck>=lowerLimit) && (toCheck<=upperLimit))
-			{return true;}
-			else {return false;}
+			if ((toCheck >= lowerLimit) && (toCheck <= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
+		} else {
+			if ((toCheck >= lowerLimit) || (toCheck <= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
 		}
-		else {
-			if ((toCheck>=lowerLimit) || (toCheck<=upperLimit))
-			{return true;}
-			else {return false;}
-		}
 	}
 
 	/*
@@ -2105,102 +2183,75 @@
 	 * @return boolean newLogExists
 	 */
 	private boolean newFoundExists(CacheHolder ch, String cacheDescription) {
-		if (!pref.checkLog || pref.maxLogsToSpider==0)
+		if (!pref.checkLog || pref.maxLogsToSpider == 0)
 			return false;
-		Time lastLogCW = new Time();
-		Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
+		final Time lastLogCW = new Time();
+		final Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
 		if (lastLog == null)
 			return true;
-		String slastLogCW = lastLog.getDate();
+		final String slastLogCW = lastLog.getDate();
 		if (slastLogCW.equals("") || slastLogCW.equals("1900-00-00"))
 			return true; // or check cacheDescGC also no log?
 		lastLogCW.parse(slastLogCW, "yyyy-MM-dd");
 
-		Time lastLogGC = new Time(); // is current time
-		lastLogGC.hour = 0;
-		lastLogGC.minute = 0;
-		lastLogGC.second = 0;
-		lastLogGC.millis = 0;
-		String[] SDate;
 		String stmp = "";
 		RexPropLogDate.search(cacheDescription);
 		if (RexPropLogDate.didMatch()) {
 			stmp = RexPropLogDate.stringMatched(1);
 		} else {
-			pref.log("check logDateRex in spider.def" + Preferences.NEWLINE + cacheDescription);
+			pref.log("[SpiderGC.java:newFoundExists]check logDateRex!", null);
 			return false;
 		}
-		if (stmp.indexOf("day") > 0) {
-			// simplyfied (update if not newer than last week)
-			lastLogGC.setTime(lastLogGC.getTime() - 691200000L); 
-		} else if (stmp.equals("")) {
-			return false; // no log yet
-		} else {
-			final String monthNames[] = { "January", "February", "March",
-					"April", "May", "June", "July", "August", "September",
-					"October", "November", "December" };
-			SDate = mString.split(stmp, ' ');
-			lastLogGC.day = Common.parseInt(SDate[0]);
-			for (int m = 0; m < 12; m++) {
-				if (monthNames[m].startsWith(SDate[1])) {
-					lastLogGC.month = m + 1;
-					m = 12;
-				}
-			}
-			lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
-		}
-		boolean ret = lastLogCW.compareTo(lastLogGC) < 0;
+		final Time lastLogGC = DateFormat.toDate(stmp);
+		// String timecheck = DateFormat.toYYMMDD(lastLogGC);
+		final boolean ret = lastLogCW.compareTo(lastLogGC) < 0;
 		return ret;
 	}
+
 	private boolean TBchanged(CacheHolder ch, String cacheDescription) {
-		// simplified Version: only presence is checked 
-		if (pref.downloadTBs && pref.checkTBs ) {
-			boolean hasTB=cacheDescription.indexOf("data-tbcount") > -1;
+		// simplified Version: only presence is checked
+		if (pref.downloadTBs && pref.checkTBs) {
+			final boolean hasTB = cacheDescription.indexOf("data-tbcount") > -1;
 			return ch.has_bugs() != (hasTB);
 		}
 		return false;
 	}
 
 	/**
-	 * Read a complete cachepage from geocaching.com including all logs. This is
-	 * used both when updating already existing caches (via spiderSingle) and
-	 * when spidering around a centre. It is also used when reading a GPX file
+	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already
+	 * existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file
 	 * and fetching the images.
 	 * 
 	 * This is the workhorse function of the spider.
 	 * 
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
-	 * @param boolean isUpdate True if an existing cache is being updated, false
-	 *        if it is a new cache
-	 * @param boolean fetchImages True if the pictures are to be fetched
-	 * @param boolean fetchTBs True if the TBs are to be fetched
-	 * @param boolean doNotGetFound True if the cache is not to be spidered if
-	 *        it has already been found
-	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding
-	 *        option '&logs=y' to command line). This is normally false when
-	 *        spidering from GPXImport as the logs are part of the GPX file, and
-	 *        true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was
-	 *         an error (continue with next cache), 1 if everything ok
+	 * @param boolean
+	 *        isUpdate True if an existing cache is being updated, false if it is a new cache
+	 * @param boolean
+	 *        fetchImages True if the pictures are to be fetched
+	 * @param boolean
+	 *        fetchTBs True if the TBs are to be fetched
+	 * @param boolean
+	 *        doNotGetFound True if the cache is not to be spidered if it has already been found
+	 * @param boolean
+	 *        fetchAllLogs True if all logs are to be fetched (by adding option '&logs=y' to command line). This is
+	 *        normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if
+	 *         everything ok
 	 */
-	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate,
-			boolean fetchImages, boolean fetchTBs, boolean doNotGetFound,
-			boolean fetchAllLogs) {
+	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean fetchTBs, boolean doNotGetFound, boolean fetchAllLogs) {
 		int ret = SPIDER_OK; // initialize value;
 		while (true) { // retry even if failure
 			pref.log(""); // new line for more overview
 			String completeWebPage;
 			int spiderTrys = 0;
-			int MAX_SPIDER_TRYS = 3;
+			final int MAX_SPIDER_TRYS = 3;
 			while (spiderTrys++ < MAX_SPIDER_TRYS) {
 				ret = SPIDER_OK; // initialize value;
 				try {
-					String doc = p.getProp("getPageByName")
-							+ ch.getWayPoint()
-							+ ((fetchAllLogs || ch.is_found()) ? p
-									.getProp("fetchAllLogs") : "");
-					completeWebPage = fetchText(doc, false);
+					final String doc = p.getProp("getPageByName") + ch.getWayPoint() + ((fetchAllLogs || ch.is_found()) ? p.getProp("fetchAllLogs") : "");
+					completeWebPage = UrlFetcher.fetch(doc);
 					pref.log("Fetched: " + ch.getWayPoint());
 					if (completeWebPage.equals("")) {
 						pref.log("Could not fetch " + ch.getWayPoint(), null);
@@ -2211,7 +2262,7 @@
 							return SPIDER_CANCEL;
 						}
 					}
-				} catch (Exception ex) {
+				} catch (final Exception ex) {
 					pref.log("Could not fetch " + ch.getWayPoint(), ex);
 					if (!infB.isClosed) {
 						continue;
@@ -2220,18 +2271,15 @@
 						return SPIDER_CANCEL;
 					}
 				}
-				// Only analyse the cache data and fetch pictures if user has
-				// not closed the progress window
+				// Only analyse the cache data and fetch pictures if user has not closed the progress window
 				if (!infB.isClosed) {
 					try {
 						ch.initStates(!isUpdate);
 
-						// first check if coordinates are available to prevent
-						// deleting existing coordinates
-						String latLon = getLatLon(completeWebPage);
+						// first check if coordinates are available to prevent deleting existing coordinates
+						final String latLon = getLatLon(completeWebPage);
 						if (latLon.equals("???")) {
-							if (completeWebPage.indexOf(p
-									.getProp("premiumCachepage")) > 0) {
+							if (completeWebPage.indexOf(p.getProp("premiumCachepage")) > 0) {
 								// Premium cache spidered by non premium member
 								pref.log("Ignoring premium member cache: " + ch.getWayPoint());
 								spiderTrys = MAX_SPIDER_TRYS;
@@ -2239,7 +2287,7 @@
 								continue;
 							} else {
 								if (spiderTrys == MAX_SPIDER_TRYS)
-									pref.log(">>>> Failed to spider Cache. Retry." + completeWebPage, null);
+									pref.log(">>>> Failed to spider Cache. Retry.", null);
 								ret = SPIDER_ERROR;
 								continue; // Restart the spider
 							}
@@ -2247,24 +2295,20 @@
 
 						ch.setHTML(true);
 						ch.setIncomplete(true);
-						// Save size of logs to be able to check whether any new
-						// logs were added
+						// Save size of logs to be able to check whether any new logs were added
 						// int logsz = chD.CacheLogs.size();
 						// chD.CacheLogs.clear();
 						ch.addiWpts.clear();
 						ch.getCacheDetails(false).images.clear();
 
-						ch.setAvailable(!(completeWebPage.indexOf(p
-								.getProp("cacheUnavailable")) >= 0));
-						ch.setArchived(completeWebPage.indexOf(p
-								.getProp("cacheArchived")) >= 0);
+						ch.setAvailable(!(completeWebPage.indexOf(p.getProp("cacheUnavailable")) >= 0));
+						ch.setArchived(completeWebPage.indexOf(p.getProp("cacheArchived")) >= 0);
 						// ==========
 						// Logs first (for check early for break)
 						// ==========
 						getLogs(completeWebPage, ch.getCacheDetails(false));
 						pref.log("Got logs");
-						// If the switch is set to not store found caches and we
-						// found the cache => return
+						// If the switch is set to not store found caches and we found the cache => return
 						if (ch.is_found() && doNotGetFound) {
 							if (infB.isClosed) {
 								return SPIDER_CANCEL;
@@ -2275,30 +2319,24 @@
 						// ==========
 						// General Cache Data
 						// ==========
-						ch.setLatLon(latLon);
-						pref.log("LatLon: " + ch.getLatLon());
+						ch.setPos(new CWPoint(latLon));
+						pref.log("LatLon: " + ch.getPos().toString());
 
-						String longDesc = getLongDesc(completeWebPage);
+						final String longDesc = getLongDesc(completeWebPage);
 						ch.getCacheDetails(false).setLongDescription(longDesc);
 						pref.log("Got description");
 
-						ch.setCacheName(SafeXML
-								.cleanback(getName(completeWebPage)));
+						ch.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
 						pref.log("Name: " + ch.getCacheName());
 
-						String location = getLocation(completeWebPage);
+						final String location = getLocation(completeWebPage);
 						if (location.length() != 0) {
-							int countryStart = location.indexOf(",");
+							final int countryStart = location.indexOf(",");
 							if (countryStart > -1) {
-								ch.getCacheDetails(false).Country = SafeXML
-										.cleanback(location.substring(
-												countryStart + 1).trim());
-								ch.getCacheDetails(false).State = SafeXML
-										.cleanback(location.substring(0,
-												countryStart).trim());
+								ch.getCacheDetails(false).Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
+								ch.getCacheDetails(false).State = SafeXML.cleanback(location.substring(0, countryStart).trim());
 							} else {
-								ch.getCacheDetails(false).Country = location
-										.trim();
+								ch.getCacheDetails(false).Country = location.trim();
 								ch.getCacheDetails(false).State = "";
 							}
 							pref.log("Got location (country/state)");
@@ -2310,31 +2348,23 @@
 						String owner = getOwner(completeWebPage);
 						owner = SafeXML.cleanback(owner).trim();
 						ch.setCacheOwner(owner);
-						if (ch.getCacheOwner().equals(pref.myAlias)
-							|| (pref.myAlias2.length() > 0 && ch.getCacheOwner().equals(pref.myAlias2)))
+						if (ch.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length() > 0 && ch.getCacheOwner().equals(pref.myAlias2)))
 							ch.setOwned(true);
-						pref.log("Owner: " + ch.getCacheOwner()
-								+ "; is_owned = " + ch.is_owned()
-								+ ";  alias1,2 = [" + pref.myAlias + "|"
-								+ pref.myAlias2 + "]");
+						pref.log("Owner: " + ch.getCacheOwner() + "; is_owned = " + ch.is_owned() + ";  alias1,2 = [" + pref.myAlias + "|" + pref.myAlias2 + "]");
 
-						ch.setDateHidden(DateFormat
-								.MDY2YMD(getDateHidden(completeWebPage)));
+						ch.setDateHidden(DateFormat.toYYMMDD(getDateHidden(completeWebPage)));
 						pref.log("Hidden: " + ch.getDateHidden());
 
-						ch.getCacheDetails(false).setHints(
-								getHints(completeWebPage));
+						ch.getCacheDetails(false).setHints(getHints(completeWebPage));
 						pref.log("Hints: " + ch.getCacheDetails(false).Hints);
 
-						ch.setCacheSize(CacheSize
-								.gcSpiderString2Cw(getSize(completeWebPage)));
+						ch.setCacheSize(CacheSize.gcSpiderString2Cw(getSize(completeWebPage)));
 						pref.log("Size: " + ch.getCacheSize());
 
 						ch.setHard(CacheTerrDiff.v1Converter(getDiff(completeWebPage)));
 						pref.log("Hard: " + ch.getHard());
 
-						ch.setTerrain(CacheTerrDiff
-								.v1Converter(getTerr(completeWebPage)));
+						ch.setTerrain(CacheTerrDiff.v1Converter(getTerr(completeWebPage)));
 						pref.log("Terr: " + ch.getTerrain());
 
 						ch.setType(getType(completeWebPage));
@@ -2344,27 +2374,24 @@
 						// ==========
 						if (fetchTBs)
 							getBugs(ch.getCacheDetails(false), completeWebPage);
-						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs
-								.size() > 0);
+						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs.size() > 0);
 						pref.log("Got TBs");
 						// ==========
 						// Images
 						// ==========
 						if (fetchImages) {
-							getImages(completeWebPage, ch.getCacheDetails(false),true);
+							getImages(completeWebPage, ch.getCacheDetails(false), true);
 							pref.log("Got images");
 						}
 						// ==========
 						// Addi waypoints
 						// ==========
-						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch
-								.is_found());
+						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch.is_found());
 						pref.log("Got additional waypoints");
 						// ==========
 						// Attributes
 						// ==========
-						getAttributes(completeWebPage, ch
-								.getCacheDetails(false));
+						getAttributes(completeWebPage, ch.getCacheDetails(false));
 						pref.log("Got attributes");
 						// ==========
 						// Last sync date
@@ -2373,7 +2400,7 @@
 						ch.setIncomplete(false);
 						pref.log("ready " + ch.getWayPoint() + " : " + ch.getLastSync());
 						break;
-					} catch (Exception ex) {
+					} catch (final Exception ex) {
 						pref.log("[getCacheByWaypointName: ]Error reading cache: " + ch.getWayPoint(), ex);
 					}
 				} else {
@@ -2382,10 +2409,7 @@
 			} // spiderTrys
 			if ((spiderTrys >= MAX_SPIDER_TRYS) && (ret == SPIDER_OK)) {
 				pref.log(">>> Failed to spider cache. Number of retrys exhausted.", null);
-				int decision = (new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(5515,"Failed to load cache.%0aPleas check your internet connection.%0aRetry?"),
-						FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB))
-						.execute();
+				final int decision = (new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(55, "Failed to load cache.%0aPleas check your internet connection.%0aRetry?"), FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB)).execute();
 				if (decision == FormBase.IDOK) {
 					continue; // retry even if failure
 				} else if (decision == FormBase.IDNO) {
@@ -2396,8 +2420,8 @@
 			}
 			break;
 		}// while(true) // retry even if failure
-		if (infB.isClosed) {// If the infoBox was closed before getting here, we
-							// return -1
+		if (infB.isClosed) {
+			// If the infoBox was closed before getting here, we return -1
 			return SPIDER_CANCEL;
 		}
 		return ret;
@@ -2411,11 +2435,10 @@
 	 * @return Cache coordinates
 	 */
 	private String getLatLon(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("latLonRex"));
+		final Regex inRex = new Regex(p.getProp("latLonRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check latLonRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getLatLon]check latLonRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2432,13 +2455,13 @@
 	 */
 	private String getLongDesc(String doc) throws Exception {
 		String res = "";
-		Regex shortDescRex = new Regex(p.getProp("shortDescRex"));
-		Regex longDescRex = new Regex(p.getProp("longDescRex"));
+		final Regex shortDescRex = new Regex(p.getProp("shortDescRex"));
+		final Regex longDescRex = new Regex(p.getProp("longDescRex"));
 		shortDescRex.search(doc);
 		if (!shortDescRex.didMatch()) {
 			if (shortDescRex_not_yet_found)
-				pref.log("no shortDesc or check shortDescRex in spider.def");
-				//		+ Preferences.NEWLINE + doc);
+				pref.log("[SpiderGC.java:getLongDesc]no shortDesc or check shortDescRex!", null);
+			// + Preferences.NEWLINE + doc);
 		} else {
 			res = shortDescRex.stringMatched(1);
 			shortDescRex_not_yet_found = false;
@@ -2446,18 +2469,16 @@
 		res += "<br>";
 		longDescRex.search(doc);
 		if (!longDescRex.didMatch()) {
-			pref.log("check longDescRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getLongDesc]check longDescRex!", null);
 		} else {
 			res += longDescRex.stringMatched(1);
 		}
-		int spanEnd = res.lastIndexOf("</span>");
+		final int spanEnd = res.lastIndexOf("</span>");
 		if (spanEnd >= 0) {
 			res = res.substring(0, spanEnd);
 		}
-		return SafeXML.cleanback(res); // since internal viewer doesn't show
-										// html-entities that are now in
-										// cacheDescription
+		// since internal viewer doesn't show html-entities that are now in cacheDescription
+		return SafeXML.cleanback(res);
 	}
 
 	/**
@@ -2468,11 +2489,10 @@
 	 * @return the location (country and state) of the cache
 	 */
 	private String getLocation(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("cacheLocationRex"));
+		final Regex inRex = new Regex(p.getProp("cacheLocationRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheLocationRex in spider.def"
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getLocation]check cacheLocationRex!", null);
 			return "";
 		}
 		return inRex.stringMatched(1);
@@ -2486,11 +2506,10 @@
 	 * @return the name of the cache
 	 */
 	private String getName(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("cacheNameRex"));
+		final Regex inRex = new Regex(p.getProp("cacheNameRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheNameRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getName]check cacheNameRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2504,11 +2523,10 @@
 	 * @return the cache owner
 	 */
 	private String getOwner(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("cacheOwnerRex"));
+		final Regex inRex = new Regex(p.getProp("cacheOwnerRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheOwnerRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getOwner]check cacheOwnerRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2522,11 +2540,10 @@
 	 * @return Hidden date
 	 */
 	private String getDateHidden(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("dateHiddenRex"));
+		final Regex inRex = new Regex(p.getProp("dateHiddenRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check dateHiddenRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getDateHidden]check dateHiddenRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2540,11 +2557,10 @@
 	 * @return Cachehints
 	 */
 	private String getHints(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("hintsRex"));
+		final Regex inRex = new Regex(p.getProp("hintsRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check hintsRex in spider.def"
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getHints]check hintsRex!", null);
 			return "";
 		}
 		return inRex.stringMatched(1);
@@ -2558,13 +2574,12 @@
 	 * @return Cache size
 	 */
 	private String getSize(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("sizeRex"));
+		final Regex inRex = new Regex(p.getProp("sizeRex"));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check sizeRex in spider.def"
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getSize]check sizeRex!", null);
 			return "None";
 		}
 	}
@@ -2577,13 +2592,12 @@
 	 * @return The cache difficulty
 	 */
 	private String getDiff(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("difficultyRex"));
+		final Regex inRex = new Regex(p.getProp("difficultyRex"));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check difficultyRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getDiff]check difficultyRex!", null);
 			return "-1";
 		}
 	}
@@ -2596,13 +2610,12 @@
 	 * @return Terrain rating
 	 */
 	private String getTerr(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("terrainRex"));
+		final Regex inRex = new Regex(p.getProp("terrainRex"));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check terrainRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getTerr]check terrainRex!", null);
 			return "-1";
 		}
 	}
@@ -2619,8 +2632,7 @@
 		if (RexCacheType.didMatch())
 			return CacheType.gcSpider2CwType(RexCacheType.stringMatched(1));
 		else {
-			pref.log("check cacheTypeRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getType]check cacheTypeRex!", null);
 			return 0;
 		}
 	}
@@ -2634,44 +2646,41 @@
 	 *            Cache Details
 	 * @return A HTML string containing the logs
 	 */
-	private void getLogs(String completeWebPage, CacheHolderDetail chD)
-			throws Exception {
+	private void getLogs(String completeWebPage, CacheHolderDetail chD) throws Exception {
 		String icon = "";
 		String name = "";
 		String logText = "";
 		String logId = "";
 		String singleLog = "";
-		LogList reslts = chD.CacheLogs;
+		final LogList reslts = chD.CacheLogs;
 		RexLogBlock.search(completeWebPage);
 		if (!RexLogBlock.didMatch()) {
-			pref.log("check blockRex in spider.def" 
-					+ Preferences.NEWLINE + completeWebPage);
+			pref.log("[SpiderGC.java:getLogs]check blockRex!", null);
 		}
-		String LogBlock = RexLogBlock.stringMatched(1);
-		exSingleLog.setSource(LogBlock);
-		singleLog = exSingleLog.findNext();
-		exIcon.setSource(singleLog);
-		exNameTemp.setSource(singleLog);
-		exName.setSource(exNameTemp.findNext());
-		exDate.setSource(singleLog);
-		exLog.setSource(singleLog);
-		exLogId.setSource(singleLog);
+		final String LogBlock = RexLogBlock.stringMatched(1);
+
+		exSingleLog.set(LogBlock);
 		int nLogs = 0;
 		boolean foundown = false;
-		while (!exSingleLog.endOfSearch()) {
-			// pref.log(singleLog);
+		while ((singleLog = exSingleLog.findNext()).length() > 0) {
 			nLogs++;
-			icon = exIcon.findNext();
-			icon=icon.substring(0, icon.length() - 1); // ' changes to " in UMTS-connection! first char in iconExEnd.
-			name = exName.findNext();
-			logText = exLog.findNext();
-			logId = exLogId.findNext();
-			String d = DateFormat.logdate2YMD(exDate.findNext());
-			// pref.log("Lognr:"+nLogs+"|"+icon+"|"+name+"-|-"+SafeXML.clean(pref.myAlias)+"|"+logId,null);
+
+			icon = exIcon.findFirst(singleLog);
+			// ' changes to " in UMTS-connection! first char in iconExEnd.
+			icon = icon.substring(0, icon.length() - 1);
+
+			name = exName.findFirst(exNameTemp.findFirst(singleLog));
+
+			logText = exLog.findFirst(singleLog);
+			logText = correctSmilies(logText);
+
+			logId = exLogId.findFirst(singleLog);
+
+			final String ed = exDate.findFirst(singleLog);
+			final String d = DateFormat.toYYMMDD(ed);
+
 			// if this log says this Cache is found by me
-			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended))	&&
-					(name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) ||
-					( pref.myAlias2.length() > 0 && name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
+			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) && (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() > 0 && name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);
 				chD.getParent().setCacheStatus(d);
 				chD.OwnLogId = logId;
@@ -2686,13 +2695,6 @@
 					break;
 				}
 			}
-			singleLog = exSingleLog.findNext();
-			exIcon.setSource(singleLog);
-			exNameTemp.setSource(singleLog);
-			exName.setSource(exNameTemp.findNext());
-			exDate.setSource(singleLog);
-			exLog.setSource(singleLog);
-			exLogId.setSource(singleLog);
 		}
 		if (nLogs > pref.maxLogsToSpider) {
 			reslts.add(Log.maxLog());
@@ -2703,70 +2705,83 @@
 	}
 
 	/**
-	 * Read the travelbug names from a previously fetched Cache page and then
-	 * read the travelbug purpose for each travelbug
+	 * This methods cleans up the path for inlined smilies in logtexts.
 	 * 
+	 * @param logText
+	 * @return
+	 */
+	private String correctSmilies(String logText) {
+		int indexOf = logText.indexOf(string);
+		while (indexOf >= 0) {
+			final String prefix = logText.substring(0, indexOf);
+			final String postFix = logText.substring(indexOf + string.length());
+			logText = prefix + "<img src=\"" + postFix;
+			indexOf = logText.indexOf(string);
+		}
+		return logText;
+	}
+
+	/**
+	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each
+	 * travelbug
+	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
 	 */
 	public void getBugs(CacheHolderDetail chD, String doc) throws Exception {
-		Extractor exBlock = new Extractor(doc, 
-				p.getProp("blockExStart"), 
-				p.getProp("blockExEnd"), 
-				0, Extractor.EXCLUDESTARTEND);
-		String bugBlock = exBlock.findNext();
-		Extractor exBug = new Extractor(bugBlock, 
-				p.getProp("bugExStart"), 
-				p.getProp("bugExEnd"), 
-				0, Extractor.EXCLUDESTARTEND);
-		String link, bug, linkPlusBug, bugDetails;
-		String oldInfoBox = infB.getInfo();
 		chD.Travelbugs.clear();
-		while (!exBug.endOfSearch()) {
-			if (infB.isClosed)
-				break; // Allow user to cancel by closing progress form
-			linkPlusBug = exBug.findNext();
-			int idx = linkPlusBug.indexOf(p.getProp("bugLinkEnd"));
-			if (idx < 0)
-				break; // No link/bug pair found
-			link = linkPlusBug.substring(0, idx);
-			Extractor exBugName = new Extractor(linkPlusBug, 
-					p.getProp("bugNameExStart"), 
-					p.getProp("bugNameExEnd"), 
-					0, Extractor.EXCLUDESTARTEND);
-			bug = exBugName.findNext();
-			if (bug.length() > 0) { // Found a bug, get its details
-				Travelbug tb = new Travelbug(bug);
-				try {
-					infB.setInfo(oldInfoBox
-							+ MyLocale.getMsg(5514, "\nGetting bug: ")
-							+ SafeXML.cleanback(bug));
-					bugDetails = fetchText(link, false);
-					pref.log("[getBugs] Fetched TB details: " + bug);
-					Extractor exDetails = new Extractor(bugDetails, p
-							.getProp("bugDetailsStart"), p
-							.getProp("bugDetailsEnd"),
-							0, Extractor.EXCLUDESTARTEND);
-					tb.setMission(exDetails.findNext());
-					Extractor exGuid = new Extractor(bugDetails,
-							"action=\"details.aspx?guid=",
-							"\" id=\"aspnetForm",
-							0, Extractor.EXCLUDESTARTEND);
-					tb.setGuid(exGuid.findNext());
-					chD.Travelbugs.add(tb);
-				} catch (Exception ex) {
-					pref.log("[getBugs] Could not fetch bug details", ex);
+		if (doc.indexOf("ctl00_ContentBody_uxTravelBugList_uxNoTrackableItemsLabel") >= 0) {
+			return; // there are no trackables
+		}
+		final Extractor exBlock = new Extractor(doc, p.getProp("blockExStart"), p.getProp("blockExEnd"), 0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBug = new Extractor("", p.getProp("bugExStart"), p.getProp("bugExEnd"), 0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBugName = new Extractor("", "", "", 0, Extractor.EXCLUDESTARTEND);
+		final String bugBlock;
+		bugBlock = exBlock.findNext();
+		int blockLength = bugBlock.length();
+		if (blockLength > 0) {
+			String link, bug, linkPlusBug, bugDetails;
+			final String oldInfoBox = infB.getInfo();
+			boolean exBugWrong = true;
+			exBug.set(bugBlock);
+			while ((linkPlusBug = exBug.findNext()).length() > 0) {
+				exBugWrong = false;
+				if (infB.isClosed)
+					break;
+				final int idx = linkPlusBug.indexOf(p.getProp("bugLinkEnd"));
+				if (idx < 0) {
+					pref.log("[SpiderGC.java:getBugs]check TBs bugLinkEnd!", null);
+					break; // No link/bug pair found
 				}
+				link = linkPlusBug.substring(0, idx);
+				exBugName.set(linkPlusBug, p.getProp("bugNameExStart"), p.getProp("bugNameExEnd"), idx, Extractor.EXCLUDESTARTEND);
+				if ((bug = exBugName.findNext()).length() > 0) {
+					// Found a bug, get its mission
+					try {
+						infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, "\nGetting bug: ") + SafeXML.cleanback(bug));
+						bugDetails = UrlFetcher.fetch(link);
+						exBugName.set(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND); // reusing
+						// exBugName
+						chD.Travelbugs.add(new Travelbug(link.substring(1 + link.indexOf("=")), bug, exBugName.findNext()));
+					} catch (final Exception ex) {
+						pref.log("[SpiderGC.java:getBugs] Could not fetch buginfo from " + link, ex);
+					}
+				}
 			}
+			infB.setInfo(oldInfoBox);
+			if (exBugWrong) {
+				if (blockLength > 200)
+					pref.log("[SpiderGC.java:getBugs]check TBs bugExStart / bugExEnd! blockLength = " + blockLength + " for " + chD.URL, null);
+			}
+		} else {
+			pref.log("[SpiderGC.java:getBugs]check TBs blockExStart / blockExEnd! ", null);
 		}
-		infB.setInfo(oldInfoBox);
 	}
 
 	/**
-	 * Get the images for a previously fetched cache page. Images are extracted
-	 * from two areas: The long description and the pictures section (including
-	 * the spoiler)
+	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and
+	 * the pictures section (including the spoiler)
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
@@ -2777,222 +2792,178 @@
 		int imgCounter = 0;
 		int spiderCounter = 0;
 		String fileName, imgName, imgType, imgUrl, imgComment;
-		Vector spideredUrls = new Vector(15);
+		final Vector spideredUrls = new Vector();
 		ImageInfo imageInfo = null;
 		Extractor exImgBlock, exImgComment;
 		int idxUrl; // Index of already spidered Url in list of spideredUrls
 		CacheImages lastImages = null;
 
 		// First: Get current image object of waypoint before spidering images.
-		CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
+		final CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
 		if (oldCh != null) {
 			lastImages = oldCh.getCacheDetails(false).images;
 		}
-
 		// ========
-		// In the long description
+		// In the long Description
 		// ========
-		String longDesc = "";
+		String longDesc = doc;
 		try {
-			if (chD.getParent().getWayPoint().startsWith("TC") || !extractLongDesc)
-				longDesc = doc;
-			else
+			if (chD.getParent().getWayPoint().startsWith("GC") || extractLongDesc)
 				longDesc = getLongDesc(doc);
 			longDesc = STRreplace.replace(longDesc, "<img", "<IMG");
 			longDesc = STRreplace.replace(longDesc, "src=", "SRC=");
 			longDesc = STRreplace.replace(longDesc, "'", "\"");
-			exImgBlock = new Extractor(longDesc, 
-					p.getProp("imgBlockExStart"),
-					p.getProp("imgBlockExEnd"), 
-					0, false);
-		} catch (Exception ex) {// Missing property in spider.def
+			exImgBlock = new Extractor(longDesc, p.getProp("imgBlockExStart"), p.getProp("imgBlockExEnd"), 0, false);
+		} catch (final Exception ex) {// Missing property in spider.def
 			return;
 		}
 		String tst;
-		tst = exImgBlock.findNext();
-		Extractor exImgSrc = new Extractor(tst, "http://", "\"", 0, true);
-		while (exImgBlock.endOfSearch() == false) {
-			imgUrl = exImgSrc.findNext();
-			if (imgUrl.length() > 0) {
-				// Optimize: img.groundspeak.com -> img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + "    ").substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(".png")
-							|| imgType.startsWith(".jpg")
-							|| imgType.startsWith(".gif")) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + "_"
-								+ Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl < 0) { // New image
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ "_" + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl,
-										fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ "_" + Convert.toString(idxUrl);
-							pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+		Extractor exImgSrc = new Extractor("", "http://", "\"", 0, true);
+		while ((tst = exImgBlock.findNext()).length() > 0) {
+			// Optimize: img.groundspeak.com -> img.geocaching.com (for better caching purposes)
+			imgUrl = exImgSrc.findFirst(tst);
+			imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
+					// Check whether image was already spidered for this cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl < 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(imgName);
-						imageInfo.setComment(null);
-						imgCounter++;
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
+						pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
+					imageInfo.setTitle(imgName);
+					imageInfo.setComment(null);
+					imgCounter++;
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 			}
-			exImgSrc.setSource(exImgBlock.findNext());
 		}
 		// ========
 		// In the image span
 		// ========
 		Extractor spanBlock, exImgName;
 		try {
-			spanBlock = new Extractor(doc, p.getProp("imgSpanExStart"), 
-					p.getProp("imgSpanExEnd"), 0, true);
+			spanBlock = new Extractor(doc, p.getProp("imgSpanExStart"), p.getProp("imgSpanExEnd"), 0, true);
 			tst = spanBlock.findNext();
-			exImgName = new Extractor(tst, p.getProp("imgNameExStart"), 
-					p.getProp("imgNameExEnd"), 0, true);
-			exImgSrc = new Extractor(tst, p.getProp("imgSrcExStart"), 
-					p.getProp("imgSrcExEnd"), 0, true);
-			exImgComment = new Extractor(tst, p.getProp("imgCommentExStart"), 
-					p.getProp("imgCommentExEnd"), 0, true);
-		} catch (Exception ex) {
+			exImgName = new Extractor(tst, p.getProp("imgNameExStart"), p.getProp("imgNameExEnd"), 0, true);
+			exImgSrc = new Extractor(tst, p.getProp("imgSrcExStart"), p.getProp("imgSrcExEnd"), 0, true);
+			exImgComment = new Extractor(tst, p.getProp("imgCommentExStart"), p.getProp("imgCommentExEnd"), 0, true);
+		} catch (final Exception ex) {
 			return;
 		}
-		while (!exImgSrc.endOfSearch()) {
-			imgUrl = exImgSrc.findNext();
+		while ((imgUrl = exImgSrc.findNext()).length() > 0) {
 			imgComment = exImgComment.findNext();
-			if (imgUrl.length() > 0) {
-				imgUrl = "http://" + imgUrl;
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + "    ").substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(".png")
-							|| imgType.startsWith(".jpg")
-							|| imgType.startsWith(".gif")) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + "_"
-								+ Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl < 0) { // New image
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ "_" + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl,
-										fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
-							pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+			imgUrl = "http://" + imgUrl;
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
+					// Check whether image was already spidered for this cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl < 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(exImgName.findNext());
-						while (imgComment.startsWith("<br />"))
-							imgComment = imgComment.substring(6);
-						while (imgComment.endsWith("<br />"))
-							imgComment = imgComment.substring(0, imgComment.length() - 6);
-						imageInfo.setComment(imgComment);
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
+						pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log("[getImages] IndexOutOfBoundsException in image span. imgURL:" + imgUrl, e);
+					imageInfo.setTitle(exImgName.findNext());
+					while (imgComment.startsWith("<br />"))
+						imgComment = imgComment.substring(6);
+					while (imgComment.endsWith("<br />"))
+						imgComment = imgComment.substring(0, imgComment.length() - 6);
+					imageInfo.setComment(imgComment);
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log("[getImages] IndexOutOfBoundsException in image span. imgURL:" + imgUrl, e);
 			}
+
 		}
 		// ========
 		// Final sweep to check for images in hrefs
 		// ========
-		Extractor exFinal = new Extractor(longDesc, "http://", "\"", 0, true);
-		while (!exFinal.endOfSearch()) {
-			imgUrl = exFinal.findNext();
-			if (imgUrl.length() > 0) {
-				// Optimize: img.groundspeak.com -> img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + "    ").substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with . Delete
-					// characters in URL after the image extension
-					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.')
-							+ imgType.length());
-					if (imgType.startsWith(".jpg")
-							|| imgType.startsWith(".bmp")
-							|| imgType.startsWith(".png")
-							|| imgType.startsWith(".gif")) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						if (idxUrl < 0) { // New image
-							imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
-							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-							imageInfo.setTitle(imgName);
-							imgCounter++;
-							chD.images.add(imageInfo);
+		final Extractor exFinal = new Extractor(longDesc, "http://", "\"", 0, true);
+		while ((imgUrl = exFinal.findNext()).length() > 0) {
+			// Optimize: img.groundspeak.com -> img.geocaching.com (for better caching purposes)
+			imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				// Delete characters in URL after the image extension
+				imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
+				if (imgType.startsWith(".jpg") || imgType.startsWith(".bmp") || imgType.startsWith(".png") || imgType.startsWith(".gif")) {
+					// Check whether image was already spidered for this cache
+					idxUrl = spideredUrls.find(imgUrl);
+					if (idxUrl < 0) { // New image
+						imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
 						}
+						if (imageInfo == null) {
+							imageInfo = new ImageInfo();
+							pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
+							imageInfo.setFilename(fileName + imgType);
+							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
+						}
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+						imageInfo.setTitle(imgName);
+						imgCounter++;
+						chD.images.add(imageInfo);
 					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 			}
+
 		}
 	}
 
@@ -3004,45 +2975,14 @@
 	 * @param target
 	 *            The bytes of the image
 	 */
-	private void spiderImage(String imgUrl, String target) {
-		// TODO implement a fetch(URL, filename) in HttpConnection and use that one
-		HttpConnection connImg;
-		Socket sockImg;
-		// InputStream is;
-		FileOutputStream fos;
-		// int bytes_read;
-		// byte[] buffer = new byte[9000];
-		ByteArray daten;
-		String datei = "";
-		datei = profile.dataDir + target;
-		connImg = new HttpConnection(imgUrl);
-		if (imgUrl.indexOf('%') >= 0)
-			connImg.documentIsEncoded = true;
-		connImg.setRequestorProperty("Connection", "close");
-		// connImg.setRequestorProperty("User-Agent","Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12");
-		// connImg.setRequestorProperty("Accept","text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5");
+	private void spiderImage(String address, String fn) {
 		try {
-			pref.log("[spiderImage] Trying to fetch image from: " + imgUrl);
-			String redirect = null;
-			do {
-				sockImg = connImg.connect();
-				redirect = connImg.getRedirectTo();
-				if (redirect != null) {
-					connImg = connImg.getRedirectedConnection(redirect);
-					pref.log("[spiderImage] Redirect to " + redirect);
-				}
-			} while (redirect != null); 
-			// TODO this can end up in an endless loop if trying to load from a malicous site
-			daten = connImg.readData(sockImg);
-			fos = new FileOutputStream(new File(datei));
-			fos.write(daten.toBytes());
-			fos.close();
-			sockImg.close();
-		} catch (UnknownHostException e) {
+			UrlFetcher.fetchDataFile(address, profile.dataDir + fn);
+		} catch (final UnknownHostException e) {
 			pref.log("[spiderImage] Host not there...", e);
-		} catch (IOException ioex) {
+		} catch (final IOException ioex) {
 			pref.log("[spiderImage] File not found!", ioex);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[spiderImage] Some other problem while fetching image", ex);
 		} finally {
 			// Continue with the spider
@@ -3057,252 +2997,122 @@
 	 * @param wayPoint
 	 *            The name of the cache
 	 * @param is_found
-	 *            Found status of the cached (is inherited by the additional
-	 *            waypoints)
+	 *            Found status of the cached (is inherited by the additional waypoints)
 	 */
 	boolean koords_not_yet_found = true;
 
-	private void getAddWaypoints(String doc, String wayPoint, boolean is_found)
-			throws Exception {
-		Extractor exWayBlock = new Extractor(doc, 
-				p.getProp("wayBlockExStart"),
-				p.getProp("wayBlockExEnd"), 
-				0, false);
-		String wayBlock = "";
-		String rowBlock = "";
-		wayBlock = exWayBlock.findNext();
-		Regex nameRex = new Regex(p.getProp("nameRex"));
-		Regex koordRex = new Regex(p.getProp("koordRex"));
-		Regex descRex = new Regex(p.getProp("descRex"));
-		Regex typeRex = new Regex(p.getProp("typeRex"));
-		int counter = 0;
-		if (!exWayBlock.endOfSearch()
-				&& wayBlock.indexOf("No additional waypoints to display.") < 0) {
-			Extractor exRowBlock = new Extractor(wayBlock, 
-					p.getProp("rowBlockExStart"), 
-					p.getProp("rowBlockExEnd"),
-					0, false);
-			rowBlock = exRowBlock.findNext();
-			rowBlock = exRowBlock.findNext();
-			while (!exRowBlock.endOfSearch()) {
-				CacheHolder hd = null;
+	private void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception {
+		final Extractor exWayBlock = new Extractor(doc, p.getProp("wayBlockExStart"), p.getProp("wayBlockExEnd"), 0, false);
+		String wayBlock;
+		if ((wayBlock = exWayBlock.findNext()).length() > 0) {
+			if (wayBlock.indexOf("No additional waypoints to display.") < 0) {
+				final Regex nameRex = new Regex(p.getProp("nameRex"));
+				final Regex koordRex = new Regex(p.getProp("koordRex"));
+				final Regex descRex = new Regex(p.getProp("descRex"));
+				final Regex typeRex = new Regex(p.getProp("typeRex"));
+				int counter = 0;
+				final Extractor exRowBlock = new Extractor(wayBlock, p.getProp("rowBlockExStart"), p.getProp("rowBlockExEnd"), 0, false);
+				String rowBlock;
+				rowBlock = exRowBlock.findNext();
+				while ((rowBlock = exRowBlock.findNext()).length() > 0) {
+					CacheHolder hd = null;
 
-				/*
-				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int
-				 * linePrefix=8; if(AddiBlock.length < linePrefix + 1) { (new
-				 * MessageBox(MyLocale.getMsg(5500,"Error"),
-				 * "GC changed table output \nCW must be changed too!",
-				 * FormBase.OKB)).execute(); break; } String
-				 * prefix=AddiBlock[linePrefix].trim();
-				 */
+					final Extractor exPrefix = new Extractor(rowBlock, p.getProp("prefixExStart"), p.getProp("prefixExEnd"), 0, true);
+					final String prefix = exPrefix.findNext();
+					String adWayPoint;
+					if (prefix.length() == 2)
+						adWayPoint = prefix + wayPoint.substring(2);
+					else
+						adWayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
+					counter++;
+					final int idx = profile.getCacheIndex(adWayPoint);
+					if (idx >= 0) {
+						// Creating new CacheHolder, but accessing old cache.xml file
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+						// Accessing Details reads file if not yet done
+						hd.getCacheDetails(true);
+					} else {
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+					}
+					hd.initStates(idx < 0);
 
-				// Extractor exPrefix=new
-				// Extractor(AddiBlock[linePrefix].trim(),p.getProp("prefixExStart"),p.getProp("prefixExEnd"),0,true);
-				Extractor exPrefix = new Extractor(rowBlock, 
-						p.getProp("prefixExStart"),
-						p.getProp("prefixExEnd"), 
-						0, true);
-				String prefix = exPrefix.findNext();
+					nameRex.search(rowBlock);
+					if (nameRex.didMatch()) {
+						hd.setCacheName(nameRex.stringMatched(1));
+					} else {
+						pref.log("check nameRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					}
 
-				String adWayPoint;
-				if (prefix.length() == 2)
-					adWayPoint = prefix + wayPoint.substring(2);
-				else
-					adWayPoint = MyLocale.formatLong(counter, "00")
-							+ wayPoint.substring(2);
-				counter++;
-				int idx = profile.getCacheIndex(adWayPoint);
-				if (idx >= 0) {
-					// Creating new CacheHolder, but accessing old cache.xml
-					// file
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-					hd.getCacheDetails(true); // Accessing Details reads file if
-												// not yet done
-				} else {
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-				}
-				hd.initStates(idx < 0);
-				nameRex.search(rowBlock);
-				if (nameRex.didMatch()) {
-					hd.setCacheName(nameRex.stringMatched(1));
-				} else {
-					pref.log("check nameRex in spider.def"
-							+ Preferences.NEWLINE + rowBlock);
-				}
-				koordRex.search(rowBlock);
-				typeRex.search(rowBlock);
-				if (koordRex.didMatch()) {
-					hd.setLatLon(koordRex.stringMatched(1));
-					koords_not_yet_found = false;
-				} else {
-					if (koords_not_yet_found)
-						pref.log("check koordRex in spider.def"
-								+ Preferences.NEWLINE + rowBlock);
-				}
-				if (typeRex.didMatch()) {
-					hd.setType(CacheType.gpxType2CwType("Waypoint|"
-							+ typeRex.stringMatched(1)));
-				} else {
-					pref.log("check typeRex in spider.def"
-							+ Preferences.NEWLINE + rowBlock);
-				}
-				rowBlock = exRowBlock.findNext();
-				descRex.search(rowBlock);
-				if (descRex.didMatch()) {
-					hd.getCacheDetails(false).setLongDescription(
-							descRex.stringMatched(1).trim());
-				} else {
-					pref.log("check descRex in spider.def"
-							+ Preferences.NEWLINE + rowBlock);
-				}
-				hd.setFound(is_found);
-				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-				hd.setHard(CacheTerrDiff.CW_DT_UNSET);
-				hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (idx < 0) {
-					cacheDB.add(hd);
-					hd.save();
-				} else {
-					CacheHolder cx = cacheDB.get(idx);
-					boolean checked = cx.is_Checked;
-					cx.initStates(false);
-					cx.update(hd);
-					cx.is_Checked = checked;
-					cx.save();
-				}
-				rowBlock = exRowBlock.findNext();
+					koordRex.search(rowBlock);
+					if (koordRex.didMatch()) {
+						hd.setPos(new CWPoint(koordRex.stringMatched(1)));
+						koords_not_yet_found = false;
+					} else {
+						if (koords_not_yet_found) {
+							koords_not_yet_found = false;
+							pref.log("check koordRex in spider.def" + Preferences.NEWLINE + rowBlock);
+						}
+					}
 
+					typeRex.search(rowBlock);
+					if (typeRex.didMatch()) {
+						hd.setType(CacheType.gpxType2CwType("Waypoint|" + typeRex.stringMatched(1)));
+					} else {
+						pref.log("check typeRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					}
+
+					rowBlock = exRowBlock.findNext();
+					descRex.search(rowBlock);
+					if (descRex.didMatch()) {
+						hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
+					} else {
+						pref.log("check descRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					}
+					hd.setFound(is_found);
+					hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+					hd.setHard(CacheTerrDiff.CW_DT_UNSET);
+					hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+
+					if (idx < 0) {
+						cacheDB.add(hd);
+						hd.save();
+					} else {
+						final CacheHolder cx = cacheDB.get(idx);
+						final boolean checked = cx.is_Checked;
+						cx.initStates(false);
+						cx.update(hd);
+						cx.is_Checked = checked;
+						cx.save();
+					}
+				}
 			}
 		}
 	}
 
-	public void getAttributes(String doc, CacheHolderDetail chD)
-			throws Exception {
-		Extractor attBlock = new Extractor(doc, p.getProp("attBlockExStart"), 
-				p.getProp("attBlockExEnd"), 0, true);
-		String atts = attBlock.findNext();
-		Extractor attEx = new Extractor(atts, p.getProp("attExStart"), 
-				p.getProp("attExEnd"), 0, true);
-		String attribute = attEx.findNext();
+	public void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
+		final Extractor attBlock = new Extractor(doc, p.getProp("attBlockExStart"), p.getProp("attBlockExEnd"), 0, true);
+		final String atts = attBlock.findNext();
+		final Extractor attEx = new Extractor(atts, p.getProp("attExStart"), p.getProp("attExEnd"), 0, true);
+		String attribute;
 		chD.attributes.clear();
-		while (!attEx.endOfSearch()) {
+		while ((attribute = attEx.findNext()).length() > 0) {
 			chD.attributes.add(attribute);
-			attribute = attEx.findNext();
 		}
 		chD.getParent().setAttribsAsBits(chD.attributes.getAttribsAsBits());
 	}
 
-	public static String fetchText(String address, boolean withResponseHeaders) {
-		ByteArray daten = fetch(address);
-		if (daten == null) return "";
-		try {
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			CharArray c_data;
-			c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			if (withResponseHeaders)
-				return getResponseHeaders(conn) + c_data.toString();
-			else
-				return c_data.toString();
-		} catch (IOException e) {
-			pref.log("IOException in fetch", e);
-			return null;
-		}
-	}
-
-	/**
-	 * Performs an initial fetch to a given address. 
-	 */
-	private static ByteArray fetch(String address) {
-		try {
-			if (pref.myproxy.length() > 0 && pref.proxyActive) {
-				pref.log("[fetch]:Using proxy: " + pref.myproxy + " / " + pref.myproxyport);
-			}
-			if (conn == null) { conn = new HttpConnection(address); }
-			else { conn.setUrl(address); }
-			conn.setRequestorProperty("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-			if (cookieSession.length() > 0) {conn.setRequestorProperty("Cookie", "ASP.NET_SessionId=" + cookieSession + "; userid=" + cookieID);};
-			conn.setRequestorProperty("Connection", "close");
-			conn.documentIsEncoded = true;
-			conn.connect();
-			if (conn.isOpen()) {
-				pref.log("[fetch]:Connect ok! " + address);
-				ByteArray daten = conn.readData();
-				conn.disconnect();
-				return daten;
-			}
-			pref.log("[fetch]:Connect not opened! " + address, null);
-			return null;
-		} catch (IOException ioex) {
-			pref.log("IOException in fetch", ioex);
-			return null;
-		}
-	}
-
-	/**
-	 * After a fetch to gc.com the next fetches have to use the post method.
-	 * This method does exactly that. Actually this method is generic in the
-	 * sense that it can be used to post to a URL using http post.
-	 */
-	private static String fetch_post(String address, String postData, boolean withResponseHeaders) {
-		try {
-			HttpConnection conn = new HttpConnection(address);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			conn.documentIsEncoded = true;
-			conn.setRequestorProperty("User-Agent","Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-			conn.setPostData(codec.encodeText(postData.toCharArray(), 0, postData.length(), true, null));
-			conn.setRequestorProperty("Content-Type", "application/x-www-form-urlencoded");
-			if (cookieSession.length() > 0) { conn.setRequestorProperty("Cookie", "ASP.NET_SessionId=" + cookieSession + "; userid=" + cookieID);};
-			conn.setRequestorProperty("Connection", "close");
-			Socket sock = conn.connect();
-			pref.log("[fetch_post]:Connect ok! " + address);
-			// ByteArray daten = conn.readData(sock);
-			CharArray c_data = conn.readText(sock, codec);
-			pref.log("[fetch_post]:Read data ok " + address);
-			// CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			sock.close();
-			if (withResponseHeaders)
-				return getResponseHeaders(conn) + c_data.toString();
-			else
-				return c_data.toString();
-		} catch (Exception e) {
-			pref.log("[fetch_post] Ignored Exception", e, true);
-		}
-		return "";
-	}
-
-	private static String getResponseHeaders(HttpConnection conn) {
-		PropertyList pl = conn.documentProperties;
-		if (pl != null) {
-			StringBuffer sb = new StringBuffer(1000);
-			boolean gotany = false;
-
-			for (int i = 0; i < pl.size(); i++) {
-				Property currProp = (Property) pl.get(i);
-				if (currProp.value != null) {
-					sb.append(currProp.name).append(": ")
-							.append(currProp.value).append("\r\n");
-					gotany = true;
-				}
-			}
-			if (gotany)
-				return sb.toString() + "\r\n";
-		}
-		return "";
-	}
-
 	final static String hex = ewe.util.TextEncoder.hex;
 
 	public String encodeUTF8URL(byte[] what) {
-		int max = what.length;
-		char[] dest = new char[6 * max]; // Assume each char is a UTF char and
-											// encoded into 6 chars
+		final int max = what.length;
+		// Assume each char is a UTF char and encoded into 6 chars
+		final char[] dest = new char[6 * max];
 		char d = 0;
 		for (int i = 0; i < max; i++) {
-			char c = (char) what[i];
-			if (c <= ' ' || c == '+' || c == '&' || c == '%' || c == '='
-					|| c == '|' || c == '{' || c == '}' || c > 0x7f) {
+			final char c = (char) what[i];
+			if (c <= ' ' || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c > 0x7f) {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);
@@ -3313,9 +3123,8 @@
 	}
 
 	/**
-	 * Load the bug id for a given name. This method is not ideal, as there are
-	 * sometimes several bugs with identical names but different IDs. Normally
-	 * the bug GUID is used which can be obtained from the cache page.<br>
+	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical
+	 * names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.<br>
 	 * Note that each bug has both an ID and a GUID.
 	 * 
 	 * @param name
@@ -3326,42 +3135,33 @@
 		String bugList;
 		try {
 			// infB.setInfo(oldInfoBox+"\nGetting bug: "+bug);
-			bugList = fetchText(p.getProp("getBugByName") + STRreplace.replace(SafeXML.clean(name), " ", "+"), false);
+			bugList = UrlFetcher.fetch(p.getProp("getBugByName") + STRreplace.replace(SafeXML.clean(name), " ", "+"));
 			pref.log("[getBugId] Fetched bugId: " + name);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugId] Could not fetch bug list" + name, ex);
 			bugList = "";
 		}
 		try {
-			if (bugList.equals("")
-					|| bugList.indexOf(p.getProp("bugNotFound")) >= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"), 
-						MyLocale.getMsg(6020, "Travelbug not found."),
-						FormBase.OKB)).execute();
+			if (bugList.equals("") || bugList.indexOf(p.getProp("bugNotFound")) >= 0) {
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(6020, "Travelbug not found."), FormBase.OKB)).execute();
 				return "";
 			}
 			if (bugList.indexOf(p.getProp("bugTotalRecords")) < 0) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(6021, "More than one travelbug found. Specify name more precisely."),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(6021, "More than one travelbug found. Specify name more precisely."), FormBase.OKB)).execute();
 				return "";
 			}
-			Extractor exGuid = new Extractor(bugList, 
-					p.getProp("bugGuidExStart"), 
-					p.getProp("bugGuidExEnd"), 
-					0, Extractor.EXCLUDESTARTEND); 
+			final Extractor exGuid = new Extractor(bugList, p.getProp("bugGuidExStart"), p.getProp("bugGuidExEnd"), 0, Extractor.EXCLUDESTARTEND);
 			// TODO Replace with spider.def
 			return exGuid.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugId] Error getting TB", ex);
 			return "";
 		}
 	}
 
 	/**
-	 * Fetch a bug's mission for a given GUID or ID. If the guid String is
-	 * longer than 10 characters it is assumed to be a GUID, otherwise it is an
-	 * ID.
+	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be
+	 * a GUID, otherwise it is an ID.
 	 * 
 	 * @param guid
 	 *            the guid or id of the travelbug
@@ -3372,27 +3172,22 @@
 		try {
 			// infB.setInfo(oldInfoBox+"\nGetting bug: "+bug);
 			if (guid.length() > 10)
-				bugDetails = fetchText(p.getProp("getBugByGuid") + guid, false);
+				bugDetails = UrlFetcher.fetch(p.getProp("getBugByGuid") + guid);
 			else
-				bugDetails = fetchText(p.getProp("getBugById") + guid, false);
+				bugDetails = UrlFetcher.fetch(p.getProp("getBugById") + guid);
 			pref.log("[getBugMissionByGuid] Fetched TB detailsById: " + guid);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByGuid] Could not fetch TB details " + guid, ex);
 			bugDetails = "";
 		}
 		try {
 			if (bugDetails.indexOf(p.getProp("bugNotFound")) >= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(6020, "Travelbug not found."),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(6020, "Travelbug not found."), FormBase.OKB)).execute();
 				return "";
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp("bugDetailsStart"), 
-					p.getProp("bugDetailsEnd"),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByGuid] Error getting TB " + guid, ex);
 			return "";
 		}
@@ -3408,9 +3203,9 @@
 	public String getBugMissionByTrackNr(String trackNr) {
 		String bugDetails;
 		try {
-			bugDetails = fetchText(p.getProp("getBugByTrackNr") + trackNr, false);
+			bugDetails = UrlFetcher.fetch(p.getProp("getBugByTrackNr") + trackNr);
 			pref.log("[getBugMissionByTrackNr] Fetched bug detailsByTrackNr: " + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByTrackNr] getBugByTrackNr " + trackNr, ex);
 			bugDetails = "";
 		}
@@ -3422,12 +3217,9 @@
 				// MessageBox.OKB)).execute();
 				return "";
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp("bugDetailsStart"), 
-					p.getProp("bugDetailsEnd"),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByTrackNr] TB Details, bugNotFound " + trackNr, ex);
 			return "";
 		}
@@ -3442,11 +3234,11 @@
 	 */
 	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
 		String bugDetails;
-		String trackNr = TB.getTrackingNo();
+		final String trackNr = TB.getTrackingNo();
 		try {
-			bugDetails = fetchText(p.getProp("getBugByTrackNr") + trackNr, false);
+			bugDetails = UrlFetcher.fetch(p.getProp("getBugByTrackNr") + trackNr);
 			pref.log("[getBugMissionAndNameByTrackNr] Fetched TB getBugByTrackNr: " + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionAndNameByTrackNr] Could not fetch bug details: " + trackNr, ex);
 			bugDetails = "";
 		}
@@ -3458,16 +3250,12 @@
 				// MessageBox.OKB)).execute();
 				return false;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
 			TB.setMission(exDetails.findNext());
-			Extractor exName = new Extractor(bugDetails, 
-					p.getProp("bugNameStart"), p.getProp("bugNameEnd"), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exName = new Extractor(bugDetails, p.getProp("bugNameStart"), p.getProp("bugNameEnd"), 0, Extractor.EXCLUDESTARTEND);
 			TB.setName(exName.findNext());
 			return true;
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionAndNameByTrackNr] TB Details, bugNotFound: " + trackNr, ex);
 			return false;
 		}
@@ -3478,11 +3266,9 @@
 			super();
 			try {
 				load(new FileInputStream(FileBase.getProgramDirectory() + "/spider.def"));
-			} catch (Exception ex) {
+			} catch (final Exception ex) {
 				pref.log("Failed to load spider.def from " + FileBase.getProgramDirectory(), ex);
-				(new MessageBox(MyLocale.getMsg(5500, "Error"), 
-						MyLocale.getMsg(5504, "Could not load 'spider.def'"),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5504, "Could not load 'spider.def'"), FormBase.OKB)).execute();
 			}
 		}
 
@@ -3496,11 +3282,9 @@
 		 *             When a key is requested which doesn't exist
 		 */
 		public String getProp(String key) throws Exception {
-			String s = super.getProperty(key);
+			final String s = super.getProperty(key);
 			if (s == null) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(5497, "Error missing tag in spider.def")+ ": " + key,
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5497, "Error missing tag in spider.def") + ": " + key, FormBase.OKB)).execute();
 				pref.log("Missing tag in spider.def: " + key);
 				throw new Exception("Missing tag in spider.def: " + key);
 			}
@@ -3534,25 +3318,32 @@
 				parse(r);
 				r.close();
 				rFIS.close();
-			} catch (Exception e) {
+			} catch (final Exception e) {
 			}
 			return _routePoints;
 		}
 
 		public void startElement(String name, AttributeList atts) {
-			if (name.equals("trkpt")|| name.equals("rtept")|| name.equals("gpxx:rpt")) {
-				double lat = Common.parseDouble(atts.getValue("lat"));
-				double lon = Common.parseDouble(atts.getValue("lon"));
-				TrackPoint tp = new TrackPoint(lat, lon);
+			if (name.equals("trkpt") || name.equals("rtept") || name.equals("gpxx:rpt")) {
+				final double lat = Common.parseDouble(atts.getValue("lat"));
+				final double lon = Common.parseDouble(atts.getValue("lon"));
+				final TrackPoint tp = new TrackPoint(lat, lon);
 				if (tp.isValid())
 					_routePoints.add(tp);
 				return;
 			}
+			if (name.equals("GeoPosition")) {
+				final double lat = Common.parseDouble(atts.getValue("Y"));
+				final double lon = Common.parseDouble(atts.getValue("X"));
+				final TrackPoint tp = new TrackPoint(lat, lon);
+				if (tp.isValid())
+					_routePoints.add(tp);
+				return;
+			}
 		}
 
 		public void endElement(String name) {
 
 		}
-
 	}
 }


Property changes on: branches/r1.2/src/CacheWolf/model
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/model/DefaultListModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/model/DefaultListModel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/model/DefaultListModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,49 @@
+package CacheWolf.model;
+
+import ewe.util.Vector;
+
+public  class DefaultListModel {
+
+	public Vector allItems;
+
+	public Vector shownItems = new Vector ();
+	public int sortCriteria;
+
+	public DefaultListModel() {
+		super();
+		allItems = new Vector ();
+		shownItems = new Vector();
+	}
+
+	/**
+	 * Creates the list of objects to be shown in the List. With this methode You can hide some objects.
+	 * Standardimplementation is to show all objects anytime. 
+	 *  
+	 */
+	public void createShowSet(){
+		shownItems.clear();
+		shownItems.addAll(allItems);
+	}
+	
+	/**
+	 * Adds an Object to this model to last position.
+	 * @param o
+	 */
+	public void add (Object o){
+		allItems.add(o);
+	}
+	
+	/**
+	 * Returns the number of elements in the showset of this model
+	 */
+	public int size(){
+		return shownItems.size();
+	}
+	
+	/**
+	 * Returns the Nth item in the showset of this model
+	 */
+	public Object get(int n){
+		return shownItems.get(n);
+	}
+}
\ No newline at end of file

Added: branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,33 @@
+package CacheWolf.model;
+
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugJourneyList;
+import ewe.util.Vector;
+
+public class TravelBugJourneyScreenModel {
+
+	public CacheHolder actualCache;
+	public TravelbugJourneyList allTravelbugJourneys;
+	public Vector shownTravelbugJourneys = new Vector ();
+	public boolean onlyLogged;
+	public int sortCriteria;
+
+	public void toggleOnlyLogged() {
+		onlyLogged = !onlyLogged;
+		createShowSet();
+		Global.getPref().travelbugShowOnlyNonLogged = onlyLogged;
+		Global.getPref().savePreferences();
+	}
+
+	public void createShowSet() {
+		shownTravelbugJourneys.clear();
+		for (int i = 0; i < allTravelbugJourneys.size(); i++) {
+			TravelbugJourney tbJourney = allTravelbugJourneys.getTBJourney(i);
+			if (!onlyLogged || (onlyLogged && (!tbJourney.getFromLogged() || !tbJourney.getToLogged()))) {
+				shownTravelbugJourneys.add(tbJourney);
+			}
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,8 @@
+package CacheWolf.model;
+
+public class TravelbugScreenModel extends DefaultListModel {
+
+	public void createShowSet() {
+	}
+
+}

Modified: branches/r1.2/src/CacheWolf/myTableControl.java
===================================================================
--- branches/r1.2/src/CacheWolf/myTableControl.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/myTableControl.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,30 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import CacheWolf.exp.OCLogExport;
 import CacheWolf.utils.CWWrapper;
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.IconAndText;
@@ -52,15 +53,17 @@
 import ewe.ui.mList;
 
 /**
- *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
+ * Implements the user interaction of the list view. Works together with myTableModel and TablePanel
  */
-public class myTableControl extends TableControl{
+public class myTableControl extends TableControl {
 
 	public Preferences pref;
 	public Profile profile;
 	public CacheDB cacheDB;
 	public TablePanel tbp;
 
+	public int clickedColumn = 0;
+
 	private MenuItem miOpen, miGoto, miCenter, miUnhideAddis;
 	private MenuItem miOpenOnline, miOpenOffline, miLogOnline, miOpenGmaps;
 	private MenuItem miDelete, miUpdate, miChangeBlack;
@@ -71,47 +74,47 @@
 	private Menu mSmall;
 
 	myTableControl(TablePanel tablePanel) {
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		cacheDB = profile.cacheDB;
 		pref = Global.getPref();
-		tbp =tablePanel;
+		tbp = tablePanel;
 		allowDragSelection = false; // allow only one row to be selected at one time
-	MenuItem[] mnuFull = {
-			miOpen = new MenuItem(MyLocale.getMsg(1021,"Open description")),
-			miGoto = new MenuItem(MyLocale.getMsg(1010,"Goto")),
-		  	miCenter = new MenuItem(MyLocale.getMsg(1019,"Center")),
-		  	miUnhideAddis = new MenuItem(MyLocale.getMsg(1042,"Unhide Addis")),
-		  	miSeparator = new MenuItem("-"),
-		  	miOpenOnline = new MenuItem(MyLocale.getMsg(1020,"Open in $browser online")),
-		  	miOpenOffline = new MenuItem(MyLocale.getMsg(1018,"Open in browser offline")),
-		  	miLogOnline = new MenuItem(MyLocale.getMsg(1052,"Log online in Browser")),
-		  	miOpenGmaps = new MenuItem(MyLocale.getMsg(1053,"Open in Google maps online")),
-		  	miSeparator,
-		  	miDelete = new MenuItem(MyLocale.getMsg(1012,"Delete selected")),
-		  	miUpdate = new MenuItem(MyLocale.getMsg(1014,"Update")),
-		  	miChangeBlack = new MenuItem(MyLocale.getMsg(1054, "Change Blacklist")),
-		  	miSeparator,
-		  	miTickAll = new MenuItem(MyLocale.getMsg(1015,"Select all")),
-		  	miUntickAll = new MenuItem(MyLocale.getMsg(1016,"De-select all"))
-	};
-  	mFull = new Menu(mnuFull, MyLocale.getMsg(1013,"With selection"));
-  	MenuItem[] mnuSmall = new MenuItem[8];
-  	mnuSmall[0] = miOpen;
-  	mnuSmall[1] = miGoto;
-  	mnuSmall[2] = miCenter;
-  	mnuSmall[3] = miUnhideAddis;
-  	mnuSmall[4] = miSeparator;
-  	mnuSmall[5] = miOpenOnline;
-  	mnuSmall[6] = miOpenOffline;
-  	mnuSmall[7] = miLogOnline;
-  	mSmall = new Menu(mnuSmall, MyLocale.getMsg(1013,"With selection"));
+		MenuItem[] mnuFull = { miOpen = new MenuItem(MyLocale.getMsg(1021, "Open description")), //
+				miGoto = new MenuItem(MyLocale.getMsg(1010, "Goto")), //
+				miCenter = new MenuItem(MyLocale.getMsg(1019, "Center")), //
+				miUnhideAddis = new MenuItem(MyLocale.getMsg(1042, "Unhide Addis")), //
+				miSeparator = new MenuItem("-"), //
+				miOpenOnline = new MenuItem(MyLocale.getMsg(1020, "Open in $browser online")), //
+				miOpenOffline = new MenuItem(MyLocale.getMsg(1018, "Open in browser offline")), //
+				miLogOnline = new MenuItem(MyLocale.getMsg(1052, "Log online in Browser")), //
+				miOpenGmaps = new MenuItem(MyLocale.getMsg(1053, "Open in Google maps online")), //
+				miSeparator, //
+				miDelete = new MenuItem(MyLocale.getMsg(1012, "Delete selected")), //
+				miUpdate = new MenuItem(MyLocale.getMsg(1014, "Update")), //
+				miChangeBlack = new MenuItem(MyLocale.getMsg(1054, "Change Blacklist")), //
+				miSeparator, //
+				miTickAll = new MenuItem(MyLocale.getMsg(1015, "Select all")), //
+				miUntickAll = new MenuItem(MyLocale.getMsg(1016, "De-select all")) //
+		};
+		mFull = new Menu(mnuFull, MyLocale.getMsg(1013, "With selection"));
+
+		MenuItem[] mnuSmall = new MenuItem[8];
+		mnuSmall[0] = miOpen;
+		mnuSmall[1] = miGoto;
+		mnuSmall[2] = miCenter;
+		mnuSmall[3] = miUnhideAddis;
+		mnuSmall[4] = miSeparator;
+		mnuSmall[5] = miOpenOnline;
+		mnuSmall[6] = miOpenOffline;
+		mnuSmall[7] = miLogOnline;
+		mSmall = new Menu(mnuSmall, MyLocale.getMsg(1013, "With selection"));
 	}
 
 	/** Full menu when listview includes checkbox */
 	public void setMenuFull() {
 		setMenu(mFull);
-//		if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
-//		   ((MenuItem)mFull.items.get(5)).modifiers|=MenuItem.Disabled;
+		// if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
+		// ((MenuItem)mFull.items.get(5)).modifiers|=MenuItem.Disabled;
 	}
 
 	public Menu getMenuFull() {
@@ -121,51 +124,60 @@
 	/** Small menu when listview does not include checkbox */
 	public void setMenuSmall() {
 		setMenu(mSmall);
-		//if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
-		//	   ((MenuItem)mSmall.items.get(5)).modifiers|=MenuItem.Disabled;
+		// if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
+		// ((MenuItem)mSmall.items.get(5)).modifiers|=MenuItem.Disabled;
 	}
 
-	public void penRightReleased(Point p){
-		if (cacheDB.size()>0) { // No context menu when DB is empty
+	public void penRightReleased(Point p) {
+		if (cacheDB.size() > 0) { // No context menu when DB is empty
 			adjustAddiHideUnhideMenu();
-			menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+			menuState.doShowMenu(p, true, null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 
 		}
 	}
 
-    public void penHeld(Point p){
-		if (cacheDB.size()>0) // No context menu when DB is empty
+	public void penHeld(Point p) {
+		if (cacheDB.size() > 0) // No context menu when DB is empty
 			adjustAddiHideUnhideMenu();
-			menuState.doShowMenu(p,true,null);
+		menuState.doShowMenu(p, true, null);
 	}
 
 	public void onKeyEvent(KeyEvent ev) {
-		if (ev.type == KeyEvent.KEY_PRESS && ev.target == this){
-			if ( (ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 1){ // <ctrl-a> gives 1, <ctrl-b> == 2
+		if (ev.type == KeyEvent.KEY_PRESS && ev.target == this) {
+			if ((ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 1) { // <ctrl-a> gives 1, <ctrl-b> == 2
 				// select all on <ctrl-a>
 				setSelectForAll(true);
 				ev.consumed = true;
-			}
-			else  {
+			} else {
 				Global.mainTab.clearDetails();
-				if (ev.key == IKeys.HOME) Global.mainTab.tbP.selectRow(0); //  cursorTo(0,cursor.x+listMode,true);
-				else if (ev.key == IKeys.END) Global.mainTab.tbP.selectRow(model.numRows-1); //cursorTo(model.numRows-1,cursor.x+listMode,true);
-				else if (ev.key == IKeys.PAGE_DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1)); //cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
-				else if (ev.key == IKeys.PAGE_UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
-				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
-				else if (ev.key == IKeys.DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1));
-				else if (ev.key == IKeys.UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
-				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y>=0 && cursor.y<tbp.myMod.numRows) Global.mainForm.cacheList.addCache(cacheDB.get(cursor.y).getWayPoint());
+				if (ev.key == IKeys.HOME)
+					Global.mainTab.tbP.selectRow(0); // cursorTo(0,cursor.x+listMode,true);
+				else if (ev.key == IKeys.END)
+					Global.mainTab.tbP.selectRow(model.numRows - 1); // cursorTo(model.numRows-1,cursor.x+listMode,true);
+				else if (ev.key == IKeys.PAGE_DOWN)
+					Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y + getOnScreen(null).height - 1, model.numRows - 1)); // cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't
+																																	// know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+				else if (ev.key == IKeys.PAGE_UP)
+					Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y - getOnScreen(null).height + 1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
+				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER)
+					Global.mainTab.select(Global.mainTab.descP);
+				else if (ev.key == IKeys.DOWN)
+					Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y + 1, model.numRows - 1));
+				else if (ev.key == IKeys.UP)
+					Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y - 1, 0));
+				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y >= 0 && cursor.y < tbp.myMod.numRows)
+					Global.mainForm.cacheList.addCache(cacheDB.get(cursor.y).getWayPoint());
 				else if (ev.key == IKeys.RIGHT) {
 					CacheHolder ch;
 					ch = cacheDB.get(tbp.getSelectedCache());
 					Global.mainTab.gotoP.setDestinationAndSwitch(ch);
-				}
-				else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f
-				else super.onKeyEvent(ev);
+				} else if (ev.key == 6)
+					MainMenu.search(); // (char)6 == ctrl + f
+				else
+					super.onKeyEvent(ev);
 			}
-		}
-		else super.onKeyEvent(ev);
+		} else
+			super.onKeyEvent(ev);
 	}
 
 	/** Set all caches either as selected or as deselected, depending on argument */
@@ -174,48 +186,49 @@
 		tbp.refreshTable();
 	}
 
-
 	/** always select a whole row */
-	public boolean isSelected(int pRow,int pCol) {
-		return pRow==selection.y;
+	public boolean isSelected(int pRow, int pCol) {
+		return pRow == selection.y;
 	}
+
 	private void callExternalProgram(String program, String parameter) {
 		// invalid path will be handled by try
 		try {
 			CWWrapper.exec(program, parameter); // maybe this works on some PDAs?
 		} catch (IOException ex) {
-			(new MessageBox(MyLocale.getMsg(321,"Error"),
-					MyLocale.getMsg(1034,"Cannot start "+program+"!") + "\n" + ex.toString() + "\n" +
-					MyLocale.getMsg(1035,"Possible reason:") + "\n" +
-					MyLocale.getMsg(1036,"A bug in ewe VM, please be") + "\n" +
-					MyLocale.getMsg(1037,"patient for an update"),FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1034, "Cannot start " + program + "!") + "\n" + ex.toString() + "\n" + MyLocale.getMsg(1035, "Possible reason:") + "\n" + MyLocale.getMsg(1036, "A bug in ewe VM, please be")
+					+ "\n" + MyLocale.getMsg(1037, "patient for an update"), FormBase.OKB)).execute();
 		}
 	}
 
-	public void popupMenuEvent(Object selectedItem){
-		if (selectedItem == null) return;
+	public void popupMenuEvent(Object selectedItem) {
+		String url;
+		CacheHolder mainCache;
+		CacheHolderDetail chD;
+		if (selectedItem == null)
+			return;
 		CacheHolder ch;
-		if (selectedItem == miTickAll){
+		if (selectedItem == miTickAll) {
 			setSelectForAll(true);
 		} else
 
-		if (selectedItem == miUntickAll){
+		if (selectedItem == miUntickAll) {
 			setSelectForAll(false);
 		} else
 
-		if (selectedItem == miDelete){
+		if (selectedItem == miDelete) {
 			Vm.showWait(true);
 			// Count # of caches to delete
-			int allCount=0;
-			int mainNonVisibleCount=0;
-			int addiNonVisibleCount=0;
-			int shouldDeleteCount=0;
-			boolean deleteFiltered=true;  // Bisheriges Verhalten
-			for(int i = cacheDB.size()-1; i >=0; i--){
+			int allCount = 0;
+			int mainNonVisibleCount = 0;
+			int addiNonVisibleCount = 0;
+			int shouldDeleteCount = 0;
+			boolean deleteFiltered = true; // Bisheriges Verhalten
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				CacheHolder currCache = cacheDB.get(i);
-				if ( currCache.is_Checked) {
+				if (currCache.is_Checked) {
 					allCount++;
-					if (! currCache.isVisible()) {
+					if (!currCache.isVisible()) {
 						if (currCache.isAddiWpt()) {
 							addiNonVisibleCount++;
 						} else {
@@ -226,62 +239,61 @@
 			}
 			// Warn if there are ticked but invisible caches - and ask if they should be deleted too.
 			shouldDeleteCount = allCount;
-			if (addiNonVisibleCount + mainNonVisibleCount > 0){
-				if ((new MessageBox(MyLocale.getMsg(144,"Warning"),
-						            MyLocale.getMsg(1029, "There are caches that are ticked but invisible.\n(Main caches: ") +
-						            	mainNonVisibleCount + MyLocale.getMsg(1030, ", additional Waypoints: ") +
-						            	addiNonVisibleCount+")\n" + MyLocale.getMsg(1031, "Delete them, too?"),
-						            	FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+			if (addiNonVisibleCount + mainNonVisibleCount > 0) {
+				if ((new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(1029, "There are caches that are ticked but invisible.\n(Main caches: ") + mainNonVisibleCount + MyLocale.getMsg(1030, ", additional Waypoints: ") + addiNonVisibleCount
+						+ ")\n" + MyLocale.getMsg(1031, "Delete them, too?"), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
 					deleteFiltered = true;
 				} else {
 					deleteFiltered = false;
 					shouldDeleteCount = allCount - mainNonVisibleCount - addiNonVisibleCount;
 				}
 			}
-			if (shouldDeleteCount>0) {
-				if ((new MessageBox(MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(1022, "Delete selected caches (") + shouldDeleteCount + MyLocale.getMsg(1028, ") ?"), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
-					DataMover dm=new DataMover();
+			if (shouldDeleteCount > 0) {
+				if ((new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(1022, "Delete selected caches (") + shouldDeleteCount + MyLocale.getMsg(1028, ") ?"), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+					DataMover dm = new DataMover();
 					myProgressBarForm pbf = new myProgressBarForm();
 					Handle h = new Handle();
-					int nDeleted=0;
-					int size=cacheDB.size();
-					pbf.setTask(h,"Be patient. Reading directory");
+					int nDeleted = 0;
+					int size = cacheDB.size();
+					pbf.setTask(h, "Be patient. Reading directory");
 					pbf.exec();
-					h.progress = (float)0.5;
+					h.progress = (float) 0.5;
 					h.changed();
-					String[] CacheFiles = new FileBugfix(profile.dataDir).list(null, FileBase.LIST_FILES_ONLY|FileBase.LIST_DONT_SORT);
-					pbf.setTask(h,MyLocale.getMsg(1012, "Delete selected"));
-					for(int i = size-1; i >=0; i--){// Start Counting down, as the size decreases with each deleted cache
+					String[] CacheFiles = new FileBugfix(profile.dataDir).list(null, FileBase.LIST_FILES_ONLY | FileBase.LIST_DONT_SORT);
+					pbf.setTask(h, MyLocale.getMsg(1012, "Delete selected"));
+					for (int i = size - 1; i >= 0; i--) {// Start Counting down, as the size decreases with each deleted cache
 						ch = cacheDB.get(i);
-						if(ch.is_Checked && (ch.isVisible() || deleteFiltered)) {
+						if (ch.is_Checked && (ch.isVisible() || deleteFiltered)) {
 							nDeleted++;
-							h.progress = ((float)nDeleted)/(float)allCount;
+							h.progress = ((float) nDeleted) / (float) allCount;
 							h.changed();
 							cacheDB.removeElementAt(i);
-							dm.deleteCacheFiles(ch.getWayPoint(),profile.dataDir,CacheFiles);
-							ch=null;
-							if (pbf.isClosed) break;
+							dm.deleteCacheFiles(ch.getWayPoint(), profile.dataDir, CacheFiles);
+							ch = null;
+							if (pbf.isClosed)
+								break;
 						}
 					}
 					pbf.exit(0);
-					tbp.myMod.numRows-=nDeleted;
-					profile.saveIndex(pref,true);
+					tbp.myMod.numRows -= nDeleted;
+					profile.saveIndex(pref, true);
 					tbp.refreshTable();
 				}
 			}
 			Vm.showWait(false);
 		} else
 
-		if (selectedItem == miUpdate){
+		if (selectedItem == miUpdate) {
 			MainMenu.updateSelectedCaches(tbp);
+			pref.setOldGCLanguage();
 		} else
-		
-		if (selectedItem == miChangeBlack){
+
+		if (selectedItem == miChangeBlack) {
 			Vm.showWait(true);
 			try {
-				for(int i = cacheDB.size()-1; i >=0; i--){
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					CacheHolder currCache = cacheDB.get(i);
-					if ( currCache.isVisible() && currCache.is_Checked) {
+					if (currCache.isVisible() && currCache.is_Checked) {
 						if (currCache.isAddiWpt()) {
 							// currCache.setBlack(!currCache.is_black());
 						} else {
@@ -295,18 +307,19 @@
 				tbp.refreshTable();
 			} finally {
 				Vm.showWait(false);
-			};
+			}
+			;
 		} else
 
-		if (selectedItem == miCenter){
+		if (selectedItem == miCenter) {
 			if (tbp.getSelectedCache() < 0) {
 				Global.getPref().log("[myTableControl:popupMenuEvent] getSelectedCache() < 0");
 				return;
 			}
 			CacheHolder thisCache = cacheDB.get(tbp.getSelectedCache());
-			CWPoint cp=new CWPoint(thisCache.getLatLon());
-			if (!cp.isValid()){
-				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
+			CWPoint cp = new CWPoint(thisCache.getPos());
+			if (!cp.isValid()) {
+				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
 				tmpMB.execute();
 			} else {
 				pref.setCurCentrePt(cp);
@@ -317,79 +330,120 @@
 			// This toggles the "showAddis" Flag
 			ch = cacheDB.get(tbp.getSelectedCache());
 			ch.setShowAddis(!ch.showAddis());
-			if (ch.addiWpts.size()>0) {
+			if (ch.addiWpts.size() > 0) {
 				tbp.refreshTable();
 			} else {
 				// This should never occur, as we check prior to activating the menu if the
 				// cache has addis. But just in case...
-				new MessageBox(MyLocale.getMsg(4201, "Info"), MyLocale.getMsg(1043, "This cache has no additional waypoints."),FormBase.OKB).execute();
+				new MessageBox(MyLocale.getMsg(4201, "Info"), MyLocale.getMsg(1043, "This cache has no additional waypoints."), FormBase.OKB).execute();
 			}
 		} else
 
-		if (selectedItem == miGoto){
+		if (selectedItem == miGoto) {
 			ch = cacheDB.get(tbp.getSelectedCache());
 			Global.mainTab.gotoP.setDestinationAndSwitch(ch);
 		} else
 
-		if (selectedItem == miOpenOnline){
-				ch = cacheDB.get(tbp.getSelectedCache());
-				CacheHolderDetail chD=ch.getCacheDetails(true);
-				if (chD != null) { callExternalProgram(pref.browser, chD.URL); }
+		if (selectedItem == miOpenOnline) {
+			ch = cacheDB.get(tbp.getSelectedCache());
+			mainCache = ch;
+			if (ch.isAddiWpt() && (ch.mainCache != null)) {
+				mainCache = ch.mainCache;
+			}
+			chD = mainCache.getCacheDetails(true);
+			url = chD.URL;
+			String wpName = mainCache.getOcCacheID();
+			if (clickedColumn == 14) {
+				if (mainCache.isOC()) {
+					String s = OC.getGCWayPoint(ch.getCacheOwner());
+					if (s.length() > 0)
+						url = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + s;
+				} else {
+					if (wpName.length() > 0) {
+						if (wpName.charAt(0) < 65)
+							wpName = mainCache.getOcCacheID().substring(1);
+						url = "http://" + OC.getOCHostName(wpName) + "/viewcache.php?wp=" + wpName;
+					}
+				}
+			}
+			if (url != null) {
+				callExternalProgram(pref.browser, url);
+			}
 		} else
 
 		if (selectedItem == miOpenGmaps) {
 			ch = cacheDB.get(tbp.getSelectedCache());
-			if (ch.pos.isValid()) {
-				String lat=""+ch.pos.getLatDeg(CWPoint.DD);
-				String lon=""+ch.pos.getLonDeg(CWPoint.DD);
-				String nameOfCache=ewe.net.URL.encodeURL(ch.cacheName,false).replace('#','N').replace('@','_');
-				String language=Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
-				if (!pref.language.equalsIgnoreCase("auto")) {language=pref.language;}
-				String url="http://maps.google."+language+"/maps?q="+nameOfCache+"@"+lat+","+lon;
+			if (ch.getPos().isValid()) {
+				String lat = "" + ch.getPos().getLatDeg(CWPoint.DD);
+				String lon = "" + ch.getPos().getLonDeg(CWPoint.DD);
+				String nameOfCache = UrlFetcher.encodeURL(ch.getCacheName(), false).replace('#', 'N').replace('@', '_');
+				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
+				if (!pref.language.equalsIgnoreCase("auto")) {
+					language = pref.language;
+				}
+				url = "http://maps.google." + language + "/maps?q=" + nameOfCache + "@" + lat + "," + lon;
 				callExternalProgram(pref.browser, url);
-				url="http://www.geocaching.com/map/default.aspx?lat="+lat+"&lng="+lon;
+				url = "http://www.geocaching.com/map/default.aspx?lat=" + lat + "&lng=" + lon;
 				callExternalProgram(pref.browser, url);
 			}
 		} else
 
 		if (selectedItem == miOpenOffline) {
-			ShowCacheInBrowser sc=new ShowCacheInBrowser();
+			ShowCacheInBrowser sc = new ShowCacheInBrowser();
 			sc.showCache(cacheDB.get(tbp.getSelectedCache()));
 		} else
 
-		if (selectedItem == miLogOnline){
-				ch = cacheDB.get(tbp.getSelectedCache());
-				CacheHolder mainCache = ch;
-				if (ch.isAddiWpt() && (ch.mainCache != null)) {
-					mainCache = ch.mainCache;
-				}
-				if (mainCache.isCacheWpt()) {
-					CacheHolderDetail chD=mainCache.getCacheDetails(true);
-						if (chD != null) {
-							String URL = "";
-							if (ch.isOC()) {
-								URL = chD.URL;
-								if (URL.indexOf("viewcache") >= 0) {
-									URL = STRreplace.replace(URL, "viewcache", "log");
+		if (selectedItem == miLogOnline) {
+			ch = cacheDB.get(tbp.getSelectedCache());
+			mainCache = ch;
+			url = "";
+			if (ch.isAddiWpt() && (ch.mainCache != null)) {
+				mainCache = ch.mainCache;
+			}
+			if (mainCache.isCacheWpt()) {
+				chD = mainCache.getCacheDetails(false);
+				if (chD != null) {
+					String notes = chD.getCacheNotes();
+					if (notes.length() > 0) {
+						Vm.setClipboardText(mainCache.getCacheStatus() + '\n' + "<br>" + notes);
+					}
+					if (mainCache.isOC()) {
+						url = chD.URL;
+						if (url.indexOf("viewcache") >= 0) {
+							url = STRreplace.replace(url, "viewcache", "log");
+						}
+					} else {
+						if (chD.OwnLogId.length() > 0) {
+							String wpName = mainCache.getOcCacheID();
+							if (wpName.length() > 0 && wpName.charAt(0) < 65) {
+								// OC log (already logged at GC but not at OC)
+								if (clickedColumn == 14) {
+									OCLogExport.doOneLog(mainCache);
+									tbp.refreshTable();
 								} else {
-									URL = "";
+									// open OC logpage with GC Logtext in Clipboard
+									Vm.setClipboardText(chD.OwnLog.getDate() + '\n' + "<br>" + chD.OwnLog.getMessage());
+									if (wpName.length() > 1) {
+										if (wpName.charAt(0) < 65) {
+											wpName = mainCache.getOcCacheID().substring(1);
+										}
+										url = "http://" + OC.getOCHostName(wpName) + "/log.php?wp=" + wpName;
+									}
 								}
-							} else {
-								URL = "http://www.geocaching.com/seek/log.aspx?ID=" + mainCache.GetCacheID();
 							}
+						} else
+							// GC log
+							url = "http://www.geocaching.com/seek/log.aspx?ID=" + mainCache.GetCacheID();
+					}
 
-							if (URL.length() > 0) {
-								String notes = chD.getCacheNotes();
-								if (notes.length() > 0) {
-									Vm.setClipboardText(notes);
-								}
-								callExternalProgram(pref.browser, URL);
-							}
-						}
+					if (url.length() > 0) {
+						callExternalProgram(pref.browser, url);
+					}
 				}
+			}
 		} else
 
-		if (selectedItem == miOpen){
+		if (selectedItem == miOpen) {
 			penDoubleClicked(null);
 		}
 
@@ -400,18 +454,16 @@
 	}
 
 	public void onEvent(Event ev) {
-		if (ev instanceof PenEvent && (ev.type == PenEvent.PEN_DOWN) ){
-			Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
-	    }
+		if (ev instanceof PenEvent && (ev.type == PenEvent.PEN_DOWN)) {
+			Global.mainTab.tbP.myMod.penEventModifiers = ((PenEvent) ev).modifiers;
+		}
 
 		super.onEvent(ev);
 	}
 
 	/**
-	 * Adjusting the menu item for hiding or unhiding additional waypoints. If the cache has no
-	 * addis, then the menu is deactivated. If it has addis, then the menu text is adapted according
-	 * to the current value of the property <code>showAddis()</code>.
-	 *
+	 * Adjusting the menu item for hiding or unhiding additional waypoints. If the cache has no addis, then the menu is deactivated. If it has addis, then the menu text is adapted according to the current value of the property <code>showAddis()</code>.
+	 * 
 	 */
 	public void adjustAddiHideUnhideMenu() {
 		if (tbp.getSelectedCache() < 0) {
@@ -437,97 +489,103 @@
 
 	// /////////////////////////////////////////////////
 	// Allow the caches to be dragged into a cachelist
-    ///////////////////////////////////////////////////
+	// /////////////////////////////////////////////////
 
 	IconAndText imgDrag;
 	String wayPoint;
 	int row;
 
 	public void startDragging(DragContext dc) {
-		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
-		 if (p==null) {super.startDragging(dc); return;}
-		 wayPoint=null;
-		 if (p.y>=0) {
+		Point p = cellAtPoint(dc.start.x, dc.start.y, null);
+		if (p == null) {
+			super.startDragging(dc);
+			return;
+		}
+		wayPoint = null;
+		if (p.y >= 0) {
 			if (!Global.mainForm.cacheListVisible) {
-				dc.cancelled=true;
+				dc.cancelled = true;
 				return;
 			}
-			 row=p.y;
-			 CacheHolder ch=cacheDB.get(p.y);
-			 wayPoint=ch.getWayPoint();
-			 imgDrag=new IconAndText();
-			 imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
-			 imgDrag.addColumn(ch.getWayPoint());
-			 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
-		 } else super.startDragging(dc);
-	 }
+			row = p.y;
+			CacheHolder ch = cacheDB.get(p.y);
+			wayPoint = ch.getWayPoint();
+			imgDrag = new IconAndText();
+			imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
+			imgDrag.addColumn(ch.getWayPoint());
+			dc.dragData = dc.startImageDrag(imgDrag, new Point(8, 8), this);
+		} else
+			super.startDragging(dc);
+	}
 
-	 public void stopDragging(DragContext dc) {
-		 if (wayPoint!=null && !dc.cancelled) {
-			 dc.stopImageDrag(true);
-			 Point p = Gui.getPosInParent(this,getWindow());
-			 p.x += dc.curPoint.x;
-			 p.y += dc.curPoint.y;
-			 Control c = getWindow().findChild(p.x,p.y);
-		     if (c instanceof mList && c.text.equals("CacheList")) {
-		    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
-		    		 c.repaintNow();
-		    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
-		    	 }
-		     }
-		     Global.mainTab.tbP.selectRow(row);
-		 }else super.stopDragging(dc);
-	 }
+	public void stopDragging(DragContext dc) {
+		if (wayPoint != null && !dc.cancelled) {
+			dc.stopImageDrag(true);
+			Point p = Gui.getPosInParent(this, getWindow());
+			p.x += dc.curPoint.x;
+			p.y += dc.curPoint.y;
+			Control c = getWindow().findChild(p.x, p.y);
+			if (c instanceof mList && c.text.equals("CacheList")) {
+				if (Global.mainForm.cacheList.addCache(wayPoint)) {
+					c.repaintNow();
+					((mList) c).makeItemVisible(((mList) c).itemsSize() - 1);
+				}
+			}
+			Global.mainTab.tbP.selectRow(row);
+		} else
+			super.stopDragging(dc);
+	}
 
-	 public void dragged(DragContext dc) {
-	 	if (wayPoint!=null)
-		   dc.imageDrag();
-	 	else
-	 		super.dragged(dc);
-	 }
+	public void dragged(DragContext dc) {
+		if (wayPoint != null)
+			dc.imageDrag();
+		else
+			super.dragged(dc);
+	}
 
-	 public void cursorTo(int pRow,int pCol,boolean selectNew) {
-		if (pRow != -2 && pCol != -2 && !canSelect(pRow,pCol)) return;
-		cursor.set(pCol,pRow);
-		if (selectNew){
+	public void cursorTo(int pRow, int pCol, boolean selectNew) {
+		if (pRow != -2 && pCol != -2 && !canSelect(pRow, pCol))
+			return;
+		cursor.set(pCol, pRow);
+		if (selectNew) {
 			clearSelectedCells(oldExtendedSelection);
-			paintCells(null,oldExtendedSelection);
-			if (pRow != -2 && pCol != -2){
-				if (scrollToVisible(pRow,pCol)) repaintNow();
-				addToSelection(Rect.buff.set(0,pRow,model.numCols,1),true);
-				//fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
+			paintCells(null, oldExtendedSelection);
+			if (pRow != -2 && pCol != -2) {
+				if (scrollToVisible(pRow, pCol))
+					repaintNow();
+				addToSelection(Rect.buff.set(0, pRow, model.numCols, 1), true);
+				// fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
 				clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
-				if (clickMode) clicked(pRow,pCol);
+				if (clickMode)
+					clicked(pRow, pCol);
 				clickedFlags = 0;
 			}
 		}
-	 }
+	}
 
-	 /**
-	  * this is only necessary to hinder the user to unselect
-	  */
-	 public void penReleased(Point p,boolean isDouble)
-	 {
-		 Point p2 = cellAtPoint(p.x,p.y,null);
-		 super.penReleased(p, isDouble);
-		 Rect sel = getSelection(null);
-		 if ((sel.height == 0 || sel.height == 0) && p2 != null) cursorTo(p2.y,p2.x, true); // if the selection is gone -> reselect it
+	/**
+	 * this is only necessary to hinder the user to unselect
+	 */
+	public void penReleased(Point p, boolean isDouble) {
+		Point p2 = cellAtPoint(p.x, p.y, null);
+		super.penReleased(p, isDouble);
+		Rect sel = getSelection(null);
+		if ((sel.height == 0 || sel.height == 0) && p2 != null)
+			cursorTo(p2.y, p2.x, true); // if the selection is gone -> reselect it
 
-	 }
+	}
 
-	 class myProgressBarForm extends ProgressBarForm {
+	class myProgressBarForm extends ProgressBarForm {
 
-		 boolean isClosed=false;
+		boolean isClosed = false;
 
-		 protected boolean canExit(int exitCode) {
-			isClosed=true;
+		protected boolean canExit(int exitCode) {
+			isClosed = true;
 			return true;
-		 }
+		}
 
-	 }
+	}
 
-
-
 	public Menu getMenuSmall() {
 		return mSmall;
 	}

Modified: branches/r1.2/src/CacheWolf/myTableModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/myTableModel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/myTableModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Color;
@@ -31,7 +31,6 @@
 import ewe.fx.Image;
 import ewe.fx.Point;
 import ewe.fx.mImage;
-import ewe.sys.Convert;
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
@@ -41,9 +40,7 @@
 import ewe.util.Vector;
 
 /**
- * Table model used to display the cache list. Used by the table control in the
- * first panel of CacheWolf. 20061212 salzkammergut, patch to speed up
- * scrolling, Used MyLocale
+ * Table model used to display the cache list. Used by the table control in the first panel of CacheWolf. 20061212 salzkammergut, patch to speed up scrolling, Used MyLocale
  */
 public class myTableModel extends TableModel {
 
@@ -66,30 +63,17 @@
 	/** The max number of columns in the list view */
 	public static final int N_COLUMNS = 20;
 	/**
-	 * How the columns are mapped onto the list view. If colMap[i]=j, it means
-	 * that the element j (as per the list below) is visible in column i.
-	 * [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name,
-	 * [6]coordinates, [7]owner, [8]datehidden, [9]status, [10]distance,
-	 * [11]bearing, [12] Size, [13] # of OC recommend. [14] OC index, [15]
-	 * Solver exists, [16] Note exists, [17] # Additionals, [18] # DNF [19] Last
-	 * Sync Date
+	 * How the columns are mapped onto the list view. If colMap[i]=j, it means that the element j (as per the list below) is visible in column i. [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates, [7]owner, [8]datehidden,
+	 * [9]status, [10]distance, [11]bearing, [12] Size, [13] # of OC recommend. [14] OC index, [15] Solver exists, [16] Note exists, [17] # Additionals, [18] # DNF [19] Last Sync Date
 	 * 
-	 * Attention: When adding columns here, also add a default width in
-	 * Preferences.listColWidth
+	 * Attention: When adding columns here, also add a default width in Preferences.listColWidth
 	 */
 	private int[] colMap;
 	/** The column widths corresponding to the list of columns above */
 	private int[] colWidth;
-	private String[] colName = { " ", "?", MyLocale.getMsg(1000, "D"),
-			MyLocale.getMsg(1001, "T"), MyLocale.getMsg(1002, "Waypoint"),
-			"Name", MyLocale.getMsg(1004, "Location"),
-			MyLocale.getMsg(1005, "Owner"), MyLocale.getMsg(1006, "Hidden"),
-			MyLocale.getMsg(1007, "Status"), MyLocale.getMsg(1008, "Dist"),
-			MyLocale.getMsg(1009, "Bear"), MyLocale.getMsg(1017, "S"),
-			MyLocale.getMsg(1026, "#Rec"), MyLocale.getMsg(1027, "OC-IDX"),
-			MyLocale.getMsg(1038, "S"), MyLocale.getMsg(1040, "N"),
-			MyLocale.getMsg(1047, "A"), MyLocale.getMsg(1049, "DNF"),
-			MyLocale.getMsg(1051, "Last synced") };
+	private String[] colName = { " ", "?", MyLocale.getMsg(1000, "D"), MyLocale.getMsg(1001, "T"), MyLocale.getMsg(1002, "Waypoint"), "Name", MyLocale.getMsg(1004, "Location"), MyLocale.getMsg(1005, "Owner"), MyLocale.getMsg(1006, "Hidden"),
+			MyLocale.getMsg(1007, "Status"), MyLocale.getMsg(1008, "Dist"), MyLocale.getMsg(1009, "Bear"), MyLocale.getMsg(1017, "S"), MyLocale.getMsg(1026, "#Rec"), MyLocale.getMsg(1027, "OC-IDX"), MyLocale.getMsg(1038, "S"),
+			MyLocale.getMsg(1040, "N"), MyLocale.getMsg(1047, "A"), MyLocale.getMsg(1049, "DNF"), MyLocale.getMsg(1051, "Last synced") };
 
 	private static Image noFindLogs[] = new Image[4];
 	public static mImage red, blue, yellow; // skull, green
@@ -106,8 +90,7 @@
 	private mImage picHasSolver, picHasNotes;
 	private mImage[] sizePics = new mImage[CacheSize.CW_TOTAL_SIZE_IMAGES];
 	/**
-	 * This is the modifier (Shift & Control key status) for Pen Events it is
-	 * set in myTableControl.onEvent
+	 * This is the modifier (Shift & Control key status) for Pen Events it is set in myTableControl.onEvent
 	 */
 	public int penEventModifiers;
 	public myTableControl tcControl;
@@ -174,10 +157,8 @@
 	 * 
 	 */
 	public void setColumnNamesAndWidths() {
-		colMap = TableColumnChooser.str2Array(Global.getPref().listColMap, 0,
-				N_COLUMNS - 1, 0, -1);
-		colWidth = TableColumnChooser.str2Array(Global.getPref().listColWidth,
-				10, 1024, 50, colMap.length);
+		colMap = TableColumnChooser.str2Array(Global.getPref().listColMap, 0, N_COLUMNS - 1, 0, -1);
+		colWidth = TableColumnChooser.str2Array(Global.getPref().listColWidth, 10, 1024, 50, colMap.length);
 		numCols = colMap.length;
 		clearCellAdjustments();
 		// If the displayed columns include the checkbox, we use the full menu
@@ -188,8 +169,7 @@
 	}
 
 	/**
-	 * Return the column widths as a comma delimited string for storing in the
-	 * preferences
+	 * Return the column widths as a comma delimited string for storing in the preferences
 	 * 
 	 * @return
 	 */
@@ -261,14 +241,12 @@
 	}
 
 	/**
-	 * Method to set the row color of the table displaying the cache list,
-	 * depending on different flags set to the cache.
+	 * Method to set the row color of the table displaying the cache list, depending on different flags set to the cache.
 	 */
 	/*
 	 * (non-Javadoc)
 	 * 
-	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean,
-	 * ewe.ui.TableCellAttributes)
+	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean, ewe.ui.TableCellAttributes)
 	 */
 	public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
 		ta = super.getCellAttributes(row, col, isSelected, ta);
@@ -320,7 +298,7 @@
 					lastColorFG.set(ta.foreground);
 					lastRow = row;
 				} catch (Exception e) {
-					Global.getPref().log("[myTableModel:getCellAttributes]Ignored row="+row+" lastRow="+lastRow,e, true);
+					Global.getPref().log("[myTableModel:getCellAttributes]Ignored row=" + row + " lastRow=" + lastRow, e, true);
 				}
 				;
 			} else {
@@ -329,8 +307,7 @@
 				ta.fillColor = lastColorBG;
 				ta.foreground = lastColorFG;
 			}
-		} else if (row == -1 && colMap[col] == 0
-				&& Global.getProfile().showBlacklisted()) {
+		} else if (row == -1 && colMap[col] == 0 && Global.getProfile().showBlacklisted()) {
 			ta.fillColor = Color.Black;
 			lastColorBG.set(ta.fillColor);
 		}
@@ -338,22 +315,17 @@
 	}
 
 	/**
-	 * Determines the arithmetic mean value of two colors and stores the result
-	 * in the third color.
+	 * Determines the arithmetic mean value of two colors and stores the result in the third color.
 	 * 
 	 * @param colorMerged
 	 *            Resulting color
 	 * @param colorA
-	 *            First color to merge. May be same object as
-	 *            <code>colorMerged</code>.
+	 *            First color to merge. May be same object as <code>colorMerged</code>.
 	 * @param colorB
-	 *            Second color to merge. May be same object as
-	 *            <code>colorMerged</code>.
+	 *            Second color to merge. May be same object as <code>colorMerged</code>.
 	 */
 	private void mergeColor(Color colorMerged, Color colorA, Color colorB) {
-		colorMerged.set((colorA.getRed() + colorB.getRed()) / 2, (colorA
-				.getGreen() + colorB.getGreen()) / 2,
-				(colorA.getBlue() + colorB.getBlue()) / 2);
+		colorMerged.set((colorA.getRed() + colorB.getRed()) / 2, (colorA.getGreen() + colorB.getGreen()) / 2, (colorA.getBlue() + colorB.getBlue()) / 2);
 	}
 
 	public int calculateRowHeight(int row) {
@@ -370,9 +342,7 @@
 	}
 
 	/**
-	 * Need to override this method with a null return to avoid getCellData
-	 * being called twice on each access to a cell. For further reference see
-	 * the Ewe source code.
+	 * Need to override this method with a null return to avoid getCellData being called twice on each access to a cell. For further reference see the Ewe source code.
 	 * 
 	 * @author skg
 	 */
@@ -432,8 +402,7 @@
 					return ch.getWayPoint();
 				case 5: // Cachename
 					// Fast return for majority of case
-					if (!showExtraWptInfo
-							|| (ch.has_bugs() == false && ch.getNoFindLogs() == 0))
+					if (!showExtraWptInfo || (ch.has_bugs() == false && ch.getNoFindLogs() == 0))
 						return ch.getCacheName();
 					// Now need more checks
 					IconAndText wpVal = new IconAndText();
@@ -448,7 +417,7 @@
 					wpVal.addColumn(ch.getCacheName());
 					return wpVal;
 				case 6: // Location
-					return ch.getLatLon();
+					return ch.getPos().toString();
 				case 7: // Owner
 					return ch.getCacheOwner();
 				case 8: // Date hidden
@@ -465,13 +434,14 @@
 					} else {
 						return sizePics[CacheSize.guiSizeImageId(ch.getCacheSize())];
 					}
-				case 13: // OC number of recommendations
-					 return ch.getRecommended();
-          
-				case 14: // OC rating
-					if (ch.isOC())
-						return Convert.formatInt(ch.recommendationScore);
-					return null;
+				case 13: // OC / gcvote Bewertung
+					return ch.getRecommended();
+				case 14: //
+					if (ch.getWayPoint().startsWith("GC"))
+						return ch.getOcCacheID();
+					else {
+						return OC.getGCWayPoint(ch.getCacheOwner());
+					}
 				case 15: // Is solver filled?
 					if (ch.hasSolver())
 						return picHasSolver;
@@ -497,10 +467,9 @@
 				case 19: // Last sync date
 					if (!ch.getLastSync().equals("")) {
 						try {
-							lastSyncWorker.parse(ch.getLastSync(),
-									"yyyyMMddHHmmss");
+							lastSyncWorker.parse(ch.getLastSync(), "yyyyMMddHHmmss");
 						} catch (IllegalArgumentException e) {
-							Global.getPref().log("Could not parse 'lastSyncDate': "	+ ch.getLastSync() + ". Reset to empty.", e);
+							Global.getPref().log("Could not parse 'lastSyncDate': " + ch.getLastSync() + ". Reset to empty.", e);
 							ch.setLastSync("");
 						}
 						return lastSyncWorker.format("yyyy-MM-dd HH:mm");
@@ -522,17 +491,18 @@
 			return false;
 		try {
 			// Check whether the click is on the checkbox image
+			tcControl.clickedColumn = colMap[cell.x];
 			if (cell.y >= 0 && colMap[cell.x] == 0) {
 				Global.getProfile().selectionChanged = true;
 				if ((penEventModifiers & IKeys.SHIFT) > 0) {
-					if (tcControl.cursor.y >= 0) { // Second row being marked
-													// with shift key pressed
+					if (tcControl.cursor.y >= 0) {
+						// Second row being marked with shift key pressed
 						if (tcControl.cursor.y < cell.y)
 							toggleSelect(tcControl.cursor.y + 1, cell.y, cell.x);
 						else
 							toggleSelect(cell.y, tcControl.cursor.y - 1, cell.x);
-					} else { // Remember this row as start of range, but don't
-								// toggle yet
+					} else {
+						// Remember this row as start of range, but don't toggle yet
 					}
 				} else { // Single row marked
 					toggleSelect(cell.y, cell.y, cell.x);
@@ -551,7 +521,7 @@
 				retval = true;
 			}
 		} catch (NullPointerException npex) {
-			Global.getPref().log("[myTableModel:Penpressed]",npex,true);
+			Global.getPref().log("[myTableModel:Penpressed]", npex, true);
 			Vm.showWait(false);
 		}
 		return retval;
@@ -574,7 +544,7 @@
 			CacheHolder ch = null;
 			if ((a != null) && (a.y >= 0) && (a.y < cacheDB.size()))
 				ch = cacheDB.get(a.y);
-			cacheDB.sort(new MyComparer(cacheDB, sortedBy, numRows),!sortAscending);
+			cacheDB.sort(new MyComparer(cacheDB, sortedBy, numRows), !sortAscending);
 			updateRows();
 			// = cacheDB.rebuild(sortedVector of ch,
 			// invisibleVector of ch)
@@ -591,9 +561,7 @@
 	}
 
 	/**
-	 * Toggle the select status for a group of caches If from==to, the addi
-	 * Waypoints are also toggled if the cache is a main waypoint If from!=to,
-	 * each cache is toggled irrespective of its type (main or addi)
+	 * Toggle the select status for a group of caches If from==to, the addi Waypoints are also toggled if the cache is a main waypoint If from!=to, each cache is toggled irrespective of its type (main or addi)
 	 * 
 	 * @param from
 	 *            index of first cache to toggle

Modified: branches/r1.2/src/CacheWolf/navi/Area.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/Area.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/Area.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -31,32 +31,37 @@
 	 public final static int NOT_ON_EDGE = -1;
 	 public final static int AT_TOP_EDGE = 1;
 	 public final static int AT_RIGHT_EDGE = 2;
-	 public final static int AT_BUTTOM_EDGE = 3;
+	 public final static int AT_BOTTOM_EDGE = 3;
 	 public final static int AT_LEFT_EDGE = 4;
 	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
 */
 	 public CWPoint topleft;
-	 public CWPoint buttomright;
+	 public CWPoint bottomright;
 	 
 	 public Area() {
 		 topleft = new CWPoint();
-		 buttomright = new CWPoint();
+		 bottomright = new CWPoint();
 	 }
 
 	 public Area(TrackPoint tl, TrackPoint br){
 		 topleft = new CWPoint(tl);
-		 buttomright = new CWPoint(br);
+		 bottomright = new CWPoint(br);
 	 }
+	 
+	 public Area(CWPoint tl, CWPoint br) {
+		 topleft = tl;
+		 bottomright = br;
+	 }
 
 	 public final boolean isInBound(TrackPoint p) {
 		 if (topleft.latDec >= p.latDec && topleft.lonDec <= p.lonDec 
-				 && buttomright.latDec <= p.latDec && buttomright.lonDec >= p.lonDec) return true;
+				 && bottomright.latDec <= p.latDec && bottomright.lonDec >= p.lonDec) return true;
 		 else return false;
 	 }
 		
 	 public final boolean isInBound(double lat, double lon) {
 		 if (topleft.latDec >= lat && topleft.lonDec <= lon
-				 && buttomright.latDec <= lat && buttomright.lonDec >= lon) return true;
+				 && bottomright.latDec <= lat && bottomright.lonDec >= lon) return true;
 		 else return false;
 	 }
 
@@ -66,24 +71,24 @@
 	 * @return
 	 */
 	 public final boolean isInBound(Area a) {
-		 return (isInBound(a.topleft) && isInBound(a.buttomright));
+		 return (isInBound(a.topleft) && isInBound(a.bottomright));
 	 }
 	 
 	 
 	 public final boolean isOverlapping(Area a) {
 		 return ! ( // test if not overlapping and invert the result, see http://www.geoclub.de/viewtopic.php?f=40&t=38364&p=607033#p607033
-				    this.buttomright.latDec > a.topleft.latDec
-				 || this.topleft.latDec     < a.buttomright.latDec
-				 || this.buttomright.lonDec < a.topleft.lonDec
-				 || this.topleft.lonDec     > a.buttomright.lonDec);
+				    this.bottomright.latDec > a.topleft.latDec
+				 || this.topleft.latDec     < a.bottomright.latDec
+				 || this.bottomright.lonDec < a.topleft.lonDec
+				 || this.topleft.lonDec     > a.bottomright.lonDec);
 	 }
 	 
 	 /* not used at the moment
 	  public boolean equals(Area a) {
 		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) < edgeTolerance 
 				 && java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) < edgeTolerance
-				 && java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) < edgeTolerance
-				 && java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) < edgeTolerance )
+				 && java.lang.Math.abs(bottomright.latDec - a.bottomright.latDec) < edgeTolerance
+				 && java.lang.Math.abs(bottomright.lonDec - a.bottomright.lonDec) < edgeTolerance )
 			 return true;
 		 else return false;
 	 }
@@ -93,19 +98,19 @@
 	 public int getEdge(CWPoint tl, CWPoint br) {
 		 if (java.lang.Math.abs(topleft.latDec - br.latDec) < edgeTolerance 
 				 && java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
-				 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
+				 && java.lang.Math.abs(bottomright.lonDec - br.lonDec) < edgeTolerance)
 			 return AT_TOP_EDGE;
 			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.lonDec - tl.lonDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+					 && java.lang.Math.abs(bottomright.lonDec - tl.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(bottomright.latDec - br.latDec) < edgeTolerance)
 				 return AT_RIGHT_EDGE;
 			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.latDec - tl.latDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
-				 return AT_BUTTOM_EDGE;
+					 && java.lang.Math.abs(bottomright.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(bottomright.lonDec - br.lonDec) < edgeTolerance)
+				 return AT_BOTTOM_EDGE;
 			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
 					 && java.lang.Math.abs(topleft.lonDec - br.lonDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+					 && java.lang.Math.abs(bottomright.latDec - br.latDec) < edgeTolerance)
 				 return AT_LEFT_EDGE;
 			 return NOT_ON_EDGE;
 	 }
@@ -117,7 +122,7 @@
 	  */
 	 public final String getEasyFindString() {
 		 String ul = getEasyFindString(topleft, 30);
-		 String br = getEasyFindString(buttomright, 30);
+		 String br = getEasyFindString(bottomright, 30);
 		 int i;
 		 for (i=0; i<br.length(); i++ ) {
 			 if (ul.charAt(i) != br.charAt(i)) break;
@@ -153,10 +158,10 @@
 	 }
 	 
 	 public String toString() {
-		 return topleft.toString() + ", " + buttomright.toString();
+		 return topleft.toString() + ", " + bottomright.toString();
 	 }
 	 
 	 public final CWPoint getCenter() {
-		 return new CWPoint((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2);
+		 return new CWPoint((topleft.latDec + bottomright.latDec)/2, (topleft.lonDec + bottomright.lonDec)/2);
 	 }
 }

Modified: branches/r1.2/src/CacheWolf/navi/AreaList.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/AreaList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/AreaList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -38,28 +38,28 @@
 /*
 	 public AreaList(int s) {super(s);}
 
-	 public void addArea(CWPoint topleft, CWPoint buttomright) {
+	 public void addArea(CWPoint topleft, CWPoint bottomright) {
 		 Area tp = getArea(topleft);
-		 if (tp != null && tp.isInBound(buttomright)) return; // area already completly in list
-		 int edge = tp.getEdge(topleft, buttomright);
+		 if (tp != null && tp.isInBound(bottomright)) return; // area already completly in list
+		 int edge = tp.getEdge(topleft, bottomright);
 		 switch (edge) {
 		 case Area.AT_TOP_EDGE: tp.topleft.latDec = topleft.latDec; break;
-		 case Area.AT_RIGHT_EDGE: tp.buttomright.lonDec = buttomright.lonDec; break;
-		 case Area.AT_BUTTOM_EDGE: tp.buttomright.latDec = buttomright.latDec; break;
+		 case Area.AT_RIGHT_EDGE: tp.bottomright.lonDec = bottomright.lonDec; break;
+		 case Area.AT_BOTTOM_EDGE: tp.bottomright.latDec = bottomright.latDec; break;
 		 case Area.AT_LEFT_EDGE: tp.topleft.lonDec = topleft.lonDec; break;
-		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, buttomright));
+		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, bottomright));
 		 }
 	 }
 
-	 public boolean AreaIsCovered(CWPoint topleft, CWPoint buttomright) {
+	 public boolean AreaIsCovered(CWPoint topleft, CWPoint bottomright) {
 		 Area tp = getArea(topleft);
-		 if (tp != null && tp.isInBound(buttomright)) return true; // area already completly in list
+		 if (tp != null && tp.isInBound(bottomright)) return true; // area already completly in list
 		 else return false;
 
 	 }
 
 	 public void addArea(Area a) {
-		 addArea(a.topleft, a.buttomright);
+		 addArea(a.topleft, a.bottomright);
 	 }
 
 	 public static AreaList joinAreas(AreaList al){

Modified: branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import org.json.JSONArray;
@@ -40,19 +40,18 @@
 import ewe.sys.TimerProc;
 import ewe.sys.Vm;
 
-
 /**
  * @author Kalle
- * Class for decoding NMEA sentences
+ *         Class for decoding NMEA sentences
  */
 
-public class CWGPSPoint extends CWPoint implements TimerProc{
+public class CWGPSPoint extends CWPoint implements TimerProc {
 	public static final int LOGNMEA = 0x01;
-	public static final int LOGRAW  = 0x02;
-	public static final int LOGALL  = LOGNMEA|LOGRAW;
+	public static final int LOGRAW = 0x02;
+	public static final int LOGALL = LOGNMEA | LOGRAW;
 
 	public double Speed; // Speed: km/h
-	public double Bear;	// Bearing
+	public double Bear; // Bearing
 	public String Time; // Time: HHmmss.SS
 	public String Date; // Date: ddMMyy
 	public int Fix; // Fix (0: none, 1: GPS, 2: differential GPS). See getFix() for more possible values.
@@ -61,7 +60,7 @@
 	public double HDOP; // Horizontal dilution of precision
 	public double Alt; // Altitude in meters
 
-	//Logging
+	// Logging
 	int logTimer = 0;
 	int logFlag = 0;
 	boolean writeLog = false;
@@ -69,15 +68,14 @@
 	FileWriter logFile;
 	String lastStrExamined = "";
 
-	//Regex numberMatcher = new Regex("\\-?\\d+");
+	// Regex numberMatcher = new Regex("\\-?\\d+");
 
-	public CWGPSPoint()
-	{
+	public CWGPSPoint() {
 		super();
 		this.Speed = 0;
 		this.Bear = 0;
 		this.Time = "";
-		this.Date="";
+		this.Date = "";
 		this.Fix = 0;
 		this.numSat = 0;
 		this.numSatsInView = 0;
@@ -85,29 +83,32 @@
 		this.HDOP = 0;
 	}
 
-
-	public double getSpeed(){
+	public double getSpeed() {
 		return this.Speed;
 	}
 
-	public double getBear (){
+	public double getBear() {
 		return this.Bear;
 	}
-	public String getTime(){
+
+	public String getTime() {
 		return this.Time;
 	}
 
 	/**
-	 * @return > 0: fixed <br> 0: not fixed <br> -1: no data from serial port <br> -2 data from serial port could not be interpreted
+	 * @return > 0: fixed <br>
+	 *         0: not fixed <br>
+	 *         -1: no data from serial port <br>
+	 *         -2 data from serial port could not be interpreted
 	 */
-	public int getFix(){
+	public int getFix() {
 		return this.Fix;
 	}
 
 	/**
 	 * this method should be called, if COM-Port is closed
 	 */
-	public void noData(){
+	public void noData() {
 		this.Fix = 0;
 		this.numSat = 0;
 		this.HDOP = 0;
@@ -116,7 +117,7 @@
 	/**
 	 * this method should be called, if not data is coming from COM-Port but is expected to come
 	 */
-	public void noDataError(){
+	public void noDataError() {
 		this.Fix = -1;
 		this.numSat = -1;
 		this.HDOP = -1;
@@ -125,13 +126,13 @@
 	/**
 	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
 	 */
-	public void noInterpretableData(){
+	public void noInterpretableData() {
 		this.Fix = -2;
 		this.numSat = -2;
 		this.HDOP = -2;
 	}
 
-	public void ticked(int timerId, int elapsed){
+	public void ticked(int timerId, int elapsed) {
 		if (timerId == logTimer) {
 			writeLog = true;
 		}
@@ -139,23 +140,26 @@
 	}
 
 	/**
-	 *
-	 * @param logFileDir directory for logfile
-	 * @param seconds	 intervall for writing to logfile
-	 * @param flag		 level of logging
+	 * 
+	 * @param logFileDir
+	 *            directory for logfile
+	 * @param seconds
+	 *            intervall for writing to logfile
+	 * @param flag
+	 *            level of logging
 	 * @return 0 success, -1 failure
 	 */
-	public int startLog(String logFileDir, int seconds, int flag){
+	public int startLog(String logFileDir, int seconds, int flag) {
 
 		Time currTime = new Time();
 		currTime.getTime();
 		currTime.setFormat("yyyyMMdd'_'HHmm");
-		String logFileName = new String(logFileDir + currTime.toString()+ ".log");
+		String logFileName = new String(logFileDir + currTime.toString() + ".log");
 		// create Logfile
 		try {
 			logFile = new FileWriter(logFileName);
 		} catch (IOException e) {
-			Global.getPref().log("Error creating LogFile " + logFileName,e,true);
+			Global.getPref().log("Error creating LogFile " + logFileName, e, true);
 			return -1;
 		}
 		// start timer
@@ -168,10 +172,11 @@
 	public void stopLog() {
 		writeLog = false;
 
-		if (doLogging){
+		if (doLogging) {
 			try {
 				logFile.close();
-			} catch (IOException e) {/*Too lazy to do something */}
+			} catch (IOException e) {/* Too lazy to do something */
+			}
 			if (logTimer > 0) {
 				Vm.cancelTimer(logTimer);
 				logTimer = 0;
@@ -180,82 +185,107 @@
 		doLogging = false;
 	}
 
-
-	public int getSats(){
+	public int getSats() {
 		return this.numSat;
 	}
 
-	public int getSatsInView(){
+	public int getSatsInView() {
 		return this.numSatsInView;
 	}
 
-	public double getAlt(){
+	public double getAlt() {
 		return this.Alt;
 	}
 
-	public double getHDOP(){
+	public double getHDOP() {
 		return this.HDOP;
 	}
 
 	/**
 	 * Sets the attributes from a NMEA String
-	 * @param NMEA	string with data to examine
+	 * 
+	 * @param NMEA
+	 *            string with data to examine
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examine(String NMEA){
+	public boolean examine(String NMEA) {
 		boolean interpreted = false;
 		boolean logWritten = false;
 		try {
 			int i, start, end;
-			String latDeg="0", latMin="0", latNS="N";
-			String lonDeg="0", lonMin="0", lonEW="E";
+			String latDeg = "0", latMin = "0", latNS = "N";
+			String lonDeg = "0", lonMin = "0", lonEW = "E";
 			String currToken;
 			end = 0;
 			lastStrExamined = NMEA;
-			while(true){
+			while (true) {
 				start = NMEA.indexOf("$GP", end);
-				if (start == -1) break;
+				if (start == -1)
+					break;
 				end = NMEA.indexOf("*", start);
-				if ((end == -1)||(end+3 > NMEA.length())) break;
+				if ((end == -1) || (end + 3 > NMEA.length()))
+					break;
 
-				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start,end+3))){
+				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start, end + 3))) {
 					continue;
 				}
 				// Write log after finding valid NMEA sequence
-				if (writeLog && (logFlag & LOGRAW) > 0){
+				if (writeLog && (logFlag & LOGRAW) > 0) {
 					try {
-						logFile.write(NMEA.substring(start,end+3)+"\n");
+						logFile.write(NMEA.substring(start, end + 3) + "\n");
 						logWritten = true;
 					} catch (IOException e) {
 						// Global.getPref().log("Ignored Exception", e, true);
 					}
 				}
 
-				Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
+				Extractor ex = new Extractor("," + NMEA.substring(start, end), ",", ",", 0, true);
 				currToken = ex.findNext();
-				if (currToken.equals("$GPGGA")){
+				if (currToken.equals("$GPGGA")) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						boolean latlonerror = false; // indicate that some error occured in the data -> in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
+						// indicate that some error occured in the data -> in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
+						boolean latlonerror = false;
 						i++;
-						if (currToken.length()==0) {
-							if (i >= 2 && i <= 5) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-						}
-						switch (i){
-						case 1: this.Time = currToken; break;
-						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 3: latNS = currToken;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							break;
+						case 2:
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 3:
+							latNS = currToken;
+							break;
 
-						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 5: lonEW = currToken;
-						break;
+						case 4:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 5:
+							lonEW = currToken;
+							break;
 						case 6:
 							if (!latlonerror) {
 								this.Fix = Convert.toInt(currToken);
@@ -265,142 +295,194 @@
 								this.Fix = 0;
 								break;
 							}
-						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
-						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						} break;
-						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						} break;
+						case 7:
+							this.numSat = Convert.toInt(currToken);
+							interpreted = true;
+							break;
+						case 8:
+							try {
+								this.HDOP = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							break;
+						case 9:
+							try {
+								this.Alt = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							break;
 						} // switch
 					} // while
-					if (Fix > 0) this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
+					if (Fix > 0)
+						this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
 
 				} // if
 
-				if (currToken.equals("$GPVTG")){
+				if (currToken.equals("$GPVTG")) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
 						i++;
-						if (currToken.length()==0) continue;
-						switch (i){
-						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						if (this.Bear > 360) Global.getPref().log("Error bear VTG",null);
-						break;
-						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						break;
+						switch (i) {
+						case 1:
+							try {
+								this.Bear = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							if (this.Bear > 360)
+								Global.getPref().log("Error bear VTG", null);
+							break;
+						case 7:
+							try {
+								this.Speed = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							break;
 						} // switch
 					} // while
 				} // if
 
-				if (currToken.equals("$GPRMC")){
+				if (currToken.equals("$GPRMC")) {
 					i = 0;
 					String status = "V";
 					boolean latlonerror = false;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
 						i++;
-						if (currToken.length() == 0) {
-							if (i >= 2 && i <= 6) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-						}
-						if (currToken.length() == 0) continue;
-						switch (i){
-						case 1: this.Time = currToken; interpreted = true; break;
-						case 2: status = currToken;
-						if (status.equals("A")) this.Fix = 1;
-						else this.Fix = 0;
-						interpreted = true;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							interpreted = true;
+							break;
+						case 2:
+							status = currToken;
+							if (status.equals("A"))
+								this.Fix = 1;
+							else
+								this.Fix = 0;
+							interpreted = true;
+							break;
 						case 3:
-							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
 							break;
-						case 4: latNS = currToken; interpreted = true;
-						break;
-						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						break;
-						case 6: lonEW = currToken;
-						interpreted = true;
-						break;
-						case 7: if (status.equals("A")){
-							try {this.Speed = Common.parseDouble(currToken)*1.854;
-							interpreted = true; } catch (NumberFormatException e) {
-								//Global.getPref().log("Ignored Exception", e, true);
-							}
-						}
-						break;
-						case 8: if (status.equals("A") && currToken.length()> 0){
-							try {this.Bear = Common.parseDouble(currToken);
-							interpreted = true; } catch (NumberFormatException e) {
+						case 4:
+							latNS = currToken;
+							interpreted = true;
+							break;
+						case 5:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log("Ignored Exception", e, true);
 							}
-						}
-						break;
-						case 9: if (status.equals("A") && currToken.length()> 0){
-							try {this.Date = currToken;
-							interpreted = true; } catch (NumberFormatException e) {
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log("Ignored Exception", e, true);
 							}
-						}
-						break;
+							break;
+						case 6:
+							lonEW = currToken;
+							interpreted = true;
+							break;
+						case 7:
+							if (status.equals("A")) {
+								try {
+									this.Speed = Common.parseDouble(currToken) * 1.854;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log("Ignored Exception", e, true);
+								}
+							}
+							break;
+						case 8:
+							if (status.equals("A") && currToken.length() > 0) {
+								try {
+									this.Bear = Common.parseDouble(currToken);
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log("Ignored Exception", e, true);
+								}
+							}
+							break;
+						case 9:
+							if (status.equals("A") && currToken.length() > 0) {
+								try {
+									this.Date = currToken;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log("Ignored Exception", e, true);
+								}
+							}
+							break;
 						} // switch
 					} // while
-					if (latlonerror) this.Fix = 0;
+					if (latlonerror)
+						this.Fix = 0;
 					else {
-						if (status.equals("A")){
-							this.set(latNS, latDeg, latMin, "0",
-									lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
+						if (status.equals("A")) {
+							this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
 						}
 					}
 				} // if
 
-				if (currToken.equals("$GPGSV")){
+				if (currToken.equals("$GPGSV")) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
 						i++;
-						if (currToken.length() == 0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-						switch (i){
-						case 3: this.numSatsInView = Convert.toInt(currToken); interpreted = true; break;
+						switch (i) {
+						case 3:
+							this.numSatsInView = Convert.toInt(currToken);
+							interpreted = true;
+							break;
 						} // switch
 					} // while
 				} // if
 
-			} //while
+			} // while
 		} catch (Exception e) {
 			Global.getPref().log("Exception in examine in CWGPSPoint", e, true);
 		}
 
-		if	(logWritten)
+		if (logWritten)
 			writeLog = false;
 
 		return interpreted;
 	}
 
-
 	/**
 	 * Sets the attributes from a GPSD <code>POLL</code> object
-	 *
-	 * @param gps	{@link JSONObject} containing GPS <code>POLL</code> data.
+	 * 
+	 * @param gps
+	 *            {@link JSONObject} containing GPS <code>POLL</code> data.
 	 * @return true if some data could be interpreted false otherwise
 	 *         Tblue> For now, this always returns true. Any ideas what
-	 *                should be treated as not interpretable?
-	 * @throws JSONException When trying to access a not existing key (should not happen!).
+	 *         should be treated as not interpretable?
+	 * @throws JSONException
+	 *             When trying to access a not existing key (should not happen!).
 	 */
 	public boolean examineGpsd(JSONObject gps) throws JSONException {
-		JSONArray fixes    = gps.getJSONArray( "fixes" );
-		JSONArray skyviews = gps.getJSONArray( "skyviews" );
+		JSONArray fixes = gps.getJSONArray("fixes");
+		JSONArray skyviews = gps.getJSONArray("skyviews");
 		JSONArray sats;
 		JSONObject a_fix, a_skyview;
 		int fix_mode, i;
@@ -409,59 +491,55 @@
 
 		lastStrExamined = gps.toString();
 
-		TimeObj.setTime( (long)( gps.getDouble( "timestamp" ) * 1000 ) );
-		this.Time = TimeObj.format( "HHmmss.SS" );
-		this.Date = TimeObj.format( "ddMMyy" );
+		TimeObj.setTime((long) (gps.getDouble("timestamp") * 1000));
+		this.Time = TimeObj.format("HHmmss.SS");
+		this.Date = TimeObj.format("ddMMyy");
 
-		if( fixes.length() > 0 ) {
+		if (fixes.length() > 0) {
 			// We will only use the first fix.
 			// TODO: Randomize?
-			a_fix = fixes.getJSONObject( 0 );
-			
+			a_fix = fixes.getJSONObject(0);
+
 			// 0: no mode seen yet, 1: none, 2: 2D, 3: 3D.
 			// Tblue> Does 3D mean differential here?
-			this.Fix = ( fix_mode = a_fix.getInt( "mode" ) ) > 0 ? fix_mode - 1 : 0;
+			this.Fix = (fix_mode = a_fix.getInt("mode")) > 0 ? fix_mode - 1 : 0;
 
 			// Speed is in m/s.
-			if( a_fix.has( "speed" ) ) {
-				this.Speed = ( a_fix.getDouble( "speed" ) / 1000 ) * 60 * 60;
+			if (a_fix.has("speed")) {
+				this.Speed = (a_fix.getDouble("speed") / 1000) * 60 * 60;
 			}
 
-			if( a_fix.has( "track" ) ) {
-				this.Bear = a_fix.getDouble( "track" );
+			if (a_fix.has("track")) {
+				this.Bear = a_fix.getDouble("track");
 			}
 
-			if( a_fix.has( "alt" ) ) {
-				this.Alt = a_fix.getDouble( "alt" );
+			if (a_fix.has("alt")) {
+				this.Alt = a_fix.getDouble("alt");
 			}
 
-			if( a_fix.has( "lat" ) && a_fix.has( "lon" ) ) {
-				my_lat = a_fix.getDouble( "lat" );
-				my_lon = a_fix.getDouble( "lon" );
+			if (a_fix.has("lat") && a_fix.has("lon")) {
+				my_lat = a_fix.getDouble("lat");
+				my_lon = a_fix.getDouble("lon");
 
-				set( my_lat > 0 ? "N" : "S", String.valueOf( my_lat ), "0", "0",
-					 my_lon > 0 ? "E" : "W", String.valueOf( my_lon ), "0", "0",
-					 TransformCoordinates.DD );
+				set(my_lat > 0 ? "N" : "S", String.valueOf(my_lat), "0", "0", my_lon > 0 ? "E" : "W", String.valueOf(my_lon), "0", "0", TransformCoordinates.DD);
 			}
 		}
 
-		if( skyviews.length() > 0 )
-		{
+		if (skyviews.length() > 0) {
 			// We will only use the first skyview.
 			// TODO: Randomize?
-			a_skyview = skyviews.getJSONObject( 0 );
+			a_skyview = skyviews.getJSONObject(0);
 
-			if( a_skyview.has( "hdop" ) ) {
-				this.HDOP = a_skyview.getDouble( "hdop" );
+			if (a_skyview.has("hdop")) {
+				this.HDOP = a_skyview.getDouble("hdop");
 			}
 
-			sats = a_skyview.getJSONArray( "satellites" );
+			sats = a_skyview.getJSONArray("satellites");
 			this.numSatsInView = sats.length();
 
-			if( this.numSatsInView > 0 )
-			{
-				for( this.numSat = 0, i = 0; i < this.numSatsInView; i++ ) {
-					if( sats.getJSONObject( i ).getBoolean( "used" ) ) {
+			if (this.numSatsInView > 0) {
+				for (this.numSat = 0, i = 0; i < this.numSatsInView; i++) {
+					if (sats.getJSONObject(i).getBoolean("used")) {
 						this.numSat++;
 					}
 				}
@@ -471,71 +549,72 @@
 		return true;
 	}
 
-
 	/**
 	 * Sets the attributes from an old-style GPSD string.
-	 * @param gps	GPSD string with data to examine
-	 *              Format: GPSD,key=value,...
+	 * 
+	 * @param gps
+	 *            GPSD string with data to examine
+	 *            Format: GPSD,key=value,...
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examineOldGpsd(String gps){
+	public boolean examineOldGpsd(String gps) {
 		boolean valid = false;
-		if(!gps.startsWith("GPSD,"))
+		if (!gps.startsWith("GPSD,"))
 			return false;
-		Extractor ex = new Extractor (gps, ",",",",4,true);
-		while(!ex.endOfSearch()){
-			String part = ex.findNext();
-			if(part.startsWith("A=") && part.indexOf('?')<0){
+		Extractor ex = new Extractor(gps, ",", ",", 4, true);
+		String part;
+		while ((part = ex.findNext()).length() > 0) {
+			if (part.startsWith("A=") && part.indexOf('?') < 0) {
 				// The current altitude as "A=%f", meters above mean sea level.
-				this.Alt=Common.parseDouble(part.substring(2));
+				this.Alt = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith("D=") && part.indexOf('?')<0){
+			} else if (part.startsWith("D=") && part.indexOf('?') < 0) {
 				// Returns the UTC time in the ISO 8601 format, "D=yyyy-mm-ddThh:mm:ss.ssZ"
-				//                                               0000000000111111111122
-				//                                               0123456789012345678901
-				String year = part.substring(2,6);
-				String month = part.substring(7,9);
-				String day = part.substring(10,12);
-				String hour = part.substring(13,15);
-				String min = part.substring(16,18);
-				String sec = part.substring(19,21);
-				this.Date=year+month+day;
-				this.Time=hour+min+sec;
+				// 0000000000111111111122
+				// 0123456789012345678901
+				String year = part.substring(2, 6);
+				String month = part.substring(7, 9);
+				String day = part.substring(10, 12);
+				String hour = part.substring(13, 15);
+				String min = part.substring(16, 18);
+				String sec = part.substring(19, 21);
+				this.Date = year + month + day;
+				this.Time = hour + min + sec;
 				valid = true;
-			}else if(part.startsWith("P=")){
+			} else if (part.startsWith("P=")) {
 				// Returns the current position in the form "P=%f %f"; numbers are in degrees, latitude first.
-				if(part.indexOf('?')<0){
+				if (part.indexOf('?') < 0) {
 					this.Fix = 1;
-					int spacepos=part.indexOf(' ');
-					if(spacepos>=3){
-						String lat=part.substring(2,spacepos);
-						String lon=part.substring(spacepos+1);
-						this.latDec=Common.parseDouble(lat);
-						this.lonDec=Common.parseDouble(lon);
-					}else
+					int spacepos = part.indexOf(' ');
+					if (spacepos >= 3) {
+						String lat = part.substring(2, spacepos);
+						String lon = part.substring(spacepos + 1);
+						this.latDec = Common.parseDouble(lat);
+						this.lonDec = Common.parseDouble(lon);
+					} else
 						this.set(part.substring(2));
-				}else{
+				} else {
 					this.Fix = 0;
 				}
 				valid = true;
-			}else if(part.startsWith("Q=")){
+			} else if (part.startsWith("Q=")) {
 				// Returns "Q=%d %f %f %f %f %f": a count of satellites used in the last fix,
 				// and five dimensionless dilution-of-precision (DOP) numbers --
 				// spherical, horizontal, vertical, time, and total geometric.
-				int spacepos=part.indexOf(' ');
-				if(part.indexOf('?')<0 && spacepos>=3){
+				int spacepos = part.indexOf(' ');
+				if (part.indexOf('?') < 0 && spacepos >= 3) {
 					this.numSat = Common.parseInt(part.substring(2, spacepos));
 					valid = true;
-				}else{
+				} else {
 					this.numSat = 0;
 				}
-				this.numSatsInView = 0;			// Not supported by GPSD
-				//TODO parse DOP values
-			}else if(part.startsWith("T=") && part.indexOf('?')<0){
+				this.numSatsInView = 0; // Not supported by GPSD
+				// TODO parse DOP values
+			} else if (part.startsWith("T=") && part.indexOf('?') < 0) {
 				// Track made good; course "T=%f" in degrees from true north.
 				this.Bear = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith("V=") && part.indexOf('?')<0){
+			} else if (part.startsWith("V=") && part.indexOf('?') < 0) {
 				// The current speed over ground as "V=%f" in knots.
 				this.Speed = Common.parseDouble(part.substring(2));
 				valid = true;
@@ -544,16 +623,16 @@
 		return valid;
 	}
 
-
-	private boolean checkSumOK(String nmea){
+	private boolean checkSumOK(String nmea) {
 		int startPos = 1; // begin after $
 		int endPos = nmea.length() - 3;// without * an two checksum chars
 		byte checkSum = 0;
 
-		for (int i= startPos; i<endPos;i++){
+		for (int i = startPos; i < endPos; i++) {
 			checkSum ^= nmea.charAt(i);
 		}
-		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		try {
+			return (checkSum == Byte.parseByte(nmea.substring(endPos + 1), 16));
 		} catch (IndexOutOfBoundsException e) {
 			return false;
 		} catch (NumberFormatException e) {
@@ -561,9 +640,7 @@
 		}
 	}
 
-
-
-	public void printAll(){
+	public void printAll() {
 		Global.getPref().log("Latitude:     " + this.getLatDeg(TransformCoordinates.DD));
 		Global.getPref().log("Longitude:    " + this.getLonDeg(TransformCoordinates.DD));
 		Global.getPref().log("Speed:        " + this.Speed);
@@ -577,5 +654,3 @@
 		Global.getPref().log("----------------");
 	}
 }
-
-

Modified: branches/r1.2/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/GotoPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/GotoPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -68,18 +68,17 @@
 import ewe.ui.mLabel;
 
 /**
- *	Class to create the panel which handles the connection to the GPS-device<br>
- *	Displays: current position,speed and bearing; relation to destination waypoint<br>
- *	Class ID: 1500
+ * Class to create the panel which handles the connection to the GPS-device<br>
+ * Displays: current position,speed and bearing; relation to destination waypoint<br>
+ * Class ID: 1500
  */
 
-
 public final class GotoPanel extends CellPanel {
 
-	//public CWGPSPoint gpsPosition = new CWGPSPoint();
-	//public CWPoint toPoint = new CWPoint();
+	// public CWGPSPoint gpsPosition = new CWGPSPoint();
+	// public CWPoint toPoint = new CWPoint();
 	public Navigate myNavigation;
-	mButton btnGPS, btnCenter,btnSave;
+	mButton btnGPS, btnCenter, btnSave;
 	mButton btnGoto, btnMap;
 	int currFormatSel;
 
@@ -101,13 +100,13 @@
 	ImageControl icRose;
 	GotoRose compassRose;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
 
 	Menu mnuContextFormt;
-	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; //miDMM, miDMS, miDD, miUTM, miGK;
+	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; // miDMM, miDMS, miDD, miUTM, miGK;
 
 	Menu mnuContextRose;
 	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
@@ -115,27 +114,32 @@
 
 	/**
 	 * Create GotoPanel
-	 * @param Preferences 	global preferences
-	 * @param MainTab		reference to MainTable
-	 * @param DetailsPanel 	reference to DetailsPanel
-	 * @param Vector		cacheDB
+	 * 
+	 * @param Preferences
+	 *            global preferences
+	 * @param MainTab
+	 *            reference to MainTable
+	 * @param DetailsPanel
+	 *            reference to DetailsPanel
+	 * @param Vector
+	 *            cacheDB
 	 */
 	public GotoPanel(Navigate nav) {
 		myNavigation = nav;
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		detP = mainT.detP;
 		cacheDB = profile.cacheDB;
 
 		// Button
-		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504,"Start")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Centre")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504, "Start")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309, "Centre")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311, "Create Waypoint")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		// ButtonP.addLast(btnMap = new mButton(MyLocale.getMsg(1506,"Map")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
-		//Format selection for coords
-		//context menu
+		// Format selection for coords
+		// context menu
 		mnuContextFormt = new Menu();
 		currFormatSel = 1; // default to d? m.m
 		mnuContextFormt.addItem(miCooformat[0] = new MenuItem("d.d?"));
@@ -148,14 +152,16 @@
 
 		// Create context menu for compass rose: select luminary for orientation
 		mnuContextRose = new Menu();
-		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i < SkyOrientation.LUMINARY_NAMES.length; i++) {
 			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
-			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-			else miLuminary[i].modifiers &= MenuItem.Checked;
+			if (i == myNavigation.luminary)
+				miLuminary[i].modifiers |= MenuItem.Checked;
+			else
+				miLuminary[i].modifiers &= MenuItem.Checked;
 		}
 
-		//Coords
-		CoordsP.addNext(lblGPS = new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		// Coords
+		CoordsP.addNext(lblGPS = new mLabel("GPS: "), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		lblGPS.backGround = RED;
 		lblGPS.setMenu(mnuContextFormt);
 		lblGPS.modifyAll(ControlConstants.WantHoldDown, 0);
@@ -164,45 +170,47 @@
 		lblPosition.anchor = CellConstants.CENTER;
 		lblPosition.setMenu(mnuContextFormt);
 		lblPosition.modifyAll(ControlConstants.WantHoldDown, 0);
-		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblDST.backGround = new Color(0,0,255);
+		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500, "DST:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		lblDST.backGround = new Color(0, 0, 255);
 		lblDST.setMenu(mnuContextFormt);
 		lblDST.modifyAll(ControlConstants.WantHoldDown, 0);
 
-		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		//Rose for bearing
-		//		compassRose = new GotoRose("rose.png");
+		// Rose for bearing
+		// compassRose = new GotoRose("rose.png");
 		compassRose = new GotoRose();
 		icRose = new ImageControl(compassRose);
 		icRose.setMenu(mnuContextRose);
 		icRose.modifyAll(ControlConstants.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
-		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		roseP.addLast(icRose, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.NORTH));
 
 		mnuContextRose.addItem(new MenuItem("", MenuItem.Separator, null));
-		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,"North Centered")));
-		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
-		else miNorthCentered.modifiers &= MenuItem.Checked;
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503, "North Centered")));
+		if (compassRose.isNorthCentered())
+			miNorthCentered.modifiers |= MenuItem.Checked;
+		else
+			miNorthCentered.modifiers &= MenuItem.Checked;
 
-		//add Panels
-		HeadP.addLast(ButtonP,CellConstants.HSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		HeadP.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));	
-		this.addNext(HeadP,CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(2,1));		
-		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506,"Map")+" "),CellConstants.HSTRETCH, CellConstants.VFILL|CellConstants.RIGHT).setTag(SPAN,new Dimension(2,1));
-		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		btnMap.backGround=GREEN;
+		// add Panels
+		HeadP.addLast(ButtonP, CellConstants.HSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		HeadP.addLast(CoordsP, CellConstants.HSTRETCH, CellConstants.HFILL | CellConstants.NORTH).setTag(SPAN, new Dimension(2, 1));
+		this.addNext(HeadP, CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506, "Map") + " "), CellConstants.HSTRETCH, CellConstants.VFILL | CellConstants.RIGHT).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(roseP, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		btnMap.backGround = GREEN;
 	}
 
-	public void resizeTo(int pWidth, int pHeight){
+	public void resizeTo(int pWidth, int pHeight) {
 		super.resizeTo(pWidth, pHeight);
 		Rect coordsRect = CoordsP.getRect();
 		int roseHeight = pHeight - coordsRect.y - coordsRect.height;
 		if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
-			//some space for the SIP button
-			if ( (Vm.getParameter(VmConstants.VM_FLAGS) & (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
-				Rect screen = (Rect)Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new Rect(),0);
+			// some space for the SIP button
+			if ((Vm.getParameter(VmConstants.VM_FLAGS) & (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) {
+				Rect screen = (Rect) Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new Rect(), 0);
 				roseHeight -= screen.height / 14;
 			}
 		}
@@ -211,14 +219,17 @@
 		compassRose.resize(pWidth, roseHeight);
 	}
 
-
 	/**
 	 * set the coords of the destination
-	 * @param dest destination
+	 * 
+	 * @param dest
+	 *            destination
 	 */
-	public void setDestination(CWPoint dest){
+	public void setDestination(CWPoint dest) {
 		myNavigation.setDestination(dest);
-		if (!myNavigation.destination.isValid()) (new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(1507,"Coordinates are out of range:") +"\n"+MyLocale.getMsg(1508,"latitude")+": "+myNavigation.destination.latDec+"\n "+MyLocale.getMsg(1509,"longditue")+": "+myNavigation.destination.lonDec, FormBase.OKB)).execute();
+		if (!myNavigation.destination.isValid())
+			(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1507, "Coordinates are out of range:") + "\n" + MyLocale.getMsg(1508, "latitude") + ": " + myNavigation.destination.latDec + "\n " + MyLocale.getMsg(1509, "longditue") + ": "
+					+ myNavigation.destination.lonDec, FormBase.OKB)).execute();
 
 	}
 
@@ -227,15 +238,17 @@
 		updateDistance();
 	}
 
-
 	/**
 	 * set the coords of the destination and switch to gotoPanel
-	 * @param LatLon destination
+	 * 
+	 * @param LatLon
+	 *            destination
 	 */
 	public void setDestinationAndSwitch(CWPoint where) {
 		myNavigation.setDestination(where);
 		mainT.select(this);
 	}
+
 	public void setDestinationAndSwitch(CacheHolder ch) {
 		myNavigation.setDestination(ch);
 		mainT.select(this);
@@ -243,16 +256,16 @@
 
 	/**
 	 * updates distance and bearing
-	 *
+	 * 
 	 */
 
 	public void updateDistance() {
-		//update distance
+		// update distance
 		float distance = -1.0f;
-		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
-			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid()) {
+			distance = (float) myNavigation.gpsPos.getDistance(myNavigation.destination);
 		}
-		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+		compassRose.setWaypointDirectionDist((float) myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
 	}
 
 	/**
@@ -263,37 +276,41 @@
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getSatsInView(), myNavigation.gpsPos.getHDOP());
-		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+		if ((fix > 0) && (myNavigation.gpsPos.getSats() >= 0)) {
 			// display values only, if signal good
 			lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 			speed.set(myNavigation.gpsPos.getSpeed());
 			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
 			bearMov.set(myNavigation.gpsPos.getBear());
 			updateDistance();
-			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			compassRose.setSunMoveDirections((float) sunAzimut.value, (float) bearMov.value, (float) speed.value);
 			// Set background to signal quality
 		}
 
 		// receiving data, but signal ist not good
-		if ((fix == 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+		if ((fix == 0) && (myNavigation.gpsPos.getSats() >= 0)) {
 			gpsStatus = YELLOW;
 		}
 		// receiving no data
 		if (fix == -1) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1510, "No data from GPS.\nConnection to serial port/gpsd closed."),FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1510, "No data from GPS.\nConnection to serial port/gpsd closed."), FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps();
 		}
 		// cannot interpret data
 		if (fix == -2) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1511, "Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n")+myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1511,
+						"Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n")
+						+ myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps(); // TODO automatic in myNavigate?
 		}
 	}
 
 	public void gpsStarted() {
-		btnGPS.setText(MyLocale.getMsg(1505,"Stop"));
+		btnGPS.setText(MyLocale.getMsg(1505, "Stop"));
 	}
 
 	public void startGps() {
@@ -301,28 +318,33 @@
 	}
 
 	public void gpsStoped() {
-		btnGPS.setText(MyLocale.getMsg(1504,"Start"));
+		btnGPS.setText(MyLocale.getMsg(1504, "Start"));
 		gpsStatus = this.backGround;
 		this.repaintNow(); // without this the change in the background color will not be displayed
 	}
 
-
 	private String getGotoBtnText() {
-		if (myNavigation.destination == null) return MyLocale.getMsg(999,"Not set");
-		else return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
+		if (myNavigation.destination == null)
+			return MyLocale.getMsg(999, "Not set");
+		else
+			return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
 	}
 
 	public void switchToMovingMap() {
 		CWPoint centerTo = null;
-		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		if (myNavigation.isGpsPosValid())
+			centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
 		else {
 			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-			//centerTo = new CWPoint(myNavigation.destination);
-			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			// centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())
+				centerTo = new CWPoint(myNavigation.destination);
 			else {
-				if (mainT.ch != null && mainT.ch.pos.isValid()) centerTo = new CWPoint(mainT.ch.pos);
+				if (mainT.ch != null && mainT.ch.getPos().isValid())
+					centerTo = new CWPoint(mainT.ch.getPos());
 				else {
-					if (pref.getCurCentrePt().isValid()) centerTo = new CWPoint(pref.getCurCentrePt());
+					if (pref.getCurCentrePt().isValid())
+						centerTo = new CWPoint(pref.getCurCentrePt());
 				}
 			}
 		}
@@ -335,10 +357,10 @@
 	/**
 	 * Eventhandler
 	 */
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		if (ev instanceof MenuEvent) {
 			if (ev.type == MenuEvent.SELECTED) {
-				if (((MenuEvent)ev).menu == mnuContextFormt) {
+				if (((MenuEvent) ev).menu == mnuContextFormt) {
 					mnuContextFormt.close();
 					mnuContextFormt.getItemAt(currFormatSel).modifiers &= ~MenuItem.Checked;
 					currFormatSel = mnuContextFormt.getInt();
@@ -346,23 +368,22 @@
 					lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 					btnGoto.setText(getGotoBtnText());
 				} // end lat-lon-format context menu
-				if (((MenuEvent)ev).menu == mnuContextRose) {
+				if (((MenuEvent) ev).menu == mnuContextRose) {
 					MenuItem action = (MenuItem) mnuContextRose.getSelectedItem();
 					if (action != null) {
-						for (int i=0; i<miLuminary.length; i++) {
+						for (int i = 0; i < miLuminary.length; i++) {
 							if (action == miLuminary[i]) {
 								myNavigation.setLuminary(i);
 								miLuminary[i].modifiers |= MenuItem.Checked;
 								compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
-							} else miLuminary[i].modifiers &= ~MenuItem.Checked;
+							} else
+								miLuminary[i].modifiers &= ~MenuItem.Checked;
 						}
 						if (action == miNorthCentered) {
 							if (compassRose.isNorthCentered()) {
 								compassRose.setNorthCentered(false);
 								miNorthCentered.modifiers &= ~MenuItem.Checked;
-							}
-							else
-							{
+							} else {
 								compassRose.setNorthCentered(true);
 								miNorthCentered.modifiers |= MenuItem.Checked;
 							}
@@ -372,44 +393,49 @@
 			}
 		}
 
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
 			// start/stop GPS connection
-			if (ev.target == btnGPS){
-				if (btnGPS.getText().equals(MyLocale.getMsg(1504, "Start"))) startGps();
-				else myNavigation.stopGps();
+			if (ev.target == btnGPS) {
+				if (btnGPS.getText().equals(MyLocale.getMsg(1504, "Start")))
+					startGps();
+				else
+					myNavigation.stopGps();
 			}
 
 			// set current position as centre and recalculate distance of caches in MainTab
-			if (ev.target == btnCenter){
+			if (ev.target == btnCenter) {
 				if (myNavigation.gpsPos.isValid()) {
 					pref.setCurCentrePt(myNavigation.gpsPos);
-				} else (new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(1514, "Cannot recalculate distances, because the GPS position is not set"), FormBase.OKB)).execute();
+				} else
+					(new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(1514, "Cannot recalculate distances, because the GPS position is not set"), FormBase.OKB)).execute();
 			}
-			//Start moving map
-			if (ev.target == btnMap){
+			// Start moving map
+			if (ev.target == btnMap) {
 				switchToMovingMap();
 			}
 			// create new waypoint with current GPS-position
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
-				ch.setLatLon(myNavigation.gpsPos.toString());
-				ch.pos = new CWPoint(myNavigation.gpsPos);
+				ch.setPos(myNavigation.gpsPos);
 				ch.setType(CacheType.CW_TYPE_STAGE); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint
-			if (ev.target == btnGoto){
-				if(Vm.isMobile()){
+			if (ev.target == btnGoto) {
+				if (Vm.isMobile()) {
 					InputScreen InScr = new InputScreen(CoordsScreen.getLocalSystem(currFormatSel));
-					if (myNavigation.destination.isValid())	InScr.setCoords(myNavigation.destination);
-					else InScr.setCoords(new CWPoint(0,0));
+					if (myNavigation.destination.isValid())
+						InScr.setCoords(myNavigation.destination);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
 					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(InScr.getCoords());
-				}else
-				{
+				} else {
 					CoordsScreen cs = new CoordsScreen();
-					if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
-					else cs.setFields(new CWPoint(0,0), CoordsScreen.getLocalSystem(currFormatSel));
+					if (myNavigation.destination.isValid())
+						cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
+					else
+						cs.setFields(new CWPoint(0, 0), CoordsScreen.getLocalSystem(currFormatSel));
 					if (cs.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(cs.getCoords());
 				}
@@ -420,7 +446,8 @@
 	}
 }
 
-/** class for displaying the compass rose
+/**
+ * class for displaying the compass rose
  * including goto, sun and moving direction
  */
 class GotoRose extends AniImage {
@@ -445,25 +472,28 @@
 
 	boolean northCentered = Global.getPref().northCenteredGoto;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
-	final static Color ORANGE = new Color(255,128,0);
-	final static Color DARKGREEN = new Color(0,192,0);
-	final static Color CYAN = new Color(0,255,255);
-	final static Color MAGENTA = new Color(255,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
+	final static Color ORANGE = new Color(255, 128, 0);
+	final static Color DARKGREEN = new Color(0, 192, 0);
+	final static Color CYAN = new Color(0, 255, 255);
+	final static Color MAGENTA = new Color(255, 0, 255);
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public GotoRose(String fn){
+	public GotoRose(String fn) {
 		super(fn);
 	}
 
-	public GotoRose(){
+	public GotoRose() {
 		super();
 	}
 
@@ -472,7 +502,7 @@
 		distance = dist;
 	}
 
-	public void setSunMoveDirections(float sd, float md, float speed ) {
+	public void setSunMoveDirections(float sd, float md, float speed) {
 		sunDir = sd;
 		moveDir = md;
 		m_speed = speed;
@@ -492,15 +522,18 @@
 		refresh();
 	}
 
-
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
+	public void doDraw(Graphics g, int options) {
 		g.setColor(Color.White);
 		g.fillRect(0, 0, location.width, location.height);
 
@@ -512,15 +545,14 @@
 		roseRadius = java.lang.Math.min((location.width * 3) / 4, location.height) / 2;
 
 		if (northCentered) {
-			//scale(location.width, location.height, null, 0);
-			//super.doDraw(g, options);
-			drawFullRose(g, 0, new Color(255,255,255), new Color(200,200,200), new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(75,75,75), 1.0f, true, true);
-		}
-		else {
-			int radius = (int)(roseRadius * 0.75f);
+			// scale(location.width, location.height, null, 0);
+			// super.doDraw(g, options);
+			drawFullRose(g, 0, new Color(255, 255, 255), new Color(200, 200, 200), new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(75, 75, 75), 1.0f, true, true);
+		} else {
+			int radius = (int) (roseRadius * 0.75f);
 
-			g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
-			g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+			g.setPen(new Pen(new Color(150, 150, 150), Pen.SOLID, 3));
+			g.drawEllipse(location.width / 2 - radius, location.height / 2 - radius, 2 * radius, 2 * radius);
 		}
 
 		drawArrows(g);
@@ -530,7 +562,7 @@
 		drawGpsStatus(g);
 	}
 
-	private void drawWayPointData(Graphics g){
+	private void drawWayPointData(Graphics g) {
 		String strTemp = MyLocale.getMsg(1512, "Waypoint");
 		g.setColor(Color.DarkBlue);
 		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4, lineHeight);
@@ -559,29 +591,30 @@
 			threshold = 1.0;
 			newDistance = distance;
 		}
-		if ( newDistance >= 0.0f ) {
+		if (newDistance >= 0.0f) {
 			tmp.set(newDistance);
-			if (tmp.value >= threshold){
-				strTemp = MyLocale.formatDouble(tmp,"0.000")+ " " + Metrics.getUnit(bigUnit);
+			if (tmp.value >= threshold) {
+				strTemp = MyLocale.formatDouble(tmp, "0.000") + " " + Metrics.getUnit(bigUnit);
 			} else {
 				tmp.set(Metrics.convertUnit(tmp.value, bigUnit, smallUnit));
-				strTemp = tmp.toString(3,0,0) + " " + Metrics.getUnit(smallUnit);
+				strTemp = tmp.toString(3, 0, 0) + " " + Metrics.getUnit(smallUnit);
 			}
-		}
-		else strTemp = "--- "+Metrics.getUnit(bigUnit);
+		} else
+			strTemp = "--- " + Metrics.getUnit(bigUnit);
 		g.drawText(strTemp, 2, lineHeight);
 
 		tmp.set(gotoDir);
 		if ((tmp.value <= 360) && (tmp.value >= -360))
-			strTemp = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
-		else strTemp = "---" + " " + MyLocale.getMsg(1502,"deg");
-		g.drawText(strTemp, 2, 2*lineHeight);
+			strTemp = tmp.toString(0, 0, 0) + " " + MyLocale.getMsg(1502, "deg");
+		else
+			strTemp = "---" + " " + MyLocale.getMsg(1502, "deg");
+		g.drawText(strTemp, 2, 2 * lineHeight);
 	}
 
-	private void drawGpsData(Graphics g){
+	private void drawGpsData(Graphics g) {
 		g.setColor(RED);
 
-		String strHeadline = MyLocale.getMsg(1501,"Current");
+		String strHeadline = MyLocale.getMsg(1501, "Current");
 
 		Double tmp = new Double();
 
@@ -600,17 +633,16 @@
 		}
 		if (tmp.value >= 0) {
 			if (tmp.value >= 100) {
-				strSpeed = MyLocale.formatDouble(tmp,"0") + unit;
+				strSpeed = MyLocale.formatDouble(tmp, "0") + unit;
+			} else {
+				strSpeed = MyLocale.formatDouble(tmp, "0.0") + unit;
 			}
-			else {
-				strSpeed = MyLocale.formatDouble(tmp,"0.0") + unit;
-			}
 		}
 
 		tmp.set(moveDir);
-		String strMoveDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		String strMoveDir = "---" + " " + MyLocale.getMsg(1502, "deg");
 		if ((tmp.value <= 360) && (tmp.value >= -360))
-			strMoveDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+			strMoveDir = tmp.toString(0, 0, 0) + " " + MyLocale.getMsg(1502, "deg");
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
 		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
@@ -621,21 +653,21 @@
 		g.setColor(Color.Black);
 		g.drawText(strHeadline, startX + 2, 0);
 		g.drawText(strSpeed, startX + 2, lineHeight);
-		g.drawText(strMoveDir, startX + 2, 2*lineHeight);
+		g.drawText(strMoveDir, startX + 2, 2 * lineHeight);
 	}
 
-	private void drawLuminaryData(Graphics g){
+	private void drawLuminaryData(Graphics g) {
 		g.setColor(YELLOW);
 
-		String strSunDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		String strSunDir = "---" + " " + MyLocale.getMsg(1502, "deg");
 		if (sunDir < 360 && sunDir > -360) {
 			Double tmp = new Double();
 			tmp.set(sunDir);
-			strSunDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+			strSunDir = tmp.toString(0, 0, 0) + " " + MyLocale.getMsg(1502, "deg");
 		}
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
-		int startY = location.height - 2*lineHeight;
+		int startY = location.height - 2 * lineHeight;
 		g.fillRect(0, startY, textWidth + 4, location.height - startY);
 
 		g.setColor(Color.Black);
@@ -643,104 +675,96 @@
 		g.drawText(strSunDir, 2, startY + lineHeight);
 	}
 
-	private void drawGpsStatus(Graphics g){
+	private void drawGpsStatus(Graphics g) {
 		if ((m_fix > 0) && (m_sats >= 0)) {
 			// Set background to signal quality
 			g.setColor(GREEN);
+		} else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) && (m_sats >= 0)) {
+			g.setColor(YELLOW);
+		} else {
+			g.setColor(RED);
 		}
-		else
-			// receiving data, but signal ist not good
-			if ((m_fix == 0) && (m_sats >= 0)) {
-				g.setColor(YELLOW);
-			}
-			else {
-				g.setColor(RED);
-			}
 
 		String strSats = "Sats: -";
 		if (m_sats >= 0) {
 			strSats = "Sats: " + Convert.toString(m_sats) + "/" + Convert.toString(m_satsInView);
 		}
 		String strHdop = "HDOP: -";
-		if (m_hdop >= 0) strHdop = "HDOP: " + Convert.toString(m_hdop);
+		if (m_hdop >= 0)
+			strHdop = "HDOP: " + Convert.toString(m_hdop);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
 		int startX = location.width - (textWidth + 4);
-		int startY = location.height - 2*lineHeight;
-		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+		int startY = location.height - 2 * lineHeight;
+		g.fillRect(startX, startY, location.width - startX, location.height - startY);
 
 		g.setColor(Color.Black);
 		g.drawText(strSats, startX + 2, startY);
 		g.drawText(strHdop, startX + 2, startY + lineHeight);
 	}
 
-	private void drawArrows(Graphics g){
-		if (g != null)
-		{
+	private void drawArrows(Graphics g) {
+		if (g != null) {
 			// select moveDirColor according to difference to gotoDir
 			Color moveDirColor = RED;
 
-			if (gotoDir < 360 && gotoDir > -360 && moveDir < 360 && moveDir > -360)
-			{
+			if (gotoDir < 360 && gotoDir > -360 && moveDir < 360 && moveDir > -360) {
 				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff > 360)
-				{
+				while (diff > 360) {
 					diff -= 360.0f;
 				}
-				if (diff > 180.0f)
-				{
+				if (diff > 180.0f) {
 					diff = 360.0f - diff;
 				}
 
-				if (diff <= 12.25f)
-				{
+				if (diff <= 12.25f) {
 					moveDirColor = GREEN;
-				}
-				else if (diff <= 22.5f)
-				{
+				} else if (diff <= 22.5f) {
 					moveDirColor = CYAN;
-				}
-				else if (diff <= 45.0f)
-				{
+				} else if (diff <= 45.0f) {
 					moveDirColor = ORANGE;
-				}
-				else if (diff <= 90.0f)
-				{
+				} else if (diff <= 90.0f) {
 					moveDirColor = MAGENTA;
 				}
 			}
 
 			// draw only valid arrows
 			if (northCentered) {
-				if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
-				if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
-			}
-			else {
-				//moveDir centered
+				if (gotoDir < 360 && gotoDir > -360)
+					drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir < 360 && moveDir > -360)
+					drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir < 360 && sunDir > -360)
+					drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			} else {
+				// moveDir centered
 				if (moveDir < 360 && moveDir > -360) {
-					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
-					//drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
-					drawFullRose(g, 360 - moveDir, new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(200,200,200), new Color(200,200,200), new Color(75,75,75), 1.0f, false, false);
+					// drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					// drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					drawFullRose(g, 360 - moveDir, new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(200, 200, 200), new Color(200, 200, 200), new Color(75, 75, 75), 1.0f, false, false);
 
-					int radius = (int)(roseRadius * 0.75f);
-					g.setPen(new Pen(RED,Pen.SOLID,3));
-					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					int radius = (int) (roseRadius * 0.75f);
+					g.setPen(new Pen(RED, Pen.SOLID, 3));
+					g.drawLine(location.width / 2, location.height / 2 - radius, location.width / 2, location.height / 2 + radius);
 
-					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
-					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
+					if (gotoDir < 360 && gotoDir > -360)
+						drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir < 360 && sunDir > -360)
+						drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
 				}
 			}
 		}
 	}
 
 	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.08f;
 		float circlePos = arrowLength * 0.7f;
-		int circleRadius = (int)(arrowLength * 0.1f);
+		int circleRadius = (int) (arrowLength * 0.1f);
 
 		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
 		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
@@ -757,20 +781,20 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		//		g.setPen(new Pen(col,Pen.SOLID,3));
-		//		g.drawLine(centerX,centerY,pointX,pointY);
+		// g.setPen(new Pen(col,Pen.SOLID,3));
+		// g.drawLine(centerX,centerY,pointX,pointY);
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
 	}
 
 	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
-		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float halfOpeningAngle = (float) (java.lang.Math.PI * 0.03);
 		float sideLineLength = arrowLength * 0.75f;
 
 		int[] pointsX = new int[4];
@@ -785,7 +809,7 @@
 		pointsX[3] = centerX;
 		pointsY[3] = centerY;
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		if (colPoint != null) {
@@ -794,29 +818,28 @@
 		}
 	}
 
-	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight,
-			Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
+	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight, Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
 		float subScale1 = 1.0f;
 		float subScale2 = 0.9f;
 		float innerScale = 0.15f;
-		if(bDrawEightArrows){
+		if (bDrawEightArrows) {
 			innerScale = 0.12f;
-			drawRosePart(g,  45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "NE", bDrawText);
+			drawRosePart(g, 45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "NE", bDrawText);
 			drawRosePart(g, 135 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "SE", bDrawText);
 			drawRosePart(g, 225 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "SW", bDrawText);
 			drawRosePart(g, 315 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "NW", bDrawText);
 		}
 
-		drawRosePart(g,   0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, "N", bDrawText);
-		drawRosePart(g,  90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "E", bDrawText);
+		drawRosePart(g, 0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, "N", bDrawText);
+		drawRosePart(g, 90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "E", bDrawText);
 		drawRosePart(g, 180 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "S", bDrawText);
 		drawRosePart(g, 270 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "W", bDrawText);
 	}
 
 	private void drawRosePart(Graphics g, float angle, Color colLeft, Color colRight, Color colBorder, Color colText, float scale, float innerScale, String strDir, boolean bDrawText) {
-		float angleRad = angle * (float)java.lang.Math.PI / 180;
-		float angleRadText = (angle + 7.5f) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = angle * (float) java.lang.Math.PI / 180;
+		float angleRadText = (angle + 7.5f) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * innerScale;
@@ -831,7 +854,7 @@
 		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
 		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
 
-		g.setPen(new Pen(colBorder,Pen.SOLID,1));
+		g.setPen(new Pen(colBorder, Pen.SOLID, 1));
 		g.setBrush(new Brush(colLeft, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
@@ -841,27 +864,26 @@
 		g.setBrush(new Brush(colRight, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
-		if (bDrawText){
+		if (bDrawText) {
 			int tempFontSize = new Float(scale * mainFont.getSize()).intValue();
 			Font tempFont = new Font(mainFont.getName(), Font.BOLD, tempFontSize);
 			g.setFont(tempFont);
 			FontMetrics tempFm = g.getFontMetrics(tempFont);
 			float stringHeight = tempFm.getHeight();
-			float stringWidth = tempFm.getTextWidth( strDir );
-			float stringGap = (float)java.lang.Math.sqrt(stringHeight*stringHeight + stringWidth*stringWidth);
+			float stringWidth = tempFm.getTextWidth(strDir);
+			float stringGap = (float) java.lang.Math.sqrt(stringHeight * stringHeight + stringWidth * stringWidth);
 
 			float stringPosition = arrowLength - stringGap / 2.0f;
 			g.setColor(colText);
-			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(),
-					centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
+			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(), centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
 
 			g.setFont(mainFont);
 		}
 	}
 
 	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.1f;
 
@@ -877,7 +899,7 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 	}
@@ -900,15 +922,14 @@
 		FontMetrics metrics = g.getFontMetrics(newFont);
 		int fontHeight = metrics.getHeight();
 
-		float ratio = (float)fontHeight / (float)size;
-		if(ratio < 0.9 || ratio > 1.1){
+		float ratio = (float) fontHeight / (float) size;
+		if (ratio < 0.9 || ratio > 1.1) {
 			size = (int) (size / ratio + 0.5);
-			if(size<5)
-				size=5;
+			if (size < 5)
+				size = 5;
 			newFont = new Font(name, style, size);
 		}
 
 		return newFont;
 	}
 }
-

Modified: branches/r1.2/src/CacheWolf/navi/MapImage.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapImage.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapImage.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Image;
@@ -35,45 +36,52 @@
 import ewe.graphics.AniImage;
 import ewe.io.FileInputStream;
 import ewe.io.IOException;
-/** 
+
+/**
  * class that can be used with any x and any y
- * it will save taht location and make itself automatically
- * invisible if it is not on the screen. Call setscreensize to
- * set the screensize
+ * it will save that location and
+ * make itself automatically invisible if it is not on the screen.
+ * Call setscreensize to set the screensize
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapImage extends AniImage {
 	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
 	public static Dimension screenDim;
 	boolean hidden = false;
+
 	public MapImage() {
 		super();
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	public MapImage(String f) throws ImageDecodingException, UnsupportedImageFormatException, ImageNotFoundException, ewe.sys.SystemResourceException {
-		if (screenDim == null) screenDim = new Dimension(0,0);
-		//super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
+		// super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
 		ewe.io.File file = ewe.sys.Vm.newFileObject();
 		file.set(null, f);
 		try {
-		//ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
-		setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super() 
-		freeSource(); // copied from super()
-		} catch (IOException e) { 
-			throw new ImageNotFoundException(f); // in order to behave the same way as super would have 
+			// ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides
+			// getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
+			setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super()
+			freeSource(); // copied from super()
+		} catch (IOException e) {
+			throw new ImageNotFoundException(f); // in order to behave the same way as super would have
 		}
 	}
 
 	public MapImage(mImage im) {
 		super(im);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	/**
 	 * Best you call this routine before you make any instance of MapImage
-	 * If the windows size changes after instantiation call  screenDimChanged()
+	 * If the windows size changes after instantiation call screenDimChanged()
 	 * for every symbol.
 	 * 
 	 */
@@ -83,13 +91,14 @@
 
 	public void setImage(Image im, Color c) {
 		super.setImage(im, c);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
-	public void setLocation (int x, int y) {
+	public void setLocation(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden && isOnScreen()) { 
+		if (!hidden && isOnScreen()) {
 			super.setLocation(x, y);
 			properties &= ~mImage.IsInvisible;
 		} else {
@@ -98,10 +107,10 @@
 		}
 	}
 
-	public void move (int x, int y) {
+	public void move(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden && isOnScreen()) { 
+		if (!hidden && isOnScreen()) {
 			super.move(x, y);
 			properties &= ~mImage.IsInvisible;
 		} else {
@@ -110,23 +119,24 @@
 		}
 	}
 
-	public boolean isOnScreen() { 
-		if ( (locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && 
-				(locAlways.y + location.height > 0 && locAlways.y < screenDim.height) ) return true;
-		else return false;
+	public boolean isOnScreen() {
+		if ((locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && (locAlways.y + location.height > 0 && locAlways.y < screenDim.height))
+			return true;
+		else
+			return false;
 	}
 
 	public void screenDimChanged() {
 		move(locAlways.x, locAlways.y);
-		//if (!hidden && isOnScreen()) properties &= ~AniImage.IsInvisible;
-		//else properties |= AniImage.IsInvisible;
+		// if (!hidden && isOnScreen()) properties &= ~AniImage.IsInvisible;
+		// else properties |= AniImage.IsInvisible;
 	}
 
-
 	public void hide() {
 		hidden = true;
 		properties |= mImage.IsInvisible;
 	}
+
 	public void unhide() {
 		hidden = false;
 		move(locAlways.x, locAlways.y);

Modified: branches/r1.2/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapInfoObject.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapInfoObject.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -40,16 +40,14 @@
 import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 
-
 /**
- * class to read, save and do the calculations for calibrated and 
- * calibrating maps
- * start offset for language file: 4300
+ * class to read, save and do the calculations for calibrated and calibrating maps start offset for language file: 4300
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapInfoObject extends Area {
-	//World file:
+	// World file:
 	// x scale
 	// y scale
 	// x rotation
@@ -59,89 +57,95 @@
 	// lon of lower right corner of image
 	// lat of lower right corner of image
 
-	private double[] affine = {0,0,0,0};
+	private final double[] affine = { 0, 0, 0, 0 };
 	private CWPoint affineTopleft = new CWPoint();;
-	private double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	// this are needed for the inervers calculation from lat/lon to x/y
+	private double transLatX, transLatY, transLonX, transLonY;
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
-	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
-	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
-	public Point shift = new Point (0,0);
-	public CWPoint origAffineUpperLeft; // this is only valid after zooming 
+	// in meters per pixel, note: it is assumed that this scale identifying the scale of the map,
+	// automatically adjusted when zooming
+	public float scale;
+	// if the image is zoomed, direct after laoding always 1
+	public float zoomFactor = 1;
+	public Point shift = new Point(0, 0);
+	public CWPoint origAffineUpperLeft; // this is only valid after zooming
 	public float rotationRad; // contains the rotation of the map == north direction in rad
-	/** full path to the respective worldfile, including ".wfl"*/
+	/** full path to the respective worldfile, including ".wfl" */
 	public String fileNameWFL = "";
 	/** filename wihout directory */
-//	public String fileName = new String();
-	/** name of the map, introduced to allow 'maps' without an image (empty maps) */ 
+	// public String fileName = new String();
+	/**
+	 * name of the map, introduced to allow 'maps' without an image (empty maps)
+	 */
 	public String mapName = "";
-	//private Character digSep = new Character(' ');
+	// private Character digSep = new Character(' ');
 	static private String digSep = MyLocale.getDigSeparator();
-	private int coordTrans = 0; 
+	private int coordTrans = 0;
 
 	public MapInfoObject() { // Public constructor
 	}
 
 	public MapInfoObject(MapInfoObject map) {
-		super (map.topleft, map.buttomright);
+		super(map.topleft, map.bottomright);
 		mapName = map.mapName;
 		affine[0] = map.affine[0];
 		affine[1] = map.affine[1];
 		affine[2] = map.affine[2];
 		affine[3] = map.affine[3];
-		origAffineUpperLeft = new CWPoint (map.origAffineUpperLeft);
+		origAffineUpperLeft = new CWPoint(map.origAffineUpperLeft);
 		affineTopleft = new CWPoint(map.affineTopleft);
 		zoomFactor = map.zoomFactor;
 		shift.set(map.shift);
 		coordTrans = map.coordTrans;
-		//	fileName = new String(map.fileName);
+		// fileName = new String(map.fileName);
 		fileNameWFL = new String(map.fileNameWFL);
 		mapName = new String(mapName);
 		doCalculations();
 	}
 
 	/**
-	 * constructes an MapInfoObject without an associated map
-	 * but with 1 Pixel = scale meters
+	 * constructes an MapInfoObject without an associated map but with 1 Pixel = scale meters
 	 */
 	public MapInfoObject(double scalei, double lat) {
-		super(new CWPoint(1,0), new CWPoint(0,1));
-		mapName=MyLocale.getMsg(4300, "empty 1 Pixel = ") + scalei + MyLocale.getMsg(4301,"meters");
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deg / java.lang.Math.cos(lat*java.lang.Math.PI / 180); //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=1; //top
-		topleft.lonDec=0; //left
-		buttomright.latDec = 0; //buttom
-		buttomright.lonDec = 1; //right
+		super(new CWPoint(1, 0), new CWPoint(0, 1));
+		mapName = MyLocale.getMsg(4300, "empty 1 Pixel = ") + scalei + MyLocale.getMsg(4301, "meters");
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deg / java.lang.Math.cos(lat * java.lang.Math.PI / 180); // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = 1; // top
+		topleft.lonDec = 0; // left
+		bottomright.latDec = 0; // bottom
+		bottomright.lonDec = 1; // right
 		affineTopleft.set(topleft);
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 	}
 
 	/**
-	 * constructs an MapInfoObject with an associated map
-	 * with 1 Pixel = scale meters, centre and width, hight in pixels
-	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 * constructs an MapInfoObject with an associated map with 1 Pixel = scale meters, centre and width, hight in pixels
+	 * 
+	 * @param name
+	 *            path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
 	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
 		super();
-		mapName = name+".wfl";
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deghorizontal; //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=center.latDec + hight / 2 *pixel2deg; //top
-		topleft.lonDec=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		mapName = name + ".wfl";
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		final double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec * java.lang.Math.PI / 180);
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deghorizontal; // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = center.latDec + hight / 2 * pixel2deg; // top
+		topleft.lonDec = center.lonDec - width / 2 * pixel2deghorizontal; // left
 		affineTopleft.set(topleft);
-		buttomright.latDec = center.latDec - hight / 2 *pixel2deg; //buttom
-		buttomright.lonDec = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		bottomright.latDec = center.latDec - hight / 2 * pixel2deg; // bottom
+		bottomright.lonDec = center.lonDec + width / 2 * pixel2deghorizontal; // right
 		fileNameWFL = name;
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 		doCalculations();
@@ -154,42 +158,51 @@
 
 	/**
 	 * 
-	 * @param path including trailing "/"
-	 * @param n without ".wfl"
+	 * @param path
+	 *            including trailing "/"
+	 * @param n
+	 *            without ".wfl"
 	 * @return name of the map including fast-find-prefix
 	 */
 	public String setName(String path, String n) {
-		String pref = getFfPrefix();
+		final String pref = getFfPrefix();
 		mapName = pref + n;
 		fileNameWFL = path + pref + mapName + ".wfl";
 		return mapName;
 	}
 
-	/** 
+	/**
 	 * @return the filename of the associated map image, "" if no file is associated, null if associated file could not be found
 	 */
 	public String getImageFilename() {
-		// if (fileName == null || fileName.length() > 0) return fileName; 
-		if (fileNameWFL.length() == 0) return ""; // no image associated (empty map)
-		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
+		// if (fileName == null || fileName.length() > 0) return fileName;
+		if (fileNameWFL.length() == 0)
+			return ""; // no image associated (empty map)
+		final String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
 		return Common.getImageName(CacheWolf.STRreplace.replace(n, "//", "/"));
 	}
 
 	/**
 	 * Method to load a .wfl-file
-	 * @param mapsPath path to the map inclunding / at the end
-	 * @param thisMap name of the map without extension
-	 * @throws IOException when there was a problem reading .wfl-file
-	 * @throws IOException when lat/lon were out of range
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @param mapsPath
+	 *            path to the map inclunding / at the end
+	 * @param thisMap
+	 *            name of the map without extension
+	 * @throws IOException
+	 *             when there was a problem reading .wfl-file
+	 * @throws IOException
+	 *             when lat/lon were out of range
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
-		FileInputStream instream = new FileInputStream (CacheWolf.STRreplace.replace(mapsPath + thisMap + ".wfl", "//", "/"));
-		InputStreamReader in = new InputStreamReader(instream);
-		
+		final FileInputStream instream = new FileInputStream(CacheWolf.STRreplace.replace(mapsPath + thisMap + ".wfl", "//", "/"));
+		final InputStreamReader in = new InputStreamReader(instream);
+
 		String line = "";
 		try {
-			for(int i = 0; i<4;i++){
+			for (int i = 0; i < 4; i++) {
 				line = in.readLine();
 				affine[i] = Common.parseDoubleException(line);
 			}
@@ -198,23 +211,31 @@
 			line = in.readLine();
 			affineTopleft.lonDec = Common.parseDoubleException(line);
 			line = in.readLine();
-			buttomright.latDec = Common.parseDoubleException(line);
+			bottomright.latDec = Common.parseDoubleException(line);
 			line = in.readLine();
-			buttomright.lonDec = Common.parseDoubleException(line);
-			line = in.readLine(); // readLine returns null, if End of File reached
-			if (line != null) coordTrans = Common.parseInt(line);
-			else coordTrans = 0;
+			bottomright.lonDec = Common.parseDoubleException(line);
+			line = in.readLine(); // readLine returns null, if End of File
+									// reached
+			if (line != null)
+				coordTrans = Common.parseInt(line);
+			else
+				coordTrans = 0;
 			fileNameWFL = mapsPath + thisMap + ".wfl";
-//			fileName = ""; //mapsPath + thisMap + ".png";
+			// fileName = ""; //mapsPath + thisMap + ".png";
 			mapName = thisMap;
 			in.close();
-			if( !buttomright.isValid() ) {
-				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; 
+			if (!bottomright.isValid()) {
+				affine[0] = 0;
+				affine[1] = 0;
+				affine[2] = 0;
+				affine[3] = 0;
 				topleft.makeInvalid();
-				throw (new IOException(MyLocale.getMsg(4301, "Lat/Lon out of range while reading ")+mapsPath + thisMap + ".wfl"));
+				throw (new IOException(MyLocale.getMsg(4301, "Lat/Lon out of range while reading ") + mapsPath + thisMap + ".wfl"));
 			}
-		} catch (NullPointerException e) { // in.readline liefert null zur?ck, wenn keine Daten mehr vorhanden sind
-			throw (new IOException(MyLocale.getMsg(4303, "not enough lines in file ")+mapsPath + thisMap + ".wfl"));
+		} catch (final NullPointerException e) { // in.readline liefert null
+													// zur?ck, wenn keine Daten
+													// mehr vorhanden sind
+			throw (new IOException(MyLocale.getMsg(4303, "not enough lines in file ") + mapsPath + thisMap + ".wfl"));
 		}
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
@@ -223,24 +244,30 @@
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
 		evalGCP(GCPs, imageWidth, imageHeight, 0);
 	}
-		/**
-	 *	Method to evaluate ground control points (georeferenced points) and identify the parameters
-	 *	for the affine transformation
-	 *  @throws IllegalArgumentException when less than 3 georeferenced points were given in GCPs
+
+	/**
+	 * Method to evaluate ground control points (georeferenced points) and identify the parameters for the affine transformation
+	 * 
+	 * @throws IllegalArgumentException
+	 *             when less than 3 georeferenced points were given in GCPs
 	 */
 
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight, int epsg_code) throws IllegalArgumentException {
-		//N 48 16.000 E 11 32.000
-		//N 48 16.000 E 11 50.000
-		//N 48 9.000 E 11 32.000
-		if (GCPs.size() < 3 ) throw new IllegalArgumentException(MyLocale.getMsg(4304, "not enough points to calibrate the map"));
+		// N 48 16.000 E 11 32.000
+		// N 48 16.000 E 11 50.000
+		// N 48 9.000 E 11 32.000
+		if (GCPs.size() < 3)
+			throw new IllegalArgumentException(MyLocale.getMsg(4304, "not enough points to calibrate the map"));
 		GCPoint gcp = new GCPoint();
-		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
-		Matrix X = new Matrix(GCPs.size(),3);
-		Matrix trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+		// Calculate parameters for latitutde affine transformation (affine
+		// 0,2,4)
+		Matrix X = new Matrix(GCPs.size(), 3);
+		Matrix trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i < GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
 			trg.matrix[i][0] = gcp.latDec;
 		}
 		Matrix Xtran = new Matrix(X);
@@ -256,11 +283,12 @@
 		affine[2] = beta.matrix[2][0];
 		affineTopleft.latDec = beta.matrix[0][0];
 
-		//Calculate parameters for longitude affine transformation (affine 1,3,5)
-		X = new Matrix(GCPs.size(),3);
-		trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
+		// Calculate parameters for longitude affine transformation (affine
+		// 1,3,5)
+		X = new Matrix(GCPs.size(), 3);
+		trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i < GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
 			X.matrix[i][0] = 1;
 			X.matrix[i][1] = gcp.bitMapX;
 			X.matrix[i][2] = gcp.bitMapY;
@@ -279,130 +307,156 @@
 		affine[3] = beta.matrix[2][0];
 		affineTopleft.lonDec = beta.matrix[0][0];
 		coordTrans = epsg_code;
-		buttomright = calcLatLon(imageWidth, imageHeight);
+		bottomright = calcLatLon(imageWidth, imageHeight);
 		doCalculations();
 	}
 
 	/**
 	 * calculates centre, diagonal size of the map and inverse to affine transformation
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 
 	private void doCalculations() throws ArithmeticException {
 		try {
 			topleft.set(calcLatLon(0, 0));
-			center.set((buttomright.latDec + topleft.latDec)/2,(buttomright.lonDec + topleft.lonDec)/2);
-			sizeKm = java.lang.Math.abs((float)center.getDistance(buttomright)) *2;
+			center.set((bottomright.latDec + topleft.latDec) / 2, (bottomright.lonDec + topleft.lonDec) / 2);
+			sizeKm = java.lang.Math.abs((float) center.getDistance(bottomright)) * 2;
 
-			//calculate reverse affine
-			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
-			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
-			transLonX = -affine[2]/nenner;
-			transLatY = -affine[1]/nenner;
-			transLonY = affine[0]/nenner;
+			// calculate reverse affine
+			final double nenner = (-affine[1] * affine[2] + affine[0] * affine[3]);
+			transLatX = affine[3] / nenner; // nenner == 0 cannot happen as long
+											// als affine is correct
+			transLonX = -affine[2] / nenner;
+			transLatY = -affine[1] / nenner;
+			transLonY = affine[0] / nenner;
 
 			// calculate north direction
-			Point c = calcMapXY(center);
-			int heightpixel = c.y * 2;
+			final Point c = calcMapXY(center);
+			final int heightpixel = c.y * 2;
 			c.y -= 1000;
-			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);  // note: the direction of nord can vary across the image. In Gau?-Kr?ger Projection it does change about 1 degree per 10km! //(float)java.lang.Math.atan(rotationX2y);
-			if (rotationRad > Math.PI) rotationRad -= 2* Math.PI;
+			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);
+			// note: the direction of nord can vary across the image.
+			// In Gau?-Kr?ger Projection it does change about 1 degree per 10km!
+			// (float)java.lang.Math.atan(rotationX2y);
+			if (rotationRad > Math.PI)
+				rotationRad -= 2 * Math.PI;
 
 			// calculate scale in meters per pixel
-			double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
+			final double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
 			scale = (float) (heightkm * 1000 / heightpixel);
-		} catch (ArithmeticException ex) { throw new ArithmeticException(MyLocale.getMsg(4305, "Not allowed values in affine\n (matrix cannot be inverted)\n in file \n") + fileNameWFL); }
+		} catch (final ArithmeticException ex) {
+			throw new ArithmeticException(MyLocale.getMsg(4305, "Not allowed values in affine\n (matrix cannot be inverted)\n in file \n") + fileNameWFL);
+		}
 	}
 
 	public void saveWFL() throws IOException, IllegalArgumentException {
-		File dateiF = new FileBugfix(fileNameWFL);
-		String tmp = dateiF.getDrivePath(); // contains the name and the extension
+		final File dateiF = new FileBugfix(fileNameWFL);
+		final String tmp = dateiF.getDrivePath(); // contains the name and the
+													// extension
 		saveWFL(tmp, mapName);
 	}
 
 	/**
-	 *	Method to save a world file (.wfl)
-	 * @param mapsPath without "/" at the end
-	 * @param mapFileName without file extension
-	 * @throws IOException when there was a problem writing .wfl-file
-	 * @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
+	 * Method to save a world file (.wfl)
+	 * 
+	 * @param mapsPath
+	 *            without "/" at the end
+	 * @param mapFileName
+	 *            without file extension
+	 * @throws IOException
+	 *             when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException
+	 *             when affine[x] for all x == 0 ("map not calibrated").
 	 */
 	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
-		if (affine[0]==0 && affine[1]==0 && affine[2]==0 && affine[3]==0 && 
-				!topleft.isValid()) throw (new IllegalArgumentException(MyLocale.getMsg(4306, "map not calibrated")));
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
-		StringBuffer towriteB=new StringBuffer(400);
+		if (mapsPath.endsWith("/")) {
+			mapsPath = mapsPath.substring(0, mapsPath.length() - 1);
+		}
+		if (affine[0] == 0 && affine[1] == 0 && affine[2] == 0 && affine[3] == 0 && !topleft.isValid())
+			throw (new IllegalArgumentException(MyLocale.getMsg(4306, "map not calibrated")));
+		final PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
+		final StringBuffer towriteB = new StringBuffer(400);
 		towriteB.append(Convert.toString(affine[0])).append("\n");
 		towriteB.append(Convert.toString(affine[1])).append("\n");
 		towriteB.append(Convert.toString(affine[2])).append("\n");
 		towriteB.append(Convert.toString(affine[3])).append("\n");
 		towriteB.append(Convert.toString(affineTopleft.latDec)).append("\n");
 		towriteB.append(Convert.toString(affineTopleft.lonDec)).append("\n");
-		towriteB.append(Convert.toString(buttomright.latDec)).append("\n");
-		towriteB.append(Convert.toString(buttomright.lonDec)).append("\n");
-		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? "" : Convert.toString(coordTrans)+"\n"));
+		towriteB.append(Convert.toString(bottomright.latDec)).append("\n");
+		towriteB.append(Convert.toString(bottomright.lonDec)).append("\n");
+		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? "" : Convert.toString(coordTrans) + "\n"));
 		String towrite = towriteB.toString();
-		if (digSep.equals(",")) towrite=towrite.replace(',', '.');
+		if (digSep.equals(","))
+			towrite = towrite.replace(',', '.');
 		outp.print(towrite);
 		outp.close();
-//		this.fileName = ""; // this will be set in getImageFilenam //mapsPath + "/" + mapFileName + ".png";
+		// this.fileName = ""; // this will be set in getImageFilenam //mapsPath
+		// + "/" + mapFileName + ".png";
 		this.fileNameWFL = mapsPath + "/" + mapFileName + ".wfl";
 		this.mapName = mapFileName;
 	}
 
-
 	/**
 	 * zoom in / out
-	 * @param zf zf > 1 == zoom in, zoom is relative to original unscaled image
-	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * 
+	 * @param zf
+	 *            zf > 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX
+	 *            shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
 	 * @param diffY
 	 */
 	public void zoom(float zf, int diffX, int diffY) {
 		// restore original values to calculate corret shift (upperleft)
 		affineTopleft.latDec = origAffineUpperLeft.latDec;
 		affineTopleft.lonDec = origAffineUpperLeft.lonDec;
-		affine[0] = affine[0] * zoomFactor; 
-		affine[1] = affine[1] * zoomFactor; 
+		affine[0] = affine[0] * zoomFactor;
+		affine[1] = affine[1] * zoomFactor;
 		affine[2] = affine[2] * zoomFactor;
 		affine[3] = affine[3] * zoomFactor;
 		TrackPoint upperleft = calcLatLon(diffX, diffY);
-		if (coordTrans != 0) upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
-		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken affineTopleft
+		if (coordTrans != 0)
+			upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
+		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken
+													// affineTopleft
 		affineTopleft.lonDec = upperleft.lonDec;
-		affine[0] = affine[0] / zf ; 
-		affine[1] = affine[1] / zf ; 
-		affine[2] = affine[2] / zf ; 
-		affine[3] = affine[3] / zf ; 
-		zoomFactor = zf ;
+		affine[0] = affine[0] / zf;
+		affine[1] = affine[1] / zf;
+		affine[2] = affine[2] / zf;
+		affine[3] = affine[3] / zf;
+		zoomFactor = zf;
 		shift.x = diffX;
 		shift.y = diffY;
 		doCalculations(); // TODO lowlat neu berechnen?
 	}
 
 	/**
-	 * Method to calculate bitmap x,y of the current map using
-	 * lat and lon target coordinates. There ist no garanty that
-	 * the returned coordinates are inside of the map. They can be negative.
+	 * Method to calculate bitmap x,y of the current map using lat and lon target coordinates. There ist no garanty that the returned coordinates are inside of the map. They can be negative.
+	 * 
 	 * @param lat
 	 * @param lon
 	 */
-	public Point calcMapXY(TrackPoint ll){
+	public Point calcMapXY(TrackPoint ll) {
 		TrackPoint t;
-		if (coordTrans != 0) t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
-		else t = ll;
-		Point coords = new Point();
+		if (coordTrans != 0)
+			t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
+		else
+			t = ll;
+		final Point coords = new Point();
 		double b0, b1;
 		b0 = t.latDec - affineTopleft.latDec;
 		b1 = t.lonDec - affineTopleft.lonDec;
-		double mapx = transLatX * b0 + transLonX * b1;
-		double mapy = transLatY * b0 + transLonY * b1;
-		coords.x = (int)Math.round(mapx);
-		coords.y = (int)Math.round(mapy);
+		final double mapx = transLatX * b0 + transLonX * b1;
+		final double mapy = transLatY * b0 + transLonY * b1;
+		coords.x = (int) Math.round(mapx);
+		coords.y = (int) Math.round(mapy);
 		return coords;
 	}
 
 	/**
 	 * gives back lat/lon from x, y in map
+	 * 
 	 * @param x
 	 * @param y
 	 * @return
@@ -415,51 +469,49 @@
 			ll = TransformCoordinatesProperties.toWgs84(ll, coordTrans);
 		return ll;
 	}
-	
+
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);
 	}
 
 	/**
-	 * Get the prefix used for easy and fast finding of the best map
-	 * The filname of the .wfl and respective image should start with this
-	 * prefix in order to make finding the best map much faster 
+	 * Get the prefix used for easy and fast finding of the best map The filname of the .wfl and respective image should start with this prefix in order to make finding the best map much faster
+	 * 
 	 * @return
 	 */
 	public String getFfPrefix() {
-		return "FF1"+getEasyFindString()+"E-";
+		return "FF1" + getEasyFindString() + "E-";
 	}
 }
 
-	/**
-	 *	Class based on CWPoint but intended to handle bitmap x and y
-	 *	Used for georeferencing bitmaps.
-	 */
-	class GCPoint extends CWPoint{
-		public int bitMapX = 0;
-		public int bitMapY = 0;
+/**
+ * Class based on CWPoint but intended to handle bitmap x and y Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint {
+	public int bitMapX = 0;
+	public int bitMapY = 0;
 
-		public GCPoint(){ // Public constructor
-		}
+	public GCPoint() { // Public constructor
+	}
 
-		public GCPoint(CWPoint p) {
-			super(p);
-		}
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
 
-		/**
-		 * If you are using Gau?-Kr?ger, put lat = northing, lon = easting 
-		 * @param lat
-		 * @param lon
-		 */
-		public GCPoint(double lat, double lon){
-			this.latDec = lat;
-			this.lonDec = lon;
-		}
-		
-		public GCPoint(CWPoint ll, Point px) {
-			super(ll);
-			bitMapX = px.x;
-			bitMapY = px.y;
-		}
+	/**
+	 * If you are using Gau?-Kr?ger, put lat = northing, lon = easting
+	 * 
+	 * @param lat
+	 * @param lon
+	 */
+	public GCPoint(double lat, double lon) {
+		this.latDec = lat;
+		this.lonDec = lon;
 	}
-	
\ No newline at end of file
+
+	public GCPoint(CWPoint ll, Point px) {
+		super(ll);
+		bitMapX = px.x;
+		bitMapY = px.y;
+	}
+}

Modified: branches/r1.2/src/CacheWolf/navi/MapLoader.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapLoader.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapLoader.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,70 +1,71 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import CacheWolf.HttpConnection;
 import CacheWolf.InfoBox;
 import CacheWolf.MyLocale;
 import CacheWolf.STRreplace;
+import CacheWolf.UrlFetcher;
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.Point;
+import ewe.io.BufferedWriter;
 import ewe.io.File;
 import ewe.io.FileBase;
 import ewe.io.FileInputStream;
-import ewe.io.FileOutputStream;
+import ewe.io.FileReader;
+import ewe.io.FileWriter;
 import ewe.io.IOException;
-import ewe.net.Socket;
+import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 import ewe.sys.Double;
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
-import ewe.util.ByteArray;
 import ewe.util.Properties;
 import ewe.util.StandardComparer;
 import ewe.util.Utils;
 import ewe.util.Vector;
 import ewe.util.mString;
 
-
 /**
- *
+ * 
  * start offset for language file: 4800
  */
 
-//Um Karten zu holen!
-//http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.09901667,11.35688333&Lang=EUR0407&Alti=1&Size=600,600&Offs=0.000000,0.000000&Pins=|5748|
-//oder
-//http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
+// Um Karten zu holen!
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.09901667,11.35688333&Lang=EUR0407&Alti=1&Size=600,600&Offs=0.000000,0.000000&Pins=|5748|
+// oder
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
 
-
 public class MapLoader {
 	InfoBox progressInfobox;
 
@@ -75,17 +76,19 @@
 	double latinc;
 	double loninc;
 	CWPoint topleft;
-	CWPoint buttomright;
+	CWPoint bottomright;
 	Point tilesSize;
 	float tileScale;
+	boolean fetchOnlyMapWithCache = false;
 
 	/**
-	 *
+	 * 
 	 * @param prxy
 	 * @param prt
-	 * @param wmspath without trailing "/"
+	 * @param wmspath
+	 *            without trailing "/"
 	 */
-	public MapLoader(String wmspath){
+	public MapLoader(String wmspath) {
 		long start = new Time().getTime();
 		InfoBox progressBox = null;
 		boolean showprogress = false;
@@ -96,11 +99,11 @@
 		String FileName;
 		OnlineMapService tempOMS;
 		MessageBox f = null;
-		dateien = files.list("*.wms", FileBase.LIST_FILES_ONLY); //"*.xyz" doesn't work on some systems -> use FileBugFix
-		for(int i = 0; i < dateien.length;i++){
+		dateien = files.list("*.wms", FileBase.LIST_FILES_ONLY); // "*.xyz" doesn't work on some systems -> use FileBugFix
+		for (int i = 0; i < dateien.length; i++) {
 			FileName = dateien[i];
 			try {
-				if (!showprogress && ((i & 0) == 0) && (new Time().getTime()-start  > 100) ) { // reason for (i & 7 == 0): test time only after i is incremented 15 times
+				if (!showprogress && ((i & 0) == 0) && (new Time().getTime() - start > 100)) { // reason for (i & 7 == 0): test time only after i is incremented 15 times
 					showprogress = true;
 					progressBox = new InfoBox(MyLocale.getMsg(327, "Info"), MyLocale.getMsg(4800, "Loading online map services"));
 					progressBox.exec();
@@ -109,8 +112,9 @@
 				}
 				tempOMS = new WebMapService(STRreplace.replace(wmspath + "/" + FileName, "//", "/"));
 				onlineMapServices.add(tempOMS);
-			}catch(Exception ex){
-				if (f == null) (f=new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(4801, "Ignoring error while \n reading web map service definition file \n")+ex.toString(), FormBase.OKB)).exec();
+			} catch (Exception ex) {
+				if (f == null)
+					(f = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(4801, "Ignoring error while \n reading web map service definition file \n") + ex.toString(), FormBase.OKB)).exec();
 			}
 		}
 		tempOMS = new ExpediaMapService();
@@ -121,26 +125,33 @@
 		}
 	}
 
-	public String[] getAvailableOnlineMapServices(){
+	public void setFetchOnlyMapWithCache(boolean value) {
+		fetchOnlyMapWithCache = value;
+	}
+
+	public String[] getAvailableOnlineMapServices() {
 		int s = onlineMapServices.size();
 		String[] services = new String[s];
-		for (int i=0; i < s; i++) {
-			services[i]=onlineMapServices.get(i).toString();
+		for (int i = 0; i < s; i++) {
+			services[i] = onlineMapServices.get(i).toString();
 		}
 		return services;
 	}
 
 	public void setCurrentMapService(int index) {
-		if (index==-1) index=0; // if no center set
+		if (index == -1)
+			index = 0; // if no center set
 		currentOnlineMapService = (OnlineMapService) onlineMapServices.get(index);
 	}
 
 	/**
 	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * 
 	 * @param center
-	 * @param distance in meters
+	 * @param distance
+	 *            in meters
 	 * @return meters per pixel calculatet in a way that the circle around center
-	 * is completly within the map
+	 *         is completly within the map
 	 */
 
 	public static float getScale(CWPoint center, float distance, Point size) {
@@ -153,59 +164,66 @@
 	/**
 	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
 	 * in path
-	 * @param center centre of all tiles
-	 * @param radius in meters
-	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
-	 * @param size in pixels
-	 * @param overlapping in pixels
-	 * @param path without "/" at the end
-	 *
+	 * 
+	 * @param center
+	 *            centre of all tiles
+	 * @param radius
+	 *            in meters
+	 * @param scale
+	 *            in "alti" value 1 alti = 3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size
+	 *            in pixels
+	 * @param overlapping
+	 *            in pixels
+	 * @param path
+	 *            without "/" at the end
+	 * 
 	 */
-	public void setTiles (CWPoint center, float radius, float scale, Point size, int overlapping) {
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+	public void setTiles(CWPoint center, float radius, float scale, Point size, int overlapping) {
+		double metersPerLat = (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec / 180 * java.lang.Math.PI);
 		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
-		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
+		bottomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
 
-		this.setTiles(topleft, buttomright, scale, size, overlapping);
+		this.setTiles(topleft, bottomright, scale, size, overlapping);
 	}
 
-	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, float scale, Point size, int overlapping) {
-		//if (toplefti.latDec <= buttomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above buttom right");
+	public void setTiles(CWPoint toplefti, CWPoint bottomrighti, float scale, Point size, int overlapping) {
+		// if (toplefti.latDec <= bottomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above bottom right");
 		topleft = new CWPoint(toplefti);
-		buttomright = new CWPoint(buttomrighti);
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
+		bottomright = new CWPoint(bottomrighti);
+		double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
 		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
 		double pixelsPerLat = metersPerLat / metersperpixel;
 		double pixelsPerLon = metersPerLon / metersperpixel;
 
-		//over all pixelsize without borders
-		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat;
-		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ;
+		// over all pixelsize without borders
+		double pixelsY = (topleft.latDec - bottomright.latDec) * pixelsPerLat;
+		double pixelsX = -(topleft.lonDec - bottomright.lonDec) * pixelsPerLon;
 
-		//border sizes around given area and overlapping between tiles
-		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
-		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		// border sizes around given area and overlapping between tiles
+		// int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		// int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
 		int borderX = overlapping;
 		int borderY = overlapping;
 
-		numMapsY = (int) java.lang.Math.ceil( (pixelsY + borderY) / (size.y - borderY) );
-		numMapsX = (int) java.lang.Math.ceil( (pixelsX + borderX) / (size.x - borderX) );
+		numMapsY = (int) java.lang.Math.ceil((pixelsY + borderY) / (size.y - borderY));
+		numMapsX = (int) java.lang.Math.ceil((pixelsX + borderX) / (size.x - borderX));
 
-		//increments calulated from pixel offset of tiles
+		// increments calulated from pixel offset of tiles
 		latinc = -(size.y - borderY) / pixelsPerLat;
 		loninc = (size.x - borderX) / pixelsPerLon;
 
-		//calculation of centre of first tile
+		// calculation of centre of first tile
 
-		//additional size for borders and rounding
+		// additional size for borders and rounding
 		double oversizeX = (numMapsX * (size.x - borderX) + borderX) - pixelsX;
 		double oversizeY = (numMapsY * (size.y - borderY) + borderY) - pixelsY;
 
-		//offset for upper left corner
-		double offsetLat = -( (size.y - oversizeY) / 2.0 ) / pixelsPerLat;
-		double offsetLon = ( (size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		// offset for upper left corner
+		double offsetLat = -((size.y - oversizeY) / 2.0) / pixelsPerLat;
+		double offsetLon = ((size.x - oversizeX) / 2.0) / pixelsPerLon;
 
 		topleft.latDec += offsetLat;
 		topleft.lonDec += offsetLon;
@@ -222,82 +240,285 @@
 		for (int row = 1; row <= numMapsY; row++) {
 			lon = topleft.lonDec;
 			for (int col = 1; col <= numMapsX; col++) {
-				if (progressInfobox != null)
-					progressInfobox.setInfo(MyLocale.getMsg(4802, "Downloading calibrated (georeferenced) \n map image \n '") + currentOnlineMapService.getName()+MyLocale.getMsg(4803, "' \n Downloading tile \n row")+" "+row+" / "+numMapsY+MyLocale.getMsg(4804, " column")+" "+ col + " / "+numMapsX);
 				center.set(lat, lon);
-				try {
-					downloadMap(center, tileScale, tilesSize, tilesPath);
-				} catch (Exception e) {
-					this.progressInfobox.addWarning(MyLocale.getMsg(4805, "Tile")+" " + row + "/" + col + MyLocale.getMsg(4806, ": Ignoring error:")+" " + e.getMessage()+"\n");
+				if (!fetchOnlyMapWithCache || hasCache(center, latinc, loninc)) {
+					if (progressInfobox != null)
+						progressInfobox.setInfo(MyLocale.getMsg(4802, "Downloading calibrated (georeferenced) \n map image \n '") + currentOnlineMapService.getName() + MyLocale.getMsg(4803, "' \n Downloading tile \n row") + " " + row + " / " + numMapsY
+								+ MyLocale.getMsg(4804, " column") + " " + col + " / " + numMapsX);
+					try {
+						downloadMap(center, tileScale, tilesSize, tilesPath);
+					} catch (Exception e) {
+						this.progressInfobox.addWarning(MyLocale.getMsg(4805, "Tile") + " " + row + "/" + col + MyLocale.getMsg(4806, ": Ignoring error:") + " " + e.getMessage() + "\n");
+					}
+					if (progressInfobox.isClosed)
+						return;
 				}
-				if (progressInfobox.isClosed) return;
 				lon += loninc;
 			}
 			lat += latinc;
 		}
 	}
 
-	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+	private boolean hasCache(CWPoint center, double latinc, double loninc) {
+		double lat = center.latDec - (latinc / 2.0);
+		double lon = center.lonDec - (loninc / 2.0);
+		CWPoint tl = new CWPoint(lat, lon);
+		lat = center.latDec + (latinc / 2.0);
+		lon = center.lonDec + (loninc / 2.0);
+		CWPoint br = new CWPoint(lat, lon);
+		Area maparea = new Area(tl, br);
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		for (int i = 0; i < cacheDB.size(); i++) {
+			CacheHolder ch = cacheDB.get(i);
+			if (maparea.isInBound(ch.getPos())) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public void setProgressInfoBox(InfoBox progrssInfoboxi) {
 		progressInfobox = progrssInfoboxi;
 	}
+
 	/**
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
-	 * @param path must include trailing "/"
+	 * @param path
+	 *            must include trailing "/"
 	 * @throws Exception
 	 */
 	public void downloadMap(CWPoint center, float scale, Point pixelsize, String path) throws Exception {
 		MapInfoObject mio = currentOnlineMapService.getMapInfoObject(center, scale, pixelsize);
 		String filename = createFilename(mio.getCenter(), mio.scale);
-		String imagename = mio.setName(path, filename) + currentOnlineMapService.getImageFileExt();
+		String imagename = mio.setName(path, filename);
+		String imagetype = currentOnlineMapService.getImageFileExt();
 		String url = currentOnlineMapService.getUrlForCenterScale(center, scale, pixelsize);
-		if (currentOnlineMapService instanceof ExpediaMapService) {
-			downloadImage(url, path+imagename);
-			mio.saveWFL();
-		}
-		else {
-			WebMapService wms = (WebMapService) currentOnlineMapService;
-			if (wms.requestUrlPart.equalsIgnoreCase("Kosmos")) {
-				url="bitmapgen"+
-					" \""+FileBase.getProgramDirectory().replace('/',File.separatorChar)+"\\"+wms.serviceTypeUrlPart+"\""+
-					" \""+path.replace('/', File.separatorChar)+imagename+"\""+
-					" -mb "+url; // + minx miny maxx maxy + pixelsize.x
-				File f=new FileBugfix(wms.MainUrl);
-				if (!f.exists() || !f.canRead()) {
-					MessageBox mb=new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(1834,"Please enter the correct path to Kosmos.Console.exe into the wms-file."),ewe.ui.MessageBox.OKB);
-					mb.execute();
+		String fName = path + imagename + imagetype;
+		FileBugfix fn = new FileBugfix(path + imagename + ".wfl");
+		FileBugfix fn1 = new FileBugfix(fName);
+		if (!fn.exists() || fn.length() == 0 || !fn1.exists() || fn1.length() == 0) {
+			if (currentOnlineMapService instanceof ExpediaMapService) {
+				downloadImage(url, path + imagename + imagetype);
+			} else {
+				WebMapService wms = (WebMapService) currentOnlineMapService;
+				if (wms.requestUrlPart.startsWith("REQUEST")) {
+					downloadImage(url, path + imagename + imagetype);
 				} else {
-					Vm.exec(wms.MainUrl.replace('/', File.separatorChar), url, 0, true);
-					mio.saveWFL();
+					Area maparea = wms.CenterScaleToArea(center, scale, pixelsize);
+					CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+					CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+
+					String mapProgramPath = wms.versionUrlPart + "/";
+					mapProgramPath = mapProgramPath.replace('/', FileBase.separatorChar);
+					String mapProgram = mapProgramPath + wms.MainUrl;
+					File f = new FileBugfix(mapProgram);
+					if (!f.exists() || !f.canRead()) {
+						MessageBox mb = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1834, "Please enter the correct path to Kosmos.Console.exe into the wms-file."), ewe.ui.MessageBox.OKB);
+						mb.execute();
+						return;
+					}
+
+					String mapProgramParams = "";
+
+					if (wms.requestUrlPart.equalsIgnoreCase("Kosmos")) {
+						// minx miny maxx maxy + pixelsize.x
+						mapProgramParams = "bitmapgen" + " \"" + FileBase.getProgramDirectory().replace('/', File.separatorChar) + "\\" + wms.serviceTypeUrlPart + "\"" + " \"" + path.replace('/', File.separatorChar) + imagename + imagetype + "\""
+								+ " -mb " + bottomleft.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + " " + topright.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + " -w " + pixelsize.x;
+						Vm.exec(mapProgram, mapProgramParams, 0, true);
+					} else {
+						if (wms.requestUrlPart.equalsIgnoreCase("Maperitive")) {
+							// Maperitive runs on Windows and Linux
+							// generating scriptfile for Maperitive from wmsfile
+							String cwPath = FileBase.getProgramDirectory().replace('/', FileBase.separatorChar) + FileBase.separatorChar;
+							String scriptFileName = cwPath + "maperitive.script";
+
+							PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(scriptFileName)));
+							outp.println("use-ruleset alias=default");
+							outp.println("clear-map");
+
+							if (wms.serviceTypeUrlPart.equals("")) {
+								outp.println("add-web-map");
+							} else {
+								outp.println("add-web-map provider=" + wms.serviceTypeUrlPart);
+							}
+
+							if (!wms.stylesUrlPart.equals("")) {
+								String myrules = mapProgramPath + wms.stylesUrlPart.replace('/', FileBase.separatorChar);
+								outp.println("use-ruleset location=" + myrules);
+								// outp.println("apply-ruleset");
+							}
+							if (!wms.layersUrlPart.equals("")) {
+								outp.println("clear-map");
+								outp.println("load-source " + mapProgramPath + wms.layersUrlPart.replace('/', FileBase.separatorChar));
+								// implicit does apply-ruleset
+							}
+
+							String koords = bottomleft.toString(TransformCoordinates.LON_LAT) + "," + topright.toString(TransformCoordinates.LON_LAT);
+							outp.println("bounds-set " + koords);
+							outp.println("zoom-bounds");
+							if (path.indexOf(':') == 1) {
+								outp.print("export-bitmap file=" + "\"" + fName + "\"");
+							} else {
+								outp.print("export-bitmap file=" + fName);
+							}
+							outp.print(" bounds=" + koords);
+							String pxSize = " width=" + pixelsize.x + " height=" + pixelsize.y;
+							outp.print(pxSize);
+							outp.println(" kml=false");
+							outp.close();
+							// executing the generated script
+							if (mapProgram.indexOf(':') == 1) {
+								mapProgramParams = "-exitafter " + "\"" + scriptFileName + "\"";
+							} else {
+								mapProgramParams = "-exitafter " + scriptFileName;
+							}
+							Vm.exec(mapProgram, mapProgramParams, 0, true);
+							// preparation for generating wfl from the ozi map-file
+							Vector GCPs = map2wfl(path + imagename);
+							mio.evalGCP(GCPs, pixelsize.x, pixelsize.y);
+							// can not supress genaration of pgw,jgw-file
+							FileBugfix pgwFile = new FileBugfix(path + imagename + ".pgw"); // seems to bee for png
+							pgwFile.delete();
+							FileBugfix jgwFile = new FileBugfix(path + imagename + ".jgw"); // seems to bee for jpg
+							jgwFile.delete();
+						}
+					}
 				}
 			}
-			else {
-				downloadImage(url, path+imagename);
-				mio.saveWFL();
+			mio.saveWFL();
+		}
+	}
+
+	private Vector map2wfl(String pathAndImageName) {
+		Vector GCPs = new Vector();
+		File mapFile = new File(pathAndImageName + ".map");
+		if (mapFile.exists()) {
+			GCPoint gcp1 = new GCPoint();
+			GCPoint gcp2 = new GCPoint();
+			GCPoint gcp3 = new GCPoint();
+			GCPoint gcp4 = new GCPoint();
+			GCPoint gcpG = new GCPoint();
+			String line = "";
+			String[] parts;
+			try {
+				FileReader inMap = new FileReader(pathAndImageName + ".map");
+				while ((line = inMap.readLine()) != null) {
+					if (line.equals("MMPNUM,4")) {
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp1.bitMapX = Convert.toInt(parts[2]);
+						gcp1.bitMapY = Convert.toInt(parts[3]);
+						if (gcp1.bitMapX == 0)
+							gcp1.bitMapX = 1;
+						if (gcp1.bitMapY == 0)
+							gcp1.bitMapY = 1;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp2.bitMapX = Convert.toInt(parts[2]);
+						gcp2.bitMapY = Convert.toInt(parts[3]);
+						if (gcp2.bitMapX == 0)
+							gcp2.bitMapX = 1;
+						if (gcp2.bitMapY == 0)
+							gcp2.bitMapY = 1;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp3.bitMapX = Convert.toInt(parts[2]);
+						gcp3.bitMapY = Convert.toInt(parts[3]);
+						if (gcp3.bitMapX == 0)
+							gcp3.bitMapX = 1;
+						if (gcp3.bitMapY == 0)
+							gcp3.bitMapY = 1;
+						// imageWidth = gcp3.bitMapX;
+						// imageHeight = gcp3.bitMapY;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp4.bitMapX = Convert.toInt(parts[2]);
+						gcp4.bitMapY = Convert.toInt(parts[3]);
+						if (gcp4.bitMapX == 0)
+							gcp4.bitMapX = 1;
+						if (gcp4.bitMapY == 0)
+							gcp4.bitMapY = 1;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp1.bitMapX;
+						gcpG.bitMapY = gcp1.bitMapY;
+						GCPs.add(gcpG);
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp2.bitMapX;
+						gcpG.bitMapY = gcp2.bitMapY;
+						GCPs.add(gcpG);
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp3.bitMapX;
+						gcpG.bitMapY = gcp3.bitMapY;
+						GCPs.add(gcpG);
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp4.bitMapX;
+						gcpG.bitMapY = gcp4.bitMapY;
+						GCPs.add(gcpG);
+					} // if
+				} // while
+				inMap.close();
+			} catch (IllegalArgumentException ex) { // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+				Global.getPref().log(MyLocale.getMsg(4117, "Error while importing .map-file: "), ex);
+			} catch (IOException ex) {
+				Global.getPref().log(MyLocale.getMsg(4118, "IO-Error while reading or writing calibration file"), ex);
 			}
+			mapFile.delete();
+		} else { // if map file.exists
+			Global.getPref().log(MyLocale.getMsg(4119, "No calibration file found for: "), null);
 		}
+		return GCPs;
 	}
 
 	public String createFilename(CWPoint center, float scale) {
-		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem()+"_s"+Common.DoubleToString(scale,0,1)
-				+ "_c" + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
+		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem() + "_s" + Common.DoubleToString(scale, 0, 1) + "_c" + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
 		return filename;
 	}
 
 	/**
-	 * @param url usual URL. If a redirect is requiered (as in the case of
-	 * Expedia, add an "R" before "http://" --> Don't download the url, retry until getting a http-redirect
-	 * this is necessary for expedia as it delivers the image only after a http-redirect
-	 * and sometimes doesn't send a redirect on the first try
-	 * @param datei path and name of file to save to
+	 * @param url
+	 *            usual URL. If a redirect is requiered (as in the case of
+	 *            Expedia, add an "R" before "http://" --> Don't download the url, retry until getting a http-redirect
+	 *            this is necessary for expedia as it delivers the image only after a http-redirect
+	 *            and sometimes doesn't send a redirect on the first try
+	 * @param datei
+	 *            path and name of file to save to
 	 */
 	public void downloadImage(String url, String datei) throws IOException {
-		HttpConnection connImg; // TODO implement this in UrlFetcher class
-		Socket sockImg;
-		FileOutputStream fos;
-		ByteArray daten;
 		String realurl;
 		boolean forceredirect;
 		if (url.startsWith("R")) {
@@ -307,44 +528,22 @@
 			forceredirect = false;
 			realurl = url;
 		}
-		connImg = new HttpConnection(realurl);
-		connImg.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-		connImg.setRequestorProperty("Connection", "close");
-	//	this prevents gdz1.leipzig.ifag.de (dtk100) from answering and ist not necessary for expedia connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
-		connImg.documentIsEncoded = true;
-		try{
-			File dateiF = new FileBugfix(datei);
-			if(!dateiF.exists()){
-				int i=0;
-				sockImg = connImg.connect();
-				String quelle = connImg.getRedirectTo();
-				boolean redirrected = false;
-				while (i < 5 && (quelle != null || (forceredirect && !redirrected))) { // this is necessary because expedia sometimes doesn't directly anser with the redirect to the map-image, but give a page in between. Solved the problem by retrying see also: http://www.geoclub.de/viewtopic.php?p=305071#305071
-					if (quelle != null) {
-						redirrected = true;
-						sockImg.close();
-						connImg = connImg.getRedirectedConnection(quelle);
-						sockImg = connImg.connect();
-						quelle = connImg.getRedirectTo();
-					}
-					i++;
-				}
-				if (i > 4) throw new IOException(MyLocale.getMsg(4807, "loadTo: failed to download map: didn't get http-redirect"));
-				String ct = (String)connImg.documentProperties.getValue("content-type", "");
-				if (!ct.substring(0, 5).equalsIgnoreCase("image") )  {
-					String tmp = connImg.readText(sockImg, null).toString(); // TODO if the content is binary will will get an Exception in InfoBox, trying to display the content
-					tmp = tmp.substring(0, (tmp.length() < 1000 ? tmp.length() : 1000));
-					sockImg.close();
-					throw new IOException(MyLocale.getMsg(4808, "downloadImage: content-type:")+" " + ct + MyLocale.getMsg(4809, " is not an image, begin of content:")+" " + tmp);
-				}
-				daten = connImg.readData(sockImg);
-				fos = new FileOutputStream(datei); // note: using the constructor (File) instead of (String) will cause not to use the fake file system
-				fos.write(daten.toBytes());
-				fos.close();
-				sockImg.close();
+		File dateiF = new FileBugfix(datei);
+		if (!dateiF.exists()) {
+			if (forceredirect)
+				UrlFetcher.setForceRedirect();
+			UrlFetcher.fetchDataFile(realurl, datei);
+			String ct = null;
+			try {
+				ct = (String) UrlFetcher.getDocumentProperties().getValue("content-type", "no-content-type provided");
+			} catch (Exception e) {
+				ct = "document property content-type does not exist!";
 			}
-		}catch(IOException e){
-			throw new IOException(MyLocale.getMsg(4810, "Error while downloading or saving map:\n") + e.getMessage());
+			if (!ct.substring(0, 5).equalsIgnoreCase("image")) {
+				dateiF = new FileBugfix(datei);
+				dateiF.delete();
+				throw new IOException(MyLocale.getMsg(4808, "downloadImage: content-type:") + " " + ct + MyLocale.getMsg(4809, " is not an image, begin of content:") + " (deleted)");
+			}
 		}
 	}
 }
@@ -356,7 +555,7 @@
 	String mapType;
 	/** Esentially the same as name, but used for the file system. It will be part of the names of the downloaded images */
 	String filename;
-	String MainUrl; //http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS
+	String MainUrl; // http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS
 	/** including "." */
 	String imageFileExt; // ".gif", ".jpg"...
 	double recommendedScales[];
@@ -369,7 +568,7 @@
 	 * This method is used in case the online map service provides only certain steps of
 	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
 	 * will be used instead of the wished scale.
-	 *
+	 * 
 	 * @param scale
 	 * @return
 	 */
@@ -383,6 +582,7 @@
 
 	/**
 	 * Overlaod this to integrate name of layers
+	 * 
 	 * @return friendly service name
 	 */
 	public String getName() {
@@ -393,6 +593,7 @@
 	 * This method is called to get a name of the
 	 * online map service which will be part of the filename
 	 * used for the downloaded image
+	 * 
 	 * @return friendly service name
 	 */
 	public String getNameForFileSystem() {
@@ -402,10 +603,12 @@
 	public String getMapType() {
 		return mapType;
 	}
+
 	/**
 	 * Overload this and return the URL to the map image, don't call super
 	 * Alternatively overload getUrlForBoundingBoxInternal
 	 * You must overload either this method or getUrlForBoundingBox
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -421,6 +624,7 @@
 	 * This is made protected and named "...Internal" because a lot of services
 	 * don't work correctly when a map is requested, that is not exactly quadratic
 	 * --> alway use getUrlForCenter...
+	 * 
 	 * @param surArea
 	 * @param pixelsize
 	 * @return
@@ -432,6 +636,7 @@
 	/**
 	 * overload this if your map service uses a special projection
 	 * an return an Area that is quadratic in that projection
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -439,19 +644,19 @@
 	 */
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
-		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y)/2 * scale / 1000;
+		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y) / 2 * scale / 1000;
 		bbox.topleft = center.project(-45, halfdiagonal);
-		bbox.buttomright = center.project(135, halfdiagonal);
+		bbox.bottomright = center.project(135, halfdiagonal);
 		return bbox;
 	}
 
-
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
 		throw new IllegalArgumentException(MyLocale.getMsg(4811, "OnlineMapService: getMapInfoObjectInternal(Area maparea, Point pixelsize):\n This method must be overloaded in order to be able to use it"));
 	}
 
 	/**
 	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -469,9 +674,9 @@
 class WebMapService extends OnlineMapService {
 	String layersUrlPart; //
 	String versionUrlPart; // VERSION=1.1.0
-	String serviceTypeUrlPart; //"SERVICE=WMS"
+	String serviceTypeUrlPart; // "SERVICE=WMS"
 	int coordinateReferenceSystem[]; // WGS84: 4326, German GK: 31466 /
-	String coordinateReferenceSystemUrlPart[]; //&SRS=EPSG:31466
+	String coordinateReferenceSystemUrlPart[]; // &SRS=EPSG:31466
 	public String requestUrlPart;
 	String imageFormatUrlPart; // FORMAT=image/png
 	String stylesUrlPart; // STYLES=
@@ -479,12 +684,13 @@
 	double maxscaleWMS;
 
 	/**
-	 *
-	 * @param filename without file extension
+	 * 
+	 * @param filename
+	 *            without file extension
 	 * @throws IOException
 	 * @throws IllegalArgumentException
 	 */
-	public WebMapService (String filename_) throws IOException, IllegalArgumentException{
+	public WebMapService(String filename_) throws IOException, IllegalArgumentException {
 		FileInputStream in = new FileInputStream(filename_);
 		Properties wms = new Properties();
 		wms.load(in);
@@ -492,104 +698,128 @@
 		String tmp = FileBase.getFileExt(filename_);
 		this.filename = tmp.substring(0, tmp.lastIndexOf('.'));
 		name = wms.getProperty("Name", "").trim();
-		if (name == "") throw new IllegalArgumentException(MyLocale.getMsg(4812, "WebMapService: property >Name:< missing in file:\n") + filename);
-		MainUrl = wms.getProperty("MainUrl", "").trim();;
-		if (MainUrl == "") throw new IllegalArgumentException(MyLocale.getMsg(4813, "WebMapService: property >MainUrl:< missing in file:\n") + filename);
+		if (name == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4812, "WebMapService: property >Name:< missing in file:\n") + filename);
+		MainUrl = wms.getProperty("MainUrl", "").trim();
+		;
+		if (MainUrl == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4813, "WebMapService: property >MainUrl:< missing in file:\n") + filename);
 		mapType = wms.getProperty("MapType", "maptype_unknown").trim();
 		serviceTypeUrlPart = wms.getProperty("ServiceTypeUrlPart", "SERVICE=WMS").trim();
-		layersUrlPart = wms.getProperty("LayersUrlPart", "").trim();;
-		versionUrlPart = wms.getProperty("VersionUrlPart", "").trim();;
+		layersUrlPart = wms.getProperty("LayersUrlPart", "").trim();
+		;
+		versionUrlPart = wms.getProperty("VersionUrlPart", "").trim();
+		;
 		tmp = wms.getProperty("CoordinateReferenceSystemCacheWolf", "").trim();
-		if (tmp.equals("")) throw new IllegalArgumentException(MyLocale.getMsg(4814, "WebMapService: no CoordinateReferenceSystemCacheWolf given"));
+		if (tmp.equals(""))
+			throw new IllegalArgumentException(MyLocale.getMsg(4814, "WebMapService: no CoordinateReferenceSystemCacheWolf given"));
 		String[] tmp2 = mString.split(tmp, ' ');
 		coordinateReferenceSystem = new int[tmp2.length];
 		for (int i = 0; i < tmp2.length; i++) {
 			coordinateReferenceSystem[i] = Common.parseInt(tmp2[i].trim());
-			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i])) throw new IllegalArgumentException(MyLocale.getMsg(4815, "Coordinate reference system not supported by CacheWolf:\n") + coordinateReferenceSystem[i]);
+			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i]))
+				throw new IllegalArgumentException(MyLocale.getMsg(4815, "Coordinate reference system not supported by CacheWolf:\n") + coordinateReferenceSystem[i]);
 		}
 		tmp = wms.getProperty("CoordinateReferenceSystemUrlPart", "").trim();
-		if (tmp == "") throw new IllegalArgumentException(MyLocale.getMsg(4816, "WebMapService: property >CoordinateReferenceSystemUrlPart:< missing in file:\n") + filename);
+		if (tmp == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4816, "WebMapService: property >CoordinateReferenceSystemUrlPart:< missing in file:\n") + filename);
 		tmp2 = mString.split(tmp, ' ');
-		if (tmp2.length != coordinateReferenceSystem.length) throw new IllegalArgumentException(MyLocale.getMsg(4817, "number of strings in CoordinateReferenceSystemUrlPart (")+tmp2.length+MyLocale.getMsg(4818, ") must match the number of codes in CoordinateReferenceSystemCacheWolf (")+coordinateReferenceSystem.length+MyLocale.getMsg(4819, ") use normal space as separator"));
+		if (tmp2.length != coordinateReferenceSystem.length)
+			throw new IllegalArgumentException(MyLocale.getMsg(4817, "number of strings in CoordinateReferenceSystemUrlPart (") + tmp2.length + MyLocale.getMsg(4818, ") must match the number of codes in CoordinateReferenceSystemCacheWolf (")
+					+ coordinateReferenceSystem.length + MyLocale.getMsg(4819, ") use normal space as separator"));
 		coordinateReferenceSystemUrlPart = new String[tmp2.length];
 		for (int i = 0; i < tmp2.length; i++) {
 			coordinateReferenceSystemUrlPart[i] = tmp2[i].trim();
-			if (coordinateReferenceSystemUrlPart[i] == "") throw new IllegalArgumentException(MyLocale.getMsg(4820, "WebMapService: property >CoordinateReferenceSystemUrlPart:< incorrect in file:\n") + filename);
+			if (coordinateReferenceSystemUrlPart[i] == "")
+				throw new IllegalArgumentException(MyLocale.getMsg(4820, "WebMapService: property >CoordinateReferenceSystemUrlPart:< incorrect in file:\n") + filename);
 		}
 		requestUrlPart = wms.getProperty("RequestUrlPart", "REQUEST=GetMap").trim();
 		imageFormatUrlPart = wms.getProperty("ImageFormatUrlPart", "").trim();
 		stylesUrlPart = wms.getProperty("StylesUrlPart", "").trim();
 		String topleftS = wms.getProperty("BoundingBoxTopLeftWGS84", "").trim();
-		String buttomrightS = wms.getProperty("BoundingBoxButtomRightWGS84", "").trim();
+		String bottomrightS = wms.getProperty("BoundingBoxBottomRightWGS84");
+		// To be backward-compatible with mispelled property-name: Don't remove these lines until all wms-Files has been changed
+		if (bottomrightS == null) {
+			bottomrightS = wms.getProperty("BoundingBoxButtomRightWGS84", "");
+		}
+		bottomrightS.trim();
 		CWPoint topleft = new CWPoint(topleftS);
-		CWPoint buttomright = new CWPoint(buttomrightS);
-		if (!topleft.isValid()) topleft.set(90, -180);
-		if (!buttomright.isValid()) buttomright.set(-90, 180);
-		boundingBox = new Area (topleft, buttomright);
+		CWPoint bottomright = new CWPoint(bottomrightS);
+		if (!topleft.isValid())
+			topleft.set(90, -180);
+		if (!bottomright.isValid())
+			bottomright.set(-90, 180);
+		boundingBox = new Area(topleft, bottomright);
 		minscaleWMS = Common.parseDouble(wms.getProperty("MinScale", "0").trim());
 		maxscaleWMS = Common.parseDouble(wms.getProperty("MaxScale", Convert.toString(java.lang.Double.MAX_VALUE)).trim());
 		minscale = minscaleWMS / Math.sqrt(2); // in WMS scale is measured diagonal while in CacheWolf it is measured vertical
 		maxscale = maxscaleWMS / Math.sqrt(2);
 		imageFileExt = wms.getProperty("ImageFileExtension", "").trim();
-		if (imageFileExt == "") throw new IllegalArgumentException(MyLocale.getMsg(4821, "WebMapService: property >ImageFileExtension:< missing in file:\n") + filename);
-		String [] recommendedScalesStr = mString.split(wms.getProperty("RecommendedScale", "5").trim(), ' ');
+		if (imageFileExt == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4821, "WebMapService: property >ImageFileExtension:< missing in file:\n") + filename);
+		String[] recommendedScalesStr = mString.split(wms.getProperty("RecommendedScale", "5").trim(), ' ');
 		// convert recommended scales to doube[], sort them and set preselected recommended scale
 		if (recommendedScalesStr.length > 0) {
 			double preselected = Common.parseDouble(recommendedScalesStr[0]);
 			Double[] recommendedScalesObj = new Double[recommendedScalesStr.length];
-			for (int i=0; i < recommendedScalesObj.length; i++) {
+			for (int i = 0; i < recommendedScalesObj.length; i++) {
 				recommendedScalesObj[i] = new Double();
 				recommendedScalesObj[i].set(Common.parseDouble(recommendedScalesStr[i].replace(',', '.')));
 			}
 			Utils.sort(recommendedScalesObj, new StandardComparer(), false);
 			recommendedScales = new double[recommendedScalesStr.length];
-			for (int i=0; i < recommendedScales.length; i++) {
+			for (int i = 0; i < recommendedScales.length; i++) {
 				recommendedScales[i] = recommendedScalesObj[i].value;
-				if (recommendedScales[i] == preselected) preselectedRecScaleIndex = i;
+				if (recommendedScales[i] == preselected)
+					preselectedRecScaleIndex = i;
 			}
 		}
 	}
 
 	private static final int TOPLEFT_INDEX = 0;
-	private static final int BUTTOMRIGHT_INDEX = 1;
+	private static final int BOTTOMRIGHT_INDEX = 1;
 	private static final int TOPRIGHT_INDEX = 2;
-	private static final int BUTTOMLEFT_INDEX = 3;
+	private static final int BOTTOMLEFT_INDEX = 3;
+
 	/**
-	 *
+	 * 
 	 * @param maparea
-	 * @return [0] = topleft, [1] = buttomright, [2] = topright, [3] = buttomleft
+	 * @return [0] = topleft, [1] = bottomright, [2] = topright, [3] = bottomleft
 	 */
 	private ProjectedPoint[] getGkArea(Area maparea) {
 		ProjectedPoint[] ret = new ProjectedPoint[4];
-	//	CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.buttomright.lonDec);
-	//	CWPoint buttomleft = new CWPoint(maparea.buttomright.latDec, maparea.topleft.lonDec);
+		// CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+		// CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
 		int crs = getCrs(maparea.getCenter());
 		// FIXME region is never read. Needed?
 		// int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[crs]);
 		ret[TOPLEFT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.topleft, coordinateReferenceSystem[crs]);
-		ret[BUTTOMRIGHT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.buttomright, coordinateReferenceSystem[crs]);
-		ret[TOPRIGHT_INDEX] =  ret[BUTTOMRIGHT_INDEX].cloneIt();
-		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BUTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
-		ret[BUTTOMLEFT_INDEX] = ret[BUTTOMRIGHT_INDEX].cloneIt();
-		ret[BUTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BUTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
-		//ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
-		//ret[3] = TransformCoordinates.wgs84ToGermanGk(buttomleft, coordinateReferenceSystem[crs]);
+		ret[BOTTOMRIGHT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.bottomright, coordinateReferenceSystem[crs]);
+		ret[TOPRIGHT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
+		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BOTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
+		ret[BOTTOMLEFT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
+		ret[BOTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BOTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
+		// ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
+		// ret[3] = TransformCoordinates.wgs84ToGermanGk(bottomleft, coordinateReferenceSystem[crs]);
 		return ret;
 	}
+
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if (region > 0 ) {
+		if (region > 0) {
 			int epsg = coordinateReferenceSystem[getCrs(center)];
 			ProjectedPoint cgk = TransformCoordinates.wgs84ToEpsg(center, epsg);
 			ProjectedPoint tlgk = cgk.cloneIt();
-			tlgk.shift(- pixelsize.x * scale / 2, 1);
+			tlgk.shift(-pixelsize.x * scale / 2, 1);
 			tlgk.shift(pixelsize.y * scale / 2, 0);
 			ProjectedPoint brgk = cgk.cloneIt();
 			brgk.shift(pixelsize.x * scale / 2, 1);
 			brgk.shift(-pixelsize.y * scale / 2, 0);
 			bbox.topleft = TransformCoordinates.ProjectedEpsgToWgs84(tlgk, epsg); // old: (tlgk, region);
-			bbox.buttomright = TransformCoordinates.ProjectedEpsgToWgs84(brgk, epsg); // TransformCoordinates.GkToWgs84(brgk, region);
+			bbox.bottomright = TransformCoordinates.ProjectedEpsgToWgs84(brgk, epsg); // TransformCoordinates.GkToWgs84(brgk, region);
 		} else {
 			switch (coordinateReferenceSystem[0]) {
 			case TransformCoordinates.EPSG_ETRS89:
@@ -597,49 +827,46 @@
 				bbox.topleft.set(center);
 				bbox.topleft.shift(-pixelsize.x * scale / 2, 1);
 				bbox.topleft.shift(pixelsize.y * scale / 2, 0);
-				bbox.buttomright.set(center);
-				bbox.buttomright.shift(pixelsize.x * scale / 2, 1);
-				bbox.buttomright.shift(-pixelsize.y * scale / 2, 0);
+				bbox.bottomright.set(center);
+				bbox.bottomright.shift(pixelsize.x * scale / 2, 1);
+				bbox.bottomright.shift(-pixelsize.y * scale / 2, 0);
 				break;
-			default: throw new IllegalArgumentException("CenterScaleToArea: epsg: " + coordinateReferenceSystem[0] + " not supported");
+			default:
+				throw new IllegalArgumentException("CenterScaleToArea: epsg: " + coordinateReferenceSystem[0] + " not supported");
 			}
 		}
 		return bbox;
 	}
 
 	protected String getUrlForBoundingBoxInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:")+" " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:")+" " + name + MyLocale.getMsg(4824, ", service area:")+" " + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:") + " " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:") + " " + name + MyLocale.getMsg(4824, ", service area:") + " " + boundingBox.toString());
 		// http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&VERSION=1.1.0&REQUEST=GetMap&SRS=EPSG:31466&BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&WIDTH=500&HEIGHT=500&LAYERS=Raster:TK25_KMF:Farbkombination&STYLES=&FORMAT=image/png
-		CWPoint buttomleft = new CWPoint (maparea.buttomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
-		double scaleh = maparea.buttomright.getDistance(buttomleft) * 1000 / pixelsize.x;
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+		double scaleh = maparea.bottomright.getDistance(bottomleft) * 1000 / pixelsize.x;
 		double scalev = maparea.topleft.getDistance(topright) * 1000 / pixelsize.y;
 		double scale = Math.sqrt(scaleh * scaleh + scalev * scalev); // meters per pixel measured diagonal
-		if ( scale < minscaleWMS || scale > maxscaleWMS ) throw new IllegalArgumentException(MyLocale.getMsg(4825, "scale")+" " + scale / Math.sqrt(2)+ MyLocale.getMsg(4826, " not supported by online map service, supported scale range:")+" " + minscale + " - " + maxscale + MyLocale.getMsg(4827, " (measured in meters per pixel vertically)"));
+		if (scale < minscaleWMS || scale > maxscaleWMS)
+			throw new IllegalArgumentException(MyLocale.getMsg(4825, "scale") + " " + scale / Math.sqrt(2) + MyLocale.getMsg(4826, " not supported by online map service, supported scale range:") + " " + minscale + " - " + maxscale
+					+ MyLocale.getMsg(4827, " (measured in meters per pixel vertically)"));
 		int crs = 0;
 		String bbox = "BBOX=";
 		int localsystem = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
 		if (localsystem > 0) {
 			crs = getCrs(maparea.getCenter());
 			ProjectedPoint[] gk = getGkArea(maparea);
-			buttomleft = TransformCoordinates.ProjectedEpsgToWgs84(gk[BUTTOMLEFT_INDEX], coordinateReferenceSystem[crs]);
+			bottomleft = TransformCoordinates.ProjectedEpsgToWgs84(gk[BOTTOMLEFT_INDEX], coordinateReferenceSystem[crs]);
 			topright = TransformCoordinates.ProjectedEpsgToWgs84(gk[TOPRIGHT_INDEX], coordinateReferenceSystem[crs]);
-			bbox += TransformCoordinates.wgs84ToEpsg(buttomleft, coordinateReferenceSystem[crs]).toString(2, "", ",");
+			bbox += TransformCoordinates.wgs84ToEpsg(bottomleft, coordinateReferenceSystem[crs]).toString(2, "", ",");
 			bbox += "," + TransformCoordinates.wgs84ToEpsg(topright, coordinateReferenceSystem[crs]).toString(2, "", ",");
 		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84)
-			bbox += buttomleft.toString(TransformCoordinates.LON_LAT)  + "," + topright.toString(TransformCoordinates.LON_LAT);
-		else throw new IllegalArgumentException(MyLocale.getMsg(4828, "Coordinate system not supported by cachewolf:")+" " + coordinateReferenceSystem.toString());
-		String ret = MainUrl + "SERVICE=WMS" + "&"+ versionUrlPart + "&" + requestUrlPart + "&" +
-		coordinateReferenceSystemUrlPart[crs] + "&" + bbox +
-		"&WIDTH=" + pixelsize.x + "&HEIGHT=" + pixelsize.y + "&" +
-		layersUrlPart + "&" + stylesUrlPart + "&" + imageFormatUrlPart;
-		if (requestUrlPart.equalsIgnoreCase("Kosmos")) {
-			// minlat minlng maxlat maxlng
-			ret=buttomleft.toString(TransformCoordinates.LAT_LON).replace(',',' ')+" "+
-				topright.toString(TransformCoordinates.LAT_LON).replace(',',' ')+
-				" -w "+pixelsize.x;
-		}
-		Global.getPref().log(ret + " WGS84: Buttom left: " + buttomleft.toString(TransformCoordinates.DD) + "top right: " + topright.toString(TransformCoordinates.DD));
+			bbox += bottomleft.toString(TransformCoordinates.LON_LAT) + "," + topright.toString(TransformCoordinates.LON_LAT);
+		else
+			throw new IllegalArgumentException(MyLocale.getMsg(4828, "Coordinate system not supported by cachewolf:") + " " + coordinateReferenceSystem.toString());
+		String ret = MainUrl + serviceTypeUrlPart + "&" + versionUrlPart + "&" + requestUrlPart + "&" + coordinateReferenceSystemUrlPart[crs] + "&" + bbox + "&WIDTH=" + pixelsize.x + "&HEIGHT=" + pixelsize.y + "&" + layersUrlPart + "&" + stylesUrlPart
+				+ "&" + imageFormatUrlPart;
+		Global.getPref().log(ret + " WGS84: Bottom left: " + bottomleft.toString(TransformCoordinates.DD) + "top right: " + topright.toString(TransformCoordinates.DD));
 		return ret;
 	}
 
@@ -648,71 +875,79 @@
 	 * a) if only one is in the array 0 is returned
 	 * b) if there are more, find out which one matches the correct zone (e.g. Gau?-K?ger stripe)
 	 * Call this routine with center of the area (use Area.getcenter())
-	 * @param p Point for which the epsg code is searched for
+	 * 
+	 * @param p
+	 *            Point for which the epsg code is searched for
 	 * @return
 	 */
 	private int getCrs(TrackPoint p) {
 		int crsindex = 0;
 		if (coordinateReferenceSystem.length > 1) {
 			int ls = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if buttom left and top right are not in the same Gau?-Kr?ger stripe?
+			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau?-Kr?ger stripe?
 			int wantepsg = gkbl.getEpsgCode();
 			for (crsindex = 0; crsindex < coordinateReferenceSystem.length; crsindex++) {
-				if (coordinateReferenceSystem[crsindex] == wantepsg) break;
+				if (coordinateReferenceSystem[crsindex] == wantepsg)
+					break;
 			}
 			if (crsindex >= coordinateReferenceSystem.length) { // not match
 				for (crsindex = 0; crsindex < coordinateReferenceSystem.length; crsindex++) {
-					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1) break; // accept 1 zone deviation
+					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1)
+						break; // accept 1 zone deviation
 				}
-				if (crsindex >= coordinateReferenceSystem.length) crsindex = -1;
+				if (crsindex >= coordinateReferenceSystem.length)
+					crsindex = -1;
 
 			}
-			if (crsindex < 0) throw new IllegalArgumentException(MyLocale.getMsg(4829, "getUrlForBoundingBox: Point:")+" " + gkbl.toString() + MyLocale.getMsg(4830, "no matching Gau?-Kr?ger-Stripe in the EPSG-code list in the .wms"));
+			if (crsindex < 0)
+				throw new IllegalArgumentException(MyLocale.getMsg(4829, "getUrlForBoundingBox: Point:") + " " + gkbl.toString() + MyLocale.getMsg(4830, "no matching Gau?-Kr?ger-Stripe in the EPSG-code list in the .wms"));
 		}
 		return crsindex;
 	}
 
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:")+" " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:")+" " + name + MyLocale.getMsg(4824, ", service area:")+" " + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:") + " " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:") + " " + name + MyLocale.getMsg(4824, ", service area:") + " " + boundingBox.toString());
 		Vector georef = new Vector(4);
 
 		// calculate a rectangle in the according coordinate reference system
-		CWPoint buttomleft = new CWPoint (maparea.buttomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 		CWPoint topleft = new CWPoint(maparea.topleft);
-		CWPoint buttomright = new CWPoint(maparea.buttomright);
-		double metersperpixalhorizontal = ( buttomright.getDistance(buttomleft) + topleft.getDistance(topright))/2 * 1000 / pixelsize.x;
-		double metersperpixalvertical = ( buttomright.getDistance(topright) + topleft.getDistance(buttomleft))/2 * 1000 / pixelsize.y;
+		CWPoint bottomright = new CWPoint(maparea.bottomright);
+		double metersperpixalhorizontal = (bottomright.getDistance(bottomleft) + topleft.getDistance(topright)) / 2 * 1000 / pixelsize.x;
+		double metersperpixalvertical = (bottomright.getDistance(topright) + topleft.getDistance(bottomleft)) / 2 * 1000 / pixelsize.y;
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if ( region > 0) {
+		if (region > 0) {
 			ProjectedPoint[] gk = getGkArea(maparea);
 			// bounding box in WMS is defined around the pixels, not exactly on the pixels --> the bounding box must be reduced on all edges by half a pixel
 			gk[TOPLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
 			gk[TOPLEFT_INDEX].shift(-metersperpixalvertical / 2, 0);
-			gk[BUTTOMRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
-			gk[BUTTOMRIGHT_INDEX].shift(metersperpixalvertical / 2, 0);
+			gk[BOTTOMRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
+			gk[BOTTOMRIGHT_INDEX].shift(metersperpixalvertical / 2, 0);
 			gk[TOPRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
 			gk[TOPRIGHT_INDEX].shift(-metersperpixalvertical / 2, 0);
-			gk[BUTTOMLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
-			gk[BUTTOMLEFT_INDEX].shift(metersperpixalvertical / 2, 0);
+			gk[BOTTOMLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
+			gk[BOTTOMLEFT_INDEX].shift(metersperpixalvertical / 2, 0);
 
 			topleft.set(gk[TOPLEFT_INDEX].getNorthing(), gk[TOPLEFT_INDEX].getEasting());
-			buttomright.set(gk[BUTTOMRIGHT_INDEX].getNorthing(), gk[BUTTOMRIGHT_INDEX].getEasting());
+			bottomright.set(gk[BOTTOMRIGHT_INDEX].getNorthing(), gk[BOTTOMRIGHT_INDEX].getEasting());
 			topright.set(gk[TOPRIGHT_INDEX].getNorthing(), gk[TOPRIGHT_INDEX].getEasting());
-			buttomleft.set(gk[BUTTOMLEFT_INDEX].getNorthing(), gk[BUTTOMLEFT_INDEX].getEasting());
+			bottomleft.set(gk[BOTTOMLEFT_INDEX].getNorthing(), gk[BOTTOMLEFT_INDEX].getEasting());
 		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84) {
 			// bounding box in WMS is defined around the pixels, not exactly on the pixels --> the bounding box must be reduced on all edges by half a pixel
 			topleft.shift(metersperpixalhorizontal / 2, 1);
 			topleft.shift(-metersperpixalvertical / 2, 0);
-			buttomright.shift(-metersperpixalhorizontal, 1);
-			buttomright.shift(metersperpixalhorizontal, 0);
-			topright = new CWPoint (topleft.latDec, buttomright.lonDec);
-			buttomleft = new CWPoint (buttomright.latDec, topleft.lonDec);
-		} else throw new IllegalArgumentException(MyLocale.getMsg(4831, "getMapInfoObject: Coordinate system not supported by cachewolf:")+" " + coordinateReferenceSystem);
+			bottomright.shift(-metersperpixalhorizontal, 1);
+			bottomright.shift(metersperpixalhorizontal, 0);
+			topright = new CWPoint(topleft.latDec, bottomright.lonDec);
+			bottomleft = new CWPoint(bottomright.latDec, topleft.lonDec);
+		} else
+			throw new IllegalArgumentException(MyLocale.getMsg(4831, "getMapInfoObject: Coordinate system not supported by cachewolf:") + " " + coordinateReferenceSystem);
 		georef.add(new GCPoint(topleft, new Point(0, 0)));
-		georef.add(new GCPoint(buttomright, new Point(pixelsize.x, pixelsize.y)));
+		georef.add(new GCPoint(bottomright, new Point(pixelsize.x, pixelsize.y)));
 		georef.add(new GCPoint(topright, new Point(pixelsize.x, 0)));
-		georef.add(new GCPoint(buttomleft, new Point(0, pixelsize.y)));
+		georef.add(new GCPoint(bottomleft, new Point(0, pixelsize.y)));
 
 		MapInfoObject ret = new MapInfoObject();
 		ret.evalGCP(georef, pixelsize.x, pixelsize.y, coordinateReferenceSystem[getCrs(maparea.getCenter())]);
@@ -722,25 +957,26 @@
 
 class ExpediaMapService extends OnlineMapService {
 	/*
-	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
+	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir
+	 * gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
 	 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&ID=3XNsF.&CenP={0,number,#.########},{1,number,#.########}&Lang=EUR0809&Alti={2,number,#}&Size={3,number,#},{4,number,#}&Offs=0.000000,0.000000\&BCheck=1
 	 * download.map.url.expedia_east.title=Url of Expedia Europe
 	 * download.map.scale_factor.expedia_east=3950
 	 */
 	final static float downloadMapScaleFactorExpedia_east = 3950;
-	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f / 2817.947378f;
 	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL;
 
 	public ExpediaMapService() {
 		name = "Expedia";
 		filename = "expedia";
-		MainUrl = "Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz."; //"Rhttp://" forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
+		MainUrl = "Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz."; // "Rhttp://" forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
 		imageFileExt = ".gif";
 		mapType = "expedia";
-		recommendedScales = new double[]{5};
+		recommendedScales = new double[] { 5 };
 		minscale = getMetersPerPixel(0.00000000000000000000001f);
-		maxscale = getMetersPerPixel((float)new CWPoint(0,0).getDistance(new CWPoint(0,180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -> m. /1000 because we have 1000x1000 Pixel usually
-		boundingBox = new Area(new CWPoint(90,-180), new CWPoint(-90,180));
+		maxscale = getMetersPerPixel((float) new CWPoint(0, 0).getDistance(new CWPoint(0, 180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -> m. /1000 because we have 1000x1000 Pixel usually
+		boundingBox = new Area(new CWPoint(90, -180), new CWPoint(-90, 180));
 	}
 
 	public float getMetersPerPixel(float scale) {
@@ -748,24 +984,25 @@
 	}
 
 	private int getZoomlevel(float scale) {
-		return (int)(Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
+		return (int) (Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
 	}
 
 	public String getUrlForCenterScale(CWPoint center, float scale, Point pixelsize) {
 		int zoomlevel = getZoomlevel(scale);
 		String zone;
-		if (     (center.lonDec <= -30   && center.lonDec >= -170) ||
-				( center.lonDec > 360-30 && center.lonDec <= 360-170) ) zone = "USA0409"; // TODO test which zone-code ist best for asia
-		else zone = "EUR0809";
+		if ((center.lonDec <= -30 && center.lonDec >= -170) || (center.lonDec > 360 - 30 && center.lonDec <= 360 - 170))
+			zone = "USA0409"; // TODO test which zone-code ist best for asia
+		else
+			zone = "EUR0809";
 		String quelle = MainUrl + "&CenP=" + center.toString(TransformCoordinates.LAT_LON);
-		quelle = quelle + "&Alti="+Convert.toString(zoomlevel)+"&Lang="+zone+"&Size="+Convert.toString(pixelsize.x)+","+Convert.toString(pixelsize.y)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
+		quelle = quelle + "&Alti=" + Convert.toString(zoomlevel) + "&Lang=" + zone + "&Size=" + Convert.toString(pixelsize.x) + "," + Convert.toString(pixelsize.y) + "&Offs=0,0&MapS=0"; // &Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
 		return quelle;
 	}
 
 	public MapInfoObject getMapInfoObject(CWPoint center, float scale, Point pixelsize) {
 		float metersPerPixel2 = getMetersPerPixel(scale);
 		float metersPerPixel = metersPerPixel2;
-		MapInfoObject cal = new MapInfoObject(metersPerPixel, center,  pixelsize.x, pixelsize.y, name);
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, center, pixelsize.x, pixelsize.y, name);
 		return cal;
 	}
 

Modified: branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -60,47 +60,47 @@
 
 /**
  * @author pfeffer
- * This Class is the Dialog for Download calibrated from expedia.com
- * is called from
- *  * start offset for language file: 1800
+ *         This Class is the Dialog for Download calibrated from expedia.com
+ *         is called from
+ *         * start offset for language file: 1800
  */
 
 public class MapLoaderGui extends Form {
 	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
-    Preferences pref = Global.getPref ();
+	Preferences pref = Global.getPref();
 	mTabbedPanel mTab = new mTabbedPanel();
 	CellPanel pnlTiles = new CellPanel();
 	CellPanel pnlPerCache = new CellPanel();
 
-	final String descString = MyLocale.getMsg(1802,"Download georeferenced maps\n Select online service:");
+	final String descString = MyLocale.getMsg(1802, "Download georeferenced maps\n Select online service:");
 	mChoice mapServiceChoice;
-	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803,"for"));
-	mChoice forSelectedChkBox = new mChoice(new String[] {MyLocale.getMsg(1804,"all"), MyLocale.getMsg(1805,"selected")}, 0);
-	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {MyLocale.getMsg(1804,"all"), MyLocale.getMsg(1805,"selected")}, 1);
-	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806,"caches"));
+	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803, "for"));
+	mChoice forSelectedChkBox = new mChoice(new String[] { MyLocale.getMsg(1804, "all"), MyLocale.getMsg(1805, "selected") }, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] { MyLocale.getMsg(1804, "all"), MyLocale.getMsg(1805, "selected") }, 1);
+	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806, "caches"));
 	mInput distanceInput;
 	mLabel distLbl;
 	mLabel km = new mLabel("km");
 	mLabel coosLbl;
 	mButton coosBtn;
-	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807,"Approx. m per pixel:"));
+	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807, "Approx. m per pixel:"));
 	mComboBox scaleInput = new mComboBox();
 	mComboBox scaleInputPerCache = new mComboBox();
-	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808,"overlapping in pixel:"));
-    mInput overlappingInput = new mInput(""+pref.mapOverlapping);
-	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809,"download an overview map"));
-	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809,"download an overview map"));
+	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808, "overlapping in pixel:"));
+	mInput overlappingInput = new mInput("" + pref.mapOverlapping);
+	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809, "download an overview map"));
+	mCheckBox fetchOnlyMapWithCacheChkBox = new mCheckBox(MyLocale.getMsg(165, "only for caches"));
+	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809, "download an overview map"));
+	mCheckBox smallTiles = new mCheckBox(MyLocale.getMsg(4280, "Small Tiles"));
+	mCheckBox bigTiles = new mCheckBox(MyLocale.getMsg(4282, "BigTiles"));
+	CheckBoxGroup tileSize = new CheckBoxGroup();
 
-    mCheckBox smallTiles = new mCheckBox (MyLocale.getMsg (4280, "Small Tiles"));
-    mCheckBox bigTiles = new mCheckBox (MyLocale.getMsg (4282, "BigTiles"));
-    CheckBoxGroup tileSize = new CheckBoxGroup ();
-
-    /**
-     * Inputfields for width an height of tile size
-     */
-    private mInput tileWidthInput = new mInput ();
-    private mInput tileHeightInput = new mInput();
-    MapLoader mapLoader;
+	/**
+	 * Inputfields for width an height of tile size
+	 */
+	private mInput tileWidthInput = new mInput();
+	private mInput tileHeightInput = new mInput();
+	MapLoader mapLoader;
 	String[] unsortedMapServices;
 	String[] sortedmapServices;
 	int[] sortingMapServices;
@@ -124,19 +124,19 @@
 		this.title = MyLocale.getMsg(1800, "Download georeferenced maps");
 		center = new CWPoint(pref.getCurCentrePt());
 		tileWidth = pref.tilewidth;
-		tileHeight=pref.tileheight;
+		tileHeight = pref.tileheight;
 		if (tileWidth == 0 || tileHeight == 0) {
-			tileWidth = pref.myAppWidth > 200?pref.myAppWidth:200;
-			tileHeight = pref.myAppHeight > 175?pref.myAppHeight:175;
+			tileWidth = pref.myAppWidth > 200 ? pref.myAppWidth : 200;
+			tileHeight = pref.myAppHeight > 175 ? pref.myAppHeight : 175;
 		}
-		pref.tilewidth=tileWidth;
-		pref.tileheight=tileHeight;
+		pref.tilewidth = tileWidth;
+		pref.tileheight = tileHeight;
 		// ist das wirklich so gewollt?
-		pref.tilewidth=1000;
-		pref.tileheight=1000;
+		pref.tilewidth = 1000;
+		pref.tileheight = 1000;
 		initTileInputfields();
 		cacheDB = cacheDBi;
-		mapLoader = new MapLoader(FileBase.getProgramDirectory()+"/"+"webmapservices");
+		mapLoader = new MapLoader(FileBase.getProgramDirectory() + "/" + "webmapservices");
 
 		// sort the items in the list of services in a way that services which cover the current center point.
 		unsortedMapServices = mapLoader.getAvailableOnlineMapServices();
@@ -151,36 +151,38 @@
 		pnlTiles.addNext(forCachesChkBox);
 		pnlTiles.addNext(forSelectedChkBox);
 		pnlTiles.addLast(cachesLbl);
-		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810, "Within a rectangle of:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		distanceInput = new mInput();
 		int tmp = Convert.toInt((Global.getProfile().getDistOC()));
 		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().getDistGC())));
 		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
-		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, "around the centre:")+" "));
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, "around the centre:") + " "));
 		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
 		pnlTiles.addNext(scaleLbl);
 		mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 		this.focusFirst();
 		pnlTiles.addLast(scaleInput);
-		//	pnlTiles.addLast(resolutionLbl);
+		// pnlTiles.addLast(resolutionLbl);
 		pnlTiles.addNext(overlappingLbl);
 		pnlTiles.addLast(overlappingInput);
 		overviewChkBox.setState(false);
-		pnlTiles.addLast(overviewChkBox);
+		pnlTiles.addNext(overviewChkBox);
+		fetchOnlyMapWithCacheChkBox.setState(false);
+		pnlTiles.addLast(fetchOnlyMapWithCacheChkBox);
 		pnlTiles.addNext(smallTiles);
 		pnlTiles.addLast(bigTiles);
 		smallTiles.setGroup(tileSize);
-                bigTiles.setGroup(tileSize);
+		bigTiles.setGroup(tileSize);
 		tileSize.selectIndex(pref.mapTileSize);
-		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB = new mButton(MyLocale.getMsg(1604, "Cancel"));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okBtiles = new mButton(MyLocale.getMsg(1605,"OK"));
+		pnlTiles.addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605, "OK"));
 		okBtiles.setHotKey(0, IKeys.ACTION);
 		okBtiles.setHotKey(0, IKeys.ENTER);
-		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(okBtiles, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		updateForCachesState();
 		mTab.addCard(pnlTiles, MyLocale.getMsg(1812, "Tiles"), MyLocale.getMsg(1812, "Tiles"));
 
@@ -189,20 +191,20 @@
 		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addLast(new mLabel(MyLocale.getMsg(1806, "caches")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1807, "Approx. m per pixel")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-		pnlPerCache.addNext (new mLabel(MyLocale.getMsg(1835, "Tilesize")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		CellPanel pnl = new CellPanel();		
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1835, "Tilesize")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		CellPanel pnl = new CellPanel();
 		tileHeightInput.columns = tileWidthInput.columns = 5;
-		pnl.addNext (tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addNext (new mLabel("x"), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addLast (tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-        pnlPerCache.addLast(pnl,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-        cancelBPerCache = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		pnl.addNext(tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addNext(new mLabel("x"), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addLast(tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnlPerCache.addLast(pnl, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604, "Cancel"));
 		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
 		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		okBPerCache = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBPerCache = new mButton(MyLocale.getMsg(1605, "OK"));
 		okBPerCache.setHotKey(0, IKeys.ACTION);
 		okBPerCache.setHotKey(0, IKeys.ENTER);
 		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
@@ -217,9 +219,9 @@
 		tileHeightInput.setText(Integer.toString(pref.tileheight));
 	}
 
-	private void setRecommScaleInput(){
+	private void setRecommScaleInput() {
 		String[] recScales = new String[mapLoader.currentOnlineMapService.recommendedScales.length];
-		for (int i=0; i<recScales.length; i++) {
+		for (int i = 0; i < recScales.length; i++) {
 			recScales[i] = Convert.toString(mapLoader.currentOnlineMapService.recommendedScales[i]);
 		}
 		scaleInput.choice.set(recScales, mapLoader.currentOnlineMapService.preselectedRecScaleIndex);
@@ -232,70 +234,72 @@
 	 * sort the map services in order to have the services, which cover
 	 * the current center first in the list
 	 * this sets inbound[], sortedMapServices[] and sortingmapServices[]
-	 *
+	 * 
 	 */
 	private void sortMapServices() {
-		sortingMapServices = new int[unsortedMapServices.length+1];
+		sortingMapServices = new int[unsortedMapServices.length + 1];
 		inbound = new boolean[unsortedMapServices.length];
-		int j=0;
-		for (int i=0; i < sortingMapServices.length-1; i++) {
-			if( ((OnlineMapService)mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
+		int j = 0;
+		for (int i = 0; i < sortingMapServices.length - 1; i++) {
+			if (((OnlineMapService) mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
 				sortingMapServices[j] = i;
 				j++;
 				inbound[i] = true;
-			} else inbound[i] = false;
+			} else
+				inbound[i] = false;
 		}
-		int k=j;
-		sortedmapServices = new String[unsortedMapServices.length+1];
-		for (int i=0; i < sortedmapServices.length-1; i++) {
+		int k = j;
+		sortedmapServices = new String[unsortedMapServices.length + 1];
+		for (int i = 0; i < sortedmapServices.length - 1; i++) {
 			if (!inbound[i]) {
 				sortingMapServices[j] = i;
 				j++;
 			}
-			sortedmapServices[i] = ((OnlineMapService)mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
+			sortedmapServices[i] = ((OnlineMapService) mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
 		}
-		sortedmapServices[j]=sortedmapServices[k];
-		sortedmapServices[k]="===== ===== ===== ===== ===== ===== =====";
-		sortingMapServices[j]=sortingMapServices[k];
-		sortingMapServices[k]=-1;
+		sortedmapServices[j] = sortedmapServices[k];
+		sortedmapServices[k] = "===== ===== ===== ===== ===== ===== =====";
+		sortingMapServices[j] = sortingMapServices[k];
+		sortingMapServices[k] = -1;
 	}
 
 	private int getSortedMapServiceIndex(int originalindex) {
 		for (int i = 0; i < sortingMapServices.length; i++) {
-			if (sortingMapServices[i] == originalindex) return i;
+			if (sortingMapServices[i] == originalindex)
+				return i;
 		}
-		throw new IllegalStateException(MyLocale.getMsg(1818, "getSortedMapServiceIndex: index")+" " + originalindex + MyLocale.getMsg(1819, "not found"));
+		throw new IllegalStateException(MyLocale.getMsg(1818, "getSortedMapServiceIndex: index") + " " + originalindex + MyLocale.getMsg(1819, "not found"));
 	}
 
 	public String getMapsDir() {
 		String ret = Global.getPref().getMapDownloadSavePath(mapLoader.currentOnlineMapService.getMapType());
-		Global.getPref().saveCustomMapsPath(getLeadingPath(ret,Global.getPref().getMapLoadPath()));
+		Global.getPref().saveCustomMapsPath(getLeadingPath(ret, Global.getPref().getMapLoadPath()));
 		// Global.getPref().saveCustomMapsPath(ret);
 		// eigentlich d?rft das erst gespeichert werden, wenn erfolgreich heruntergeladen wurde
 		return ret;
 	}
 
-	private String getLeadingPath(String newPath , String oldPath) {
-		String LeadingPath="";
-		int StartPos=0;
+	private String getLeadingPath(String newPath, String oldPath) {
+		String LeadingPath = "";
+		int StartPos = 0;
 		int EndPos;
-		int LastPos = java.lang.Math.min(newPath.length(),oldPath.length());
+		int LastPos = java.lang.Math.min(newPath.length(), oldPath.length());
 		do {
-			EndPos=java.lang.Math.min(newPath.indexOf("/", StartPos),LastPos);
-			if (newPath.substring(StartPos,EndPos).equals(oldPath.substring(StartPos, EndPos))) {
-				LeadingPath=LeadingPath.concat(newPath.substring(StartPos,EndPos+1));
-				StartPos=EndPos+1;
-			}
-			else {
+			EndPos = java.lang.Math.min(newPath.indexOf("/", StartPos), LastPos);
+			if (newPath.substring(StartPos, EndPos).equals(oldPath.substring(StartPos, EndPos))) {
+				LeadingPath = LeadingPath.concat(newPath.substring(StartPos, EndPos + 1));
+				StartPos = EndPos + 1;
+			} else {
 				break;
 			}
-		} while (StartPos<LastPos);
+		} while (StartPos < LastPos);
 		return LeadingPath;
 	}
 
 	public void downloadTiles() {
 		String mapsDir = getMapsDir();
-		if (mapsDir == null) return;
+		if (mapsDir == null)
+			return;
 		InfoBox progressBox = new InfoBox(MyLocale.getMsg(1815, "Downloading georeferenced maps"), MyLocale.getMsg(1816, "Downloading georeferenced maps\n \n \n \n \n"), InfoBox.PROGRESS_WITH_WARNINGS);
 		progressBox.setPreferredSize(220, 300);
 		progressBox.setInfoHeight(160);
@@ -304,16 +308,16 @@
 		mapLoader.setProgressInfoBox(progressBox);
 		Vm.showWait(true);
 		int length;
-        	switch (tileSize.getSelectedIndex()){
-		    //Perhaps introduce a medium size??
+		switch (tileSize.getSelectedIndex()) {
+		// Perhaps introduce a medium size??
 		case 0:
-		    length=500;
-		    break;
+			length = 500;
+			break;
 		default:
-		    length=1000;
+			length = 1000;
 		}
-		//Override size if one tile for each cache is wanted
-			Point size = new Point(length, length);
+		// Override size if one tile for each cache is wanted
+		Point size = new Point(length, length);
 		if (perCache) {
 			length = 1000;
 			size = new Point(tileWidth, tileHeight);
@@ -326,9 +330,8 @@
 				progressBox.close(0);
 				return;
 			}
-			mapLoader.setTiles(surArea.topleft, surArea.buttomright, scale, size, overlapping );
-		} else
-		{ // calculate from centre point an radius
+			mapLoader.setTiles(surArea.topleft, surArea.bottomright, scale, size, overlapping);
+		} else { // calculate from centre point an radius
 			mapLoader.setTiles(center, radius * 1000, scale, size, overlapping);
 		}
 		if (overviewmap) {
@@ -337,32 +340,28 @@
 			try {
 				mapLoader.downloadMap(center, overviewScale, size, mapsDir);
 			} catch (Exception e) {
-				progressBox.addWarning(MyLocale.getMsg(1825, "Overview map: Ignoring error:")+" " + e.getMessage()+"\n");
+				progressBox.addWarning(MyLocale.getMsg(1825, "Overview map: Ignoring error:") + " " + e.getMessage() + "\n");
 			}
 		}
-		if (!perCache){  // download tiles
+		if (!perCache) { // download tiles
 			mapLoader.setProgressInfoBox(progressBox);
+			mapLoader.setFetchOnlyMapWithCache(fetchOnlyMapWithCacheChkBox.getState());
 			mapLoader.downlaodTiles(mapsDir);
 		} else { // per cache
 			CacheHolder ch;
-			CWPoint tmpca = new CWPoint();
 			int numdownloaded = 0;
 			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
 			int numCaches = Global.getProfile().numCachesInArea;
-			for (int i=cacheDB.size()-1; i >= 0; i--) {
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				ch = cacheDB.get(i);
 				if (!this.onlySelected || ch.is_Checked) {
-					if (ch.pos == null) { // this can not happen
-						tmpca.set(ch.getLatLon());
-						ch.pos = new CWPoint(tmpca);
-					}
-					if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
+					if (ch.getPos().isValid() && ch.getPos().latDec != 0 && ch.getPos().lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
 						numdownloaded++;
-						progressBox.setInfo(MyLocale.getMsg(1820, "Downloading map '")+mapLoader.currentOnlineMapService.getName()+"'\n"+numdownloaded+" / "+numCaches+MyLocale.getMsg(1821, "\n for cache:\n")+ch.getCacheName());
+						progressBox.setInfo(MyLocale.getMsg(1820, "Downloading map '") + mapLoader.currentOnlineMapService.getName() + "'\n" + numdownloaded + " / " + numCaches + MyLocale.getMsg(1821, "\n for cache:\n") + ch.getCacheName());
 						try {
-							mapLoader.downloadMap(ch.pos, scale, size, mapsDir);
+							mapLoader.downloadMap(ch.getPos(), scale, size, mapsDir);
 						} catch (Exception e) {
-							progressBox.addWarning(MyLocale.getMsg(1822, "Cache:")+" " + ch.getCacheName() + "(" + ch.getWayPoint() + ") "+MyLocale.getMsg(1823, "Ignoring error:")+" " + e.getMessage()+"\n");
+							progressBox.addWarning(MyLocale.getMsg(1822, "Cache:") + " " + ch.getCacheName() + "(" + ch.getWayPoint() + ") " + MyLocale.getMsg(1823, "Ignoring error:") + " " + e.getMessage() + "\n");
 						}
 					}
 				}
@@ -373,20 +372,19 @@
 		progressBox.addOkButton();
 		progressBox.waitUntilClosed();
 		mapLoader.setProgressInfoBox(null);
-		//progressBox.close(0);
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
-		//	(new MessageBox("Download maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
+		// progressBox.close(0);
+		if (Global.mainTab.mm != null)
+			Global.mainTab.mm.mapsloaded = false;
+		// (new MessageBox("Download maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
 	}
 
-
 	private void updateForCachesState() {
 		int a, b;
 		if (forCachesChkBox.getState()) {
 			// create map rectangle from caches
 			a = 0;
 			b = ControlConstants.Disabled;
-		}
-		else { // use centre and distance input
+		} else { // use centre and distance input
 			a = ControlConstants.Disabled;
 			b = 0;
 		}
@@ -396,28 +394,29 @@
 		distLbl.modify(b, a);
 		coosBtn.modify(b, a);
 		coosLbl.modify(b, a);
-		km.modify(b,a);
+		km.modify(b, a);
 		repaintNow();
 
 	}
 
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB || ev.target == cancelBPerCache){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB || ev.target == cancelBPerCache) {
 				this.close(FormBase.IDCANCEL);
-			}
-			else if (ev.target == okBtiles || ev.target == okBPerCache){
+			} else if (ev.target == okBtiles || ev.target == okBPerCache) {
 				if (sortingMapServices[mapServiceChoice.selectedIndex] == -1) {
 					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1833, "Please don't select the separator line in the wms service option"), FormBase.OKB)).execute();
 				}
 				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 				if (ev.target == okBtiles) { // get tiles
 					perCache = false;
-					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all"))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all")))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBox.getState();
-					radius = (float)CacheWolf.Common.parseDouble(distanceInput.getText());
-					scale = (float)CacheWolf.Common.parseDouble(scaleInput.getText());
+					radius = (float) CacheWolf.Common.parseDouble(distanceInput.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInput.getText());
 					overlapping = Convert.toInt(overlappingInput.getText());
 					if (!forCachesChkBox.getState()) {
 						if (radius <= 0) {
@@ -435,41 +434,43 @@
 					}
 				} else { // per cache
 					perCache = true;
-					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all"))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all")))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBoxPerCache.getState();
-					scale = (float)CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
 					tileWidth = CacheWolf.Common.parseInt(tileWidthInput.getText());
 					tileHeight = CacheWolf.Common.parseInt(tileHeightInput.getText());
 					if (tileWidth <= 0) {
 						new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1836, "Width of tiles must be greater 0."), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					if (tileHeight <= 0) {
 						new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1837, "Height of tiles must be greater 0."), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					// If width and height has been valid, set them in preferences also:
-					pref.tileheight=tileHeight;
-					pref.tilewidth=tileWidth;
+					pref.tileheight = tileHeight;
+					pref.tilewidth = tileWidth;
 				}
 				if (scale < mapLoader.currentOnlineMapService.minscale || scale > mapLoader.currentOnlineMapService.maxscale) {
 					if (scale < mapLoader.currentOnlineMapService.minscale) {
 						scaleInput.setText(Convert.toString(mapLoader.currentOnlineMapService.minscale));
-						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale*100)/100));
+						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale * 100) / 100));
 					} else {
-						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale*100)/100));
+						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale * 100) / 100));
 						scaleInputPerCache.setText(Convert.toString(mapLoader.currentOnlineMapService.maxscale));
 					}
-					(new MessageBox(MyLocale.getMsg(321, "Error"), "! " + scale + "\n" + MyLocale.getMsg(1830, "The selected online map service provides map in the scale from") + " " + mapLoader.currentOnlineMapService.minscale + MyLocale.getMsg(1831, " to") + " " + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, "\n please adjust 'Approx. meter pro pixel' accordingly"), FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(321, "Error"), "! " + scale + "\n" + MyLocale.getMsg(1830, "The selected online map service provides map in the scale from") + " " + mapLoader.currentOnlineMapService.minscale
+							+ MyLocale.getMsg(1831, " to") + " " + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, "\n please adjust 'Approx. meter pro pixel' accordingly"), FormBase.OKB)).execute();
 					return;
 				}
 				this.close(FormBase.IDOK);
 				this.downloadTiles();
-			}
-			else if (ev.target == coosBtn) {
+			} else if (ev.target == coosBtn) {
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(center, TransformCoordinates.CW);
 				if (cs.execute() != FormBase.IDCANCEL) {
@@ -479,32 +480,29 @@
 					sortMapServices();
 					mapServiceChoice.set(sortedmapServices, (!inbound[tmp] ? 0 : getSortedMapServiceIndex((tmp))));
 				}
-			}
-			else if (ev.target == forCachesChkBox) {
+			} else if (ev.target == forCachesChkBox) {
 				updateForCachesState();
+			} else if (ev.target == tileSize) {
+				switch (tileSize.getSelectedIndex()) {
+				case 0:
+					overlappingInput.setText("10");
+					pref.mapTileSize = 0;
+					pref.mapOverlapping = 10;
+					break;
+				default:
+					overlappingInput.setText("100");
+					pref.mapTileSize = 1;
+					pref.mapOverlapping = 100;
+				}
 			}
-			else if (ev.target == tileSize){
-			    switch (tileSize.getSelectedIndex()){
-			    case 0:
-			    overlappingInput.setText ("10");
-			    pref.mapTileSize=0;
-			    pref.mapOverlapping=10;
-			    break;
-			    default:
-			    overlappingInput.setText ("100");
-			    pref.mapTileSize=1;
-			    pref.mapOverlapping=100;
-			    }
-			}
 		} // end of "if controllEvent..."
-		if (ev instanceof DataChangeEvent){
-		    if (ev.target == mapServiceChoice) {
-			mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
-			setRecommScaleInput();
-		    }
-		    else if (ev.target == overlappingInput){
-			pref.mapOverlapping = Convert.toInt(overlappingInput.getText ());
-		    }
+		if (ev instanceof DataChangeEvent) {
+			if (ev.target == mapServiceChoice) {
+				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
+				setRecommScaleInput();
+			} else if (ev.target == overlappingInput) {
+				pref.mapOverlapping = Convert.toInt(overlappingInput.getText());
+			}
 		}
 		super.onEvent(ev);
 	}

Modified: branches/r1.2/src/CacheWolf/navi/MapSymbol.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapSymbol.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapSymbol.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,26 +33,30 @@
 	String name;
 	String filename;
 	CWPoint where;
-	
+
 	public MapSymbol(String namei, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 		mapObject = mapObjecti;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, Image fromIm, CWPoint where_) {
 		name = namei;
 		where = where_;
 		mapObject = mapObjecti;
 		setImage(fromIm);
 	}
-	public void loadImage(){
-		setImage(new Image(filename),0); freeSource();;
-		//properties = AniImage.AlwaysOnTop;
+
+	public void loadImage() {
+		setImage(new Image(filename), 0);
+		freeSource();
+		// properties = AniImage.AlwaysOnTop;
 	}
 }

Modified: branches/r1.2/src/CacheWolf/navi/MapsList.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapsList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapsList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -300,8 +300,8 @@
 	 * if no map includes both it returns null
 	 * @param if more than one map includes topleft and bottomright than the one will
 	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
-	 * as topleft and buttomright use gps as topleft.
-	 * if topleft is really topleft or if it is buttomright is not relevant.
+	 * as topleft and bottomright use gps as topleft.
+	 * if topleft is really topleft or if it is bottomright is not relevant.
 	 */
 
 	public final MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
@@ -527,9 +527,9 @@
 	}
 */
 	/** for determining if a new map should be downloaded
-	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
-		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
-			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
+	public boolean isInAmap(CWPoint topleft, CWPoint bottomright) {
+		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(bottomright.latDec)) ||
+			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(boxsttomright.lonDec)
 			return false;
 	}
 	 */

Modified: branches/r1.2/src/CacheWolf/navi/MovingMap.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MovingMap.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MovingMap.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,7 +33,6 @@
 import CacheWolf.CacheType;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import CacheWolf.GuiImageBroker;
 import CacheWolf.InfoBox;
 import CacheWolf.MainTab;
 import CacheWolf.MyLocale;
@@ -61,6 +60,7 @@
 import ewe.sys.Convert;
 import ewe.sys.Double;
 import ewe.sys.SystemResourceException;
+import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
 import ewe.ui.ControlConstants;
@@ -86,17 +86,21 @@
 import ewe.util.Vector;
 
 /**
- *	Class to handle a moving map.
+ * Class to handle a moving map.
  */
 public final class MovingMap extends Form implements ICommandListener {
-	public final static int gotFix = 4; //green
-	public final static int lostFix = 3; //yellow
+	public final static int gotFix = 4; // green
+	public final static int lostFix = 3; // yellow
 	public final static int noGPSData = 2; // red
-	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
-	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
+	public final static int noGPS = 1; // no GPS-Position marker, manually
+										// disconnected
+	public final static int ignoreGPS = -1; // ignore even changes in
+											// GPS-signal (eg. from lost fix
+											// to gotFix) this is wanted
+											// when the map is moved
+											// manually
 
 	public MapSymbol gotoPos = null;
-	CacheHolder markedCache = null;
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
@@ -107,7 +111,7 @@
 	CWPoint TrackOverlaySetCenterTopLeft;
 	Vector tracks;
 	MapInfoObject currentMap = null;
-	//String mapPath;
+	// String mapPath;
 	Navigate myNavigation;
 	boolean running = false;
 
@@ -117,33 +121,39 @@
 	AniImage statusImageNoSignal;
 	AniImage statusImageNoGps;
 	MapSymbol posCircle;
-	String MARK_CACHE_IMAGE;
+	final static Image imgSelectedCache = new Image("mark_cache.png");
+	final static Image imgGoto = new Image("goto_map.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
-	//double posCircleLat, posCircleLon;
+	// double posCircleLat, posCircleLon;
 	FontMetrics fm;
 
-	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean dontUpdatePos = false; // this is only internaly used to avoid
+									// multi-threading problems
 	boolean ignoreGps = false; // ignores updateGps-calls if true
 	boolean autoSelectMap = true;
-	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean forceMapLoad = true; // only needed to force updateposition
+									// to try to load the best map again
+									// after OutOfMemoryError after an
+									// repeated click on snap-to-gps
 	public boolean mapHidden = false;
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
 	public boolean mapsloaded = false;
-	boolean additionalOverlaysDeleted=true;
-	protected boolean paintPosDestLine=true;
+	boolean additionalOverlaysDeleted = true;
+	protected boolean paintPosDestLine = true;
 	Point lastRepaintMapPos = null;
 	double lastDistance = -1;
 
 	// the layer for the buttons
-	private MovingMapControls controlsLayer;
-	
+	private final MovingMapControls controlsLayer;
+
 	float lastHighestResolutionGPSDestScale = -1;
 
 	public static final int tileWidth = 100;
 	public static final int tileHeight = 100;
 
-	//Needed by updatePosition to decide if a recalculation of map-tiles is needed:
+	// Needed by updatePosition to decide if a recalculation of map-tiles is
+	// needed:
 	private int lastXPos;
 	private int lastYPos;
 	private int lastWidth;
@@ -157,76 +167,83 @@
 	public void setFillWhiteArea(boolean fillWhiteArea) {
 		pref.fillWhiteArea = fillWhiteArea;
 		if (!fillWhiteArea) { // remove tiles from panel
-			for (int i = mmp.images.size() -1; i >= 0; i--) {
-				AniImage im = (AniImage) mmp.images.get(i);
-				if ((im instanceof MapImage)
-						&& (!((im instanceof MapSymbol)
-								|| (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+			for (int i = mmp.images.size() - 1; i >= 0; i--) {
+				final AniImage im = (AniImage) mmp.images.get(i);
+				if ((im instanceof MapImage) && (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
 					mmp.images.remove(im);
 				}
 			}
 		}
 	}
 
-	public boolean getShowCachesOnMap() {return pref.showCachesOnMap; }
 	public void setShowCachesOnMap(boolean value) {
 		if (value != pref.showCachesOnMap) {
-			pref.showCachesOnMap=value;
+			pref.showCachesOnMap = value;
 		}
 		if (!value) {
 			removeAllMapSymbols();
 		}
 
 	}
-	
-	
+
 	public boolean isMobileVga() {
 		return mobileVGA;
 	}
-	
+
 	public InteractivePanel getMmp() {
 		return mmp;
 	}
-	
+
 	public MovingMapControls getControlsLayer() {
 		return controlsLayer;
 	}
 
-	public MovingMap(Navigate nav, CacheDB cacheDB){
+	public MovingMap(Navigate nav, CacheDB cacheDB) {
 		this.cacheDB = cacheDB;
 		this.myNavigation = nav;
 		this.pref = Global.getPref();
-		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)	this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
-//      The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
-//      when MovingMap was started with maximized CacheWolf-Window
-//		this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
+		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)
+			this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
+		// The following line is commented out, because this caused trouble
+		// under ewe-vm v1.49 on win-xp
+		// when MovingMap was started with maximized CacheWolf-Window
+		// this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE |
+		// UIConstants.BDR_NOBORDER;
 		this.hasTopBar = false;
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-//		this.setPreferredSize(240,320);
+		// this.setPreferredSize(240,320);
 		this.title = "Moving Map";
-		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.backGround = new Color(254, 254, 254); // background must not
+													// be black because
+													// black is interpreted
+													// as transparent and
+													// transparent images
+													// above (eg
+													// trackoverlay) want be
+													// drawn in windows-VM,
+													// so be care, don|t use
+													// white either
 
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 
-		if (Vm.isMobile() && MyLocale.getScreenWidth() >= 400) 
+		if (Vm.isMobile() && MyLocale.getScreenWidth() >= 400)
 			mobileVGA = true;
-		String imagesize="";
-		if(mobileVGA) imagesize="_vga";
+		String imagesize = "";
+		if (mobileVGA)
+			imagesize = "_vga";
 
-		
-		statusImageHaveSignal = new AniImage("position_green"+imagesize+".png");
-		statusImageNoSignal = new AniImage("position_yellow"+imagesize+".png");
-		statusImageNoGps = new AniImage("position_red"+imagesize+".png");
-		posCircle = new MapSymbol("position_green"+imagesize+".png", "gps-position", new CWPoint());
-		MARK_CACHE_IMAGE = "mark_cache.png";
-		//directionArrows
+		statusImageHaveSignal = new AniImage("position_green" + imagesize + ".png");
+		statusImageNoSignal = new AniImage("position_yellow" + imagesize + ".png");
+		statusImageNoGps = new AniImage("position_red" + imagesize + ".png");
+		posCircle = new MapSymbol("position_green" + imagesize + ".png", "gps-position", new CWPoint());
+		// directionArrows
 		directionArrows.properties = mImage.AlwaysOnTop;
 		mmp.addImage(directionArrows);
-		//target distance
-		int fontSize = ( 3 * pref.fontSize ) / 2;
-		Font imageFont = new Font("Helvetica", Font.PLAIN, fontSize );
+		// target distance
+		final int fontSize = (3 * pref.fontSize) / 2;
+		final Font imageFont = new Font("Helvetica", Font.PLAIN, fontSize);
 		fm = getFontMetrics(imageFont);
 		setGpsStatus(noGPS);
 		posCircle.properties = mImage.AlwaysOnTop;
@@ -238,56 +255,70 @@
 		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 		lastHighestResolutionGPSDestScale = -1;
 
-		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
-		
+		lastRepaintMapPos = new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
+
 		controlsLayer = new MovingMapControls(this);
-		
-		
+
 	}
 
-	public void resizeTo(int w,int h) {
+	public void resizeTo(int w, int h) {
 		super.resizeTo(w, h);
 		updateFormSize(w, h);
 	}
 
 	public void updateFormSize(int w, int h) {
 		MapImage.setScreenSize(w, h);
-		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
-		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged();
-		if (posCircle != null) posCircle.screenDimChanged();
-		if (tracks != null) rebuildOverlaySet();
-		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
-			for (int i = symbols.size() -1; i >= 0; i-- ) {
-				((MapSymbol)symbols.get(i)).screenDimChanged();
+		directionArrows.setLocation(w / 2 - directionArrows.getWidth() / 2, 10);
+		if (mmp.mapImage != null)
+			mmp.mapImage.screenDimChanged();
+		if (posCircle != null)
+			posCircle.screenDimChanged();
+		if (tracks != null)
+			rebuildOverlaySet();
+		if (symbols != null) { // TODO: see if the rest of the code works
+								// with symbols = null
+			for (int i = symbols.size() - 1; i >= 0; i--) {
+				((MapSymbol) symbols.get(i)).screenDimChanged();
 			}
 		}
-		if (controlsLayer!=null) {
+		if (controlsLayer != null) {
 			controlsLayer.updateFormSize(w, h);
 		}
 	}
 
 	boolean loadingMapList = false;
+
 	/**
 	 * loads the list of maps
-	 * @param mapsPath must not have a trailing end "/"
-	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 * 
+	 * @param mapsPath
+	 *            must not have a trailing end "/"
+	 * @param lat
+	 *            used to create empty maps with correct conversion from lon
+	 *            to meters the latitude must be known
 	 */
-	public void loadMaps(String mapsPath, double lat){
-		if (loadingMapList) return;
+	public void loadMaps(String mapsPath, double lat) {
+		if (loadingMapList)
+			return;
 		loadingMapList = true;
-		InfoBox inf = new InfoBox(MyLocale.getMsg(4201, "Info"), MyLocale.getMsg(4203, "Loading list of maps..."));
+		final InfoBox inf = new InfoBox(MyLocale.getMsg(4201, "Info"), MyLocale.getMsg(4203, "Loading list of maps..."));
 		Vm.showWait(this, true);
 		inf.exec();
 		inf.waitUntilPainted(100);
 		resetCenterOfMap();
-		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		final boolean saveGpsIgnoreStatus = dontUpdatePos;
 		dontUpdatePos = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
-			(new MessageBox(MyLocale.getMsg(4201, "Information"), MyLocale.getMsg(4204, "No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated"), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(4201, "Information"), MyLocale.getMsg(4204, "No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated"),
+					FormBase.OKB)).execute();
 			noMapsAvailable = true;
-		} else noMapsAvailable = false;
-		maps.addEmptyMaps(lat); // the empty maps must be added last, otherwise in method setBestMap, when no map is available, a malfunction will happen, see there
+		} else
+			noMapsAvailable = false;
+		maps.addEmptyMaps(lat); // the empty maps must be added last,
+								// otherwise in method setBestMap, when no
+								// map is available, a malfunction will
+								// happen, see there
 		maps.onCompletedRead();
 		dontUpdatePos = saveGpsIgnoreStatus;
 		inf.close(0);
@@ -298,11 +329,10 @@
 
 	public void updateScale() {
 
-		if (currentMap != null)
-		{
+		if (currentMap != null) {
 			double lineLengthMeters = 40 * currentMap.scale;
 
-			int metricSystem = pref.metricSystem;
+			final int metricSystem = pref.metricSystem;
 			double localizedLineLength = 0;
 			int bigUnit = -1;
 			int smallUnit = -1;
@@ -313,7 +343,7 @@
 				smallUnit = Metrics.FEET;
 				threshold = 501;
 
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, smallUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, smallUnit);
 			} else {
 				bigUnit = Metrics.KILOMETER;
 				smallUnit = Metrics.METER;
@@ -324,53 +354,50 @@
 
 			int currentUnit = smallUnit;
 
-			float digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-			localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			float digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+			localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 
-			if (localizedLineLength >= threshold)
-			{
+			if (localizedLineLength >= threshold) {
 				currentUnit = bigUnit;
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, currentUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, currentUnit);
 
-				digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-				localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+				digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+				localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 			}
 
 			String lineLengthString = Convert.toString((int) localizedLineLength) + Metrics.getUnit(currentUnit);
 
-			if	(digits < 0){
-				Double tmp = new Double();
+			if (digits < 0) {
+				final Double tmp = new Double();
 				tmp.set(localizedLineLength);
 
-				int decimals = (int)(-1 * digits);
+				final int decimals = (int) (-1 * digits);
 
-				lineLengthString = tmp.toString(decimals+2,decimals,0) + Metrics.getUnit(currentUnit);
-//				lineLengthString = MyLocale.formatDouble(tmp,"0.000") + Metrics.getUnit(currentUnit);
+				lineLengthString = tmp.toString(decimals + 2, decimals, 0) + Metrics.getUnit(currentUnit);
+				// lineLengthString = MyLocale.formatDouble(tmp,"0.000") +
+				// Metrics.getUnit(currentUnit);
 			}
 
-			lineLengthMeters = Metrics.convertUnit( localizedLineLength, currentUnit, Metrics.METER);
+			lineLengthMeters = Metrics.convertUnit(localizedLineLength, currentUnit, Metrics.METER);
 
-			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+			final int lineLengthPixels = (int) java.lang.Math.round(lineLengthMeters / currentMap.scale);
 
 			controlsLayer.updateContent("scale", lineLengthString, lineLengthPixels);
-		}
-		else{
+		} else {
 
-		controlsLayer.updateContent("scale", "no map", 20);
+			controlsLayer.updateContent("scale", "no map", 20);
 		}
 	}
 
 	public void updateDistance(boolean repaint) {
-		if (gotoPos != null && posCircle.where.isValid())
-		{
-			double currentDistance = gotoPos.where.getDistance(posCircle.where);
-			if (currentDistance != lastDistance)
-			{
+		if (gotoPos != null && posCircle.where.isValid()) {
+			final double currentDistance = gotoPos.where.getDistance(posCircle.where);
+			if (currentDistance != lastDistance) {
 				lastDistance = currentDistance;
-				ewe.sys.Double dd = new ewe.sys.Double();
+				final ewe.sys.Double dd = new ewe.sys.Double();
 				String d;
 
-				int metricSystem = pref.metricSystem;
+				final int metricSystem = pref.metricSystem;
 				double localizedDistance = 0;
 				int bigUnit = -1;
 				int smallUnit = -1;
@@ -389,42 +416,45 @@
 					localizedDistance = currentDistance;
 				}
 				dd.set(localizedDistance);
-				if (dd.value >= threshold){
-					d = MyLocale.formatDouble(dd,"0.000") + Metrics.getUnit(bigUnit);
+				if (dd.value >= threshold) {
+					d = MyLocale.formatDouble(dd, "0.000") + Metrics.getUnit(bigUnit);
 				} else {
 					dd.set(Metrics.convertUnit(dd.value, bigUnit, smallUnit));
-					d = dd.toString(3,0,0) + Metrics.getUnit(smallUnit);
+					d = dd.toString(3, 0, 0) + Metrics.getUnit(smallUnit);
 				}
 
 				controlsLayer.updateContent("distance", d);
 
 			}
-		}
-		else
-		{
+		} else {
 			controlsLayer.updateContent("distance", "");
 		}
 	}
 
 	public void forceMapLoad() {
 		forceMapLoad = true;
-		updatePosition(posCircle.where); // this sets forceMapLoad to false after loading a map
+		updatePosition(posCircle.where); // this sets forceMapLoad to
+											// false after loading a map
 	}
 
 	public final FormFrame myExec(CWPoint centerTo, boolean forceCenter) {
-		FormFrame ret = exec();
+		final FormFrame ret = exec();
 		running = true;
-		// disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
-		if (forceCenter) setGpsStatus(noGPS);
-		// to load maplist + place a map on screen otherwise no symbol can be placed
-		ignoreGps=true; // else overlay symbols are removed on started gps
-		
+		// disconnect movingMap from GPS TODO only if GPS-pos is not on the
+		// screen
+		if (forceCenter)
+			setGpsStatus(noGPS);
+		// to load maplist + place a map on screen otherwise no symbol can
+		// be placed
+		ignoreGps = true; // else overlay symbols are removed on started
+							// gps
+
 		rebuildOverlaySet(); // show tracks , even if reentering map
-		
+
 		updatePosition(centerTo);
 		setCenterOfScreen(centerTo, false);
-		
-		if (getControlsLayer()!=null) {
+
+		if (getControlsLayer() != null) {
 			getControlsLayer().changeRoleState(MovingMapControls.ROLE_MENU, false);
 		}
 
@@ -432,50 +462,39 @@
 		if (Global.getProfile().selectionChanged) {
 			// this means marking has changed
 			Global.getProfile().selectionChanged = false;
-			if (getShowCachesOnMap()) removeAllMapSymbols(); // not really needed: hopefully removed by showCachesOnMap
+			if (pref.showCachesOnMap)
+				removeAllMapSymbols(); // not really needed: hopefully
+										// removed by showCachesOnMap
 		}
-		setMarkedCache(Global.mainTab.ch); // this is the selected one (not necessary marked)
 		showCachesOnMap();
-		
+
 		if (myNavigation.destinationIsCache) {
 			destChanged(myNavigation.destinationCache);
-		}
-		else {
+		} else {
 			destChanged(myNavigation.destination);
 		}
 
 		repaint();
-		ignoreGps=false;
-		
+		ignoreGps = false;
+
 		return ret;
 	}
 
-	public void setMarkedCache(CacheHolder ch) {
-		if (ch == markedCache) return;
-		if (markedCache != null) {
-			removeMapSymbol("selectedCache");
-			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
-		}
-		if (ch != null) {
-			if ( ch.pos.isValid()) {
-				addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos);
-				addSymbolIfNecessary(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
-				markedCache = ch;
-			}
-		}
-	}
-
 	public void addTrack(Track tr) {
-		if (tr == null) return;
-		if (tracks == null) tracks = new Vector();
-		if (tracks.find(tr) >= 0 ) return; // track already in list
+		if (tr == null)
+			return;
+		if (tracks == null)
+			tracks = new Vector();
+		if (tracks.find(tr) >= 0)
+			return; // track already in list
 		tracks.add(tr);
 		rebuildOverlaySet();
 	}
 
 	public void addTracks(Track[] trs) {
-		if (trs==null || trs.length == 0) return;
-		for (int i=0; i<trs.length; i++) {
+		if (trs == null || trs.length == 0)
+			return;
+		for (int i = 0; i < trs.length; i++) {
 			addTrack(trs[i]);
 		}
 		rebuildOverlaySet();
@@ -483,26 +502,30 @@
 
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
-	 *
+	 * 
 	 * add tracks with addtrack(track) before
 	 */
 
 	public void addOverlaySet() {
-		if (tracks == null) return; // no tracks
+		if (tracks == null)
+			return; // no tracks
 		try {
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 			addMissingOverlays();
-		} catch (NullPointerException e) {
+		} catch (final NullPointerException e) {
 			// hapens if currentmap == null or PosCircle not valid
+		} catch (final IllegalArgumentException e) {
+			// happens if screensize is still not known ---> in both cases
+			// creation of Overlayset will be done in updateOverlayPos if
+			// tracks != null
 		}
-		catch (IllegalArgumentException e) {
-			// happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
-		}
 	}
 
 	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
-			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
+			for (int i = 0; i < TrackOverlays.length; i++) {
+				destroyOverlay(i);
+			}
 		}
 		Vm.getUsedMemory(true); // call garbage collection
 		Vm.gc();
@@ -514,24 +537,49 @@
 	}
 
 	public void addMissingOverlays() {
-		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0)
+			return; // height == 0 happens if this is called before the form
+					// ist displayed on the screen
 		if (TrackOverlays == null) {
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 		}
-		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		final boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid
+															// multi-threading
+															// problems
 		dontUpdatePos = true;
-		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
-		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
-		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		final Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4]
+																				// ==
+																				// center
+																				// of
+																				// Trackoverlays
+		// upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 *
+		// width;
+		// upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1
+		// * height;
 		int i;
-		for (int yi=0; yi<3; yi++) {
-			for (int xi=0; xi<3; xi++) {
-				i = yi*3+xi;
-				if (TrackOverlays[i]==null) {
+		for (int yi = 0; yi < 3; yi++) {
+			for (int xi = 0; xi < 3; xi++) {
+				i = yi * 3 + xi;
+				if (TrackOverlays[i] == null) {
 					pref.log("addMissingOverlays: widht: " + width + ", height: " + height);
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap);
-					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
+					TrackOverlays[i] = new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x + (xi - 1) * width, upperleftOf4.y + (yi - 1) * height), width, height, currentMap);
+					TrackOverlays[i].setLocation(width + 1, height + 1); // outside
+																			// of
+																			// the
+																			// screen
+																			// will
+																			// hide
+																			// it
+																			// automatically
+																			// it
+																			// will
+																			// get
+																			// the
+																			// correct
+																			// position
+																			// in
+																			// upadteOverlayposition
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -539,29 +587,32 @@
 			}
 		}
 		updateOverlayOnlyPos();
-		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		if (mmp.mapImage != null)
+			mmp.images.moveToBack(mmp.mapImage);
 		dontUpdatePos = saveGPSIgnoreStatus;
 	}
 
 	private void destroyOverlay(int ov) {
-		if (TrackOverlays[ov] == null) return;
+		if (TrackOverlays[ov] == null)
+			return;
 		mmp.removeImage(TrackOverlays[ov]);
 		TrackOverlays[ov].free();
-		TrackOverlays[ov]=null;
+		TrackOverlays[ov] = null;
 	}
+
 	public void rearangeOverlays() {
-		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
+		final Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
-			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2 * height));
 			destroyOverlay(6);
 			destroyOverlay(7);
 			destroyOverlay(8);
 			mmp.removeImage(TrackOverlays[0]);
 			mmp.removeImage(TrackOverlays[1]);
 			mmp.removeImage(TrackOverlays[2]);
-			TrackOverlays[6]=TrackOverlays[0];
-			TrackOverlays[7]=TrackOverlays[1];
-			TrackOverlays[8]=TrackOverlays[2];
+			TrackOverlays[6] = TrackOverlays[0];
+			TrackOverlays[7] = TrackOverlays[1];
+			TrackOverlays[8] = TrackOverlays[2];
 			mmp.addImage(TrackOverlays[6]);
 			mmp.addImage(TrackOverlays[7]);
 			mmp.addImage(TrackOverlays[8]);
@@ -573,16 +624,16 @@
 			destroyOverlay(5);
 		} else {
 			if (TrackOverlays[3].isOnScreen()) { // links raus
-				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y));
 				destroyOverlay(2);
 				destroyOverlay(5);
 				destroyOverlay(8);
 				mmp.removeImage(TrackOverlays[0]);
 				mmp.removeImage(TrackOverlays[3]);
 				mmp.removeImage(TrackOverlays[6]);
-				TrackOverlays[2]=TrackOverlays[0];
-				TrackOverlays[5]=TrackOverlays[3];
-				TrackOverlays[8]=TrackOverlays[6];
+				TrackOverlays[2] = TrackOverlays[0];
+				TrackOverlays[5] = TrackOverlays[3];
+				TrackOverlays[8] = TrackOverlays[6];
 				mmp.addImage(TrackOverlays[2]);
 				mmp.addImage(TrackOverlays[5]);
 				mmp.addImage(TrackOverlays[8]);
@@ -594,16 +645,16 @@
 				destroyOverlay(7);
 			} else {
 				if (TrackOverlays[5].isOnScreen()) { // rechts raus
-					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y));
 					destroyOverlay(0);
 					destroyOverlay(3);
 					destroyOverlay(6);
 					mmp.removeImage(TrackOverlays[2]);
 					mmp.removeImage(TrackOverlays[5]);
 					mmp.removeImage(TrackOverlays[8]);
-					TrackOverlays[0]=TrackOverlays[2];
-					TrackOverlays[3]=TrackOverlays[5];
-					TrackOverlays[6]=TrackOverlays[8];
+					TrackOverlays[0] = TrackOverlays[2];
+					TrackOverlays[3] = TrackOverlays[5];
+					TrackOverlays[6] = TrackOverlays[8];
 					mmp.addImage(TrackOverlays[0]);
 					mmp.addImage(TrackOverlays[3]);
 					mmp.addImage(TrackOverlays[6]);
@@ -615,16 +666,16 @@
 					destroyOverlay(7);
 				} else {
 					if (TrackOverlays[7].isOnScreen()) { // unten raus
-						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2 * height));
 						destroyOverlay(0);
 						destroyOverlay(1);
 						destroyOverlay(2);
 						mmp.removeImage(TrackOverlays[6]);
 						mmp.removeImage(TrackOverlays[7]);
 						mmp.removeImage(TrackOverlays[8]);
-						TrackOverlays[0]=TrackOverlays[6];
-						TrackOverlays[1]=TrackOverlays[7];
-						TrackOverlays[2]=TrackOverlays[8];
+						TrackOverlays[0] = TrackOverlays[6];
+						TrackOverlays[1] = TrackOverlays[7];
+						TrackOverlays[2] = TrackOverlays[8];
 						mmp.addImage(TrackOverlays[0]);
 						mmp.addImage(TrackOverlays[1]);
 						mmp.addImage(TrackOverlays[2]);
@@ -634,12 +685,14 @@
 						destroyOverlay(3);
 						destroyOverlay(4);
 						destroyOverlay(5);
-					} else { // it is important to test for diagonal only if the other didn't match
-						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
-							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+					} else { // it is important to test for diagonal only
+								// if the other didn't match
+						if (TrackOverlays[0].isOnScreen()) { // links
+																// oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y - 2 * height));
 							destroyOverlay(8);
 							mmp.removeImage(TrackOverlays[0]);
-							TrackOverlays[8]=TrackOverlays[0];
+							TrackOverlays[8] = TrackOverlays[0];
 							mmp.addImage(TrackOverlays[8]);
 							TrackOverlays[0] = null;
 							destroyOverlay(1);
@@ -650,11 +703,13 @@
 							destroyOverlay(6);
 							destroyOverlay(7);
 						} else {
-							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
-								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+							if (TrackOverlays[2].isOnScreen()) { // rechts
+																	// oben
+																	// raus
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y - 2 * height));
 								destroyOverlay(6);
 								mmp.removeImage(TrackOverlays[2]);
-								TrackOverlays[6]=TrackOverlays[2];
+								TrackOverlays[6] = TrackOverlays[2];
 								mmp.addImage(TrackOverlays[6]);
 								TrackOverlays[2] = null;
 								destroyOverlay(0);
@@ -665,11 +720,13 @@
 								destroyOverlay(7);
 								destroyOverlay(8);
 							} else {
-								if (TrackOverlays[6].isOnScreen()) { // links unten raus
-									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+								if (TrackOverlays[6].isOnScreen()) { // links
+																		// unten
+																		// raus
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y + 2 * height));
 									destroyOverlay(2);
 									mmp.removeImage(TrackOverlays[6]);
-									TrackOverlays[2]=TrackOverlays[6];
+									TrackOverlays[2] = TrackOverlays[6];
 									mmp.addImage(TrackOverlays[2]);
 									TrackOverlays[6] = null;
 									destroyOverlay(0);
@@ -680,11 +737,13 @@
 									destroyOverlay(7);
 									destroyOverlay(8);
 								} else {
-									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
-										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+									if (TrackOverlays[8].isOnScreen()) { // rechts
+																			// unten
+																			// raus
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y + 2 * height));
 										destroyOverlay(0);
 										mmp.removeImage(TrackOverlays[8]);
-										TrackOverlays[0]=TrackOverlays[8];
+										TrackOverlays[0] = TrackOverlays[8];
 										mmp.addImage(TrackOverlays[0]);
 										TrackOverlays[8] = null;
 										destroyOverlay(1);
@@ -694,49 +753,60 @@
 										destroyOverlay(5);
 										destroyOverlay(6);
 										destroyOverlay(7);
-									}else
-										for (int i=0; i<TrackOverlays.length; i++) {
+									} else
+										for (int i = 0; i < TrackOverlays.length; i++) {
 											destroyOverlay(i);
 											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
-										} // this happens if a position jump occured
-								}}}}}}} // close all IFs
+										} // this happens if a position
+											// jump occured
+								}
+							}
+						}
+					}
+				}
+			}
+		} // close all IFs
 		Vm.gc(); // call garbage collection
 	}
 
 	public void ShowLastAddedPoint(Track tr) {
-		if (TrackOverlays == null || tr == null) return;
-		for (int i=0; i<TrackOverlays.length; i++){
+		if (TrackOverlays == null || tr == null)
+			return;
+		for (int i = 0; i < TrackOverlays.length; i++) {
 			TrackOverlays[i].paintLastAddedPoint(tr);
 		}
 	}
 
 	public void updateOverlayOnlyPos() {
-		if (TrackOverlays == null || TrackOverlays[4] == null) return;
-		//	Point upperleft = getMapXYPosition();
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			return;
+		// Point upperleft = getMapXYPosition();
 		Point posOnScreen;
 		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft);
-		Dimension ws = mmp.getSize(null);
-		int ww = ws.width;
-		int wh = ws.height;
-		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		final Dimension ws = mmp.getSize(null);
+		final int ww = ws.width;
+		final int wh = ws.height;
+		// Vm.sleep(100); // this is necessary because the ewe vm ist not
+		// multi-threaded and the serial thread also needs time
 		int num, pX, pY;
-		for (int yi=0; yi<3; yi++) {
-			for (int xi=0; xi<3; xi++) {
-				num = yi*3+xi;
-				pX = posOnScreen.x+(xi-1)*ww;
-				pY = posOnScreen.y+(yi-1)*wh;
+		for (int yi = 0; yi < 3; yi++) {
+			for (int xi = 0; xi < 3; xi++) {
+				num = yi * 3 + xi;
+				pX = posOnScreen.x + (xi - 1) * ww;
+				pY = posOnScreen.y + (yi - 1) * wh;
 				TrackOverlays[num].setLocation(pX, pY);
 			}
 		}
 	}
 
 	public void updateOverlayPos() {
-		if (tracks == null || tracks.size() == 0) return;
-		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		if (tracks == null || tracks.size() == 0)
+			return;
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			addMissingOverlays();
 		else {
 			updateOverlayOnlyPos();
-			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0
-					|| TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
+			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0 || TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
 				rearangeOverlays();
 				addMissingOverlays();
 				// updateOverlayOnlyPos(); is called from addMissingOverlays
@@ -746,249 +816,289 @@
 
 	/**
 	 * move posCircle to the Centre of the Screen
-	 *
+	 * 
 	 */
 	public void resetCenterOfMap() {
 		if (width != 0) {
-			posCircleX = width /2;
-			posCircleY = height /2;
+			posCircleX = width / 2;
+			posCircleY = height / 2;
 		} else {
-			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-			posCircleY = pref.myAppHeight/2;
+			// maybe this could / should be replaced to windows size
+			posCircleX = pref.myAppWidth / 2;
+			posCircleY = pref.myAppHeight / 2;
 		}
 		posCircle.hidden = false;
-		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -> hiding the posCircle in some situation
+		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2);
+		// posCircle.setLocation a problem -> hiding the posCircle in some situation
 	}
 
 	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
 		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
 	}
 
-	public void setCenterOfScreen (CWPoint c, boolean repaint) {
-		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	public void setCenterOfScreen(CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(this.width / 2, this.height / 2), c, repaint);
 	}
 
 	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
-		Point mappos = getMapPositionOnScreen();
-		Point onscreenpos = getXYonScreen(c);
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		final Point mappos = getMapPositionOnScreen();
+		final Point onscreenpos = getXYonScreen(c);
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
 		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-		if (repaint) mmp.repaintNow();
+		if (repaint)
+			mmp.repaintNow();
 	}
 
-	/** call this if the map moved on the screen (by dragging)
-	 * this routine will adjust (move accordingly) all other symbols on the screen
+	/**
+	 * call this if the map moved on the screen (by dragging) this routine
+	 * will adjust (move accordingly) all other symbols on the screen
+	 * 
 	 * @param diffX
 	 * @param diffY
 	 */
 	public void mapMoved(int diffX, int diffY) {
-		int w = posCircle.getWidth();
-		int h = posCircle.getHeight();
-		int npx = posCircleX-w/2+diffX;
-		int npy = posCircleY-h/2+diffY;
+		final int w = posCircle.getWidth();
+		final int h = posCircle.getHeight();
+		final int npx = posCircleX - w / 2 + diffX;
+		final int npy = posCircleY - h / 2 + diffY;
 		posCircle.move(npx, npy);
-		posCircleX = posCircleX+diffX;
-		posCircleY = posCircleY+diffY;
-		if (posCircle.where.isValid()){
+		posCircleX = posCircleX + diffX;
+		posCircleY = posCircleY + diffY;
+		if (posCircle.where.isValid()) {
 			dontUpdatePos = false;
 			updatePosition(posCircle.where);
-		}
-		else updateSymbolPositions(); // will also be done in updatePosition
+		} else
+			// will also be done in updatePosition
+			updateSymbolPositions();
 		updateOverlayPos();
 	}
 
 	/**
-	 * get upper left corner of map on window
-	 * this is called when the map needs to be moved / the position of the map is wanted
-	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
-	 * returns the same as mmp.mapImage.getLocation(mapPos);
-	 * but also works if mmp == null and is used to move the map to the correct point
+	 * get upper left corner of map on window this is called when the map
+	 * needs to be moved / the position of the map is wanted the
+	 * map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos); but also works
+	 * if mmp == null and is used to move the map to the correct point
+	 * 
 	 * @return
 	 */
 	public Point getMapPositionOnScreen() {
 		if (currentMap == null || !posCircle.where.isValid())
-			return new Point(pref.myAppWidth +1, pref.myAppHeight +1);
-		// in case no calculation is possible return somthing outside of the screen
-		Point mapPos = new Point();
-		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-		//else {
-		Point mapposint = currentMap.calcMapXY(posCircle.where);
+			return new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
+		// in case no calculation is possible return somthing outside of the
+		// screen
+		final Point mapPos = new Point();
+		// if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		// else {
+		final Point mapposint = currentMap.calcMapXY(posCircle.where);
 		mapPos.x = posCircleX - mapposint.x;
 		mapPos.y = posCircleY - mapposint.y;
-		//}
+		// }
 		return mapPos;
 	}
 
 	/**
-	 *
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
 	 */
-	public Point getXYonScreen(TrackPoint ll){
-		if (currentMap == null) return null;
-		Point coords = currentMap.calcMapXY(ll);
-		Point mapPos = getMapPositionOnScreen();
+	public Point getXYonScreen(TrackPoint ll) {
+		if (currentMap == null)
+			return null;
+		final Point coords = currentMap.calcMapXY(ll);
+		final Point mapPos = getMapPositionOnScreen();
 		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 	}
 
-	public CWPoint ScreenXY2LatLon (int px, int py){
-		Point mapPos = getMapPositionOnScreen();
+	public CWPoint ScreenXY2LatLon(int px, int py) {
+		final Point mapPos = getMapPositionOnScreen();
 		return currentMap.calcLatLon(px - mapPos.x, py - mapPos.y);
 	}
 
-
 	public void updateSymbolPositions() {
-		if (symbols == null) return;
+		if (symbols == null)
+			return;
 		Point pOnScreen;
 		MapSymbol symb;
 		int w, h;
 		showCachesOnMap();
-		for (int i=symbols.size()-1; i>=0; i--) {
-			symb = (MapSymbol)symbols.get(i);
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			symb = (MapSymbol) symbols.get(i);
 			pOnScreen = getXYonScreen(symb.where);
-			w=symb.getWidth();
-			h=symb.getHeight();
-			symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+			w = symb.getWidth();
+			h = symb.getHeight();
+			symb.move(pOnScreen.x - w / 2, pOnScreen.y - h / 2);
 		}
 	}
 
 	public MapSymbol addSymbol(String pName, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, filename, where);
+		if (symbols == null)
+			symbols = new Vector();
+		final MapSymbol ms = new MapSymbol(pName, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		final Point pOnScreen = getXYonScreen(where);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
 	public MapSymbol addSymbol(String pName, Object mapObject, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
+		if (symbols == null)
+			symbols = new Vector();
+		final MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		final Point pOnScreen = getXYonScreen(where);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
-	public void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
-		if (findMapSymbol(pName) >= 0) return;
-		else addSymbol(pName, mapObject, imSymb, where);
+	private boolean addSymbolIsNecessary(String pName) {
+		if (findMapSymbol(pName) >= 0)
+			return false;
+		else
+			return true;
 	}
 
+	private void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
+		if (findMapSymbol(pName) >= 0)
+			return;
+		else
+			addSymbol(pName, mapObject, imSymb, where);
+	}
+
 	public void addSymbolOnTop(String pName, Object mapObject, String filename, CWPoint where) {
-		removeMapSymbol(pName); // Object possibly removes another picture from screen
-		addSymbol(pName,mapObject,filename, where);
+		removeMapSymbol(mapObject);
+		addSymbol(pName, mapObject, filename, where);
 	}
 
 	public void addSymbol(String pName, Object mapObject, Image imSymb, CWPoint ll) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
+		if (symbols == null)
+			symbols = new Vector();
+		final MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
 		ms.properties = mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(ll);
-		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		final Point pOnScreen = getXYonScreen(ll);
+		if (pOnScreen != null)
+			ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 	}
 
 	public void destChanged(CWPoint d) {
-		if(!running || (d == null && gotoPos == null) ||
-				(d != null && gotoPos != null && gotoPos.where.equals(d))) return;
+		if (!running || (d == null && gotoPos == null) || (d != null && gotoPos != null && gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol("goto");
-		if (d == null || !d.isValid() ) return;
+		if (d == null || !d.isValid())
+			return;
 		gotoPos = addSymbol("goto", "goto_map.png", d);
-		//updateDistance(); - this is called from updatePosition
 		forceMapLoad = true;
-		if (this.width != 0) updatePosition(posCircle.where); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+		// dirty hack: if this.width == 0, then the symbols are not on the
+		// screen
+		// and get hidden by updateSymbolPositions
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
 	public void destChanged(CacheHolder ch) {
-		CWPoint d = new CWPoint (ch.pos);
-		if(!running || (gotoPos != null && gotoPos.where.equals(d))) return;
+		final CWPoint d = new CWPoint(ch.getPos());
+		if (!running || (gotoPos != null && gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol("goto");
-		if (!d.isValid() ) return;
+		if (!d.isValid())
+			return;
 		gotoPos = addSymbol("goto", ch, "goto_map.png", d);
-		//updateDistance(); - this is called from updatePosition
 		forceMapLoad = true;
-		if (this.width != 0) updatePosition(posCircle.where); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+		// dirty hack: if this.width == 0, then the symbols are not on the
+		// screen
+		// and get hidden by updateSymbolPositions
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
-	public CWPoint getGotoPos(){
-		if (gotoPos == null) return null;
+	public CWPoint getGotoPos() {
+		if (gotoPos == null)
+			return null;
 		return new CWPoint(gotoPos.where);
 	}
 
-	public void removeAllMapSymbols(){
-		if (symbols == null) return;
-		for (int i = symbols.size()-1; i >= 0; i--) {
-			mmp.removeImage((MapSymbol)symbols.get(i));
+	public void removeAllMapSymbols() {
+		if (symbols == null)
+			return;
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			mmp.removeImage((MapSymbol) symbols.get(i));
 		}
 		symbols.removeAllElements();
 	}
 
 	public void removeMapSymbol(String pName) {
-		int symbNr = findMapSymbol(pName);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		final int symbNr = findMapSymbol(pName);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(Object obj) {
-		int symbNr = findMapSymbol(obj);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		final int symbNr = findMapSymbol(obj);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(int SymNr) {
-		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		mmp.removeImage(((MapSymbol) symbols.get(SymNr)));
 		symbols.removeElementAt(SymNr);
 	}
 
 	public int findMapSymbol(String pName) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i >= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == pName) return i;
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.name == pName)
+				return i;
 		}
 		return -1;
 	}
 
 	public int findMapSymbol(Object obj) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i >= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.mapObject == obj) return i;
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.mapObject == obj)
+				return i;
 		}
 		return -1;
 	}
 
 	/**
 	 * Move the map so that the posCircle is at lat/lon
-	 *
+	 * 
 	 * @param
 	 */
-	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
+	public void updateOnlyPosition(CWPoint where, boolean updateOverlay) {
 		posCircle.where.set(where);
-		Point mapPos = getMapPositionOnScreen();
-		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1))
-		{
+		final Point mapPos = getMapPositionOnScreen();
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1)) {
 			lastRepaintMapPos = mapPos;
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			if (mmp.mapImage != null)
+				mmp.mapImage.move(mapPos.x, mapPos.y);
 			updateSymbolPositions();
 			updateDistance(false);
-			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
+			if (updateOverlay)
+				updateOverlayPos(); // && TrackOverlays != null
 			repaint(); // don't wait
-		}
-		else
-		{
+		} else {
 			updateDistance(true);
 		}
 	}
+
 	private void loadBestMap(CWPoint where) {
 		if (!mapsloaded || !this.maps.getMapsPath().equals(pref.getCustomMapsPath())) {
 			loadMaps(pref.getCustomMapsPath(), where.latDec);
@@ -999,46 +1109,47 @@
 			forceMapLoad = false;
 		}
 	}
+
 	/**
-	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 * Method to laod the best map for lat/lon and move the map so that the
+	 * posCircle is at lat/lon
 	 */
-	public void updatePosition(CWPoint where){
-		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+	public void updatePosition(CWPoint where) {
+		if (dontUpdatePos || loadingMapList || (where.latDec == 0 && where.lonDec == 0))
+			return; // avoid multi-threading problems
 		loadBestMap(where);
-		if (width==0 || height==0) { pref.log("[MovingMap:updatePosition]no window shown"); return; } // why is this called with these values
+		if (width == 0 || height == 0) {
+			pref.log("[MovingMap:updatePosition]no window shown");
+			return;
+		} // why is this called with these values
 		updateOnlyPosition(where, true);
-		Point mapPos = getMapPositionOnScreen();
-		boolean screenNotCompletlyCovered = (mmp.mapImage == null)
-				|| (mmp.mapImage != null && (
-				   mapPos.y > 0                                      || mapPos.x                           > 0
-				|| mapPos.y + mmp.mapImage.getHeight() < this.height || mapPos.x + mmp.mapImage.getWidth() < this.width));
-		//if screendimensions changed also force reload of map
+		final Point mapPos = getMapPositionOnScreen();
+		final boolean screenNotCompletlyCovered = (mmp.mapImage == null) || (mmp.mapImage != null && (mapPos.y > 0 || mapPos.x > 0 || mapPos.y + mmp.mapImage.getHeight() < this.height || mapPos.x + mmp.mapImage.getWidth() < this.width));
+		// if screendimensions changed also force reload of map
 		forceMapLoad |= lastWidth != width || lastHeight != height;
-		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) { // if force || want || map doesn't cover the screen completly
-			if (forceMapLoad ||
-				(java.lang.Math.abs(lastCompareX - mapPos.x) > this.width / 10 ||
-				 java.lang.Math.abs(lastCompareY - mapPos.y) > this.height / 10)) {
-				// more then 1/10 of screen moved since last time we tried to find a better map
+		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) {
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX - mapPos.x) > this.width / 10 || java.lang.Math.abs(lastCompareY - mapPos.y) > this.height / 10)) {
+				// more then 1/10 of screen moved since last time we tried
+				// to find a better map
 				if (autoSelectMap) {
 					setBestMap(where, screenNotCompletlyCovered);
 					forceMapLoad = false;
 				}
-				if (isFillWhiteArea()) { fillWhiteArea(screenNotCompletlyCovered); }
+				if (isFillWhiteArea()) {
+					fillWhiteArea(screenNotCompletlyCovered);
+				}
 				lastCompareX = mapPos.x;
 				lastCompareY = mapPos.y;
-			}
-			else{
-				int deltaX = mapPos.x - lastXPos;
-				int deltaY = mapPos.y - lastYPos;
-				for(int i = mmp.images.size() -1; i >= 0; i--){
-					AniImage im = (AniImage) mmp.images.get(i);
-					if ((im instanceof MapImage)
-						&& (!((im instanceof MapSymbol)
-							|| (im instanceof TrackOverlay)
-							|| mmp.mapImage == im))) {
-						//locAlways contains the real coordinates while
-						//location is only correct if the image is on the screen.
-						Point p = ((MapImage)im).locAlways;
+			} else {
+				final int deltaX = mapPos.x - lastXPos;
+				final int deltaY = mapPos.y - lastYPos;
+				for (int i = mmp.images.size() - 1; i >= 0; i--) {
+					final AniImage im = (AniImage) mmp.images.get(i);
+					if ((im instanceof MapImage) && (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+						// locAlways contains the real coordinates while
+						// location is only correct if the image is on the
+						// screen.
+						final Point p = ((MapImage) im).locAlways;
 						p.x += deltaX;
 						p.y += deltaY;
 						im.setLocation(p.x, p.y);
@@ -1056,223 +1167,250 @@
 	private void showCachesOnMap() {
 		// if (width == 0 || height == 0) return;
 		CacheHolder ch;
-		Area screenArea = new Area(ScreenXY2LatLon(0,0), ScreenXY2LatLon(width,height));
+		final Area screenArea = new Area(ScreenXY2LatLon(0, 0), ScreenXY2LatLon(width, height));
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
-			if (screenArea.isInBound(ch.pos)) {
-				// because visible and valid don't change while showing map -->need no remove
-				if (ch.isVisible() && ch.pos.isValid()) {
-					if (getShowCachesOnMap()) {
-						addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
-					}
-					else {
-						if (ch.is_Checked) {
-							addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
+			if (screenArea.isInBound(ch.getPos())) {
+				// because visible and valid don't change while showing map
+				// -->need no remove
+				if (ch.isVisible() && ch.getPos().isValid()) {
+					if (pref.showCachesOnMap) {
+						if (addSymbolIsNecessary(ch.getWayPoint())) {
+							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
 						}
-						else {
+					} else {
+						if (ch.is_Checked || ch == cacheDB.get(Global.mainTab.tbP.getSelectedCache())) {
+							if (addSymbolIsNecessary(ch.getWayPoint())) {
+								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
+							}
+						} else {
 							removeMapSymbol(ch);
 						}
 					}
 				}
-			}else{
-				if (ch.cacheName.equals("")) {
-					removeMapSymbol(ch);
-				}
-				else {
-					// remove the right one , as
-					// possibly more than one picture associated with ch (target,selected ..)
-					removeMapSymbol(ch.cacheName);
-				}
+			} else {
+				removeMapSymbol(ch);
 			}
 		}
 		// adding target and selected
 		// show target
 		if (gotoPos != null) {
-			// the CacheHolder Symbol must be inserted too, even if not marked (if it is Cache)
+			// the CacheHolder Symbol must be inserted too, even if not
+			// marked (if it is Cache)
 			// anywhere there if all Caches shown on map
 			CacheHolder gotoPosCH = null;
 			if (gotoPos.mapObject instanceof CacheHolder) {
 				gotoPosCH = (CacheHolder) gotoPos.mapObject;
 			}
 			if (gotoPosCH != null) {
-				if (screenArea.isInBound(gotoPosCH.pos)) {
-					if (!getShowCachesOnMap()) {
-						addSymbolIfNecessary(gotoPosCH.cacheName, gotoPosCH, GuiImageBroker.getTypeImage(gotoPosCH.getType(),true), gotoPosCH.pos);
+				if (screenArea.isInBound(gotoPosCH.getPos())) {
+					if (!pref.showCachesOnMap) {
+						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.getPos());
 					}
-					addSymbolOnTop("goto", gotoPosCH, "goto_map.png", gotoPos.where);
+					addSymbolIfNecessary("goto", gotoPosCH, imgGoto, gotoPos.where);
 				}
 			}
 		}
-		// show Selected
-		if (markedCache != null) {
-			if (screenArea.isInBound(markedCache.pos)) {
-				addSymbolIfNecessary(markedCache.cacheName, markedCache, GuiImageBroker.getTypeImage(markedCache.getType(),true), markedCache.pos);
-				addSymbolOnTop("selectedCache", markedCache, MARK_CACHE_IMAGE, markedCache.pos);
+		// mark Selected
+		removeMapSymbol("selectedCache");
+		ch = cacheDB.get(Global.mainTab.tbP.getSelectedCache());
+		if (ch != null) {
+			if (screenArea.isInBound(ch.getPos())) {
+				addSymbolIfNecessary("selectedCache", ch, imgSelectedCache, ch.getPos());
 			}
 		}
 	}
-	boolean reflectResourceException=true;
+
+	boolean reflectResourceException = true;
+
 	private void fillWhiteArea(boolean screenNotCompletlyCovered) {
-		if (mmp.mapImage == null) return; // if error at map load
+		if (mmp.mapImage == null)
+			return; // if error at map load
 		// Clean up any additional images, tiles will removed and any
 		// other item be added again later
-		Vector icons = new Vector(mmp.images.size());
-		try {			
-		Vm.showWait(true);
-		dontUpdatePos=true; // no new Position while filling
-		
-		int s = mmp.images.size(); // avoid calling size() in each iteration
-		for (int i = 0; i < s ;  i++) {
-			AniImage im = (AniImage) mmp.images.get(i);
-			if (!(im instanceof MapImage) ||
-				(im instanceof MapSymbol) ||
-				(im instanceof TrackOverlay) ||
-				mmp.mapImage == im) {
-				icons.add(im);
+		final Vector icons = new Vector(mmp.images.size());
+		try {
+			Vm.showWait(true);
+			dontUpdatePos = true; // no new Position while filling
+
+			final int s = mmp.images.size(); // avoid calling size() in
+												// each iteration
+			for (int i = 0; i < s; i++) {
+				final AniImage im = (AniImage) mmp.images.get(i);
+				if (!(im instanceof MapImage) || (im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im) {
+					icons.add(im);
+				}
 			}
-		}
-		mmp.images.clear();
-		// Mark all tiles as dirty
-		MovingMapCache.getCache().clearUsedFlags();
+			mmp.images.clear();
+			// Mark all tiles as dirty
+			MovingMapCache.getCache().clearUsedFlags();
 
-		// Holds areas not filled by currentmap and/or used tiles
-		Vector rectangles = new Vector();
-		// calculate areas which will not drawn
-		Point mapPosx = getMapPositionOnScreen();
-		if ( screenNotCompletlyCovered && ( // screen not completely covered is only used, because it is already calculated
-				mapPosx.x > this.width || mapPosx.y > this.height // map doesn't overlap with the screen
-				|| mapPosx.x + mmp.mapImage.getWidth() < 0 || mapPosx.y + mmp.mapImage.getHeight() < 0) ) {
-			rectangles.add(new Rect(0,0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
-		} else {
-			Rect whiteArea = new Rect((int)(-width/10), (int)(-height/10), (int)(width*1.1), (int)(height*1.1));
-			Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
-			calculateRectangles(blackArea, whiteArea, rectangles);
-		}
-		// I've sometimes experienced an endless loop which might be
-		// caused by a bug in getBestMap. Therefore i will stop the loop
-		// after 30 runs
-		int count = 0;
-		while (isFillWhiteArea() && currentMap.zoomFactor == 1.0
-				&& !mapHidden && !rectangles.isEmpty() && count < 30) {
-			count++;
-			try {
-				updateTileForWhiteArea(rectangles);
+			// Holds areas not filled by currentmap and/or used tiles
+			final Vector rectangles = new Vector();
+			// calculate areas which will not drawn
+			final Point mapPosx = getMapPositionOnScreen();
+			if (screenNotCompletlyCovered && ( // screen not completely
+												// covered is only used,
+												// because it is already
+												// calculated
+					mapPosx.x > this.width || mapPosx.y > this.height // map
+																		// doesn't
+																		// overlap
+																		// with
+																		// the
+																		// screen
+							|| mapPosx.x + mmp.mapImage.getWidth() < 0 || mapPosx.y + mmp.mapImage.getHeight() < 0)) {
+				rectangles.add(new Rect(0, 0, this.width, this.height)); // if
+																			// the
+																			// map
+																			// is
+																			// completely
+																			// outside
+																			// the
+																			// screen,
+																			// just
+																			// fill
+																			// the
+																			// screen,
+																			// nit
+																			// all
+																			// the
+																			// space
+																			// beteween
+																			// the
+																			// map
+																			// and
+																			// the
+																			// screen
+			} else {
+				final Rect whiteArea = new Rect((-width / 10), (-height / 10), (int) (width * 1.1), (int) (height * 1.1));
+				final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
+				calculateRectangles(blackArea, whiteArea, rectangles);
 			}
-			catch (ewe.sys.SystemResourceException sre) {
-				// next time there may be no problem, and ask only once
-				if (reflectResourceException) {
-					if (new MessageBox(
-							"Error",
-							"Not enough ressources to fill white ares, disabling this",
-							MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
-						setFillWhiteArea(false);
-						reflectResourceException=true;
+			// I've sometimes experienced an endless loop which might be
+			// caused by a bug in getBestMap. Therefore i will stop the loop
+			// after 30 runs
+			int count = 0;
+			while (isFillWhiteArea() && currentMap.zoomFactor == 1.0 && !mapHidden && !rectangles.isEmpty() && count < 30) {
+				count++;
+				try {
+					updateTileForWhiteArea(rectangles);
+				} catch (final ewe.sys.SystemResourceException sre) {
+					// next time there may be no problem, and ask only once
+					if (reflectResourceException) {
+						if (new MessageBox("Error", "Not enough ressources to fill white ares, disabling this", MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
+							setFillWhiteArea(false);
+							reflectResourceException = true;
+						} else {
+							reflectResourceException = false;
+						}
 					}
-					else {
-						reflectResourceException=false;						
-					}
 				}
 			}
-		}
-		} 
-		finally {
+		} finally {
 			// Remove all tiles not needed from the cache to reduce memory
 			MovingMapCache.getCache().cleanCache();
 			// At Last redraw all icons on the map
 			mmp.images.addAll(icons);
-			Vm.showWait(false);		
-			dontUpdatePos=false; // do next Position 
+			Vm.showWait(false);
+			dontUpdatePos = false; // do next Position
 			repaint();
-		} 
+		}
 	}
+
 	private void updateTileForWhiteArea(Vector rectangles) {
 		Rect blackArea;
-		Rect r = (Rect) rectangles.get(0);
+		final Rect r = (Rect) rectangles.get(0);
 		rectangles.removeElementAt(0);
-		//calculate the center of the rectangle and try to get an map for it
-		int middlewidth = r.x + (r.width)/2;
-		int middleheight = r.y + (r.height)/2;
-		CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
-		Rect screen = new Rect ();
-		screen.height = r.height ;//- r.y;
-		screen.width = r.width ;//- r.x;
-		MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true,false);
-		if (bestMap == null){
-			//No map found, area must be left white
+		// calculate the center of the rectangle and try to get an map for
+		// it
+		final int middlewidth = r.x + (r.width) / 2;
+		final int middleheight = r.y + (r.height) / 2;
+		final CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
+		final Rect screen = new Rect();
+		screen.height = r.height;// - r.y;
+		screen.width = r.width;// - r.x;
+		final MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true, false);
+		if (bestMap == null) {
+			// No map found, area must be left white
 			return;
 		}
-		//A map was found, but it does not contain the previously calculated center
-		if (!(bestMap.buttomright.latDec <= centerPoint.latDec && centerPoint.latDec <= bestMap.topleft.latDec)){
+		// A map was found, but it does not contain the previously
+		// calculated center
+		if (!(bestMap.bottomright.latDec <= centerPoint.latDec && centerPoint.latDec <= bestMap.topleft.latDec)) {
 			return;
 		}
-		if (!(bestMap.topleft.lonDec <= centerPoint.lonDec && centerPoint.lonDec <= bestMap.buttomright.lonDec)){
+		if (!(bestMap.topleft.lonDec <= centerPoint.lonDec && centerPoint.lonDec <= bestMap.bottomright.lonDec)) {
 			return;
 		}
-		//Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
-		//For me, showing a message seems better than throwing the NPE
-		String imagefilename = bestMap.getImageFilename();
-		if (imagefilename == null){
-			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n")+currentMap.fileNameWFL, FormBase.OKB)).execute();
+		// Pfeffer got an NPE in the following if-statement. I think the
+		// image-filename has got not the correct extension.
+		// For me, showing a message seems better than throwing the NPE
+		final String imagefilename = bestMap.getImageFilename();
+		if (imagefilename == null) {
+			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n") + currentMap.fileNameWFL, FormBase.OKB)).execute();
 			return;
 		}
 
 		if (!imagefilename.equals(currentMap.getImageFilename())) {
-			String filename = bestMap.getImageFilename();
+			final String filename = bestMap.getImageFilename();
 			if (filename.length() > 0) {
-				//calculate position of the new map on the screen
-				Point mapPos = new Point();
-				Point mapposint = bestMap.calcMapXY(posCircle.where);
+				// calculate position of the new map on the screen
+				final Point mapPos = new Point();
+				final Point mapposint = bestMap.calcMapXY(posCircle.where);
 				mapPos.x = posCircleX - mapposint.x;
 				mapPos.y = posCircleY - mapposint.y;
-				Point mapDimension = bestMap.calcMapXY(bestMap.buttomright);
-				blackArea = new Rect (mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
-				//Are there any white areas left?
+				final Point mapDimension = bestMap.calcMapXY(bestMap.bottomright);
+				blackArea = new Rect(mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
+				// Are there any white areas left?
 				calculateRectangles(blackArea, r, rectangles);
-				//Not all maps have the dimension 1000x1000 Pixels, we cache this information:
-				Dimension rect2 = MovingMapCache.getCache().getDimension (filename);
+				// Not all maps have the dimension 1000x1000 Pixels, we
+				// cache this information:
+				Dimension rect2 = MovingMapCache.getCache().getDimension(filename);
 				MapImage fullImage = null;
-				if (rect2 == null){
+				if (rect2 == null) {
 					fullImage = new MapImage(filename);
-					rect2 = new Dimension (fullImage.getHeight(), fullImage.getWidth());
-					MovingMapCache.getCache ().putDimension (filename, rect2);
+					rect2 = new Dimension(fullImage.getHeight(), fullImage.getWidth());
+					MovingMapCache.getCache().putDimension(filename, rect2);
 				}
 				generateTiles(blackArea, filename, mapPos, rect2, fullImage);
 			}
 		}
 	}
 
-	private void generateTiles(Rect blackArea, String filename, Point mapPos,
-			Dimension rect2, MapImage fullImage) {
-		//Generate tiles from the map
-		int numRows = ((rect2.height-1)/tileHeight)+1;
-		int numCols = ((rect2.width-1)/tileWidth)+1;
+	private void generateTiles(Rect blackArea, String filename, Point mapPos, Dimension rect2, MapImage fullImage) {
+		// Generate tiles from the map
+		final int numRows = ((rect2.height - 1) / tileHeight) + 1;
+		final int numCols = ((rect2.width - 1) / tileWidth) + 1;
 		for (int row = 0; row < numRows; row++) {
 			for (int column = 0; column < numCols; column++) {
-				//Tile is not needed, don't process
+				// Tile is not needed, don't process
 				if (!isCoveredByBlackArea(mapPos, row, column, blackArea, rect2)) {
 					continue;
 				}
-				//Get tile from cache or if not found, put all tiles for this image into the cache.
+				// Get tile from cache or if not found, put all tiles for
+				// this image into the cache.
 				MapImage im = MovingMapCache.getCache().get(filename, row, column);
 				if (im == null) {
-					if (fullImage == null){
+					if (fullImage == null) {
 						fullImage = new MapImage(filename);
 					}
 					putImageIntoCache(filename, fullImage, mapPos, blackArea);
 					im = MovingMapCache.getCache().get(filename, row, column);
 				}
-				//If a tile has been found, draw it on the screen
+				// If a tile has been found, draw it on the screen
 				if (im != null) {
-					//Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
-					boolean added=false;
-					for(int i=mmp.images.size()-1; i >= 0; i--) {
-						MapImage m=(MapImage) mmp.images.get(i);
-						if (m == im){
-							added=true;
+					// Check if not already added. this might happen if the
+					// map for horizontal and vertical stripe is the same
+					boolean added = false;
+					for (int i = mmp.images.size() - 1; i >= 0; i--) {
+						final MapImage m = (MapImage) mmp.images.get(i);
+						if (m == im) {
+							added = true;
 							break;
 						}
 					}
-					if(!added){
+					if (!added) {
 						im.setLocation(mapPos.x + (column * tileWidth), mapPos.y + (row * tileHeight));
 						mmp.addImage(im);
 					}
@@ -1283,17 +1421,17 @@
 
 	private void putImageIntoCache(String filename, MapImage fullImage, Point mapPos, Rect blackArea) {
 		MapImage im;
-		int numRows = (fullImage.getHeight()-1)/tileHeight + 1;
-		int numCols = (fullImage.getWidth()-1)/tileWidth + 1;
+		final int numRows = (fullImage.getHeight() - 1) / tileHeight + 1;
+		final int numCols = (fullImage.getWidth() - 1) / tileWidth + 1;
 		for (int row2 = 0; row2 < numRows; row2++) {
 			for (int column2 = 0; column2 < numCols; column2++) {
-				int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth*column2));
-				int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight*row2));
-				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))){
+				final int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth * column2));
+				final int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight * row2));
+				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))) {
 					continue;
 				}
-				Image image2 = new Image(realWidth, realHeight);
-				int[] pixels = new int[realWidth * realHeight];
+				final Image image2 = new Image(realWidth, realHeight);
+				final int[] pixels = new int[realWidth * realHeight];
 				fullImage.getPixels(pixels, 0, tileWidth * column2, tileHeight * row2, realWidth, realHeight, 0);
 				image2.setPixels(pixels, 0, 0, 0, realWidth, realHeight, 0);
 				im = new MapImage();
@@ -1304,54 +1442,55 @@
 		}
 	}
 
-	private boolean isCoveredByBlackArea (Point mapPos, int row,int column,Rect blackArea, Dimension mapDimension){
-		int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth*column));
-		int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight*row));
-		int left = mapPos.x + column * tileWidth;
-		int right = left + realWidth;
-		int top = mapPos.y + row * tileHeight;
-		int bottom = top +realHeight;
-		if (right < blackArea.x || bottom < blackArea.y){
+	private boolean isCoveredByBlackArea(Point mapPos, int row, int column, Rect blackArea, Dimension mapDimension) {
+		final int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth * column));
+		final int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight * row));
+		final int left = mapPos.x + column * tileWidth;
+		final int right = left + realWidth;
+		final int top = mapPos.y + row * tileHeight;
+		final int bottom = top + realHeight;
+		if (right < blackArea.x || bottom < blackArea.y) {
 			return false;
 		}
-		if (left > blackArea.x + blackArea.width || top > blackArea.y + blackArea.height){
+		if (left > blackArea.x + blackArea.width || top > blackArea.y + blackArea.height) {
 			return false;
 		}
 		return true;
 	}
+
 	/*
-	private String SRect(Rect r){
-		String OL, UR ;
-		OL= " ("+String.valueOf(r.x)+","+String.valueOf(r.y)+")";
-		UR= " ("+String.valueOf(r.x+r.width)+","+String.valueOf(r.y+r.height)+") ";
-		return OL+" :"+UR;
-	}
-	*/
+	 * private String SRect(Rect r){ String OL, UR ; OL= "
+	 * ("+String.valueOf(r.x)+","+String.valueOf(r.y)+")"; UR= "
+	 * ("+String.valueOf(r.x+r.width)+","+String.valueOf(r.y+r.height)+") ";
+	 * return OL+" :"+UR; }
+	 */
 	private void calculateRectangles(Rect blackArea, Rect whiteArea, Vector rectangles) {
-		if (width == 0 || height == 0) return;
-		int offsetX = width/10;
-		int offsetY = height/10;
-		int width=this.width+offsetX;
-		int height=this.height+offsetY;
-		if (whiteArea.x >= width || whiteArea.y >= height) return;
+		if (width == 0 || height == 0)
+			return;
+		final int offsetX = width / 10;
+		final int offsetY = height / 10;
+		final int width = this.width + offsetX;
+		final int height = this.height + offsetY;
+		if (whiteArea.x >= width || whiteArea.y >= height)
+			return;
 
-		if (blackArea.x < -offsetX){
+		if (blackArea.x < -offsetX) {
 			blackArea.width += blackArea.x + offsetX;
 			blackArea.x = -offsetX;
 		}
-		if (blackArea.y < -offsetY){
+		if (blackArea.y < -offsetY) {
 			blackArea.height += blackArea.y + offsetY;
 			blackArea.y = -offsetY;
 		}
-		if (blackArea.x + blackArea.width > width){
+		if (blackArea.x + blackArea.width > width) {
 			blackArea.width = width - blackArea.x;
 		}
-		if (blackArea.y + blackArea.height > height){
+		if (blackArea.y + blackArea.height > height) {
 			blackArea.height = height - blackArea.y;
 		}
 
 		if (blackArea.x > whiteArea.x) {
-			Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = -offsetX;
 			r.y = whiteArea.y;
 			r.width = blackArea.x + offsetX;
@@ -1359,23 +1498,23 @@
 			rectangles.add(r);
 		}
 		if (blackArea.y > whiteArea.y) {
-			Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = -offsetY;
 			r.width = whiteArea.width;
 			r.height = blackArea.y + offsetY;
 			rectangles.add(r);
 		}
-		if ((blackArea.y + blackArea.height) <  whiteArea.y + whiteArea.height) {
-			Rect r= new Rect ();
+		if ((blackArea.y + blackArea.height) < whiteArea.y + whiteArea.height) {
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = blackArea.y + blackArea.height;
 			r.width = whiteArea.width;
 			r.height = (whiteArea.y + whiteArea.height) - r.y;
 			rectangles.add(r);
 		}
-		if ((blackArea.x + blackArea.width)<  whiteArea.x + whiteArea.width) {
-			Rect r= new Rect ();
+		if ((blackArea.x + blackArea.width) < whiteArea.x + whiteArea.width) {
+			final Rect r = new Rect();
 			r.x = blackArea.x + blackArea.width;
 			r.y = whiteArea.y;
 			r.width = (whiteArea.x + whiteArea.width) - r.x;
@@ -1385,18 +1524,24 @@
 	}
 
 	public void updateGps(int fix) {
-		if (!running || ignoreGps) return;
-		// runMovingMap neccessary in case of multi-threaded Java-VM: 
+		if (!running || ignoreGps)
+			return;
+		// runMovingMap neccessary in case of multi-threaded Java-VM:
 		// ticked could be called during load of mmp
-		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
-			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
-					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+		if ((fix > 0) && (myNavigation.gpsPos.getSats() >= 0)) { // TODO
+																	// is
+																	// getSats
+																	// really
+																	// necessary?
+			directionArrows.setDirections((float) myNavigation.gpsPos.getBearing(myNavigation.destination), (float) myNavigation.skyOrientationDir.lonDec, (float) myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos);
 			ShowLastAddedPoint(myNavigation.curTrack);
 		}
-		if (fix == 0 && myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
-		if (fix < 0 )	setGpsStatus(MovingMap.noGPSData);
+		if (fix == 0 && myNavigation.gpsPos.getSats() == 0)
+			setGpsStatus(MovingMap.lostFix);
+		if (fix < 0)
+			setGpsStatus(MovingMap.noGPSData);
 		controlsLayer.updateContent("hdop", Convert.toString(myNavigation.gpsPos.getHDOP()));
 		controlsLayer.updateContent("sats", Convert.toString(myNavigation.gpsPos.getSats()) + "/" + Convert.toString(myNavigation.gpsPos.getSatsInView()));
 	}
@@ -1405,81 +1550,132 @@
 		addTrack(myNavigation.curTrack);
 		ignoreGps = false;
 	}
+
 	public void gpsStoped() {
 		setGpsStatus(MovingMap.noGPS);
 	}
 
 	int mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 	float scaleWanted;
-	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
-	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	boolean wantMapTest = true; // if true updateposition calls setBestMap
+								// regulary even if the currentmap covers
+								// the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen
+														// resolution as
+														// long as a map is
+														// available that
+														// overlaps with the
+														// screen and with
+														// the PosCircle -
+														// it changes the
+														// resolution if no
+														// such map is
+														// available. It wil
+														// cahnge back to
+														// the
+	// wanted scale as soon as a map becomes available (through movement of
+	// the GPS-receiver)
 	public final static int HIGHEST_RESOLUTION = 2;
 	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
 	boolean inBestMap = false; // to avoid multi-threading problems
 
 	/**
-	 * loads the best map for lat/lon according to mapChangeModus
-	 * lat/lon will be at the screen-pos of posCircle
-	 * when posCircle is not on the screen (shifted outside my the user)
-	 * then this routine uses the centre of the screen to find the best map
-	 * but anyway the map will be adjusted (moved) relativ to posCircle
-	 * when a better map was found the called method updateposition will set
-	 * posCirleLat/-Lon to lat/lon.
-	 *
+	 * loads the best map for lat/lon according to mapChangeModus lat/lon
+	 * will be at the screen-pos of posCircle when posCircle is not on the
+	 * screen (shifted outside my the user) then this routine uses the
+	 * centre of the screen to find the best map but anyway the map will be
+	 * adjusted (moved) relativ to posCircle when a better map was found the
+	 * called method updateposition will set posCirleLat/-Lon to lat/lon.
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @param loadIfSameScale
-	 * 			false: will not change the map if the better map has the same scale as the current
-	 * 			  - this is used not to change the map if it covers already the screen completely
-	 * 			true: willchange the map, regardless of change in scale
+	 *            false: will not change the map if the better map has the
+	 *            same scale as the current - this is used not to change the
+	 *            map if it covers already the screen completely true:
+	 *            willchange the map, regardless of change in scale
 	 */
 	public void setBestMap(CWPoint where, boolean loadIfSameScale) {
-		if (inBestMap) return;
+		if (inBestMap)
+			return;
 		inBestMap = true;
-		Object [] s = getRectForMapChange(where);
-		CWPoint cll = (CWPoint) s[0];
-		Rect screen = (Rect) s[1];
-		boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
+		final Object[] s = getRectForMapChange(where);
+		final CWPoint cll = (CWPoint) s[0];
+		final Rect screen = (Rect) s[1];
+		final boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
 		MapInfoObject newmap = null;
 		wantMapTest = true;
 		switch (mapChangeModus) {
 		case NORMAL_KEEP_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, scaleWanted, false,true);
-			if (newmap == null) newmap = currentMap;
-			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			newmap = maps.getBestMap(cll, screen, scaleWanted, false, true);
+			if (newmap == null)
+				newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap))
+				wantMapTest = false;
 			break;
 		case HIGHEST_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+			newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			break;
 		case HIGHEST_RESOLUTION_GPS_DEST:
-			if (gotoPos!= null && GpsStatus != noGPS && posCircle.where.isValid()) {
-				if ( ( !posCircleOnScreen ) && ( lastHighestResolutionGPSDestScale > 0 ) ) {
-					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+			if (gotoPos != null && GpsStatus != noGPS && posCircle.where.isValid()) {
+				if ((!posCircleOnScreen) && (lastHighestResolutionGPSDestScale > 0)) {
+					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 				} else {
-					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
-					if (newmap == null)	newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false,true); // use map with most available overview if no map containing PosCircle and GotoPos is available
+					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO
+																					// use
+																					// home-coos
+																					// if
+																					// no
+																					// gps?
+																					// -
+																					// consider
+																					// start
+																					// from
+																					// details
+																					// panel
+																					// and
+																					// from
+																					// gotopanel
+					if (newmap == null)
+						newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false, true); // use
+																													// map
+																													// with
+																													// most
+																													// available
+																													// overview
+																													// if
+																													// no
+																													// map
+																													// containing
+																													// PosCircle
+																													// and
+																													// GotoPos
+																													// is
+																													// available
 
 					if (newmap != null) {
 						lastHighestResolutionGPSDestScale = newmap.scale;
 
 						if (!posCircleOnScreen) {
-							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 						}
 					}
 				}
 			}
-			//	either Goto-Pos or GPS-Pos not set
+			// either Goto-Pos or GPS-Pos not set
 			else {
 				lastHighestResolutionGPSDestScale = -1;
-				newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+				newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			}
 			break;
-		default: (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4208, "Bug: \nillegal mapChangeModus: ") + mapChangeModus, FormBase.OKB)).execute(); break;
+		default:
+			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4208, "Bug: \nillegal mapChangeModus: ") + mapChangeModus, FormBase.OKB)).execute();
+			break;
 		}
-		if ( newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
-			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+		if (newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName))) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap)) {
 				// better map found
 				setMap(newmap, where);
 				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
@@ -1489,54 +1685,94 @@
 		}
 		if (currentMap == null && newmap == null) {
 			// F?r die aktuelle Position steht keine Karte zur Verf?ng
-			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
+			posCircle.where.set(cll); // choosemap calls setmap with
+										// posCircle-coos
 			try {
-				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: "-4" only works if the empty maps were added last see MapsList.addEmptyMaps
-			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4209, "setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:") + where.toString(), FormBase.OKB)).exec(); }
-			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
+				setMap(((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware:
+																								// "-4"
+																								// only
+																								// works
+																								// if
+																								// the
+																								// empty
+																								// maps
+																								// were
+																								// added
+																								// last
+																								// see
+																								// MapsList.addEmptyMaps
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4209, "setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:") + where.toString(), FormBase.OKB)).exec();
+			}
+			while (currentMap == null) { // this actually cannot happen,
+											// but maybe in case of an
+											// inconstistent code change
+											// (esp. regarding empty maps)
 				mmp.chooseMap(); // force the user to select a scale
-				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4210, "Moving map cannot run without a map - please select one. \n You can select an empty map"), FormBase.OKB)).execute();
+				if (currentMap == null)
+					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4210, "Moving map cannot run without a map - please select one. \n You can select an empty map"), FormBase.OKB)).execute();
 			}
 		}
 		inBestMap = false;
 	}
 
-	public void setResModus (int modus) {
+	public void setResModus(int modus) {
 		scaleWanted = currentMap.scale;
-		if (mapChangeModus == modus) return;
+		if (mapChangeModus == modus)
+			return;
 		mapChangeModus = modus;
 		lastHighestResolutionGPSDestScale = -1;
 		if (modus != NORMAL_KEEP_RESOLUTION) {
 			setBestMap(posCircle.where, true);
 		}
 	}
+
 	/**
 	 * method to get a point on the screen which must be included in the map
-	 * the map methods are looking for. If the poscircle is on the screen this will be
-	 * that point. If it is outside then the centre of the screen will be used.
-	 *
-	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
+	 * the map methods are looking for. If the poscircle is on the screen
+	 * this will be that point. If it is outside then the centre of the
+	 * screen will be used.
+	 * 
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen
+	 * around it
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
 	 */
 	public Object[] getRectForMapChange(CWPoint ll) {
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
 		int pX, pY;
 		CWPoint cll;
 		Boolean posCircleOnScreen = java.lang.Boolean.FALSE;
 		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h && ll.isValid()) {
 			posCircleOnScreen = java.lang.Boolean.TRUE;
 			pX = posCircleX; // posCircle is inside the screen
-			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f???hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem
+								// evtl. Kartenwechsel PosCircle on Screen
+								// ist. So wie es jetzt ist, kann 2mal der
+								// gleiche Aufruf zum laden
+								// unterschiedlicher Karten f???hren, wenn
+								// vorher PosCircle nicht auf dem
+			// SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
-		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
-			cll = ScreenXY2LatLon(w/2, h/2);
-			pX = w/2;
-			pY = h/2;
+		} else { // when posCircle out of screen - use centre of screen
+					// as point which as to be included in the map
+			cll = ScreenXY2LatLon(w / 2, h / 2);
+			pX = w / 2;
+			pY = h / 2;
 		}
-		Object[] ret = new Object[3];
+		final Object[] ret = new Object[3];
 		ret[0] = cll;
 		ret[1] = new Rect(pX, pY, w, h);
 		ret[2] = posCircleOnScreen;
@@ -1544,25 +1780,35 @@
 	}
 
 	/**
-	 *
-	 * @param betterOverview true: getmap with better overview
+	 * 
+	 * @param betterOverview
+	 *            true: getmap with better overview
 	 * @return
 	 */
-	public void loadMoreDetailedMap(boolean betterOverview){
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
-		Rect screen = new Rect(w/2, h/2, w, h);
+	public void loadMoreDetailedMap(boolean betterOverview) {
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
+		final Rect screen = new Rect(w / 2, h / 2, w, h);
 
 		CWPoint cll;
 		if (currentMap != null) {
-			cll = ScreenXY2LatLon(w/2, h/2);
+			cll = ScreenXY2LatLon(w / 2, h / 2);
 		} else {
 			cll = new CWPoint(posCircle.where);
 		}
 
-		MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale * currentMap.zoomFactor, !betterOverview);
+		final MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale * currentMap.zoomFactor, !betterOverview);
 		if (m != null) {
-			boolean saveGpsIgnStatus = dontUpdatePos;
+			final boolean saveGpsIgnStatus = dontUpdatePos;
 			dontUpdatePos = true;
 			setMap(m, cll);
 			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
@@ -1570,57 +1816,103 @@
 				fillWhiteArea(true);
 			}
 			dontUpdatePos = saveGpsIgnStatus;
-		}
-		else (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4211, "No ") +
-				(betterOverview ? MyLocale.getMsg(4212, "less") : MyLocale.getMsg(4213, "more") ) +
-				MyLocale.getMsg(4214, " detailed map available"),
-				FormBase.OKB)).execute();
+		} else
+			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4211, "No ") + (betterOverview ? MyLocale.getMsg(4212, "less") : MyLocale.getMsg(4213, "more")) + MyLocale.getMsg(4214, " detailed map available"), FormBase.OKB)).execute();
 	}
 
-	public void loadMapForAllCaches(){
-		Area sur = Global.getProfile().getSourroundingArea(true);
+	public void loadMapForAllCaches() {
+		final Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
 			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4215, "Keine  Caches mit H???ckchen ausgew???hlt"), FormBase.OKB)).execute();
 			return;
 		}
-		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
-		if (newmap == null ) { // no map that includs all caches is available -> load map with lowest resolution
-			Object [] s = getRectForMapChange(posCircle.where);
-			CWPoint cll = (CWPoint) s[0];
-			Rect screen = (Rect) s[1];
-			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false,true);
+		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.bottomright);
+		if (newmap == null) { // no map that includs all caches is
+								// available -> load map with lowest
+								// resolution
+			final Object[] s = getRectForMapChange(posCircle.where);
+			final CWPoint cll = (CWPoint) s[0];
+			final Rect screen = (Rect) s[1];
+			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE - 1, false, true);
 		}
-		if (newmap == null) { // no map is covering any area of the caches -> zoom an empty map to cover all caches on screen
+		if (newmap == null) { // no map is covering any area of the caches
+								// -> zoom an empty map to cover all caches
+								// on screen
 			try {
-				Object [] s = getRectForMapChange(posCircle.where);
-			//	CWPoint cll = (CWPoint) s[0];
-				Rect screen = (Rect) s[1];
-				float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.buttomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
-				float neededscaley = (float) (sur.topleft.getDistance(sur.buttomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
-				newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(); // beware: "-4" only works if the empty maps were added last see MapsList.addEmptyMaps
+				final Object[] s = getRectForMapChange(posCircle.where);
+				// CWPoint cll = (CWPoint) s[0];
+				final Rect screen = (Rect) s[1];
+				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width - 15)); // 15
+																																						// for
+																																						// the
+																																						// size
+																																						// of
+																																						// the
+																																						// cache
+																																						// image
+				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height - 15)); // 15
+																																						// for
+																																						// the
+																																						// size
+																																						// of
+																																						// the
+																																						// cache
+																																						// image
+				newmap = ((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(); // beware:
+																						// "-4"
+																						// only
+																						// works
+																						// if
+																						// the
+																						// empty
+																						// maps
+																						// were
+																						// added
+																						// last
+																						// see
+																						// MapsList.addEmptyMaps
 				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex > neededscaley ? neededscalex : neededscaley), 0, 0);
 				forceMapLoad = true;
-			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4279, "loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();"), FormBase.OKB)).exec(); }
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4279, "loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();"), FormBase.OKB)).exec();
+			}
 		}
-		boolean saveGpsIgnStatus = dontUpdatePos;
+		final boolean saveGpsIgnStatus = dontUpdatePos;
 		dontUpdatePos = true;
 		setMap(newmap, posCircle.where);
 		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 		dontUpdatePos = saveGpsIgnStatus;
 	}
 
-	public void setGpsStatus (int status) {
-		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+	public void setGpsStatus(int status) {
+		if (status == GpsStatus)
+			return; // if ignoreGpsStatutsChanges == true than the Map is in
+					// manual-mode
 		GpsStatus = status;
 		dontUpdatePos = false;
 		ignoreGps = false;
 		switch (status) {
-		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		case noGPS: {
+			posCircle.change(null);
+			ignoreGps = true;
+			break;
 		}
-		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
+		case gotFix: {
+			posCircle.change(statusImageHaveSignal);
+			break;
+		}
+		case lostFix: {
+			posCircle.change(statusImageNoSignal);
+			break;
+		}
+		case noGPSData: {
+			posCircle.change(statusImageNoGps);
+			break;
+		}
+		}
+		mapMoved(0, 0); // positions the posCircle correctly accourding to
+						// its size (which can change when the image
+						// changes, e.g. from null to something else
 		posCircle.refreshNow();
 	}
 
@@ -1628,122 +1920,147 @@
 		resetCenterOfMap();
 		dontUpdatePos = false;
 		ignoreGps = false;
-		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make
+											// updateposition to test if the
+											// current map is the best one
+											// for the GPS-Position
 		lastCompareY = Integer.MAX_VALUE;
 		autoSelectMap = true;
 		forceMapLoad = true;
 		// showMap(); why this?
-		if (myNavigation.gpsPos.Fix <=0) updatePosition(posCircle.where);
-		else updateGps(myNavigation.gpsPos.getFix());
+		if (myNavigation.gpsPos.Fix <= 0)
+			updatePosition(posCircle.where);
+		else
+			updateGps(myNavigation.gpsPos.getFix());
 	}
 
-	/** sets and displays the map
-	 *
+	/**
+	 * sets and displays the map
+	 * 
 	 * @param newmap
-	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
-	 * @param lon -361: don't adust to lat/lon
+	 * @param lat
+	 *            move map so that lat/lon is in the centre / -361: don't
+	 *            adust to lat/lon
+	 * @param lon
+	 *            -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, CWPoint where) {
 		if (currentMap != null && newmap.mapName.equals(currentMap.mapName) && !forceMapLoad) {
 			updateOnlyPosition(where, true);
 			return;
 		}
-		try {			
+		try {
 			Vm.showWait(true);
 			boolean saveIgnoreStatus;
 			saveIgnoreStatus = dontUpdatePos;
-			dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
-			pref.log(MyLocale.getMsg(4216, "Loading map...")+newmap.mapName);
+			dontUpdatePos = true; // make updatePosition ignore calls
+									// during loading new map
+			pref.log(MyLocale.getMsg(4216, "Loading map...") + newmap.mapName);
 			try {
 				this.currentMap = newmap;
 				this.title = currentMap.mapName;
-				// neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-				lastCompareX = Integer.MAX_VALUE; 
+				// neccessary to make updateposition to test if the current
+				// map is the best one for the GPS-Position
+				lastCompareX = Integer.MAX_VALUE;
 				lastCompareY = Integer.MAX_VALUE;
-				if (mmp.mapImage != null ) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free(); 
-					mmp.mapImage = null; 
+				if (mmp.mapImage != null) {
+					mmp.removeImage(mmp.mapImage);
+					mmp.mapImage.free();
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 					// calls the garbage collection
-					Vm.getUsedMemory(true); 
-				} 
-				// give memory free before loading the new map to avoid out of memory error
-				String ImageFilename = currentMap.getImageFilename();
-				if (ImageFilename == null ) {
+					Vm.getUsedMemory(true);
+				}
+				// give memory free before loading the new map to avoid out
+				// of memory error
+				final String ImageFilename = currentMap.getImageFilename();
+				if (ImageFilename == null) {
 					mmp.mapImage = new MapImage();
 					maps.remove(currentMap);
-					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n")+currentMap.fileNameWFL, FormBase.OKB)).execute();
-				}
-				else {
+					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n") + currentMap.fileNameWFL, FormBase.OKB)).execute();
+				} else {
 					if (ImageFilename.length() > 0) {
 						// attention: when running in native java-vm,
-						// no exception will be thrown, not even OutOfMemeoryError
-						mmp.mapImage = new MapImage(ImageFilename); 
-					}
-					else mmp.mapImage = new MapImage(); // no image associated with the calibration info ("empty map")
+						// no exception will be thrown, not even
+						// OutOfMemeoryError
+						mmp.mapImage = new MapImage(ImageFilename);
+					} else
+						mmp.mapImage = new MapImage(); // no image
+														// associated with
+														// the calibration
+														// info ("empty
+														// map")
 				}
 				mapImage1to1 = mmp.mapImage;
 				mmp.mapImage.properties = mmp.mapImage.properties | mImage.IsMoveable;
-				if (mapHidden) mmp.mapImage.hide();
-				mmp.mapImage.move(0,0);
+				if (mapHidden)
+					mmp.mapImage.hide();
+				mmp.mapImage.move(0, 0);
 				mmp.addImage(mmp.mapImage);
 				mmp.images.moveToBack(mmp.mapImage);
 				rebuildOverlaySet();
-				forceMapLoad = true; // forces updateOnlyPosition to redraw
+				forceMapLoad = true; // forces updateOnlyPosition to
+										// redraw
 				updateAfterMapChange(where);
 				forceMapLoad = false;
 				directionArrows.setMap(currentMap);
 				updateScale();
-				// this doesn't work in a ticked-thread in the ewe-vm. 
+				// this doesn't work in a ticked-thread in the ewe-vm.
 				// That's why i made a new mThread in gotoPanel for ticked
 				dontUpdatePos = saveIgnoreStatus;
-			} catch (IllegalArgumentException e) { 
+			} catch (final IllegalArgumentException e) {
 				// thrown by new AniImage() in ewe-vm if file not found;
-				pref.log("[MovingMap:setMap]IllegalArgumentException",e,true);
+				pref.log("[MovingMap:setMap]IllegalArgumentException", e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4218, "Could not load map: \n")+ newmap.getImageFilename(), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4218, "Could not load map: \n") + newmap.getImageFilename(), FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
-			} catch (OutOfMemoryError e) {
-				pref.log("[MovingMap:setMap]OutOfMemoryError",e,true);
+			} catch (final OutOfMemoryError e) {
+				pref.log("[MovingMap:setMap]OutOfMemoryError", e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4219, "Not enough memory to load map: \n")
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4219, "Not enough memory to load map: \n") + newmap.getImageFilename() + MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"), FormBase.OKB))
+						.execute();
 				dontUpdatePos = saveIgnoreStatus;
-			}catch (SystemResourceException e) {
-				pref.log("[MovingMap:setMap]SystemResourceException",e,true);
+			} catch (final SystemResourceException e) {
+				pref.log("[MovingMap:setMap]SystemResourceException", e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
-				updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually
-				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4221, "Not enough ressources to load map: ")
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"),
+				updateOnlyPosition(where, false); // TODO this doesn't
+													// work correctly if the
+													// resolution changed, I
+													// guess because the
+													// pixels of PosCircle
+													// will be interpreted
+													// from the new
+													// resolution, but
+													// should be interpreted
+													// using the old
+													// resolution to
+				// test: select a map with a much greater value of m per
+				// pixel manually
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4221, "Not enough ressources to load map: ") + newmap.getImageFilename() + MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"),
 						FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
 			}
-		}
-		finally{
+		} finally {
 			Vm.showWait(false);
 		}
 	}
@@ -1752,21 +2069,31 @@
 		if (!posCircle.where.isValid()) {
 			posCircle.where.set(newCenter);
 		}
-		Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
-		Point centerOnMap = currentMap.calcMapXY(newCenter);
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
-		int mapPosX = w/2 - centerOnMap.x;
-		int mapPosY = h/2 - centerOnMap.y;
-		int newPosCircleX = mapPosX + circlePosOnMap.x;
-		int newPosCircleY = mapPosY + circlePosOnMap.y;
+		final Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
+		final Point centerOnMap = currentMap.calcMapXY(newCenter);
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
+		final int mapPosX = w / 2 - centerOnMap.x;
+		final int mapPosY = h / 2 - centerOnMap.y;
+		final int newPosCircleX = mapPosX + circlePosOnMap.x;
+		final int newPosCircleY = mapPosY + circlePosOnMap.y;
 
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.move(mapPosX, mapPosY);
 
-		int wCircle = posCircle.getWidth();
-		int hCircle = posCircle.getHeight();
-		int npx = newPosCircleX-wCircle/2;
-		int npy = newPosCircleY-hCircle/2;
+		final int wCircle = posCircle.getWidth();
+		final int hCircle = posCircle.getHeight();
+		final int npx = newPosCircleX - wCircle / 2;
+		final int npy = newPosCircleY - hCircle / 2;
 		posCircle.move(npx, npy);
 		posCircleX = newPosCircleX;
 		posCircleY = newPosCircleY;
@@ -1777,9 +2104,9 @@
 	public void hideMap() {
 		if (mmp != null && mmp.mapImage != null)
 			mmp.mapImage.hide();
-		for(Iterator i=mmp.images.iterator(); i.hasNext ();){
-			AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
+			final AniImage image = (AniImage) i.next();
+			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)) {
 				((MapImage) image).hide();
 			}
 		}
@@ -1788,63 +2115,86 @@
 	}
 
 	public void showMap() {
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.unhide();
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.unhide();
 		mapHidden = false;
-		for(Iterator i=mmp.images.iterator(); i.hasNext ();){
-			AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
+			final AniImage image = (AniImage) i.next();
+			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)) {
 				((MapImage) image).unhide();
 			}
 		}
 		repaintNow();
 	}
-/*
-	public void setZoomingMode() {
-		repaintNow();
-		zoomingMode = true;
-	}
-*/
+
+	/*
+	 * public void setZoomingMode() { repaintNow(); zoomingMode = true; }
+	 */
 	/**
 	 * zommes in if w>0 and out if w<0
+	 * 
 	 * @param firstclickpoint
 	 * @param w
 	 * @param h
 	 */
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
-		int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
-		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		int newImageWidth = (int) (this.width * (this.width < 481 ? 2 : 1.6)); // (maximal)
+																				// size
+																				// of
+																				// the
+																				// zoomed
+																				// image
+		int newImageHeight = (int) (this.height * (this.width < 481 ? 2 : 1.6)); // dont
+																					// make
+																					// this
+																					// to
+																					// big,
+																					// otherwise
+																					// it
+																					// causes
+																					// out
+																					// of
+																					// memory
+																					// errors
+		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w / 2, firstclickpoint.y + h / 2);
 		float zoomFactor;
 		if (h < 0) {
 			h = java.lang.Math.abs(h);
 			firstclickpoint.y = firstclickpoint.y - h;
 		}
 		if (w > 0) { // zoom in
-			zoomFactor = java.lang.Math.min((float)this.width / (float)w, (float)this.height / (float)h);
-		}
-		else { // zoom out
+			zoomFactor = java.lang.Math.min((float) this.width / (float) w, (float) this.height / (float) h);
+		} else { // zoom out
 			w = java.lang.Math.abs(w);
-			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
-			zoomFactor = java.lang.Math.max((float)w / (float)this.width, (float)h / (float)this.height);
+			firstclickpoint.x = firstclickpoint.x - w; // make
+														// firstclickedpoint
+														// the upper left
+														// corner
+			zoomFactor = java.lang.Math.max((float) w / (float) this.width, (float) h / (float) this.height);
 		}
-		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
+		// calculate rect in unzoomed image in a way that the centre of the
+		// new image is the centre of selected area but give priority to the
+		// prefered image size of the scaled image
 		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
-		Point mappos = getMapPositionOnScreen();
-		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
-		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-		{
+		final Point mappos = getMapPositionOnScreen();
+		final int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w / 2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth / 2);
+		final int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h / 2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight / 2);
+		final Rect newImageRect = new Rect(xinunscaledimage, yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null) {
 			// try to avoid overlapping by shifting
 			if (newImageRect.x < 0)
 				newImageRect.x = 0; // align left if left overlapping
 			if (newImageRect.y < 0)
 				newImageRect.y = 0;
 			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth())
-				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+				newImageRect.x = mapImage1to1.getWidth() - newImageWidth; // align
+																			// right
+																			// if
+																			// right
+																			// overlaping
 			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight())
-				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+				newImageRect.y = mapImage1to1.getHeight() - newImageHeight;
 			// crop if after shifting still overlapping
 			if (newImageRect.x < 0)
 				newImageRect.x = 0;
@@ -1853,25 +2203,23 @@
 			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth())
 				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
 			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight())
-				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+				newImageRect.height = mapImage1to1.getHeight() - newImageRect.y;
 		}
 		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
 	}
 
 	public void zoomin() {
-		zoomScreenRect(new Point(this.width / 4, this.height / 4),
-				this.width / 2, this.height / 2);
+		zoomScreenRect(new Point(this.width / 4, this.height / 4), this.width / 2, this.height / 2);
 	}
 
 	public void zoomout() {
-		CWPoint center = currentMap.center;
+		final CWPoint center = currentMap.center;
 		float zoomfactor = currentMap.zoomFactor / 2;
 		if (zoomfactor < 1) {
 			zoomfactor = 1;
 		}
 		if (mapImage1to1 != null)
-			zoomFromUnscaled(zoomfactor, new Rect(0, 0,
-					mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+			zoomFromUnscaled(zoomfactor, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
 		else
 			zoomFromUnscaled(zoomfactor, new Rect(0, 0, 1, 1), center);
 	}
@@ -1881,20 +2229,26 @@
 	}
 
 	public void zoom1to1() {
-		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+		final CWPoint center = ScreenXY2LatLon(this.width / 2, this.height / 2);
+		if (mapImage1to1 != null)
+			zoomFromUnscaled(1, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else
+			zoomFromUnscaled(1, new Rect(0, 0, 1, 1), center);
 	}
 
 	/**
 	 * do the actual scaling
-	 * @param zoomFactor relative to original image
-	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * 
+	 * @param zoomFactor
+	 *            relative to original image
+	 * @param newImageRect
+	 *            Rect in the 1:1 image that contains the area to be zoomed
+	 *            into
 	 * @param center
 	 */
-	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+	public void zoomFromUnscaled(float zoomFactor, Rect newImageRect, CWPoint center) {
 		Vm.showWait(this, true);
-		boolean savegpsstatus = dontUpdatePos;
+		final boolean savegpsstatus = dontUpdatePos;
 		if (mapImage1to1 != null) {
 			dontUpdatePos = true; // avoid multi-thread problems
 			int saveprop = mImage.IsMoveable;
@@ -1906,32 +2260,38 @@
 				if (mmp.mapImage != mapImage1to1) {
 					mmp.mapImage.free();
 					mmp.mapImage = null;
-				} else tmp = mapImage1to1;
+				} else
+					tmp = mapImage1to1;
 			}
 			Vm.getUsedMemory(true);
 			try {
-				if (zoomFactor == 1) tmp = mapImage1to1;
-				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				if (zoomFactor == 1)
+					tmp = mapImage1to1;
+				else
+					tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width * zoomFactor), (int) (newImageRect.height * zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-			} catch (OutOfMemoryError e) {
-				(new MessageBox(MyLocale.getMsg(4207, "Error"),
-						MyLocale.getMsg(4222, "Out of memory error"), FormBase.OKB)).execute();
-				//tmp = mapImage1to1;
-			} //if (tmp != null) currentMap.zoom();}
+			} catch (final OutOfMemoryError e) {
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4222, "Out of memory error"), FormBase.OKB)).execute();
+				// tmp = mapImage1to1;
+			} // if (tmp != null) currentMap.zoom();}
 			Vm.getUsedMemory(true);
-			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage = tmp; // use unscaled or no image in case of
+								// OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
-			if (mapHidden) mmp.mapImage.hide();
+			if (mapHidden)
+				mmp.mapImage.hide();
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
-			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-			{
-				Point mappos = getMapPositionOnScreen();
-				mmp.mapImage.move(mappos.x,mappos.y);
+			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null) {
+				final Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x, mappos.y);
 			}
 		} else // no map image loaded
-		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
-		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
+		{
+			currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+		}
+		// scaleWanted = currentMap.scale; use this if you want to change
+		// automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
 		Vm.getUsedMemory(true); // call garbage collection
 		setCenterOfScreen(center, false);
@@ -1942,15 +2302,14 @@
 		dontUpdatePos = savegpsstatus;
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
+	public void onEvent(Event ev) {
+		if (ev instanceof FormEvent && (ev.type == FormEvent.CLOSED)) {
 			running = false;
 		}
-		if( ev instanceof KeyEvent &&
-			ev.target == this &&
-			( (((KeyEvent)ev).key == IKeys.ESCAPE) ||
-			  (((KeyEvent)ev).key == IKeys.ENTER) ||
-			  (((KeyEvent)ev).key == IKeys.ACTION) ) ) {
+		if (ev instanceof KeyEvent && ev.target == this && //
+				((((KeyEvent) ev).key == IKeys.ESCAPE) || //
+						(((KeyEvent) ev).key == IKeys.ENTER) || //
+				(((KeyEvent) ev).key == IKeys.ACTION))) {
 			this.close(0);
 			ev.consumed = true;
 		}
@@ -1958,21 +2317,21 @@
 	}
 
 	public boolean handleCommand(int actionCommand) {
-		if (CLOSE == actionCommand) {			
-			WindowEvent tmp = new WindowEvent();
+		if (CLOSE == actionCommand) {
+			final WindowEvent tmp = new WindowEvent();
 			tmp.type = WindowEvent.CLOSE;
 			postEvent(tmp);
 			return true;
-		} 
+		}
 		if (SELECT_MAP == actionCommand) {
 			mmp.chooseMap();
 			return true;
 		}
 		if (CHANGE_MAP_DIR == actionCommand) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
+			final FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 			fc.addMask("*.wfl");
-			fc.setTitle(MyLocale.getMsg(4200,"Select map directory:"));
-			if(fc.execute() != FormBase.IDCANCEL){
+			fc.setTitle(MyLocale.getMsg(4200, "Select map directory:"));
+			if (fc.execute() != FormBase.IDCANCEL) {
 				Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
 				loadMaps(Global.getPref().getCustomMapsPath(), posCircle.where.latDec);
 				forceMapLoad();
@@ -1981,27 +2340,27 @@
 		}
 		if (FILL_MAP == actionCommand) {
 			setFillWhiteArea(true);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (NO_FILL_MAP == actionCommand) {
 			setFillWhiteArea(false);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (SHOW_CACHES == actionCommand) {
 			setShowCachesOnMap(true);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (HIDE_CACHES == actionCommand) {
 			setShowCachesOnMap(false);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
@@ -2042,7 +2401,7 @@
 			return true;
 		}
 		if (MOVE_TO_DEST == actionCommand) {
-			if (gotoPos!=null) {
+			if (gotoPos != null) {
 				setCenterOfScreen(gotoPos.where, true);
 			}
 			return true;
@@ -2075,22 +2434,20 @@
 		return mapHidden;
 	}
 
-	
 	public void setPaintPosDestLine(boolean paintPosDestLine) {
 		this.paintPosDestLine = paintPosDestLine;
 	}
-	
-	
+
 }
 
 /**
- *	Class to display the map bitmap and to select another bitmap to display.
+ * Class to display the map bitmap and to select another bitmap to display.
  */
 class MovingMapPanel extends InteractivePanel implements EventListener {
 	Menu kontextMenu;
 	MenuItem gotoMenuItem = new MenuItem(MyLocale.getMsg(4230, "Goto here$g"), 0, null);
 	MenuItem newWayPointMenuItem = new MenuItem(MyLocale.getMsg(4232, "Create new Waypoint here$n"), 0, null);;
-	MenuItem openCacheDescMenuItem,openCacheDetailMenuItem,addCachetoListMenuItem,gotoCacheMenuItem,hintMenuItem,missionMenuItem;
+	MenuItem openCacheDescMenuItem, openCacheDetailMenuItem, addCachetoListMenuItem, gotoCacheMenuItem, markFoundMenuItem, hintMenuItem, missionMenuItem;
 
 	MenuItem miLuminary[];
 
@@ -2100,47 +2457,53 @@
 	Point saveMapLoc = null;
 	boolean saveGpsIgnoreStatus;
 	boolean paintingZoomArea;
-	
+
 	ImageList saveImageList = null;
-	int lastZoomWidth , lastZoomHeight;
-	
-	boolean ignoreNextDrag=false;
-	boolean onlyIfCache=false;
-	
-	public MovingMapPanel(MovingMap f){
+	int lastZoomWidth, lastZoomHeight;
+
+	boolean ignoreNextDrag = false;
+	boolean onlyIfCache = false;
+
+	public MovingMapPanel(MovingMap f) {
 		this.mm = f;
 		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
-		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i < SkyOrientation.LUMINARY_NAMES.length; i++) {
 			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
 		}
-		set(ControlConstants.WantHoldDown, true); // want to get simulated right-clicks
+		set(ControlConstants.WantHoldDown, true); // want to get simulated
+													// right-clicks
 	}
 
-	public boolean imageBeginDragged(AniImage which,Point pos) {
+	public boolean imageBeginDragged(AniImage which, Point pos) {
 		if (mm.zoomingMode == true) { // zoom
-//			saveMapLoc = pos;
-			//		saveGpsIgnoreStatus = mm.ignoreGps;
-			//	mm.ignoreGps = true;
+			// saveMapLoc = pos;
+			// saveGpsIgnoreStatus = mm.ignoreGps;
+			// mm.ignoreGps = true;
 			return false;
 		}
 		if (mm.getControlsLayer().imageBeginDragged(which, pos)) {
 			return false;
-		}			
+		}
 		// move (drag) map
-		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		// if (!(which == null || which == mapImage || which instanceof
+		// TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.dontUpdatePos;
 		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
-		else return super.imageBeginDragged(null, pos);
+		if (mapImage.isOnScreen() && !mapImage.hidden)
+			return super.imageBeginDragged(mapImage, pos);
+		else
+			return super.imageBeginDragged(null, pos);
 	}
 
-	public boolean imageNotDragged(ImageDragContext dc,Point pos){
-		boolean ret = super.imageNotDragged(dc, pos);
+	public boolean imageNotDragged(ImageDragContext dc, Point pos) {
+		final boolean ret = super.imageNotDragged(dc, pos);
 		bringMaptoBack();
-		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		if (dc.image == null)
+			moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else
+			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 		mm.dontUpdatePos = saveGpsIgnoreStatus;
 		this.repaintNow();
 		return ret;
@@ -2148,66 +2511,82 @@
 
 	public void onPenEvent(PenEvent ev) {
 		if (ignoreNextDrag) {
-			// On PDA next event after a Kontext ist a drag, that will move the map unwanted
-			ignoreNextDrag=false;
-			if (ev.type == PenEvent.PEN_DRAG) return; // ignoring now
+			// On PDA next event after a Kontext ist a drag, that will move
+			// the map unwanted
+			ignoreNextDrag = false;
+			if (ev.type == PenEvent.PEN_DRAG)
+				return; // ignoring now
 		}
 		if (ev.type == PenEvent.PEN_DOWN) {
 			if (mm.zoomingMode) {
 				saveGpsIgnoreStatus = mm.dontUpdatePos;
 				mm.dontUpdatePos = true;
-				saveMapLoc = new Point (ev.x, ev.y);
+				saveMapLoc = new Point(ev.x, ev.y);
 				paintingZoomArea = true;
 				mm.zoomingMode = true;
-			}
-			else {
-				saveMapLoc = new Point (ev.x, ev.y);
+			} else {
+				saveMapLoc = new Point(ev.x, ev.y);
 				if (ev.modifiers == PenEvent.RIGHT_BUTTON) {
-					// context penHeld is fired directly on PDA (cause WantHoldDown Control Modifier)
+					// context penHeld is fired directly on PDA (cause
+					// WantHoldDown Control Modifier)
 					// but not on PC (Java) , therefor it is here
-					penHeld(new Point (ev.x, ev.y));
-				}
-				else {
+					penHeld(new Point(ev.x, ev.y));
+				} else {
 					// do it even on left klick
-					onlyIfCache=true;
-					penHeld(new Point (ev.x, ev.y));
+					onlyIfCache = true;
+					penHeld(new Point(ev.x, ev.y));
 				}
 			}
-		}
-		else {
+		} else {
 			if (mm.zoomingMode) {
-				if ( ev.type == PenEvent.PEN_UP ) {
+				if (ev.type == PenEvent.PEN_UP) {
 					paintingZoomArea = false;
 					mm.zoomingMode = false;
 					mm.getControlsLayer().changeRoleState("zoom_manually", false);
 					mm.dontUpdatePos = saveGpsIgnoreStatus;
-					if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
+					if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15) {
 						repaintNow();
-						return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+						return; // dont make to big zoom jumps - it is most
+								// probable not an intentional zoom
 					}
 					mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 				}
-				if (paintingZoomArea && 
-					(ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+				if (paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
 					int left, top;
-					Graphics dr = this.getGraphics();
-					if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
+					final Graphics dr = this.getGraphics();
+					if (lastZoomWidth < 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight < 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
 					left -= 2;
 					top -= 2;
-					if (top < 0) top = 0;
-					if (left < 0) left = 0;
-					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+					if (top < 0)
+						top = 0;
+					if (left < 0)
+						left = 0;
+					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth) + 4, java.lang.Math.abs(lastZoomHeight) + 4));
 					lastZoomWidth = ev.x - saveMapLoc.x;
-					lastZoomHeight =  ev.y - saveMapLoc.y;
-					if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
-					dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
-					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
+					lastZoomHeight = ev.y - saveMapLoc.y;
+					if (lastZoomWidth < 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight < 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
+					dr.setPen(new Pen(new Color(255, 0, 0), Pen.SOLID, 3));
+					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug
+																														// in
+																														// ewe:
+																														// thickness
+																														// parameter
+																														// is
+																														// ignored
 				}
 			}
 		}
@@ -2224,31 +2603,35 @@
 		images.removeAllElements();
 		images.add(mapImage);
 	}
+
 	private void bringMaptoBack() {
-		if (saveImageList == null) return;
+		if (saveImageList == null)
+			return;
 		images = saveImageList;
 		saveImageList = null;
 	}
 
 	public void moveMap(int diffX, int diffY) {
 		Point p = new Point();
-		if (mapImage!= null) {
+		if (mapImage != null) {
 			p = mapImage.locAlways;
-			mapImage.move(p.x+diffX,p.y+diffY);
-			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+			mapImage.move(p.x + diffX, p.y + diffY);
+			// if (mm.mapHidden) mapImage.properties |=
+			// AniImage.IsInvisible; // this is neccesarry because move will
+			// unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
 
-	public void mapMoved(int diffX, int diffY){
+	public void mapMoved(int diffX, int diffY) {
 		mm.mapMoved(diffX, diffY);
 		this.repaintNow();
 	}
 
-	public void doPaint(Graphics g,Rect area) {
+	public void doPaint(Graphics g, Rect area) {
 		super.doPaint(g, area);
 		if (mm.gotoPos != null && mm.paintPosDestLine) {
-			Point dest = mm.getXYonScreen(mm.gotoPos.where);
+			final Point dest = mm.getXYonScreen(mm.gotoPos.where);
 			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
 		}
@@ -2256,12 +2639,14 @@
 
 	public void chooseMap() {
 		CWPoint gpspos;
-		if (mm.myNavigation.gpsPos.Fix > 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
-		else gpspos = null;
-		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
-		if(l.execute() == FormBase.IDOK){
+		if (mm.myNavigation.gpsPos.Fix > 0)
+			gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else
+			gpspos = null;
+		final ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
+		if (l.execute() == FormBase.IDOK) {
 			mm.autoSelectMap = false;
-			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length()==0) {
+			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length() == 0) {
 				mm.setMap(l.selectedMap, mm.posCircle.where);
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.ignoreGps = false;
@@ -2270,26 +2655,35 @@
 				mm.ignoreGps = true;
 				mm.setMap(l.selectedMap, mm.posCircle.where);
 				if (mm.currentMap.fileNameWFL.length() > 0)
-					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if
+																		// map
+																		// has
+																		// an
+																		// image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
-				//mm.posCircleX = 0; // place map to the upper left corner of windows
-				//mm.posCircleY = 0;
-				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+				// Point posCXY = new Point (0,0);
+				// mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				// double lat = mm.currentMap.affine[0]*posCXY.x +
+				// mm.currentMap.affine[2]*posCXY.y +
+				// mm.currentMap.affine[4];
+				// mm.posCircleX = 0; // place map to the upper left corner
+				// of windows
+				// mm.posCircleY = 0;
+				// mm.updateOnlyPosition(mm.currentMap.affine[4],
+				// mm.currentMap.affine[5], true);
 			}
 		}
 	}
 
 	/**
-	 *	Method to react to user.
+	 * Method to react to user.
 	 */
-	public void imageClicked(AniImage which, Point pos){
+	public void imageClicked(AniImage which, Point pos) {
 		mm.getControlsLayer().imageClicked(which);
 	}
 
-	public void penHeld(Point p){
-		ignoreNextDrag=true;
+	public void penHeld(Point p) {
+		ignoreNextDrag = true;
 		if (!mm.zoomingMode) {
 			kontextMenu = new Menu();
 			if (!onlyIfCache) {
@@ -2297,123 +2691,160 @@
 				kontextMenu.addItem(newWayPointMenuItem);
 				kontextMenu.addItem(new MenuItem("-"));
 			}
-			AniImage clickedOnImage = images.findHotImage(p);
+			final AniImage clickedOnImage = images.findHotImage(p);
 			if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
-				if ( ((MapSymbol)clickedOnImage).mapObject instanceof CacheHolder) {
-					clickedCache = (CacheHolder)( ((MapSymbol)clickedOnImage).mapObject);
-					// clickedCache == null can happen if clicked on the goto-symbol
+				if (((MapSymbol) clickedOnImage).mapObject instanceof CacheHolder) {
+					clickedCache = (CacheHolder) (((MapSymbol) clickedOnImage).mapObject);
+					// clickedCache == null can happen if clicked on the
+					// goto-symbol
 					if (clickedCache != null) {
-						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, "Open Desctiption")+" '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$o");
+						CacheHolder ch = clickedCache;
+						if (clickedCache.isAddiWpt()) {
+							ch = clickedCache.mainCache;
+						}
+						if (ch != null) {
+							kontextMenu.addItem(new MenuItem(ch.getWayPoint() + " '" + ch.getCacheName() + "'"));
+							if (!ch.isCustomWpt()) {
+								kontextMenu.addItem(new MenuItem( //
+										CacheSize.cw2ExportString(ch.getCacheSize()) + //
+												" D: " + CacheTerrDiff.longDT(ch.getHard()) + //
+												" T: " + CacheTerrDiff.longDT(ch.getTerrain()) + //
+												""));
+								kontextMenu.addItem(new MenuItem( //
+										"" + ch.getCacheOwner() + //
+												" " + ch.getDateHidden() + //
+												""));
+							}
+						}
+						if (clickedCache.isAddiWpt()) {
+							kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint() + " '" + clickedCache.getCacheName() + "'"));
+						}
+						kontextMenu.addItem(new MenuItem("-"));
+						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, "Open Desctiption") + "$o");
 						kontextMenu.addItem(openCacheDescMenuItem);
-						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, "Open Details")+" '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$e");
+						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, "Open Details") + "$e");
 						kontextMenu.addItem(openCacheDetailMenuItem);
-						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, "Goto")+ " '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$g"); 
+						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, "Goto") + "$g");
 						kontextMenu.addItem(gotoCacheMenuItem);
+						if (!clickedCache.is_found()) {
+							int msgNr = 318; // normal found
+							if (clickedCache.getType() == CacheType.CW_TYPE_WEBCAM) {
+								msgNr = 361;
+							} else if (clickedCache.getType() == CacheType.CW_TYPE_EVENT || clickedCache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+								msgNr = 355;
+							}
+							markFoundMenuItem = new MenuItem(MyLocale.getMsg(msgNr, "Found") + "$m");
+							kontextMenu.addItem(markFoundMenuItem);
+						}
 						if (Global.mainForm.cacheListVisible) {
-							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
+							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199, "Add to cachetour"));
 							kontextMenu.addItem(addCachetoListMenuItem);
 						}
-						String stmp=clickedCache.getCacheDetails(false).Hints;
-						stmp=stmp.substring(0,Math.min(10,stmp.length())).trim();
-						if (!stmp.equals("")){
-							kontextMenu.addItem(hintMenuItem=new MenuItem("Hint: "+stmp));
+						String stmp = clickedCache.getCacheDetails(false).Hints;
+						stmp = stmp.substring(0, Math.min(10, stmp.length())).trim();
+						if (!stmp.equals("")) {
+							kontextMenu.addItem(hintMenuItem = new MenuItem("Hint: " + stmp));
 						}
 						if (clickedCache.getType() == CacheType.CW_TYPE_QUESTION) {
-							stmp=clickedCache.getCacheDetails(false).LongDescription;
+							stmp = clickedCache.getCacheDetails(false).LongDescription;
 							if (!stmp.equals("")) {
-								kontextMenu.addItem(missionMenuItem=new MenuItem("?: "));								
+								kontextMenu.addItem(missionMenuItem = new MenuItem("?: "));
 							}
 						}
-						kontextMenu.addItem(new MenuItem("-"));
-						kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint()+" Info:"));
-						kontextMenu.addItem(new MenuItem("Difficulty: "+CacheTerrDiff.longDT(clickedCache.getHard())));
-						kontextMenu.addItem(new MenuItem("Terrain: "+CacheTerrDiff.longDT(clickedCache.getTerrain())));
-						kontextMenu.addItem(new MenuItem("Size: "+CacheSize.cw2ExportString(clickedCache.getCacheSize())));
 					}
 				}
 			}
 			/*
-			 *  this kontext will be replaced by the settings of the rose in the goto panel
-			 *    
-			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
-			}
-			else {
-				for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
-					kontextMenu.addItem(miLuminary[i]);
-					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-					else miLuminary[i].modifiers &= MenuItem.Checked;
-				}
-			}
-			*/
-			onlyIfCache=false;
-			if (kontextMenu.items.size()>0) {
+			 * this kontext will be replaced by the settings of the rose in
+			 * the goto panel
+			 * 
+			 * if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) { } else {
+			 * for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+			 * kontextMenu.addItem(miLuminary[i]); if (i ==
+			 * mm.myNavigation.luminary) miLuminary[i].modifiers |=
+			 * MenuItem.Checked; else miLuminary[i].modifiers &=
+			 * MenuItem.Checked; } }
+			 */
+			onlyIfCache = false;
+			if (kontextMenu.items.size() > 0) {
 				kontextMenu.exec(this, new Point(p.x, p.y), this);
-			}
-			else kontextMenu=null;
+			} else
+				kontextMenu = null;
 		}
 	}
-	
+
 	public boolean imageMovedOn(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
-				CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
-				this.toolTip=ch.getWayPoint()+"\n"
-							+ ch.cacheName+"\n"
-							+ "Difficulty: "+CacheTerrDiff.longDT(ch.getHard())+"\n"
-							+ "Terrain: "+CacheTerrDiff.longDT(ch.getTerrain())+"\n"
-							+ "Size: "+CacheSize.cw2ExportString(ch.getCacheSize())+"\n";
-				if (ch.getType() == CacheType.CW_TYPE_QUESTION) {
-					this.toolTip = this.toolTip + ch.getCacheDetails(false).LongDescription;
-				}
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
+				final CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
+				this.toolTip = ch.getWayPoint() + "\n" + ch.getCacheName();
 			}
 		}
 		return true;
 	}
+
 	public boolean imageMovedOff(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
-				this.toolTip=null;
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
+				this.toolTip = null;
 			}
 		}
 		return true;
 	}
 
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		// nothing selected in kontext
-		if (kontextMenu != null 
-				&& ev instanceof PenEvent 
-				&& ev.type == PenEvent.PEN_DOWN 
-				&& ev.target == this) {
-			kontextMenu.close(); 
-			kontextMenu = null; 
+		if (kontextMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {
+			kontextMenu.close();
+			kontextMenu = null;
 			return;
 		}
 		// something selected
 		if (ev instanceof MenuEvent) {
 			if (ev.target == kontextMenu) {
-				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
-					MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
+				if ((((MenuEvent) ev).type == MenuEvent.SELECTED)) {
+					final MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
 					if (action == gotoMenuItem) {
 						closeKontextMenu();
 						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 					}
 					if (action == openCacheDescMenuItem || action == openCacheDetailMenuItem) {
 						leaveMovingMap();
-						MainTab mainT = Global.mainTab;
-						if (action == openCacheDescMenuItem) 
-							mainT.openPanel(clickedCache,2);
+						final MainTab mainT = Global.mainTab;
+						if (action == openCacheDescMenuItem)
+							mainT.openPanel(clickedCache, 2);
 						else
-							mainT.openPanel(clickedCache,1);
+							mainT.openPanel(clickedCache, 1);
 					}
 					if (action == gotoCacheMenuItem) {
 						closeKontextMenu();
 						mm.myNavigation.setDestination(clickedCache);
 					}
+					if (action == markFoundMenuItem) {
+						closeKontextMenu();
+						final Time dtm = new Time();
+						dtm.setFormat("yyyy-MM-dd HH:mm");
+						clickedCache.setCacheStatus(dtm.toString());
+						clickedCache.setFound(true);
+						clickedCache.save();
+						if (clickedCache.hasAddiWpt()) {
+							CacheHolder addiWpt;
+							for (int i = clickedCache.addiWpts.getCount() - 1; i >= 0; i--) {
+								addiWpt = (CacheHolder) clickedCache.addiWpts.get(i);
+								addiWpt.setCacheStatus(dtm.toString());
+								addiWpt.setFound(true);
+								addiWpt.save();
+								mm.removeMapSymbol(addiWpt.getWayPoint());
+							}
+						}
+						mm.removeMapSymbol(clickedCache.getWayPoint());
+						mm.updateSymbolPositions();
+						this.repaintNow();
+					}
 					if (action == newWayPointMenuItem) {
 						leaveMovingMap();
-						CacheHolder newWP = new CacheHolder();
-						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						newWP.setLatLon(newWP.pos.toString());
+						final CacheHolder newWP = new CacheHolder();
+						newWP.setPos(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 						Global.mainTab.newWaypoint(newWP);
 					}
 					if (action == addCachetoListMenuItem) {
@@ -2421,21 +2852,19 @@
 						Global.mainForm.cacheList.addCache(clickedCache.getWayPoint());
 					}
 					if (action == hintMenuItem) {
-						(new MessageBox("Hint", STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints),"<br>","\n"), FormBase.OKB)).execute();
+						(new MessageBox("Hint", STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints), "<br>", "\n"), FormBase.OKB)).execute();
 					}
 					if (action == missionMenuItem) {
-						(new MessageBox("Mission", STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription,"<br>","\n"), FormBase.OKB)).execute();
+						(new MessageBox("Mission", STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription, "<br>", "\n"), FormBase.OKB)).execute();
 					}
 					/*
-					for (int i=0; i<miLuminary.length; i++) {
-						if (action == miLuminary[i]) {
-							kontextMenu.close();
-							mm.myNavigation.setLuminary(i);
-							mm.updateGps(mm.myNavigation.gpsPos.getFix());
-							miLuminary[i].modifiers |= MenuItem.Checked;
-						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
-					}
-					*/
+					 * for (int i=0; i<miLuminary.length; i++) { if (action ==
+					 * miLuminary[i]) { kontextMenu.close();
+					 * mm.myNavigation.setLuminary(i);
+					 * mm.updateGps(mm.myNavigation.gpsPos.getFix());
+					 * miLuminary[i].modifiers |= MenuItem.Checked; } else
+					 * miLuminary[i].modifiers &= ~MenuItem.Checked; }
+					 */
 				}
 			} // if (ev.target == kontextMenu)
 		}
@@ -2445,84 +2874,97 @@
 	private void closeKontextMenu() {
 		kontextMenu.close();
 		// for not to do an additional klick (before reacting on klicks)
-		PenEvent pev = new PenEvent();
-		pev.target=this;
-		pev.type=PenEvent.PEN_DOWN;
+		final PenEvent pev = new PenEvent();
+		pev.target = this;
+		pev.type = PenEvent.PEN_DOWN;
 		this.postEvent(pev);
-		pev.type=PenEvent.PEN_UP;
+		pev.type = PenEvent.PEN_UP;
 		this.postEvent(pev);
 	}
+
 	private void leaveMovingMap() {
 		closeKontextMenu();
-		WindowEvent close = new WindowEvent();
+		final WindowEvent close = new WindowEvent();
 		close.target = this;
 		close.type = WindowEvent.CLOSE;
-		this.postEvent(close);		
+		this.postEvent(close);
 	}
 }
 
 /**
- *	Class to display maps to choose from
+ * Class to display maps to choose from
  */
-class ListBox extends Form{
+class ListBox extends Form {
 	public MapInfoObject selectedMap; // = new MapInfoObject();
 	mButton cancelButton, okButton;
-	mList list = new mList(4,1,false);
+	mList list = new mList(4, 1, false);
 	public boolean selected = false;
 	Vector maps;
 
-	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap) {
 		this.title = MyLocale.getMsg(4271, "Maps");
-		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
-		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
-		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100);
+		// else
+		// set width to screenwidth *3/4 but to at least 240 if the screen
+		// is big engough for 240px width
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth() * 3 / 4, java.lang.Math.min(240, MyLocale.getScreenWidth())), MyLocale.getScreenHeight() * 3 / 4);
 		this.maps = maps;
 		MapInfoObject map;
 		MapListEntry ml;
 		String cmp;
 		int oldmap = -1;
 		boolean curMapFound = false;
-		boolean[] inList = new boolean[maps.size()];
+		final boolean[] inList = new boolean[maps.size()];
 		int row = -1;
-		if (curMap == null) curMapFound = true;
+		if (curMap == null)
+			curMapFound = true;
 		if (gotopos != null && Gps != null) {
 			list.addItem(MyLocale.getMsg(4272, "--- Maps containing GPS and goto pos. ---"));
 			row++;
-			cmp = "FF1"+(new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
-			for(int i = 0; i<maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = "FF1" + (new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
+			for (int i = 0; i < maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) && map.isInBound(gotopos) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec) && map.isInBound(gotopos)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound && curMap!=null && map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound && curMap != null && map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
-				} else inList[i] = false;
+				} else
+					inList[i] = false;
 			}
 		}
 		if (Gps != null) {
 			list.addItem(MyLocale.getMsg(4273, "--- Maps containing curr. position ---"));
 			row++;
-			cmp = "FF1"+Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
-			for(int i = 0; i<maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = "FF1" + Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
+			for (int i = 0; i < maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && curMap!=null && map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound && curMap != null && map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2532,18 +2974,23 @@
 		if (gotopos != null) {
 			list.addItem(MyLocale.getMsg(4274, "--- Karten des Ziels ---"));
 			row++;
-			cmp = "FF1"+Area.getEasyFindString(gotopos, 30);
-			for(int i = 0; i<maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = "FF1" + Area.getEasyFindString(gotopos, 30);
+			for (int i = 0; i < maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if(map.isInBound(gotopos)) {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(gotopos)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && curMap!=null && map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound && curMap != null && map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2552,69 +2999,76 @@
 		}
 		list.addItem(MyLocale.getMsg(4275, "--- andere Karten ---"));
 		row++;
-		for(int i = 0; i<maps.size();i++){
-			ml = (MapListEntry)maps.get(i);
-			if(!inList[i]) {
+		for (int i = 0; i < maps.size(); i++) {
+			ml = (MapListEntry) maps.get(i);
+			if (!inList[i]) {
 				list.addItem(i + ": " + ml.filename);
 				row++;
-				if (!curMapFound && curMap!=null && ml.filename.equals(curMap.mapName)) {
+				if (!curMapFound && curMap != null && ml.filename.equals(curMap.mapName)) {
 					oldmap = row;
 					curMapFound = true;
 				}
 			}
 		}
 		list.selectItem(oldmap, true);
-		this.addLast(new CacheWolf.MyScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new CacheWolf.MyScrollBarPanel(list), CellConstants.STRETCH, CellConstants.FILL);
 		cancelButton = new mButton(MyLocale.getMsg(4276, "Cancel"));
 		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(cancelButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton = new mButton(MyLocale.getMsg(4277, "Select"));
 		okButton.setHotKey(0, KeyEvent.getActionKey(true));
-		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(okButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton.takeFocus(0);
 	}
+
 	public void mapSelected() {
 		try {
 			selectedMap = null;
 			int mapNum = 0;
 			String it = new String();
 			it = list.getText();
-			if (it != ""){
-				it = it.substring(0,it.indexOf(':'));
+			if (it != "") {
+				it = it.substring(0, it.indexOf(':'));
 				mapNum = Convert.toInt(it);
 				try {
-				selectedMap = ((MapListEntry)maps.get(mapNum)).getMap();
-				selected = true;
-				this.close(FormBase.IDOK);
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4278, "Cannot load wfl-file: \n")
-							+ ((MapListEntry)maps.get(mapNum)).filename, FormBase.OKB)).execute();
+					selectedMap = ((MapListEntry) maps.get(mapNum)).getMap();
+					selected = true;
+					this.close(FormBase.IDOK);
+				} catch (final IOException e) {
+					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4278, "Cannot load wfl-file: \n") + ((MapListEntry) maps.get(mapNum)).filename, FormBase.OKB)).execute();
 				}
-			}
-			else {
+			} else {
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-		}catch (NegativeArraySizeException e) {
+		} catch (final NegativeArraySizeException e) {
 			// happens in substring when a dividing line selected
 		}
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelButton){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelButton) {
 				selectedMap = null;
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+			if (ev.target == okButton || ev.target == list) { // ev.target
+																// == list
+																// is posted
+																// by mList
+																// if a
+																// selection
+																// was
+																// double
+																// clicked
 				mapSelected();
 			}
 		}
 		super.onEvent(ev);
 	}
 
-	public void  penDoubleClicked(Point where) {
+	public void penDoubleClicked(Point where) {
 		mapSelected();
 	}
 }
@@ -2626,13 +3080,13 @@
 
 	int minY;
 	Graphics draw;
-	private MapInfoObject map=null;
+	private MapInfoObject map = null;
 
-	Color moveDirColor = new Color(255,0,0); // RED
-	final static Color sunDirColor = new Color(255,255,0); // Yellow
-	//final static Color GREEN = new Color(0,255,0);
-	final static Color gotoDirColor = new Color(0,0,128); // dark blue
-	final static Color northDirColor = new Color(0,0,255); // Blue
+	Color moveDirColor = new Color(255, 0, 0); // RED
+	final static Color sunDirColor = new Color(255, 255, 0); // Yellow
+	// final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0, 0, 128); // dark blue
+	final static Color northDirColor = new Color(0, 0, 255); // Blue
 	Point[] sunDirArrow = null;
 	Point[] gotoDirArrow = null;
 	Point[] moveDirArrow = null;
@@ -2642,31 +3096,37 @@
 	int arrowThickness = imageSize / 28;
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public ArrowsOnMap(){
+	public ArrowsOnMap() {
 		super();
 		newImage();
-		//	setDirections(90, 180, -90);
+		// setDirections(90, 180, -90);
 	}
 
 	public void newImage() {
-		setImage(new Image(imageSize,imageSize), Color.White);
+		setImage(new Image(imageSize, imageSize), Color.White);
 		draw = new Graphics(image);
 	}
+
 	public void setMap(MapInfoObject m) {
 		map = m;
 		makeArrows();
 	}
 
-	public void setDirections(float gd, float sd, float md ) {
-		if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
-				|| java.lang.Math.abs(sunDir - sd) > 1
-				|| java.lang.Math.abs(moveDir - md) > 1)
-		{
-			//dirsChanged = false;
+	public void setDirections(float gd, float sd, float md) {
+		if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage
+													// only update if the is
+													// a change of
+													// directions of more
+													// than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) > 1 || java.lang.Math.abs(moveDir - md) > 1) {
+			// dirsChanged = false;
 			gotoDir = gd;
 			sunDir = sd;
 			moveDir = md;
@@ -2676,98 +3136,123 @@
 
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
-		if (map == null || g == null) return;
+	public void doDraw(Graphics g, int options) {
+		if (map == null || g == null)
+			return;
 		drawArrows(g);
 		return;
-/*		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
-			return;
-		}
-		dirsChanged = false;
-		//super.doDraw(g, options);
-		draw.setColor(Color.White);
-		draw.fillRect(0, 0, location.width, location.height);
-		minY = Integer.MAX_VALUE;
-		drawArrows(draw);
-		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
-		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-*/	}
+		/*
+		 * if (!dirsChanged) {
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); //
+		 * the transparency with a transparent color doesn't work in ewe-vm
+		 * for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 return; }
+		 * dirsChanged = false; //super.doDraw(g, options);
+		 * draw.setColor(Color.White); draw.fillRect(0, 0, location.width,
+		 * location.height); minY = Integer.MAX_VALUE; drawArrows(draw);
+		 * draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); //
+		 * this trick (note: wrong transparentColor) forces a redraw
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+		 */}
 
-	private void makeArrows(){
-			// draw only valid arrows
-			if (moveDir < 360 && moveDir > -360) {
-				if (moveDirArrow == null) moveDirArrow = new Point[2];
-				makeArrow(moveDirArrow, moveDir, 1.0f);
-			} else moveDirArrow = null;
-			if (gotoDir < 360 && gotoDir > -360) {
-				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
-				makeArrow(gotoDirArrow, gotoDir, 1.0f);
-			} else gotoDirArrow = null;
-			if (sunDir < 360 && sunDir> -360) {
-				if (sunDirArrow == null ) sunDirArrow = new Point[2];
-				makeArrow(sunDirArrow, sunDir, 0.75f);
-			} else sunDirArrow = null;
-			if (map != null && java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
-				if (northDirArrow == null) northDirArrow = new Point[2];
-				makeArrow(northDirArrow, 0, 1.0f); // north direction
-			} else northDirArrow = null;
+	private void makeArrows() {
+		// draw only valid arrows
+		if (moveDir < 360 && moveDir > -360) {
+			if (moveDirArrow == null)
+				moveDirArrow = new Point[2];
+			makeArrow(moveDirArrow, moveDir, 1.0f);
+		} else
+			moveDirArrow = null;
+		if (gotoDir < 360 && gotoDir > -360) {
+			if (gotoDirArrow == null)
+				gotoDirArrow = new Point[2];
+			makeArrow(gotoDirArrow, gotoDir, 1.0f);
+		} else
+			gotoDirArrow = null;
+		if (sunDir < 360 && sunDir > -360) {
+			if (sunDirArrow == null)
+				sunDirArrow = new Point[2];
+			makeArrow(sunDirArrow, sunDir, 0.75f);
+		} else
+			sunDirArrow = null;
+		if (map != null && java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI) { // show
+																									// northth
+																									// arrow
+																									// only
+																									// if
+																									// it
+																									// has
+																									// more
+																									// than
+																									// 1.5
+																									// degree
+																									// deviation
+																									// from
+																									// vertical
+																									// direction
+			if (northDirArrow == null)
+				northDirArrow = new Point[2];
+			makeArrow(northDirArrow, 0, 1.0f); // north direction
+		} else
+			northDirArrow = null;
 
-			//select moveDirColor according to difference to gotoDir
-			moveDirColor = new Color(255,0,0); // red
+		// select moveDirColor according to difference to gotoDir
+		moveDirColor = new Color(255, 0, 0); // red
 
-			if (moveDirArrow != null && gotoDirArrow != null)
-			{
-				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff > 360)
-				{
-					diff -= 360.0f;
-				}
-				if (diff > 180)
-				{
-					diff = 360.0f - diff;
-				}
+		if (moveDirArrow != null && gotoDirArrow != null) {
+			float diff = java.lang.Math.abs(moveDir - gotoDir);
+			while (diff > 360) {
+				diff -= 360.0f;
+			}
+			if (diff > 180) {
+				diff = 360.0f - diff;
+			}
 
-				if (diff <= 5.0)
-				{
-					moveDirColor = new Color(0,192,0);// darkgreen
-				}
-				else if (diff <= 22.5)
-				{
-					moveDirColor = new Color(0,255,0);// green
-				}
-				else if (diff <= 45.0)
-				{
-					moveDirColor = new Color(255,128,0);// orange
-				}
+			if (diff <= 5.0) {
+				moveDirColor = new Color(0, 192, 0);// darkgreen
+			} else if (diff <= 22.5) {
+				moveDirColor = new Color(0, 255, 0);// green
+			} else if (diff <= 45.0) {
+				moveDirColor = new Color(255, 128, 0);// orange
 			}
 		}
+	}
 
 	/**
 	 * make (calculate) Pixel array for a single arrow
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
+	 * 
+	 * @param g
+	 *            handle for drawing
+	 * @param angle
+	 *            angle of arrow
+	 * @param col
+	 *            color of arrow
 	 */
 	private void makeArrow(Point[] arrow, float angle, float scale) {
-		if (map == null) return;
+		if (map == null)
+			return;
 
 		float angleRad;
-		int centerX = location.width/2, centerY = location.height/2;
-		if (arrow[0] == null) arrow[0] = new Point();
-		if (arrow[1] == null) arrow[1] = new Point();
+		final int centerX = location.width / 2, centerY = location.height / 2;
+		if (arrow[0] == null)
+			arrow[0] = new Point();
+		if (arrow[1] == null)
+			arrow[1] = new Point();
 		arrow[0].x = centerX;
 		arrow[0].y = centerY;
-		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		angleRad = angle * (float) java.lang.Math.PI / 180 + map.rotationRad;
 		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
 		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
-		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
-		//	g.drawLine(centerX,centerY,x,y);
+		// g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		// g.drawLine(centerX,centerY,x,y);
 	}
 
 	public void drawArrows(Graphics g) {
@@ -2778,12 +3263,9 @@
 	}
 
 	public void drawArrow(Graphics g, Point[] arrow, Color col) {
-		if (arrow == null) return;
-		g.setPen(new Pen(col,Pen.SOLID,arrowThickness));
-		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+		if (arrow == null)
+			return;
+		g.setPen(new Pen(col, Pen.SOLID, arrowThickness));
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x, arrow[1].y);
 	}
 }
-
-
-
-

Modified: branches/r1.2/src/CacheWolf/navi/Navigate.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/Navigate.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/Navigate.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,30 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
- 
+
 import net.ax86.GPS;
 import net.ax86.GPSException;
 
@@ -46,13 +46,13 @@
 import ewe.ui.MessageBox;
 import ewe.util.mString;
 
-
 /**
  * Non-Gui Class to handle all things regarding navigation
  * (GPS, Sun direction etc.)
  * start offset in localisation file: 4400
+ * 
  * @author Pfeffer
- *
+ * 
  */
 public class Navigate {
 	public CWPoint destination = new CWPoint();
@@ -60,7 +60,7 @@
 	public boolean destinationIsCache = false;
 	public CWGPSPoint gpsPos = new CWGPSPoint();
 	public Track curTrack = null;
-	public Color trackColor = new Color(255,0,0); // red
+	public Color trackColor = new Color(255, 0, 0); // red
 	public CWPoint skyOrientationDir = new CWPoint();
 	public int luminary = SkyOrientation.SUN;
 
@@ -78,160 +78,167 @@
 	public void setGotoPanel(GotoPanel gp) {
 		gotoPanel = gp;
 	}
-	public void setMovingMap (MovingMap mm) {
+
+	public void setMovingMap(MovingMap mm) {
 		movingMap = mm;
-		if (gpsRunning) mm.gpsStarted();
+		if (gpsRunning)
+			mm.gpsStarted();
 	}
 
 	public void startGps(boolean loggingOn, int loggingIntervall) {
 		lograw = loggingOn;
 		logIntervall = loggingIntervall; // TODO switch on and off during serthread running
-		
-		switch(Global.getPref().useGPSD) {
-			// Tblue> TODO: NEW vs. OLD: This is ugly! The only line that's
-			//        different is the one where the object is created!
-			case Preferences.GPSD_FORMAT_NEW:
-				try {
-					gpsdThread = new GpsdThread(gpsPos);
-					gpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-						MyLocale.getMsg(4408, "Could not connect to GPSD: ")
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"),
-						FormBase.OKB)).execute();
-				} catch( Exception e ) {
-					// Other error (JSON/GPS).
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-						MyLocale.getMsg(99999, "Could not initialize GPSD connection: ") 
-						+ e.getMessage(),
-						FormBase.OKB)).execute();
-				}
-				break;
 
-			case Preferences.GPSD_FORMAT_OLD:
-				try {
-					oldGpsdThread = new OldGpsdThread(gpsPos);
-					oldGpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-						MyLocale.getMsg(4408, "Could not connect to GPSD: ")
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"),
-						FormBase.OKB)).execute();
-				}
-				break;
+		switch (Global.getPref().useGPSD) {
+		// Tblue> TODO: NEW vs. OLD: This is ugly! The only line that's
+		// different is the one where the object is created!
+		case Preferences.GPSD_FORMAT_NEW:
+			try {
+				gpsdThread = new GpsdThread(gpsPos);
+				gpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4408, "Could not connect to GPSD: ") + e.getMessage() + MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"), FormBase.OKB))
+						.execute();
+			} catch (Exception e) {
+				// Other error (JSON/GPS).
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(99999, "Could not initialize GPSD connection: ") + e.getMessage(), FormBase.OKB)).execute();
+			}
+			break;
 
-			case Preferences.GPSD_DISABLED:
-			default:
-				if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
-				try {
-					serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
-					if (pref.forwardGPS && !serThread.tcpForward) {
-						(new MessageBox(MyLocale.getMsg(4400, "Warning"),
-								MyLocale.getMsg(4401, "Ignoring error:\n could not forward GPS data to host:\n")
-								+ pref.forwardGpsHost+"\n" + serThread.lastError
-								+ MyLocale.getMsg(4402, "\nstop and start GPS to retry"), FormBase.OKB)).exec();
-					}
-					serThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-							MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ")
-							+ e.getMessage()
-							+ MyLocale.getMsg(4405, "\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS"),
-							FormBase.OKB)).execute();
-				} catch (UnsatisfiedLinkError e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-							MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ")
-							+ MyLocale.getMsg(4406, "Please copy jave_ewe.dll into the directory of the cachewolf program"),
-							FormBase.OKB)).execute();
+		case Preferences.GPSD_FORMAT_OLD:
+			try {
+				oldGpsdThread = new OldGpsdThread(gpsPos);
+				oldGpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4408, "Could not connect to GPSD: ") + e.getMessage() + MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"), FormBase.OKB))
+						.execute();
+			}
+			break;
+
+		case Preferences.GPSD_DISABLED:
+		default:
+			if (serThread != null)
+				if (serThread.isAlive())
+					return; // TODO use gpsRunning
+			try {
+				serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
+				if (pref.forwardGPS && !serThread.tcpForward) {
+					(new MessageBox(MyLocale.getMsg(4400, "Warning"), MyLocale.getMsg(4401, "Ignoring error:\n could not forward GPS data to host:\n") + pref.forwardGpsHost + "\n" + serThread.lastError
+							+ MyLocale.getMsg(4402, "\nstop and start GPS to retry"), FormBase.OKB)).exec();
 				}
-				break;
+				serThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ") + e.getMessage()
+						+ MyLocale.getMsg(4405, "\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS"), FormBase.OKB)).execute();
+			} catch (UnsatisfiedLinkError e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ")
+						+ MyLocale.getMsg(4406, "Please copy jave_ewe.dll into the directory of the cachewolf program"), FormBase.OKB)).execute();
+			}
+			break;
 		}
 	}
+
 	public void startDisplayTimer() {
 		tickerThread = new UpdateThread(this, 1000);
 		tickerThread.start();
 	}
 
-	public void stopDisplayTimer(){
-		if (tickerThread != null) tickerThread.stop();
+	public void stopDisplayTimer() {
+		if (tickerThread != null)
+			tickerThread.stop();
 	}
 
 	public void stopGps() {
-		if(serThread!=null)	serThread.stop();
-		if(gpsdThread!=null) gpsdThread.stop();
-		if(oldGpsdThread!=null) oldGpsdThread.stop();
+		if (serThread != null)
+			serThread.stop();
+		if (gpsdThread != null)
+			gpsdThread.stop();
+		if (oldGpsdThread != null)
+			oldGpsdThread.stop();
 		stopDisplayTimer();
 		gpsPos.stopLog();
 		gpsRunning = false;
-		if (gotoPanel != null) gotoPanel.gpsStoped();
-		if (movingMap != null) movingMap.gpsStoped();
+		if (gotoPanel != null)
+			gotoPanel.gpsStoped();
+		if (movingMap != null)
+			movingMap.gpsStoped();
 	}
 
 	public boolean isGpsPosValid() {
-		return ((serThread != null && serThread.isAlive()) ||
-		       (gpsdThread != null && gpsdThread.isAlive()) ||
-		       (oldGpsdThread != null && oldGpsdThread.isAlive()))
-		        && gpsPos.isValid() ; // && gpsPos.getfiex();
+		return ((serThread != null && serThread.isAlive()) || (gpsdThread != null && gpsdThread.isAlive()) || (oldGpsdThread != null && oldGpsdThread.isAlive())) && gpsPos.isValid(); // && gpsPos.getfiex();
 	}
 
-
 	public void setDestination(String LatLon) {
 		setDestination(new CWPoint(LatLon));
 	}
 
-
 	public void setDestination(CWPoint d) {
 		destinationIsCache = false;
-		destination = new CWPoint (d);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(destination);
+		destination = new CWPoint(d);
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(destination);
 	}
 
 	public void setDestination(CacheHolder ch) {
 		destinationIsCache = true;
-		destinationCache=ch;
-		destination = new CWPoint (ch.pos);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(ch);
+		destinationCache = ch;
+		destination = new CWPoint(ch.getPos());
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(ch);
 	}
 
 	/**
 	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * 
 	 * @param lu
 	 */
 	public void setLuminary(int lu) {
 		luminary = lu;
 	}
+
 	public void ticked() {
 		int fix = gpsPos.getFix();
-		if (fix > 0 && (gpsPos.getSats()>= 0)) {
-			if (curTrack == null) curTrack = new Track(trackColor);
+		if (fix > 0 && (gpsPos.getSats() >= 0)) {
+			if (curTrack == null)
+				curTrack = new Track(trackColor);
 			try {
 				curTrack.add(gpsPos);
 			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
 				curTrack = new Track(trackColor);
 				curTrack.add(gpsPos);
-				if (movingMap != null) movingMap.addTrack(curTrack);
+				if (movingMap != null)
+					movingMap.addTrack(curTrack);
 			}
 			try {
 				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
@@ -245,14 +252,14 @@
 			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
 		}
 		gotoPanel.updateGps(fix);
-		if (movingMap != null) movingMap.updateGps(fix);
+		if (movingMap != null)
+			movingMap.updateGps(fix);
 	}
 }
 
-
 /**
  * Thread for reading data from gpsd.
- *
+ * 
  * @author Tilman Blumenbach
  */
 class GpsdThread extends mThread {
@@ -260,27 +267,24 @@
 	CWGPSPoint myGPS;
 	boolean run;
 
-
 	public GpsdThread(CWGPSPoint GPSPoint) throws IOException, JSONException, GPSException {
 		JSONObject response;
 		int proto_major;
 
 		myGPS = GPSPoint;
 		gpsObj = new GPS(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
-		gpsObj.stream( GPS.WATCH_ENABLE );
+		gpsObj.stream(GPS.WATCH_ENABLE);
 
 		// Check major protocol version:
 		response = gpsObj.read();
 
-		if( ! response.getString( "class" ).equals( "VERSION" ) ) {
-			throw new GPSException( "Expected VERSION object at connect." );
-		} else if( ( proto_major = response.getInt( "proto_major" ) ) != 3 ) {
-			throw new GPSException( "Invalid protocol API version; got " +
-					proto_major + ", want 3." );
+		if (!response.getString("class").equals("VERSION")) {
+			throw new GPSException("Expected VERSION object at connect.");
+		} else if ((proto_major = response.getInt("proto_major")) != 3) {
+			throw new GPSException("Invalid protocol API version; got " + proto_major + ", want 3.");
 		}
 	}
 
-
 	public void run() {
 		JSONObject response;
 		String respClass;
@@ -290,46 +294,46 @@
 
 		run = true;
 		while (run) {
-			if( gpsObj != null ) {
+			if (gpsObj != null) {
 				gotValidData = false;
 
 				try {
-					/* Tblue> This is ugly, but BufferedReader::ready() seems to
-					 *        be broken in Ewe, so instead of only polling when
-					 *        there is no data from gpsd (by checking the return
-					 *        value of GPS::waiting(), we poll on every iteration.
-					 *        Not ideal, but works for now.
+					/*
+					 * Tblue> This is ugly, but BufferedReader::ready() seems to
+					 * be broken in Ewe, so instead of only polling when
+					 * there is no data from gpsd (by checking the return
+					 * value of GPS::waiting(), we poll on every iteration.
+					 * Not ideal, but works for now.
 					 */
 					gpsObj.poll();
 
-					/* Tblue> TODO: I think this call should not block, but
-					 *              my GPS class does not yet support non-blocking
-					 *              reads...
+					/*
+					 * Tblue> TODO: I think this call should not block, but
+					 * my GPS class does not yet support non-blocking
+					 * reads...
 					 */
-					response  = gpsObj.read();
-					
+					response = gpsObj.read();
+
 					// If we get here we have got some data:
 					noData = 0;
 
-					respClass = response.getString( "class" );
-					if( respClass.equals( "DEVICE" ) && response.has( "activated" ) &&
-						response.getDouble( "activated" ) != 0 )
-					{	// This is a new device, we need to tell gpsd we want to watch it:
-						Global.getPref().log( "New GPS device, sending WATCH command." );
-						gpsObj.stream( GPS.WATCH_ENABLE );
-					} else if( respClass.equals( "POLL" ) ) {
+					respClass = response.getString("class");
+					if (respClass.equals("DEVICE") && response.has("activated") && response.getDouble("activated") != 0) { // This is a new device, we need to tell gpsd we want to watch it:
+						Global.getPref().log("New GPS device, sending WATCH command.");
+						gpsObj.stream(GPS.WATCH_ENABLE);
+					} else if (respClass.equals("POLL")) {
 						gotValidData = myGPS.examineGpsd(response);
-					} else if( respClass.equals( "ERROR" ) ) {
+					} else if (respClass.equals("ERROR")) {
 						// Global.getPref().log( "Ignored gpsd error: " + response.getString( "message" ) );
 					}
-				} catch( Exception e ) {
+				} catch (Exception e) {
 					// Something bad happened, will just ignore this JSON
 					// object:
 					// Ignored Exception", e, true);
 					gotValidData = false;
 				}
 
-				if( gotValidData ) {
+				if (gotValidData) {
 					notInterpreted = 0;
 				} else {
 					notInterpreted++;
@@ -354,18 +358,16 @@
 		myGPS.noData();
 	}
 
-
 	public void stop() {
 		run = false;
 
-		if( gpsObj != null ) {
+		if (gpsObj != null) {
 			gpsObj.cleanup();
 		}
 	}
 }
 
-
-class OldGpsdThread extends mThread{
+class OldGpsdThread extends mThread {
 	Socket gpsdSocket;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -373,7 +375,7 @@
 	String lastError = new String();
 
 	public OldGpsdThread(CWGPSPoint GPSPoint) throws IOException {
-		try{
+		try {
 			gpsdSocket = new Socket(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
 		} catch (IOException e) {
 			throw new IOException(Global.getPref().gpsdHost);
@@ -386,33 +388,36 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(900);
 				noData++;
-				if (noData > 5) { myGPS.noDataError(); }
+				if (noData > 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log("Ignored Exception", e, true);
 			}
-			if (gpsdSocket != null)	{
+			if (gpsdSocket != null) {
 				gpsResult = getGpsdData("ADPQTV\r\n");
-				if (gpsResult!=null) {
+				if (gpsResult != null) {
 					noData = 0;
 					if (myGPS.examineOldGpsd(gpsResult))
 						notinterpreted = 0;
 					else
 						notinterpreted++;
-					if (notinterpreted > 22) myGPS.noInterpretableData();
+					if (notinterpreted > 22)
+						myGPS.noInterpretableData();
 				}
 			}
 
-			//myGPS.printAll();
+			// myGPS.printAll();
 		} // while
 		myGPS.noData();
 	}
 
 	private String getGpsdData(String command) {
-		byte[] rcvBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+		byte[] rcvBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 		int rcvLength = 0;
 		try {
 			gpsdSocket.write(command.getBytes());
@@ -430,7 +435,7 @@
 			Global.getPref().log("Socket exception", e, true);
 		}
 		String str = null;
-		if (rcvLength > 0)	{
+		if (rcvLength > 0) {
 			str = mString.fromAscii(rcvBuff, 0, rcvLength);
 		}
 		return str;
@@ -438,18 +443,18 @@
 
 	public void stop() {
 		run = false;
-		if (gpsdSocket != null) gpsdSocket.close();
+		if (gpsdSocket != null)
+			gpsdSocket.close();
 	}
 }
 
-
 /**
  * Thread for reading data from COM-port
- *
+ * 
  */
-class SerialThread extends mThread{
+class SerialThread extends mThread {
 	SerialPort comSp;
-	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	byte[] comBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 	int comLength = 0;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -457,18 +462,22 @@
 	String lastError = new String();
 
 	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
-		try{
+		try {
 			spo.portName = CacheWolf.Common.fixSerialPortName(spo.portName);
 			comSp = new SerialPort(spo);
 		} catch (IOException e) {
 			throw new IOException(spo.portName);
 		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm
-		if (forwardIP.length()>0) {
+		if (forwardIP.length() > 0) {
 			try {
 				tcpConn = new Socket(forwardIP, 23);
 				tcpForward = true;
-			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-			} catch (IOException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (ewe.net.UnknownHostException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
+			} catch (IOException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
 			}
 		}
 		myGPS = GPSPoint;
@@ -478,26 +487,34 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(1000);
 				noData++;
-				if (noData > 5) { myGPS.noDataError(); }
+				if (noData > 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log("Ignored Exception", e, true);
 			}
-			if (comSp != null)	{
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-				if (comLength > 0)	{
+			if (comSp != null) {
+				comLength = comSp.nonBlockingRead(comBuff, 0, comBuff.length);
+				if (comLength > 0) {
 					noData = 0;
 					String str = mString.fromAscii(comBuff, 0, comLength);
 					if (tcpForward) {
 						try {
 							tcpConn.write(comBuff, 0, comLength);
-						} catch (IOException e) { tcpForward = false; }
+						} catch (IOException e) {
+							tcpForward = false;
+						}
 					}
-					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
-					if (notinterpreted > 22) myGPS.noInterpretableData();
+					if (myGPS.examine(str))
+						notinterpreted = 0;
+					else
+						notinterpreted++;
+					if (notinterpreted > 22)
+						myGPS.noInterpretableData();
 				}
 			}
 		} // while
@@ -507,7 +524,8 @@
 
 	public void stop() {
 		run = false;
-		if (comSp != null) comSp.close();
+		if (comSp != null)
+			comSp.close();
 	}
 }
 
@@ -522,16 +540,21 @@
 	public int calldelay;
 	public Navigate ticked;
 
-	public UpdateThread (Navigate gp, int cd) {
+	public UpdateThread(Navigate gp, int cd) {
 		ticked = gp;
 		calldelay = cd;
 	}
 
-	public void run () {
+	public void run() {
 		run = true;
 		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {	}
-			try { ticked.ticked();} catch (Exception e) {
+			try {
+				sleep(calldelay);
+			} catch (InterruptedException e) {
+			}
+			try {
+				ticked.ticked();
+			} catch (Exception e) {
 				// Global.getPref().log("Navigate.UpdateThread.run(): Ignored Exception. There should not be an Exception, so please report it in the cachewolf forum at www.geoclub.de", e, true);
 			}
 		}
@@ -541,6 +564,3 @@
 		run = false;
 	}
 }
-
-
-

Modified: branches/r1.2/src/CacheWolf/navi/Track.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/Track.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/Track.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,81 +1,93 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
-
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
 package CacheWolf.navi;
 
 import ewe.fx.Color;
+import ewe.io.BufferedWriter;
+import ewe.io.FileWriter;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.sys.Vm;
+import ewe.ui.MessageBox;
+import ewe.util.Utils;
 
 public class Track {
 	public Color trackColor;
-	public TrackPoint TrackPoints[];
-	public int num;
+	private TrackPoint trackPoints[];
+    private int index;
+	private int num;
 	
-	public Track(Color f) {
+	public Track(Color f, int trackSize) {
 		trackColor = f;
-		TrackPoints = new TrackPoint[5000];
+		trackPoints = new TrackPoint[trackSize];
 		num = 0;
+        index = 0;
 	}
-/*===== add is currently not used	
+
+        public Track (Color f){
+            this(f, 5000);
+        }
+
+        public Track (){
+            this (new Color (0xff,0,0));
+        }
+
 	public void add(double lat, double lon) {
-		TrackPoints[num] = new TrackPoint(lat, lon);
-		num++;
+		add(new TrackPoint(lat, lon));
 	}
-=====*/	
+
 	/**
-	 * throws IndexOutOfBoundsException when track is full
 	 */
 	public void add(TrackPoint t) { 
-		if (TrackPoints == null || t == null) return;
-		TrackPoints[num] = new TrackPoint(t);
+		if (t == null) return;
+		
+		trackPoints[index] = new TrackPoint(t);
+        index++;
+        if (index >= trackPoints.length) index = 0;
 		num++;
+        if (num >= trackPoints.length) num = trackPoints.length;
 	}
-/*===== loadTrack/saveTrack are currently not used
+        
+        /**
+         * returns number of Point in this track
+         */
+        public int size(){
+            return num;
+        }
+
+        /**
+          * returns the i.th point in this track
+          */
+        public TrackPoint get (int i){
+            //The array has never been filled, so first position is 0:
+            if (num < trackPoints.length) return trackPoints[i];
+            //Once filled, the least inserted position is marked by index
+            int tmpIndex = (index+i) % trackPoints.length;
+            return trackPoints[tmpIndex];
+        }
+
 	public void loadTrack(String filename){ // TODO untested!
-		byte [] all = ewe.sys.Vm.readResource(null,filename);
+		byte [] all = Vm.readResource(null,filename);
 		if (all == null) return; // TODO error handling
-		num = Utils.readInt(all, 0, 4);
-		for (int i=0; i<=num; i++){
-			TrackPoints[i].latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
-			TrackPoints[i].lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+		int numOfPoints = Utils.readInt(all, 0, 4);
+		for (int i=0; i<=numOfPoints; i++){
+			TrackPoint point = new TrackPoint();
+			point.latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
+			point.lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+			add (point);
 		}
 	}
 	
-	public void saveTrack(String filename){  // TODO untested!
-	//ByteArray ba=new ByteArray();
-	byte[] ba = new byte[8*2*num+4]; // 8 bytes is one double int has size 4
-	Utils.writeInt(num, ba, 0, 4);
-	for (int i=0; i<=num; i++){
-		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].latDec), ba, (i*2)*8 + 4);
-		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].lonDec), ba, (i*2+1)*8 + 4);
+	public void saveTrack(String filename) { // TODO untested!
+		byte[] ba = new byte[8 * 2 * size() + 4]; // 8 bytes is one double int has size 4
+		Utils.writeInt(size(), ba, 0, 4);
+		for (int i = 0; i <= size(); i++) {
+			Utils.writeLong(Double.doubleToLongBits(get(i).latDec), ba, (i * 2) * 8 + 4);
+			Utils.writeLong(Double.doubleToLongBits(get(i).lonDec), ba, (i * 2 + 1) * 8 + 4);
+		}
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
+			outp.print(ba.toString());
+		} catch (IOException e) {
+			(new MessageBox("Error", "Error reading trackfile:\n" + e.toString(), MessageBox.OKB)).execute();
+		}
 	}
-	try{
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(filename)));
-		outp.print(ba.toString());
-	}catch (IOException e) {
-		(new MessageBox("Error", "Error reading trackfile:\n"+e.toString(), MessageBox.OKB)).execute();}
-	}
-=====*/
-
 }

Modified: branches/r1.2/src/CacheWolf/navi/TrackOverlay.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/TrackOverlay.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/TrackOverlay.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -107,9 +107,9 @@
 		int tri, i;
 		Track tr;
 		int numberOfTracks = tracks.size();
-		int numberOfPoints = ((Track)tracks.get(numberOfTracks - 1)).num;
+		int numberOfPoints = ((Track)tracks.get(numberOfTracks - 1)).size();
 		if (numberOfTracks > 1){
-			numberOfPoints += (numberOfTracks - 1) * ((Track)tracks.get(0)).num;
+			numberOfPoints += (numberOfTracks - 1) * ((Track)tracks.get(0)).size();
 		}
 		int n = 0;
 		
@@ -117,13 +117,13 @@
 			tr = (Track)tracks.get(tri);
 			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
 			draw.setColor(tr.trackColor);
-			if (tr.num > 0) {
-				for (i=0; i < tr.num; i++) {
+			if (tr.size() > 0) {
+				for (i=0; i < tr.size(); i++) {
 					n++;
 					if  ((numberOfPoints - n > 5*60) && ((n & 1) == 0)) continue;
 					if  ((numberOfPoints - n > 15*60) && ((n & 2) == 0)) continue;
 					if  ((numberOfPoints - n > 30*60) && ((n & 4) == 0)) continue;
-					paintPoint(tr.trackColor, tr.TrackPoints[i]);
+					paintPoint(tr.trackColor, tr.get(i));
 				}
 			}
 		}
@@ -195,7 +195,7 @@
 	public void paintLastAddedPoint(Track tr) { 
 		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
 		draw.setColor(tr.trackColor);
-		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1])) notOnThisOverlaySince = 0;
+		if (paintPoint(tr.trackColor, tr.get(tr.size()-1))) notOnThisOverlaySince = 0;
 		else notOnThisOverlaySince++;
 		if (notOnThisOverlaySince > FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
 			fixate();

Modified: branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
 import CacheWolf.Global;
@@ -87,25 +87,21 @@
 					offsetx = offsety;
 				}
 
-				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH,
-						0);
-				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW,
-						imageH, 0);
+				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH, 0);
+				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW, imageH, 0);
 
-				for (int line = 0; line < imageH; line++) {
-					for (int pos = 0; pos < imageW; pos++) {
+				for (int y = 0; y < imageH; y++) {
+					for (int x = 0; x < imageW; x++) {
 
-						if (line >= offsety && pos >= offsetx
-								&& line < offsety + iconH
-								&& pos < offsetx + iconW) {
+						if (y >= offsety && x >= offsetx && y < offsety + iconH && x < offsetx + iconW) {
 
-							int iconx = pos - offsetx;
-							int icony = line - offsety;
+							int iconx = x - offsetx;
+							int icony = y - offsety;
 
-							int index = line * imageW + pos;
+							int index = y * imageW + x;
 							int iconIndex = icony * iconW + iconx;
 							int alphaval = (iconPixels[iconIndex] >> 24) & 0xff;
-							
+
 							if (alphaval > 127) {
 								imagePixels[index] = iconPixels[iconIndex];
 							}
@@ -117,15 +113,14 @@
 				image.setPixels(imagePixels, 0, 0, 0, imageW, imageH, 0);
 
 			} else
-				Global.getPref().log("icon " + iconSrc + " is bigger than " + source+ "! Icon not loaded",null);
+				Global.getPref().log("icon " + iconSrc + " is bigger than " + source + "! Icon not loaded", null);
 
 		}
 
 		if (alpha >= 0 && alpha < 256) {
 			alpha = alpha << 24;
 
-			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(),
-					image.getHeight(), 0);
+			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			for (int i = 0; i < imageBits.length; i++) {
 				if (imageBits[i] != 0) {
 					imageBits[i] &= 0xffffff;
@@ -133,8 +128,7 @@
 				}
 
 			}
-			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image
-					.getHeight(), 0);
+			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			image.enableAlpha();
 		}
 
@@ -156,6 +150,7 @@
 	public String getContent() {
 		return null;
 	}
+
 	public String getText() {
 		return null;
 	}
@@ -209,7 +204,7 @@
 
 			Boolean thisElement = (Boolean) roles.get(nextKey);
 			if (!overallRoles.containsKey(nextKey)) {
-				Global.getPref().log("Lookup role " + nextKey + " not possible",null);
+				Global.getPref().log("Lookup role " + nextKey + " not possible", null);
 				return false;
 			}
 

Modified: branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
-
 import ewe.fx.Image;
 import ewe.fx.mImage;
 import ewe.graphics.AniImage;
@@ -34,22 +33,20 @@
 
 	private int command;
 	private AniImageGrayScaled aniImage;
-	
-	public MovingMapControlItemButton(String source,String iconSrc, int actionCommand,
-			int alpha) {
+
+	public MovingMapControlItemButton(String source, String iconSrc, int actionCommand, int alpha) {
 		Image image = MovingMapControlItem.createImage(source, iconSrc, alpha);
 		aniImage = new AniImageGrayScaled(image);
 		aniImage.freeSource();
 		command = actionCommand;
-		aniImage.properties|= mImage.AlwaysOnTop;
-		xProperties|=IS_ICON_WITH_COMMAND;
+		aniImage.properties |= mImage.AlwaysOnTop;
+		xProperties |= IS_ICON_WITH_COMMAND;
 	}
 
 	public int getActionCommand() {
 		return command;
 	}
 
-	
 	public int getWidth() {
 		return aniImage.getWidth();
 	}

Modified: branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,7 +84,7 @@
 	public static final String BUTTON_ATTR_FROM_BOTTOM = "fromBottom";
 	/**
 	 * define when this button is visible. Contains a list of rolenames. Delimiter is '+'. If the role name starts with
-	 * '!' the buttom is shown if this role is inactive [(!)String+(!)String...] Example visibleIf="menu+!zoom" button
+	 * '!' the button is shown if this role is inactive [(!)String+(!)String...] Example visibleIf="menu+!zoom" button
 	 * is visible if role "menu" is active and role "zoom" is inactive.
 	 */
 	public static final String BUTTON_ATTR_VISIBILITY = "visibleIf";

Modified: branches/r1.2/src/CacheWolf/utils/CWWrapper.java
===================================================================
--- branches/r1.2/src/CacheWolf/utils/CWWrapper.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/utils/CWWrapper.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -58,6 +58,7 @@
 		return exec(cmd, arg, false, true);
 	}
 	public static int exec(String cmd, String arg, final boolean wait, final boolean surround) throws ewe.io.IOException {
+		// works if there is only one argument
 		if (surround) {
 			if (Vm.getPlatform().equals("WinCE") || Vm.getPlatform().equals("Win32"))
 			{
@@ -70,8 +71,11 @@
 				 * (see ewe/sys/Vm.java)			 *
 				 * on linux (and os x?) we must not have extra quotes, filenames with spaces are unsupported
 				 * */
-				if (cmd.indexOf(' ') > -1) {
-					cmd = "\"" + cmd + "\"";
+				if (cmd.indexOf(':') == 1) {
+					// java on Windows
+					if (cmd.indexOf(' ') > -1) {
+						cmd = "\"" + cmd + "\"";
+					}
 				}
 				if (arg.indexOf(' ') > -1) {
 					arg = "\"" + arg + "\"";


Property changes on: branches/r1.2/src/CacheWolf/view
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,17 @@
+package CacheWolf.view;
+
+public interface ITravelbugScreen {
+
+	/**
+	 * Shows the form
+	 * @return
+	 */
+	int execute();
+
+	/**
+	 * Returns the selected entry if any else <code>null</code>
+	 * @return
+	 */
+	int getSelectedItem();
+
+}
\ No newline at end of file

Added: branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,65 @@
+package CacheWolf.view;
+
+import java.lang.reflect.Constructor;
+
+import CacheWolf.Global;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugScreen;
+import CacheWolf.view.ewe.TravelbugJourneyScreen;
+import CacheWolf.view.pda.PDATravelbugScreen;
+import ewe.reflect.Reflect;
+import ewe.sys.Vm;
+
+public class TravelBugScreenFactory {
+
+	/**
+	 * Variante fuer Desktop unter Java???
+	 */
+	private static boolean isSwing;
+	static {
+		Global.getPref().log("Static initializer start ");
+		Class swingClass = null;
+		try {
+			swingClass = TravelbugJourneyScreen.class.getClassLoader().loadClass("javax.swing.JTable");
+		} catch (Exception e) {
+			Global.getPref().log("Swing not found");
+			Global.getPref().log(e.toString());
+			// ignore!
+		}
+		isSwing = swingClass != null && false;
+	}
+
+	/**
+	 * Variante fuer Android-PDA
+	 */
+	private static final boolean isAndroid = false;
+
+	public static ITravelbugScreen createTravelbugScreen(TravelbugList tbl, String title, Boolean allowNew) {
+		Global.getPref().log("Mobile-Device: " + Vm.isMobile());
+		Global.getPref().log("Preference for Mobile-Device: " + Global.getPref().mobileGUI);
+		if (Vm.isMobile() && Global.getPref().mobileGUI) {
+			try {
+				Class loadClass = Reflect.getForName("CacheWolf.view.pda.PDATravelbugScreen").getReflectedClass();
+				Constructor constructor = loadClass.getConstructor(new Class[] { TravelbugList.class, String.class, boolean.class });
+				ITravelbugScreen result = (ITravelbugScreen) constructor.newInstance(new Object[] { tbl, title, allowNew });
+				Global.getPref().log("TBScreen successfully instantiated");
+				return result;
+			} catch (Throwable e) {
+				Global.getPref().log("CacheWolf.view.pda.PDATravelbugScreen not found");
+				Global.getPref().log("Error in instantiating TravelBugScreen", e, true);
+				e.printStackTrace();
+				// ignore?? VM on WinPC seems to have no classloader
+				return new PDATravelbugScreen(tbl, title, allowNew.booleanValue());
+			}
+		} else if (isSwing) {
+			throw new InstantiationError("No Swing GUI available");
+			// return new TravelbugJourneyScreen(model);
+		} else if (isAndroid) {
+			throw new InstantiationError("No Android GUI available");
+			// return new TravelbugJourneyScreen(model);
+		} else {
+			return new TravelbugScreen(tbl, title, allowNew.booleanValue());
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,77 @@
+package CacheWolf.view;
+
+import java.lang.reflect.Constructor;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.TravelbugJourneyList;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import CacheWolf.view.ewe.TravelbugJourneyScreen;
+import CacheWolf.view.pda.PDATravelbugJourneyScreen;
+import ewe.reflect.Reflect;
+import ewe.sys.Vm;
+import ewe.ui.Form;
+
+public class TravelbugJourneyScreenFactory {
+
+	/**
+	 * Variante fuer Desktop unter Java???
+	 */
+	private static boolean isSwing ;
+	static{
+		Global.getPref().log("Static initializer start ");
+		Class swingClass = null;
+		try {
+			swingClass = TravelbugJourneyScreen.class.getClassLoader().loadClass("javax.swing.JTable");
+		} catch (Exception e) {
+			Global.getPref().log("Swing not found");
+			Global.getPref().log(e.toString());
+			//ignore!
+		}
+		isSwing = swingClass!=null;
+		isSwing = false;
+	}
+
+	/**
+	 * Variante fuer Android-PDA
+	 */
+	private static final boolean isAndroid = false;
+
+	public static Form createTravelbugJourneyScreen() {
+		TravelBugJourneyScreenModel model = new TravelBugJourneyScreenModel();
+		model.onlyLogged = Global.getPref().travelbugShowOnlyNonLogged;
+		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		CacheHolder ch = cacheDB.get(curCacheNo);
+		model.actualCache = ch;
+		TravelbugJourneyList myTravelbugJourneys = new TravelbugJourneyList();
+		myTravelbugJourneys.readTravelbugsFile();
+
+		model.allTravelbugJourneys = myTravelbugJourneys;
+
+		Global.getPref().log("Mobile-Device: " + Vm.isMobile());
+		Global.getPref().log("Preference for Mobile-Device: " + Global.getPref().mobileGUI);
+		if (Vm.isMobile() && Global.getPref().mobileGUI) {
+			try {
+				Class loadClass = Reflect.getForName("CacheWolf.view.pda.PDATravelbugJourneyScreen").getReflectedClass();
+				Constructor constructor = loadClass.getConstructor(new Class[]{model.getClass()});
+				Form result = (Form) constructor.newInstance(new Object[] {model});
+				Global.getPref().log("TBScreen successfully instantiated");
+				return result;
+			} catch (Throwable e) {
+				Global.getPref().log("CacheWolf.view.pda.PDATravelbugJourneyScreen not found");
+				Global.getPref().log("Error in instantiating TravelBugJourneyScreen", e, true);
+				e.printStackTrace();
+				//ignore?? VM on WinPC seems to have no classloader
+				return new PDATravelbugJourneyScreen(model);
+			}
+		} else if ( isSwing) {
+			throw new InstantiationError ("No Swing GUI available");
+		} else if (isAndroid) {
+			throw new InstantiationError ("No Android GUI available");
+		} else {
+			return new TravelbugJourneyScreen(model);
+		}
+	}
+}


Property changes on: branches/r1.2/src/CacheWolf/view/ewe
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,773 @@
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
+
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+package CacheWolf.view.ewe;
+
+/**
+ * A list to manage the travelbugs. Each row represents one @see TravelbugJourney.
+ * The lower half of the screen which is separated from the top by a splitter bar,
+ * contains four tabs: One for the travelbug, one for the source (where the travelbug 
+ * was picked up), one for the destination (where the travelbug was dropped) and one
+ * for the mission. These tabs are used for inputting data about the travelbug journey.
+ * The travelbugs are read from file travelbugs.xml which is stored in the base directory.
+ * When the screen is closed, all data is written back to the file.
+ * @author salzkammergut
+ */
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.DateTimeChooser;
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.MyScrollBarPanel;
+import CacheWolf.TableColumnChooser;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugPickup;
+import CacheWolf.imp.SpiderGC;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import CacheWolf.utils.CWWrapper;
+import ewe.fx.Color;
+import ewe.fx.Dimension;
+import ewe.fx.FontMetrics;
+import ewe.fx.IImage;
+import ewe.fx.IconAndText;
+import ewe.fx.Image;
+import ewe.fx.Point;
+import ewe.fx.Rect;
+import ewe.fx.mImage;
+import ewe.sys.Convert;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.CellConstants;
+import ewe.ui.CellPanel;
+import ewe.ui.Control;
+import ewe.ui.ControlConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.DataChangeEvent;
+import ewe.ui.Event;
+import ewe.ui.Form;
+import ewe.ui.FormEvent;
+import ewe.ui.Gui;
+import ewe.ui.HtmlDisplay;
+import ewe.ui.IKeys;
+import ewe.ui.Menu;
+import ewe.ui.MenuItem;
+import ewe.ui.MultiPanelEvent;
+import ewe.ui.PanelSplitter;
+import ewe.ui.PenEvent;
+import ewe.ui.ScrollablePanel;
+import ewe.ui.SplittablePanel;
+import ewe.ui.TableCellAttributes;
+import ewe.ui.TableControl;
+import ewe.ui.TableModel;
+import ewe.ui.mButton;
+import ewe.ui.mCheckBox;
+import ewe.ui.mInput;
+import ewe.ui.mLabel;
+import ewe.ui.mTabbedPanel;
+
+public class TravelbugJourneyScreen extends Form {
+
+	// ============= VIEW
+	/** The list control */
+	// Set to Public to implement MVC-Pattern [AP]
+	public tbListControl tcTbJourneyList;
+	/** The list model */
+	// Set to Public to implement MVC-Pattern [AP]
+	public tbListTableModel modTbJourneyList;
+	/** The actual journeys */
+
+	/** The panel for the lower half of the screen */
+	private CellPanel lowerpane;
+	private mInput inpName, inpTrackingNo, inpFromDate, inpFromProfile, inpFromWaypoint, inpToDate, inpToProfile, inpToWaypoint;
+	private mLabel lblId;
+	private mButton btnFromDate, btnToDate;
+	private mCheckBox chkFromLogged, chkToLogged;
+	private HtmlDisplay txtMission;
+	private mTabbedPanel pnlTab;
+
+	/** The currently selected row */
+	// Set to Public to implement MVC-Pattern [AP]
+	public int selectedRow = -1;
+
+	/** A label which holds the number of currently displayed travelbug journeys */
+	private mLabel lblNumVisibleJourneys;
+	private final Color RED = new Color(255, 0, 0);
+	private int exitKeys[] = { 75009 };
+
+	// =========== CONTROLLER
+	public TravelbugMenu mnuTBMenu;
+	// ========== MODEL
+	public TravelBugJourneyScreenModel model;
+
+	/**
+	 * A flag to track whether the current cache has to be saved because a
+	 * travelbug was added to or taken from it.
+	 */
+	// Set to Public to implement MVC-Pattern [AP]
+	public boolean chDmodified = false;
+
+	// =========== MODEL
+	// Set to Public to implement MVC-Pattern [AP]
+	// public TravelbugJourneyList tblMyTravelbugJourneys;
+	/** List of TBs in the current cache */
+	// Set to Public to implement MVC-Pattern [AP]
+	public TravelbugList tblSrcCache;
+	/** The current cache */
+	// Set to Public to implement MVC-Pattern [AP]
+	public CacheHolderDetail chD;
+	/** The base data of the current cache */
+	// Set to Public to implement MVC-Pattern [AP]
+	public CacheHolder ch;
+	/** The name of the current waypoint */
+	// Set to Public to implement MVC-Pattern [AP]
+	public String waypoint = "";
+
+	public TravelbugJourneyScreen(TravelBugJourneyScreenModel newModel) {
+		model = newModel;
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+		// On modern PDAs the splitter is to small to move it with the stylus.
+		// We will make it a littler thicker
+		MyLocale.setSplitterSize(split);
+		CellPanel tablepane = split.getNextPanel();
+		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+		String cache = "";
+		if (curCacheNo >= 0 && curCacheNo < cacheDB.size()) {
+			ch = cacheDB.get(curCacheNo);
+			cache = MyLocale.getMsg(6022, ": Current cache: ") + ch.getWayPoint() + " - " + ch.getCacheName();
+			waypoint = ch.getWayPoint();
+			chD = ch.getCacheDetails(true);
+			tblSrcCache = ch.getCacheDetails(true).Travelbugs;
+		}
+		title = "Travelbugs" + cache;
+		tcTbJourneyList = new tbListControl(model);
+		tcTbJourneyList.setTableModel(modTbJourneyList = new tbListTableModel());
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList, ScrollablePanel.AlwaysShowVerticalScrollers), STRETCH, FILL);
+
+		lowerpane = split.getNextPanel();
+
+		pnlTab = new mTabbedPanel();
+		pnlTab.extraControlsRight = lblNumVisibleJourneys = new mLabel("  0");
+		// ------------------------------------------------
+		// SET Menu
+		// ------------------------------------------------
+		mnuTBMenu = new TravelbugMenu(model);
+		mnuTBMenu.view = this;
+
+		addLast(mnuTBMenu, HSTRETCH, HFILL);
+
+		// ------------------------------------------------
+		// First Tab - Name & Tracking #
+		// ------------------------------------------------
+		CellPanel pnlName = new CellPanel();
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6025, "Name:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpName = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6026, "Tracking #:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpTrackingNo = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6027, "ID/GUID:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(lblId = new mLabel(""), HSTRETCH, HFILL);
+		pnlTab.addCard(pnlName, MyLocale.getMsg(6028, "Name"), "Name");
+
+		// ------------------------------------------------
+		// Second Tab - Where was the TB picked up from
+		// ------------------------------------------------
+		CellPanel pnlFrom = new CellPanel();
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromProfile = new mInput(), HSTRETCH, HFILL);
+		pnlFrom.addLast(inpFromWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030, "Date found:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate = new mButton(new mImage("calendar.png")), DONTSTRETCH, DONTFILL | WEST);
+		btnFromDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addLast(chkFromLogged = new mCheckBox(""), DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged.exitKeys = exitKeys;
+		pnlFrom.addLast(new mLabel(""));
+
+		pnlTab.addCard(pnlFrom, MyLocale.getMsg(6032, "From"), "From");
+
+		// ------------------------------------------------
+		// Third Tab - Where was the TB dropped
+		// ------------------------------------------------
+		CellPanel pnlTo = new CellPanel();
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToProfile = new mInput(), HSTRETCH, HFILL);
+		pnlTo.addLast(inpToWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033, "Date dropped:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpToDate.modifyAll(DisplayOnly,0);
+		pnlTo.addLast(btnToDate = new mButton(new mImage("calendar.png")), DONTSTRETCH, DONTFILL | WEST);
+		btnToDate.modify(0, ControlConstants.TakesKeyFocus);
+		// pnlTo.addLast(new mLabel(""));
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addLast(chkToLogged = new mCheckBox(""), DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged.exitKeys = exitKeys;
+		pnlTo.addLast(new mLabel(""));
+
+		pnlTab.addCard(pnlTo, MyLocale.getMsg(6034, "To"), "To");
+
+		// ------------------------------------------------
+		// Last Panel - TB Mission
+		// ------------------------------------------------
+		CellPanel pnlDest = new CellPanel();
+		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035, "Mission:")));
+		pnlDest.addLast(txtMission = new HtmlDisplay(), STRETCH, FILL);
+		txtMission.rows = 3;
+		pnlTab.addCard(pnlDest, MyLocale.getMsg(6036, "Mission"), "Mission");
+
+		lowerpane.addLast(pnlTab, STRETCH, FILL);
+
+		split.setSplitter(PanelSplitter.AFTER | PanelSplitter.HIDDEN, PanelSplitter.BEFORE | PanelSplitter.HIDDEN, 0);
+		addLast(split, STRETCH, FILL);
+
+		modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+		// Get the columns to display and their widths from preferences
+		modTbJourneyList.columnMap = TableColumnChooser.str2Array(Global.getPref().travelbugColMap, 0, 11, 0, -1);
+		modTbJourneyList.colWidth = TableColumnChooser.str2Array(Global.getPref().travelbugColWidth, 10, 1024, 50, -1);
+		modTbJourneyList.numCols = modTbJourneyList.columnMap.length;
+
+		modTbJourneyList.select(0, 12, true);
+		/* Restore the saved setting about showing only non-logged bugs */
+		if (Global.getPref().travelbugShowOnlyNonLogged) {
+			tcTbJourneyList.toggleNonLogged();
+		}
+		updateNumBugs();
+
+	}
+
+	/** Indicate the number of journeys currently displayed */
+	private void updateNumBugs() {
+		lblNumVisibleJourneys.setText("" + modTbJourneyList.numRows);
+		lblNumVisibleJourneys.repaint();
+	}
+
+	/** The control which had the last focus */
+	private Control currentControl;
+
+	public void onEvent(Event ev) {
+		// Update the table from the input form
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) && selectedRow != -1 && selectedRow < model.allTravelbugJourneys.size()) {
+			TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(selectedRow);
+			if (currentControl == inpName)
+				tbj.getTb().setName(inpName.getText());
+			else if (currentControl == inpTrackingNo)
+				tbj.getTb().setTrackingNo(inpTrackingNo.getText());
+			else if (currentControl == inpFromProfile)
+				tbj.setFromProfile(inpFromProfile.getText());
+			else if (currentControl == inpFromWaypoint)
+				tbj.setFromWaypoint(inpFromWaypoint.getText());
+			else if (currentControl == inpFromDate)
+				tbj.setFromDate(inpFromDate.getText());
+			else if (currentControl == chkFromLogged)
+				tbj.setFromLogged(chkFromLogged.state);
+			else if (currentControl == inpToProfile)
+				tbj.setToProfile(inpToProfile.getText());
+			else if (currentControl == inpToWaypoint)
+				tbj.setToWaypoint(inpToWaypoint.getText());
+			else if (currentControl == inpToDate)
+				tbj.setToDate(inpToDate.getText());
+			else if (currentControl == chkToLogged)
+				tbj.setToLogged(chkToLogged.state);
+			// else if (ev.target==txtMission)
+			// tb.setMission(txtMission.getText());
+			tcTbJourneyList.repaint();
+		}
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED && selectedRow != -1) {
+			if (ev.target == inpTrackingNo) {
+				pnlTab.selectNextTab(true, true);
+				Gui.takeFocus(inpFromProfile, ControlConstants.ByKeyboard);
+				pnlTab.repaint();
+			}
+			if (ev.target == inpFromDate)
+				Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+			if (ev.target == inpToDate)
+				Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+			if (ev.target == btnFromDate || ev.target == btnToDate) {
+				mInput inpDate = ev.target == btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, "Date found");
+				dc.setPreferredSize(240, 240);
+				String foundDate = inpDate.getText();
+				Time t = new Time();
+				try {
+					t.parse(foundDate, "y-M-d H:m");
+				} catch (IllegalArgumentException e) {
+					try {
+						t.parse(foundDate, "y-M-d");
+					} catch (IllegalArgumentException e1) {
+						// Can't parse date - should not happen
+					}
+				}
+				;
+				dc.reset(t);
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpDate.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time);
+					if (ev.target == btnFromDate) {
+						model.allTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
+						Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+					} else {
+						model.allTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
+						Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+					}
+					tcTbJourneyList.repaint();
+				}
+			}
+		}
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.EXITED) {
+			pnlTab.selectNextTab(true, true);
+			if (ev.target == chkFromLogged)
+				Gui.takeFocus(inpToProfile, ControlConstants.ByKeyboard);
+			if (ev.target == chkToLogged)
+				Gui.takeFocus(txtMission, ControlConstants.ByKeyboard);
+		}
+		// The user closed the travelbugs screen
+		if (ev instanceof FormEvent && ev.type == FormEvent.CLOSED && chD != null) {
+			model.allTravelbugJourneys.saveTravelbugsFile();
+			model.allTravelbugJourneys.clear();
+			// Save the flag about showing non-logged journeys only
+			boolean old = Global.getPref().travelbugShowOnlyNonLogged;
+			Global.getPref().travelbugShowOnlyNonLogged = (tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked;
+			String travelbugColWidth = modTbJourneyList.getColWidths();
+			// If the preferences changed, save the pref.xml file
+			Vm.showWait(true);
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) || old != Global.getPref().travelbugShowOnlyNonLogged) {
+				Global.getPref().travelbugColWidth = travelbugColWidth;
+				Global.getPref().savePreferences();
+			}
+			// If the list of travelbugs in the cache was modified, we need to
+			// save the cache too
+			if (chDmodified) {
+				ch.setHas_bugs(chD.Travelbugs.size() > 0);
+				ch.save();
+			}
+			Vm.showWait(false);
+			chD = null;
+		}
+		updateNumBugs();
+		currentControl = Gui.focusedControl();
+	}
+
+	// ==============================================================
+	// tbListTableModel
+	// ==============================================================
+	class tbListTableModel extends TableModel {
+		private FontMetrics fm;
+		private Image imgRed;
+
+		tbListTableModel() {
+
+			fillToEqualHeights = true;
+			allRowsSameSize = true;
+			hasRowHeaders = false;
+			// shadeAlternateRows=true;
+			cursorSize = new Dimension(12, 1);
+			clipData = true;
+			fm = getFontMetrics();
+			// A red dot indicates that the journey has not been completely
+			// logged
+			imgRed = new Image("red.png");
+		}
+
+		private int colWidth[];
+		private int columnMap[];
+
+		public Object getCellText(int row, int col) {
+			return null;
+		}
+
+		public Object getCellData(int row, int col) {
+			if (row == -1) {
+				return TravelbugJourney.getElementNameByNumber(columnMap[col]);
+			} else {
+				int map = columnMap[col];
+				// If we have not yet logged the from or the to, a red dot is
+				// placed in front of the first item
+				if (col == 0 && (!model.allTravelbugJourneys.getTBJourney(row).getFromLogged() || !model.allTravelbugJourneys.getTBJourney(row).getToLogged())) {
+					// Is it a column with a checkbox?
+					if (map != 7 && map != 11)
+						return new IconAndText((IImage) imgRed, (String) model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map), fm);
+					else { // Checkbox - special treatment
+						IconAndText iat = new IconAndText(imgRed, "", fm);
+						iat.addColumn(model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+						return iat;
+					}
+				} else
+					return model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
+			}
+		}
+
+		public int calculateRowHeight(int row) {
+			return charHeight + 2;
+		}
+
+		public int calculateColWidth(int col) {
+			if (col == -1)
+				return 0;
+			else if (col < numCols)
+				return colWidth[columnMap[col]];
+			else
+				return 0;
+		}
+
+		public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
+			ta = super.getCellAttributes(row, col, isSelected, ta);
+			ta.alignment = CellConstants.LEFT;
+			ta.anchor = CellConstants.LEFT;
+			// Color the elements red, if we have not yet logged
+			if (row >= 0)
+				switch (columnMap[col]) {
+				case 6: // fromDate
+					if (!model.allTravelbugJourneys.getTBJourney(row).getFromLogged())
+						ta.foreground = RED;
+					break;
+				case 10: // toDate
+					if (!model.allTravelbugJourneys.getTBJourney(row).getToLogged())
+						ta.foreground = RED;
+					break;
+				}
+			return ta;
+		}
+
+		public void showFields(TravelbugJourney tbj) {
+			inpName.setText(tbj.getTb().getName());
+			inpTrackingNo.setText(tbj.getTb().getTrackingNo());
+			lblId.setText(tbj.getTb().getGuid());
+			inpFromProfile.setText(tbj.getFromProfile());
+			inpFromWaypoint.setText(tbj.getFromWaypoint());
+			inpFromDate.setText(tbj.getFromDate());
+			chkFromLogged.setState(tbj.getFromLogged());
+			inpToProfile.setText(tbj.getToProfile());
+			inpToWaypoint.setText(tbj.getToWaypoint());
+			inpToDate.setText(tbj.getToDate());
+			chkToLogged.setState(tbj.getToLogged());
+			txtMission.setHtml(tbj.getTb().getMission());
+		}
+
+		private boolean sortAsc = false;
+		private int sortedBy = -1;
+		private int lastRow = -1;
+		public int penEventModifiers;
+
+		public boolean penPressed(Point onTable, Point cell) {
+			boolean retval = false;
+			if (cell != null && cell.y == -1) { // Hit a header => sort the
+				// table accordingly
+				Vm.showWait(true);
+				if (cell.x == sortedBy)
+					sortAsc = !sortAsc;
+				else
+					sortAsc = false;
+				sortedBy = cell.x;
+				// Check whether the list only shows non-logged journeys. If so,
+				// a subset
+				// of the table must be sorted
+				if ((tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
+					model.allTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc, modTbJourneyList.numRows);
+				} else { // Showing all journeys - sort the full table
+					model.allTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+				}
+				tcTbJourneyList.repaint();
+				Vm.showWait(false);
+				retval = true;
+			} else if (cell != null && cell.y >= 0 && (penEventModifiers & IKeys.SHIFT) > 0) {
+				// A range of rows can be marked by shift-click on the first and
+				// last row
+				if (lastRow != -1) { // Second row being marked with shift key
+					// pressed
+					if (lastRow < cell.y)
+						toggleSelect(lastRow, cell.y);
+					else
+						toggleSelect(cell.y, lastRow);
+					lastRow = -1;
+					retval = true;
+				} else { // Remember this row as start of range, but don't
+					// toggle yet
+					lastRow = cell.y;
+				}
+			} else { // Single row marked
+				lastRow = -1;
+			}
+			return retval;
+		}
+
+		/** Select a range of rows */
+		private void toggleSelect(int fromRow, int toRow) {
+			tcTbJourneyList.clearSelection(null);
+			tcTbJourneyList.addToSelection(new Rect(0, fromRow, numCols, toRow - fromRow + 1), false, true);
+		}
+
+		/**
+		 * Return the column widths as a comma delimited string for storing in
+		 * the preferences
+		 * 
+		 * @return
+		 */
+		private String getColWidths() {
+			// Update the list with the current widths
+			for (int col = 0; col < numCols; col++) {
+				colWidth[columnMap[col]] = getColWidth(col);
+			}
+			// Convert to string
+			StringBuffer sb = new StringBuffer(40);
+			for (int i = 0; i < colWidth.length; i++) {
+				if (sb.length() != 0)
+					sb.append(',');
+				sb.append(colWidth[i]);
+			}
+			return sb.toString();
+		}
+	}
+
+	// ==============================================================
+	// tbListControl
+	// ==============================================================
+	class tbListControl extends TableControl {
+		private MenuItem mnuNewTB, mnuDeleteTB, mnuGetMission, mnuOpenOnline, mnuDropTB, mnuPickupTB, mnuDeleteTBs;
+		public MenuItem mnuToggleList;
+		private Menu mnuFullMenu, mnuDeleteMenu;
+		private TravelBugJourneyScreenModel tbModel;
+
+		tbListControl(TravelBugJourneyScreenModel tbModel) {
+			this.tbModel = tbModel;
+			MenuItem[] TBMenuItems = new MenuItem[10];
+			TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, "Pick up TB from current cache"));
+			TBMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6041, "Drop TB in cache"));
+			TBMenuItems[2] = new MenuItem("-");
+			TBMenuItems[3] = mnuNewTB = new MenuItem(MyLocale.getMsg(6042, "New Travelbug"));
+			TBMenuItems[4] = mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043, "Delete Travelbug"));
+			TBMenuItems[5] = new MenuItem("-");
+			TBMenuItems[6] = mnuGetMission = new MenuItem(MyLocale.getMsg(6044, "Get Mission"));
+			TBMenuItems[7] = mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045, "Open on-line"));
+			TBMenuItems[8] = new MenuItem("-");
+			TBMenuItems[9] = mnuToggleList = new MenuItem(MyLocale.getMsg(6046, "Show only not logged"));
+			mnuFullMenu = new Menu(TBMenuItems, "");
+			// A second pop-up menu with only one entry, if a range of rows is
+			// selected
+			MenuItem[] TBMenuItemsDel = new MenuItem[1];
+			TBMenuItemsDel[0] = mnuDeleteTBs = new MenuItem(MyLocale.getMsg(6047, "Delete selected Travelbugs"));
+			mnuDeleteMenu = new Menu(TBMenuItemsDel, "");
+			mnuDropTB.modifiers |= MenuItem.Disabled;
+			mnuDeleteTB.modifiers |= MenuItem.Disabled;
+			mnuGetMission.modifiers |= MenuItem.Disabled;
+			mnuOpenOnline.modifiers |= MenuItem.Disabled;
+		}
+
+		public void onEvent(Event ev) {
+			if (ev instanceof PenEvent) {
+				modTbJourneyList.penEventModifiers = ((PenEvent) ev).modifiers;
+			}
+
+			Rect sel = getSelection();
+			if (sel.y < tbModel.allTravelbugJourneys.size()) {
+				mnuDeleteTB.modifiers &= ~MenuItem.Disabled;
+				mnuGetMission.modifiers &= ~MenuItem.Disabled;
+				mnuOpenOnline.modifiers &= ~MenuItem.Disabled;
+				if (tbModel.allTravelbugJourneys.getTBJourney(sel.y).inMyPosession())
+					mnuDropTB.modifiers &= ~MenuItem.Disabled;
+				else
+					mnuDropTB.modifiers |= MenuItem.Disabled;
+			} else {
+				mnuDeleteTB.modifiers |= MenuItem.Disabled;
+				mnuGetMission.modifiers |= MenuItem.Disabled;
+				mnuOpenOnline.modifiers |= MenuItem.Disabled;
+			}
+			// If more than one row is selected, show the limited pop-up menu
+			if (sel.height > 1)
+				setMenu(mnuDeleteMenu);
+			else
+				setMenu(mnuFullMenu);
+			if (ev instanceof PenEvent)
+				modTbJourneyList.penEventModifiers = ((PenEvent) ev).modifiers;
+			super.onEvent(ev);
+		}
+
+		private Rect getSelection() {
+			Rect sel = getSelection(null);
+			return sel;
+		}
+
+		public void penRightReleased(Point p) {
+			menuState.doShowMenu(p, true, null); // direct call (not through
+			// doMenu) is neccesary
+			// because it will exclude
+			// the whole table
+		}
+
+		public void penHeld(Point p) {
+			menuState.doShowMenu(p, true, null);
+		}
+
+		public void popupMenuEvent(Object selectedItem) {
+			if (selectedItem == mnuPickupTB) {
+				Travelbug tb = TravelbugPickup.pickupTravelbug(tblSrcCache);
+				if (tb != null) {
+					chDmodified = true;
+					tbModel.allTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, waypoint);
+					modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+					tcTbJourneyList.repaint();
+				}
+			}
+			if (selectedItem == mnuDropTB) {
+				if (selectedRow >= 0 && selectedRow < modTbJourneyList.numRows) {
+					Travelbug tb = tbModel.allTravelbugJourneys.getTBJourney(selectedRow).getTb();
+					chD.Travelbugs.add(tb);
+					tbModel.allTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, waypoint);
+					chDmodified = true;
+					ch.setHas_bugs(true);
+				}
+				repaint();
+			}
+			if (selectedItem == mnuNewTB) {
+				TravelbugJourney tbj = new TravelbugJourney("New");
+				tbj.setFromProfile(Global.getProfile().name);
+				tbj.setFromWaypoint(waypoint);
+				tbModel.allTravelbugJourneys.add(tbj);
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+				cursorTo(tbModel.allTravelbugJourneys.size() - 1, 1, true);
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuDeleteTB && selectedRow >= 0) {
+				tbModel.allTravelbugJourneys.remove(selectedRow);
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+				if (selectedRow > 0)
+					cursorTo(selectedRow - 1, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(""));
+				tcTbJourneyList.repaint();
+			}
+			/*
+			 * Delete a group of travelbugs which have been marked with
+			 * Shift-Click
+			 */
+			if (selectedItem == mnuDeleteTBs) {
+				Rect sel = getSelection();
+				for (int i = 0; i < sel.height; i++)
+					tbModel.allTravelbugJourneys.remove(sel.y);
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+				if (sel.y < modTbJourneyList.numRows)
+					cursorTo(sel.y, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(""));
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuGetMission && selectedRow > -1) {
+				TravelbugJourney tbj = tbModel.allTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+
+				// if we have an ID, get mission by ID
+				if (tbj.getTb().getGuid().length() != 0) {
+					tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+				} else {
+					// try to get mission and name by tracking number
+					boolean suceeded = false;
+					if (tbj.getTb().getTrackingNo().length() != 0) {
+						suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+					}
+					// if this has't worked, try to get ID by name
+					if (!suceeded) {
+						tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+						// if we have an ID now, get mission by ID
+						if (tbj.getTb().getGuid().length() != 0) {
+							tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+						}
+					}
+				}
+
+				Vm.showWait(false);
+				tcTbJourneyList.repaint();
+				txtMission.setHtml(tbj.getTb().getMission());
+				inpName.setText(tbj.getTb().getName());
+				lblId.setText(tbj.getTb().getGuid());
+				lowerpane.repaint();
+				Global.getPref().setOldGCLanguage();
+			}
+			if (selectedItem == mnuOpenOnline && selectedRow >= 0) {
+				TravelbugJourney tbj = tbModel.allTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+				// First check whether ID is set, if not get it
+				if (tbj.getTb().getGuid().length() == 0)
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+				if (tbj.getTb().getGuid().length() != 0) {
+					Vm.showWait(false);
+					try {
+						String s;
+						if (tbj.getTb().getGuid().length() > 10)
+							s = "http://www.geocaching.com/track/details.aspx?guid=" + tbj.getTb().getGuid();
+						else
+							s = "http://www.geocaching.com/track/details.aspx?id=" + tbj.getTb().getGuid();
+
+						CWWrapper.exec(Global.getPref().browser, s);
+						Global.getPref().log("Executed: \"" + Global.getPref().browser + "\" \"" + s + "\"");
+					} catch (Exception ioex) {
+						Global.getPref().log("Ignored Exception", ioex, true);
+					}
+				}
+			}
+			if (selectedItem == mnuToggleList) {
+				toggleNonLogged();
+			}
+			updateNumBugs();
+			Global.getPref().setOldGCLanguage();
+		}
+
+		/**
+		 * Toggle between displaying all journeys or just those which still need
+		 * to be logged
+		 */
+		public void toggleNonLogged() {
+			mnuToggleList.modifiers ^= MenuItem.Checked;
+			if ((mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
+				// First sort the non-logged items to the top
+				tbModel.allTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
+				// modListTable.numRows=tblMyTravelbugJourneys.size();
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.countNonLogged();
+			} else {
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+			}
+			tcTbJourneyList.repaint();
+		}
+
+		public void cursorTo(int row, int col, boolean selectNew) {
+			super.cursorTo(row, col, selectNew);
+			selectedRow = row;
+			if (row >= 0) {
+				modTbJourneyList.showFields(tbModel.allTravelbugJourneys.getTBJourney(row));
+			} else {
+				modTbJourneyList.showFields(new TravelbugJourney(""));
+			}
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,177 @@
+package CacheWolf.view.ewe;
+
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugPickup;
+import CacheWolf.imp.SpiderGC;
+import CacheWolf.model.DefaultListModel;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import CacheWolf.utils.CWWrapper;
+import ewe.fx.Rect;
+import ewe.sys.Vm;
+import ewe.ui.Event;
+import ewe.ui.Menu;
+import ewe.ui.MenuBar;
+import ewe.ui.MenuEvent;
+import ewe.ui.MenuItem;
+import ewe.ui.PullDownMenu;
+
+/**
+ * Controller for the {@link TravelbugList}. Preferrably used by {@link TravelbugJourneyScreen}
+ * 
+ * @author andi
+ * 
+ */
+public class TravelbugMenu extends MenuBar {
+	private MenuItem mnuNewTB;
+	private MenuItem mnuDeleteTB;
+	private MenuItem mnuGetMission;
+	private MenuItem mnuOpenOnline;
+	private MenuItem mnuDropTB;
+	private MenuItem mnuPickupTB;
+	private MenuItem mnuDeleteTBs;
+
+	/**
+	 * The model controlled by this
+	 */
+	/**
+	 * The View displaying the model for this
+	 */
+	public TravelbugJourneyScreen view;
+	private TravelBugJourneyScreenModel model;
+
+	public TravelbugMenu(TravelBugJourneyScreenModel model) {
+		this.model = model;
+		MenuItem[] TBMenuItems = new MenuItem[9];
+		TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, "Pick up TB from current cache"));
+		TBMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6041, "Drop TB in cache"));
+		TBMenuItems[2] = new MenuItem("-");
+		TBMenuItems[3] = mnuNewTB = new MenuItem(MyLocale.getMsg(6042, "New Travelbug"));
+		TBMenuItems[4] = mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043, "Delete Travelbug"));
+		TBMenuItems[5] = new MenuItem("-");
+		TBMenuItems[6] = mnuGetMission = new MenuItem(MyLocale.getMsg(6044, "Get Mission"));
+		TBMenuItems[7] = mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045, "Open on-line"));
+		TBMenuItems[8] = new MenuItem("-");
+		// A second pop-up menu with only one entry, if a range of rows is
+		// selected
+		MenuItem[] TBMenuItemsDel = new MenuItem[1];
+		TBMenuItemsDel[0] = mnuDeleteTBs = new MenuItem(MyLocale.getMsg(6047, "Delete selected Travelbugs"));
+		// mnuDropTB.modifiers |= MenuItem.Disabled;
+		// mnuDeleteTB.modifiers |= MenuItem.Disabled;
+		// mnuGetMission.modifiers |= MenuItem.Disabled;
+		// mnuOpenOnline.modifiers |= MenuItem.Disabled;
+
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(120, "Application"), new Menu(TBMenuItems, null)));
+
+	}
+
+	public void onEvent(Event event) {
+		if (event instanceof MenuEvent) {
+			MenuEvent mev = (MenuEvent) event;
+			if (mev.selectedItem == mnuPickupTB) {
+				Travelbug tb = TravelbugPickup.pickupTravelbug(view.tblSrcCache);
+				if (tb != null) {
+					view.chDmodified = true;
+					model.allTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, view.waypoint);
+					view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+					view.repaint();
+				}
+
+			} else if (mev.selectedItem == mnuDropTB) {
+				if (view.selectedRow >= 0 && view.selectedRow < view.modTbJourneyList.numRows) {
+					Travelbug tb = model.allTravelbugJourneys.getTBJourney(view.selectedRow).getTb();
+					view.chD.Travelbugs.add(tb);
+					model.allTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, view.waypoint);
+					view.chDmodified = true;
+					view.ch.setHas_bugs(true);
+				}
+				view.repaint();
+			} else if (mev.selectedItem == mnuNewTB) {
+				TravelbugJourney tbj = new TravelbugJourney("New");
+				tbj.setFromProfile(Global.getProfile().name);
+				tbj.setFromWaypoint(view.waypoint);
+				model.allTravelbugJourneys.add(tbj);
+				view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+				// view.cursorTo(view.tblMyTravelbugJourneys.size()-1,1,true);
+				view.repaint();
+			} else if (mev.selectedItem == mnuDeleteTB && view.selectedRow >= 0) {
+				model.allTravelbugJourneys.remove(view.selectedRow);
+				view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+				if (view.selectedRow > 0) {
+					// cursorTo(view.selectedRow-1,0,true);
+				} else {
+					// view.modTbJourneyList.showFields(new
+					// TravelbugJourney(""));
+				}
+				view.repaint();
+			}
+			/*
+			 * Delete a group of travelbugs which have been marked with
+			 * Shift-Click
+			 */
+			if (mev.selectedItem == mnuDeleteTBs) {
+				Rect sel = view.tcTbJourneyList.getSelection(null);
+				for (int i = 0; i < sel.height; i++)
+					model.allTravelbugJourneys.remove(sel.y);
+				view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+				if (sel.y < view.modTbJourneyList.numRows) {
+					// cursorTo(sel.y,0,true);
+				} else {
+					view.modTbJourneyList.showFields(new TravelbugJourney(""));
+				}
+				view.repaint();
+			} else if (mev.selectedItem == mnuGetMission && view.selectedRow > -1) {
+				TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(view.selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+
+				// if we have an ID, get mission by ID
+				if (tbj.getTb().getGuid().length() != 0) {
+					tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+				} else {
+					// try to get mission and name by tracking number
+					boolean suceeded = false;
+					if (tbj.getTb().getTrackingNo().length() != 0) {
+						suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+					}
+					// if this has't worked, try to get ID by name
+					if (!suceeded) {
+						tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+						// if we have an ID now, get mission by ID
+						if (tbj.getTb().getGuid().length() != 0) {
+							tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+						}
+					}
+				}
+				Global.getPref().setOldGCLanguage();
+			} else if (mev.selectedItem == mnuOpenOnline && view.selectedRow >= 0) {
+				TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(view.selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+				// First check whether ID is set, if not get it
+				if (tbj.getTb().getGuid().length() == 0)
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+				if (tbj.getTb().getGuid().length() != 0) {
+					Vm.showWait(false);
+					try {
+						String s;
+						if (tbj.getTb().getGuid().length() > 10)
+							s = "http://www.geocaching.com/track/details.aspx?guid=" + tbj.getTb().getGuid();
+						else
+							s = "http://www.geocaching.com/track/details.aspx?id=" + tbj.getTb().getGuid();
+
+						CWWrapper.exec(Global.getPref().browser, s);
+						Global.getPref().log("Executed: \"" + Global.getPref().browser + "\" \"" + s + "\"");
+					} catch (Exception ioex) {
+						Global.getPref().log("Ignored Exception", ioex, true);
+					}
+				}
+				Global.getPref().setOldGCLanguage();
+			}
+
+		}
+	}
+}


Property changes on: branches/r1.2/src/CacheWolf/view/pda
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,253 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.fx.Rect;
+import ewe.sys.Convert;
+import ewe.sys.Time;
+import ewe.ui.CellPanel;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.ui.Gui;
+import ewe.ui.Panel;
+import ewe.ui.mButton;
+import ewe.ui.mLabel;
+import ewe.util.Grid;
+
+public class PDADateTimeChooser extends Form  {
+
+	private int year; 
+	private int month; 
+	private int day; 
+
+	private int hour; 
+	public int getHour() {
+		return hour;
+	}
+
+	public int getMinute() {
+		return minute;
+	}
+
+	private int minute; 
+
+	private	mLabel lbDay;
+	private mLabel lbMonth;
+	private mLabel lbYear;
+	private mLabel lbHour;
+	private mLabel lbMinute;
+	private mLabel lbSep;
+	
+	private mButton btDayUp;
+	private mButton btMonthUp;
+	private mButton btYearUp;
+	private mButton btHourUp;
+	private mButton btMinuteUp;
+
+	private mButton btDayDown;
+	private mButton btMonthDown;
+	private mButton btYearDown;
+	private mButton btHourDown;
+	private mButton btMinuteDown;
+
+	private mButton btSet;
+	private mButton btTime;
+	private mButton btCalendar;
+	private mButton btCancel;
+
+	public PDADateTimeChooser (){
+		int screenWidth = MyLocale.getScreenWidth();
+		String string = "SET TIME CANCEL";
+		int fontsize =  screenWidth/string.length();
+		Rect size = Gui.getSize(getFontMetrics(), string, 5,0);
+		while (size.width < screenWidth) {
+			fontsize += 5;
+			font = new Font(getFont().getName(), Font.BOLD,fontsize);
+			size = Gui.getSize(getFontMetrics(), string, 5, 0);
+		}
+
+		backGround = Color.White;
+
+		lbDay = new mLabel("");
+		lbDay.anchor=mLabel.CENTER;
+		lbMonth = new mLabel ("");
+		lbMonth.anchor=mLabel.CENTER;
+		lbYear = new mLabel ("");
+		lbYear.anchor=mLabel.CENTER;
+		lbHour = new mLabel ("HH");
+		lbHour.anchor=mLabel.CENTER;
+		lbSep = new mLabel(":");
+		lbMinute = new mLabel ("MM");
+		lbMinute.anchor=mLabel.CENTER;
+
+		btDayUp = new mButton (" ^^ ");btDayUp.backGround=Color.LightBlue;
+		btMonthUp = new mButton (" ^^ ");btMonthUp.backGround=Color.LightBlue;
+		btYearUp = new mButton ("  ^^  ");btYearUp.backGround=Color.LightBlue;
+		btHourUp = new mButton ("  ^^  ");btHourUp.backGround=Color.LightBlue;
+		btMinuteUp = new mButton ("  ^^  ");btMinuteUp.backGround=Color.LightBlue;
+
+		btDayDown = new mButton ("vv");btDayDown.backGround=Color.LightBlue;
+		btMonthDown = new mButton ("vv");btMonthDown.backGround=Color.LightBlue;
+		btYearDown = new mButton (" vv ");btYearDown.backGround=Color.LightBlue;
+		btHourDown = new mButton (" vv ");btHourDown.backGround=Color.LightBlue;
+		btMinuteDown = new mButton (" vv ");btMinuteDown.backGround=Color.LightBlue;
+		
+		btSet = new mButton ("Set");btSet.backGround=Color.Sand;
+		btTime = new mButton ("Time");btTime.backGround=Color.Sand;
+		btCalendar  = new mButton("Cal");btCalendar.backGround=Color.Sand;
+		btCancel = new mButton ("Cancel");btCancel.backGround=Color.Sand;
+
+		layoutCalendar();
+		
+		addListener(this);
+	}
+
+	
+	private void layoutCalendar() {
+		removeAll();
+		addNext (lbDay,HSTRETCH,HFILL);
+		addNext (lbMonth,HSTRETCH,HFILL);
+		addLast (lbYear,HSTRETCH,HFILL);
+
+		addNext (btDayUp,HSTRETCH,HFILL);
+		addNext (btMonthUp,HSTRETCH,HFILL);
+		addLast (btYearUp,HSTRETCH,HFILL);
+
+		addNext (btDayDown,HSTRETCH,HFILL);
+		addNext (btMonthDown,HSTRETCH,HFILL);
+		addLast (btYearDown,HSTRETCH,HFILL);
+		
+		addNext (btSet, HSTRETCH,CENTER|HFILL);
+		addNext (btTime, HSTRETCH,CENTER|HFILL);
+		addLast (btCancel, HSTRETCH,CENTER|HFILL);
+	}
+	
+	private void layoutTime() {
+		removeAll ();
+		Panel p = new CellPanel();
+		p.addNext (lbHour, HSTRETCH,HFILL);
+		p.addNext (lbSep,DONTSTRETCH,DONTFILL);
+		p.addLast (lbMinute, HSTRETCH,CENTER);
+		p.addNext (btHourUp, HSTRETCH,HFILL);
+		p.addNext(new mLabel(""));
+		p.addLast (btMinuteUp, HSTRETCH,HFILL);
+		p.addNext (btHourDown, HSTRETCH,HFILL);
+		p.addNext(new mLabel(""));
+		p.addLast (btMinuteDown, HSTRETCH,HFILL);
+		
+		addLast (p, HSTRETCH,HFILL);
+
+		Panel p1 = new CellPanel();
+		p1.addNext(btSet, HSTRETCH,CENTER|HFILL);
+		p1.addNext(btCalendar, HSTRETCH,CENTER|HFILL);
+		p1.addLast(btCancel, HSTRETCH,CENTER|HFILL);
+		addLast (p1, HSTRETCH,CENTER|HFILL);
+	}
+
+	public int getDay() {
+		return day;
+	}
+
+	public int getMonth() {
+		return month;
+	}
+
+	public String getTime() {
+		return Convert.toString(year) + "-" + MyLocale.formatLong(month, "00") + "-"
+		+ MyLocale.formatLong(day, "00") + " " + MyLocale.formatLong(hour, "00") +
+		":"+MyLocale.formatLong(minute, "00");
+	}
+
+	public int getYear() {
+		return year;
+	}
+
+	public void reset(Time t) {
+		year = t.year;
+		month = t.month;
+		day = t.day;
+		hour = t.hour;
+		minute=t.minute;
+
+		lbDay.setText(Integer.toString(day));
+		lbMonth.setText(Integer.toString(month));
+		lbYear.setText(Integer.toString(year));
+		lbHour.setText(Integer.toString(hour));
+		lbMinute.setText(MyLocale.formatLong(minute, "00"));
+	}
+	
+	public void onControlEvent(ControlEvent ev) {
+		switch (ev.type) {
+		case ControlEvent.PRESSED:
+			if (ev.target == btDayUp && day < 31) {
+				day++;
+				lbDay.setText(Integer.toString(day));
+			}
+			else if (ev.target == btDayDown && day > 1){
+				day--;
+				lbDay.setText(Integer.toString(day));
+			}
+			
+			else if (ev.target == btMonthUp && month < 12){
+				month++;
+				lbMonth.setText(Integer.toString(month));
+			}
+			else if (ev.target == btMonthDown && month > 1){
+				month--;
+				lbMonth.setText(Integer.toString(month));
+			}
+
+			else if (ev.target == btYearUp){
+				year++;
+				lbYear.setText(Integer.toString(year));
+			}
+			else if (ev.target == btYearDown){
+				year--;
+				lbYear.setText(Integer.toString(year));
+			}
+			
+			else if (ev.target == btHourUp && hour < 23){
+				hour++;
+				lbHour.setText(Integer.toString(hour));
+			}
+			else if (ev.target == btHourDown && hour > 0){
+				hour--;
+				lbHour.setText(Integer.toString(hour));
+			}
+			else if (ev.target == btMinuteUp && minute < 59){
+				minute++;
+				lbMinute.setText(MyLocale.formatLong(minute, "00"));
+			}
+			else if (ev.target == btMinuteDown && minute > 0){
+				minute--;
+				lbMinute.setText(MyLocale.formatLong(minute, "00"));
+			}
+
+			else if (ev.target == btSet){
+				exit(IDOK);
+			}
+			else if (ev.target == btTime){
+				Gui.flashMessage("Uhrzeit anzeigen", 1000, this, 0);
+				made=false;
+				layoutTime();
+				make(true);
+				relayoutMe(true);
+				reShow(0,0,width,height);
+			}
+			else if (ev.target == btCalendar){
+				Gui.flashMessage("Calendar anzeigen!", 1000, this, 0);
+				made=false;
+				layoutCalendar();
+				make(true);
+				relayoutMe(true);
+				reShow(0,0,width,height);				
+			}
+			else if (ev.target == btCancel){
+				exit(IDNO);
+			}
+			
+		}
+		super.onControlEvent(ev);
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,7 @@
+package CacheWolf.view.pda;
+
+import ewe.ui.mButton;
+
+public class PDAEmptyButton extends mButton {
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAList.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAList.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,87 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.model.DefaultListModel;
+import ewe.sys.Vm;
+import ewe.ui.CellConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.util.Vector;
+
+public abstract class PDAList extends Form {
+	protected static final String LINE = "Line";
+
+	protected static final String NEXT_PAGE = "NextPage";
+
+	protected static final String PREV_PAGE = "PrevPage";
+
+	protected static final String MENUE = "Menue";
+
+	public DefaultListModel model;
+	private int linesOnScreen=7;
+	PDAListButton[] listButtons;
+	protected int firstLine;
+
+	public PDAList() {
+		listButtons = new PDAListButton[linesOnScreen];
+		//Show Full Screen
+		setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
+		addListener(this);
+		setTitle("Liste");
+
+		firstLine = 0;
+		for (int i = 0; i < linesOnScreen; i++) {
+			listButtons[i] = new PDAListButton("", LINE + i);
+			addLast(listButtons[i], CellConstants.STRETCH, CellConstants.FILL);
+		}
+		setupTBButtons();
+		PDAMenuButton b1 = new PDAMenuButton("<<<", PREV_PAGE);
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(MyLocale.getMsg(6052, "MENU"), MENUE);
+		b1.anchor = 0;
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(">>>", NEXT_PAGE);
+		b1.anchor = CellConstants.EAST;
+		addLast(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+	}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) && model.size() > firstLine + linesOnScreen) {
+					firstLine += linesOnScreen;
+					setupTBButtons();
+				} else if (ev.action.equals(PREV_PAGE) && firstLine > 0) {
+					firstLine -= linesOnScreen;
+					if (firstLine < 0) {
+						firstLine = 0;
+					}
+					setupTBButtons();
+				} else if (ev.action.startsWith(LINE)) {
+					int line = ev.action.charAt(LINE.length()) - '0';
+					Object clickedItem =  model.get(line + firstLine);
+					Vm.debug("List clicked: " + clickedItem);
+				} else if (ev.action.equals(MENUE)) {
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public void setupTBButtons() {
+		for (int i = 0; i < linesOnScreen; i++) {
+			if (model != null && i + firstLine < model.size()) {
+				Object modelElement = model.get(i + firstLine);
+				listButtons[i].text = modelElement.toString();
+			} else {
+				listButtons[i].text = listButtons[i].fromText = listButtons[i].toText = "";
+			}
+			listButtons[i].repaint();
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,34 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.ui.CellConstants;
+import ewe.ui.mButton;
+
+public class PDAListButton extends mButton {
+
+	public String fromText;
+	public String toText;
+	public boolean toLogged;
+	public boolean fromLogged;
+	
+	public PDAListButton(String newText, String newAction) {
+		super(newText);
+		action = newAction;
+		buttonObject = new PDAListButtonObject(this);
+
+		backGround = Color.White;
+		foreGround = Color.Black;
+
+		font = new Font(getFont().getName(), Font.BOLD, 40);
+		anchor = CellConstants.WEST;
+		textPosition=2;
+	}
+
+	public void make(boolean paramBoolean) {
+		if (this.buttonObject != null)
+			return;
+		this.buttonObject = new PDAListButtonObject(this);
+	}
+	
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,58 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.fx.Graphics;
+import ewe.fx.Rect;
+import ewe.ui.ButtonObject;
+
+public class PDAListButtonObject extends ButtonObject {
+	private PDAListButton pdaListButton;
+
+	public PDAListButtonObject(PDAListButton pdaListButton) {
+		super(pdaListButton);
+		this.pdaListButton = pdaListButton;
+	}
+
+	public void paint(Graphics paramGraphics) {
+		if ((this.soft) && (this.control != null))
+			this.control.doBackground(paramGraphics);
+		if (this.text == null)
+			this.text = "";
+		drawButton(paramGraphics);
+		Rect localRect1 = paramGraphics.reduceClip(new Rect(this.borderWidth, this.borderWidth, this.size.width
+				- (this.borderWidth * 2), this.size.height - (this.borderWidth * 2)));
+		try {
+			paramGraphics.setColor(foreground);
+			int x = 10;
+			if (this.image != null) {
+				int y = (size.height - image.getHeight()) / 2;
+				this.image.draw(paramGraphics, 10, y, 0);
+				x += image.getWidth();
+				x += 10;
+			}
+			paramGraphics.setFont(this.font);
+			paramGraphics.drawText(text, x, 10);
+			Font tmpFont = new Font(font.getName(), Font.BOLD, 20);
+			paramGraphics.setFont(tmpFont);
+			if (pdaListButton.fromText != null) {
+				paramGraphics.drawText(pdaListButton.fromText, x + 15, 45);
+			}
+			if (!pdaListButton.fromLogged) {
+				paramGraphics.setColor(new Color(255, 0, 0));
+				paramGraphics.fillEllipse(x, 50, 10, 10);
+				paramGraphics.setColor(foreground);
+			}
+			if (pdaListButton.toText != null) {
+				paramGraphics.drawText(pdaListButton.toText, x + 15, 70);
+			}
+			if (!pdaListButton.toLogged) {
+				paramGraphics.setColor(new Color(255, 0, 0));
+				paramGraphics.fillEllipse(x, 75, 10, 10);
+				paramGraphics.setColor(foreground);
+			}
+		} finally {
+			paramGraphics.restoreClip(localRect1);
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+
+public abstract class PDAMenu extends Form {
+
+	protected static final String CANCEL = "__Cancel_Exit__";
+
+	public abstract void actionPerformed(String actionCommand);
+
+	public PDAMenu(){
+		setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
+	}
+	
+	public void onControlEvent(ControlEvent paramEvent) {
+		switch (paramEvent.type) {
+		case ControlEvent.PRESSED:
+			if (paramEvent.action.equals(CANCEL)) {
+				exit(0);
+				
+			} else {
+				actionPerformed(paramEvent.action);
+			}
+		}
+		super.onControlEvent(paramEvent);
+	}
+
+	protected void buildMenu() {
+		PDAMenuButton button = new PDAMenuButton(MyLocale.getMsg(6057, "Back"), CANCEL);
+		addLast(button);
+	}
+
+	protected void addMenuItem(String item, String actionCommand) {
+		PDAMenuButton button = new PDAMenuButton(item, actionCommand);
+		addLast(button);
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,35 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.ui.CellConstants;
+import ewe.ui.mButton;
+
+public class PDAMenuButton extends mButton {
+
+	public String fromText;
+	public String toText;
+	public boolean toLogged;
+	public boolean fromLogged;
+
+	public PDAMenuButton(String newText, String newAction) {
+		super(newText);
+		action = newAction;
+
+		minHeight = 200;
+		preferredHeight=200;
+		maxHeight=200;
+		backGround = Color.Sand;
+		foreGround = Color.Black;
+
+		font = new Font(getFont().getName(), Font.BOLD, 40);
+		anchor = CellConstants.WEST;
+		textPosition = 2;
+	}
+	
+	public void make(boolean paramBoolean) {
+		if (this.buttonObject != null)
+			return;
+		this.buttonObject = new PDAMenuButtonObject(this);
+	}
+}
\ No newline at end of file

Added: branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,24 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Dimension;
+import ewe.ui.ButtonObject;
+
+public class PDAMenuButtonObject extends ButtonObject{
+	private PDAMenuButton pdaMenuButton;
+	private Dimension calculateSize;
+
+	public PDAMenuButtonObject(PDAMenuButton pdaListButton) {
+		super(pdaListButton);
+		this.pdaMenuButton = pdaListButton;
+	}
+
+	  public Dimension calculateSize(Dimension paramDimension){
+		  calculateSize = super.calculateSize(paramDimension);
+		  if (calculateSize.height < 100){
+			  calculateSize.height=100;
+			  paramDimension.height=100;
+		  }
+		  return calculateSize;
+	  }
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,49 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.Preferences;
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.ui.Frame;
+import ewe.ui.Gui;
+import ewe.ui.mLabel;
+
+public class PDAOptionPane extends Form {
+	public static final int CANCEL = 0;
+	public static final int OK = 1;
+	private static final String OK_STR = "OK";
+	private static final String CANCEL_STR = "CANCEL";
+
+	private int result = CANCEL;
+
+	public static int showConfirmDialog(Frame parent, String title, String message) {
+		PDAOptionPane pane = new PDAOptionPane();
+		pane.title = title;
+		pane.backGround=new Color(255,128,128);
+		Font tmpFont = new Font("Helvetica", Font.BOLD, Preferences.getPrefObject().fontSize * 2);
+		mLabel messageLabel = new mLabel(message);
+		messageLabel.font=tmpFont;
+		pane.addLast(messageLabel, HFILL, HSTRETCH);
+		PDAMenuButton button = new PDAMenuButton("OK", OK_STR);
+		pane.addNext(button, FILL, STRETCH);
+		button = new PDAMenuButton("Abbruch", CANCEL_STR);
+		pane.addLast(button, FILL, STRETCH);
+		pane.setLocation(0, 0);
+		pane.execute(null, Gui.FILL_FRAME);
+		return pane.result;
+	}
+
+	public void onControlEvent(ControlEvent event) {
+		switch (event.type) {
+		case ControlEvent.PRESSED:
+			String action = event.action;
+			if (action.equals(OK_STR)) {
+				result = OK;
+				exit(0);
+			} else if (action.equals(CANCEL_STR)) {
+				exit(0);
+			}
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,188 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.imp.SpiderGC;
+import CacheWolf.utils.CWWrapper;
+import ewe.sys.Vm;
+
+public class PDATravelbugDetailMenu extends PDAMenu {
+
+	private static final String BROWSER = "browser";
+
+	private static final String SPIDER = "spider";
+
+	private static final String DELETE = "delete";
+
+	private static final String EXIT = "exit";
+
+	private static final String DROP = "drop";
+
+	private PDATravelbugDetailPanel view;
+
+	private PDATravelbugJourneyScreen journeyScreen;
+
+	public PDATravelbugDetailMenu(PDATravelbugDetailPanel view, PDATravelbugJourneyScreen journeyScreen) {
+		this.view = view;
+		this.journeyScreen = journeyScreen;
+
+		setTitle("TravelBugDetail - Menu");
+
+		addMenuItem(MyLocale.getMsg(6041, "Drop TB in cache"), DROP);
+		addMenuItem(MyLocale.getMsg(6044, "Get mission (and name)"), SPIDER);
+		addMenuItem(MyLocale.getMsg(6045, "Open on-line"), BROWSER);
+		addMenuItem(MyLocale.getMsg(6043, "Delete Travelbug"), DELETE);
+		addMenuItem(MyLocale.getMsg(6061, "Close"), EXIT);
+
+		buildMenu();
+
+	}
+
+	public void actionPerformed(String action) {
+		if (action.equals(DROP)) {
+			Travelbug tb = view.getTravelbug().getTb();
+			int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+			CacheDB cacheDB = Global.getProfile().cacheDB;
+			if (curCacheNo >= 0 && curCacheNo < cacheDB.size()) {
+				CacheHolder ch = cacheDB.get(curCacheNo);
+				CacheHolderDetail cacheDetails = ch.getCacheDetails(true);
+				cacheDetails.Travelbugs.add(tb);
+				journeyScreen.model.allTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, ch.getWayPoint());
+				ch.setHas_bugs(true);
+				ch.save();
+				// Set Input fields to the new Values:
+				view.getInpToWaypoint().setText(view.getTravelbug().getToWaypoint());
+				view.getInpToProfile().setText(view.getTravelbug().getToProfile());
+				view.getInpToDate().setText(view.getTravelbug().getToDate());
+				// Save now. The action won't recognize the changes:
+				journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+			}
+			journeyScreen.setupTBButtons();
+			exit(0);
+		} else if (action.equals(BROWSER)) {
+			SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+			Vm.showWait(true);
+			// First check whether ID is set, if not get it
+			Travelbug tb = view.getTravelbug().getTb();
+			if (tb.getGuid().length() == 0) {
+				tb.setGuid(spider.getBugId(tb.getName()));
+			}
+			if (tb.getGuid().length() != 0) {
+				Vm.showWait(false);
+				try {
+					String s;
+					if (tb.getGuid().length() > 10)
+						s = "http://www.geocaching.com/track/details.aspx?guid=" + tb.getGuid();
+					else
+						s = "http://www.geocaching.com/track/details.aspx?id=" + tb.getGuid();
+
+					CWWrapper.exec(Global.getPref().browser, s);
+					Global.getPref().log("Executed: \"" + Global.getPref().browser + "\" \"" + s + "\"");
+				} catch (Exception ioex) {
+					Global.getPref().log("Ignored Exception", ioex, true);
+				}
+			}
+			Global.getPref().setOldGCLanguage();
+			exit(0);
+		} else if (action.equals(SPIDER)) {
+			Travelbug tb = view.getTravelbug().getTb();
+			SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+			Vm.showWait(true);
+
+			// if we have an ID, get mission by ID
+			if (tb.getGuid().length() != 0) {
+				tb.setMission(spider.getBugMissionByGuid(tb.getGuid()));
+			} else {
+				// try to get mission and name by tracking number
+				boolean suceeded = false;
+				if (tb.getTrackingNo().length() != 0) {
+					suceeded = spider.getBugMissionAndNameByTrackNr(tb);
+				}
+				// if this has't worked, try to get ID by name
+				if (!suceeded) {
+					tb.setGuid(spider.getBugId(tb.getName().trim()));
+					// if we have an ID now, get mission by ID
+					if (tb.getGuid().length() != 0) {
+						tb.setMission(spider.getBugMissionByGuid(tb.getGuid()));
+					}
+				}
+			}
+			journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+			Vm.showWait(false);
+			Global.getPref().setOldGCLanguage();
+			exit(0);
+		} else if (action.equals(DELETE)) {
+			// LOESCHEN DES TB's aus der Datenbank ist Boese!!!
+			// Erst mal eine Sicherheitesabfrage bauen:
+			int r = PDAOptionPane.showConfirmDialog(this.getFrame(), "Sind Sie Sicher???", "Wollen Sie wirklich den TB l?schen??");
+			if (r == PDAOptionPane.OK) {
+				for (int i = 0; i < journeyScreen.model.allTravelbugJourneys.size(); i++) {
+					TravelbugJourney tbJourney = journeyScreen.model.allTravelbugJourneys.getTBJourney(i);
+					if (tbJourney.getTb().getTrackingNo().equals(view.getTravelbug().getTb().getTrackingNo())) {
+						journeyScreen.model.allTravelbugJourneys.remove(i);
+						journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+						journeyScreen.setupTBButtons();
+						break;
+					}
+				}
+			}
+		} else if (action.equals(EXIT)) {
+			boolean changed = false;
+			if (!view.getInpName().text.equals(view.getTravelbug().getTb().getName())) {
+				view.getTravelbug().getTb().setName(view.getInpName().text);
+				changed = true;
+			}
+			if (!view.getInpTrackingNo().text.equals(view.getTravelbug().getTb().getTrackingNo())) {
+				view.getTravelbug().getTb().setTrackingNo(view.getInpTrackingNo().text);
+				changed = true;
+			}
+
+			if (!view.getInpFromProfile().text.equals(view.getTravelbug().getFromProfile())) {
+				view.getTravelbug().setFromProfile(view.getInpFromProfile().text);
+				changed = true;
+			}
+			if (!view.getInpFromWaypoint().text.equals(view.getTravelbug().getFromWaypoint())) {
+				view.getTravelbug().setFromWaypoint(view.getInpFromWaypoint().text);
+				changed = true;
+			}
+			if (!view.getInpFromDate().text.equals(view.getTravelbug().getFromDate())) {
+				view.getTravelbug().setFromDate(view.getInpFromDate().text);
+				changed = true;
+			}
+			if (view.getTravelbug().getFromLogged() != view.getChkFromLogged().state) {
+				view.getTravelbug().setFromLogged(view.getChkFromLogged().state);
+				changed = true;
+			}
+
+			if (!view.getInpToProfile().text.equals(view.getTravelbug().getToProfile())) {
+				view.getTravelbug().setToProfile(view.getInpToProfile().text);
+				changed = true;
+			}
+			if (!view.getInpToWaypoint().text.equals(view.getTravelbug().getToWaypoint())) {
+				view.getTravelbug().setToWaypoint(view.getInpToWaypoint().text);
+				changed = true;
+			}
+			if (!view.getInpToDate().text.equals(view.getTravelbug().getToDate())) {
+				view.getTravelbug().setToDate(view.getInpToDate().text);
+				changed = true;
+			}
+			if (view.getTravelbug().getToLogged() != view.getChkToLogged().state) {
+				view.getTravelbug().setToLogged(view.getChkToLogged().state);
+				changed = true;
+			}
+
+			if (changed) {
+				journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+				journeyScreen.createShowSet();
+			}
+
+			exit(1);
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,295 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.TravelbugJourney;
+import ewe.fx.Color;
+import ewe.fx.Dimension;
+import ewe.fx.Font;
+import ewe.fx.mImage;
+import ewe.sys.Convert;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.CardPanel;
+import ewe.ui.CellConstants;
+import ewe.ui.CellPanel;
+import ewe.ui.ControlConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.ui.Gui;
+import ewe.ui.HtmlDisplay;
+import ewe.ui.SipButton;
+import ewe.ui.WindowConstants;
+import ewe.ui.mButton;
+import ewe.ui.mCheckBox;
+import ewe.ui.mInput;
+import ewe.ui.mLabel;
+
+public class PDATravelbugDetailPanel extends Form {
+
+	private static final int BOXWIDTH = 40;
+
+	private static final String MENUE = "MENUE";
+
+	private static final String BACK = "back";
+
+	private static final String FORWARD = "Vor";
+
+	private static final String FROM_DATE = "from_date";
+
+	private static final String TO_DATE = "to_date";
+
+	private TravelbugJourney travelbug;
+
+	public TravelbugJourney getTravelbug() {
+		return travelbug;
+	}
+
+	private CardPanel pnlTab;
+
+	private mInput inpName;
+
+	public mInput getInpName() {
+		return inpName;
+	}
+
+	private mInput inpTrackingNo;
+
+	public mInput getInpTrackingNo() {
+		return inpTrackingNo;
+	}
+
+	private mLabel lblId;
+
+	private mInput inpFromProfile;
+
+	public mInput getInpFromProfile() {
+		return inpFromProfile;
+	}
+
+	private mInput inpFromWaypoint;
+
+	public mInput getInpFromWaypoint() {
+		return inpFromWaypoint;
+	}
+
+	private mInput inpFromDate;
+
+	public mInput getInpFromDate() {
+		return inpFromDate;
+	}
+
+	private mButton btnFromDate;
+
+	private mCheckBox chkFromLogged;
+
+	public mCheckBox getChkFromLogged() {
+		return chkFromLogged;
+	}
+
+	private mInput inpToProfile;
+
+	public mInput getInpToProfile() {
+		return inpToProfile;
+	}
+
+	private mInput inpToWaypoint;
+
+	public mInput getInpToWaypoint() {
+		return inpToWaypoint;
+	}
+
+	private mInput inpToDate;
+
+	public mInput getInpToDate() {
+		return inpToDate;
+	}
+
+	private mButton btnToDate;
+
+	private mCheckBox chkToLogged;
+
+	public mCheckBox getChkToLogged() {
+		return chkToLogged;
+	}
+
+	private HtmlDisplay txtMission;
+
+	private PDATravelbugJourneyScreen view;
+
+	public PDATravelbugDetailPanel(TravelbugJourney tbJourney, PDATravelbugJourneyScreen view) {
+		SipButton.sipButtonSize = new Dimension(35, 40);
+		Vm.setSIP(Vm.SIP_LEAVE_BUTTON);
+		this.windowFlagsToSet = WindowConstants.FLAG_SHOW_SIP_BUTTON;
+		travelbug = tbJourney;
+		this.view = view;
+		setTitle(tbJourney.getTb().getName());
+
+		pnlTab = new CardPanel();
+		addLast(pnlTab);
+
+		// ------------------------------------------------
+		// First Tab - Name & Tracking #
+		// ------------------------------------------------
+		CellPanel pnlName = new CellPanel();
+		CellPanel panel = new CellPanel();
+		panel.backGround = Color.White;
+		panel.addNext(new mLabel(MyLocale.getMsg(6025, "Name:")), DONTSTRETCH, DONTFILL | WEST);
+		inpName = new mInput(tbJourney.getTb().getName());
+		inpName.backGround = Color.White;
+		inpName.borderStyle = BDR_OUTLINE | BF_LEFT | BF_TOP | BF_RIGHT | BF_SQUARE;
+		panel.addLast(inpName, HSTRETCH, HFILL);
+		panel.addNext(new mLabel(MyLocale.getMsg(6026, "Tracking #:")), DONTSTRETCH, DONTFILL | WEST);
+		inpTrackingNo = new mInput(tbJourney.getTb().getTrackingNo());
+		inpTrackingNo.backGround = Color.White;
+		inpTrackingNo.borderStyle = BDR_OUTLINE | BF_LEFT | BF_TOP | BF_RIGHT | BF_SQUARE;
+		panel.addLast(inpTrackingNo, HSTRETCH, HFILL);
+		panel.addNext(new mLabel(MyLocale.getMsg(6027, "ID/GUID:")), DONTSTRETCH, DONTFILL | WEST);
+		lblId = new mLabel(tbJourney.getTb().getGuid());
+		lblId.backGround = Color.White;
+		lblId.borderStyle = BDR_OUTLINE | BF_LEFT | BF_TOP | BF_RIGHT | BF_SQUARE;
+		panel.addLast(lblId, HSTRETCH, HFILL);
+		pnlName.addLast(panel, STRETCH, FILL);
+		// VON-Tab
+		mLabel label = new mLabel(MyLocale.getMsg(6058, "Retrieved:"));
+		Font tmpFont = new Font("Helvetica", Font.BOLD, Preferences.getPrefObject().fontSize * 2);
+		label.font = tmpFont;
+		panel.addLast(label, DONTSTRETCH, DONTFILL | WEST);
+		panel.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		inpFromProfile = new mInput(tbJourney.getFromProfile());
+		panel.addNext(inpFromProfile, HSTRETCH, HFILL);
+		inpFromWaypoint = new mInput(tbJourney.getFromWaypoint());
+		panel.addLast(inpFromWaypoint, HSTRETCH, HFILL);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6059, "Date:")), DONTSTRETCH, DONTFILL | WEST);
+		inpFromDate = new mInput(tbJourney.getFromDate());
+		panel.addNext(inpFromDate, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		btnFromDate = new mButton(new mImage("calendar.png"));
+		btnFromDate.action = FROM_DATE;
+		panel.addLast(btnFromDate, DONTSTRETCH, HFILL | WEST);
+		btnFromDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged = new mCheckBox("");
+		chkFromLogged.boxWidth = BOXWIDTH;
+		chkFromLogged.font = tmpFont;
+		chkFromLogged.setState(tbJourney.getFromLogged());
+		panel.addLast(chkFromLogged, DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged.exitKeys = exitKeys;
+		// To-Tab
+		label = new mLabel(MyLocale.getMsg(6060, "Dropped off:"));
+		label.font = tmpFont;
+		panel.addLast(label, DONTSTRETCH, DONTFILL | WEST);
+		panel.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		inpToProfile = new mInput(tbJourney.getToProfile());
+		panel.addNext(inpToProfile, HSTRETCH, HFILL);
+		inpToWaypoint = new mInput(tbJourney.getToWaypoint());
+		panel.addLast(inpToWaypoint, HSTRETCH, HFILL);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6059, "Date:")), DONTSTRETCH, DONTFILL | WEST);
+		inpToDate = new mInput(tbJourney.getToDate());
+		panel.addNext(inpToDate, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		btnToDate = new mButton(new mImage("calendar.png"));
+		btnToDate.action = TO_DATE;
+		panel.addLast(btnToDate, DONTSTRETCH, HFILL | WEST);
+		btnToDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged = new mCheckBox("");
+		chkToLogged.boxWidth = BOXWIDTH;
+		chkToLogged.setState(tbJourney.getToLogged());
+		panel.addLast(chkToLogged, DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged.exitKeys = exitKeys;
+
+		panel = new CellPanel();
+		PDAMenuButton pdaListButton = new PDAMenuButton("<<<", BACK);
+		pdaListButton.change(ControlConstants.Disabled, 0);
+		panel.addNext(pdaListButton, HSTRETCH, HFILL);
+		panel.addNext(new PDAMenuButton(MyLocale.getMsg(6052, "MENU"), MENUE));
+		panel.addLast(new PDAMenuButton(">>>", FORWARD), HSTRETCH, HFILL);
+		pnlName.addLast(panel, HSTRETCH, HFILL);
+
+		pnlTab.addItem(pnlName, MyLocale.getMsg(6028, "Name"), "Name");
+
+		// ------------------------------------------------
+		// Last Panel - TB Mission
+		// ------------------------------------------------
+		CellPanel pnlDest = new CellPanel();
+		label = new mLabel(MyLocale.getMsg(6035, "Mission:"));
+		tmpFont = new Font("Helvetica", Font.BOLD, Preferences.getPrefObject().fontSize * 2);
+		label.setFont(tmpFont);
+		pnlDest.addLast(label, DONTSTRETCH, DONTFILL);
+		txtMission = new HtmlDisplay();
+		txtMission.setHtml(tbJourney.getTb().getMission());
+		pnlDest.addLast(txtMission, STRETCH, FILL);
+		txtMission.rows = 3;
+
+		panel = new CellPanel();
+		panel.addNext(new PDAMenuButton("<<<", BACK), HSTRETCH, HFILL);
+		panel.addNext(new PDAMenuButton(MyLocale.getMsg(6052, "MENU"), MENUE));
+		pdaListButton = new PDAMenuButton(">>>", "");
+		pdaListButton.change(ControlConstants.Disabled, 0);
+		panel.addLast(pdaListButton, HSTRETCH, HFILL);
+		panel.backGround = new Color(250, 0, 0);
+		pnlDest.addLast(panel, DONTSTRETCH, FILL);
+		pnlTab.addItem(pnlDest, MyLocale.getMsg(6036, "Mission"), "Mission");
+		SipButton.placeIn(this);
+		Gui.takeFocus(null, ControlConstants.ByKeyboard);
+	}
+
+	public void onControlEvent(ControlEvent paramEvent) {
+		switch (paramEvent.type) {
+		case ControlEvent.PRESSED:
+			String action = paramEvent.action;
+			if (action.equals(FORWARD)) {
+				pnlTab.select(pnlTab.getSelectedItem()+1);
+			} else if (action.equals(BACK)) {
+				pnlTab.select(pnlTab.getSelectedItem()-1);
+//				pnlTab.selectNextTab(false, true);
+			} else if (action.equals(MENUE)) {
+				PDATravelbugDetailMenu detailMenu = new PDATravelbugDetailMenu(this, view);
+				int execute = detailMenu.execute();
+				if (execute == 1){
+					exit(0);
+				}				
+			} else if (action.equals(FROM_DATE) || action.equals(TO_DATE)) {
+				mInput inpDate = action.equals(FROM_DATE) ? inpFromDate : inpToDate;
+				PDADateTimeChooser dc = new PDADateTimeChooser();
+				dc.setTitle(MyLocale.getMsg(328, "Date found"));
+				dc.setLocation(0, 0);
+//				dc.setPreferredSize(240, 240);
+				String foundDate = inpDate.getText();
+				Time t = new Time();
+				try {
+					t.parse(foundDate, "y-M-d H:m");
+				} catch (IllegalArgumentException e) {
+					try {
+						t.parse(foundDate, "y-M-d");
+					} catch (IllegalArgumentException e1) {
+						// Can't parse date - should not happen
+					}
+				}
+				dc.reset(t);
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpDate.setText(Convert.toString(dc.getYear ()) + "-" + MyLocale.formatLong(dc.getMonth (), "00") + "-"
+							+ MyLocale.formatLong(dc.getDay(), "00") + " " + dc.getTime() + " " + MyLocale.formatLong(dc.getHour(), "00") +
+							":"+MyLocale.formatLong(dc.getMinute(), "00"));
+				}
+			}
+		}
+	}
+
+	public void focusFirst(int paramInt) {
+		super.focusFirst(paramInt);
+		// Erst mal den Focus so setzen, dass die Tastatur nicht aufgeklappt
+		// wird.
+		// Wenn der TB noch nicht abgelegt wurde, dann den Focus auf den Button
+		// zum ablegen, sonst immer auf die Aufnahme
+		if (travelbug.getToDate().length() == 0 && travelbug.getFromDate().length() > 0) {
+			Gui.takeFocus(btnToDate, paramInt);
+
+		} else {
+			Gui.takeFocus(btnFromDate, paramInt);
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,134 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import ewe.graphics.AniImage;
+import ewe.sys.Vm;
+import ewe.ui.CellConstants;
+import ewe.ui.ControlConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+
+public class PDATravelbugJourneyScreen extends Form {
+	private static final String LINE = "Line";
+
+	private static final String NEXT_PAGE = "NextPage";
+
+	private static final String PREV_PAGE = "PrevPage";
+
+	private static final String MENUE = "Menue";
+
+	PDAListButton[] listButtons;
+
+	TravelBugJourneyScreenModel model;
+
+	/**
+	 * The index of the first item in the list shown
+	 */
+	private int firstLine;
+
+	private final int linesOnScreen = 7;
+
+	/**
+	 * The six visible entries in the List
+	 */
+
+	public PDATravelbugJourneyScreen(TravelBugJourneyScreenModel travelbugModel) {
+		listButtons = new PDAListButton[linesOnScreen];
+		addListener(this);
+		setTitle("TravelBugs");
+
+		model = travelbugModel;
+
+		// backgroundImage = new Image("bug_vga.gif");
+		for (int i = 0; i < model.allTravelbugJourneys.size(); i++) {
+			model.shownTravelbugJourneys.add(model.allTravelbugJourneys.getTBJourney(i));
+		}
+
+		firstLine = 0;
+		for (int i = 0; i < linesOnScreen; i++) {
+			listButtons[i] = new PDAListButton("", LINE + i);
+			addLast(listButtons[i], CellConstants.STRETCH, CellConstants.FILL);
+		}
+		model.createShowSet();
+		setupTBButtons();
+		PDAMenuButton b1 = new PDAMenuButton("<<<", PREV_PAGE);
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(MyLocale.getMsg(6052, "MENU"), MENUE);
+		b1.anchor = 0;
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(">>>", NEXT_PAGE);
+		b1.anchor = CellConstants.EAST;
+		addLast(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+	}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) && model.shownTravelbugJourneys.size() > firstLine + linesOnScreen) {
+					firstLine += linesOnScreen;
+					setupTBButtons();
+				} else if (ev.action.equals(PREV_PAGE) && firstLine > 0) {
+					firstLine -= linesOnScreen;
+					if (firstLine < 0) {
+						firstLine = 0;
+					}
+					setupTBButtons();
+				} else if (ev.action.startsWith(LINE)) {
+					int line = ev.action.charAt(LINE.length()) - '0';
+					TravelbugJourney tbJourney = (TravelbugJourney) model.shownTravelbugJourneys.get(line + firstLine);
+					Form form = new PDATravelbugDetailPanel(tbJourney, this);
+					form.setPreferredSize(800, 600);
+					form.execute();
+					setupTBButtons();
+				} else if (ev.action.equals(MENUE)) {
+					Form form = new PDATravelbugMenuPanel(this);
+					form.setPreferredSize(800, 600);
+					int execute = form.execute();
+					if (execute == 1){
+						exit(0);
+					}
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public void setupTBButtons() {
+		for (int i = 0; i < linesOnScreen; i++) {
+			if (i + firstLine < model.shownTravelbugJourneys.size()) {
+				TravelbugJourney tbJourney = (TravelbugJourney) model.shownTravelbugJourneys.get(i + firstLine);
+				String tbName = tbJourney.getTb().getName();
+				listButtons[i].text = tbName;
+				listButtons[i].fromText = tbJourney.getFromWaypoint() + '/' + tbJourney.getFromProfile();
+				listButtons[i].fromLogged = tbJourney.getFromLogged();
+				listButtons[i].toText = tbJourney.getToWaypoint() + '/' + tbJourney.getToProfile();
+				listButtons[i].toLogged = tbJourney.getToLogged();
+				listButtons[i].image = new AniImage("bug_vga.gif");
+				listButtons[i].modify(ControlConstants.Disabled, 1);
+			} else {
+				listButtons[i].text = listButtons[i].fromText =	listButtons[i].toText = "";
+				listButtons[i].toLogged = listButtons[i].fromLogged = true;
+				listButtons[i].image = null;
+				listButtons[i].modify(ControlConstants.Disabled, 0);
+			}
+			listButtons[i].repaint();
+		}
+	}
+
+	public void toggleOnlyLogged() {
+		model.toggleOnlyLogged();
+		firstLine = 0;
+		setupTBButtons();
+	}
+
+	public void createShowSet() {
+		firstLine = 0;
+		model.createShowSet();
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,101 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugPickup;
+import CacheWolf.view.ewe.TravelbugJourneyScreen;
+import ewe.fx.Dimension;
+
+public class PDATravelbugMenuPanel extends PDAMenu {
+
+	private static final String RETRIEVE = "retrieve";
+	private static final String TOGGLE_LOG = "toggle_log";
+	private static final String NEW_TB = "new_tb";
+	private static final String EXPERT = "expert_view";
+	private static final String SORT = "sort";
+	private static final String EXIT = "exit";
+	private PDATravelbugJourneyScreen view;
+
+	public PDATravelbugMenuPanel(PDATravelbugJourneyScreen view) {
+		this.view =view;
+		setTitle(MyLocale.getMsg(6053, "Travelbug - Menu"));
+
+		addMenuItem(view.model.onlyLogged ? MyLocale.getMsg(6054, "Show all") : MyLocale.getMsg(6046, "Show only not logged"),
+				TOGGLE_LOG);
+		addMenuItem(MyLocale.getMsg(6055, "Sort ..."), SORT);
+		addMenuItem(MyLocale.getMsg(6042, "New Travelbug"), NEW_TB);
+		addMenuItem(MyLocale.getMsg(6040, "Pick up TB from current cache"), RETRIEVE);
+		addMenuItem(MyLocale.getMsg(6056, "Expertview"), EXPERT);
+		addMenuItem(MyLocale.getMsg(6061, "Close"), EXIT);
+		buildMenu ();
+	}
+
+	public void actionPerformed(String actionCommand) {
+		if (actionCommand.equals(RETRIEVE)) {
+			int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+			CacheDB cacheDB = Global.getProfile().cacheDB;
+			if (curCacheNo >= 0 && curCacheNo < cacheDB.size()) {
+				CacheHolder ch = cacheDB.get(curCacheNo);
+				String waypoint = ch.getWayPoint();
+				TravelbugList tblSrcCache = ch.getCacheDetails(true).Travelbugs;
+
+				Travelbug tb = TravelbugPickup.pickupTravelbug(tblSrcCache);
+				if (tb != null) {
+					view.model.allTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, waypoint);
+					CacheHolderDetail cacheDetails = ch.getCacheDetails(true);
+					ch.setHas_bugs(cacheDetails.Travelbugs.size() > 0);
+					ch.save();
+					view.model.allTravelbugJourneys.saveTravelbugsFile();
+				}
+			}
+			view.createShowSet();
+			view.setupTBButtons();
+			exit(0);
+		} else if (actionCommand.equals(TOGGLE_LOG)) {
+			view.toggleOnlyLogged();
+			exit(0);
+		} else if (actionCommand.equals(EXPERT)) {
+			TravelbugJourneyScreen travelbugJourneyScreen = new TravelbugJourneyScreen(view.model);
+			Dimension arg0 = new Dimension();
+			getSize(arg0);
+			travelbugJourneyScreen.setPreferredSize(arg0.width, arg0.height);
+			travelbugJourneyScreen.execute();
+			exit(0);
+			view.exit(0);
+		} else if (actionCommand.equals(NEW_TB)) {
+			int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+			CacheDB cacheDB = Global.getProfile().cacheDB;
+			CacheHolder ch = cacheDB.get(curCacheNo);
+			TravelbugJourney tbj = new TravelbugJourney("New");
+			tbj.setFromProfile(Global.getProfile().name);
+			tbj.setFromWaypoint("");
+			tbj.setFromLogged(true);
+			view.model.allTravelbugJourneys.add(tbj);
+			CacheHolderDetail cacheDetails = ch.getCacheDetails(true);
+			ch.setHas_bugs(cacheDetails.Travelbugs.size() > 0);
+			ch.save();
+			view.model.allTravelbugJourneys.saveTravelbugsFile();
+			view.createShowSet();
+			view.setupTBButtons();
+			exit(0);
+		} else if (actionCommand.equals(SORT)) {
+			PDATravelbugSortMenu sortMenu = new PDATravelbugSortMenu();
+			sortMenu.execute();
+			if (sortMenu.sortColumn > 0) {
+				view.model.allTravelbugJourneys.sort(sortMenu.sortColumn, sortMenu.ascending);
+				view.createShowSet();
+				view.setupTBButtons();
+			}
+			exit(0);
+		} else if (actionCommand.equals(EXIT)){
+			exit(1);
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,68 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugList;
+import CacheWolf.model.DefaultListModel;
+import CacheWolf.view.ITravelbugScreen;
+import ewe.ui.ControlEvent;
+
+public class PDATravelbugScreen extends PDAList implements ITravelbugScreen{
+
+	/** The index into the list of travelbugs indicating the selected bug */
+	public int selectedItem=-1;
+	
+	/**
+	 * A screen to choose a travelbug from a list of bugs
+	 * @param tbl The list of travelbugs from which to choose
+	 * @param title The title of the screen
+	 * @param allowNew True if a travelbug not on the list can be selected
+	 */
+	public PDATravelbugScreen(TravelbugList tbl, String title, boolean allowNew) {
+		super();
+		model = new DefaultListModel();
+		for (int i=0;i < tbl.size();i++){
+			Travelbug tb = tbl.getTB(i);
+			model.add(tb.getName());
+		}
+		if (allowNew){
+			model.add(MyLocale.getMsg(6015,"*** OTHER ***"));
+		}
+		model.createShowSet();
+		setupTBButtons();
+}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) ||(ev.action.equals(PREV_PAGE))) {
+					super.onControlEvent(ev);	
+				} else if (ev.action.startsWith(LINE)) {
+					selectedItem = ev.action.charAt(LINE.length()) - '0';
+//					Object clickedItem =  model.get(line + firstLine);
+//					Form form = new PDATravelbugDetailPanel(tbJourney, this);
+//					form.setPreferredSize(800, 600);
+//					form.execute();
+//					setupTBButtons();
+					exit(0);
+				} else if (ev.action.equals(MENUE)) {
+//					Form form = new PDATravelbugMenuPanel(this);
+//					form.setPreferredSize(800, 600);
+//					int execute = form.execute();
+//					if (execute == 1){
+//						exit(0);
+//					}
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public int getSelectedItem() {
+		return selectedItem;
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,86 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import ewe.fx.Rect;
+import ewe.ui.Window;
+
+public class PDATravelbugSortMenu extends PDAMenu {
+	private static final String NAME = "name";
+	private static final String FROM_WP = "from_wp";
+	private static final String FROM_DATE = "from_date";
+	private static final String TO_WP = "to_wp";
+	private static final String TO_DATE = "to_date";
+	private static final String TRACK_NR = "track_nw";
+	private static final String EXIT = "exit";
+	public int sortColumn = -1;
+	public boolean ascending = true;
+
+	public PDATravelbugSortMenu() {
+		super();
+		PDAMenuButton button = new PDAMenuButton(MyLocale.getMsg(6028, "Name"), NAME);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("^^", NAME + "_UP");
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("vv", NAME + "_DOWN");
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6005, "From Wpt"), FROM_WP);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("^^", FROM_WP + "_UP");
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("vv", FROM_WP + "_DOWN");
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6006, "From Date"), FROM_DATE);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("^^", FROM_DATE + "_UP");
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("vv", FROM_DATE + "_DOWN");
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6009, "To Wpt"), TO_WP);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("^^", TO_WP + "_UP");
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("vv", TO_WP + "_DOWN");
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6010, "To Date"), TO_DATE);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("^^", TO_DATE + "_UP");
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("vv", TO_DATE + "_DOWN");
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6062, "Track-No"), TRACK_NR);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("^^", TRACK_NR + "_UP");
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton("vv", TRACK_NR + "_DOWN");
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6057, "Back"), EXIT);
+		addLast(button);
+
+		Rect s = (Rect) Window.getGuiInfo(Window.INFO_SCREEN_RECT, null, new Rect(), 0);
+		setPreferredSize(s.width, s.height);
+	}
+
+	public void actionPerformed(String actionCommand) {
+		if (actionCommand.startsWith(NAME)) {
+			sortColumn = 1;
+		} else if (actionCommand.startsWith(FROM_WP)) {
+			sortColumn = 5;
+		} else if (actionCommand.startsWith(FROM_DATE)) {
+			sortColumn = 6;
+		} else if (actionCommand.startsWith(TO_WP)) {
+			sortColumn = 9;
+		} else if (actionCommand.startsWith(TO_DATE)) {
+			sortColumn = 10;
+		} else if (actionCommand.startsWith(TRACK_NR)) {
+			sortColumn = 2;
+		}
+		ascending = actionCommand.endsWith("DOWN");
+		exit(0);
+	}
+}

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,7 +1,7 @@
 ???'------------------------------------------------------------------------------
 ' <auto-generated>
 '     Dieser Code wurde von einem Tool generiert.
-'     Laufzeitversion:2.0.50727.3082
+'     Laufzeitversion:4.0.30319.1
 '
 '     ??nderungen an dieser Datei k??nnen falsches Verhalten verursachen und gehen verloren, wenn
 '     der Code erneut generiert wird.
@@ -16,7 +16,7 @@
     
     'HINWEIS: Diese Datei wird automatisch generiert. ??ndern Sie sie nicht direkt. Zum ??ndern
     ' oder bei in dieser Datei auftretenden Buildfehlern wechseln Sie zum Projekt-Designer.
-    ' (Wechseln Sie dazu zu den Projekteigenschaften, oder doppelklicken Sie auf den Knoten "Eigenes Projekt" im
+    ' (Wechseln Sie dazu zu den Projekteigenschaften, oder doppelklicken Sie auf den Knoten "Mein Projekt" im
     ' Projektmappen-Explorer). Nehmen Sie auf der Registerkarte "Anwendung" entsprechende ??nderungen vor.
     '
     Partial Friend Class MyApplication

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,7 +1,7 @@
 ???'------------------------------------------------------------------------------
 ' <auto-generated>
 '     Dieser Code wurde von einem Tool generiert.
-'     Laufzeitversion:2.0.50727.3082
+'     Laufzeitversion:4.0.30319.1
 '
 '     ??nderungen an dieser Datei k??nnen falsches Verhalten verursachen und gehen verloren, wenn
 '     der Code erneut generiert wird.
@@ -22,7 +22,7 @@
     '''<summary>
     '''  Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
     '''</summary>
-    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0"),  _
+    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0"),  _
      Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
      Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
      Global.Microsoft.VisualBasic.HideModuleNameAttribute()>  _

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,7 +1,7 @@
 ???'------------------------------------------------------------------------------
 ' <auto-generated>
 '     Dieser Code wurde von einem Tool generiert.
-'     Laufzeitversion:2.0.50727.3082
+'     Laufzeitversion:4.0.30319.1
 '
 '     ??nderungen an dieser Datei k??nnen falsches Verhalten verursachen und gehen verloren, wenn
 '     der Code erneut generiert wird.
@@ -15,12 +15,12 @@
 Namespace My
     
     <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
-     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0"),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0"),  _
      Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
     Partial Friend NotInheritable Class MySettings
         Inherits Global.System.Configuration.ApplicationSettingsBase
         
-        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings),MySettings)
+        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings()),MySettings)
         
 #Region "Funktion zum automatischen Speichern von My.Settings"
 #If _MyType = "WindowsForms" Then

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/bin/Debug/capxml2wms.exe
===================================================================
(Binary files differ)

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -23,298 +23,297 @@
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(capxml2wms))
-        Me.ButtonErstellen = New System.Windows.Forms.Button
-        Me.TextBoxUrl = New System.Windows.Forms.TextBox
-        Me.Label1 = New System.Windows.Forms.Label
-        Me.TextBoxXML = New System.Windows.Forms.TextBox
-        Me.Label2 = New System.Windows.Forms.Label
-        Me.ComboBoxVersion = New System.Windows.Forms.ComboBox
-        Me.ButtonGetCapabilities = New System.Windows.Forms.Button
-        Me.ButtonShowMap = New System.Windows.Forms.Button
-        Me.CheckedListBoxLayers = New System.Windows.Forms.CheckedListBox
-        Me.Label3 = New System.Windows.Forms.Label
-        Me.ButtonCheckNone = New System.Windows.Forms.Button
-        Me.ButtonCheckAll = New System.Windows.Forms.Button
-        Me.ComboBoxEPSG = New System.Windows.Forms.ComboBox
-        Me.Label4 = New System.Windows.Forms.Label
-        Me.HScrollBar1 = New System.Windows.Forms.HScrollBar
-        Me.Label5 = New System.Windows.Forms.Label
-        Me.ComboBoxFormat = New System.Windows.Forms.ComboBox
-        Me.ComboBoxBBox = New System.Windows.Forms.ComboBox
-        Me.Label6 = New System.Windows.Forms.Label
-        Me.ComboBoxBBoxI = New System.Windows.Forms.ComboBox
-        Me.ButtonFindScale = New System.Windows.Forms.Button
+        Me.ButtonErstellen = New System.Windows.Forms.Button()
+        Me.Panel1 = New System.Windows.Forms.Panel()
+        Me.ComboBoxBBoxI = New System.Windows.Forms.ComboBox()
+        Me.Label6 = New System.Windows.Forms.Label()
+        Me.ComboBoxBBox = New System.Windows.Forms.ComboBox()
+        Me.ComboBoxFormat = New System.Windows.Forms.ComboBox()
+        Me.Label5 = New System.Windows.Forms.Label()
+        Me.Label4 = New System.Windows.Forms.Label()
+        Me.ComboBoxEPSG = New System.Windows.Forms.ComboBox()
+        Me.ButtonFindScale = New System.Windows.Forms.Button()
+        Me.ButtonCheckAll = New System.Windows.Forms.Button()
+        Me.ButtonCheckNone = New System.Windows.Forms.Button()
+        Me.Label3 = New System.Windows.Forms.Label()
+        Me.CheckedListBoxLayers = New System.Windows.Forms.CheckedListBox()
+        Me.Panel2 = New System.Windows.Forms.Panel()
+        Me.TextBoxXML = New System.Windows.Forms.TextBox()
+        Me.ButtonGetCapabilities = New System.Windows.Forms.Button()
+        Me.ComboBoxVersion = New System.Windows.Forms.ComboBox()
+        Me.Label2 = New System.Windows.Forms.Label()
+        Me.Label1 = New System.Windows.Forms.Label()
+        Me.TextBoxUrl = New System.Windows.Forms.TextBox()
+        Me.Panel1.SuspendLayout()
+        Me.Panel2.SuspendLayout()
         Me.SuspendLayout()
         '
         'ButtonErstellen
         '
         Me.ButtonErstellen.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonErstellen.Location = New System.Drawing.Point(540, 552)
+        Me.ButtonErstellen.Location = New System.Drawing.Point(537, 553)
         Me.ButtonErstellen.Name = "ButtonErstellen"
         Me.ButtonErstellen.Size = New System.Drawing.Size(123, 36)
         Me.ButtonErstellen.TabIndex = 1
-        Me.ButtonErstellen.Text = "WMS-Datei erstellen"
+        Me.ButtonErstellen.Text = "3. WMS-Datei erstellen"
         Me.ButtonErstellen.UseVisualStyleBackColor = True
         '
-        'TextBoxUrl
+        'Panel1
         '
-        Me.TextBoxUrl.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+        Me.Panel1.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
+                    Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.TextBoxUrl.Location = New System.Drawing.Point(20, 57)
-        Me.TextBoxUrl.Name = "TextBoxUrl"
-        Me.TextBoxUrl.Size = New System.Drawing.Size(496, 20)
-        Me.TextBoxUrl.TabIndex = 0
+        Me.Panel1.Controls.Add(Me.ComboBoxBBoxI)
+        Me.Panel1.Controls.Add(Me.Label6)
+        Me.Panel1.Controls.Add(Me.ComboBoxBBox)
+        Me.Panel1.Controls.Add(Me.ComboBoxFormat)
+        Me.Panel1.Controls.Add(Me.Label5)
+        Me.Panel1.Controls.Add(Me.Label4)
+        Me.Panel1.Controls.Add(Me.ComboBoxEPSG)
+        Me.Panel1.Controls.Add(Me.ButtonFindScale)
+        Me.Panel1.Controls.Add(Me.ButtonCheckAll)
+        Me.Panel1.Controls.Add(Me.ButtonCheckNone)
+        Me.Panel1.Controls.Add(Me.Label3)
+        Me.Panel1.Controls.Add(Me.CheckedListBoxLayers)
+        Me.Panel1.Location = New System.Drawing.Point(20, 240)
+        Me.Panel1.Name = "Panel1"
+        Me.Panel1.Size = New System.Drawing.Size(643, 306)
+        Me.Panel1.TabIndex = 24
         '
-        'Label1
+        'ComboBoxBBoxI
         '
-        Me.Label1.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
-                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.Label1.AutoSize = True
-        Me.Label1.Location = New System.Drawing.Point(21, 27)
-        Me.Label1.Name = "Label1"
-        Me.Label1.Size = New System.Drawing.Size(205, 13)
-        Me.Label1.TabIndex = 2
-        Me.Label1.Text = "http Adresse des WMS-Servers eingeben:"
+        Me.ComboBoxBBoxI.FormattingEnabled = True
+        Me.ComboBoxBBoxI.Location = New System.Drawing.Point(190, 36)
+        Me.ComboBoxBBoxI.Name = "ComboBoxBBoxI"
+        Me.ComboBoxBBoxI.Size = New System.Drawing.Size(252, 21)
+        Me.ComboBoxBBoxI.TabIndex = 35
+        Me.ComboBoxBBoxI.Visible = False
         '
-        'TextBoxXML
+        'Label6
         '
-        Me.TextBoxXML.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
-                    Or System.Windows.Forms.AnchorStyles.Left) _
+        Me.Label6.AutoSize = True
+        Me.Label6.Location = New System.Drawing.Point(141, 6)
+        Me.Label6.Name = "Label6"
+        Me.Label6.Size = New System.Drawing.Size(35, 13)
+        Me.Label6.TabIndex = 34
+        Me.Label6.Text = "BBox:"
+        '
+        'ComboBoxBBox
+        '
+        Me.ComboBoxBBox.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.TextBoxXML.Location = New System.Drawing.Point(20, 83)
-        Me.TextBoxXML.Multiline = True
-        Me.TextBoxXML.Name = "TextBoxXML"
-        Me.TextBoxXML.ReadOnly = True
-        Me.TextBoxXML.ScrollBars = System.Windows.Forms.ScrollBars.Both
-        Me.TextBoxXML.Size = New System.Drawing.Size(643, 288)
-        Me.TextBoxXML.TabIndex = 4
-        Me.TextBoxXML.WordWrap = False
+        Me.ComboBoxBBox.FormattingEnabled = True
+        Me.ComboBoxBBox.Location = New System.Drawing.Point(144, 23)
+        Me.ComboBoxBBox.Name = "ComboBoxBBox"
+        Me.ComboBoxBBox.Size = New System.Drawing.Size(489, 21)
+        Me.ComboBoxBBox.TabIndex = 33
         '
-        'Label2
+        'ComboBoxFormat
         '
-        Me.Label2.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.Label2.AutoSize = True
-        Me.Label2.Location = New System.Drawing.Point(511, 27)
-        Me.Label2.Name = "Label2"
-        Me.Label2.Size = New System.Drawing.Size(75, 13)
-        Me.Label2.TabIndex = 5
-        Me.Label2.Text = "WMS-Version:"
-        Me.Label2.Visible = False
+        Me.ComboBoxFormat.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ComboBoxFormat.FormattingEnabled = True
+        Me.ComboBoxFormat.Location = New System.Drawing.Point(512, 104)
+        Me.ComboBoxFormat.Name = "ComboBoxFormat"
+        Me.ComboBoxFormat.Size = New System.Drawing.Size(121, 21)
+        Me.ComboBoxFormat.TabIndex = 32
         '
-        'ComboBoxVersion
+        'Label5
         '
-        Me.ComboBoxVersion.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxVersion.FormattingEnabled = True
-        Me.ComboBoxVersion.Items.AddRange(New Object() {"1.0.0", "1.1.0", "1.1.1"})
-        Me.ComboBoxVersion.Location = New System.Drawing.Point(588, 24)
-        Me.ComboBoxVersion.MaxDropDownItems = 3
-        Me.ComboBoxVersion.Name = "ComboBoxVersion"
-        Me.ComboBoxVersion.Size = New System.Drawing.Size(75, 21)
-        Me.ComboBoxVersion.TabIndex = 6
+        Me.Label5.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label5.AutoSize = True
+        Me.Label5.Location = New System.Drawing.Point(514, 88)
+        Me.Label5.Name = "Label5"
+        Me.Label5.Size = New System.Drawing.Size(42, 13)
+        Me.Label5.TabIndex = 31
+        Me.Label5.Text = "Format:"
         '
-        'ButtonGetCapabilities
+        'Label4
         '
-        Me.ButtonGetCapabilities.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonGetCapabilities.Location = New System.Drawing.Point(540, 43)
-        Me.ButtonGetCapabilities.Name = "ButtonGetCapabilities"
-        Me.ButtonGetCapabilities.Size = New System.Drawing.Size(123, 36)
-        Me.ButtonGetCapabilities.TabIndex = 7
-        Me.ButtonGetCapabilities.Text = "M??glichkeiten abfragen"
-        Me.ButtonGetCapabilities.UseVisualStyleBackColor = True
+        Me.Label4.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label4.AutoSize = True
+        Me.Label4.Location = New System.Drawing.Point(514, 47)
+        Me.Label4.Name = "Label4"
+        Me.Label4.Size = New System.Drawing.Size(39, 13)
+        Me.Label4.TabIndex = 30
+        Me.Label4.Text = "EPSG:"
         '
-        'ButtonShowMap
+        'ComboBoxEPSG
         '
-        Me.ButtonShowMap.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonShowMap.Location = New System.Drawing.Point(540, 397)
-        Me.ButtonShowMap.Name = "ButtonShowMap"
-        Me.ButtonShowMap.Size = New System.Drawing.Size(123, 36)
-        Me.ButtonShowMap.TabIndex = 8
-        Me.ButtonShowMap.Text = "Test Karte anzeigen"
-        Me.ButtonShowMap.UseVisualStyleBackColor = True
+        Me.ComboBoxEPSG.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ComboBoxEPSG.FormattingEnabled = True
+        Me.ComboBoxEPSG.Location = New System.Drawing.Point(512, 64)
+        Me.ComboBoxEPSG.Name = "ComboBoxEPSG"
+        Me.ComboBoxEPSG.Size = New System.Drawing.Size(121, 21)
+        Me.ComboBoxEPSG.TabIndex = 29
         '
-        'CheckedListBoxLayers
+        'ButtonFindScale
         '
-        Me.CheckedListBoxLayers.Anchor = CType(((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left) _
-                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.CheckedListBoxLayers.CheckOnClick = True
-        Me.CheckedListBoxLayers.FormattingEnabled = True
-        Me.CheckedListBoxLayers.HorizontalScrollbar = True
-        Me.CheckedListBoxLayers.Location = New System.Drawing.Point(20, 397)
-        Me.CheckedListBoxLayers.Name = "CheckedListBoxLayers"
-        Me.CheckedListBoxLayers.Size = New System.Drawing.Size(496, 109)
-        Me.CheckedListBoxLayers.TabIndex = 9
+        Me.ButtonFindScale.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ButtonFindScale.Location = New System.Drawing.Point(517, 265)
+        Me.ButtonFindScale.Name = "ButtonFindScale"
+        Me.ButtonFindScale.Size = New System.Drawing.Size(123, 36)
+        Me.ButtonFindScale.TabIndex = 28
+        Me.ButtonFindScale.Text = "2. Optimale Scale finden"
+        Me.ButtonFindScale.UseVisualStyleBackColor = True
         '
-        'Label3
+        'ButtonCheckAll
         '
-        Me.Label3.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label3.AutoSize = True
-        Me.Label3.Location = New System.Drawing.Point(21, 381)
-        Me.Label3.Name = "Label3"
-        Me.Label3.Size = New System.Drawing.Size(36, 13)
-        Me.Label3.TabIndex = 10
-        Me.Label3.Text = "Layer:"
+        Me.ButtonCheckAll.Location = New System.Drawing.Point(6, 24)
+        Me.ButtonCheckAll.Name = "ButtonCheckAll"
+        Me.ButtonCheckAll.Size = New System.Drawing.Size(60, 20)
+        Me.ButtonCheckAll.TabIndex = 27
+        Me.ButtonCheckAll.Text = "alle  x"
+        Me.ButtonCheckAll.UseVisualStyleBackColor = True
         '
         'ButtonCheckNone
         '
-        Me.ButtonCheckNone.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ButtonCheckNone.Location = New System.Drawing.Point(212, 377)
+        Me.ButtonCheckNone.Location = New System.Drawing.Point(72, 23)
         Me.ButtonCheckNone.Name = "ButtonCheckNone"
         Me.ButtonCheckNone.Size = New System.Drawing.Size(60, 20)
-        Me.ButtonCheckNone.TabIndex = 13
+        Me.ButtonCheckNone.TabIndex = 26
         Me.ButtonCheckNone.Text = "kein x"
         Me.ButtonCheckNone.UseVisualStyleBackColor = True
         '
-        'ButtonCheckAll
+        'Label3
         '
-        Me.ButtonCheckAll.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ButtonCheckAll.Location = New System.Drawing.Point(149, 377)
-        Me.ButtonCheckAll.Name = "ButtonCheckAll"
-        Me.ButtonCheckAll.Size = New System.Drawing.Size(60, 20)
-        Me.ButtonCheckAll.TabIndex = 14
-        Me.ButtonCheckAll.Text = "alle  x"
-        Me.ButtonCheckAll.UseVisualStyleBackColor = True
+        Me.Label3.AutoSize = True
+        Me.Label3.Location = New System.Drawing.Point(3, 6)
+        Me.Label3.Name = "Label3"
+        Me.Label3.Size = New System.Drawing.Size(36, 13)
+        Me.Label3.TabIndex = 25
+        Me.Label3.Text = "Layer:"
         '
-        'ComboBoxEPSG
+        'CheckedListBoxLayers
         '
-        Me.ComboBoxEPSG.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxEPSG.FormattingEnabled = True
-        Me.ComboBoxEPSG.Location = New System.Drawing.Point(20, 526)
-        Me.ComboBoxEPSG.Name = "ComboBoxEPSG"
-        Me.ComboBoxEPSG.Size = New System.Drawing.Size(121, 21)
-        Me.ComboBoxEPSG.TabIndex = 15
+        Me.CheckedListBoxLayers.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
+                    Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.CheckedListBoxLayers.CheckOnClick = True
+        Me.CheckedListBoxLayers.FormattingEnabled = True
+        Me.CheckedListBoxLayers.HorizontalScrollbar = True
+        Me.CheckedListBoxLayers.Location = New System.Drawing.Point(6, 72)
+        Me.CheckedListBoxLayers.Name = "CheckedListBoxLayers"
+        Me.CheckedListBoxLayers.Size = New System.Drawing.Size(496, 229)
+        Me.CheckedListBoxLayers.TabIndex = 24
         '
-        'Label4
+        'Panel2
         '
-        Me.Label4.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label4.AutoSize = True
-        Me.Label4.Location = New System.Drawing.Point(22, 509)
-        Me.Label4.Name = "Label4"
-        Me.Label4.Size = New System.Drawing.Size(39, 13)
-        Me.Label4.TabIndex = 16
-        Me.Label4.Text = "EPSG:"
+        Me.Panel2.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Panel2.Controls.Add(Me.TextBoxXML)
+        Me.Panel2.Controls.Add(Me.ButtonGetCapabilities)
+        Me.Panel2.Controls.Add(Me.ComboBoxVersion)
+        Me.Panel2.Controls.Add(Me.Label2)
+        Me.Panel2.Controls.Add(Me.Label1)
+        Me.Panel2.Controls.Add(Me.TextBoxUrl)
+        Me.Panel2.Location = New System.Drawing.Point(20, 12)
+        Me.Panel2.Name = "Panel2"
+        Me.Panel2.Size = New System.Drawing.Size(643, 222)
+        Me.Panel2.TabIndex = 25
         '
-        'HScrollBar1
+        'TextBoxXML
         '
-        Me.HScrollBar1.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.HScrollBar1.Location = New System.Drawing.Point(540, 377)
-        Me.HScrollBar1.Minimum = 1
-        Me.HScrollBar1.Name = "HScrollBar1"
-        Me.HScrollBar1.Size = New System.Drawing.Size(123, 17)
-        Me.HScrollBar1.TabIndex = 17
-        Me.HScrollBar1.Value = 1
+        Me.TextBoxXML.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
+                    Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.TextBoxXML.Location = New System.Drawing.Point(6, 52)
+        Me.TextBoxXML.Multiline = True
+        Me.TextBoxXML.Name = "TextBoxXML"
+        Me.TextBoxXML.ReadOnly = True
+        Me.TextBoxXML.ScrollBars = System.Windows.Forms.ScrollBars.Both
+        Me.TextBoxXML.Size = New System.Drawing.Size(627, 167)
+        Me.TextBoxXML.TabIndex = 13
+        Me.TextBoxXML.WordWrap = False
         '
-        'Label5
+        'ButtonGetCapabilities
         '
-        Me.Label5.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label5.AutoSize = True
-        Me.Label5.Location = New System.Drawing.Point(148, 509)
-        Me.Label5.Name = "Label5"
-        Me.Label5.Size = New System.Drawing.Size(42, 13)
-        Me.Label5.TabIndex = 18
-        Me.Label5.Text = "Format:"
+        Me.ButtonGetCapabilities.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ButtonGetCapabilities.Location = New System.Drawing.Point(517, 9)
+        Me.ButtonGetCapabilities.Name = "ButtonGetCapabilities"
+        Me.ButtonGetCapabilities.Size = New System.Drawing.Size(123, 36)
+        Me.ButtonGetCapabilities.TabIndex = 12
+        Me.ButtonGetCapabilities.Text = "1. M??glichkeiten abfragen"
+        Me.ButtonGetCapabilities.UseVisualStyleBackColor = True
         '
-        'ComboBoxFormat
+        'ComboBoxVersion
         '
-        Me.ComboBoxFormat.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxFormat.FormattingEnabled = True
-        Me.ComboBoxFormat.Location = New System.Drawing.Point(151, 526)
-        Me.ComboBoxFormat.Name = "ComboBoxFormat"
-        Me.ComboBoxFormat.Size = New System.Drawing.Size(121, 21)
-        Me.ComboBoxFormat.TabIndex = 19
+        Me.ComboBoxVersion.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ComboBoxVersion.FormattingEnabled = True
+        Me.ComboBoxVersion.Items.AddRange(New Object() {"1.0.0", "1.1.0", "1.1.1", "1.3.0"})
+        Me.ComboBoxVersion.Location = New System.Drawing.Point(412, 25)
+        Me.ComboBoxVersion.MaxDropDownItems = 3
+        Me.ComboBoxVersion.Name = "ComboBoxVersion"
+        Me.ComboBoxVersion.Size = New System.Drawing.Size(84, 21)
+        Me.ComboBoxVersion.TabIndex = 11
         '
-        'ComboBoxBBox
+        'Label2
         '
-        Me.ComboBoxBBox.Anchor = CType(((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left) _
-                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxBBox.FormattingEnabled = True
-        Me.ComboBoxBBox.Location = New System.Drawing.Point(20, 567)
-        Me.ComboBoxBBox.Name = "ComboBoxBBox"
-        Me.ComboBoxBBox.Size = New System.Drawing.Size(496, 21)
-        Me.ComboBoxBBox.TabIndex = 20
+        Me.Label2.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label2.AutoSize = True
+        Me.Label2.Location = New System.Drawing.Point(409, 9)
+        Me.Label2.Name = "Label2"
+        Me.Label2.Size = New System.Drawing.Size(75, 13)
+        Me.Label2.TabIndex = 10
+        Me.Label2.Text = "WMS-Version:"
         '
-        'Label6
+        'Label1
         '
-        Me.Label6.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label6.AutoSize = True
-        Me.Label6.Location = New System.Drawing.Point(22, 550)
-        Me.Label6.Name = "Label6"
-        Me.Label6.Size = New System.Drawing.Size(35, 13)
-        Me.Label6.TabIndex = 21
-        Me.Label6.Text = "BBox:"
+        Me.Label1.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label1.AutoSize = True
+        Me.Label1.Location = New System.Drawing.Point(3, 9)
+        Me.Label1.Name = "Label1"
+        Me.Label1.Size = New System.Drawing.Size(205, 13)
+        Me.Label1.TabIndex = 9
+        Me.Label1.Text = "http Adresse des WMS-Servers eingeben:"
         '
-        'ComboBoxBBoxI
+        'TextBoxUrl
         '
-        Me.ComboBoxBBoxI.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxBBoxI.FormattingEnabled = True
-        Me.ComboBoxBBoxI.Location = New System.Drawing.Point(20, 580)
-        Me.ComboBoxBBoxI.Name = "ComboBoxBBoxI"
-        Me.ComboBoxBBoxI.Size = New System.Drawing.Size(252, 21)
-        Me.ComboBoxBBoxI.TabIndex = 22
-        Me.ComboBoxBBoxI.Visible = False
+        Me.TextBoxUrl.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.TextBoxUrl.Location = New System.Drawing.Point(6, 25)
+        Me.TextBoxUrl.Name = "TextBoxUrl"
+        Me.TextBoxUrl.Size = New System.Drawing.Size(400, 20)
+        Me.TextBoxUrl.TabIndex = 8
         '
-        'ButtonFindScale
-        '
-        Me.ButtonFindScale.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonFindScale.Location = New System.Drawing.Point(540, 439)
-        Me.ButtonFindScale.Name = "ButtonFindScale"
-        Me.ButtonFindScale.Size = New System.Drawing.Size(123, 36)
-        Me.ButtonFindScale.TabIndex = 23
-        Me.ButtonFindScale.Text = "Optimale Scale finden"
-        Me.ButtonFindScale.UseVisualStyleBackColor = True
-        '
         'capxml2wms
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.ClientSize = New System.Drawing.Size(675, 601)
-        Me.Controls.Add(Me.ButtonFindScale)
-        Me.Controls.Add(Me.ComboBoxBBoxI)
-        Me.Controls.Add(Me.Label6)
-        Me.Controls.Add(Me.ComboBoxBBox)
-        Me.Controls.Add(Me.ComboBoxFormat)
-        Me.Controls.Add(Me.Label5)
-        Me.Controls.Add(Me.HScrollBar1)
-        Me.Controls.Add(Me.Label4)
-        Me.Controls.Add(Me.ComboBoxEPSG)
-        Me.Controls.Add(Me.ButtonCheckAll)
-        Me.Controls.Add(Me.ButtonCheckNone)
-        Me.Controls.Add(Me.Label3)
-        Me.Controls.Add(Me.CheckedListBoxLayers)
-        Me.Controls.Add(Me.ButtonShowMap)
-        Me.Controls.Add(Me.ButtonGetCapabilities)
-        Me.Controls.Add(Me.ComboBoxVersion)
-        Me.Controls.Add(Me.Label2)
-        Me.Controls.Add(Me.TextBoxXML)
-        Me.Controls.Add(Me.Label1)
-        Me.Controls.Add(Me.TextBoxUrl)
+        Me.Controls.Add(Me.Panel2)
+        Me.Controls.Add(Me.Panel1)
         Me.Controls.Add(Me.ButtonErstellen)
         Me.Icon = CType(resources.GetObject("$this.Icon"), System.Drawing.Icon)
         Me.Name = "capxml2wms"
         Me.Text = "capxml2wms"
+        Me.Panel1.ResumeLayout(False)
+        Me.Panel1.PerformLayout()
+        Me.Panel2.ResumeLayout(False)
+        Me.Panel2.PerformLayout()
         Me.ResumeLayout(False)
-        Me.PerformLayout()
 
     End Sub
     Private WithEvents ButtonErstellen As System.Windows.Forms.Button
-    Private WithEvents TextBoxUrl As System.Windows.Forms.TextBox
-    Private WithEvents Label1 As System.Windows.Forms.Label
-    Private WithEvents TextBoxXML As System.Windows.Forms.TextBox
-    Private WithEvents ComboBoxVersion As System.Windows.Forms.ComboBox
-    Private WithEvents Label2 As System.Windows.Forms.Label
-    Private WithEvents ButtonGetCapabilities As System.Windows.Forms.Button
-    Private WithEvents ButtonShowMap As System.Windows.Forms.Button
-    Private WithEvents CheckedListBoxLayers As System.Windows.Forms.CheckedListBox
-    Private WithEvents Label3 As System.Windows.Forms.Label
-    Private WithEvents ButtonCheckNone As System.Windows.Forms.Button
+    Friend WithEvents Panel1 As System.Windows.Forms.Panel
+    Private WithEvents ButtonFindScale As System.Windows.Forms.Button
     Private WithEvents ButtonCheckAll As System.Windows.Forms.Button
+    Private WithEvents ButtonCheckNone As System.Windows.Forms.Button
+    Private WithEvents Label3 As System.Windows.Forms.Label
+    Private WithEvents CheckedListBoxLayers As System.Windows.Forms.CheckedListBox
+    Private WithEvents ComboBoxBBoxI As System.Windows.Forms.ComboBox
+    Private WithEvents Label6 As System.Windows.Forms.Label
+    Private WithEvents ComboBoxBBox As System.Windows.Forms.ComboBox
+    Private WithEvents ComboBoxFormat As System.Windows.Forms.ComboBox
+    Private WithEvents Label5 As System.Windows.Forms.Label
     Private WithEvents Label4 As System.Windows.Forms.Label
     Private WithEvents ComboBoxEPSG As System.Windows.Forms.ComboBox
-    Private WithEvents HScrollBar1 As System.Windows.Forms.HScrollBar
-    Private WithEvents Label5 As System.Windows.Forms.Label
-    Private WithEvents ComboBoxFormat As System.Windows.Forms.ComboBox
-    Private WithEvents ComboBoxBBox As System.Windows.Forms.ComboBox
-    Private WithEvents Label6 As System.Windows.Forms.Label
-    Private WithEvents ComboBoxBBoxI As System.Windows.Forms.ComboBox
-    Private WithEvents ButtonFindScale As System.Windows.Forms.Button
+    Friend WithEvents Panel2 As System.Windows.Forms.Panel
+    Private WithEvents TextBoxXML As System.Windows.Forms.TextBox
+    Private WithEvents ButtonGetCapabilities As System.Windows.Forms.Button
+    Private WithEvents ComboBoxVersion As System.Windows.Forms.ComboBox
+    Private WithEvents Label2 As System.Windows.Forms.Label
+    Private WithEvents Label1 As System.Windows.Forms.Label
+    Private WithEvents TextBoxUrl As System.Windows.Forms.TextBox
 
 End Class

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx	2011-08-01 18:08:06 UTC (rev 3048)
@@ -112,12 +112,12 @@
     <value>2.0</value>
   </resheader>
   <resheader name="reader">
-    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
   </resheader>
   <resheader name="writer">
-    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
   </resheader>
-  <assembly alias="System.Drawing" name="System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
     <value>
         AAABAAEAMC8AAAEAGAAQHAAAFgAAACgAAAAwAAAAXgAAAAEAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -85,39 +85,13 @@
         End If
         CheckedListBoxLayers.Items.Add(Layername, False)
     End Sub
-
-    Private Sub ButtonGetCapabilities_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonGetCapabilities.Click
-        GotCapabilities = GetCapabilities()
-        maxScale = 1000
-        minScale = 0
-        If Not recScale Is Nothing Then
-            recScale.Clear()
-        End If
-    End Sub
-
-    Private Sub ButtonShowMap_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonShowMap.Click
-        Dim MeineSkalierung As Double
-        MeineSkalierung = 2.0 * Me.HScrollBar1.Value
-        mapUrl = makeGetMapUrl(MeineSkalierung)
-        Dim center As point
-        center.x = 0
-        center.y = 0
-        Dim SM As New Map(mapUrl, 0, 0, 0, center)
-        'MsgBox("Noch nicht vorhanden!", MsgBoxStyle.Information, "Hinweis!")
-        SM.ButtonAddToRecommendedScale.Visible = False
-        SM.ButtonHelp.Visible = False
-        SM.ButtonScaleDown.Visible = False
-        SM.ButtonScaleUp.Visible = False
-        SM.ButtonUseAsMaxScale.Visible = False
-        SM.ButtonUseAsMinScale.Visible = False
-        SM.LabelScaleDiagonal.Visible = False
-        SM.LabelScaleVertical.Visible = False
-        SM.ShowDialog()
-    End Sub
     Friend _srs As Integer
     Friend _pixelwidth As Integer
     Private Sub ButtonFindScale_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonFindScale.Click
         Dim BBoxString As String
+        If Me.ComboBoxEPSG.Items.Count = 0 Then
+            Return
+        End If
 
         _srs = Me.ComboBoxEPSG.SelectedItem
 
@@ -199,75 +173,7 @@
         mapUrl += "&FORMAT=" & Me.ComboBoxFormat.SelectedItem.ToString
         makeGetMapUrlFromBBox = mapUrl
     End Function
-    Private Function makeGetMapUrl(ByVal scale As Double) As String
-        'http:// www.lv-bw.de/dv/service/getrds2.asp?login=dv&pw=anonymous
-        '&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap
-        '&SRS=EPSG:31467
-        '&BBOX=3500394.51 , 5371405.09 , 3520394.51 , 5391405.09 
-        '&WIDTH=1000
-        '&HEIGHT=1000
-        '&LAYERS=DVTK50K
-        '&STYLES=
-        '&FORMAT=image/png
-
-
-        mapUrl = wmsUrl & "SERVICE=WMS&VERSION=" & Version & "&REQUEST=GetMap"
-
-        mapUrl += "&SRS=EPSG:" & Me.ComboBoxEPSG.SelectedItem
-
-        Dim rxmin As Double
-        Dim rxmax As Double
-        Dim rymin As Double
-        Dim rymax As Double
-
-        If Me.ComboBoxEPSG.SelectedItem = "4326" Then
-            Me.ComboBoxBBoxI.SelectedIndex = Me.ComboBoxBBox.SelectedIndex
-            GetBBoxValues(Me.ComboBoxBBoxI.SelectedItem)
-        Else
-            Try
-                GetBBoxValues(Me.OBBoxes.Item("EPSG:" & Me.ComboBoxEPSG.SelectedItem))
-            Catch ex As Exception
-                'todo: und jetzt umrechnen !
-                'das spar ich mir wohl, oder !
-                Me.ComboBoxBBoxI.SelectedIndex = Me.ComboBoxBBox.SelectedIndex
-                GetBBoxValues(Me.ComboBoxBBoxI.SelectedItem)
-                ' jetzt haben wir die BBox zum WGS84
-                MsgBox("Kartenansicht f?r diese Auswahl nicht implementiert", MsgBoxStyle.Exclamation)
-                Exit Function
-            End Try
-        End If
-
-        Dim HalbeKantenlaengex As Double = (rmaxx - rminx) / scale
-        Dim HalbeKantenlaengey As Double = (rmaxy - rminy) / scale
-        Dim HalbeKantenlaenge As Double = HalbeKantenlaengex
-        If HalbeKantenlaengex > HalbeKantenlaengey Then
-            HalbeKantenlaenge = HalbeKantenlaengey
-        End If
-        ' is in x und y die gleiche Einheit?
-        rxmin = rxmitte - HalbeKantenlaenge
-        rxmax = rxmitte + HalbeKantenlaenge
-        rymin = rymitte - HalbeKantenlaenge
-        rymax = rymitte + HalbeKantenlaenge
-
-        Dim BBox As String = "&BBox=" & rxmin.ToString(DPunkt) & "," & rymin.ToString(DPunkt) & ","
-        BBox += rxmax.ToString(DPunkt) & "," & rymax.ToString(DPunkt)
-
-        mapUrl += BBox
-        mapUrl += "&WIDTH=500"
-        mapUrl += "&HEIGHT=500"
-        ' und die gew?hlten Layer durch Komma getrennt
-        Dim SelectedLayers As String = ""
-        For Each s As String In CheckedListBoxLayers.CheckedItems
-            SelectedLayers += "," & s.Split("|")(0)
-        Next
-        If SelectedLayers <> "" Then
-            mapUrl += "&LAYERS=" & SelectedLayers.Substring(1).Replace(" ", "%20")
-        End If
-        mapUrl += "&STYLES="
-        mapUrl += "&FORMAT=" & Me.ComboBoxFormat.SelectedItem.ToString
-        makeGetMapUrl = mapUrl
-    End Function
-
+    
     Friend Function metersToBBoxVertical(ByVal epsg As Integer) As Double
         If epsg = 4326 Then
             metersToBBoxVertical = 360 / (WGS84.a * Math.PI * 2)
@@ -297,15 +203,19 @@
     End Function
     Private Sub ButtonErstellen_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonErstellen.Click
 
+        If Not GotCapabilities Then
+            GotCapabilities = GetCapabilities()
+        End If
+        If Not GotCapabilities Then
+            Return
+        End If
+
+
         Dim wmsFileName As String = IO.Path.ChangeExtension(xmlFileName, ".wms")
         IO.File.Delete(wmsFileName) 'vorsichtshalber
         Dim encoding As System.Text.Encoding = New System.Text.UTF8Encoding(False)
         Dim F As New System.IO.StreamWriter(wmsFileName, False, encoding)
 
-        If Not GotCapabilities Then
-            GotCapabilities = GetCapabilities()
-        End If
-
         Me.ComboBoxBBoxI.SelectedIndex = Me.ComboBoxBBox.SelectedIndex
         GetBBoxValues(Me.ComboBoxBBoxI.SelectedItem)
 
@@ -337,7 +247,7 @@
         F.WriteLine("StylesUrlPart:     STYLES=")
         F.WriteLine("ImageFormatUrlPart:FORMAT=" & Me.ComboBoxFormat.SelectedItem.ToString)
         F.WriteLine("BoundingBoxTopLeftWGS84: " & maxy & " " & minx)
-        F.WriteLine("BoundingBoxButtomRightWGS84: " & miny & " " & maxx)
+        F.WriteLine("BoundingBoxBottomRightWGS84: " & miny & " " & maxx)
         F.WriteLine("#BBox_Mitte: " & mittey & " " & mittex)
         F.WriteLine("MinScale:   " & (Math.Ceiling(minScale * 10000) / 10000).ToString(DPunkt))
         F.WriteLine("MaxScale:   " & (Math.Floor(maxScale * 10000) / 10000).ToString(DPunkt))
@@ -425,7 +335,6 @@
 
     Private Sub TextBoxUrl_TextChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles TextBoxUrl.TextChanged
         GotCapabilities = False
-        Me.ButtonShowMap.Enabled = False
         wmsUrl = Me.TextBoxUrl.Text
         capsUrl = Me.TextBoxUrl.Text
     End Sub
@@ -500,8 +409,6 @@
         Me.TextBoxXML.Text = System.Text.Encoding.UTF8.GetString(ms.GetBuffer())
         ms.Close()
 
-        Me.ButtonShowMap.Enabled = True
-
         '1. Version aus WMT_MS_Capabilities
         For Each nl As XmlNode In xd.GetElementsByTagName("WMT_MS_Capabilities")
             If nl.NodeType = XmlNodeType.Element Then
@@ -522,16 +429,22 @@
             End If
         Next
 
+        If Caps Is Nothing Then
+            Return False
+        End If
+
         '2. OnlineResource  aus Service
-        For Each nl As XmlNode In Service
-            If nl.NodeType = XmlNodeType.Element Then
-                If nl.Name = "OnlineResource" Then
-                    Dim ne As XmlElement = nl
-                    OnlineResource = ne.GetAttribute("xlink:href")
-                    Exit For
+        If Not Service Is Nothing Then
+            For Each nl As XmlNode In Service
+                If nl.NodeType = XmlNodeType.Element Then
+                    If nl.Name = "OnlineResource" Then
+                        Dim ne As XmlElement = nl
+                        OnlineResource = ne.GetAttribute("xlink:href")
+                        Exit For
+                    End If
                 End If
-            End If
-        Next
+            Next
+        End If
 
         Dim Request As XmlElement = Nothing
         Dim Exception As XmlElement = Nothing
@@ -558,7 +471,7 @@
             End If
         Next
         If Layer Is Nothing Then
-            Exit Function
+            Return False
         End If
 
         Dim ltmp() As String
@@ -589,16 +502,6 @@
                 End If
             Next
         Next
-        Me.ComboBoxEPSG.SelectedIndex = -1
-        For i As Integer = 0 To Me.ComboBoxEPSG.Items.Count - 1
-            If Me.ComboBoxEPSG.Items.Item(i) = "4326" Then
-                Me.ComboBoxEPSG.SelectedIndex = i
-                Exit For
-            Else
-                'falls ?berhaupt was drin steht
-                Me.ComboBoxEPSG.SelectedIndex = 0
-            End If
-        Next
 
         '11.
         Me.ComboBoxFormat.Items.Clear()
@@ -676,23 +579,45 @@
             If n.NodeType = XmlNodeType.Element Then
                 Dim e As XmlElement = n
                 Dim stmp As String = e.GetAttribute("SRS")
-                If Not OBBoxes.ContainsKey(stmp) Then
-                    OBBoxes.Add(stmp, e)
+                If Not stmp = "EPSG:4326" Then
+                    If Not OBBoxes.ContainsKey(stmp) Then
+                        OBBoxes.Add(stmp, e)
+                    End If
                 End If
             End If
         Next
+        '<LatLonBoundingBox minx="8.334125" miny="44.552846" maxx="11.658327" maxy="46.739748" />
         If Not OBBoxes.ContainsKey("EPSG:4326") Then
             For Each n As XmlNode In Layer.GetElementsByTagName("LatLonBoundingBox")
                 If n.NodeType = XmlNodeType.Element Then
                     Dim e As XmlElement = n
-                    Dim stmp As String = e.GetAttribute("SRS")
-                    If Not stmp = "" And Not OBBoxes.ContainsKey(stmp) Then
+                    If Not OBBoxes.ContainsKey("EPSG:4326") Then
                         OBBoxes.Add("EPSG:4326", e)
+                        If Me.ComboBoxEPSG.Items.Count = 0 Then
+                            Dim s As String = "4326"
+                            SRSD.Add("SRS=EPSG:" & s, " ")
+                            SRS = SRS & "SRS=EPSG:" & s & " "
+                            SRSCW = SRSCW & " " & s
+                            ComboBoxEPSG.Items.Add(s)
+                        End If
                     End If
                 End If
             Next
         End If
 
+        ' 14 Nacharbeiten
+        Me.ComboBoxEPSG.SelectedIndex = -1
+        For i As Integer = 0 To Me.ComboBoxEPSG.Items.Count - 1
+            If Me.ComboBoxEPSG.Items.Item(i) = "4326" Then
+                Me.ComboBoxEPSG.SelectedIndex = i
+                Exit For
+            Else
+                'falls ?berhaupt was drin steht
+                Me.ComboBoxEPSG.SelectedIndex = 0
+            End If
+        Next
+
+
         ButtonCheckAll_Click(Nothing, Nothing)
         Return True
 
@@ -709,6 +634,9 @@
         'Dim rminy As Double
         'Dim rmaxx As Double
         'Dim rmaxy As Double
+        If e Is Nothing Then
+            Return
+        End If
         minx = e.GetAttribute("minx")
         rminx = Double.Parse(minx, DPunkt.NumberFormat)
         minx = Format(rminx, "0.0000").Replace(",", ".")
@@ -798,4 +726,12 @@
 
     End Function
 
+    Private Sub ButtonGetCapabilities_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonGetCapabilities.Click
+        GotCapabilities = GetCapabilities()
+        maxScale = 1000
+        minScale = 0
+        If Not recScale Is Nothing Then
+            recScale.Clear()
+        End If
+    End Sub
 End Class

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,5 +1,5 @@
 ???<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -14,10 +14,11 @@
     <ApplicationIcon>gc.ico</ApplicationIcon>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
-    <OldToolsVersion>2.0</OldToolsVersion>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
     <PublishUrl>publish\</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Disk</InstallFrom>
@@ -30,7 +31,6 @@
     <MapFileExtensions>true</MapFileExtensions>
     <ApplicationRevision>0</ApplicationRevision>
     <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <IsWebBootstrapper>false</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
   </PropertyGroup>
@@ -41,7 +41,7 @@
     <DefineTrace>true</DefineTrace>
     <OutputPath>bin\Debug\</OutputPath>
     <DocumentationFile>capxml2wms.xml</DocumentationFile>
-    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022,42353,42354,42355</NoWarn>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
@@ -50,7 +50,7 @@
     <Optimize>true</Optimize>
     <OutputPath>bin\Release\</OutputPath>
     <DocumentationFile>capxml2wms.xml</DocumentationFile>
-    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022,42353,42354,42355</NoWarn>
   </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
@@ -133,7 +133,7 @@
   <ItemGroup>
     <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
       <Visible>False</Visible>
-      <ProductName>.NET Framework Client Profile</ProductName>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
       <Install>false</Install>
     </BootstrapperPackage>
     <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,4 +1,5 @@
-???<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+???<?xml version="1.0" encoding="utf-8"?>
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <PublishUrlHistory>http://localhost/capxml2wms/</PublishUrlHistory>
     <InstallUrlHistory>

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms.sln
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms.sln	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms.sln	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,6 +1,6 @@
 ???
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual Basic Express 2008
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Basic Express 2010
 Project("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}") = "capxml2wms", "capxml2wms\capxml2wms.vbproj", "{623B1E12-B5BF-4835-A982-AE5500BFADC8}"
 EndProject
 Global



From araber95 at mail.berlios.de  Tue Aug  2 11:38:29 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Tue,  2 Aug 2011 11:38:29 AM +0200
Subject: [Cachewolf-svn] r3049 - in branches/r1.2/src/CacheWolf: . navi
Message-ID: <20110802093829.90F864833AF@sheep.berlios.de>

Author: araber95
Date: 2011-08-02 11:38:29 +0200 (Tue, 02 Aug 2011)
New Revision: 3049

Modified:
   branches/r1.2/src/CacheWolf/Version.java
   branches/r1.2/src/CacheWolf/navi/TransformCoordinates.java
Log:
changed missing changes for release 1.2

Modified: branches/r1.2/src/CacheWolf/Version.java
===================================================================
--- branches/r1.2/src/CacheWolf/Version.java	2011-08-01 18:08:06 UTC (rev 3048)
+++ branches/r1.2/src/CacheWolf/Version.java	2011-08-02 09:38:29 UTC (rev 3049)
@@ -27,6 +27,7 @@
 
 import com.stevesoft.ewe_pat.Regex;
 
+import ewe.io.ByteArrayInputStream;
 import ewe.io.IOException;
 import ewe.sys.Convert;
 import ewe.sys.Vm;
@@ -71,7 +72,9 @@
 	 * @throws IOException
 	 */
 	public static void checkForUpdates() throws IOException {
-		Properties curvers = UrlFetcher.fetchPropertyList("http://svn.berlios.de/svnroot/repos/cachewolf/trunk/currentversions.txt");
+		String currentVersionsUrl="http://svn.berlios.de/svnroot/repos/cachewolf/trunk/currentversions.txt";
+		Properties curvers = new Properties();
+		curvers.load(new ByteArrayInputStream(UrlFetcher.fetchData(currentVersionsUrl)));
 		versionnumbers = new String[updateavailabe.length];
 		for (int i = updateavailabe.length-1; i >=1; i--) {
 			updateavailabe[i] = checkVersion(curvers, "T"+(i-1), i); // this also sets versionnumber[i]
@@ -132,7 +135,7 @@
 				Regex s;
 				int i = svnRString.indexOf(' ');
 				if (i > 0) {
-					tmp = UrlFetcher.fetchString(svnRString.substring(0, i));
+					tmp = UrlFetcher.fetch(svnRString.substring(0, i));
 					s = new Regex (svnRString.substring(i+1, svnRString.length())); // flyingfish works 3/2008 with ("(?i)Revision[\\s]*[:=][\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)");
 				} else { versionnumbers[t] = "error: no RegEx"; return 3; }
 				s.search(tmp);

Modified: branches/r1.2/src/CacheWolf/navi/TransformCoordinates.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/TransformCoordinates.java	2011-08-01 18:08:06 UTC (rev 3048)
+++ branches/r1.2/src/CacheWolf/navi/TransformCoordinates.java	2011-08-02 09:38:29 UTC (rev 3049)
@@ -162,12 +162,12 @@
 	private static final TransformParameters GB_ITALIAN_SARDINIA_TO_WGS84 =  new TransformParameters(-168.6, -34.0, 38.6, 0.374, 0.679, 1.379, 9.48, HAYFORD1909);
 	private static final Area ITALY_SARDINIA = new Area(new CWPoint(42, 6), new CWPoint(38, 11));
 	private static final Area ITALY_SARDINIA_GK = new Area(wgs84ToEpsg(ITALY_SARDINIA.topleft, EPSG_ITALIAN_GB_EW1).toTrackPoint(TransformCoordinates.LOCALSYSTEM_ITALIAN_GB),
-			wgs84ToEpsg(ITALY_SARDINIA.buttomright, EPSG_ITALIAN_GB_EW1).toTrackPoint(TransformCoordinates.LOCALSYSTEM_ITALIAN_GB));
+			wgs84ToEpsg(ITALY_SARDINIA.bottomright, EPSG_ITALIAN_GB_EW1).toTrackPoint(TransformCoordinates.LOCALSYSTEM_ITALIAN_GB));
 
 	private static final TransformParameters GB_ITALIAN_SICILIA_TO_WGS84 =  new TransformParameters(-50.2, -50.4, 84.8, 0.690, 2.012, -0.459, 28.08, HAYFORD1909);
 	private static final Area ITALY_SICILIA = new Area(new CWPoint(39, 12), new CWPoint(36.3, 15.6));
 	private static final Area ITALY_SICILIA_GK = new Area(wgs84ToEpsg(ITALY_SICILIA.topleft, EPSG_ITALIAN_GB_EW2).toTrackPoint(TransformCoordinates.LOCALSYSTEM_ITALIAN_GB),
-			wgs84ToEpsg(ITALY_SICILIA.buttomright, EPSG_ITALIAN_GB_EW2).toTrackPoint(TransformCoordinates.LOCALSYSTEM_ITALIAN_GB));
+			wgs84ToEpsg(ITALY_SICILIA.bottomright, EPSG_ITALIAN_GB_EW2).toTrackPoint(TransformCoordinates.LOCALSYSTEM_ITALIAN_GB));
 
 	// see also http://hal.gis.univie.ac.at/karto/lehr/fachbereiche/geoinfo/givi0304/tutorials/ersteschritte/projectionen.htm#ParMGIWGS84 
 	// taken from taken from http://www.crs-geo.eu/crseu/EN/Home/homepage__node.html?__nnn=true click on "national CRS" -> Austria -> AT (translation *-1 as of 11-8-2009)



From engywuck at mail.berlios.de  Sun Aug  7 10:05:04 2011
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sun,  7 Aug 2011 10:05:04 AM +0200
Subject: [Cachewolf-svn] r3050 - trunk/src/CacheWolf
Message-ID: <20110807080504.646D64833AA@sheep.berlios.de>

Author: engywuck
Date: 2011-08-07 10:05:03 +0200 (Sun, 07 Aug 2011)
New Revision: 3050

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
When caches are checked (or unchecked) using the multi selection, then this now also covers non visible additional waypoints. 

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-08-02 09:38:29 UTC (rev 3049)
+++ trunk/src/CacheWolf/myTableModel.java	2011-08-07 08:05:03 UTC (rev 3050)
@@ -578,14 +578,21 @@
 			ch.is_Checked = !ch.is_Checked;
 			tcControl.repaintCell(j, x);
 			// set the ceckbox also for addi wpts
-			if (ch.hasAddiWpt() && singleRow) {
+			if (ch.hasAddiWpt()) {
 				CacheHolder addiWpt;
 				int addiCount = ch.addiWpts.getCount();
 				for (int i = 0; i < addiCount; i++) {
 					addiWpt = (CacheHolder) ch.addiWpts.get(i);
-					addiWpt.is_Checked = ch.is_Checked;
-					if (addiWpt.isVisible()) {
-						tcControl.repaintCell(cacheDB.getIndex(addiWpt), x);
+					int addiIdx = cacheDB.getIndex(addiWpt);
+					// Change check state of addi wpt only if
+					// it is outside the selected range and not visible
+					// - otherwise it will be touched by this 
+					// algorithm
+					if (! addiWpt.isVisible() && (addiIdx > to || addiIdx < from)){
+						addiWpt.is_Checked = ch.is_Checked;
+						if (addiWpt.isVisible()) {
+							tcControl.repaintCell(cacheDB.getIndex(addiWpt), x);
+						}
 					}
 				}
 



From pfeffer at mail.berlios.de  Mon Aug  8 01:54:01 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon,  8 Aug 2011 01:54:01 AM +0200
Subject: [Cachewolf-svn] r3051 - trunk/src/CacheWolf/navi
Message-ID: <20110807235401.6FEAA481261@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-08 01:54:01 +0200 (Mon, 08 Aug 2011)
New Revision: 3051

Modified:
   trunk/src/CacheWolf/navi/MapLoader.java
Log:
MapLoader: Calculate the distance between tiles more exactly (using the WGS84-ellipsoid instead of assuming a sphere). This is still not exact, because the wg84-ellipsoid is used, but ellipsoid which is used for the projection would be really correct.

Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2011-08-07 08:05:03 UTC (rev 3050)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2011-08-07 23:54:01 UTC (rev 3051)
@@ -57,7 +57,7 @@
 import ewe.util.mString;
 
 /**
- * 
+ *
  * start offset for language file: 4800
  */
 
@@ -82,7 +82,7 @@
 	boolean fetchOnlyMapWithCache = false;
 
 	/**
-	 * 
+	 *
 	 * @param prxy
 	 * @param prt
 	 * @param wmspath
@@ -146,7 +146,7 @@
 
 	/**
 	 * calculates the Expedia Alti = scale which fits in distance to its edges
-	 * 
+	 *
 	 * @param center
 	 * @param distance
 	 *            in meters
@@ -164,7 +164,7 @@
 	/**
 	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
 	 * in path
-	 * 
+	 *
 	 * @param center
 	 *            centre of all tiles
 	 * @param radius
@@ -177,7 +177,7 @@
 	 *            in pixels
 	 * @param path
 	 *            without "/" at the end
-	 * 
+	 *
 	 */
 	public void setTiles(CWPoint center, float radius, float scale, Point size, int overlapping) {
 		double metersPerLat = (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
@@ -192,8 +192,15 @@
 		// if (toplefti.latDec <= bottomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above bottom right");
 		topleft = new CWPoint(toplefti);
 		bottomright = new CWPoint(bottomrighti);
-		double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
+		// veraltet: Berechnung auf Kugel: double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		// veraltet: Berechnung auf Kugel: double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
+
+		CWPoint center = new CWPoint((topleft.latDec + bottomright.latDec)/2, (toplefti.lonDec + bottomrighti.lonDec)/2);
+		CWPoint centerleft = new CWPoint((topleft.latDec + bottomright.latDec)/2, toplefti.lonDec);
+		CWPoint centerbottom = new CWPoint(bottomright.latDec, (toplefti.lonDec + bottomrighti.lonDec)/2);
+		double metersPerLat = 1000.0 * center.getDistance(centerbottom)/(center.latDec - centerbottom.latDec);
+		double metersPerLon = 1000.0 * center.getDistance(centerleft  )/(center.lonDec - centerleft.lonDec);
+
 		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
 		double pixelsPerLat = metersPerLat / metersperpixel;
 		double pixelsPerLon = metersPerLon / metersperpixel;
@@ -282,7 +289,7 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -568,7 +575,7 @@
 	 * This method is used in case the online map service provides only certain steps of
 	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
 	 * will be used instead of the wished scale.
-	 * 
+	 *
 	 * @param scale
 	 * @return
 	 */
@@ -582,7 +589,7 @@
 
 	/**
 	 * Overlaod this to integrate name of layers
-	 * 
+	 *
 	 * @return friendly service name
 	 */
 	public String getName() {
@@ -593,7 +600,7 @@
 	 * This method is called to get a name of the
 	 * online map service which will be part of the filename
 	 * used for the downloaded image
-	 * 
+	 *
 	 * @return friendly service name
 	 */
 	public String getNameForFileSystem() {
@@ -608,7 +615,7 @@
 	 * Overload this and return the URL to the map image, don't call super
 	 * Alternatively overload getUrlForBoundingBoxInternal
 	 * You must overload either this method or getUrlForBoundingBox
-	 * 
+	 *
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -624,7 +631,7 @@
 	 * This is made protected and named "...Internal" because a lot of services
 	 * don't work correctly when a map is requested, that is not exactly quadratic
 	 * --> alway use getUrlForCenter...
-	 * 
+	 *
 	 * @param surArea
 	 * @param pixelsize
 	 * @return
@@ -636,7 +643,7 @@
 	/**
 	 * overload this if your map service uses a special projection
 	 * an return an Area that is quadratic in that projection
-	 * 
+	 *
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -656,7 +663,7 @@
 
 	/**
 	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
-	 * 
+	 *
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -684,7 +691,7 @@
 	double maxscaleWMS;
 
 	/**
-	 * 
+	 *
 	 * @param filename
 	 *            without file extension
 	 * @throws IOException
@@ -782,7 +789,7 @@
 	private static final int BOTTOMLEFT_INDEX = 3;
 
 	/**
-	 * 
+	 *
 	 * @param maparea
 	 * @return [0] = topleft, [1] = bottomright, [2] = topright, [3] = bottomleft
 	 */
@@ -875,7 +882,7 @@
 	 * a) if only one is in the array 0 is returned
 	 * b) if there are more, find out which one matches the correct zone (e.g. Gau?-K?ger stripe)
 	 * Call this routine with center of the area (use Area.getcenter())
-	 * 
+	 *
 	 * @param p
 	 *            Point for which the epsg code is searched for
 	 * @return



From araber95 at mail.berlios.de  Tue Aug  9 03:11:37 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Tue,  9 Aug 2011 03:11:37 PM +0200
Subject: [Cachewolf-svn] r3052 - trunk/src/CacheWolf
Message-ID: <20110809131137.8DD33481533@sheep.berlios.de>

Author: araber95
Date: 2011-08-09 15:11:37 +0200 (Tue, 09 Aug 2011)
New Revision: 3052

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
Reducing Overlapping of maps to 2 Pixel

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-08-07 23:54:01 UTC (rev 3051)
+++ trunk/src/CacheWolf/Preferences.java	2011-08-09 13:11:37 UTC (rev 3052)
@@ -276,7 +276,7 @@
 	 * Max. length for Garmin waypoint names (for etrex which can only accept 6 chars)
 	 */
 	public int garminMaxLen = 0;
-	/** OC true = alle neu Laden false = wenn ?nderungsdatum neuer */
+	/** OC true = alle neu Laden false = wenn ???nderungsdatum neuer */
 	public boolean downloadAllOC = false;
 	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
 	/**
@@ -343,7 +343,7 @@
 	/** Selected Size of map tiles */
 	public int mapTileSize = 1;
 	/** How many should maptiles overlap */
-	public int mapOverlapping = 100;
+	public int mapOverlapping = 2;
 	/** Width and height of free defined tile size */
 	public int tilewidth;
 	public int tileheight;
@@ -710,7 +710,7 @@
 			mapTileSize = Convert.parseInt(tmp);
 			tmp = atts.getValue("overlapping");
 			if (tmp == null || tmp.length() == 0)
-				tmp = "100";
+				tmp = "2";
 			mapOverlapping = Convert.parseInt(tmp);
 			tmp = atts.getValue("tilewidth");
 			tilewidth = (tmp != null && tmp.length() > 0) ? Convert.parseInt(tmp) : 0;
@@ -1210,7 +1210,7 @@
 			return; // no select
 		// check selection
 		if (lastProfile.equals(f.newSelectedProfile)) {
-			// aktives Profil kann nicht gel?scht / umbenannt werden;
+			// aktives Profil kann nicht gel???scht / umbenannt werden;
 			new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(ErrorMsgActive, "[Profile active...]"), FormBase.MBOK).execute();
 		} else {
 			boolean err = true;
@@ -1224,7 +1224,7 @@
 				p.dataDir = absoluteBaseDir + f.newSelectedProfile + "/";
 				p.readIndex();
 				String mapsPath = absoluteBaseDir + "maps" + p.getRelativeCustomMapsPath();
-				int answer = new MessageBox("", mapsPath + " " + MyLocale.getMsg(143, "l?schen ?"), FormBase.MBYESNO).execute();
+				int answer = new MessageBox("", mapsPath + " " + MyLocale.getMsg(143, "l???schen ?"), FormBase.MBYESNO).execute();
 				if (answer == 1) {
 					deleteDirectory(new FileBugfix(mapsPath));
 				}



From araber95 at mail.berlios.de  Wed Aug 10 10:58:17 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 10 Aug 2011 10:58:17 AM +0200
Subject: [Cachewolf-svn] r3053 - trunk/src/CacheWolf/navi
Message-ID: <20110810085818.2250848153C@sheep.berlios.de>

Author: araber95
Date: 2011-08-10 10:58:17 +0200 (Wed, 10 Aug 2011)
New Revision: 3053

Modified:
   trunk/src/CacheWolf/navi/MapLoader.java
Log:
download of map per cache without calculating distance on ellipsoid. 

Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2011-08-09 13:11:37 UTC (rev 3052)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2011-08-10 08:58:17 UTC (rev 3053)
@@ -57,7 +57,7 @@
 import ewe.util.mString;
 
 /**
- *
+ * 
  * start offset for language file: 4800
  */
 
@@ -82,7 +82,7 @@
 	boolean fetchOnlyMapWithCache = false;
 
 	/**
-	 *
+	 * 
 	 * @param prxy
 	 * @param prt
 	 * @param wmspath
@@ -146,7 +146,7 @@
 
 	/**
 	 * calculates the Expedia Alti = scale which fits in distance to its edges
-	 *
+	 * 
 	 * @param center
 	 * @param distance
 	 *            in meters
@@ -164,7 +164,7 @@
 	/**
 	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
 	 * in path
-	 *
+	 * 
 	 * @param center
 	 *            centre of all tiles
 	 * @param radius
@@ -177,7 +177,7 @@
 	 *            in pixels
 	 * @param path
 	 *            without "/" at the end
-	 *
+	 * 
 	 */
 	public void setTiles(CWPoint center, float radius, float scale, Point size, int overlapping) {
 		double metersPerLat = (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
@@ -192,15 +192,21 @@
 		// if (toplefti.latDec <= bottomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above bottom right");
 		topleft = new CWPoint(toplefti);
 		bottomright = new CWPoint(bottomrighti);
-		// veraltet: Berechnung auf Kugel: double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
-		// veraltet: Berechnung auf Kugel: double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
+		double metersPerLat;
+		double metersPerLon;
+		if (topleft.equals(bottomright)) {
+			// veraltet: Berechnung auf Kugel: double
+			metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+			// veraltet: Berechnung auf Kugel: double
+			metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
+		} else {
+			CWPoint center = new CWPoint((topleft.latDec + bottomright.latDec) / 2.0, (toplefti.lonDec + bottomrighti.lonDec) / 2.0);
+			CWPoint centerleft = new CWPoint((topleft.latDec + bottomright.latDec) / 2.0, toplefti.lonDec);
+			CWPoint centerbottom = new CWPoint(bottomright.latDec, (toplefti.lonDec + bottomrighti.lonDec) / 2.0);
+			metersPerLat = 1000.0 * center.getDistance(centerbottom) / (center.latDec - centerbottom.latDec);
+			metersPerLon = 1000.0 * center.getDistance(centerleft) / (center.lonDec - centerleft.lonDec);
+		}
 
-		CWPoint center = new CWPoint((topleft.latDec + bottomright.latDec)/2, (toplefti.lonDec + bottomrighti.lonDec)/2);
-		CWPoint centerleft = new CWPoint((topleft.latDec + bottomright.latDec)/2, toplefti.lonDec);
-		CWPoint centerbottom = new CWPoint(bottomright.latDec, (toplefti.lonDec + bottomrighti.lonDec)/2);
-		double metersPerLat = 1000.0 * center.getDistance(centerbottom)/(center.latDec - centerbottom.latDec);
-		double metersPerLon = 1000.0 * center.getDistance(centerleft  )/(center.lonDec - centerleft.lonDec);
-
 		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
 		double pixelsPerLat = metersPerLat / metersperpixel;
 		double pixelsPerLon = metersPerLon / metersperpixel;
@@ -289,7 +295,7 @@
 	}
 
 	/**
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -575,7 +581,7 @@
 	 * This method is used in case the online map service provides only certain steps of
 	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
 	 * will be used instead of the wished scale.
-	 *
+	 * 
 	 * @param scale
 	 * @return
 	 */
@@ -589,7 +595,7 @@
 
 	/**
 	 * Overlaod this to integrate name of layers
-	 *
+	 * 
 	 * @return friendly service name
 	 */
 	public String getName() {
@@ -600,7 +606,7 @@
 	 * This method is called to get a name of the
 	 * online map service which will be part of the filename
 	 * used for the downloaded image
-	 *
+	 * 
 	 * @return friendly service name
 	 */
 	public String getNameForFileSystem() {
@@ -615,7 +621,7 @@
 	 * Overload this and return the URL to the map image, don't call super
 	 * Alternatively overload getUrlForBoundingBoxInternal
 	 * You must overload either this method or getUrlForBoundingBox
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -631,7 +637,7 @@
 	 * This is made protected and named "...Internal" because a lot of services
 	 * don't work correctly when a map is requested, that is not exactly quadratic
 	 * --> alway use getUrlForCenter...
-	 *
+	 * 
 	 * @param surArea
 	 * @param pixelsize
 	 * @return
@@ -643,7 +649,7 @@
 	/**
 	 * overload this if your map service uses a special projection
 	 * an return an Area that is quadratic in that projection
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -663,7 +669,7 @@
 
 	/**
 	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -691,7 +697,7 @@
 	double maxscaleWMS;
 
 	/**
-	 *
+	 * 
 	 * @param filename
 	 *            without file extension
 	 * @throws IOException
@@ -789,7 +795,7 @@
 	private static final int BOTTOMLEFT_INDEX = 3;
 
 	/**
-	 *
+	 * 
 	 * @param maparea
 	 * @return [0] = topleft, [1] = bottomright, [2] = topright, [3] = bottomleft
 	 */
@@ -880,9 +886,9 @@
 	/**
 	 * This method gives the number in the array of coordinateReferenceSystems, which should be used
 	 * a) if only one is in the array 0 is returned
-	 * b) if there are more, find out which one matches the correct zone (e.g. Gau?-K?ger stripe)
+	 * b) if there are more, find out which one matches the correct zone (e.g. Gau???-K???ger stripe)
 	 * Call this routine with center of the area (use Area.getcenter())
-	 *
+	 * 
 	 * @param p
 	 *            Point for which the epsg code is searched for
 	 * @return
@@ -891,7 +897,7 @@
 		int crsindex = 0;
 		if (coordinateReferenceSystem.length > 1) {
 			int ls = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau?-Kr?ger stripe?
+			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau???-Kr???ger stripe?
 			int wantepsg = gkbl.getEpsgCode();
 			for (crsindex = 0; crsindex < coordinateReferenceSystem.length; crsindex++) {
 				if (coordinateReferenceSystem[crsindex] == wantepsg)
@@ -907,7 +913,7 @@
 
 			}
 			if (crsindex < 0)
-				throw new IllegalArgumentException(MyLocale.getMsg(4829, "getUrlForBoundingBox: Point:") + " " + gkbl.toString() + MyLocale.getMsg(4830, "no matching Gau?-Kr?ger-Stripe in the EPSG-code list in the .wms"));
+				throw new IllegalArgumentException(MyLocale.getMsg(4829, "getUrlForBoundingBox: Point:") + " " + gkbl.toString() + MyLocale.getMsg(4830, "no matching Gau???-Kr???ger-Stripe in the EPSG-code list in the .wms"));
 		}
 		return crsindex;
 	}



From araber95 at mail.berlios.de  Sat Aug 20 03:29:06 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 20 Aug 2011 03:29:06 PM +0200
Subject: [Cachewolf-svn] r3054 - trunk/res_noewe
Message-ID: <20110820132906.6AAC4481368@sheep.berlios.de>

Author: araber95
Date: 2011-08-20 15:29:06 +0200 (Sat, 20 Aug 2011)
New Revision: 3054

Modified:
   trunk/res_noewe/spider.def
Log:
updated logsection of spider.def (after gc's change from 18.Aug.2011)

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-08-10 08:58:17 UTC (rev 3053)
+++ trunk/res_noewe/spider.def	2011-08-20 13:29:06 UTC (rev 3054)
@@ -128,22 +128,22 @@
 # blockRex extrahiert zun?chst aus der gesamten Seite den Logbereich
 blockRex           = <table class="LogsTable">((?s).*?)</table>\\s+<p>
 # singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
-singleLogExStart   = ><strong><img src=
-singleLogExEnd     = <small><a\ href="
+singleLogExStart   = class="logOwnerProfileName"
+singleLogExEnd     = class="AlignRight">
 # iconEx, nameTempEx, dateEx, singleLogEx werden auf einen singleLog angewendet
 iconExStart        = www.geocaching.com/images/icons/
 iconExEnd          = \ alt="
-nameTempExStart    = <a\ href='
+nameTempExStart    = <a\ href=
 nameTempExEnd      = /a>
 # Name extrahiert aus nameTemp
 nameExStart        = >
 nameExEnd          = <
-dateExStart        = "\ />&nbsp;
-dateExEnd          = \ by\ <a\ href='/profile/?guid=
-logExStart         = found)<br\ /><br\ />
-logExEnd           = <br\ /><br\ /><small><a\ href="
-logIdExStart         = '\ id='
-logIdExEnd           = '>
+dateExStart        = LogDate">
+dateExEnd          = </span>
+logExStart         = class="LogText">
+logExEnd           = </p>
+logIdExStart       = '\ id='
+logIdExEnd         = '>
 # Die Icons, die einen erfolgreichen Fund signalisieren
 icon_smile         = icon_smile.gif
 icon_camera        = icon_camera.gif



From engywuck at mail.berlios.de  Sun Aug 21 10:51:49 2011
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sun, 21 Aug 2011 10:51:49 AM +0200
Subject: [Cachewolf-svn] r3055 - trunk/src/CacheWolf
Message-ID: <20110821085149.A5E2E4815BB@sheep.berlios.de>

Author: engywuck
Date: 2011-08-21 10:51:49 +0200 (Sun, 21 Aug 2011)
New Revision: 3055

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
Correction: If a single cache is checked, then all its addi wpts are checked, wether they are visible or not.

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-08-20 13:29:06 UTC (rev 3054)
+++ trunk/src/CacheWolf/myTableModel.java	2011-08-21 08:51:49 UTC (rev 3055)
@@ -588,7 +588,10 @@
 					// it is outside the selected range and not visible
 					// - otherwise it will be touched by this 
 					// algorithm
-					if (! addiWpt.isVisible() && (addiIdx > to || addiIdx < from)){
+					// Exception: If just one cache is clicked, then check all
+					// addi wpts it has, regardless of their position.
+					if ((! addiWpt.isVisible() && (addiIdx > to || addiIdx < from))
+							|| singleRow){
 						addiWpt.is_Checked = ch.is_Checked;
 						if (addiWpt.isVisible()) {
 							tcControl.repaintCell(cacheDB.getIndex(addiWpt), x);



From engywuck at mail.berlios.de  Sun Aug 21 10:53:36 2011
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sun, 21 Aug 2011 10:53:36 AM +0200
Subject: [Cachewolf-svn] r3056 - trunk/src/CacheWolf
Message-ID: <20110821085336.A75574815BB@sheep.berlios.de>

Author: engywuck
Date: 2011-08-21 10:53:36 +0200 (Sun, 21 Aug 2011)
New Revision: 3056

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
When "check all caches" is used, then the addi wpts of visible caches are also checked, even if they are not visible.
When "uncheck all caches" is used, then all caches are unchecked, if they are visible or not.

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2011-08-21 08:51:49 UTC (rev 3055)
+++ trunk/src/CacheWolf/Profile.java	2011-08-21 08:53:36 UTC (rev 3056)
@@ -574,13 +574,36 @@
 		return "Profile: Name=" + name + "\nCentre=" + centre.toString() + "\ndataDir=" + dataDir + "\nlastSyncOC=" + getLast_sync_opencaching() + "\ndistOC=" + getDistOC() + "\ndistGC=" + getDistGC();
 	}
 
+	/**
+	 * Sets the selection state for all caches to the given state <code>selectStatus</code>.
+	 * There is a little distinction for the <code>true</code> and <code>false</code> case:<br>
+	 * selectStatus <code>true</code>: All <i>visible</i> caches are checked, and their addi
+	 * wpts, regardless if they are visible or not.<br>
+	 * selectStatus <code>false</code>: All caches are unchecked, regardless if they are visible 
+	 * or not. 
+	 * @param selectStatus If <code>true</code> all caches are checked, if <code>false</code>
+	 * all caches are unchecked.
+	 */
 	public void setSelectForAll(boolean selectStatus) {
+		CacheHolder ch;
 		selectionChanged = true;
-		CacheHolder ch;
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
-			if (ch.isVisible())
+			if (selectStatus) {
+				if (ch.isVisible()) {
+					ch.is_Checked = selectStatus; // set the ceckbox also for addi wpts
+					if (ch.hasAddiWpt()) {
+						CacheHolder addiWpt;
+						int addiCount = ch.addiWpts.getCount();
+						for (int j = 0; j < addiCount; j++) {
+							addiWpt = (CacheHolder) ch.addiWpts.get(j);
+							addiWpt.is_Checked = selectStatus;
+						}
+					}					
+				}
+			} else /* selectStatus==false */ {
 				ch.is_Checked = selectStatus;
+			}
 		}
 	}
 



From araber95 at mail.berlios.de  Mon Aug 22 05:52:14 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Mon, 22 Aug 2011 05:52:14 PM +0200
Subject: [Cachewolf-svn] r3057 - trunk/res_noewe
Message-ID: <20110822155215.3A74C481280@sheep.berlios.de>

Author: araber95
Date: 2011-08-22 17:52:14 +0200 (Mon, 22 Aug 2011)
New Revision: 3057

Modified:
   trunk/res_noewe/spider.def
Log:
(own) logid should be correct again

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-08-21 08:53:36 UTC (rev 3056)
+++ trunk/res_noewe/spider.def	2011-08-22 15:52:14 UTC (rev 3057)
@@ -142,8 +142,8 @@
 dateExEnd          = </span>
 logExStart         = class="LogText">
 logExEnd           = </p>
-logIdExStart       = '\ id='
-logIdExEnd         = '>
+logIdExStart       = "\ id="
+logIdExEnd         = ">
 # Die Icons, die einen erfolgreichen Fund signalisieren
 icon_smile         = icon_smile.gif
 icon_camera        = icon_camera.gif



From pfeffer at mail.berlios.de  Thu Aug 25 02:55:34 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Aug 2011 02:55:34 AM +0200
Subject: [Cachewolf-svn] r3058 - in trunk/src: . org org/bouncycastle
	org/bouncycastle/asn1 org/bouncycastle/asn1/nist
	org/bouncycastle/asn1/oiw org/bouncycastle/asn1/pkcs
	org/bouncycastle/asn1/sec org/bouncycastle/asn1/teletrust
	org/bouncycastle/asn1/x500 org/bouncycastle/asn1/x500/style
	org/bouncycastle/asn1/x509 org/bouncycastle/asn1/x9
	org/bouncycastle/crypto org/bouncycastle/crypto/agreement
	org/bouncycastle/crypto/digests org/bouncycastle/crypto/encodings
	org/bouncycastle/crypto/engines
	org/bouncycastle/crypto/generators org/bouncycastle/crypto/io
	org/bouncycastle/crypto/macs org/bouncycastle/crypto/modes
	org/bouncycastle/crypto/params org/bouncycastle/crypto/prng
	org/bouncycastle/crypto/signers org/bouncycastle/crypto/tls
	org/bouncycastle/crypto/util org/bouncycastle/math
	org/bouncycastle/math/ec org/bouncycastle/util
	org/bouncycastle/util/encoders org/bouncycastle/util/io
Message-ID: <20110825005535.DB195481462@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-25 02:55:34 +0200 (Thu, 25 Aug 2011)
New Revision: 3058

Added:
   trunk/src/org/
   trunk/src/org/bouncycastle/
   trunk/src/org/bouncycastle/asn1/
   trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
   trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java
   trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
   trunk/src/org/bouncycastle/asn1/ASN1Boolean.java
   trunk/src/org/bouncycastle/asn1/ASN1Choice.class
   trunk/src/org/bouncycastle/asn1/ASN1Choice.java
   trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
   trunk/src/org/bouncycastle/asn1/ASN1Encodable.java
   trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
   trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java
   trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
   trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java
   trunk/src/org/bouncycastle/asn1/ASN1Exception.class
   trunk/src/org/bouncycastle/asn1/ASN1Exception.java
   trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
   trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java
   trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
   trunk/src/org/bouncycastle/asn1/ASN1InputStream.java
   trunk/src/org/bouncycastle/asn1/ASN1Integer.class
   trunk/src/org/bouncycastle/asn1/ASN1Integer.java
   trunk/src/org/bouncycastle/asn1/ASN1Null.class
   trunk/src/org/bouncycastle/asn1/ASN1Null.java
   trunk/src/org/bouncycastle/asn1/ASN1Object.class
   trunk/src/org/bouncycastle/asn1/ASN1Object.java
   trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
   trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java
   trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
   trunk/src/org/bouncycastle/asn1/ASN1OctetString.java
   trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
   trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java
   trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
   trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java
   trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
   trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java
   trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
   trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
   trunk/src/org/bouncycastle/asn1/ASN1Sequence.java
   trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
   trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java
   trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
   trunk/src/org/bouncycastle/asn1/ASN1Set.class
   trunk/src/org/bouncycastle/asn1/ASN1Set.java
   trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
   trunk/src/org/bouncycastle/asn1/ASN1SetParser.java
   trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
   trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java
   trunk/src/org/bouncycastle/asn1/ASN1String.class
   trunk/src/org/bouncycastle/asn1/ASN1String.java
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java
   trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
   trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java
   trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
   trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java
   trunk/src/org/bouncycastle/asn1/BERFactory.class
   trunk/src/org/bouncycastle/asn1/BERFactory.java
   trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
   trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java
   trunk/src/org/bouncycastle/asn1/BEROutputStream.class
   trunk/src/org/bouncycastle/asn1/BEROutputStream.java
   trunk/src/org/bouncycastle/asn1/BERSequence.class
   trunk/src/org/bouncycastle/asn1/BERSequence.java
   trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
   trunk/src/org/bouncycastle/asn1/BERSequenceParser.java
   trunk/src/org/bouncycastle/asn1/BERSet.class
   trunk/src/org/bouncycastle/asn1/BERSet.java
   trunk/src/org/bouncycastle/asn1/BERSetParser.class
   trunk/src/org/bouncycastle/asn1/BERSetParser.java
   trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
   trunk/src/org/bouncycastle/asn1/BERTaggedObject.java
   trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
   trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java
   trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
   trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java
   trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
   trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java
   trunk/src/org/bouncycastle/asn1/DERBMPString.class
   trunk/src/org/bouncycastle/asn1/DERBMPString.java
   trunk/src/org/bouncycastle/asn1/DERBitString.class
   trunk/src/org/bouncycastle/asn1/DERBitString.java
   trunk/src/org/bouncycastle/asn1/DERBoolean.class
   trunk/src/org/bouncycastle/asn1/DERBoolean.java
   trunk/src/org/bouncycastle/asn1/DEREncodable.class
   trunk/src/org/bouncycastle/asn1/DEREncodable.java
   trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
   trunk/src/org/bouncycastle/asn1/DEREncodableVector.java
   trunk/src/org/bouncycastle/asn1/DEREnumerated.class
   trunk/src/org/bouncycastle/asn1/DEREnumerated.java
   trunk/src/org/bouncycastle/asn1/DERExternal.class
   trunk/src/org/bouncycastle/asn1/DERExternal.java
   trunk/src/org/bouncycastle/asn1/DERExternalParser.class
   trunk/src/org/bouncycastle/asn1/DERExternalParser.java
   trunk/src/org/bouncycastle/asn1/DERFactory.class
   trunk/src/org/bouncycastle/asn1/DERFactory.java
   trunk/src/org/bouncycastle/asn1/DERGeneralString.class
   trunk/src/org/bouncycastle/asn1/DERGeneralString.java
   trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
   trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java
   trunk/src/org/bouncycastle/asn1/DERIA5String.class
   trunk/src/org/bouncycastle/asn1/DERIA5String.java
   trunk/src/org/bouncycastle/asn1/DERInteger.class
   trunk/src/org/bouncycastle/asn1/DERInteger.java
   trunk/src/org/bouncycastle/asn1/DERNull.class
   trunk/src/org/bouncycastle/asn1/DERNull.java
   trunk/src/org/bouncycastle/asn1/DERNumericString.class
   trunk/src/org/bouncycastle/asn1/DERNumericString.java
   trunk/src/org/bouncycastle/asn1/DERObject.class
   trunk/src/org/bouncycastle/asn1/DERObject.java
   trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
   trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java
   trunk/src/org/bouncycastle/asn1/DEROctetString.class
   trunk/src/org/bouncycastle/asn1/DEROctetString.java
   trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
   trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java
   trunk/src/org/bouncycastle/asn1/DEROutputStream.class
   trunk/src/org/bouncycastle/asn1/DEROutputStream.java
   trunk/src/org/bouncycastle/asn1/DERPrintableString.class
   trunk/src/org/bouncycastle/asn1/DERPrintableString.java
   trunk/src/org/bouncycastle/asn1/DERSequence.class
   trunk/src/org/bouncycastle/asn1/DERSequence.java
   trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
   trunk/src/org/bouncycastle/asn1/DERSequenceParser.java
   trunk/src/org/bouncycastle/asn1/DERSet.class
   trunk/src/org/bouncycastle/asn1/DERSet.java
   trunk/src/org/bouncycastle/asn1/DERSetParser.class
   trunk/src/org/bouncycastle/asn1/DERSetParser.java
   trunk/src/org/bouncycastle/asn1/DERString.class
   trunk/src/org/bouncycastle/asn1/DERString.java
   trunk/src/org/bouncycastle/asn1/DERT61String.class
   trunk/src/org/bouncycastle/asn1/DERT61String.java
   trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
   trunk/src/org/bouncycastle/asn1/DERTaggedObject.java
   trunk/src/org/bouncycastle/asn1/DERTags.class
   trunk/src/org/bouncycastle/asn1/DERTags.java
   trunk/src/org/bouncycastle/asn1/DERUTCTime.class
   trunk/src/org/bouncycastle/asn1/DERUTCTime.java
   trunk/src/org/bouncycastle/asn1/DERUTF8String.class
   trunk/src/org/bouncycastle/asn1/DERUTF8String.java
   trunk/src/org/bouncycastle/asn1/DERUniversalString.class
   trunk/src/org/bouncycastle/asn1/DERUniversalString.java
   trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
   trunk/src/org/bouncycastle/asn1/DERUnknownTag.java
   trunk/src/org/bouncycastle/asn1/DERVisibleString.class
   trunk/src/org/bouncycastle/asn1/DERVisibleString.java
   trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
   trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java
   trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
   trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java
   trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
   trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java
   trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
   trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java
   trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
   trunk/src/org/bouncycastle/asn1/LazyDERSequence.java
   trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
   trunk/src/org/bouncycastle/asn1/LimitedInputStream.java
   trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
   trunk/src/org/bouncycastle/asn1/OIDTokenizer.java
   trunk/src/org/bouncycastle/asn1/nist/
   trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
   trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java
   trunk/src/org/bouncycastle/asn1/nist/package.html
   trunk/src/org/bouncycastle/asn1/oiw/
   trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
   trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java
   trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/oiw/package.html
   trunk/src/org/bouncycastle/asn1/pkcs/
   trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
   trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java
   trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/pkcs/package.html
   trunk/src/org/bouncycastle/asn1/sec/
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java
   trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/sec/package.html
   trunk/src/org/bouncycastle/asn1/teletrust/
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/teletrust/package.html
   trunk/src/org/bouncycastle/asn1/x500/
   trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
   trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java
   trunk/src/org/bouncycastle/asn1/x500/RDN.class
   trunk/src/org/bouncycastle/asn1/x500/RDN.java
   trunk/src/org/bouncycastle/asn1/x500/X500Name.class
   trunk/src/org/bouncycastle/asn1/x500/X500Name.java
   trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
   trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java
   trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
   trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java
   trunk/src/org/bouncycastle/asn1/x500/style/
   trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
   trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java
   trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
   trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java
   trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
   trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java
   trunk/src/org/bouncycastle/asn1/x509/
   trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
   trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java
   trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
   trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java
   trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
   trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java
   trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
   trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java
   trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
   trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java
   trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
   trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java
   trunk/src/org/bouncycastle/asn1/x509/Time.class
   trunk/src/org/bouncycastle/asn1/x509/Time.java
   trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
   trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java
   trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
   trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java
   trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
   trunk/src/org/bouncycastle/asn1/x509/X509Extension.java
   trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
   trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java
   trunk/src/org/bouncycastle/asn1/x509/X509Name.class
   trunk/src/org/bouncycastle/asn1/x509/X509Name.java
   trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
   trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java
   trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
   trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java
   trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/x509/package.html
   trunk/src/org/bouncycastle/asn1/x9/
   trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
   trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java
   trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
   trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java
   trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
   trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java
   trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
   trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java
   trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
   trunk/src/org/bouncycastle/asn1/x9/X9Curve.java
   trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java
   trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java
   trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java
   trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
   trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java
   trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
   trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java
   trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
   trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java
   trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/x9/package.html
   trunk/src/org/bouncycastle/crypto/
   trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
   trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java
   trunk/src/org/bouncycastle/crypto/BasicAgreement.class
   trunk/src/org/bouncycastle/crypto/BasicAgreement.java
   trunk/src/org/bouncycastle/crypto/BlockCipher.class
   trunk/src/org/bouncycastle/crypto/BlockCipher.java
   trunk/src/org/bouncycastle/crypto/CipherParameters.class
   trunk/src/org/bouncycastle/crypto/CipherParameters.java
   trunk/src/org/bouncycastle/crypto/CryptoException.class
   trunk/src/org/bouncycastle/crypto/CryptoException.java
   trunk/src/org/bouncycastle/crypto/DSA.class
   trunk/src/org/bouncycastle/crypto/DSA.java
   trunk/src/org/bouncycastle/crypto/DataLengthException.class
   trunk/src/org/bouncycastle/crypto/DataLengthException.java
   trunk/src/org/bouncycastle/crypto/Digest.class
   trunk/src/org/bouncycastle/crypto/Digest.java
   trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
   trunk/src/org/bouncycastle/crypto/ExtendedDigest.java
   trunk/src/org/bouncycastle/crypto/ExtensionType.class
   trunk/src/org/bouncycastle/crypto/ExtensionType.java
   trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
   trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java
   trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java
   trunk/src/org/bouncycastle/crypto/Mac.class
   trunk/src/org/bouncycastle/crypto/Mac.java
   trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
   trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java
   trunk/src/org/bouncycastle/crypto/Signer.class
   trunk/src/org/bouncycastle/crypto/Signer.java
   trunk/src/org/bouncycastle/crypto/agreement/
   trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
   trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java
   trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
   trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java
   trunk/src/org/bouncycastle/crypto/agreement/package.html
   trunk/src/org/bouncycastle/crypto/digests/
   trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
   trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java
   trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
   trunk/src/org/bouncycastle/crypto/digests/LongDigest.java
   trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
   trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java
   trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
   trunk/src/org/bouncycastle/crypto/digests/NullDigest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java
   trunk/src/org/bouncycastle/crypto/digests/package.html
   trunk/src/org/bouncycastle/crypto/encodings/
   trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
   trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java
   trunk/src/org/bouncycastle/crypto/encodings/package.html
   trunk/src/org/bouncycastle/crypto/engines/
   trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
   trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java
   trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
   trunk/src/org/bouncycastle/crypto/engines/DESEngine.java
   trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
   trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java
   trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
   trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java
   trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
   trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java
   trunk/src/org/bouncycastle/crypto/engines/package.html
   trunk/src/org/bouncycastle/crypto/generators/
   trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java
   trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
   trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java
   trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java
   trunk/src/org/bouncycastle/crypto/generators/package.html
   trunk/src/org/bouncycastle/crypto/io/
   trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
   trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java
   trunk/src/org/bouncycastle/crypto/io/package.html
   trunk/src/org/bouncycastle/crypto/macs/
   trunk/src/org/bouncycastle/crypto/macs/HMac.class
   trunk/src/org/bouncycastle/crypto/macs/HMac.java
   trunk/src/org/bouncycastle/crypto/macs/package.html
   trunk/src/org/bouncycastle/crypto/modes/
   trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
   trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java
   trunk/src/org/bouncycastle/crypto/modes/package.html
   trunk/src/org/bouncycastle/crypto/package.html
   trunk/src/org/bouncycastle/crypto/params/
   trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
   trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java
   trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java
   trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
   trunk/src/org/bouncycastle/crypto/params/KeyParameter.java
   trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
   trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java
   trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
   trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java
   trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/package.html
   trunk/src/org/bouncycastle/crypto/prng/
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java
   trunk/src/org/bouncycastle/crypto/prng/package.html
   trunk/src/org/bouncycastle/crypto/signers/
   trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
   trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java
   trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
   trunk/src/org/bouncycastle/crypto/signers/DSASigner.java
   trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
   trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java
   trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
   trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java
   trunk/src/org/bouncycastle/crypto/signers/package.html
   trunk/src/org/bouncycastle/crypto/tls/
   trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
   trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java
   trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
   trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java
   trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
   trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java
   trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
   trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java
   trunk/src/org/bouncycastle/crypto/tls/Certificate.class
   trunk/src/org/bouncycastle/crypto/tls/Certificate.java
   trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
   trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java
   trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
   trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java
   trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
   trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java
   trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
   trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java
   trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
   trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java
   trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
   trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java
   trunk/src/org/bouncycastle/crypto/tls/ContentType.class
   trunk/src/org/bouncycastle/crypto/tls/ContentType.java
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java
   trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java
   trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
   trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java
   trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java
   trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
   trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java
   trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
   trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java
   trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java
   trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
   trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java
   trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
   trunk/src/org/bouncycastle/crypto/tls/RecordStream.java
   trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
   trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java
   trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java
   trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
   trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java
   trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java
   trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClient.java
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
   trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java
   trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
   trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java
   trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
   trunk/src/org/bouncycastle/crypto/tls/TlsMac.java
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java
   trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
   trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java
   trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
   trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java
   trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java
   trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java
   trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java
   trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
   trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java
   trunk/src/org/bouncycastle/crypto/tls/package.html
   trunk/src/org/bouncycastle/crypto/util/
   trunk/src/org/bouncycastle/crypto/util/Pack.class
   trunk/src/org/bouncycastle/crypto/util/Pack.java
   trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
   trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java
   trunk/src/org/bouncycastle/crypto/util/package.html
   trunk/src/org/bouncycastle/math/
   trunk/src/org/bouncycastle/math/ec/
   trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
   trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java
   trunk/src/org/bouncycastle/math/ec/ECConstants.class
   trunk/src/org/bouncycastle/math/ec/ECConstants.java
   trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECCurve.class
   trunk/src/org/bouncycastle/math/ec/ECCurve.java
   trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement.java
   trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
   trunk/src/org/bouncycastle/math/ec/ECMultiplier.java
   trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECPoint.class
   trunk/src/org/bouncycastle/math/ec/ECPoint.java
   trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java
   trunk/src/org/bouncycastle/math/ec/IntArray.class
   trunk/src/org/bouncycastle/math/ec/IntArray.java
   trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/PreCompInfo.java
   trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
   trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java
   trunk/src/org/bouncycastle/math/ec/Tnaf.class
   trunk/src/org/bouncycastle/math/ec/Tnaf.java
   trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java
   trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java
   trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java
   trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java
   trunk/src/org/bouncycastle/math/ec/ZTauElement.class
   trunk/src/org/bouncycastle/math/ec/ZTauElement.java
   trunk/src/org/bouncycastle/math/ec/package.html
   trunk/src/org/bouncycastle/util/
   trunk/src/org/bouncycastle/util/Arrays.class
   trunk/src/org/bouncycastle/util/Arrays.java
   trunk/src/org/bouncycastle/util/BigIntegers.class
   trunk/src/org/bouncycastle/util/BigIntegers.java
   trunk/src/org/bouncycastle/util/Strings.class
   trunk/src/org/bouncycastle/util/Strings.java
   trunk/src/org/bouncycastle/util/encoders/
   trunk/src/org/bouncycastle/util/encoders/Encoder.class
   trunk/src/org/bouncycastle/util/encoders/Encoder.java
   trunk/src/org/bouncycastle/util/encoders/Hex.class
   trunk/src/org/bouncycastle/util/encoders/Hex.java
   trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
   trunk/src/org/bouncycastle/util/encoders/HexEncoder.java
   trunk/src/org/bouncycastle/util/encoders/package.html
   trunk/src/org/bouncycastle/util/io/
   trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
   trunk/src/org/bouncycastle/util/io/StreamOverflowException.java
   trunk/src/org/bouncycastle/util/io/Streams.class
   trunk/src/org/bouncycastle/util/io/Streams.java
Log:
the tls/ssl library

Added: trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1ApplicationSpecificParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    DEREncodable readObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Boolean.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Boolean.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Boolean.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,15 @@
+package org.bouncycastle.asn1;
+
+public class ASN1Boolean
+    extends DERBoolean
+{
+    public ASN1Boolean(boolean value)
+    {
+        super(value);
+    }
+
+    ASN1Boolean(byte[] value)
+    {
+        super(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Choice.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Choice.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Choice.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Choice.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Choice.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,14 @@
+package org.bouncycastle.asn1;
+
+/**
+ * Marker interface for CHOICE objects - if you implement this in a role your
+ * own object any attempt to tag the object implicitly will convert the tag to
+ * an explicit one as the encoding rules require.
+ * <p>
+ * If you use this interface your class should also implement the getInstance
+ * pattern which takes a tag object and the tagging mode used. 
+ */
+public interface ASN1Choice
+{
+    // marker interface
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Encodable.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Encodable.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Encodable.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,102 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+/**
+ * Base class for objects which can be written directly to ASN.1 output streams.
+ */
+public abstract class ASN1Encodable
+    implements DEREncodable
+{
+    public static final String DER = "DER";
+    public static final String BER = "BER";
+
+    /**
+     * Return the default BER or DER encoding for this object.
+     *
+     * @return BER/DER byte encoded object.
+     * @throws IOException on encoding error.
+     */
+    public byte[] getEncoded()
+        throws IOException
+    {
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        ASN1OutputStream        aOut = new ASN1OutputStream(bOut);
+
+        aOut.writeObject(this);
+
+        return bOut.toByteArray();
+    }
+
+    /**
+     * Return either the default for "BER" or a DER encoding if "DER" is specified.
+     *
+     * @param encoding name of encoding to use.
+     * @return byte encoded object.
+     * @throws IOException on encoding error.
+     */
+    public byte[] getEncoded(
+        String encoding)
+        throws IOException
+    {
+        if (encoding.equals(DER))
+        {
+            ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+            DEROutputStream         dOut = new DEROutputStream(bOut);
+
+            dOut.writeObject(this);
+
+            return bOut.toByteArray();
+        }
+
+        return this.getEncoded();
+    }
+
+    /**
+     * Return the DER encoding of the object, null if the DER encoding can not be made.
+     *
+     * @return a DER byte array, null otherwise.
+     */
+    public byte[] getDEREncoded()
+    {
+        try
+        {
+            return this.getEncoded(DER);
+        }
+        catch (IOException e)
+        {
+            return null;
+        }
+    }
+
+    public int hashCode()
+    {
+        return this.toASN1Object().hashCode();
+    }
+
+    public boolean equals(
+        Object  o)
+    {
+        if (this == o)
+        {
+            return true;
+        }
+
+        if (!(o instanceof DEREncodable))
+        {
+            return false;
+        }
+
+        DEREncodable other = (DEREncodable)o;
+
+        return this.toASN1Object().equals(other.getDERObject());
+    }
+
+    public DERObject getDERObject()
+    {
+        return this.toASN1Object();
+    }
+
+    public abstract DERObject toASN1Object();
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,32 @@
+package org.bouncycastle.asn1;
+
+import ewe.util.Vector;
+
+/**
+ * the parent class for this will eventually disappear. Use this one!
+ */
+public class ASN1EncodableVector
+    extends DEREncodableVector
+{
+    Vector v = new Vector();
+
+    public ASN1EncodableVector()
+    {
+
+    }
+
+    public void add(DEREncodable obj)
+    {
+        v.addElement(obj);
+    }
+
+    public DEREncodable get(int i)
+    {
+        return (DEREncodable)v.elementAt(i);
+    }
+
+    public int size()
+    {
+        return v.size();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+import ewe.math.BigInteger;
+
+public class ASN1Enumerated
+    extends DEREnumerated
+{
+    ASN1Enumerated(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+    public ASN1Enumerated(BigInteger value)
+    {
+        super(value);
+    }
+
+    public ASN1Enumerated(int value)
+    {
+        super(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Exception.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Exception.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Exception.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Exception.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Exception.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class ASN1Exception
+    extends IOException
+{
+    private Throwable cause;
+
+    ASN1Exception(String message)
+    {
+        super(message);
+    }
+
+    ASN1Exception(String message, Throwable cause)
+    {
+        super(message);
+        this.cause = cause;
+    }
+
+    public Throwable getCause()
+    {
+        return cause;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+import ewe.sys.Date;
+
+public class ASN1GeneralizedTime
+    extends DERGeneralizedTime
+{
+    ASN1GeneralizedTime(byte[] bytes)
+    {
+        super(bytes);
+    }
+/*
+    public ASN1GeneralizedTime(Date time)
+    {
+        super(time);
+    }
+*/
+    public ASN1GeneralizedTime(String time)
+    {
+        super(time);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1InputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1InputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1InputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,401 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.EOFException;
+import ewe.io.FilterInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.io.Streams;
+
+/**
+ * a general purpose ASN.1 decoder - note: this class differs from the
+ * others in that it returns null after it has read the last object in
+ * the stream. If an ASN.1 NULL is encountered a DER/BER Null object is
+ * returned.
+ */
+public class ASN1InputStream
+    extends FilterInputStream
+    implements DERTags
+{
+    private final int limit;
+    private final boolean lazyEvaluate;
+
+    static int findLimit(InputStream in)
+    {
+        if (in instanceof LimitedInputStream)
+        {
+            return ((LimitedInputStream)in).getRemaining();
+        }
+        else if (in instanceof ByteArrayInputStream)
+        {
+            return ((ByteArrayInputStream)in).available();
+        }
+
+        return Integer.MAX_VALUE;
+    }
+
+    public ASN1InputStream(
+        InputStream is)
+    {
+        this(is, findLimit(is));
+    }
+
+    /**
+     * Create an ASN1InputStream based on the input byte array. The length of DER objects in
+     * the stream is automatically limited to the length of the input array.
+     *
+     * @param input array containing ASN.1 encoded data.
+     */
+    public ASN1InputStream(
+        byte[] input)
+    {
+        this(new ByteArrayInputStream(input), input.length);
+    }
+
+    /**
+     * Create an ASN1InputStream based on the input byte array. The length of DER objects in
+     * the stream is automatically limited to the length of the input array.
+     *
+     * @param input array containing ASN.1 encoded data.
+     * @param lazyEvaluate true if parsing inside constructed objects can be delayed.
+     */
+    public ASN1InputStream(
+        byte[] input,
+        boolean lazyEvaluate)
+    {
+        this(new ByteArrayInputStream(input), input.length, lazyEvaluate);
+    }
+
+    /**
+     * Create an ASN1InputStream where no DER object will be longer than limit.
+     *
+     * @param input stream containing ASN.1 encoded data.
+     * @param limit maximum size of a DER encoded object.
+     */
+    public ASN1InputStream(
+        InputStream input,
+        int         limit)
+    {
+        this(input, limit, false);
+    }
+
+    /**
+     * Create an ASN1InputStream where no DER object will be longer than limit, and constructed
+     * objects such as sequences will be parsed lazily.
+     *
+     * @param input stream containing ASN.1 encoded data.
+     * @param limit maximum size of a DER encoded object.
+     * @param lazyEvaluate true if parsing inside constructed objects can be delayed.
+     */
+    public ASN1InputStream(
+        InputStream input,
+        int         limit,
+        boolean     lazyEvaluate)
+    {
+        super(input);
+        this.limit = limit;
+        this.lazyEvaluate = lazyEvaluate;
+    }
+
+    protected int readLength()
+        throws IOException
+    {
+        return readLength(this, limit);
+    }
+
+    protected void readFully(
+        byte[]  bytes)
+        throws IOException
+    {
+        if (Streams.readFully(this, bytes) != bytes.length)
+        {
+            throw new EOFException("EOF encountered in middle of object");
+        }
+    }
+
+    /**
+     * build an object given its tag and the number of bytes to construct it from.
+     */
+    protected DERObject buildObject(
+        int       tag,
+        int       tagNo,
+        int       length)
+        throws IOException
+    {
+        boolean isConstructed = (tag & CONSTRUCTED) != 0;
+
+        DefiniteLengthInputStream defIn = new DefiniteLengthInputStream(this, length);
+
+        if ((tag & APPLICATION) != 0)
+        {
+            return new DERApplicationSpecific(isConstructed, tagNo, defIn.toByteArray());
+        }
+
+        if ((tag & TAGGED) != 0)
+        {
+            return new ASN1StreamParser(defIn).readTaggedObject(isConstructed, tagNo);
+        }
+
+        if (isConstructed)
+        {
+            // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+            switch (tagNo)
+            {
+                case OCTET_STRING:
+                    //
+                    // yes, people actually do this...
+                    //
+                    return new BERConstructedOctetString(buildDEREncodableVector(defIn).v);
+                case SEQUENCE:
+                    if (lazyEvaluate)
+                    {
+                        return new LazyDERSequence(defIn.toByteArray());
+                    }
+                    else
+                    {
+                        return DERFactory.createSequence(buildDEREncodableVector(defIn));
+                    }
+                case SET:
+                    return DERFactory.createSet(buildDEREncodableVector(defIn), false);
+                case EXTERNAL:
+                    return new DERExternal(buildDEREncodableVector(defIn));
+                default:
+                    return new DERUnknownTag(true, tagNo, defIn.toByteArray());
+            }
+        }
+
+        return createPrimitiveDERObject(tagNo, defIn.toByteArray());
+    }
+
+    ASN1EncodableVector buildEncodableVector()
+        throws IOException
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        DERObject o;
+
+        while ((o = readObject()) != null)
+        {
+            v.add(o);
+        }
+
+        return v;
+    }
+
+    ASN1EncodableVector buildDEREncodableVector(
+        DefiniteLengthInputStream dIn) throws IOException
+    {
+        return new ASN1InputStream(dIn).buildEncodableVector();
+    }
+
+    public DERObject readObject()
+        throws IOException
+    {
+        int tag = read();
+        if (tag <= 0)
+        {
+            if (tag == 0)
+            {
+                throw new IOException("unexpected end-of-contents marker");
+            }
+
+            return null;
+        }
+
+        //
+        // calculate tag number
+        //
+        int tagNo = readTagNumber(this, tag);
+
+        boolean isConstructed = (tag & CONSTRUCTED) != 0;
+
+        //
+        // calculate length
+        //
+        int length = readLength();
+
+        if (length < 0) // indefinite length method
+        {
+            if (!isConstructed)
+            {
+                throw new IOException("indefinite length primitive encoding encountered");
+            }
+
+            IndefiniteLengthInputStream indIn = new IndefiniteLengthInputStream(this, limit);
+            ASN1StreamParser sp = new ASN1StreamParser(indIn, limit);
+
+            if ((tag & APPLICATION) != 0)
+            {
+                return new BERApplicationSpecificParser(tagNo, sp).getLoadedObject();
+            }
+
+            if ((tag & TAGGED) != 0)
+            {
+                return new BERTaggedObjectParser(true, tagNo, sp).getLoadedObject();
+            }
+
+            // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+            switch (tagNo)
+            {
+                case OCTET_STRING:
+                    return new BEROctetStringParser(sp).getLoadedObject();
+                case SEQUENCE:
+                    return new BERSequenceParser(sp).getLoadedObject();
+                case SET:
+                    return new BERSetParser(sp).getLoadedObject();
+                case EXTERNAL:
+                    return new DERExternalParser(sp).getLoadedObject();
+                default:
+                    throw new IOException("unknown BER object encountered");
+            }
+        }
+        else
+        {
+            try
+            {
+                return buildObject(tag, tagNo, length);
+            }
+            catch (IllegalArgumentException e)
+            {
+                throw new ASN1Exception("corrupted stream detected", e);
+            }
+        }
+    }
+
+    static int readTagNumber(InputStream s, int tag)
+        throws IOException
+    {
+        int tagNo = tag & 0x1f;
+
+        //
+        // with tagged object tag number is bottom 5 bits, or stored at the start of the content
+        //
+        if (tagNo == 0x1f)
+        {
+            tagNo = 0;
+
+            int b = s.read();
+
+            // X.690-0207 8.1.2.4.2
+            // "c) bits 7 to 1 of the first subsequent octet shall not all be zero."
+            if ((b & 0x7f) == 0) // Note: -1 will pass
+            {
+                throw new IOException("corrupted stream - invalid high tag number found");
+            }
+
+            while ((b >= 0) && ((b & 0x80) != 0))
+            {
+                tagNo |= (b & 0x7f);
+                tagNo <<= 7;
+                b = s.read();
+            }
+
+            if (b < 0)
+            {
+                throw new EOFException("EOF found inside tag value.");
+            }
+
+            tagNo |= (b & 0x7f);
+        }
+
+        return tagNo;
+    }
+
+    static int readLength(InputStream s, int limit)
+        throws IOException
+    {
+        int length = s.read();
+        if (length < 0)
+        {
+            throw new EOFException("EOF found when length expected");
+        }
+
+        if (length == 0x80)
+        {
+            return -1;      // indefinite-length encoding
+        }
+
+        if (length > 127)
+        {
+            int size = length & 0x7f;
+
+            // Note: The invalid long form "0xff" (see X.690 8.1.3.5c) will be caught here
+            if (size > 4)
+            {
+                throw new IOException("DER length more than 4 bytes: " + size);
+            }
+
+            length = 0;
+            for (int i = 0; i < size; i++)
+            {
+                int next = s.read();
+
+                if (next < 0)
+                {
+                    throw new EOFException("EOF found reading length");
+                }
+
+                length = (length << 8) + next;
+            }
+
+            if (length < 0)
+            {
+                throw new IOException("corrupted stream - negative length found");
+            }
+
+            if (length >= limit)   // after all we must have read at least 1 byte
+            {
+                throw new IOException("corrupted stream - out of bounds length found");
+            }
+        }
+
+        return length;
+    }
+
+    static DERObject createPrimitiveDERObject(
+        int     tagNo,
+        byte[]  bytes)
+    {
+        switch (tagNo)
+        {
+            case BIT_STRING:
+                return DERBitString.fromOctetString(bytes);
+            case BMP_STRING:
+                return new DERBMPString(bytes);
+            case BOOLEAN:
+                return new ASN1Boolean(bytes);
+            case ENUMERATED:
+                return new ASN1Enumerated(bytes);
+            case GENERALIZED_TIME:
+                return new ASN1GeneralizedTime(bytes);
+            case GENERAL_STRING:
+                return new DERGeneralString(bytes);
+            case IA5_STRING:
+                return new DERIA5String(bytes);
+            case INTEGER:
+                return new ASN1Integer(bytes);
+            case NULL:
+                return DERNull.INSTANCE;   // actual content is ignored (enforce 0 length?)
+            case NUMERIC_STRING:
+                return new DERNumericString(bytes);
+            case OBJECT_IDENTIFIER:
+                return new ASN1ObjectIdentifier(bytes);
+            case OCTET_STRING:
+                return new DEROctetString(bytes);
+            case PRINTABLE_STRING:
+                return new DERPrintableString(bytes);
+            case T61_STRING:
+                return new DERT61String(bytes);
+            case UNIVERSAL_STRING:
+                return new DERUniversalString(bytes);
+            case UTC_TIME:
+                return new ASN1UTCTime(bytes);
+            case UTF8_STRING:
+                return new DERUTF8String(bytes);
+            case VISIBLE_STRING:
+                return new DERVisibleString(bytes);
+            default:
+                return new DERUnknownTag(false, tagNo, bytes);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Integer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Integer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Integer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Integer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Integer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+import ewe.math.BigInteger;
+
+public class ASN1Integer
+    extends DERInteger
+{
+    ASN1Integer(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+    public ASN1Integer(BigInteger value)
+    {
+        super(value);
+    }
+
+    public ASN1Integer(int value)
+    {
+        super(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Null.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Null.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Null.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Null.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Null.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * A NULL object.
+ */
+public abstract class ASN1Null
+    extends ASN1Object
+{
+    public ASN1Null()
+    {
+    }
+
+    public int hashCode()
+    {
+        return -1;
+    }
+
+    boolean asn1Equals(
+        DERObject o)
+    {
+        if (!(o instanceof ASN1Null))
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+
+    public String toString()
+    {
+         return "NULL";
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Object.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Object.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Object.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Object.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Object.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,45 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public abstract  class ASN1Object
+    extends DERObject
+{
+    /**
+     * Create a base ASN.1 object from a byte stream.
+     *
+     * @param data the byte stream to parse.
+     * @return the base ASN.1 object represented by the byte stream.
+     * @exception IOException if there is a problem parsing the data.
+     */
+    public static ASN1Object fromByteArray(byte[] data)
+        throws IOException
+    {
+        ASN1InputStream aIn = new ASN1InputStream(data);
+
+        try
+        {
+            return (ASN1Object)aIn.readObject();
+        }
+        catch (ClassCastException e)
+        {
+            throw new IOException("cannot recognise object in stream");
+        }
+    }
+
+    public final boolean equals(Object o)
+    {
+        if (this == o)
+        {
+            return true;
+        }
+
+        return (o instanceof DEREncodable) && asn1Equals(((DEREncodable)o).getDERObject());
+    }
+
+    public abstract int hashCode();
+
+    abstract void encode(DEROutputStream out) throws IOException;
+
+    abstract boolean asn1Equals(DERObject o);
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,26 @@
+package org.bouncycastle.asn1;
+
+public class ASN1ObjectIdentifier
+    extends DERObjectIdentifier
+{
+    public ASN1ObjectIdentifier(String identifier)
+    {
+        super(identifier);
+    }
+
+    ASN1ObjectIdentifier(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+    /**
+     * Return an OID that creates a branch under the current one.
+     *
+     * @param branchID node numbers for the new branch.
+     * @return
+     */
+    public ASN1ObjectIdentifier branch(String branchID)
+    {
+        return new ASN1ObjectIdentifier(getId() + "." + branchID);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1OctetString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1OctetString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,135 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.Arrays;
+import org.bouncycastle.util.encoders.Hex;
+
+public abstract class ASN1OctetString
+    extends ASN1Object
+    implements ASN1OctetStringParser
+{
+    byte[]  string;
+
+    /**
+     * return an Octet String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want.
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *              be converted.
+     */
+    public static ASN1OctetString getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof ASN1OctetString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return BERConstructedOctetString.fromSequence(ASN1Sequence.getInstance(o));
+        }
+    }
+
+    /**
+     * return an Octet String from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static ASN1OctetString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof ASN1OctetString)
+        {
+            return (ASN1OctetString)obj;
+        }
+
+        // TODO: this needs to be deleted in V2
+        if (obj instanceof ASN1TaggedObject)
+        {
+            return getInstance(((ASN1TaggedObject)obj).getObject());
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * @param string the octets making up the octet string.
+     */
+    public ASN1OctetString(
+        byte[]  string)
+    {
+        if (string == null)
+        {
+            throw new NullPointerException("string cannot be null");
+        }
+        this.string = string;
+    }
+
+    public ASN1OctetString(
+        DEREncodable obj)
+    {
+        try
+        {
+            this.string = obj.getDERObject().getEncoded(ASN1Encodable.DER);
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException("Error processing object : " + e.toString());
+        }
+    }
+
+    public InputStream getOctetStream()
+    {
+        return new ByteArrayInputStream(string);
+    }
+
+    public ASN1OctetStringParser parser()
+    {
+        return this;
+    }
+
+    public byte[] getOctets()
+    {
+        return string;
+    }
+
+    public int hashCode()
+    {
+        return Arrays.hashCode(this.getOctets());
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof ASN1OctetString))
+        {
+            return false;
+        }
+
+        ASN1OctetString  other = (ASN1OctetString)o;
+
+        return Arrays.areEqual(string, other.string);
+    }
+
+    public DERObject getLoadedObject()
+    {
+        return this.getDERObject();
+    }
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+
+    public String toString()
+    {
+      return "#"+new String(Hex.encode(string));
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,9 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.InputStream;
+
+public interface ASN1OctetStringParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    public InputStream getOctetStream();
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class ASN1OutputStream
+    extends DEROutputStream
+{
+    public ASN1OutputStream(
+        OutputStream    os)
+    {
+        super(os);
+    }
+
+    public void writeObject(
+        Object    obj)
+        throws IOException
+    {
+        if (obj == null)
+        {
+            writeNull();
+        }
+        else if (obj instanceof DERObject)
+        {
+            ((DERObject)obj).encode(this);
+        }
+        else if (obj instanceof DEREncodable)
+        {
+            ((DEREncodable)obj).getDERObject().encode(this);
+        }
+        else
+        {
+            throw new IOException("object not ASN1Encodable");
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.asn1;
+
+public class ASN1ParsingException
+    extends IllegalStateException
+{
+    private Throwable cause;
+
+    ASN1ParsingException(String message)
+    {
+        super(message);
+    }
+
+    ASN1ParsingException(String message, Throwable cause)
+    {
+        super(message);
+        this.cause = cause;
+    }
+
+    public Throwable getCause()
+    {
+        return cause;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Sequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Sequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Sequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,247 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Vector;
+
+public abstract class ASN1Sequence
+    extends ASN1Object
+{
+    private Vector seq = new Vector();
+
+    /**
+     * return an ASN1Sequence from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static ASN1Sequence getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof ASN1Sequence)
+        {
+            return (ASN1Sequence)obj;
+        }
+        else if (obj instanceof byte[])
+        {
+            try
+            {
+                return ASN1Sequence.getInstance(ASN1Object.fromByteArray((byte[])obj));
+            }
+            catch (IOException e)
+            {
+                throw new IllegalArgumentException("failed to construct sequence from byte[]: " + e.getMessage());
+            }
+        }
+
+        throw new IllegalArgumentException("unknown object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * Return an ASN1 sequence from a tagged object. There is a special
+     * case here, if an object appears to have been explicitly tagged on
+     * reading but we were expecting it to be implicitly tagged in the
+     * normal course of events it indicates that we lost the surrounding
+     * sequence - so we need to add it back (this will happen if the tagged
+     * object is a sequence that contains other sequences). If you are
+     * dealing with implicitly tagged sequences you really <b>should</b>
+     * be using this method.
+     *
+     * @param obj the tagged object.
+     * @param explicit true if the object is meant to be explicitly tagged,
+     *          false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *          be converted.
+     */
+    public static ASN1Sequence getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        if (explicit)
+        {
+            if (!obj.isExplicit())
+            {
+                throw new IllegalArgumentException("object implicit - explicit expected.");
+            }
+
+            return (ASN1Sequence)obj.getObject();
+        }
+        else
+        {
+            //
+            // constructed object which appears to be explicitly tagged
+            // when it should be implicit means we have to add the
+            // surrounding sequence.
+            //
+            if (obj.isExplicit())
+            {
+                if (obj instanceof BERTaggedObject)
+                {
+                    return new BERSequence(obj.getObject());
+                }
+                else
+                {
+                    return new DERSequence(obj.getObject());
+                }
+            }
+            else
+            {
+                if (obj.getObject() instanceof ASN1Sequence)
+                {
+                    return (ASN1Sequence)obj.getObject();
+                }
+            }
+        }
+
+        throw new IllegalArgumentException("unknown object in getInstance: " + obj.getClass().getName());
+    }
+
+    public Enumeration getObjects()
+    {
+        return seq.elements();
+    }
+
+    public ASN1SequenceParser parser()
+    {
+        final ASN1Sequence outer = this;
+
+        return new ASN1SequenceParser()
+        {
+            private final int max = size();
+
+            private int index;
+
+            public DEREncodable readObject() throws IOException
+            {
+                if (index == max)
+                {
+                    return null;
+                }
+
+                DEREncodable obj = getObjectAt(index++);
+                if (obj instanceof ASN1Sequence)
+                {
+                    return ((ASN1Sequence)obj).parser();
+                }
+                if (obj instanceof ASN1Set)
+                {
+                    return ((ASN1Set)obj).parser();
+                }
+
+                return obj;
+            }
+
+            public DERObject getLoadedObject()
+            {
+                return outer;
+            }
+
+            public DERObject getDERObject()
+            {
+                return outer;
+            }
+        };
+    }
+
+    /**
+     * return the object at the sequence position indicated by index.
+     *
+     * @param index the sequence number (starting at zero) of the object
+     * @return the object at the sequence position indicated by index.
+     */
+    public DEREncodable getObjectAt(
+        int index)
+    {
+        return (DEREncodable)seq.elementAt(index);
+    }
+
+    /**
+     * return the number of objects in this sequence.
+     *
+     * @return the number of objects in this sequence.
+     */
+    public int size()
+    {
+        return seq.size();
+    }
+
+    public int hashCode()
+    {
+        Enumeration             e = this.getObjects();
+        int                     hashCode = size();
+
+        while (e.hasMoreElements())
+        {
+            Object o = getNext(e);
+            hashCode *= 17;
+
+            hashCode ^= o.hashCode();
+        }
+
+        return hashCode;
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof ASN1Sequence))
+        {
+            return false;
+        }
+
+        ASN1Sequence   other = (ASN1Sequence)o;
+
+        if (this.size() != other.size())
+        {
+            return false;
+        }
+
+        Enumeration s1 = this.getObjects();
+        Enumeration s2 = other.getObjects();
+
+        while (s1.hasMoreElements())
+        {
+            DEREncodable  obj1 = getNext(s1);
+            DEREncodable  obj2 = getNext(s2);
+
+            DERObject  o1 = obj1.getDERObject();
+            DERObject  o2 = obj2.getDERObject();
+
+            if (o1 == o2 || o1.equals(o2))
+            {
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private DEREncodable getNext(Enumeration e)
+    {
+        DEREncodable encObj = (DEREncodable)e.nextElement();
+
+        // unfortunately null was allowed as a substitute for DER null
+        if (encObj == null)
+        {
+            return DERNull.INSTANCE;
+        }
+
+        return encObj;
+    }
+
+    protected void addObject(
+        DEREncodable obj)
+    {
+        seq.addElement(obj);
+    }
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+
+    public String toString()
+    {
+      return seq.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1SequenceParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    DEREncodable readObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Set.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Set.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Set.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Set.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Set.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,345 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Vector;
+
+abstract public class ASN1Set
+    extends ASN1Object
+{
+    protected Vector set = new Vector();
+
+    /**
+     * return an ASN1Set from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static ASN1Set getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof ASN1Set)
+        {
+            return (ASN1Set)obj;
+        }
+
+        throw new IllegalArgumentException("unknown object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * Return an ASN1 set from a tagged object. There is a special
+     * case here, if an object appears to have been explicitly tagged on
+     * reading but we were expecting it to be implicitly tagged in the
+     * normal course of events it indicates that we lost the surrounding
+     * set - so we need to add it back (this will happen if the tagged
+     * object is a sequence that contains other sequences). If you are
+     * dealing with implicitly tagged sets you really <b>should</b>
+     * be using this method.
+     *
+     * @param obj the tagged object.
+     * @param explicit true if the object is meant to be explicitly tagged
+     *          false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *          be converted.
+     */
+    public static ASN1Set getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        if (explicit)
+        {
+            if (!obj.isExplicit())
+            {
+                throw new IllegalArgumentException("object implicit - explicit expected.");
+            }
+
+            return (ASN1Set)obj.getObject();
+        }
+        else
+        {
+            //
+            // constructed object which appears to be explicitly tagged
+            // and it's really implicit means we have to add the
+            // surrounding sequence.
+            //
+            if (obj.isExplicit())
+            {
+                ASN1Set    set = new DERSet(obj.getObject());
+
+                return set;
+            }
+            else
+            {
+                if (obj.getObject() instanceof ASN1Set)
+                {
+                    return (ASN1Set)obj.getObject();
+                }
+
+                //
+                // in this case the parser returns a sequence, convert it
+                // into a set.
+                //
+                ASN1EncodableVector  v = new ASN1EncodableVector();
+
+                if (obj.getObject() instanceof ASN1Sequence)
+                {
+                    ASN1Sequence s = (ASN1Sequence)obj.getObject();
+                    Enumeration e = s.getObjects();
+
+                    while (e.hasMoreElements())
+                    {
+                        v.add((DEREncodable)e.nextElement());
+                    }
+
+                    return new DERSet(v, false);
+                }
+            }
+        }
+
+        throw new IllegalArgumentException("unknown object in getInstance: " + obj.getClass().getName());
+    }
+
+    public ASN1Set()
+    {
+    }
+
+    public Enumeration getObjects()
+    {
+        return set.elements();
+    }
+
+    /**
+     * return the object at the set position indicated by index.
+     *
+     * @param index the set number (starting at zero) of the object
+     * @return the object at the set position indicated by index.
+     */
+    public DEREncodable getObjectAt(
+        int index)
+    {
+        return (DEREncodable)set.elementAt(index);
+    }
+
+    /**
+     * return the number of objects in this set.
+     *
+     * @return the number of objects in this set.
+     */
+    public int size()
+    {
+        return set.size();
+    }
+
+    public ASN1Encodable[] toArray()
+    {
+        ASN1Encodable[] values = new ASN1Encodable[this.size()];
+
+        for (int i = 0; i != this.size(); i++)
+        {
+            values[i] = (ASN1Encodable)this.getObjectAt(i);
+        }
+
+        return values;
+    }
+
+    public ASN1SetParser parser()
+    {
+        final ASN1Set outer = this;
+
+        return new ASN1SetParser()
+        {
+            private final int max = size();
+
+            private int index;
+
+            public DEREncodable readObject() throws IOException
+            {
+                if (index == max)
+                {
+                    return null;
+                }
+
+                DEREncodable obj = getObjectAt(index++);
+                if (obj instanceof ASN1Sequence)
+                {
+                    return ((ASN1Sequence)obj).parser();
+                }
+                if (obj instanceof ASN1Set)
+                {
+                    return ((ASN1Set)obj).parser();
+                }
+
+                return obj;
+            }
+
+            public DERObject getLoadedObject()
+            {
+                return outer;
+            }
+
+            public DERObject getDERObject()
+            {
+                return outer;
+            }
+        };
+    }
+
+    public int hashCode()
+    {
+        Enumeration             e = this.getObjects();
+        int                     hashCode = size();
+
+        while (e.hasMoreElements())
+        {
+            Object o = getNext(e);
+            hashCode *= 17;
+
+            hashCode ^= o.hashCode();
+        }
+
+        return hashCode;
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof ASN1Set))
+        {
+            return false;
+        }
+
+        ASN1Set   other = (ASN1Set)o;
+
+        if (this.size() != other.size())
+        {
+            return false;
+        }
+
+        Enumeration s1 = this.getObjects();
+        Enumeration s2 = other.getObjects();
+
+        while (s1.hasMoreElements())
+        {
+            DEREncodable  obj1 = getNext(s1);
+            DEREncodable  obj2 = getNext(s2);
+
+            DERObject  o1 = obj1.getDERObject();
+            DERObject  o2 = obj2.getDERObject();
+
+            if (o1 == o2 || o1.equals(o2))
+            {
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private DEREncodable getNext(Enumeration e)
+    {
+        DEREncodable encObj = (DEREncodable)e.nextElement();
+
+        // unfortunately null was allowed as a substitute for DER null
+        if (encObj == null)
+        {
+            return DERNull.INSTANCE;
+        }
+
+        return encObj;
+    }
+
+    /**
+     * return true if a <= b (arrays are assumed padded with zeros).
+     */
+    private boolean lessThanOrEqual(
+         byte[] a,
+         byte[] b)
+    {
+        int len = Math.min(a.length, b.length);
+        for (int i = 0; i != len; ++i)
+        {
+            if (a[i] != b[i])
+            {
+                return (a[i] & 0xff) < (b[i] & 0xff);
+            }
+        }
+        return len == a.length;
+    }
+
+    private byte[] getEncoded(
+        DEREncodable obj)
+    {
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        ASN1OutputStream        aOut = new ASN1OutputStream(bOut);
+
+        try
+        {
+            aOut.writeObject(obj);
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException("cannot encode object added to SET");
+        }
+
+        return bOut.toByteArray();
+    }
+
+    protected void sort()
+    {
+        if (set.size() > 1)
+        {
+            boolean    swapped = true;
+            int        lastSwap = set.size() - 1;
+
+            while (swapped)
+            {
+                int    index = 0;
+                int    swapIndex = 0;
+                byte[] a = getEncoded((DEREncodable)set.elementAt(0));
+
+                swapped = false;
+
+                while (index != lastSwap)
+                {
+                    byte[] b = getEncoded((DEREncodable)set.elementAt(index + 1));
+
+                    if (lessThanOrEqual(a, b))
+                    {
+                        a = b;
+                    }
+                    else
+                    {
+                        Object  o = set.elementAt(index);
+
+                        set.setElementAt(set.elementAt(index + 1), index);
+                        set.setElementAt(o, index + 1);
+
+                        swapped = true;
+                        swapIndex = index;
+                    }
+
+                    index++;
+                }
+
+                lastSwap = swapIndex;
+            }
+        }
+    }
+
+    protected void addObject(
+        DEREncodable obj)
+    {
+        set.addElement(obj);
+    }
+
+    abstract void encode(DEROutputStream out)
+            throws IOException;
+
+    public String toString()
+    {
+      return set.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1SetParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1SetParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1SetParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1SetParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    public DEREncodable readObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,245 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+public class ASN1StreamParser
+{
+    private final InputStream _in;
+    private final int         _limit;
+
+    public ASN1StreamParser(
+        InputStream in)
+    {
+        this(in, ASN1InputStream.findLimit(in));
+    }
+
+    public ASN1StreamParser(
+        InputStream in,
+        int         limit)
+    {
+        this._in = in;
+        this._limit = limit;
+    }
+
+    public ASN1StreamParser(
+        byte[] encoding)
+    {
+        this(new ByteArrayInputStream(encoding), encoding.length);
+    }
+
+    DEREncodable readIndef(int tagValue) throws IOException
+    {
+        // Note: INDEF => CONSTRUCTED
+
+        // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+        switch (tagValue)
+        {
+            case DERTags.EXTERNAL:
+                return new DERExternalParser(this);
+            case DERTags.OCTET_STRING:
+                return new BEROctetStringParser(this);
+            case DERTags.SEQUENCE:
+                return new BERSequenceParser(this);
+            case DERTags.SET:
+                return new BERSetParser(this);
+            default:
+                throw new ASN1Exception("unknown BER object encountered: 0x" + Integer.toHexString(tagValue));
+        }
+    }
+
+    DEREncodable readImplicit(boolean constructed, int tag) throws IOException
+    {
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            if (!constructed)
+            {
+                throw new IOException("indefinite length primitive encoding encountered");
+            }
+
+            return readIndef(tag);
+        }
+
+        if (constructed)
+        {
+            switch (tag)
+            {
+                case DERTags.SET:
+                    return new DERSetParser(this);
+                case DERTags.SEQUENCE:
+                    return new DERSequenceParser(this);
+                case DERTags.OCTET_STRING:
+                    return new BEROctetStringParser(this);
+            }
+        }
+        else
+        {
+            switch (tag)
+            {
+                case DERTags.SET:
+                    throw new ASN1Exception("sequences must use constructed encoding (see X.690 8.9.1/8.10.1)");
+                case DERTags.SEQUENCE:
+                    throw new ASN1Exception("sets must use constructed encoding (see X.690 8.11.1/8.12.1)");
+                case DERTags.OCTET_STRING:
+                    return new DEROctetStringParser((DefiniteLengthInputStream)_in);
+            }
+        }
+
+        // TODO ASN1Exception
+        throw new RuntimeException("implicit tagging not implemented");
+    }
+
+    DERObject readTaggedObject(boolean constructed, int tag) throws IOException
+    {
+        if (!constructed)
+        {
+            // Note: !CONSTRUCTED => IMPLICIT
+            DefiniteLengthInputStream defIn = (DefiniteLengthInputStream)_in;
+            return new DERTaggedObject(false, tag, new DEROctetString(defIn.toByteArray()));
+        }
+
+        ASN1EncodableVector v = readVector();
+
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            return v.size() == 1
+                ?   new BERTaggedObject(true, tag, v.get(0))
+                :   new BERTaggedObject(false, tag, BERFactory.createSequence(v));
+        }
+
+        return v.size() == 1
+            ?   new DERTaggedObject(true, tag, v.get(0))
+            :   new DERTaggedObject(false, tag, DERFactory.createSequence(v));
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        int tag = _in.read();
+        if (tag == -1)
+        {
+            return null;
+        }
+
+        //
+        // turn of looking for "00" while we resolve the tag
+        //
+        set00Check(false);
+
+        //
+        // calculate tag number
+        //
+        int tagNo = ASN1InputStream.readTagNumber(_in, tag);
+
+        boolean isConstructed = (tag & DERTags.CONSTRUCTED) != 0;
+
+        //
+        // calculate length
+        //
+        int length = ASN1InputStream.readLength(_in, _limit);
+
+        if (length < 0) // indefinite length method
+        {
+            if (!isConstructed)
+            {
+                throw new IOException("indefinite length primitive encoding encountered");
+            }
+
+            IndefiniteLengthInputStream indIn = new IndefiniteLengthInputStream(_in, _limit);
+            ASN1StreamParser sp = new ASN1StreamParser(indIn, _limit);
+
+            if ((tag & DERTags.APPLICATION) != 0)
+            {
+                return new BERApplicationSpecificParser(tagNo, sp);
+            }
+
+            if ((tag & DERTags.TAGGED) != 0)
+            {
+                return new BERTaggedObjectParser(true, tagNo, sp);
+            }
+
+            return sp.readIndef(tagNo);
+        }
+        else
+        {
+            DefiniteLengthInputStream defIn = new DefiniteLengthInputStream(_in, length);
+
+            if ((tag & DERTags.APPLICATION) != 0)
+            {
+                return new DERApplicationSpecific(isConstructed, tagNo, defIn.toByteArray());
+            }
+
+            if ((tag & DERTags.TAGGED) != 0)
+            {
+                return new BERTaggedObjectParser(isConstructed, tagNo, new ASN1StreamParser(defIn));
+            }
+
+            if (isConstructed)
+            {
+                // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+                switch (tagNo)
+                {
+                    case DERTags.OCTET_STRING:
+                        //
+                        // yes, people actually do this...
+                        //
+                        return new BEROctetStringParser(new ASN1StreamParser(defIn));
+                    case DERTags.SEQUENCE:
+                        return new DERSequenceParser(new ASN1StreamParser(defIn));
+                    case DERTags.SET:
+                        return new DERSetParser(new ASN1StreamParser(defIn));
+                    case DERTags.EXTERNAL:
+                        return new DERExternalParser(new ASN1StreamParser(defIn));
+                    default:
+                        // TODO Add DERUnknownTagParser class?
+                        return new DERUnknownTag(true, tagNo, defIn.toByteArray());
+                }
+            }
+
+            // Some primitive encodings can be handled by parsers too...
+            switch (tagNo)
+            {
+                case DERTags.OCTET_STRING:
+                    return new DEROctetStringParser(defIn);
+            }
+
+            try
+            {
+                return ASN1InputStream.createPrimitiveDERObject(tagNo, defIn.toByteArray());
+            }
+            catch (IllegalArgumentException e)
+            {
+                throw new ASN1Exception("corrupted stream detected", e);
+            }
+        }
+    }
+
+    private void set00Check(boolean enabled)
+    {
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            ((IndefiniteLengthInputStream)_in).setEofOn00(enabled);
+        }
+    }
+
+    ASN1EncodableVector readVector() throws IOException
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        DEREncodable obj;
+        while ((obj = readObject()) != null)
+        {
+            if (obj instanceof InMemoryRepresentable)
+            {
+                v.add(((InMemoryRepresentable)obj).getLoadedObject());
+            }
+            else
+            {
+                v.add(obj.getDERObject());
+            }
+        }
+
+        return v;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,6 @@
+package org.bouncycastle.asn1;
+
+public interface ASN1String
+{
+    public String getString();
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,215 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
+ * a [n] where n is some number - these are assumed to follow the construction
+ * rules (as with sequences).
+ */
+public abstract class ASN1TaggedObject
+    extends ASN1Object
+    implements ASN1TaggedObjectParser
+{
+    int             tagNo;
+    boolean         empty = false;
+    boolean         explicit = true;
+    DEREncodable    obj = null;
+
+    static public ASN1TaggedObject getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        if (explicit)
+        {
+            return (ASN1TaggedObject)obj.getObject();
+        }
+
+        throw new IllegalArgumentException("implicitly tagged tagged object");
+    }
+
+    static public ASN1TaggedObject getInstance(
+        Object obj)
+    {
+        if (obj == null || obj instanceof ASN1TaggedObject)
+        {
+                return (ASN1TaggedObject)obj;
+        }
+
+        throw new IllegalArgumentException("unknown object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * Create a tagged object in the explicit style.
+     *
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public ASN1TaggedObject(
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        this.explicit = true;
+        this.tagNo = tagNo;
+        this.obj = obj;
+    }
+
+    /**
+     * Create a tagged object with the style given by the value of explicit.
+     * <p>
+     * If the object implements ASN1Choice the tag style will always be changed
+     * to explicit in accordance with the ASN.1 encoding rules.
+     * </p>
+     * @param explicit true if the object is explicitly tagged.
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public ASN1TaggedObject(
+        boolean         explicit,
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        if (obj instanceof ASN1Choice)
+        {
+            this.explicit = true;
+        }
+        else
+        {
+            this.explicit = explicit;
+        }
+
+        this.tagNo = tagNo;
+        this.obj = obj;
+    }
+
+    boolean asn1Equals(
+        DERObject o)
+    {
+        if (!(o instanceof ASN1TaggedObject))
+        {
+            return false;
+        }
+
+        ASN1TaggedObject other = (ASN1TaggedObject)o;
+
+        if (tagNo != other.tagNo || empty != other.empty || explicit != other.explicit)
+        {
+            return false;
+        }
+
+        if(obj == null)
+        {
+            if (other.obj != null)
+            {
+                return false;
+            }
+        }
+        else
+        {
+            if (!(obj.getDERObject().equals(other.obj.getDERObject())))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public int hashCode()
+    {
+        int code = tagNo;
+
+        // TODO: actually this is wrong - the problem is that a re-encoded
+        // object may end up with a different hashCode due to implicit
+        // tagging. As implicit tagging is ambiguous if a sequence is involved
+        // it seems the only correct method for both equals and hashCode is to
+        // compare the encodings...
+        if (obj != null)
+        {
+            code ^= obj.hashCode();
+        }
+
+        return code;
+    }
+
+    public int getTagNo()
+    {
+        return tagNo;
+    }
+
+    /**
+     * return whether or not the object may be explicitly tagged.
+     * <p>
+     * Note: if the object has been read from an input stream, the only
+     * time you can be sure if isExplicit is returning the true state of
+     * affairs is if it returns false. An implicitly tagged object may appear
+     * to be explicitly tagged, so you need to understand the context under
+     * which the reading was done as well, see getObject below.
+     */
+    public boolean isExplicit()
+    {
+        return explicit;
+    }
+
+    public boolean isEmpty()
+    {
+        return empty;
+    }
+
+    /**
+     * return whatever was following the tag.
+     * <p>
+     * Note: tagged objects are generally context dependent if you're
+     * trying to extract a tagged object you should be going via the
+     * appropriate getInstance method.
+     */
+    public DERObject getObject()
+    {
+        if (obj != null)
+        {
+            return obj.getDERObject();
+        }
+
+        return null;
+    }
+
+    /**
+     * Return the object held in this tagged object as a parser assuming it has
+     * the type of the passed in tag. If the object doesn't have a parser
+     * associated with it, the base object is returned.
+     */
+    public DEREncodable getObjectParser(
+        int     tag,
+        boolean isExplicit)
+    {
+        switch (tag)
+        {
+        case DERTags.SET:
+            return ASN1Set.getInstance(this, isExplicit).parser();
+        case DERTags.SEQUENCE:
+            return ASN1Sequence.getInstance(this, isExplicit).parser();
+        case DERTags.OCTET_STRING:
+            return ASN1OctetString.getInstance(this, isExplicit).parser();
+        }
+
+        if (isExplicit)
+        {
+            return getObject();
+        }
+
+        throw new RuntimeException("implicit tagging not implemented for tag: " + tag);
+    }
+
+    public DERObject getLoadedObject()
+    {
+        return this.getDERObject();
+    }
+
+    abstract void encode(DEROutputStream  out)
+        throws IOException;
+
+    public String toString()
+    {
+        return "[" + tagNo + "]" + obj;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1TaggedObjectParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    public int getTagNo();
+
+    public DEREncodable getObjectParser(int tag, boolean isExplicit)
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+
+public class ASN1UTCTime
+    extends DERUTCTime
+{
+    ASN1UTCTime(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+  /*  public ASN1UTCTime(Date time)
+    {
+        super(time);
+    }
+*/
+ /*   public ASN1UTCTime(String time)
+    {
+        super(time);
+    }
+    */
+}

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+public class BERApplicationSpecific
+    extends DERApplicationSpecific
+{
+    public BERApplicationSpecific(int tagNo, ASN1EncodableVector vec)
+    {
+        super(tagNo, vec);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class BERApplicationSpecificParser
+    implements ASN1ApplicationSpecificParser
+{
+    private final int tag;
+    private final ASN1StreamParser parser;
+
+    BERApplicationSpecificParser(int tag, ASN1StreamParser parser)
+    {
+        this.tag = tag;
+        this.parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+         return new BERApplicationSpecific(tag, parser.readVector());
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage(), e);
+        }
+    }
+
+}

Added: trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,157 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Vector;
+
+public class BERConstructedOctetString
+    extends DEROctetString
+{
+    private static final int MAX_LENGTH = 1000;
+
+    /**
+     * convert a vector of octet strings into a single byte string
+     */
+    static private byte[] toBytes(
+        Vector  octs)
+    {
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+
+        for (int i = 0; i != octs.size(); i++)
+        {
+            try
+            {
+                DEROctetString  o = (DEROctetString)octs.elementAt(i);
+
+                bOut.write(o.getOctets());
+            }
+            catch (ClassCastException e)
+            {
+                throw new IllegalArgumentException(octs.elementAt(i).getClass().getName() + " found in input should only contain DEROctetString");
+            }
+            catch (IOException e)
+            {
+                throw new IllegalArgumentException("exception converting octets " + e.toString());
+            }
+        }
+
+        return bOut.toByteArray();
+    }
+
+    private Vector  octs;
+
+    /**
+     * @param string the octets making up the octet string.
+     */
+    public BERConstructedOctetString(
+        byte[]  string)
+    {
+        super(string);
+    }
+
+    public BERConstructedOctetString(
+        Vector  octs)
+    {
+        super(toBytes(octs));
+
+        this.octs = octs;
+    }
+
+    public BERConstructedOctetString(
+        DERObject  obj)
+    {
+        super(obj);
+    }
+
+    public BERConstructedOctetString(
+        DEREncodable  obj)
+    {
+        super(obj.getDERObject());
+    }
+
+    public byte[] getOctets()
+    {
+        return string;
+    }
+
+    /**
+     * return the DER octets that make up this string.
+     */
+    public Enumeration getObjects()
+    {
+        if (octs == null)
+        {
+            return generateOcts().elements();
+        }
+
+        return octs.elements();
+    }
+
+    private Vector generateOcts()
+    {
+        Vector vec = new Vector();
+        for (int i = 0; i < string.length; i += MAX_LENGTH)
+        {
+            int end;
+
+            if (i + MAX_LENGTH > string.length)
+            {
+                end = string.length;
+            }
+            else
+            {
+                end = i + MAX_LENGTH;
+            }
+
+            byte[] nStr = new byte[end - i];
+
+            System.arraycopy(string, i, nStr, 0, nStr.length);
+
+            vec.addElement(new DEROctetString(nStr));
+         }
+
+         return vec;
+    }
+
+    public void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.write(CONSTRUCTED | OCTET_STRING);
+
+            out.write(0x80);
+
+            //
+            // write out the octet array
+            //
+            Enumeration e = getObjects();
+            while (e.hasMoreElements())
+            {
+                out.writeObject(e.nextElement());
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+
+    public static BERConstructedOctetString fromSequence(ASN1Sequence seq)
+    {
+        Vector      v = new Vector();
+        Enumeration e = seq.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            v.addElement(e.nextElement());
+        }
+
+        return new BERConstructedOctetString(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERFactory.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+class BERFactory
+{
+    static final BERSequence EMPTY_SEQUENCE = new BERSequence();
+    static final BERSet EMPTY_SET = new BERSet();
+
+    static BERSequence createSequence(ASN1EncodableVector v)
+    {
+        return v.size() < 1 ? EMPTY_SEQUENCE : new BERSequence(v);
+    }
+
+    static BERSet createSet(ASN1EncodableVector v)
+    {
+        return v.size() < 1 ? EMPTY_SET : new BERSet(v);
+    }
+
+    static BERSet createSet(ASN1EncodableVector v, boolean needsSorting)
+    {
+        return v.size() < 1 ? EMPTY_SET : new BERSet(v, needsSorting);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.io.Streams;
+
+public class BEROctetStringParser
+    implements ASN1OctetStringParser
+{
+    private ASN1StreamParser _parser;
+
+    BEROctetStringParser(
+        ASN1StreamParser parser)
+    {
+        _parser = parser;
+    }
+
+    public InputStream getOctetStream()
+    {
+        return new ConstructedOctetStream(_parser);
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new BERConstructedOctetString(Streams.readAll(getOctetStream()));
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException("IOException converting stream to byte array: " + e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BEROutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BEROutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BEROutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BEROutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BEROutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class BEROutputStream
+    extends DEROutputStream
+{
+    public BEROutputStream(
+        OutputStream    os)
+    {
+        super(os);
+    }
+
+    public void writeObject(
+        Object    obj)
+        throws IOException
+    {
+        if (obj == null)
+        {
+            writeNull();
+        }
+        else if (obj instanceof DERObject)
+        {
+            ((DERObject)obj).encode(this);
+        }
+        else if (obj instanceof DEREncodable)
+        {
+            ((DEREncodable)obj).getDERObject().encode(this);
+        }
+        else
+        {
+            throw new IOException("object not BEREncodable");
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,59 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class BERSequence
+    extends DERSequence
+{
+    /**
+     * create an empty sequence
+     */
+    public BERSequence()
+    {
+    }
+
+    /**
+     * create a sequence containing one object
+     */
+    public BERSequence(
+        DEREncodable    obj)
+    {
+        super(obj);
+    }
+
+    /**
+     * create a sequence containing a vector of objects.
+     */
+    public BERSequence(
+        ASN1EncodableVector   v)
+    {
+        super(v);
+    }
+
+    /*
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.write(SEQUENCE | CONSTRUCTED);
+            out.write(0x80);
+
+            Enumeration e = getObjects();
+            while (e.hasMoreElements())
+            {
+                out.writeObject(e.nextElement());
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSequenceParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSequenceParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSequenceParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class BERSequenceParser
+    implements ASN1SequenceParser
+{
+    private ASN1StreamParser _parser;
+
+    BERSequenceParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new BERSequence(_parser.readVector());
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException(e.getMessage());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSet.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSet.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSet.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSet.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSet.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,69 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class BERSet
+    extends DERSet
+{
+    /**
+     * create an empty sequence
+     */
+    public BERSet()
+    {
+    }
+
+    /**
+     * create a set containing one object
+     */
+    public BERSet(
+        DEREncodable    obj)
+    {
+        super(obj);
+    }
+
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    public BERSet(
+        ASN1EncodableVector   v)
+    {
+        super(v, false);
+    }
+
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    BERSet(
+        ASN1EncodableVector  v,
+        boolean              needsSorting)
+    {
+        super(v, needsSorting);
+    }
+
+    /*
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.write(SET | CONSTRUCTED);
+            out.write(0x80);
+
+            Enumeration e = getObjects();
+            while (e.hasMoreElements())
+            {
+                out.writeObject(e.nextElement());
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSetParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSetParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSetParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSetParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSetParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class BERSetParser
+    implements ASN1SetParser
+{
+    private ASN1StreamParser _parser;
+
+    BERSetParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new BERSet(_parser.readVector(), false);
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERTaggedObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERTaggedObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,107 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+/**
+ * BER TaggedObject - in ASN.1 notation this is any object preceded by
+ * a [n] where n is some number - these are assumed to follow the construction
+ * rules (as with sequences).
+ */
+public class BERTaggedObject
+    extends DERTaggedObject
+{
+    /**
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public BERTaggedObject(
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(tagNo, obj);
+    }
+
+    /**
+     * @param explicit true if an explicitly tagged object.
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public BERTaggedObject(
+        boolean         explicit,
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(explicit, tagNo, obj);
+    }
+
+    /**
+     * create an implicitly tagged object that contains a zero
+     * length sequence.
+     */
+    public BERTaggedObject(
+        int             tagNo)
+    {
+        super(false, tagNo, new BERSequence());
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.writeTag(CONSTRUCTED | TAGGED, tagNo);
+            out.write(0x80);
+
+            if (!empty)
+            {
+                if (!explicit)
+                {
+                    Enumeration e;
+                    if (obj instanceof ASN1OctetString)
+                    {
+                        if (obj instanceof BERConstructedOctetString)
+                        {
+                            e = ((BERConstructedOctetString)obj).getObjects();
+                        }
+                        else
+                        {
+                            ASN1OctetString             octs = (ASN1OctetString)obj;
+                            BERConstructedOctetString   berO = new BERConstructedOctetString(octs.getOctets());
+                            e = berO.getObjects();
+                        }
+                    }
+                    else if (obj instanceof ASN1Sequence)
+                    {
+                        e = ((ASN1Sequence)obj).getObjects();
+                    }
+                    else if (obj instanceof ASN1Set)
+                    {
+                        e = ((ASN1Set)obj).getObjects();
+                    }
+                    else
+                    {
+                        throw new RuntimeException("not implemented: " + obj.getClass().getName());
+                    }
+
+                    while (e.hasMoreElements())
+                    {
+                        out.writeObject(e.nextElement());
+                    }
+                }
+                else
+                {
+                    out.writeObject(obj);
+                }
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,78 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+public class BERTaggedObjectParser
+    implements ASN1TaggedObjectParser
+{
+    private boolean _constructed;
+    private int _tagNumber;
+    private ASN1StreamParser _parser;
+
+    /**
+     * @deprecated
+     */
+    protected BERTaggedObjectParser(
+        int         baseTag,
+        int         tagNumber,
+        InputStream contentStream)
+    {
+        this((baseTag & DERTags.CONSTRUCTED) != 0, tagNumber, new ASN1StreamParser(contentStream));
+    }
+
+    BERTaggedObjectParser(
+        boolean             constructed,
+        int                 tagNumber,
+        ASN1StreamParser    parser)
+    {
+        _constructed = constructed;
+        _tagNumber = tagNumber;
+        _parser = parser;
+    }
+
+    public boolean isConstructed()
+    {
+        return _constructed;
+    }
+
+    public int getTagNo()
+    {
+        return _tagNumber;
+    }
+
+    public DEREncodable getObjectParser(
+        int     tag,
+        boolean isExplicit)
+        throws IOException
+    {
+        if (isExplicit)
+        {
+            if (!_constructed)
+            {
+                throw new IOException("Explicit tags must be constructed (see X.690 8.14.2)");
+            }
+            return _parser.readObject();
+        }
+
+        return _parser.readImplicit(_constructed, tag);
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return _parser.readTaggedObject(_constructed, _tagNumber);
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return this.getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,111 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.InputStream;
+import ewe.io.IOException;
+
+class ConstructedOctetStream
+    extends InputStream
+{
+    private final ASN1StreamParser _parser;
+
+    private boolean                _first = true;
+    private InputStream            _currentStream;
+
+    ConstructedOctetStream(
+        ASN1StreamParser parser)
+    {
+        _parser = parser;
+    }
+
+    public int read(byte[] b, int off, int len) throws IOException
+    {
+        if (_currentStream == null)
+        {
+            if (!_first)
+            {
+                return -1;
+            }
+
+            ASN1OctetStringParser s = (ASN1OctetStringParser)_parser.readObject();
+
+            if (s == null)
+            {
+                return -1;
+            }
+
+            _first = false;
+            _currentStream = s.getOctetStream();
+        }
+
+        int totalRead = 0;
+
+        for (;;)
+        {
+            int numRead = _currentStream.read(b, off + totalRead, len - totalRead);
+
+            if (numRead >= 0)
+            {
+                totalRead += numRead;
+
+                if (totalRead == len)
+                {
+                    return totalRead;
+                }
+            }
+            else
+            {
+                ASN1OctetStringParser aos = (ASN1OctetStringParser)_parser.readObject();
+
+                if (aos == null)
+                {
+                    _currentStream = null;
+                    return totalRead < 1 ? -1 : totalRead;
+                }
+
+                _currentStream = aos.getOctetStream();
+            }
+        }
+    }
+
+    public int read()
+        throws IOException
+    {
+        if (_currentStream == null)
+        {
+            if (!_first)
+            {
+                return -1;
+            }
+
+            ASN1OctetStringParser s = (ASN1OctetStringParser)_parser.readObject();
+    
+            if (s == null)
+            {
+                return -1;
+            }
+    
+            _first = false;
+            _currentStream = s.getOctetStream();
+        }
+
+        for (;;)
+        {
+            int b = _currentStream.read();
+
+            if (b >= 0)
+            {
+                return b;
+            }
+
+            ASN1OctetStringParser s = (ASN1OctetStringParser)_parser.readObject();
+
+            if (s == null)
+            {
+                _currentStream = null;
+                return -1;
+            }
+
+            _currentStream = s.getOctetStream();
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,225 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Arrays;
+
+/**
+ * Base class for an application specific object
+ */
+public class DERApplicationSpecific
+    extends ASN1Object
+{
+    private final boolean   isConstructed;
+    private final int       tag;
+    private final byte[]    octets;
+
+    DERApplicationSpecific(
+        boolean isConstructed,
+        int     tag,
+        byte[]  octets)
+    {
+        this.isConstructed = isConstructed;
+        this.tag = tag;
+        this.octets = octets;
+    }
+
+    public DERApplicationSpecific(
+        int    tag,
+        byte[] octets)
+    {
+        this(false, tag, octets);
+    }
+
+    public DERApplicationSpecific(
+        int                  tag,
+        DEREncodable         object)
+        throws IOException
+    {
+        this(true, tag, object);
+    }
+
+    public DERApplicationSpecific(
+        boolean      explicit,
+        int          tag,
+        DEREncodable object)
+        throws IOException
+    {
+        byte[] data = object.getDERObject().getDEREncoded();
+
+        this.isConstructed = explicit;
+        this.tag = tag;
+
+        if (explicit)
+        {
+            this.octets = data;
+        }
+        else
+        {
+            int lenBytes = getLengthOfLength(data);
+            byte[] tmp = new byte[data.length - lenBytes];
+            System.arraycopy(data, lenBytes, tmp, 0, tmp.length);
+            this.octets = tmp;
+        }
+    }
+
+    public DERApplicationSpecific(int tagNo, ASN1EncodableVector vec)
+    {
+        this.tag = tagNo;
+        this.isConstructed = true;
+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+
+        for (int i = 0; i != vec.size(); i++)
+        {
+            try
+            {
+                bOut.write(((ASN1Encodable)vec.get(i)).getEncoded());
+            }
+            catch (IOException e)
+            {
+                throw new ASN1ParsingException("malformed object: " + e, e);
+            }
+        }
+        this.octets = bOut.toByteArray();
+    }
+
+    private int getLengthOfLength(byte[] data)
+    {
+        int count = 2;               // TODO: assumes only a 1 byte tag number
+
+        while((data[count - 1] & 0x80) != 0)
+        {
+            count++;
+        }
+
+        return count;
+    }
+
+    public boolean isConstructed()
+    {
+        return isConstructed;
+    }
+
+    public byte[] getContents()
+    {
+        return octets;
+    }
+
+    public int getApplicationTag()
+    {
+        return tag;
+    }
+
+    /**
+     * Return the enclosed object assuming explicit tagging.
+     *
+     * @return  the resulting object
+     * @throws IOException if reconstruction fails.
+     */
+    public DERObject getObject()
+        throws IOException
+    {
+        return new ASN1InputStream(getContents()).readObject();
+    }
+
+    /**
+     * Return the enclosed object assuming implicit tagging.
+     *
+     * @param derTagNo the type tag that should be applied to the object's contents.
+     * @return  the resulting object
+     * @throws IOException if reconstruction fails.
+     */
+    public DERObject getObject(int derTagNo)
+        throws IOException
+    {
+        if (derTagNo >= 0x1f)
+        {
+            throw new IOException("unsupported tag number");
+        }
+
+        byte[] orig = this.getEncoded();
+        byte[] tmp = replaceTagNumber(derTagNo, orig);
+
+        if ((orig[0] & DERTags.CONSTRUCTED) != 0)
+        {
+            tmp[0] |= DERTags.CONSTRUCTED;
+        }
+
+        return new ASN1InputStream(tmp).readObject();
+    }
+
+    /* (non-Javadoc)
+     * @see org.bouncycastle.asn1.DERObject#encode(org.bouncycastle.asn1.DEROutputStream)
+     */
+    void encode(DEROutputStream out) throws IOException
+    {
+        int classBits = DERTags.APPLICATION;
+        if (isConstructed)
+        {
+            classBits |= DERTags.CONSTRUCTED;
+        }
+
+        out.writeEncoded(classBits, tag, octets);
+    }
+
+    boolean asn1Equals(
+        DERObject o)
+    {
+        if (!(o instanceof DERApplicationSpecific))
+        {
+            return false;
+        }
+
+        DERApplicationSpecific other = (DERApplicationSpecific)o;
+
+        return isConstructed == other.isConstructed
+            && tag == other.tag
+            && Arrays.areEqual(octets, other.octets);
+    }
+
+    public int hashCode()
+    {
+        return (isConstructed ? 1 : 0) ^ tag ^ Arrays.hashCode(octets);
+    }
+
+    private byte[] replaceTagNumber(int newTag, byte[] input)
+        throws IOException
+    {
+        int tagNo = input[0] & 0x1f;
+        int index = 1;
+        //
+        // with tagged object tag number is bottom 5 bits, or stored at the start of the content
+        //
+        if (tagNo == 0x1f)
+        {
+            tagNo = 0;
+
+            int b = input[index++] & 0xff;
+
+            // X.690-0207 8.1.2.4.2
+            // "c) bits 7 to 1 of the first subsequent octet shall not all be zero."
+            if ((b & 0x7f) == 0) // Note: -1 will pass
+            {
+                throw new ASN1ParsingException("corrupted stream - invalid high tag number found");
+            }
+
+            while ((b >= 0) && ((b & 0x80) != 0))
+            {
+                tagNo |= (b & 0x7f);
+                tagNo <<= 7;
+                b = input[index++] & 0xff;
+            }
+
+            tagNo |= (b & 0x7f);
+        }
+
+        byte[] tmp = new byte[input.length - index + 1];
+
+        System.arraycopy(input, index, tmp, 1, tmp.length - 1);
+
+        tmp[0] = (byte)newTag;
+
+        return tmp;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERBMPString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERBMPString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERBMPString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERBMPString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERBMPString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,125 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER BMPString object.
+ */
+public class DERBMPString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a BMP String from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERBMPString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERBMPString)
+        {
+            return (DERBMPString)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return a BMP String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *              be converted.
+     */
+    public static DERBMPString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERBMPString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERBMPString(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+    
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERBMPString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length / 2];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)((string[2 * i] << 8) | (string[2 * i + 1] & 0xff));
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor
+     */
+    public DERBMPString(
+        String   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    protected boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERBMPString))
+        {
+            return false;
+        }
+
+        DERBMPString  s = (DERBMPString)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        char[]  c = string.toCharArray();
+        byte[]  b = new byte[c.length * 2];
+
+        for (int i = 0; i != c.length; i++)
+        {
+            b[2 * i] = (byte)(c[i] >> 8);
+            b[2 * i + 1] = (byte)c[i];
+        }
+
+        out.writeEncoded(BMP_STRING, b);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERBitString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERBitString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERBitString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERBitString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERBitString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,277 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Arrays;
+
+public class DERBitString
+    extends ASN1Object
+    implements DERString
+{
+    private static final char[]  table = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+
+    protected byte[]      data;
+    protected int         padBits;
+
+    /**
+     * return the correct number of pad bits for a bit string defined in
+     * a 32 bit constant
+     */
+    static protected int getPadBits(
+        int bitString)
+    {
+        int val = 0;
+        for (int i = 3; i >= 0; i--)
+        {
+            //
+            // this may look a little odd, but if it isn't done like this pre jdk1.2
+            // JVM's break!
+            //
+            if (i != 0)
+            {
+                if ((bitString >> (i * 8)) != 0)
+                {
+                    val = (bitString >> (i * 8)) & 0xFF;
+                    break;
+                }
+            }
+            else
+            {
+                if (bitString != 0)
+                {
+                    val = bitString & 0xFF;
+                    break;
+                }
+            }
+        }
+
+        if (val == 0)
+        {
+            return 7;
+        }
+
+
+        int bits = 1;
+
+        while (((val <<= 1) & 0xFF) != 0)
+        {
+            bits++;
+        }
+
+        return 8 - bits;
+    }
+
+    /**
+     * return the correct number of bytes for a bit string defined in
+     * a 32 bit constant
+     */
+    static protected byte[] getBytes(int bitString)
+    {
+        int bytes = 4;
+        for (int i = 3; i >= 1; i--)
+        {
+            if ((bitString & (0xFF << (i * 8))) != 0)
+            {
+                break;
+            }
+            bytes--;
+        }
+
+        byte[] result = new byte[bytes];
+        for (int i = 0; i < bytes; i++)
+        {
+            result[i] = (byte) ((bitString >> (i * 8)) & 0xFF);
+        }
+
+        return result;
+    }
+
+    /**
+     * return a Bit String from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERBitString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERBitString)
+        {
+            return (DERBitString)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return a Bit String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERBitString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERBitString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return fromOctetString(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    protected DERBitString(
+        byte    data,
+        int     padBits)
+    {
+        this.data = new byte[1];
+        this.data[0] = data;
+        this.padBits = padBits;
+    }
+
+    /**
+     * @param data the octets making up the bit string.
+     * @param padBits the number of extra bits at the end of the string.
+     */
+    public DERBitString(
+        byte[]  data,
+        int     padBits)
+    {
+        this.data = data;
+        this.padBits = padBits;
+    }
+
+    public DERBitString(
+        byte[]  data)
+    {
+        this(data, 0);
+    }
+
+    public DERBitString(
+        DEREncodable  obj)
+    {
+        try
+        {
+            this.data = obj.getDERObject().getEncoded(ASN1Encodable.DER);
+            this.padBits = 0;
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException("Error processing object : " + e.toString());
+        }
+    }
+
+    public byte[] getBytes()
+    {
+        return data;
+    }
+
+    public int getPadBits()
+    {
+        return padBits;
+    }
+
+
+    /**
+     * @return the value of the bit string as an int (truncating if necessary)
+     */
+    public int intValue()
+    {
+        int value = 0;
+
+        for (int i = 0; i != data.length && i != 4; i++)
+        {
+            value |= (data[i] & 0xff) << (8 * i);
+        }
+
+        return value;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        byte[]  bytes = new byte[getBytes().length + 1];
+
+        bytes[0] = (byte)getPadBits();
+        System.arraycopy(getBytes(), 0, bytes, 1, bytes.length - 1);
+
+        out.writeEncoded(BIT_STRING, bytes);
+    }
+
+    public int hashCode()
+    {
+        return padBits ^ Arrays.hashCode(data);
+    }
+
+    protected boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERBitString))
+        {
+            return false;
+        }
+
+        DERBitString other = (DERBitString)o;
+
+        return this.padBits == other.padBits
+            && Arrays.areEqual(this.data, other.data);
+    }
+
+    public String getString()
+    {
+        StringBuffer          buf = new StringBuffer("#");
+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+        ASN1OutputStream      aOut = new ASN1OutputStream(bOut);
+
+        try
+        {
+            aOut.writeObject(this);
+        }
+        catch (IOException e)
+        {
+           throw new RuntimeException("internal error encoding BitString");
+        }
+
+        byte[]    string = bOut.toByteArray();
+
+        for (int i = 0; i != string.length; i++)
+        {
+            buf.append(table[(string[i] >>> 4) & 0xf]);
+            buf.append(table[string[i] & 0xf]);
+        }
+
+        return buf.toString();
+    }
+
+    public String toString()
+    {
+        return getString();
+    }
+
+    static DERBitString fromOctetString(byte[] bytes)
+    {
+        if (bytes.length < 1)
+        {
+            throw new IllegalArgumentException("truncated BIT STRING detected");
+        }
+
+        int padBits = bytes[0];
+        byte[] data = new byte[bytes.length - 1];
+
+        if (data.length != 0)
+        {
+            System.arraycopy(bytes, 1, data, 0, bytes.length - 1);
+        }
+
+        return new DERBitString(data, padBits);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERBoolean.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERBoolean.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERBoolean.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERBoolean.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERBoolean.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,117 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERBoolean
+    extends ASN1Object
+{
+    byte         value;
+
+    public static final DERBoolean FALSE = new DERBoolean(false);
+    public static final DERBoolean TRUE  = new DERBoolean(true);
+
+    /**
+     * return a boolean from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERBoolean getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERBoolean)
+        {
+            return (DERBoolean)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return a DERBoolean from the passed in boolean.
+     */
+    public static DERBoolean getInstance(
+        boolean  value)
+    {
+        return (value ? TRUE : FALSE);
+    }
+
+    /**
+     * return a Boolean from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERBoolean getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERBoolean)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERBoolean(((ASN1OctetString)o).getOctets());
+        }
+    }
+    
+    public DERBoolean(
+        byte[]       value)
+    {
+        if (value.length != 1)
+        {
+            throw new IllegalArgumentException("byte value should have 1 byte in it");
+        }
+        
+        this.value = value[0];
+    }
+
+    public DERBoolean(
+        boolean     value)
+    {
+        this.value = (value) ? (byte)0xff : (byte)0;
+    }
+
+    public boolean isTrue()
+    {
+        return (value != 0);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        byte[]  bytes = new byte[1];
+
+        bytes[0] = value;
+
+        out.writeEncoded(BOOLEAN, bytes);
+    }
+    
+    protected boolean asn1Equals(
+        DERObject  o)
+    {
+        if ((o == null) || !(o instanceof DERBoolean))
+        {
+            return false;
+        }
+
+        return (value == ((DERBoolean)o).value);
+    }
+    
+    public int hashCode()
+    {
+        return value;
+    }
+
+
+    public String toString()
+    {
+      return (value != 0) ? "TRUE" : "FALSE";
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEREncodable.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEREncodable.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEREncodable.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEREncodable.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEREncodable.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,6 @@
+package org.bouncycastle.asn1;
+
+public interface DEREncodable
+{
+    public DERObject getDERObject();
+}

Added: trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEREncodableVector.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEREncodableVector.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEREncodableVector.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.util.Vector;
+
+/**
+ * a general class for building up a vector of DER encodable objects -
+ * this will eventually be superceded by ASN1EncodableVector so you should
+ * use that class in preference.
+ */
+public class DEREncodableVector
+{
+    Vector v = new Vector();
+
+    /**
+     * @deprecated use ASN1EncodableVector instead.
+     */
+    public DEREncodableVector()
+    {
+
+    }
+
+    public void add(
+        DEREncodable   obj)
+    {
+        v.addElement(obj);
+    }
+
+    public DEREncodable get(
+        int i)
+    {
+        return (DEREncodable)v.elementAt(i);
+    }
+
+    public int size()
+    {
+        return v.size();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEREnumerated.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEREnumerated.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEREnumerated.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEREnumerated.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEREnumerated.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,101 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.util.Arrays;
+
+public class DEREnumerated
+    extends ASN1Object
+{
+    byte[]      bytes;
+
+    /**
+     * return an integer from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DEREnumerated getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DEREnumerated)
+        {
+            return (DEREnumerated)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return an Enumerated from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DEREnumerated getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DEREnumerated)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DEREnumerated(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    public DEREnumerated(
+        int         value)
+    {
+        bytes = BigInteger.valueOf(value).toByteArray();
+    }
+
+    public DEREnumerated(
+        BigInteger   value)
+    {
+        bytes = value.toByteArray();
+    }
+
+    public DEREnumerated(
+        byte[]   bytes)
+    {
+        this.bytes = bytes;
+    }
+
+    public BigInteger getValue()
+    {
+        return new BigInteger(bytes);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(ENUMERATED, bytes);
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DEREnumerated))
+        {
+            return false;
+        }
+
+        DEREnumerated other = (DEREnumerated)o;
+
+        return Arrays.areEqual(this.bytes, other.bytes);
+    }
+
+    public int hashCode()
+    {
+        return Arrays.hashCode(bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERExternal.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERExternal.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERExternal.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERExternal.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERExternal.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,283 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+/**
+ * Class representing the DER-type External
+ */
+public class DERExternal
+    extends ASN1Object
+{
+    private DERObjectIdentifier directReference;
+    private DERInteger indirectReference;
+    private ASN1Object dataValueDescriptor;
+    private int encoding;
+    private DERObject externalContent;
+
+    public DERExternal(ASN1EncodableVector vector)
+    {
+        int offset = 0;
+
+        DERObject enc = getObjFromVector(vector, offset);
+        if (enc instanceof DERObjectIdentifier)
+        {
+            directReference = (DERObjectIdentifier)enc;
+            offset++;
+            enc = getObjFromVector(vector, offset);
+        }
+        if (enc instanceof DERInteger)
+        {
+            indirectReference = (DERInteger) enc;
+            offset++;
+            enc = getObjFromVector(vector, offset);
+        }
+        if (!(enc instanceof DERTaggedObject))
+        {
+            dataValueDescriptor = (ASN1Object) enc;
+            offset++;
+            enc = getObjFromVector(vector, offset);
+        }
+
+        if (vector.size() != offset + 1)
+        {
+            throw new IllegalArgumentException("input vector too large");
+        }
+
+        if (!(enc instanceof DERTaggedObject))
+        {
+            throw new IllegalArgumentException("No tagged object found in vector. Structure doesn't seem to be of type External");
+        }
+        DERTaggedObject obj = (DERTaggedObject)enc;
+        setEncoding(obj.getTagNo());
+        externalContent = obj.getObject();
+    }
+
+    private DERObject getObjFromVector(ASN1EncodableVector v, int index)
+    {
+        if (v.size() <= index)
+        {
+            throw new IllegalArgumentException("too few objects in input vector");
+        }
+
+        return v.get(index).getDERObject();
+    }
+    /**
+     * Creates a new instance of DERExternal
+     * See X.690 for more informations about the meaning of these parameters
+     * @param directReference The direct reference or <code>null</code> if not set.
+     * @param indirectReference The indirect reference or <code>null</code> if not set.
+     * @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
+     * @param externalData The external data in its encoded form.
+     */
+    public DERExternal(DERObjectIdentifier directReference, DERInteger indirectReference, ASN1Object dataValueDescriptor, DERTaggedObject externalData)
+    {
+        this(directReference, indirectReference, dataValueDescriptor, externalData.getTagNo(), externalData.getDERObject());
+    }
+
+    /**
+     * Creates a new instance of DERExternal.
+     * See X.690 for more informations about the meaning of these parameters
+     * @param directReference The direct reference or <code>null</code> if not set.
+     * @param indirectReference The indirect reference or <code>null</code> if not set.
+     * @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
+     * @param encoding The encoding to be used for the external data
+     * @param externalData The external data
+     */
+    public DERExternal(DERObjectIdentifier directReference, DERInteger indirectReference, ASN1Object dataValueDescriptor, int encoding, DERObject externalData)
+    {
+        setDirectReference(directReference);
+        setIndirectReference(indirectReference);
+        setDataValueDescriptor(dataValueDescriptor);
+        setEncoding(encoding);
+        setExternalContent(externalData.getDERObject());
+    }
+
+    /* (non-Javadoc)
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode()
+    {
+        int ret = 0;
+        if (directReference != null)
+        {
+            ret = directReference.hashCode();
+        }
+        if (indirectReference != null)
+        {
+            ret ^= indirectReference.hashCode();
+        }
+        if (dataValueDescriptor != null)
+        {
+            ret ^= dataValueDescriptor.hashCode();
+        }
+        ret ^= externalContent.hashCode();
+        return ret;
+    }
+
+    /* (non-Javadoc)
+     * @see org.bouncycastle.asn1.DERObject#encode(org.bouncycastle.asn1.DEROutputStream)
+     */
+    void encode(DEROutputStream out)
+        throws IOException
+    {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        if (directReference != null)
+        {
+            baos.write(directReference.getDEREncoded());
+        }
+        if (indirectReference != null)
+        {
+            baos.write(indirectReference.getDEREncoded());
+        }
+        if (dataValueDescriptor != null)
+        {
+            baos.write(dataValueDescriptor.getDEREncoded());
+        }
+        DERTaggedObject obj = new DERTaggedObject(encoding, externalContent);
+        baos.write(obj.getDEREncoded());
+        out.writeEncoded(DERTags.CONSTRUCTED, DERTags.EXTERNAL, baos.toByteArray());
+    }
+
+    /* (non-Javadoc)
+     * @see org.bouncycastle.asn1.ASN1Object#asn1Equals(org.bouncycastle.asn1.DERObject)
+     */
+    boolean asn1Equals(DERObject o)
+    {
+        if (!(o instanceof DERExternal))
+        {
+            return false;
+        }
+        if (this == o)
+        {
+            return true;
+        }
+        DERExternal other = (DERExternal)o;
+        if (directReference != null)
+        {
+            if (other.directReference == null || !other.directReference.equals(directReference))
+            {
+                return false;
+            }
+        }
+        if (indirectReference != null)
+        {
+            if (other.indirectReference == null || !other.indirectReference.equals(indirectReference))
+            {
+                return false;
+            }
+        }
+        if (dataValueDescriptor != null)
+        {
+            if (other.dataValueDescriptor == null || !other.dataValueDescriptor.equals(dataValueDescriptor))
+            {
+                return false;
+            }
+        }
+        return externalContent.equals(other.externalContent);
+    }
+
+    /**
+     * Returns the data value descriptor
+     * @return The descriptor
+     */
+    public ASN1Object getDataValueDescriptor()
+    {
+        return dataValueDescriptor;
+    }
+
+    /**
+     * Returns the direct reference of the external element
+     * @return The reference
+     */
+    public DERObjectIdentifier getDirectReference()
+    {
+        return directReference;
+    }
+
+    /**
+     * Returns the encoding of the content. Valid values are
+     * <ul>
+     * <li><code>0</code> single-ASN1-type</li>
+     * <li><code>1</code> OCTET STRING</li>
+     * <li><code>2</code> BIT STRING</li>
+     * </ul>
+     * @return The encoding
+     */
+    public int getEncoding()
+    {
+        return encoding;
+    }
+
+    /**
+     * Returns the content of this element
+     * @return The content
+     */
+    public DERObject getExternalContent()
+    {
+        return externalContent;
+    }
+
+    /**
+     * Returns the indirect reference of this element
+     * @return The reference
+     */
+    public DERInteger getIndirectReference()
+    {
+        return indirectReference;
+    }
+
+    /**
+     * Sets the data value descriptor
+     * @param dataValueDescriptor The descriptor
+     */
+    private void setDataValueDescriptor(ASN1Object dataValueDescriptor)
+    {
+        this.dataValueDescriptor = dataValueDescriptor;
+    }
+
+    /**
+     * Sets the direct reference of the external element
+     * @param directReferemce The reference
+     */
+    private void setDirectReference(DERObjectIdentifier directReferemce)
+    {
+        this.directReference = directReferemce;
+    }
+
+    /**
+     * Sets the encoding of the content. Valid values are
+     * <ul>
+     * <li><code>0</code> single-ASN1-type</li>
+     * <li><code>1</code> OCTET STRING</li>
+     * <li><code>2</code> BIT STRING</li>
+     * </ul>
+     * @param encoding The encoding
+     */
+    private void setEncoding(int encoding)
+    {
+        if (encoding < 0 || encoding > 2)
+        {
+            throw new IllegalArgumentException("invalid encoding value: " + encoding);
+        }
+        this.encoding = encoding;
+    }
+
+    /**
+     * Sets the content of this element
+     * @param externalContent The content
+     */
+    private void setExternalContent(DERObject externalContent)
+    {
+        this.externalContent = externalContent;
+    }
+
+    /**
+     * Sets the indirect reference of this element
+     * @param indirectReference The reference
+     */
+    private void setIndirectReference(DERInteger indirectReference)
+    {
+        this.indirectReference = indirectReference;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERExternalParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERExternalParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERExternalParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERExternalParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERExternalParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,52 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERExternalParser
+    implements DEREncodable, InMemoryRepresentable
+{
+    private ASN1StreamParser _parser;
+
+    /**
+     * 
+     */
+    public DERExternalParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        try
+        {
+            return new DERExternal(_parser.readVector());
+        }
+        catch (IllegalArgumentException e)
+        {
+            throw new ASN1Exception(e.getMessage(), e);
+        }
+    }
+    
+    public DERObject getDERObject()
+    {
+        try 
+        {
+            return getLoadedObject();
+        }
+        catch (IOException ioe) 
+        {
+            throw new ASN1ParsingException("unable to get DER object", ioe);
+        }
+        catch (IllegalArgumentException ioe) 
+        {
+            throw new ASN1ParsingException("unable to get DER object", ioe);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERFactory.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+class DERFactory
+{
+    static final DERSequence EMPTY_SEQUENCE = new DERSequence();
+    static final DERSet EMPTY_SET = new DERSet();
+
+    static DERSequence createSequence(ASN1EncodableVector v)
+    {
+        return v.size() < 1 ? EMPTY_SEQUENCE : new DERSequence(v);
+    }
+
+    static DERSet createSet(ASN1EncodableVector v)
+    {
+        return v.size() < 1 ? EMPTY_SET : new DERSet(v);
+    }
+
+    static DERSet createSet(ASN1EncodableVector v, boolean needsSorting)
+    {
+        return v.size() < 1 ? EMPTY_SET : new DERSet(v, needsSorting);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERGeneralString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERGeneralString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERGeneralString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERGeneralString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERGeneralString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,94 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERGeneralString 
+    extends ASN1Object implements DERString
+{
+    private String string;
+
+    public static DERGeneralString getInstance(
+        Object obj) 
+    {
+        if (obj == null || obj instanceof DERGeneralString) 
+        {
+            return (DERGeneralString) obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: "
+                + obj.getClass().getName());
+    }
+
+    public static DERGeneralString getInstance(
+        ASN1TaggedObject obj, 
+        boolean explicit) 
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERGeneralString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERGeneralString(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    public DERGeneralString(byte[] string) 
+    {
+        char[] cs = new char[string.length];
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] & 0xff);
+        }
+        this.string = new String(cs);
+    }
+
+    public DERGeneralString(String string) 
+    {
+        this.string = string;
+    }
+    
+    public String getString() 
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets() 
+    {
+        char[] cs = string.toCharArray();
+        byte[] bs = new byte[cs.length];
+        for (int i = 0; i != cs.length; i++) 
+        {
+            bs[i] = (byte) cs[i];
+        }
+        return bs;
+    }
+    
+    void encode(DEROutputStream out) 
+        throws IOException 
+    {
+        out.writeEncoded(GENERAL_STRING, this.getOctets());
+    }
+    
+    public int hashCode() 
+    {
+        return this.getString().hashCode();
+    }
+    
+    boolean asn1Equals(DERObject o)
+    {
+        if (!(o instanceof DERGeneralString)) 
+        {
+            return false;
+        }
+        DERGeneralString s = (DERGeneralString) o;
+        return this.getString().equals(s.getString());
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,338 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+// import java.text.ParseException;
+// import java.text.SimpleDateFormat;
+import ewe.sys.Date;
+// import java.util.SimpleTimeZone;
+// import java.util.TimeZone;
+
+/**
+ * Generalized time object.
+ */
+public class DERGeneralizedTime
+    extends ASN1Object
+{
+    String      time;
+
+    /**
+     * return a generalized time from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERGeneralizedTime getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERGeneralizedTime)
+        {
+            return (DERGeneralizedTime)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return a Generalized Time object from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERGeneralizedTime getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERGeneralizedTime)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERGeneralizedTime(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * The correct format for this is YYYYMMDDHHMMSS[.f]Z, or without the Z
+     * for local time, or Z+-HHMM on the end, for difference between local
+     * time and UTC time. The fractional second amount f must consist of at
+     * least one number with trailing zeroes removed.
+     *
+     * @param time the time string.
+     * @exception IllegalArgumentException if String is an illegal format.
+     */
+    public DERGeneralizedTime(
+        String  time)
+    {
+        this.time = time;
+        try
+        {
+            this.getDate();
+        }
+        catch (IllegalArgumentException e)
+        {
+            throw new IllegalArgumentException("invalid date string: " + e.getMessage());
+        }
+    }
+
+    /**
+     * base constructer from a java.util.date object
+     */
+  /*  public DERGeneralizedTime(
+        Date time)
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat("yyyyMMddHHmmss'Z'");
+
+        dateF.setTimeZone(new SimpleTimeZone(0,"Z"));
+
+        this.time = dateF.format(time);
+    }
+*/
+    DERGeneralizedTime(
+        byte[]  bytes)
+    {
+        //
+        // explicitly convert to characters
+        //
+        char[]  dateC = new char[bytes.length];
+
+        for (int i = 0; i != dateC.length; i++)
+        {
+            dateC[i] = (char)(bytes[i] & 0xff);
+        }
+
+        this.time = new String(dateC);
+    }
+
+    /**
+     * Return the time.
+     * @return The time string as it appeared in the encoded object.
+     */
+    public String getTimeString()
+    {
+        return time;
+    }
+
+    /**
+     * return the time - always in the form of
+     *  YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm).
+     * <p>
+     * Normally in a certificate we would expect "Z" rather than "GMT",
+     * however adding the "GMT" means we can just use:
+     * <pre>
+     *     dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
+     * </pre>
+     * To read in the time and get a date which is compatible with our local
+     * time zone.
+     */
+    public String getTime()
+    {
+        //
+        // standardise the format.
+        //
+        if (time.charAt(time.length() - 1) == 'Z')
+        {
+            return time.substring(0, time.length() - 1) + "GMT+00:00";
+        }
+        else
+        {
+            int signPos = time.length() - 5;
+            char sign = time.charAt(signPos);
+            if (sign == '-' || sign == '+')
+            {
+                return time.substring(0, signPos)
+                    + "GMT"
+                    + time.substring(signPos, signPos + 3)
+                    + ":"
+                    + time.substring(signPos + 3);
+            }
+            else
+            {
+                signPos = time.length() - 3;
+                sign = time.charAt(signPos);
+                if (sign == '-' || sign == '+')
+                {
+                    return time.substring(0, signPos)
+                        + "GMT"
+                        + time.substring(signPos)
+                        + ":00";
+                }
+            }
+        }
+        return time + calculateGMTOffset();
+    }
+
+    private String calculateGMTOffset()
+    {
+ //       String sign = "+";
+/*        TimeZone timeZone = TimeZone.getDefault();
+        int offset = timeZone.getRawOffset();
+        if (offset < 0)
+        {
+            sign = "-";
+            offset = -offset;
+        }
+        int hours = offset / (60 * 60 * 1000);
+        int minutes = (offset - (hours * 60 * 60 * 1000)) / (60 * 1000);
+*/
+        /* commented out for ewe        try
+        {
+     if (timeZone.useDaylightTime() && timeZone.inDaylightTime(this.getDate()))
+            {
+                hours += sign.equals("+") ? 1 : -1;
+            }
+        }
+        catch (ParseException e)
+        {
+            // we'll do our best and ignore daylight savings
+        }
+        */
+        return "GMT" + "+00:00"; // commented out for ewe + sign + convert(hours) + ":" + convert(minutes);
+    }
+
+    private String convert(int time)
+    {
+        if (time < 10)
+        {
+            return "0" + time;
+        }
+
+        return Integer.toString(time);
+    }
+
+    public Date getDate()
+        throws IllegalArgumentException
+    {
+  //      SimpleDateFormat dateF;
+        String dateFewe;
+        String d = time;
+
+        if (time.endsWith("Z"))
+        {
+            if (hasFractionalSeconds())
+            {
+                dateFewe = "yyyyMMddHHmmss.SSS'Z'";
+            	// dateF = new SimpleDateFormat("yyyyMMddHHmmss.SSS'Z'");
+            }
+            else
+            {
+            	dateFewe = "yyyyMMddHHmmss'Z'";
+                //dateF = new SimpleDateFormat("yyyyMMddHHmmss'Z'");
+            }
+
+       // TODO commented out for ewe   dateF.setTimeZone(new SimpleTimeZone(0, "Z"));
+        }
+        else if (time.indexOf('-') > 0 || time.indexOf('+') > 0)
+        {
+            d = this.getTime();
+            if (hasFractionalSeconds())
+            {
+            	dateFewe = "yyyyMMddHHmmss.SSSz";
+                // dateF = new SimpleDateFormat("yyyyMMddHHmmss.SSSz");
+            }
+            else
+            {
+            	dateFewe = "yyyyMMddHHmmssz";
+                // dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
+            }
+
+//          TODO commented out for ewe    dateF.setTimeZone(new SimpleTimeZone(0, "Z"));
+        }
+        else
+        {
+            if (hasFractionalSeconds())
+            {
+            	dateFewe = "yyyyMMddHHmmss.SSS";
+                // dateF = new SimpleDateFormat("yyyyMMddHHmmss.SSS");
+            }
+            else
+            {
+            	dateFewe = "yyyyMMddHHmmss";
+                // dateF = new SimpleDateFormat("yyyyMMddHHmmss");
+            }
+
+//          TODO commented out for ewe     dateF.setTimeZone(new SimpleTimeZone(0, TimeZone.getDefault().getID()));
+        }
+
+        if (hasFractionalSeconds())
+        {
+            // java misinterprets extra digits as being milliseconds...
+            String frac = d.substring(14);
+            int    index;
+            for (index = 1; index < frac.length(); index++)
+            {
+                char ch = frac.charAt(index);
+                if (!('0' <= ch && ch <= '9'))
+                {
+                    break;
+                }
+            }
+
+            if (index - 1 > 3)
+            {
+                frac = frac.substring(0, 4) + frac.substring(index);
+                d = d.substring(0, 14) + frac;
+            }
+            else if (index - 1 == 1)
+            {
+                frac = frac.substring(0, index) + "00" + frac.substring(index);
+                d = d.substring(0, 14) + frac;
+            }
+            else if (index - 1 == 2)
+            {
+                frac = frac.substring(0, index) + "0" + frac.substring(index);
+                d = d.substring(0, 14) + frac;
+            }
+        }
+
+        Date ret = new Date();
+        ret.parse(d, dateFewe);
+        return ret; // dateF.parse(d);
+    }
+
+    private boolean hasFractionalSeconds()
+    {
+        return time.indexOf('.') == 14;
+    }
+
+    private byte[] getOctets()
+    {
+        char[]  cs = time.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs;
+    }
+
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(GENERALIZED_TIME, this.getOctets());
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERGeneralizedTime))
+        {
+            return false;
+        }
+
+        return time.equals(((DERGeneralizedTime)o).time);
+    }
+
+    public int hashCode()
+    {
+        return time.hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERIA5String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERIA5String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERIA5String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERIA5String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERIA5String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,173 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER IA5String object - this is an ascii string.
+ */
+public class DERIA5String
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a IA5 string from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERIA5String getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERIA5String)
+        {
+            return (DERIA5String)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return an IA5 String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERIA5String getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERIA5String)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERIA5String(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - with bytes.
+     */
+    public DERIA5String(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] & 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor - without validation.
+     */
+    public DERIA5String(
+        String   string)
+    {
+        this(string, false);
+    }
+
+    /**
+     * Constructor with optional validation.
+     *
+     * @param string the base string to wrap.
+     * @param validate whether or not to check the string.
+     * @throws IllegalArgumentException if validate is true and the string
+     * contains characters that should not be in an IA5String.
+     */
+    public DERIA5String(
+        String   string,
+        boolean  validate)
+    {
+        if (string == null)
+        {
+            throw new NullPointerException("string cannot be null");
+        }
+        if (validate && !isIA5String(string))
+        {
+            throw new IllegalArgumentException("string contains illegal characters");
+        }
+
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(IA5_STRING, this.getOctets());
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERIA5String))
+        {
+            return false;
+        }
+
+        DERIA5String  s = (DERIA5String)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    /**
+     * return true if the passed in String can be represented without
+     * loss as an IA5String, false otherwise.
+     *
+     * @return true if in printable set, false otherwise.
+     */
+    public static boolean isIA5String(
+        String  str)
+    {
+        for (int i = str.length() - 1; i >= 0; i--)
+        {
+            char    ch = str.charAt(i);
+
+            if (ch > 0x007f)
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERInteger.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERInteger.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERInteger.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERInteger.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERInteger.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,122 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.util.Arrays;
+
+public class DERInteger
+    extends ASN1Object
+{
+    byte[]      bytes;
+
+    /**
+     * return an integer from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERInteger getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERInteger)
+        {
+            return (DERInteger)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return an Integer from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERInteger getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERInteger)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new ASN1Integer(ASN1OctetString.getInstance(obj.getObject()).getOctets());
+        }
+    }
+
+    public DERInteger(
+        int         value)
+    {
+        bytes = BigInteger.valueOf(value).toByteArray();
+    }
+
+    public DERInteger(
+        BigInteger   value)
+    {
+        bytes = value.toByteArray();
+    }
+
+    public DERInteger(
+        byte[]   bytes)
+    {
+        this.bytes = bytes;
+    }
+
+    public BigInteger getValue()
+    {
+        return new BigInteger(bytes);
+    }
+
+    /**
+     * in some cases positive values get crammed into a space,
+     * that's not quite big enough...
+     */
+    public BigInteger getPositiveValue()
+    {
+        return new BigInteger(1, bytes);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(INTEGER, bytes);
+    }
+    
+    public int hashCode()
+    {
+         int     value = 0;
+ 
+         for (int i = 0; i != bytes.length; i++)
+         {
+             value ^= (bytes[i] & 0xff) << (i % 4);
+         }
+ 
+         return value;
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERInteger))
+        {
+            return false;
+        }
+
+        DERInteger other = (DERInteger)o;
+
+        return Arrays.areEqual(bytes, other.bytes);
+    }
+
+    public String toString()
+    {
+      return getValue().toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERNull.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERNull.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERNull.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERNull.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERNull.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * A NULL object.
+ */
+public class DERNull
+    extends ASN1Null
+{
+    public static final DERNull INSTANCE = new DERNull();
+
+    byte[]  zeroBytes = new byte[0];
+
+    public DERNull()
+    {
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(NULL, zeroBytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERNumericString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERNumericString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERNumericString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERNumericString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERNumericString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,176 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
+ */
+public class DERNumericString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a Numeric string from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERNumericString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERNumericString)
+        {
+            return (DERNumericString)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return an Numeric String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERNumericString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERNumericString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERNumericString(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - with bytes.
+     */
+    public DERNumericString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] & 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor -  without validation..
+     */
+    public DERNumericString(
+        String   string)
+    {
+        this(string, false);
+    }
+
+    /**
+     * Constructor with optional validation.
+     *
+     * @param string the base string to wrap.
+     * @param validate whether or not to check the string.
+     * @throws IllegalArgumentException if validate is true and the string
+     * contains characters that should not be in a NumericString.
+     */
+    public DERNumericString(
+        String   string,
+        boolean  validate)
+    {
+        if (validate && !isNumericString(string))
+        {
+            throw new IllegalArgumentException("string contains illegal characters");
+        }
+
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(NUMERIC_STRING, this.getOctets());
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERNumericString))
+        {
+            return false;
+        }
+
+        DERNumericString  s = (DERNumericString)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    /**
+     * Return true if the string can be represented as a NumericString ('0'..'9', ' ')
+     *
+     * @param str string to validate.
+     * @return true if numeric, fale otherwise.
+     */
+    public static boolean isNumericString(
+        String  str)
+    {
+        for (int i = str.length() - 1; i >= 0; i--)
+        {
+            char    ch = str.charAt(i);
+
+            if (ch > 0x007f)
+            {
+                return false;
+            }
+
+            if (('0' <= ch && ch <= '9') || ch == ' ')
+            {
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,20 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public abstract class DERObject
+    extends ASN1Encodable
+    implements DERTags
+{
+    public DERObject toASN1Object()
+    {
+        return this;
+    }
+
+    public abstract int hashCode();
+
+    public abstract boolean equals(Object o);
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,268 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+import ewe.math.BigInteger;
+
+public class DERObjectIdentifier
+    extends ASN1Object
+{
+    String      identifier;
+
+    /**
+     * return an OID from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERObjectIdentifier getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERObjectIdentifier)
+        {
+            return (DERObjectIdentifier)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return an Object Identifier from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERObjectIdentifier getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERObjectIdentifier)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new ASN1ObjectIdentifier(ASN1OctetString.getInstance(obj.getObject()).getOctets());
+        }
+    }
+    
+
+    DERObjectIdentifier(
+        byte[]  bytes)
+    {
+        StringBuffer    objId = new StringBuffer();
+        long            value = 0;
+        BigInteger      bigValue = null;
+        boolean         first = true;
+
+        for (int i = 0; i != bytes.length; i++)
+        {
+            int b = bytes[i] & 0xff;
+
+            if (value < 0x80000000000000L) 
+            {
+                value = value * 128 + (b & 0x7f);
+                if ((b & 0x80) == 0)             // end of number reached
+                {
+                    if (first)
+                    {
+                        switch ((int)value / 40)
+                        {
+                        case 0:
+                            objId.append('0');
+                            break;
+                        case 1:
+                            objId.append('1');
+                            value -= 40;
+                            break;
+                        default:
+                            objId.append('2');
+                            value -= 80;
+                        }
+                        first = false;
+                    }
+
+                    objId.append('.');
+                    objId.append(value);
+                    value = 0;
+                }
+            } 
+            else 
+            {
+                if (bigValue == null)
+                {
+                    bigValue = BigInteger.valueOf(value);
+                }
+                bigValue = bigValue.shiftLeft(7);
+                bigValue = bigValue.or(BigInteger.valueOf(b & 0x7f));
+                if ((b & 0x80) == 0) 
+                {
+                    objId.append('.');
+                    objId.append(bigValue);
+                    bigValue = null;
+                    value = 0;
+                }
+            }
+        }
+
+        this.identifier = objId.toString();
+    }
+
+    public DERObjectIdentifier(
+        String  identifier)
+    {
+        if (!isValidIdentifier(identifier))
+        {
+            throw new IllegalArgumentException("string " + identifier + " not an OID");
+        }
+
+        this.identifier = identifier;
+    }
+
+    public String getId()
+    {
+        return identifier;
+    }
+
+    private void writeField(
+        OutputStream    out,
+        long            fieldValue)
+        throws IOException
+    {
+        byte[] result = new byte[9];
+        int pos = 8;
+        result[pos] = (byte)((int)fieldValue & 0x7f);
+        while (fieldValue >= (1L << 7))
+        {
+            fieldValue >>= 7;
+            result[--pos] = (byte)((int)fieldValue & 0x7f | 0x80);
+        }
+        out.write(result, pos, 9 - pos);
+    }
+
+    private void writeField(
+        OutputStream    out,
+        BigInteger      fieldValue)
+        throws IOException
+    {
+        int byteCount = (fieldValue.bitLength()+6)/7;
+        if (byteCount == 0) 
+        {
+            out.write(0);
+        }  
+        else 
+        {
+            BigInteger tmpValue = fieldValue;
+            byte[] tmp = new byte[byteCount];
+            for (int i = byteCount-1; i >= 0; i--) 
+            {
+                tmp[i] = (byte) ((tmpValue.intValue() & 0x7f) | 0x80);
+                tmpValue = tmpValue.shiftRight(7); 
+            }
+            tmp[byteCount-1] &= 0x7f;
+            out.write(tmp);
+        }
+
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        OIDTokenizer            tok = new OIDTokenizer(identifier);
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        DEROutputStream         dOut = new DEROutputStream(bOut);
+
+        writeField(bOut, 
+                    Integer.parseInt(tok.nextToken()) * 40
+                    + Integer.parseInt(tok.nextToken()));
+
+        while (tok.hasMoreTokens())
+        {
+            String token = tok.nextToken();
+            if (token.length() < 18) 
+            {
+                writeField(bOut, Long.parseLong(token));
+            }
+            else
+            {
+                writeField(bOut, new BigInteger(token));
+            }
+        }
+
+        dOut.close();
+
+        byte[]  bytes = bOut.toByteArray();
+
+        out.writeEncoded(OBJECT_IDENTIFIER, bytes);
+    }
+
+    public int hashCode()
+    {
+        return identifier.hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERObjectIdentifier))
+        {
+            return false;
+        }
+
+        return identifier.equals(((DERObjectIdentifier)o).identifier);
+    }
+
+    public String toString()
+    {
+        return getId();
+    }
+
+    private static boolean isValidIdentifier(
+        String identifier)
+    {
+        if (identifier.length() < 3
+            || identifier.charAt(1) != '.')
+        {
+            return false;
+        }
+
+        char first = identifier.charAt(0);
+        if (first < '0' || first > '2')
+        {
+            return false;
+        }
+
+        boolean periodAllowed = false;
+        for (int i = identifier.length() - 1; i >= 2; i--)
+        {
+            char ch = identifier.charAt(i);
+
+            if ('0' <= ch && ch <= '9')
+            {
+                periodAllowed = true;
+                continue;
+            }
+
+            if (ch == '.')
+            {
+                if (!periodAllowed)
+                {
+                    return false;
+                }
+
+                periodAllowed = false;
+                continue;
+            }
+
+            return false;
+        }
+
+        return periodAllowed;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEROctetString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEROctetString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEROctetString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEROctetString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEROctetString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DEROctetString
+    extends ASN1OctetString
+{
+    /**
+     * @param string the octets making up the octet string.
+     */
+    public DEROctetString(
+        byte[]  string)
+    {
+        super(string);
+    }
+
+    public DEROctetString(
+        DEREncodable  obj)
+    {
+        super(obj);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(OCTET_STRING, string);
+    }
+
+    static void encode(
+        DEROutputStream derOut,
+        byte[]          bytes)
+        throws IOException
+    {
+        derOut.writeEncoded(DERTags.OCTET_STRING, bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+public class DEROctetStringParser
+    implements ASN1OctetStringParser
+{
+    private DefiniteLengthInputStream stream;
+
+    DEROctetStringParser(
+        DefiniteLengthInputStream stream)
+    {
+        this.stream = stream;
+    }
+
+    public InputStream getOctetStream()
+    {
+        return stream;
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new DEROctetString(stream.toByteArray());
+    }
+    
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException("IOException converting stream to byte array: " + e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEROutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEROutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEROutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEROutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEROutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,134 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.FilterOutputStream;
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class DEROutputStream
+    extends FilterOutputStream implements DERTags
+{
+    public DEROutputStream(
+        OutputStream    os)
+    {
+        super(os);
+    }
+
+    private void writeLength(
+        int length)
+        throws IOException
+    {
+        if (length > 127)
+        {
+            int size = 1;
+            int val = length;
+
+            while ((val >>>= 8) != 0)
+            {
+                size++;
+            }
+
+            write((byte)(size | 0x80));
+
+            for (int i = (size - 1) * 8; i >= 0; i -= 8)
+            {
+                write((byte)(length >> i));
+            }
+        }
+        else
+        {
+            write((byte)length);
+        }
+    }
+
+    void writeEncoded(
+        int     tag,
+        byte[]  bytes)
+        throws IOException
+    {
+        write(tag);
+        writeLength(bytes.length);
+        write(bytes);
+    }
+
+    void writeTag(int flags, int tagNo)
+        throws IOException
+    {
+        if (tagNo < 31)
+        {
+            write(flags | tagNo);
+        }
+        else
+        {
+            write(flags | 0x1f);
+            if (tagNo < 128)
+            {
+                write(tagNo);
+            }
+            else
+            {
+                byte[] stack = new byte[5];
+                int pos = stack.length;
+
+                stack[--pos] = (byte)(tagNo & 0x7F);
+
+                do
+                {
+                    tagNo >>= 7;
+                    stack[--pos] = (byte)(tagNo & 0x7F | 0x80);
+                }
+                while (tagNo > 127);
+
+                write(stack, pos, stack.length - pos);
+            }
+        }
+    }
+
+    void writeEncoded(int flags, int tagNo, byte[] bytes)
+        throws IOException
+    {
+        writeTag(flags, tagNo);
+        writeLength(bytes.length);
+        write(bytes);
+    }
+
+    protected void writeNull()
+        throws IOException
+    {
+        write(NULL);
+        write(0x00);
+    }
+
+    public void write(byte[] buf)
+        throws IOException
+    {
+        out.write(buf, 0, buf.length);
+    }
+
+    public void write(byte[] buf, int offSet, int len)
+        throws IOException
+    {
+        out.write(buf, offSet, len);
+    }
+
+    public void writeObject(
+        Object    obj)
+        throws IOException
+    {
+        if (obj == null)
+        {
+            writeNull();
+        }
+        else if (obj instanceof DERObject)
+        {
+            ((DERObject)obj).encode(this);
+        }
+        else if (obj instanceof DEREncodable)
+        {
+            ((DEREncodable)obj).getDERObject().encode(this);
+        }
+        else
+        {
+            throw new IOException("object not DEREncodable");
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERPrintableString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERPrintableString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERPrintableString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERPrintableString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERPrintableString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,203 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER PrintableString object.
+ */
+public class DERPrintableString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a printable string from the passed in object.
+     * 
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERPrintableString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERPrintableString)
+        {
+            return (DERPrintableString)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return a Printable String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERPrintableString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERPrintableString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERPrintableString(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERPrintableString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] & 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor - this does not validate the string
+     */
+    public DERPrintableString(
+        String   string)
+    {
+        this(string, false);
+    }
+
+    /**
+     * Constructor with optional validation.
+     *
+     * @param string the base string to wrap.
+     * @param validate whether or not to check the string.
+     * @throws IllegalArgumentException if validate is true and the string
+     * contains characters that should not be in a PrintableString.
+     */
+    public DERPrintableString(
+        String   string,
+        boolean  validate)
+    {
+        if (validate && !isPrintableString(string))
+        {
+            throw new IllegalArgumentException("string contains illegal characters");
+        }
+
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(PRINTABLE_STRING, this.getOctets());
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERPrintableString))
+        {
+            return false;
+        }
+
+        DERPrintableString  s = (DERPrintableString)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    /**
+     * return true if the passed in String can be represented without
+     * loss as a PrintableString, false otherwise.
+     *
+     * @return true if in printable set, false otherwise.
+     */
+    public static boolean isPrintableString(
+        String  str)
+    {
+        for (int i = str.length() - 1; i >= 0; i--)
+        {
+            char    ch = str.charAt(i);
+
+            if (ch > 0x007f)
+            {
+                return false;
+            }
+
+            if ('a' <= ch && ch <= 'z')
+            {
+                continue;
+            }
+
+            if ('A' <= ch && ch <= 'Z')
+            {
+                continue;
+            }
+
+            if ('0' <= ch && ch <= '9')
+            {
+                continue;
+            }
+
+            switch (ch)
+            {
+            case ' ':
+            case '\'':
+            case '(':
+            case ')':
+            case '+':
+            case '-':
+            case '.':
+            case ':':
+            case '=':
+            case '?':
+            case '/':
+            case ',':
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,80 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class DERSequence
+    extends ASN1Sequence
+{
+    /**
+     * create an empty sequence
+     */
+    public DERSequence()
+    {
+    }
+
+    /**
+     * create a sequence containing one object
+     */
+    public DERSequence(
+        DEREncodable    obj)
+    {
+        this.addObject(obj);
+    }
+
+    /**
+     * create a sequence containing a vector of objects.
+     */
+    public DERSequence(
+        ASN1EncodableVector   v)
+    {
+        for (int i = 0; i != v.size(); i++)
+        {
+            this.addObject(v.get(i));
+        }
+    }
+
+    /**
+     * create a sequence containing an array of objects.
+     */
+    public DERSequence(
+        ASN1Encodable[]   a)
+    {
+        for (int i = 0; i != a.length; i++)
+        {
+            this.addObject(a[i]);
+        }
+    }
+    
+    /*
+     * A note on the implementation:
+     * <p>
+     * As DER requires the constructed, definite-length model to
+     * be used for structured types, this varies slightly from the
+     * ASN.1 descriptions given. Rather than just outputing SEQUENCE,
+     * we also have to specify CONSTRUCTED, and the objects length.
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        // TODO Intermediate buffer could be avoided if we could calculate expected length
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        DEROutputStream         dOut = new DEROutputStream(bOut);
+        Enumeration             e = this.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            Object    obj = e.nextElement();
+
+            dOut.writeObject(obj);
+        }
+
+        dOut.close();
+
+        byte[]  bytes = bOut.toByteArray();
+
+        out.writeEncoded(SEQUENCE | CONSTRUCTED, bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSequenceParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSequenceParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSequenceParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERSequenceParser
+    implements ASN1SequenceParser
+{
+    private ASN1StreamParser _parser;
+
+    DERSequenceParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+         return new DERSequence(_parser.readVector());
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException(e.getMessage());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSet.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSet.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSet.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSet.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSet.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,100 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+/**
+ * A DER encoded set object
+ */
+public class DERSet
+    extends ASN1Set
+{
+    /**
+     * create an empty set
+     */
+    public DERSet()
+    {
+    }
+
+    /**
+     * @param obj - a single object that makes up the set.
+     */
+    public DERSet(
+        DEREncodable   obj)
+    {
+        this.addObject(obj);
+    }
+
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    public DERSet(
+        ASN1EncodableVector   v)
+    {
+        this(v, true);
+    }
+    
+    /**
+     * create a set from an array of objects.
+     */
+    public DERSet(
+        ASN1Encodable[]   a)
+    {
+        for (int i = 0; i != a.length; i++)
+        {
+            this.addObject(a[i]);
+        }
+        
+        this.sort();
+    }
+    
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    DERSet(
+        ASN1EncodableVector  v,
+        boolean              needsSorting)
+    {
+        for (int i = 0; i != v.size(); i++)
+        {
+            this.addObject(v.get(i));
+        }
+
+        if (needsSorting)
+        {
+            this.sort();
+        }
+    }
+
+    /*
+     * A note on the implementation:
+     * <p>
+     * As DER requires the constructed, definite-length model to
+     * be used for structured types, this varies slightly from the
+     * ASN.1 descriptions given. Rather than just outputing SET,
+     * we also have to specify CONSTRUCTED, and the objects length.
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        // TODO Intermediate buffer could be avoided if we could calculate expected length
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        DEROutputStream         dOut = new DEROutputStream(bOut);
+        Enumeration             e = this.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            Object    obj = e.nextElement();
+
+            dOut.writeObject(obj);
+        }
+
+        dOut.close();
+
+        byte[]  bytes = bOut.toByteArray();
+
+        out.writeEncoded(SET | CONSTRUCTED, bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSetParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSetParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSetParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSetParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSetParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERSetParser
+    implements ASN1SetParser
+{
+    private ASN1StreamParser _parser;
+
+    DERSetParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new DERSet(_parser.readVector(), false);
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+/**
+ * basic interface for DER string objects.
+ */
+public interface DERString
+    extends ASN1String
+{
+
+}

Added: trunk/src/org/bouncycastle/asn1/DERT61String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERT61String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERT61String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERT61String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERT61String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,125 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER T61String (also the teletex string)
+ */
+public class DERT61String
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a T61 string from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERT61String getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERT61String)
+        {
+            return (DERT61String)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return an T61 String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERT61String getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERT61String(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - with bytes.
+     */
+    public DERT61String(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] & 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor - with string.
+     */
+    public DERT61String(
+        String   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(T61_STRING, this.getOctets());
+    }
+    
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERT61String))
+        {
+            return false;
+        }
+
+        return this.getString().equals(((DERT61String)o).getString());
+    }
+    
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERTaggedObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERTaggedObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERTaggedObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,85 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER TaggedObject - in ASN.1 notation this is any object preceded by
+ * a [n] where n is some number - these are assumed to follow the construction
+ * rules (as with sequences).
+ */
+public class DERTaggedObject
+    extends ASN1TaggedObject
+{
+    private static final byte[] ZERO_BYTES = new byte[0];
+
+    /**
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public DERTaggedObject(
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(tagNo, obj);
+    }
+
+    /**
+     * @param explicit true if an explicitly tagged object.
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public DERTaggedObject(
+        boolean         explicit,
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(explicit, tagNo, obj);
+    }
+
+    /**
+     * create an implicitly tagged object that contains a zero
+     * length sequence.
+     */
+    public DERTaggedObject(
+        int             tagNo)
+    {
+        super(false, tagNo, new DERSequence());
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        if (!empty)
+        {
+            byte[] bytes = obj.getDERObject().getEncoded(DER);
+
+            if (explicit)
+            {
+                out.writeEncoded(CONSTRUCTED | TAGGED, tagNo, bytes);
+            }
+            else
+            {
+                //
+                // need to mark constructed types...
+                //
+                int flags;
+                if ((bytes[0] & CONSTRUCTED) != 0)
+                {
+                    flags = CONSTRUCTED | TAGGED;
+                }
+                else
+                {
+                    flags = TAGGED;
+                }
+
+                out.writeTag(flags, tagNo);
+                out.write(bytes, 1, bytes.length - 1);
+            }
+        }
+        else
+        {
+            out.writeEncoded(CONSTRUCTED | TAGGED, tagNo, ZERO_BYTES);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERTags.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERTags.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERTags.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERTags.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERTags.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.asn1;
+
+public interface DERTags
+{
+    public static final int BOOLEAN             = 0x01;
+    public static final int INTEGER             = 0x02;
+    public static final int BIT_STRING          = 0x03;
+    public static final int OCTET_STRING        = 0x04;
+    public static final int NULL                = 0x05;
+    public static final int OBJECT_IDENTIFIER   = 0x06;
+    public static final int EXTERNAL            = 0x08;
+    public static final int ENUMERATED          = 0x0a;
+    public static final int SEQUENCE            = 0x10;
+    public static final int SEQUENCE_OF         = 0x10; // for completeness
+    public static final int SET                 = 0x11;
+    public static final int SET_OF              = 0x11; // for completeness
+
+
+    public static final int NUMERIC_STRING      = 0x12;
+    public static final int PRINTABLE_STRING    = 0x13;
+    public static final int T61_STRING          = 0x14;
+    public static final int VIDEOTEX_STRING     = 0x15;
+    public static final int IA5_STRING          = 0x16;
+    public static final int UTC_TIME            = 0x17;
+    public static final int GENERALIZED_TIME    = 0x18;
+    public static final int GRAPHIC_STRING      = 0x19;
+    public static final int VISIBLE_STRING      = 0x1a;
+    public static final int GENERAL_STRING      = 0x1b;
+    public static final int UNIVERSAL_STRING    = 0x1c;
+    public static final int BMP_STRING          = 0x1e;
+    public static final int UTF8_STRING         = 0x0c;
+    
+    public static final int CONSTRUCTED         = 0x20;
+    public static final int APPLICATION         = 0x40;
+    public static final int TAGGED              = 0x80;
+}

Added: trunk/src/org/bouncycastle/asn1/DERUTCTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUTCTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUTCTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUTCTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUTCTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,258 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+// import java.text.ParseException;
+// import java.text.SimpleDateFormat;
+// import ewe.sys.Date;
+// import java.util.SimpleTimeZone;
+
+/**
+ * UTC time object.
+ */
+public class DERUTCTime
+    extends ASN1Object
+{
+    String      time;
+
+    /**
+     * return an UTC Time from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERUTCTime getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERUTCTime)
+        {
+            return (DERUTCTime)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return an UTC Time from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERUTCTime getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERUTCTime)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERUTCTime(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * The correct format for this is YYMMDDHHMMSSZ (it used to be that seconds were
+     * never encoded. When you're creating one of these objects from scratch, that's
+     * what you want to use, otherwise we'll try to deal with whatever gets read from
+     * the input stream... (this is why the input format is different from the getTime()
+     * method output).
+     * <p>
+     *
+     * @param time the time string.
+     */
+ /*   public DERUTCTime(
+        String  time)
+    {
+        this.time = time;
+        try
+        {
+            this.getDate();
+        }
+        catch (ParseException e)
+        {
+            throw new IllegalArgumentException("invalid date string: " + e.getMessage());
+        }
+    }
+*/
+    /**
+     * base constructer from a java.util.date object
+     */
+ /*   public DERUTCTime(
+        Date time)
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat("yyMMddHHmmss'Z'");
+
+        dateF.setTimeZone(new SimpleTimeZone(0,"Z"));
+
+        this.time = dateF.format(time);
+    }
+*/
+    DERUTCTime(
+        byte[]  bytes)
+    {
+        //
+        // explicitly convert to characters
+        //
+        char[]  dateC = new char[bytes.length];
+
+        for (int i = 0; i != dateC.length; i++)
+        {
+            dateC[i] = (char)(bytes[i] & 0xff);
+        }
+
+        this.time = new String(dateC);
+    }
+
+    /**
+     * return the time as a date based on whatever a 2 digit year will return. For
+     * standardised processing use getAdjustedDate().
+     *
+     * @return the resulting date
+     * @exception ParseException if the date string cannot be parsed.
+     */
+  /*  public Date getDate()
+        throws ParseException
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat("yyMMddHHmmssz");
+
+        return dateF.parse(getTime());
+    }
+*/
+    /**
+     * return the time as an adjusted date
+     * in the range of 1950 - 2049.
+     *
+     * @return a date in the range of 1950 to 2049.
+     * @exception ParseException if the date string cannot be parsed.
+     */
+  /*  public Date getAdjustedDate()
+        throws ParseException
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
+
+        dateF.setTimeZone(new SimpleTimeZone(0, "Z"));
+
+        return dateF.parse(getAdjustedTime());
+    }
+*/
+    /**
+     * return the time - always in the form of
+     *  YYMMDDhhmmssGMT(+hh:mm|-hh:mm).
+     * <p>
+     * Normally in a certificate we would expect "Z" rather than "GMT",
+     * however adding the "GMT" means we can just use:
+     * <pre>
+     *     dateF = new SimpleDateFormat("yyMMddHHmmssz");
+     * </pre>
+     * To read in the time and get a date which is compatible with our local
+     * time zone.
+     * <p>
+     * <b>Note:</b> In some cases, due to the local date processing, this
+     * may lead to unexpected results. If you want to stick the normal
+     * convention of 1950 to 2049 use the getAdjustedTime() method.
+     */
+    public String getTime()
+    {
+        //
+        // standardise the format.
+        //
+        if (time.indexOf('-') < 0 && time.indexOf('+') < 0)
+        {
+            if (time.length() == 11)
+            {
+                return time.substring(0, 10) + "00GMT+00:00";
+            }
+            else
+            {
+                return time.substring(0, 12) + "GMT+00:00";
+            }
+        }
+        else
+        {
+            int index = time.indexOf('-');
+            if (index < 0)
+            {
+                index = time.indexOf('+');
+            }
+            String d = time;
+
+            if (index == time.length() - 3)
+            {
+                d += "00";
+            }
+
+            if (index == 10)
+            {
+                return d.substring(0, 10) + "00GMT" + d.substring(10, 13) + ":" + d.substring(13, 15);
+            }
+            else
+            {
+                return d.substring(0, 12) + "GMT" + d.substring(12, 15) + ":" +  d.substring(15, 17);
+            }
+        }
+    }
+
+    /**
+     * return a time string as an adjusted date with a 4 digit year. This goes
+     * in the range of 1950 - 2049.
+     */
+    public String getAdjustedTime()
+    {
+        String   d = this.getTime();
+
+        if (d.charAt(0) < '5')
+        {
+            return "20" + d;
+        }
+        else
+        {
+            return "19" + d;
+        }
+    }
+
+    private byte[] getOctets()
+    {
+        char[]  cs = time.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(UTC_TIME, this.getOctets());
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERUTCTime))
+        {
+            return false;
+        }
+
+        return time.equals(((DERUTCTime)o).time);
+    }
+
+    public int hashCode()
+    {
+        return time.hashCode();
+    }
+
+    public String toString()
+    {
+      return time;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERUTF8String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUTF8String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUTF8String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUTF8String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUTF8String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,115 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Strings;
+
+/**
+ * DER UTF8String object.
+ */
+public class DERUTF8String
+    extends ASN1Object
+    implements DERString
+{
+    String string;
+
+    /**
+     * return an UTF8 string from the passed in object.
+     * 
+     * @exception IllegalArgumentException
+     *                if the object cannot be converted.
+     */
+    public static DERUTF8String getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DERUTF8String)
+        {
+            return (DERUTF8String)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: "
+                + obj.getClass().getName());
+    }
+
+    /**
+     * return an UTF8 String from a tagged object.
+     * 
+     * @param obj
+     *            the tagged object holding the object we want
+     * @param explicit
+     *            true if the object is meant to be explicitly tagged false
+     *            otherwise.
+     * @exception IllegalArgumentException
+     *                if the tagged object cannot be converted.
+     */
+    public static DERUTF8String getInstance(
+        ASN1TaggedObject obj,
+        boolean explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERUTF8String)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERUTF8String(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERUTF8String(byte[] string)
+    {
+        try
+        {
+            this.string = Strings.fromUTF8ByteArray(string);
+        }
+        catch (ArrayIndexOutOfBoundsException e)
+        {
+            throw new IllegalArgumentException("UTF8 encoding invalid");
+        }
+    }
+
+    /**
+     * basic constructor
+     */
+    public DERUTF8String(String string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(DERObject o)
+    {
+        if (!(o instanceof DERUTF8String))
+        {
+            return false;
+        }
+
+        DERUTF8String s = (DERUTF8String)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    void encode(DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(UTF8_STRING, Strings.toUTF8ByteArray(string));
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERUniversalString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUniversalString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUniversalString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUniversalString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUniversalString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,124 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+/**
+ * DER UniversalString object.
+ */
+public class DERUniversalString
+    extends ASN1Object
+    implements DERString
+{
+    private static final char[]  table = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+    private byte[] string;
+    
+    /**
+     * return a Universal String from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERUniversalString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERUniversalString)
+        {
+            return (DERUniversalString)obj;
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return a Universal String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERUniversalString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERUniversalString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERUniversalString(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERUniversalString(
+        byte[]   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        StringBuffer    buf = new StringBuffer("#");
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        ASN1OutputStream            aOut = new ASN1OutputStream(bOut);
+        
+        try
+        {
+            aOut.writeObject(this);
+        }
+        catch (IOException e)
+        {
+           throw new RuntimeException("internal error encoding BitString");
+        }
+        
+        byte[]    string = bOut.toByteArray();
+        
+        for (int i = 0; i != string.length; i++)
+        {
+            buf.append(table[(string[i] >>> 4) & 0xf]);
+            buf.append(table[string[i] & 0xf]);
+        }
+        
+        return buf.toString();
+    }
+
+    public String toString()
+    {
+        return getString();
+    }
+
+    public byte[] getOctets()
+    {
+        return string;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(UNIVERSAL_STRING, this.getOctets());
+    }
+    
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERUniversalString))
+        {
+            return false;
+        }
+
+        return this.getString().equals(((DERUniversalString)o).getString());
+    }
+    
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUnknownTag.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUnknownTag.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUnknownTag.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,79 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Arrays;
+
+/**
+ * We insert one of these when we find a tag we don't recognise.
+ */
+public class DERUnknownTag
+    extends DERObject
+{
+    private boolean   isConstructed;
+    private int       tag;
+    private byte[]    data;
+
+    /**
+     * @param tag the tag value.
+     * @param data the contents octets.
+     */
+    public DERUnknownTag(
+        int     tag,
+        byte[]  data)
+    {
+        this(false, tag, data);
+    }
+
+    public DERUnknownTag(
+        boolean isConstructed,
+        int     tag,
+        byte[]  data)
+    {
+        this.isConstructed = isConstructed;
+        this.tag = tag;
+        this.data = data;
+    }
+
+    public boolean isConstructed()
+    {
+        return isConstructed;
+    }
+
+    public int getTag()
+    {
+        return tag;
+    }
+
+    public byte[] getData()
+    {
+        return data;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(isConstructed ? DERTags.CONSTRUCTED : 0, tag, data);
+    }
+    
+    public boolean equals(
+        Object o)
+    {
+        if (!(o instanceof DERUnknownTag))
+        {
+            return false;
+        }
+        
+        DERUnknownTag other = (DERUnknownTag)o;
+
+        return isConstructed == other.isConstructed
+            && tag == other.tag
+            && Arrays.areEqual(data, other.data);
+    }
+    
+    public int hashCode()
+    {
+        return (isConstructed ? ~0 : 0) ^ tag ^ Arrays.hashCode(data);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERVisibleString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERVisibleString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERVisibleString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERVisibleString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERVisibleString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER VisibleString object.
+ */
+public class DERVisibleString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a Visible String from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERVisibleString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERVisibleString)
+        {
+            return (DERVisibleString)obj;
+        }
+
+        if (obj instanceof ASN1OctetString)
+        {
+            return new DERVisibleString(((ASN1OctetString)obj).getOctets());
+        }
+
+        if (obj instanceof ASN1TaggedObject)
+        {
+            return getInstance(((ASN1TaggedObject)obj).getObject());
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * return a Visible String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERVisibleString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(obj.getObject());
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERVisibleString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] & 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor
+     */
+    public DERVisibleString(
+        String   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(VISIBLE_STRING, this.getOctets());
+    }
+    
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERVisibleString))
+        {
+            return false;
+        }
+
+        return this.getString().equals(((DERVisibleString)o).getString());
+    }
+    
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,105 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.EOFException;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.io.Streams;
+
+class DefiniteLengthInputStream
+        extends LimitedInputStream
+{
+    private static final byte[] EMPTY_BYTES = new byte[0];
+
+    private final int _originalLength;
+    private int _remaining;
+
+    DefiniteLengthInputStream(
+        InputStream in,
+        int         length)
+    {
+        super(in, length);
+
+        if (length < 0)
+        {
+            throw new IllegalArgumentException("negative lengths not allowed");
+        }
+
+        this._originalLength = length;
+        this._remaining = length;
+
+        if (length == 0)
+        {
+            setParentEofDetect(true);
+        }
+    }
+
+    int getRemaining()
+    {
+        return _remaining;
+    }
+
+    public int read()
+        throws IOException
+    {
+        if (_remaining == 0)
+        {
+            return -1;
+        }
+
+        int b = _in.read();
+
+        if (b < 0)
+        {
+            throw new EOFException("DEF length " + _originalLength + " object truncated by " + _remaining);
+        }
+
+        if (--_remaining == 0)
+        {
+            setParentEofDetect(true);
+        }
+
+        return b;
+    }
+
+    public int read(byte[] buf, int off, int len)
+        throws IOException
+    {
+        if (_remaining == 0)
+        {
+            return -1;
+        }
+
+        int toRead = Math.min(len, _remaining);
+        int numRead = _in.read(buf, off, toRead);
+
+        if (numRead < 0)
+        {
+            throw new EOFException("DEF length " + _originalLength + " object truncated by " + _remaining);
+        }
+
+        if ((_remaining -= numRead) == 0)
+        {
+            setParentEofDetect(true);
+        }
+
+        return numRead;
+    }
+
+    byte[] toByteArray()
+        throws IOException
+    {
+        if (_remaining == 0)
+        {
+            return EMPTY_BYTES;
+        }
+
+        byte[] bytes = new byte[_remaining];
+        if ((_remaining -= Streams.readFully(_in, bytes)) != 0)
+        {
+            throw new EOFException("DEF length " + _originalLength + " object truncated by " + _remaining);
+        }
+        setParentEofDetect(true);
+        return bytes;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,9 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface InMemoryRepresentable
+{
+    DERObject getLoadedObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,111 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.EOFException;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+class IndefiniteLengthInputStream
+    extends LimitedInputStream
+{
+    private int _b1;
+    private int _b2;
+    private boolean _eofReached = false;
+    private boolean _eofOn00 = true;
+
+    IndefiniteLengthInputStream(
+        InputStream in,
+        int         limit)
+        throws IOException
+    {
+        super(in, limit);
+
+        _b1 = in.read();
+        _b2 = in.read();
+
+        if (_b2 < 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        checkForEof();
+    }
+
+    void setEofOn00(
+        boolean eofOn00)
+    {
+        _eofOn00 = eofOn00;
+        checkForEof();
+    }
+
+    private boolean checkForEof()
+    {
+        if (!_eofReached && _eofOn00 && (_b1 == 0x00 && _b2 == 0x00))
+        {
+            _eofReached = true;
+            setParentEofDetect(true);
+        }
+        return _eofReached;
+    }
+
+    public int read(byte[] b, int off, int len)
+        throws IOException
+    {
+        // Only use this optimisation if we aren't checking for 00
+        if (_eofOn00 || len < 3)
+        {
+            return super.read(b, off, len);
+        }
+
+        if (_eofReached)
+        {
+            return -1;
+        }
+
+        int numRead = _in.read(b, off + 2, len - 2);
+
+        if (numRead < 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        b[off] = (byte)_b1;
+        b[off + 1] = (byte)_b2;
+
+        _b1 = _in.read();
+        _b2 = _in.read();
+
+        if (_b2 < 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        return numRead + 2;
+    }
+
+    public int read()
+        throws IOException
+    {
+        if (checkForEof())
+        {
+            return -1;
+        }
+
+        int b = _in.read();
+
+        if (b < 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        int v = _b1;
+
+        _b1 = _b2;
+        _b2 = b;
+
+        return v;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,43 @@
+package org.bouncycastle.asn1;
+
+import ewe.util.Enumeration;
+import ewe.io.IOException;
+
+class LazyDERConstructionEnumeration
+    implements Enumeration
+{
+    private ASN1InputStream aIn;
+    private Object          nextObj;
+
+    public LazyDERConstructionEnumeration(byte[] encoded)
+    {
+        aIn = new ASN1InputStream(encoded, true);
+        nextObj = readObject();
+    }
+
+    public boolean hasMoreElements()
+    {
+        return nextObj != null;
+    }
+
+    public Object nextElement()
+    {
+        Object o = nextObj;
+
+        nextObj = readObject();
+
+        return o;
+    }
+
+    private Object readObject()
+    {
+        try
+        {
+            return aIn.readObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException("malformed DER construction: " + e, e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/LazyDERSequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/LazyDERSequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/LazyDERSequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,75 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class LazyDERSequence
+    extends DERSequence
+{
+    private byte[] encoded;
+    private boolean parsed = false;
+    private int size = -1;
+
+    LazyDERSequence(
+        byte[] encoded)
+        throws IOException
+    {
+        this.encoded = encoded;
+    }
+
+    private void parse()
+    {
+        Enumeration en = new LazyDERConstructionEnumeration(encoded);
+
+        while (en.hasMoreElements())
+        {
+            addObject((DEREncodable)en.nextElement());
+        }
+
+        parsed = true;
+    }
+
+    public synchronized DEREncodable getObjectAt(int index)
+    {
+        if (!parsed)
+        {
+            parse();
+        }
+
+        return super.getObjectAt(index);
+    }
+
+    public synchronized Enumeration getObjects()
+    {
+        if (parsed)
+        {
+            return super.getObjects();
+        }
+
+        return new LazyDERConstructionEnumeration(encoded);
+    }
+
+    public int size()
+    {
+        if (size < 0)
+        {
+            Enumeration en = new LazyDERConstructionEnumeration(encoded);
+
+            size = 0;
+            while (en.hasMoreElements())
+            {
+                en.nextElement();
+                size++;
+            }
+        }
+
+        return size;
+    }
+    
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(SEQUENCE | CONSTRUCTED, encoded);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/LimitedInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/LimitedInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/LimitedInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,32 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.InputStream;
+
+abstract class LimitedInputStream
+        extends InputStream
+{
+    protected final InputStream _in;
+    private int _limit;
+
+    LimitedInputStream(
+        InputStream in,
+        int         limit)
+    {
+        this._in = in;
+        this._limit = limit;
+    }
+
+    int getRemaining()
+    {
+        // TODO: maybe one day this can become more accurate
+        return _limit;
+    }
+    
+    protected void setParentEofDetect(boolean on)
+    {
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            ((IndefiniteLengthInputStream)_in).setEofOn00(on);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/OIDTokenizer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/OIDTokenizer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/OIDTokenizer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.asn1;
+
+/**
+ * class for breaking up an OID into it's component tokens, ala
+ * java.util.StringTokenizer. We need this class as some of the
+ * lightweight Java environment don't support classes like
+ * StringTokenizer.
+ */
+public class OIDTokenizer
+{
+    private String  oid;
+    private int     index;
+
+    public OIDTokenizer(
+        String oid)
+    {
+        this.oid = oid;
+        this.index = 0;
+    }
+
+    public boolean hasMoreTokens()
+    {
+        return (index != -1);
+    }
+
+    public String nextToken()
+    {
+        if (index == -1)
+        {
+            return null;
+        }
+
+        String  token;
+        int     end = oid.indexOf('.', index);
+
+        if (end == -1)
+        {
+            token = oid.substring(index);
+            index = -1;
+            return token;
+        }
+
+        token = oid.substring(index, end);
+
+        index = end + 1;
+        return token;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,96 @@
+package org.bouncycastle.asn1.nist;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.sec.SECNamedCurves;
+import org.bouncycastle.asn1.sec.SECObjectIdentifiers;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.util.Strings;
+
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+/**
+ * Utility class for fetching curves using their NIST names as published in FIPS-PUB 186-2
+ */
+public class NISTNamedCurves
+{
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+    }
+
+    static
+    {
+        // TODO Missing the "K-" curves
+
+        defineCurve("B-571", SECObjectIdentifiers.sect571r1);
+        defineCurve("B-409", SECObjectIdentifiers.sect409r1);
+        defineCurve("B-283", SECObjectIdentifiers.sect283r1);
+        defineCurve("B-233", SECObjectIdentifiers.sect233r1);
+        defineCurve("B-163", SECObjectIdentifiers.sect163r2);
+        defineCurve("P-521", SECObjectIdentifiers.secp521r1);
+        defineCurve("P-384", SECObjectIdentifiers.secp384r1);
+        defineCurve("P-256", SECObjectIdentifiers.secp256r1);
+        defineCurve("P-224", SECObjectIdentifiers.secp224r1);
+        defineCurve("P-192", SECObjectIdentifiers.secp192r1);
+    }
+
+    public static X9ECParameters getByName(
+        String  name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toUpperCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier  oid)
+    {
+        return SECNamedCurves.getByOID(oid);
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String  name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toUpperCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier  oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/nist/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/nist/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/nist/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Support classes for NIST related objects.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,49 @@
+package org.bouncycastle.asn1.oiw;
+
+import ewe.math.*;
+import ewe.util.*;
+
+import org.bouncycastle.asn1.*;
+
+public class ElGamalParameter
+    extends ASN1Encodable
+{
+    DERInteger      p, g;
+
+    public ElGamalParameter(
+        BigInteger  p,
+        BigInteger  g)
+    {
+        this.p = new DERInteger(p);
+        this.g = new DERInteger(g);
+    }
+
+    public ElGamalParameter(
+        ASN1Sequence  seq)
+    {
+        Enumeration     e = seq.getObjects();
+
+        p = (DERInteger)e.nextElement();
+        g = (DERInteger)e.nextElement();
+    }
+
+    public BigInteger getP()
+    {
+        return p.getPositiveValue();
+    }
+
+    public BigInteger getG()
+    {
+        return g.getPositiveValue();
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(p);
+        v.add(g);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,31 @@
+package org.bouncycastle.asn1.oiw;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface OIWObjectIdentifiers
+{
+    // id-SHA1 OBJECT IDENTIFIER ::=    
+    //   {iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2) 26 }    //
+    static final ASN1ObjectIdentifier    md4WithRSA              = new ASN1ObjectIdentifier("1.3.14.3.2.2");
+    static final ASN1ObjectIdentifier    md5WithRSA              = new ASN1ObjectIdentifier("1.3.14.3.2.3");
+    static final ASN1ObjectIdentifier    md4WithRSAEncryption    = new ASN1ObjectIdentifier("1.3.14.3.2.4");
+    
+    static final ASN1ObjectIdentifier    desECB                  = new ASN1ObjectIdentifier("1.3.14.3.2.6");
+    static final ASN1ObjectIdentifier    desCBC                  = new ASN1ObjectIdentifier("1.3.14.3.2.7");
+    static final ASN1ObjectIdentifier    desOFB                  = new ASN1ObjectIdentifier("1.3.14.3.2.8");
+    static final ASN1ObjectIdentifier    desCFB                  = new ASN1ObjectIdentifier("1.3.14.3.2.9");
+
+    static final ASN1ObjectIdentifier    desEDE                  = new ASN1ObjectIdentifier("1.3.14.3.2.17");
+    
+    static final ASN1ObjectIdentifier    idSHA1                  = new ASN1ObjectIdentifier("1.3.14.3.2.26");
+
+    static final ASN1ObjectIdentifier    dsaWithSHA1             = new ASN1ObjectIdentifier("1.3.14.3.2.27");
+
+    static final ASN1ObjectIdentifier    sha1WithRSA             = new ASN1ObjectIdentifier("1.3.14.3.2.29");
+    
+    // ElGamal Algorithm OBJECT IDENTIFIER ::=    
+    // {iso(1) identified-organization(3) oiw(14) dirservsig(7) algorithm(2) encryption(1) 1 }
+    //
+    static final ASN1ObjectIdentifier    elGamalAlgorithm        = new ASN1ObjectIdentifier("1.3.14.7.2.1.1");
+
+}

Added: trunk/src/org/bouncycastle/asn1/oiw/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/oiw/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/oiw/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Objects and OID for the support of ISO OIW.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,88 @@
+package org.bouncycastle.asn1.pkcs;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DHParameter
+    extends ASN1Encodable
+{
+    DERInteger      p, g, l;
+
+    public DHParameter(
+        BigInteger  p,
+        BigInteger  g,
+        int         l)
+    {
+        this.p = new DERInteger(p);
+        this.g = new DERInteger(g);
+
+        if (l != 0)
+        {
+            this.l = new DERInteger(l);
+        }
+        else
+        {
+            this.l = null;
+        }
+    }
+
+    public DHParameter(
+        ASN1Sequence  seq)
+    {
+        Enumeration     e = seq.getObjects();
+
+        p = (DERInteger)e.nextElement();
+        g = (DERInteger)e.nextElement();
+
+        if (e.hasMoreElements())
+        {
+            l = (DERInteger)e.nextElement();
+        }
+        else
+        {
+            l = null;
+        }
+    }
+
+    public BigInteger getP()
+    {
+        return p.getPositiveValue();
+    }
+
+    public BigInteger getG()
+    {
+        return g.getPositiveValue();
+    }
+
+    public BigInteger getL()
+    {
+        if (l == null)
+        {
+            return null;
+        }
+
+        return l.getPositiveValue();
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(p);
+        v.add(g);
+
+        if (this.getL() != null)
+        {
+            v.add(l);
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,252 @@
+package org.bouncycastle.asn1.pkcs;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface PKCSObjectIdentifiers
+{
+    //
+    // pkcs-1 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_1                    = new ASN1ObjectIdentifier("1.2.840.113549.1.1");
+    static final ASN1ObjectIdentifier    rsaEncryption             = pkcs_1.branch("1");
+    static final ASN1ObjectIdentifier    md2WithRSAEncryption      = pkcs_1.branch("2");
+    static final ASN1ObjectIdentifier    md4WithRSAEncryption      = pkcs_1.branch("3");
+    static final ASN1ObjectIdentifier    md5WithRSAEncryption      = pkcs_1.branch("4");
+    static final ASN1ObjectIdentifier    sha1WithRSAEncryption     = pkcs_1.branch("5");
+    static final ASN1ObjectIdentifier    srsaOAEPEncryptionSET     = pkcs_1.branch("6");
+    static final ASN1ObjectIdentifier    id_RSAES_OAEP             = pkcs_1.branch("7");
+    static final ASN1ObjectIdentifier    id_mgf1                   = pkcs_1.branch("8");
+    static final ASN1ObjectIdentifier    id_pSpecified             = pkcs_1.branch("9");
+    static final ASN1ObjectIdentifier    id_RSASSA_PSS             = pkcs_1.branch("10");
+    static final ASN1ObjectIdentifier    sha256WithRSAEncryption   = pkcs_1.branch("11");
+    static final ASN1ObjectIdentifier    sha384WithRSAEncryption   = pkcs_1.branch("12");
+    static final ASN1ObjectIdentifier    sha512WithRSAEncryption   = pkcs_1.branch("13");
+    static final ASN1ObjectIdentifier    sha224WithRSAEncryption   = pkcs_1.branch("14");
+
+    //
+    // pkcs-3 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 3 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_3                  = new ASN1ObjectIdentifier("1.2.840.113549.1.3");
+    static final ASN1ObjectIdentifier    dhKeyAgreement          = pkcs_3.branch("1");
+
+    //
+    // pkcs-5 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 5 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_5                  = new ASN1ObjectIdentifier("1.2.840.113549.1.5");
+
+    static final ASN1ObjectIdentifier    pbeWithMD2AndDES_CBC    = pkcs_5.branch("1");
+    static final ASN1ObjectIdentifier    pbeWithMD2AndRC2_CBC    = pkcs_5.branch("4");
+    static final ASN1ObjectIdentifier    pbeWithMD5AndDES_CBC    = pkcs_5.branch("3");
+    static final ASN1ObjectIdentifier    pbeWithMD5AndRC2_CBC    = pkcs_5.branch("6");
+    static final ASN1ObjectIdentifier    pbeWithSHA1AndDES_CBC   = pkcs_5.branch("10");
+    static final ASN1ObjectIdentifier    pbeWithSHA1AndRC2_CBC   = pkcs_5.branch("11");
+
+    static final ASN1ObjectIdentifier    id_PBES2                = pkcs_5.branch("13");
+
+    static final ASN1ObjectIdentifier    id_PBKDF2               = pkcs_5.branch("12");
+
+    //
+    // encryptionAlgorithm OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) 3 }
+    //
+    static final ASN1ObjectIdentifier    encryptionAlgorithm     = new ASN1ObjectIdentifier("1.2.840.113549.3");
+
+    static final ASN1ObjectIdentifier    des_EDE3_CBC            = encryptionAlgorithm.branch("7");
+    static final ASN1ObjectIdentifier    RC2_CBC                 = encryptionAlgorithm.branch("2");
+
+    //
+    // object identifiers for digests
+    //
+    static final ASN1ObjectIdentifier    digestAlgorithm        = new ASN1ObjectIdentifier("1.2.840.113549.2");
+    //
+    // md2 OBJECT IDENTIFIER ::=
+    //      {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 2}
+    //
+    static final ASN1ObjectIdentifier    md2                    = digestAlgorithm.branch("2");
+
+    //
+    // md4 OBJECT IDENTIFIER ::=
+    //      {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 4}
+    //
+    static final ASN1ObjectIdentifier    md4 = digestAlgorithm.branch("4");
+
+    //
+    // md5 OBJECT IDENTIFIER ::=
+    //      {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 5}
+    //
+    static final ASN1ObjectIdentifier    md5                     = digestAlgorithm.branch("5");
+
+    static final ASN1ObjectIdentifier    id_hmacWithSHA1         = digestAlgorithm.branch("7");
+    static final ASN1ObjectIdentifier    id_hmacWithSHA224       = digestAlgorithm.branch("8");
+    static final ASN1ObjectIdentifier    id_hmacWithSHA256       = digestAlgorithm.branch("9");
+    static final ASN1ObjectIdentifier    id_hmacWithSHA384       = digestAlgorithm.branch("10");
+    static final ASN1ObjectIdentifier    id_hmacWithSHA512       = digestAlgorithm.branch("11");
+
+    //
+    // pkcs-7 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 7 }
+    //
+    static final String                 pkcs_7                  = "1.2.840.113549.1.7";
+    static final ASN1ObjectIdentifier    data                    = new ASN1ObjectIdentifier(pkcs_7 + ".1");
+    static final ASN1ObjectIdentifier    signedData              = new ASN1ObjectIdentifier(pkcs_7 + ".2");
+    static final ASN1ObjectIdentifier    envelopedData           = new ASN1ObjectIdentifier(pkcs_7 + ".3");
+    static final ASN1ObjectIdentifier    signedAndEnvelopedData  = new ASN1ObjectIdentifier(pkcs_7 + ".4");
+    static final ASN1ObjectIdentifier    digestedData            = new ASN1ObjectIdentifier(pkcs_7 + ".5");
+    static final ASN1ObjectIdentifier    encryptedData           = new ASN1ObjectIdentifier(pkcs_7 + ".6");
+
+    //
+    // pkcs-9 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 9 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_9                  = new ASN1ObjectIdentifier("1.2.840.113549.1.9");
+
+    static final ASN1ObjectIdentifier    pkcs_9_at_emailAddress  = pkcs_9.branch("1");
+    static final ASN1ObjectIdentifier    pkcs_9_at_unstructuredName = pkcs_9.branch("2");
+    static final ASN1ObjectIdentifier    pkcs_9_at_contentType = pkcs_9.branch("3");
+    static final ASN1ObjectIdentifier    pkcs_9_at_messageDigest = pkcs_9.branch("4");
+    static final ASN1ObjectIdentifier    pkcs_9_at_signingTime = pkcs_9.branch("5");
+    static final ASN1ObjectIdentifier    pkcs_9_at_counterSignature = pkcs_9.branch("6");
+    static final ASN1ObjectIdentifier    pkcs_9_at_challengePassword = pkcs_9.branch("7");
+    static final ASN1ObjectIdentifier    pkcs_9_at_unstructuredAddress = pkcs_9.branch("8");
+    static final ASN1ObjectIdentifier    pkcs_9_at_extendedCertificateAttributes = pkcs_9.branch("9");
+
+    static final ASN1ObjectIdentifier    pkcs_9_at_signingDescription = pkcs_9.branch("13");
+    static final ASN1ObjectIdentifier    pkcs_9_at_extensionRequest = pkcs_9.branch("14");
+    static final ASN1ObjectIdentifier    pkcs_9_at_smimeCapabilities = pkcs_9.branch("15");
+
+    static final ASN1ObjectIdentifier    pkcs_9_at_friendlyName  = pkcs_9.branch("20");
+    static final ASN1ObjectIdentifier    pkcs_9_at_localKeyId    = pkcs_9.branch("21");
+
+    /** @deprecated use x509Certificate instead */
+    static final ASN1ObjectIdentifier    x509certType            = pkcs_9.branch("22.1");
+
+    static final ASN1ObjectIdentifier    certTypes               = pkcs_9.branch("22");
+    static final ASN1ObjectIdentifier    x509Certificate         = certTypes.branch("1");
+    static final ASN1ObjectIdentifier    sdsiCertificate         = certTypes.branch("2");
+
+    static final ASN1ObjectIdentifier    crlTypes                = pkcs_9.branch("23");
+    static final ASN1ObjectIdentifier    x509Crl                 = crlTypes.branch("1");
+
+    static final ASN1ObjectIdentifier    id_alg_PWRI_KEK    = pkcs_9.branch("16.3.9");
+
+    //
+    // SMIME capability sub oids.
+    //
+    static final ASN1ObjectIdentifier    preferSignedData        = pkcs_9.branch("15.1");
+    static final ASN1ObjectIdentifier    canNotDecryptAny        = pkcs_9.branch("15.2");
+    static final ASN1ObjectIdentifier    sMIMECapabilitiesVersions = pkcs_9.branch("15.3");
+
+    //
+    // id-ct OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) ct(1)}
+    //
+    static final ASN1ObjectIdentifier    id_ct = new ASN1ObjectIdentifier("1.2.840.113549.1.9.16.1");
+
+    static final ASN1ObjectIdentifier    id_ct_authData          = id_ct.branch("2");
+    static final ASN1ObjectIdentifier    id_ct_TSTInfo           = id_ct.branch("4");
+    static final ASN1ObjectIdentifier    id_ct_compressedData    = id_ct.branch("9");
+    static final ASN1ObjectIdentifier    id_ct_authEnvelopedData = id_ct.branch("23");
+    static final ASN1ObjectIdentifier    id_ct_timestampedData   = id_ct.branch("31");
+
+    //
+    // id-cti OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) cti(6)}
+    //
+    static final ASN1ObjectIdentifier    id_cti = new ASN1ObjectIdentifier("1.2.840.113549.1.9.16.6");
+    
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfOrigin  = id_cti.branch("1");
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfReceipt = id_cti.branch("2");
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfDelivery = id_cti.branch("3");
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfSender = id_cti.branch("4");
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfApproval = id_cti.branch("5");
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfCreation = id_cti.branch("6");
+    
+    //
+    // id-aa OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) attributes(2)}
+    //
+    static final ASN1ObjectIdentifier    id_aa = new ASN1ObjectIdentifier("1.2.840.113549.1.9.16.2");
+
+
+    static final ASN1ObjectIdentifier id_aa_receiptRequest = id_aa.branch("1");
+    
+    static final ASN1ObjectIdentifier id_aa_contentHint = id_aa.branch("4"); // See RFC 2634
+    static final ASN1ObjectIdentifier id_aa_msgSigDigest = id_aa.branch("5");
+    static final ASN1ObjectIdentifier id_aa_contentReference = id_aa.branch("10");
+    /*
+     * id-aa-encrypKeyPref OBJECT IDENTIFIER ::= {id-aa 11}
+     * 
+     */
+    static final ASN1ObjectIdentifier id_aa_encrypKeyPref = id_aa.branch("11");
+    static final ASN1ObjectIdentifier id_aa_signingCertificate = id_aa.branch("12");
+    static final ASN1ObjectIdentifier id_aa_signingCertificateV2 = id_aa.branch("47");
+
+    static final ASN1ObjectIdentifier id_aa_contentIdentifier = id_aa.branch("7"); // See RFC 2634
+
+    /*
+     * RFC 3126
+     */
+    static final ASN1ObjectIdentifier id_aa_signatureTimeStampToken = id_aa.branch("14");
+    
+    static final ASN1ObjectIdentifier id_aa_ets_sigPolicyId = id_aa.branch("15");
+    static final ASN1ObjectIdentifier id_aa_ets_commitmentType = id_aa.branch("16");
+    static final ASN1ObjectIdentifier id_aa_ets_signerLocation = id_aa.branch("17");
+    static final ASN1ObjectIdentifier id_aa_ets_signerAttr = id_aa.branch("18");
+    static final ASN1ObjectIdentifier id_aa_ets_otherSigCert = id_aa.branch("19");
+    static final ASN1ObjectIdentifier id_aa_ets_contentTimestamp = id_aa.branch("20");
+    static final ASN1ObjectIdentifier id_aa_ets_certificateRefs = id_aa.branch("21");
+    static final ASN1ObjectIdentifier id_aa_ets_revocationRefs = id_aa.branch("22");
+    static final ASN1ObjectIdentifier id_aa_ets_certValues = id_aa.branch("23");
+    static final ASN1ObjectIdentifier id_aa_ets_revocationValues = id_aa.branch("24");
+    static final ASN1ObjectIdentifier id_aa_ets_escTimeStamp = id_aa.branch("25");
+    static final ASN1ObjectIdentifier id_aa_ets_certCRLTimestamp = id_aa.branch("26");
+    static final ASN1ObjectIdentifier id_aa_ets_archiveTimestamp = id_aa.branch("27");
+
+    /** @deprecated use id_aa_ets_sigPolicyId instead */
+    static final ASN1ObjectIdentifier id_aa_sigPolicyId = id_aa_ets_sigPolicyId;
+    /** @deprecated use id_aa_ets_commitmentType instead */
+    static final ASN1ObjectIdentifier id_aa_commitmentType = id_aa_ets_commitmentType;
+    /** @deprecated use id_aa_ets_signerLocation instead */
+    static final ASN1ObjectIdentifier id_aa_signerLocation = id_aa_ets_signerLocation;
+    /** @deprecated use id_aa_ets_otherSigCert instead */
+    static final ASN1ObjectIdentifier id_aa_otherSigCert = id_aa_ets_otherSigCert;
+    
+    //
+    // id-spq OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-spq(5)}
+    //
+    final String id_spq = "1.2.840.113549.1.9.16.5";
+
+    static final ASN1ObjectIdentifier id_spq_ets_uri = new ASN1ObjectIdentifier(id_spq + ".1");
+    static final ASN1ObjectIdentifier id_spq_ets_unotice = new ASN1ObjectIdentifier(id_spq + ".2");
+
+    //
+    // pkcs-12 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 12 }
+    //
+    static final ASN1ObjectIdentifier   pkcs_12                  = new ASN1ObjectIdentifier("1.2.840.113549.1.12");
+    static final ASN1ObjectIdentifier   bagtypes                 = pkcs_12.branch("10.1");
+
+    static final ASN1ObjectIdentifier    keyBag                  = bagtypes.branch("1");
+    static final ASN1ObjectIdentifier    pkcs8ShroudedKeyBag     = bagtypes.branch("2");
+    static final ASN1ObjectIdentifier    certBag                 = bagtypes.branch("3");
+    static final ASN1ObjectIdentifier    crlBag                  = bagtypes.branch("4");
+    static final ASN1ObjectIdentifier    secretBag               = bagtypes.branch("5");
+    static final ASN1ObjectIdentifier    safeContentsBag         = bagtypes.branch("6");
+
+    static final ASN1ObjectIdentifier    pkcs_12PbeIds  = pkcs_12.branch("1");
+
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd128BitRC4 = pkcs_12PbeIds.branch("1");
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd40BitRC4  = pkcs_12PbeIds.branch("2");
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd3_KeyTripleDES_CBC = pkcs_12PbeIds.branch("3");
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd2_KeyTripleDES_CBC = pkcs_12PbeIds.branch("4");
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd128BitRC2_CBC = pkcs_12PbeIds.branch("5");
+    static final ASN1ObjectIdentifier    pbewithSHAAnd40BitRC2_CBC = pkcs_12PbeIds.branch("6");
+
+    static final ASN1ObjectIdentifier    id_alg_CMS3DESwrap = new ASN1ObjectIdentifier("1.2.840.113549.1.9.16.3.6");
+    static final ASN1ObjectIdentifier    id_alg_CMSRC2wrap = new ASN1ObjectIdentifier("1.2.840.113549.1.9.16.3.7");
+}
+

Added: trunk/src/org/bouncycastle/asn1/pkcs/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/pkcs/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/pkcs/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Support classes useful for encoding and supporting the various RSA PKCS documents.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1029 @@
+package org.bouncycastle.asn1.sec;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.asn1.x9.X9ECParametersHolder;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+public class SECNamedCurves
+{
+    private static BigInteger fromHex(
+        String hex)
+    {
+        return new BigInteger(1, Hex.decode(hex));
+    }
+
+    /*
+     * secp112r1
+     */
+    static X9ECParametersHolder secp112r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = (2^128 - 3) / 76439
+            BigInteger p = fromHex("DB7C2ABF62E35E668076BEAD208B");
+            BigInteger a = fromHex("DB7C2ABF62E35E668076BEAD2088");
+            BigInteger b = fromHex("659EF8BA043916EEDE8911702B22");
+            byte[] S = Hex.decode("00F50B028E4D696E676875615175290472783FB1");
+            BigInteger n = fromHex("DB7C2ABF62E35E7628DFAC6561C5");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "09487239995A5EE76B55F9C2F098"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "09487239995A5EE76B55F9C2F098"
+                + "A89CE5AF8724C0A23E0E0FF77500"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp112r2
+     */
+    static X9ECParametersHolder secp112r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = (2^128 - 3) / 76439
+            BigInteger p = fromHex("DB7C2ABF62E35E668076BEAD208B");
+            BigInteger a = fromHex("6127C24C05F38A0AAAF65C0EF02C");
+            BigInteger b = fromHex("51DEF1815DB5ED74FCC34C85D709");
+            byte[] S = Hex.decode("002757A1114D696E6768756151755316C05E0BD4");
+            BigInteger n = fromHex("36DF0AAFD8B8D7597CA10520D04B");
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "4BA30AB5E892B4E1649DD0928643"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "4BA30AB5E892B4E1649DD0928643"
+                + "ADCD46F5882E3747DEF36E956E97"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp128r1
+     */
+    static X9ECParametersHolder secp128r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^128 - 2^97 - 1
+            BigInteger p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
+            BigInteger a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
+            BigInteger b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
+            byte[] S = Hex.decode("000E0D4D696E6768756151750CC03A4473D03679");
+            BigInteger n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "161FF7528B899B2D0C28607CA52C5B86"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "161FF7528B899B2D0C28607CA52C5B86"
+                + "CF5AC8395BAFEB13C02DA292DDED7A83"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp128r2
+     */
+    static X9ECParametersHolder secp128r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^128 - 2^97 - 1
+            BigInteger p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
+            BigInteger a = fromHex("D6031998D1B3BBFEBF59CC9BBFF9AEE1");
+            BigInteger b = fromHex("5EEEFCA380D02919DC2C6558BB6D8A5D");
+            byte[] S = Hex.decode("004D696E67687561517512D8F03431FCE63B88F4");
+            BigInteger n = fromHex("3FFFFFFF7FFFFFFFBE0024720613B5A3");
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "7B6AA5D85E572983E6FB32A7CDEBC140"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "7B6AA5D85E572983E6FB32A7CDEBC140"
+                + "27B6916A894D3AEE7106FE805FC34B44"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp160k1
+     */
+    static X9ECParametersHolder secp160k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(7);
+            byte[] S = null;
+            BigInteger n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+//            ECPoint G = curve.decodePoint(Hex.decode("02"
+//                + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"
+                + "938CF935318FDCED6BC28286531733C3F03C4FEE"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp160r1
+     */
+    static X9ECParametersHolder secp160r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^160 - 2^31 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
+            BigInteger a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
+            BigInteger b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
+            byte[] S = Hex.decode("1053CDE42C14D696E67687561517533BF3F83345");
+            BigInteger n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+                //+ "4A96B5688EF573284664698968C38BB913CBFC82"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "4A96B5688EF573284664698968C38BB913CBFC82"
+                + "23A628553168947D59DCC912042351377AC5FB32"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp160r2
+     */
+    static X9ECParametersHolder secp160r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
+            BigInteger a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC70");
+            BigInteger b = fromHex("B4E134D3FB59EB8BAB57274904664D5AF50388BA");
+            byte[] S = Hex.decode("B99B99B099B323E02709A4D696E6768756151751");
+            BigInteger n = fromHex("0100000000000000000000351EE786A818F3A1A16B");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "52DCB034293A117E1F4FF11B30F7199D3144CE6D"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "52DCB034293A117E1F4FF11B30F7199D3144CE6D"
+                + "FEAFFEF2E331F296E071FA0DF9982CFEA7D43F2E"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp192k1
+     */
+    static X9ECParametersHolder secp192k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(3);
+            byte[] S = null;
+            BigInteger n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"
+                + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp192r1
+     */
+    static X9ECParametersHolder secp192r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^192 - 2^64 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
+            BigInteger a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
+            BigInteger b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
+            byte[] S = Hex.decode("3045AE6FC8422F64ED579528D38120EAE12196D5");
+            BigInteger n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"
+                + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp224k1
+     */
+    static X9ECParametersHolder secp224k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^224 - 2^32 - 2^12 - 2^11 - 2^9 - 2^7 - 2^4 - 2 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D");
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(5);
+            byte[] S = null;
+            BigInteger n = fromHex("010000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C"
+                + "7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp224r1
+     */
+    static X9ECParametersHolder secp224r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^224 - 2^96 + 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
+            BigInteger a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
+            BigInteger b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
+            byte[] S = Hex.decode("BD71344799D5C7FCDC45B59FA3B9AB8F6A948BC5");
+            BigInteger n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"
+                + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp256k1
+     */
+    static X9ECParametersHolder secp256k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(7);
+            byte[] S = null;
+            BigInteger n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"
+                + "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp256r1
+     */
+    static X9ECParametersHolder secp256r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
+            BigInteger p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
+            BigInteger a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
+            BigInteger b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
+            byte[] S = Hex.decode("C49D360886E704936A6678E1139D26B7819F7E90");
+            BigInteger n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"
+                + "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp384r1
+     */
+    static X9ECParametersHolder secp384r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^384 - 2^128 - 2^96 + 2^32 - 1
+            BigInteger p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF");
+            BigInteger a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC");
+            BigInteger b = fromHex("B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF");
+            byte[] S = Hex.decode("A335926AA319A27A1D00896A6773A4827ACDAC73");
+            BigInteger n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7"
+                + "3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp521r1
+     */
+    static X9ECParametersHolder secp521r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^521 - 1
+            BigInteger p = fromHex("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
+            BigInteger a = fromHex("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC");
+            BigInteger b = fromHex("0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00");
+            byte[] S = Hex.decode("D09E8800291CB85396CC6717393284AAA0DA64BA");
+            BigInteger n = fromHex("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409");
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66"
+                + "011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+    
+    /*
+     * sect113r1
+     */
+    static X9ECParametersHolder sect113r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 113;
+            int k = 9;
+
+            BigInteger a = fromHex("003088250CA6E7C7FE649CE85820F7");
+            BigInteger b = fromHex("00E8BEE4D3E2260744188BE0E9C723");
+            byte[] S = Hex.decode("10E723AB14D696E6768756151756FEBF8FCB49A9");
+            BigInteger n = fromHex("0100000000000000D9CCEC8A39E56F");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "009D73616F35F4AB1407D73562C10F"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "009D73616F35F4AB1407D73562C10F"
+                + "00A52830277958EE84D1315ED31886"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect113r2
+     */
+    static X9ECParametersHolder sect113r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 113;
+            int k = 9;
+
+            BigInteger a = fromHex("00689918DBEC7E5A0DD6DFC0AA55C7");
+            BigInteger b = fromHex("0095E9A9EC9B297BD4BF36E059184F");
+            byte[] S = Hex.decode("10C0FB15760860DEF1EEF4D696E676875615175D");
+            BigInteger n = fromHex("010000000000000108789B2496AF93");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "01A57A6A7B26CA5EF52FCDB8164797"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "01A57A6A7B26CA5EF52FCDB8164797"
+                + "00B3ADC94ED1FE674C06E695BABA1D"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect131r1
+     */
+    static X9ECParametersHolder sect131r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 131;
+            int k1 = 2;
+            int k2 = 3;
+            int k3 = 8;
+
+            BigInteger a = fromHex("07A11B09A76B562144418FF3FF8C2570B8");
+            BigInteger b = fromHex("0217C05610884B63B9C6C7291678F9D341");
+            byte[] S = Hex.decode("4D696E676875615175985BD3ADBADA21B43A97E2");
+            BigInteger n = fromHex("0400000000000000023123953A9464B54D");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "0081BAF91FDF9833C40F9C181343638399"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "0081BAF91FDF9833C40F9C181343638399"
+                + "078C6E7EA38C001F73C8134B1B4EF9E150"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect131r2
+     */
+    static X9ECParametersHolder sect131r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 131;
+            int k1 = 2;
+            int k2 = 3;
+            int k3 = 8;
+
+            BigInteger a = fromHex("03E5A88919D7CAFCBF415F07C2176573B2");
+            BigInteger b = fromHex("04B8266A46C55657AC734CE38F018F2192");
+            byte[] S = Hex.decode("985BD3ADBAD4D696E676875615175A21B43A97E3");
+            BigInteger n = fromHex("0400000000000000016954A233049BA98F");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "0356DCD8F2F95031AD652D23951BB366A8"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "0356DCD8F2F95031AD652D23951BB366A8"
+                + "0648F06D867940A5366D9E265DE9EB240F"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect163k1
+     */
+    static X9ECParametersHolder sect163k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 163;
+            int k1 = 3;
+            int k2 = 6;
+            int k3 = 7;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex("04000000000000000000020108A2E0CC0D99F8A5EF");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "02FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE8"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "02FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE8"
+                + "0289070FB05D38FF58321F2E800536D538CCDAA3D9"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect163r1
+     */
+    static X9ECParametersHolder sect163r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 163;
+            int k1 = 3;
+            int k2 = 6;
+            int k3 = 7;
+
+            BigInteger a = fromHex("07B6882CAAEFA84F9554FF8428BD88E246D2782AE2");
+            BigInteger b = fromHex("0713612DCDDCB40AAB946BDA29CA91F73AF958AFD9");
+            byte[] S = Hex.decode("24B7B137C8A14D696E6768756151756FD0DA2E5C");
+            BigInteger n = fromHex("03FFFFFFFFFFFFFFFFFFFF48AAB689C29CA710279B");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "0369979697AB43897789566789567F787A7876A654"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "0369979697AB43897789566789567F787A7876A654"
+                + "00435EDB42EFAFB2989D51FEFCE3C80988F41FF883"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect163r2
+     */
+    static X9ECParametersHolder sect163r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 163;
+            int k1 = 3;
+            int k2 = 6;
+            int k3 = 7;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex("020A601907B8C953CA1481EB10512F78744A3205FD");
+            byte[] S = Hex.decode("85E25BFE5C86226CDB12016F7553F9D0E693A268");
+            BigInteger n = fromHex("040000000000000000000292FE77E70C12A4234C33");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "03F0EBA16286A2D57EA0991168D4994637E8343E36"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "03F0EBA16286A2D57EA0991168D4994637E8343E36"
+                + "00D51FBC6C71A0094FA2CDD545B11C5C0C797324F1"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect193r1
+     */
+    static X9ECParametersHolder sect193r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 193;
+            int k = 15;
+
+            BigInteger a = fromHex("0017858FEB7A98975169E171F77B4087DE098AC8A911DF7B01");
+            BigInteger b = fromHex("00FDFB49BFE6C3A89FACADAA7A1E5BBC7CC1C2E5D831478814");
+            byte[] S = Hex.decode("103FAEC74D696E676875615175777FC5B191EF30");
+            BigInteger n = fromHex("01000000000000000000000000C7F34A778F443ACC920EBA49");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "01F481BC5F0FF84A74AD6CDF6FDEF4BF6179625372D8C0C5E1"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "01F481BC5F0FF84A74AD6CDF6FDEF4BF6179625372D8C0C5E1"
+                + "0025E399F2903712CCF3EA9E3A1AD17FB0B3201B6AF7CE1B05"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect193r2
+     */
+    static X9ECParametersHolder sect193r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 193;
+            int k = 15;
+
+            BigInteger a = fromHex("0163F35A5137C2CE3EA6ED8667190B0BC43ECD69977702709B");
+            BigInteger b = fromHex("00C9BB9E8927D4D64C377E2AB2856A5B16E3EFB7F61D4316AE");
+            byte[] S = Hex.decode("10B7B4D696E676875615175137C8A16FD0DA2211");
+            BigInteger n = fromHex("010000000000000000000000015AAB561B005413CCD4EE99D5");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "00D9B67D192E0367C803F39E1A7E82CA14A651350AAE617E8F"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "00D9B67D192E0367C803F39E1A7E82CA14A651350AAE617E8F"
+                + "01CE94335607C304AC29E7DEFBD9CA01F596F927224CDECF6C"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect233k1
+     */
+    static X9ECParametersHolder sect233k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 233;
+            int k = 74;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex("8000000000000000000000000000069D5BB915BCD46EFB1AD5F173ABDF");
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "017232BA853A7E731AF129F22FF4149563A419C26BF50A4C9D6EEFAD6126"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "017232BA853A7E731AF129F22FF4149563A419C26BF50A4C9D6EEFAD6126"
+                + "01DB537DECE819B7F70F555A67C427A8CD9BF18AEB9B56E0C11056FAE6A3"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect233r1
+     */
+    static X9ECParametersHolder sect233r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 233;
+            int k = 74;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex("0066647EDE6C332C7F8C0923BB58213B333B20E9CE4281FE115F7D8F90AD");
+            byte[] S = Hex.decode("74D59FF07F6B413D0EA14B344B20A2DB049B50C3");
+            BigInteger n = fromHex("01000000000000000000000000000013E974E72F8A6922031D2603CFE0D7");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "00FAC9DFCBAC8313BB2139F1BB755FEF65BC391F8B36F8F8EB7371FD558B"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "00FAC9DFCBAC8313BB2139F1BB755FEF65BC391F8B36F8F8EB7371FD558B"
+                + "01006A08A41903350678E58528BEBF8A0BEFF867A7CA36716F7E01F81052"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect239k1
+     */
+    static X9ECParametersHolder sect239k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 239;
+            int k = 158;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex("2000000000000000000000000000005A79FEC67CB6E91F1C1DA800E478A5");
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "29A0B6A887A983E9730988A68727A8B2D126C44CC2CC7B2A6555193035DC"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "29A0B6A887A983E9730988A68727A8B2D126C44CC2CC7B2A6555193035DC"
+                + "76310804F12E549BDB011C103089E73510ACB275FC312A5DC6B76553F0CA"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect283k1
+     */
+    static X9ECParametersHolder sect283k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 283;
+            int k1 = 5;
+            int k2 = 7;
+            int k3 = 12;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex("01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9AE2ED07577265DFF7F94451E061E163C61");
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "0503213F78CA44883F1A3B8162F188E553CD265F23C1567A16876913B0C2AC2458492836"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "0503213F78CA44883F1A3B8162F188E553CD265F23C1567A16876913B0C2AC2458492836"
+                + "01CCDA380F1C9E318D90F95D07E5426FE87E45C0E8184698E45962364E34116177DD2259"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect283r1
+     */
+    static X9ECParametersHolder sect283r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 283;
+            int k1 = 5;
+            int k2 = 7;
+            int k3 = 12;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex("027B680AC8B8596DA5A4AF8A19A0303FCA97FD7645309FA2A581485AF6263E313B79A2F5");
+            byte[] S = Hex.decode("77E2B07370EB0F832A6DD5B62DFC88CD06BB84BE");
+            BigInteger n = fromHex("03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEF90399660FC938A90165B042A7CEFADB307");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "05F939258DB7DD90E1934F8C70B0DFEC2EED25B8557EAC9C80E2E198F8CDBECD86B12053"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "05F939258DB7DD90E1934F8C70B0DFEC2EED25B8557EAC9C80E2E198F8CDBECD86B12053"
+                + "03676854FE24141CB98FE6D4B20D02B4516FF702350EDDB0826779C813F0DF45BE8112F4"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect409k1
+     */
+    static X9ECParametersHolder sect409k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 409;
+            int k = 87;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5F83B2D4EA20400EC4557D5ED3E3E7CA5B4B5C83B8E01E5FCF");
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "0060F05F658F49C1AD3AB1890F7184210EFD0987E307C84C27ACCFB8F9F67CC2C460189EB5AAAA62EE222EB1B35540CFE9023746"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "0060F05F658F49C1AD3AB1890F7184210EFD0987E307C84C27ACCFB8F9F67CC2C460189EB5AAAA62EE222EB1B35540CFE9023746"
+                + "01E369050B7C4E42ACBA1DACBF04299C3460782F918EA427E6325165E9EA10E3DA5F6C42E9C55215AA9CA27A5863EC48D8E0286B"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect409r1
+     */
+    static X9ECParametersHolder sect409r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 409;
+            int k = 87;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex("0021A5C2C8EE9FEB5C4B9A753B7B476B7FD6422EF1F3DD674761FA99D6AC27C8A9A197B272822F6CD57A55AA4F50AE317B13545F");
+            byte[] S = Hex.decode("4099B5A457F9D69F79213D094C4BCD4D4262210B");
+            BigInteger n = fromHex("010000000000000000000000000000000000000000000000000001E2AAD6A612F33307BE5FA47C3C9E052F838164CD37D9A21173");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "015D4860D088DDB3496B0C6064756260441CDE4AF1771D4DB01FFE5B34E59703DC255A868A1180515603AEAB60794E54BB7996A7"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "015D4860D088DDB3496B0C6064756260441CDE4AF1771D4DB01FFE5B34E59703DC255A868A1180515603AEAB60794E54BB7996A7"
+                + "0061B1CFAB6BE5F32BBFA78324ED106A7636B9C5A7BD198D0158AA4F5488D08F38514F1FDF4B4F40D2181B3681C364BA0273C706"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect571k1
+     */
+    static X9ECParametersHolder sect571k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 571;
+            int k1 = 2;
+            int k2 = 5;
+            int k3 = 10;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex("020000000000000000000000000000000000000000000000000000000000000000000000131850E1F19A63E4B391A8DB917F4138B630D84BE5D639381E91DEB45CFE778F637C1001");
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("02"
+            //+ "026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972"
+                + "0349DC807F4FBF374F4AEADE3BCA95314DD58CEC9F307A54FFC61EFC006D8A2C9D4979C0AC44AEA74FBEBBB9F772AEDCB620B01A7BA7AF1B320430C8591984F601CD4C143EF1C7A3"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect571r1
+     */
+    static X9ECParametersHolder sect571r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 571;
+            int k1 = 2;
+            int k2 = 5;
+            int k3 = 10;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex("02F40E7E2221F295DE297117B7F3D62F5C6A97FFCB8CEFF1CD6BA8CE4A9A18AD84FFABBD8EFA59332BE7AD6756A66E294AFD185A78FF12AA520E4DE739BACA0C7FFEFF7F2955727A");
+            byte[] S = Hex.decode("2AA058F73A0E33AB486B0F610410C53A7F132310");
+            BigInteger n = fromHex("03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE661CE18FF55987308059B186823851EC7DD9CA1161DE93D5174D66E8382E9BB2FE84E47");
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode("03"
+            //+ "0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4C850D927E1E7769C8EEC2D19"));
+            ECPoint G = curve.decodePoint(Hex.decode("04"
+                + "0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4C850D927E1E7769C8EEC2D19"
+                + "037BF27342DA639B6DCCFFFEB73D69D78C6C27A6009CBBCA1980F8533921E8A684423E43BAB08A576291AF8F461BB2A8B3531D2F0485C19B16E2F1516E23DD3C1A4827AF1B8AC15B"));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable curves = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid, X9ECParametersHolder holder)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+        curves.put(oid, holder);
+    }
+
+    static
+    {
+        defineCurve("secp112r1", SECObjectIdentifiers.secp112r1, secp112r1);
+        defineCurve("secp112r2", SECObjectIdentifiers.secp112r2, secp112r2);
+        defineCurve("secp128r1", SECObjectIdentifiers.secp128r1, secp128r1);
+        defineCurve("secp128r2", SECObjectIdentifiers.secp128r2, secp128r2);
+        defineCurve("secp160k1", SECObjectIdentifiers.secp160k1, secp160k1);
+        defineCurve("secp160r1", SECObjectIdentifiers.secp160r1, secp160r1);
+        defineCurve("secp160r2", SECObjectIdentifiers.secp160r2, secp160r2);
+        defineCurve("secp192k1", SECObjectIdentifiers.secp192k1, secp192k1);
+        defineCurve("secp192r1", SECObjectIdentifiers.secp192r1, secp192r1);
+        defineCurve("secp224k1", SECObjectIdentifiers.secp224k1, secp224k1);
+        defineCurve("secp224r1", SECObjectIdentifiers.secp224r1, secp224r1); 
+        defineCurve("secp256k1", SECObjectIdentifiers.secp256k1, secp256k1);
+        defineCurve("secp256r1", SECObjectIdentifiers.secp256r1, secp256r1); 
+        defineCurve("secp384r1", SECObjectIdentifiers.secp384r1, secp384r1); 
+        defineCurve("secp521r1", SECObjectIdentifiers.secp521r1, secp521r1); 
+
+        defineCurve("sect113r1", SECObjectIdentifiers.sect113r1, sect113r1);
+        defineCurve("sect113r2", SECObjectIdentifiers.sect113r2, sect113r2);
+        defineCurve("sect131r1", SECObjectIdentifiers.sect131r1, sect131r1);
+        defineCurve("sect131r2", SECObjectIdentifiers.sect131r2, sect131r2);
+        defineCurve("sect163k1", SECObjectIdentifiers.sect163k1, sect163k1);
+        defineCurve("sect163r1", SECObjectIdentifiers.sect163r1, sect163r1);
+        defineCurve("sect163r2", SECObjectIdentifiers.sect163r2, sect163r2);
+        defineCurve("sect193r1", SECObjectIdentifiers.sect193r1, sect193r1);
+        defineCurve("sect193r2", SECObjectIdentifiers.sect193r2, sect193r2);
+        defineCurve("sect233k1", SECObjectIdentifiers.sect233k1, sect233k1);
+        defineCurve("sect233r1", SECObjectIdentifiers.sect233r1, sect233r1);
+        defineCurve("sect239k1", SECObjectIdentifiers.sect239k1, sect239k1);
+        defineCurve("sect283k1", SECObjectIdentifiers.sect283k1, sect283k1);
+        defineCurve("sect283r1", SECObjectIdentifiers.sect283r1, sect283r1);
+        defineCurve("sect409k1", SECObjectIdentifiers.sect409k1, sect409k1);
+        defineCurve("sect409r1", SECObjectIdentifiers.sect409r1, sect409r1);
+        defineCurve("sect571k1", SECObjectIdentifiers.sect571k1, sect571k1);
+        defineCurve("sect571r1", SECObjectIdentifiers.sect571r1, sect571r1); 
+    }
+
+    public static X9ECParameters getByName(
+        String name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier oid)
+    {
+        X9ECParametersHolder holder = (X9ECParametersHolder)curves.get(oid);
+
+        if (holder != null)
+        {
+            return holder.getParameters();
+        }
+
+        return null;
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,50 @@
+package org.bouncycastle.asn1.sec;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
+
+public interface SECObjectIdentifiers
+{
+    /**
+     *  ellipticCurve OBJECT IDENTIFIER ::= {
+     *        iso(1) identified-organization(3) certicom(132) curve(0)
+     *  }
+     */
+    static final ASN1ObjectIdentifier ellipticCurve = new ASN1ObjectIdentifier("1.3.132.0");
+
+    static final ASN1ObjectIdentifier sect163k1 = ellipticCurve.branch("1");
+    static final ASN1ObjectIdentifier sect163r1 = ellipticCurve.branch("2");
+    static final ASN1ObjectIdentifier sect239k1 = ellipticCurve.branch("3");
+    static final ASN1ObjectIdentifier sect113r1 = ellipticCurve.branch("4");
+    static final ASN1ObjectIdentifier sect113r2 = ellipticCurve.branch("5");
+    static final ASN1ObjectIdentifier secp112r1 = ellipticCurve.branch("6");
+    static final ASN1ObjectIdentifier secp112r2 = ellipticCurve.branch("7");
+    static final ASN1ObjectIdentifier secp160r1 = ellipticCurve.branch("8");
+    static final ASN1ObjectIdentifier secp160k1 = ellipticCurve.branch("9");
+    static final ASN1ObjectIdentifier secp256k1 = ellipticCurve.branch("10");
+    static final ASN1ObjectIdentifier sect163r2 = ellipticCurve.branch("15");
+    static final ASN1ObjectIdentifier sect283k1 = ellipticCurve.branch("16");
+    static final ASN1ObjectIdentifier sect283r1 = ellipticCurve.branch("17");
+    static final ASN1ObjectIdentifier sect131r1 = ellipticCurve.branch("22");
+    static final ASN1ObjectIdentifier sect131r2 = ellipticCurve.branch("23");
+    static final ASN1ObjectIdentifier sect193r1 = ellipticCurve.branch("24");
+    static final ASN1ObjectIdentifier sect193r2 = ellipticCurve.branch("25");
+    static final ASN1ObjectIdentifier sect233k1 = ellipticCurve.branch("26");
+    static final ASN1ObjectIdentifier sect233r1 = ellipticCurve.branch("27");
+    static final ASN1ObjectIdentifier secp128r1 = ellipticCurve.branch("28");
+    static final ASN1ObjectIdentifier secp128r2 = ellipticCurve.branch("29");
+    static final ASN1ObjectIdentifier secp160r2 = ellipticCurve.branch("30");
+    static final ASN1ObjectIdentifier secp192k1 = ellipticCurve.branch("31");
+    static final ASN1ObjectIdentifier secp224k1 = ellipticCurve.branch("32");
+    static final ASN1ObjectIdentifier secp224r1 = ellipticCurve.branch("33");
+    static final ASN1ObjectIdentifier secp384r1 = ellipticCurve.branch("34");
+    static final ASN1ObjectIdentifier secp521r1 = ellipticCurve.branch("35");
+    static final ASN1ObjectIdentifier sect409k1 = ellipticCurve.branch("36");
+    static final ASN1ObjectIdentifier sect409r1 = ellipticCurve.branch("37");
+    static final ASN1ObjectIdentifier sect571k1 = ellipticCurve.branch("38");
+    static final ASN1ObjectIdentifier sect571r1 = ellipticCurve.branch("39");
+
+    static final ASN1ObjectIdentifier secp192r1 = X9ObjectIdentifiers.prime192v1;
+    static final ASN1ObjectIdentifier secp256r1 = X9ObjectIdentifiers.prime256v1;
+
+}

Added: trunk/src/org/bouncycastle/asn1/sec/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/sec/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/sec/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Classes for support of the SEC standard for Elliptic Curve.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,351 @@
+package org.bouncycastle.asn1.teletrust;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.asn1.x9.X9ECParametersHolder;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+/**
+ * elliptic curves defined in "ECC Brainpool Standard Curves and Curve Generation"
+ * http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt
+ */
+public class TeleTrusTNamedCurves
+{
+    static X9ECParametersHolder brainpoolP160r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger("E95E4A5F737059DC60DFC7AD95B3D8139515620F", 16), // q
+                new BigInteger("340E7BE2A280EB74E2BE61BADA745D97E8F7C300", 16), // a
+                new BigInteger("1E589A8595423412134FAA2DBDEC95C8D8675E58", 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("04BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC31667CB477A1A8EC338F94741669C976316DA6321")), // G
+                new BigInteger("E95E4A5F737059DC60DF5991D45029409E60FC09", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP160t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //   new BigInteger("24DBFF5DEC9B986BBFE5295A29BFBAE45E0F5D0B", 16), // Z
+                new BigInteger("E95E4A5F737059DC60DFC7AD95B3D8139515620F", 16), // q
+                new BigInteger("E95E4A5F737059DC60DFC7AD95B3D8139515620C", 16), // a'
+                new BigInteger("7A556B6DAE535B7B51ED2C4D7DAA7A0B5C55F380", 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("04B199B13B9B34EFC1397E64BAEB05ACC265FF2378ADD6718B7C7C1961F0991B842443772152C9E0AD")), // G
+                new BigInteger("E95E4A5F737059DC60DF5991D45029409E60FC09", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP192r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger("C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297", 16), // q
+                new BigInteger("6A91174076B1E0E19C39C031FE8685C1CAE040E5C69A28EF", 16), // a
+                new BigInteger("469A28EF7C28CCA3DC721D044F4496BCCA7EF4146FBF25C9", 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("04C0A0647EAAB6A48753B033C56CB0F0900A2F5C4853375FD614B690866ABD5BB88B5F4828C1490002E6773FA2FA299B8F")), // G
+                new BigInteger("C302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP192t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger("1B6F5CC8DB4DC7AF19458A9CB80DC2295E5EB9C3732104CB") //Z
+                new BigInteger("C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297", 16), // q
+                new BigInteger("C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86294", 16), // a'
+                new BigInteger("13D56FFAEC78681E68F9DEB43B35BEC2FB68542E27897B79", 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("043AE9E58C82F63C30282E1FE7BBF43FA72C446AF6F4618129097E2C5667C2223A902AB5CA449D0084B7E5B3DE7CCC01C9")), // G'
+                new BigInteger("C302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP224r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger("D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF", 16), // q
+                new BigInteger("68A5E62CA9CE6C1C299803A6C1530B514E182AD8B0042A59CAD29F43", 16), // a
+                new BigInteger("2580F63CCFE44138870713B1A92369E33E2135D266DBB372386C400B", 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("040D9029AD2C7E5CF4340823B2A87DC68C9E4CE3174C1E6EFDEE12C07D58AA56F772C0726F24C6B89E4ECDAC24354B9E99CAA3F6D3761402CD")), // G
+                new BigInteger("D7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F", 16), //n
+                new BigInteger("01", 16)); // n
+        }
+    };
+    static X9ECParametersHolder brainpoolP224t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger("2DF271E14427A346910CF7A2E6CFA7B3F484E5C2CCE1C8B730E28B3F") //Z
+                new BigInteger("D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF", 16), // q
+                new BigInteger("D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FC", 16), // a'
+                new BigInteger("4B337D934104CD7BEF271BF60CED1ED20DA14C08B3BB64F18A60888D", 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("046AB1E344CE25FF3896424E7FFE14762ECB49F8928AC0C76029B4D5800374E9F5143E568CD23F3F4D7C0D4B1E41C8CC0D1C6ABD5F1A46DB4C")), // G'
+                new BigInteger("D7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP256r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger("A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377", 16), // q
+                new BigInteger("7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9", 16), // a
+                new BigInteger("26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6", 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("048BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997")), // G
+                new BigInteger("A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP256t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger("3E2D4BD9597B58639AE7AA669CAB9837CF5CF20A2C852D10F655668DFC150EF0") //Z
+                new BigInteger("A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377", 16), // q
+                new BigInteger("A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5374", 16), // a'
+                new BigInteger("662C61C430D84EA4FE66A7733D0B76B7BF93EBC4AF2F49256AE58101FEE92B04", 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("04A3E8EB3CC1CFE7B7732213B23A656149AFA142C47AAFBC2B79A191562E1305F42D996C823439C56D7F7B22E14644417E69BCB6DE39D027001DABE8F35B25C9BE")), // G'
+                new BigInteger("A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP320r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger("D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27", 16), // q
+                new BigInteger("3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F492F375A97D860EB4", 16), // a
+                new BigInteger("520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD884539816F5EB4AC8FB1F1A6", 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("0443BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C710AF8D0D39E2061114FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7D35245D1692E8EE1")), // G
+                new BigInteger("D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP320t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger("15F75CAF668077F7E85B42EB01F0A81FF56ECD6191D55CB82B7D861458A18FEFC3E5AB7496F3C7B1") //Z
+                new BigInteger("D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27", 16), // q
+                new BigInteger("D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E24", 16), // a'
+                new BigInteger("A7F561E038EB1ED560B3D147DB782013064C19F27ED27C6780AAF77FB8A547CEB5B4FEF422340353", 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("04925BE9FB01AFC6FB4D3E7D4990010F813408AB106C4F09CB7EE07868CC136FFF3357F624A21BED5263BA3A7A27483EBF6671DBEF7ABB30EBEE084E58A0B077AD42A5A0989D1EE71B1B9BC0455FB0D2C3")), // G'
+                new BigInteger("D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP384r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger("8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53", 16), // q
+                new BigInteger("7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22CE2826", 16), // a
+                new BigInteger("4A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62D57CB4390295DBC9943AB78696FA504C11", 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("041D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315")), // G
+                new BigInteger("8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP384t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger("41DFE8DD399331F7166A66076734A89CD0D2BCDB7D068E44E1F378F41ECBAE97D2D63DBC87BCCDDCCC5DA39E8589291C") //Z
+                new BigInteger("8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53", 16), // q
+                new BigInteger("8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC50", 16), // a'
+                new BigInteger("7F519EADA7BDA81BD826DBA647910F8C4B9346ED8CCDC64E4B1ABD11756DCE1D2074AA263B88805CED70355A33B471EE", 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("0418DE98B02DB9A306F2AFCD7235F72A819B80AB12EBD653172476FECD462AABFFC4FF191B946A5F54D8D0AA2F418808CC25AB056962D30651A114AFD2755AD336747F93475B7A1FCA3B88F2B6A208CCFE469408584DC2B2912675BF5B9E582928")), // G'
+                new BigInteger("8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP512r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger("AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3", 16), // q
+                new BigInteger("7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA", 16), // a
+                new BigInteger("3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723", 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("0481AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F8227DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892")), // G
+                new BigInteger("AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP512t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger("12EE58E6764838B69782136F0F2D3BA06E27695716054092E60A80BEDB212B64E585D90BCE13761F85C3F1D2A64E3BE8FEA2220F01EBA5EEB0F35DBD29D922AB") //Z
+                new BigInteger("AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3", 16), // q
+                new BigInteger("AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F0", 16), // a'
+                new BigInteger("7CBBBCF9441CFAB76E1890E46884EAE321F70C0BCB4981527897504BEC3E36A62BCDFA2304976540F6450085F2DAE145C22553B465763689180EA2571867423E", 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode("04640ECE5C12788717B9C1BA06CBC2A6FEBA85842458C56DDE9DB1758D39C0313D82BA51735CDB3EA499AA77A7D6943A64F7A3F25FE26F06B51BAA2696FA9035DA5B534BD595F5AF0FA2C892376C84ACE1BB4E3019B71634C01131159CAE03CEE9D9932184BEEF216BD71DF2DADF86A627306ECFF96DBB8BACE198B61E00F8B332")), // G'
+                new BigInteger("AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069", 16), //n
+                new BigInteger("01", 16)); // h
+        }
+    };
+
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable curves = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid, X9ECParametersHolder holder)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+        curves.put(oid, holder);
+    }
+
+    static
+    {
+        defineCurve("brainpoolp160r1", TeleTrusTObjectIdentifiers.brainpoolP160r1, brainpoolP160r1);
+        defineCurve("brainpoolp160t1", TeleTrusTObjectIdentifiers.brainpoolP160t1, brainpoolP160t1);
+        defineCurve("brainpoolp192r1", TeleTrusTObjectIdentifiers.brainpoolP192r1, brainpoolP192r1);
+        defineCurve("brainpoolp192t1", TeleTrusTObjectIdentifiers.brainpoolP192t1, brainpoolP192t1);
+        defineCurve("brainpoolp224r1", TeleTrusTObjectIdentifiers.brainpoolP224r1, brainpoolP224r1);
+        defineCurve("brainpoolp224t1", TeleTrusTObjectIdentifiers.brainpoolP224t1, brainpoolP224t1);
+        defineCurve("brainpoolp256r1", TeleTrusTObjectIdentifiers.brainpoolP256r1, brainpoolP256r1);
+        defineCurve("brainpoolp256t1", TeleTrusTObjectIdentifiers.brainpoolP256t1, brainpoolP256t1);
+        defineCurve("brainpoolp320r1", TeleTrusTObjectIdentifiers.brainpoolP320r1, brainpoolP320r1);
+        defineCurve("brainpoolp320t1", TeleTrusTObjectIdentifiers.brainpoolP320t1, brainpoolP320t1);
+        defineCurve("brainpoolp384r1", TeleTrusTObjectIdentifiers.brainpoolP384r1, brainpoolP384r1);
+        defineCurve("brainpoolp384t1", TeleTrusTObjectIdentifiers.brainpoolP384t1, brainpoolP384t1);
+        defineCurve("brainpoolp512r1", TeleTrusTObjectIdentifiers.brainpoolP512r1, brainpoolP512r1);
+        defineCurve("brainpoolp512t1", TeleTrusTObjectIdentifiers.brainpoolP512t1, brainpoolP512t1);
+    }
+
+    public static X9ECParameters getByName(
+        String name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier oid)
+    {
+        X9ECParametersHolder holder = (X9ECParametersHolder)curves.get(oid);
+
+        if (holder != null)
+        {
+            return holder.getParameters();
+        }
+
+        return null;
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+
+    public static DERObjectIdentifier getOID(short curvesize, boolean twisted)
+    {
+        return getOID("brainpoolP" + curvesize + (twisted ? "t" : "r") + "1");
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,42 @@
+package org.bouncycastle.asn1.teletrust;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface TeleTrusTObjectIdentifiers
+{
+    static final ASN1ObjectIdentifier teleTrusTAlgorithm = new ASN1ObjectIdentifier("1.3.36.3");
+
+    static final ASN1ObjectIdentifier    ripemd160           = teleTrusTAlgorithm.branch("2.1");
+    static final ASN1ObjectIdentifier    ripemd128           = teleTrusTAlgorithm.branch("2.2");
+    static final ASN1ObjectIdentifier    ripemd256           = teleTrusTAlgorithm.branch("2.3");
+
+    static final ASN1ObjectIdentifier teleTrusTRSAsignatureAlgorithm = teleTrusTAlgorithm.branch("3.1");
+
+    static final ASN1ObjectIdentifier    rsaSignatureWithripemd160           = teleTrusTRSAsignatureAlgorithm.branch("2");
+    static final ASN1ObjectIdentifier    rsaSignatureWithripemd128           = teleTrusTRSAsignatureAlgorithm.branch("3");
+    static final ASN1ObjectIdentifier    rsaSignatureWithripemd256           = teleTrusTRSAsignatureAlgorithm.branch("4");
+
+    static final ASN1ObjectIdentifier    ecSign = teleTrusTAlgorithm.branch("3.2");
+
+    static final ASN1ObjectIdentifier    ecSignWithSha1  = ecSign.branch("1");
+    static final ASN1ObjectIdentifier    ecSignWithRipemd160  = ecSign.branch("2");
+
+    static final ASN1ObjectIdentifier ecc_brainpool = teleTrusTAlgorithm.branch("3.2.8");
+    static final ASN1ObjectIdentifier ellipticCurve = ecc_brainpool.branch("1");
+    static final ASN1ObjectIdentifier versionOne = ellipticCurve.branch("1");
+
+    static final ASN1ObjectIdentifier brainpoolP160r1 = versionOne.branch("1");
+    static final ASN1ObjectIdentifier brainpoolP160t1 = versionOne.branch("2");
+    static final ASN1ObjectIdentifier brainpoolP192r1 = versionOne.branch("3");
+    static final ASN1ObjectIdentifier brainpoolP192t1 = versionOne.branch("4");
+    static final ASN1ObjectIdentifier brainpoolP224r1 = versionOne.branch("5");
+    static final ASN1ObjectIdentifier brainpoolP224t1 = versionOne.branch("6");
+    static final ASN1ObjectIdentifier brainpoolP256r1 = versionOne.branch("7");
+    static final ASN1ObjectIdentifier brainpoolP256t1 = versionOne.branch("8");
+    static final ASN1ObjectIdentifier brainpoolP320r1 = versionOne.branch("9");
+    static final ASN1ObjectIdentifier brainpoolP320t1 = versionOne.branch("10");
+    static final ASN1ObjectIdentifier brainpoolP384r1 = versionOne.branch("11");
+    static final ASN1ObjectIdentifier brainpoolP384t1 = versionOne.branch("12");
+    static final ASN1ObjectIdentifier brainpoolP512r1 = versionOne.branch("13");
+    static final ASN1ObjectIdentifier brainpoolP512t1 = versionOne.branch("14");
+}

Added: trunk/src/org/bouncycastle/asn1/teletrust/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/teletrust/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/teletrust/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Support classes for TeleTrust related objects.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,71 @@
+package org.bouncycastle.asn1.x500;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class AttributeTypeAndValue
+    extends ASN1Encodable
+{
+    private ASN1ObjectIdentifier type;
+    private ASN1Encodable       value;
+
+    private AttributeTypeAndValue(ASN1Sequence seq)
+    {
+        type = (ASN1ObjectIdentifier)seq.getObjectAt(0);
+        value = (ASN1Encodable)seq.getObjectAt(1);
+    }
+
+    public static AttributeTypeAndValue getInstance(Object o)
+    {
+        if (o instanceof AttributeTypeAndValue)
+        {
+            return (AttributeTypeAndValue)o;
+        }
+        else if (o != null)
+        {
+            return new AttributeTypeAndValue(ASN1Sequence.getInstance(o));
+        }
+
+        throw new IllegalArgumentException("null value in getInstance()");
+    }
+
+    public AttributeTypeAndValue(
+        ASN1ObjectIdentifier type,
+        ASN1Encodable value)
+    {
+        this.type = type;
+        this.value = value;
+    }
+
+    public ASN1ObjectIdentifier getType()
+    {
+        return type;
+    }
+
+    public ASN1Encodable getValue()
+    {
+        return value;
+    }
+
+    /**
+     * <pre>
+     * AttributeTypeAndValue ::= SEQUENCE {
+     *           type         OBJECT IDENTIFIER,
+     *           value        ANY DEFINED BY type }
+     * </pre>
+     * @return a basic ASN.1 object representation.
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(type);
+        v.add(value);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/RDN.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/RDN.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/RDN.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/RDN.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/RDN.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,106 @@
+package org.bouncycastle.asn1.x500;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Set;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.DERSet;
+
+public class RDN
+    extends ASN1Encodable
+{
+    private ASN1Set values;
+
+    private RDN(ASN1Set values)
+    {
+        this.values = values;
+    }
+
+    public static RDN getInstance(Object obj)
+    {
+        if (obj instanceof RDN)
+        {
+            return (RDN)obj;
+        }
+        else if (obj != null)
+        {
+            return new RDN(ASN1Set.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    /**
+     * Create a single valued RDN.
+     *
+     * @param oid
+     * @param value
+     */
+    public RDN(ASN1ObjectIdentifier oid, ASN1Encodable value)
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(oid);
+        v.add(value);
+
+        this.values = new DERSet(new DERSequence(v));
+    }
+
+    public RDN(AttributeTypeAndValue attrTAndV)
+    {
+        this.values = new DERSet(attrTAndV);
+    }
+
+    /**
+     * Create a multi-valued RDN.
+     */
+    public RDN(AttributeTypeAndValue[] aAndVs)
+    {
+        this.values = new DERSet(aAndVs);
+    }
+
+    public boolean isMultiValued()
+    {
+        return this.values.size() > 1;
+    }
+
+    public AttributeTypeAndValue getFirst()
+    {
+        if (this.values.size() == 0)
+        {
+            return null;
+        }
+
+        return AttributeTypeAndValue.getInstance(this.values.getObjectAt(0));
+    }
+
+    public AttributeTypeAndValue[] getTypesAndValues()
+    {
+        AttributeTypeAndValue[] tmp = new AttributeTypeAndValue[values.size()];
+
+        for (int i = 0; i != tmp.length; i++)
+        {
+            tmp[i] = AttributeTypeAndValue.getInstance(values.getObjectAt(i));
+        }
+
+        return tmp;
+    }
+
+    /**
+     * <pre>
+     * RelativeDistinguishedName ::=
+     *                     SET OF AttributeTypeAndValue
+
+     * AttributeTypeAndValue ::= SEQUENCE {
+     *        type     AttributeType,
+     *        value    AttributeValue }
+     * </pre>
+     * @return
+     */
+    public DERObject toASN1Object()
+    {
+        return values;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/X500Name.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/X500Name.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/X500Name.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/X500Name.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/X500Name.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,274 @@
+package org.bouncycastle.asn1.x500;
+
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Choice;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.x500.style.BCStyle;
+import org.bouncycastle.asn1.x509.X509Name;
+
+/**
+ * <pre>
+ *     Name ::= CHOICE {
+ *                       RDNSequence }
+ *
+ *     RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
+ *
+ *     RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
+ *
+ *     AttributeTypeAndValue ::= SEQUENCE {
+ *                                   type  OBJECT IDENTIFIER,
+ *                                   value ANY }
+ * </pre>
+ */
+public class X500Name
+    extends ASN1Encodable
+    implements ASN1Choice
+{
+    private static X500NameStyle    defaultStyle = BCStyle.INSTANCE;
+
+    private boolean                 isHashCodeCalculated;
+    private int                     hashCodeValue;
+
+    private X500NameStyle style;
+    private RDN[] rdns;
+
+//    public X500Name(X500NameStyle style, X500Name name)
+//    {
+//        this.rdns = name.rdns;
+//        this.style = style;
+//    }
+
+    /**
+     * Return a X509Name based on the passed in tagged object.
+     *
+     * @param obj tag object holding name.
+     * @param explicit true if explicitly tagged false otherwise.
+     * @return the X509Name
+     */
+    public static X500Name getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        // must be true as choice item
+        return getInstance(ASN1Sequence.getInstance(obj, true));
+    }
+
+    public static X500Name getInstance(
+        Object  obj)
+    {
+        if (obj instanceof X500Name)
+        {
+            return (X500Name)obj;
+        }
+        else if (obj instanceof X509Name)
+        {
+            return new X500Name(ASN1Sequence.getInstance(((X509Name)obj).getDERObject()));
+        }
+        else if (obj != null)
+        {
+            return new X500Name(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    /**
+     * Constructor from ASN1Sequence
+     *
+     * the principal will be a list of constructed sets, each containing an (OID, String) pair.
+     */
+    private X500Name(
+        ASN1Sequence  seq)
+    {
+        this(defaultStyle, seq);
+    }
+
+    private X500Name(
+        X500NameStyle style,
+        ASN1Sequence  seq)
+    {
+        this.style = style;
+        this.rdns = new RDN[seq.size()];
+
+        int index = 0;
+
+        for (Enumeration e = seq.getObjects(); e.hasMoreElements();)
+        {
+            rdns[index++] = RDN.getInstance(e.nextElement());
+        }
+    }
+
+    public X500Name(
+        RDN[] rDNs)
+    {
+        this(defaultStyle, rDNs);
+    }
+
+    public X500Name(
+        X500NameStyle style,
+        RDN[]         rDNs)
+    {
+        this.rdns = rDNs;
+        this.style = style;
+    }
+
+    public X500Name(
+        String dirName)
+    {
+        this(defaultStyle, dirName);
+    }
+
+    public X500Name(
+        X500NameStyle style,
+        String        dirName)
+    {
+        this(style.fromString(dirName));
+
+        this.style = style;
+    }
+
+    /**
+     * return an array of RDNs in structure order.
+     *
+     * @return an array of RDN objects.
+     */
+    public RDN[] getRDNs()
+    {
+        RDN[] tmp = new RDN[this.rdns.length];
+
+        System.arraycopy(rdns, 0, tmp, 0, tmp.length);
+
+        return tmp;
+    }
+
+    /**
+     * return an array of RDNs containing the attribute type given by OID in structure order.
+     *
+     * @param oid the type OID we are looking for.
+     * @return an array, possibly zero length, of RDN objects.
+     */
+    public RDN[] getRDNs(ASN1ObjectIdentifier oid)
+    {
+        RDN[] res = new RDN[rdns.length];
+        int   count = 0;
+
+        for (int i = 0; i != rdns.length; i++)
+        {
+            RDN rdn = rdns[i];
+
+            if (rdn.isMultiValued())
+            {
+                AttributeTypeAndValue[] attr = rdn.getTypesAndValues();
+                for (int j = 0; j != attr.length; j++)
+                {
+                    if (attr[j].getType().equals(oid))
+                    {
+                        res[count++] = rdn;
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                if (rdn.getFirst().getType().equals(oid))
+                {
+                    res[count++] = rdn;
+                }
+            }
+        }
+
+        RDN[] tmp = new RDN[count];
+
+        System.arraycopy(res, 0, tmp, 0, tmp.length);
+
+        return tmp;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return new DERSequence(rdns);
+    }
+
+    public int hashCode()
+    {
+        if (isHashCodeCalculated)
+        {
+            return hashCodeValue;
+        }
+
+        isHashCodeCalculated = true;
+
+        hashCodeValue = style.calculateHashCode(this);
+
+        return hashCodeValue;
+    }
+
+    /**
+     * test for equality - note: case is ignored.
+     */
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+
+        if (!(obj instanceof X500Name || obj instanceof ASN1Sequence))
+        {
+            return false;
+        }
+
+        DERObject derO = ((DEREncodable)obj).getDERObject();
+
+        if (this.getDERObject().equals(derO))
+        {
+            return true;
+        }
+
+        try
+        {
+            return style.areEqual(this, new X500Name(ASN1Sequence.getInstance(((DEREncodable)obj).getDERObject())));
+        }
+        catch (Exception e)
+        {
+            return false;
+        }
+    }
+
+    public String toString()
+    {
+        return style.toString(this);
+    }
+
+    /**
+     * Set the default style for X500Name construction.
+     *
+     * @param style  an X500NameStyle
+     */
+    public static void setDefaultStyle(X500NameStyle style)
+    {
+        if (style == null)
+        {
+            throw new NullPointerException("cannot set style to null");
+        }
+
+        defaultStyle = style;
+    }
+
+    /**
+     * Return the current default style.
+     *
+     * @return default style for X500Name construction.
+     */
+    public static X500NameStyle getDefaultStyle()
+    {
+        return defaultStyle;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,81 @@
+package org.bouncycastle.asn1.x500;
+
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public class X500NameBuilder
+{
+    private X500NameStyle template;
+    private Vector rdns = new Vector();
+
+    public X500NameBuilder(X500NameStyle template)
+    {
+        this.template = template;
+    }
+
+    public X500NameBuilder addRDN(ASN1ObjectIdentifier oid, String value)
+    {
+        this.addRDN(oid, template.stringToValue(oid, value));
+
+        return this;
+    }
+
+    public X500NameBuilder addRDN(ASN1ObjectIdentifier oid, ASN1Encodable value)
+    {
+        rdns.addElement(new RDN(oid, value));
+
+        return this;
+    }
+
+    public X500NameBuilder addRDN(AttributeTypeAndValue attrTAndV)
+    {
+        rdns.addElement(new RDN(attrTAndV));
+
+        return this;
+    }
+
+    public X500NameBuilder addMultiValuedRDN(ASN1ObjectIdentifier[] oids, String[] values)
+    {
+        ASN1Encodable[] vals = new ASN1Encodable[values.length];
+
+        for (int i = 0; i != vals.length; i++)
+        {
+            vals[i] = template.stringToValue(oids[i], values[i]);
+        }
+
+        return addMultiValuedRDN(oids, vals);
+    }
+
+    public X500NameBuilder addMultiValuedRDN(ASN1ObjectIdentifier[] oids, ASN1Encodable[] values)
+    {
+        AttributeTypeAndValue[] avs = new AttributeTypeAndValue[oids.length];
+
+        for (int i = 0; i != oids.length; i++)
+        {
+            avs[i] = new AttributeTypeAndValue(oids[i], values[i]);
+        }
+
+        return addMultiValuedRDN(avs);
+    }
+
+    public X500NameBuilder addMultiValuedRDN(AttributeTypeAndValue[] attrTAndVs)
+    {
+        rdns.addElement(new RDN(attrTAndVs));
+
+        return this;
+    }
+
+    public X500Name build()
+    {
+        RDN[] vals = new RDN[rdns.size()];
+
+        for (int i = 0; i != vals.length; i++)
+        {
+            vals[i] = (RDN)rdns.elementAt(i);
+        }
+
+        return new X500Name(template, vals);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,34 @@
+package org.bouncycastle.asn1.x500;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+/**
+ * It turns out that the number of standard ways the fields in a DN should be 
+ * encoded into their ASN.1 counterparts is rapidly approaching the
+ * number of machines on the internet. By default the X500Name class
+ * will produce UTF8Strings in line with the current recommendations (RFC 3280).
+ * <p>
+ */
+public interface X500NameStyle
+{
+    /**
+     * Convert the passed in String value into the appropriate ASN.1
+     * encoded object.
+     * 
+     * @param oid the oid associated with the value in the DN.
+     * @param value the value of the particular DN component.
+     * @return the ASN.1 equivalent for the value.
+     */
+    ASN1Encodable stringToValue(ASN1ObjectIdentifier oid, String value);
+
+    ASN1ObjectIdentifier attrNameToOID(String attrName);
+
+    boolean areEqual(X500Name name1, X500Name name2);
+
+    RDN[] fromString(String dirName);
+
+    int calculateHashCode(X500Name name);
+
+    String toString(X500Name name);
+}

Added: trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,544 @@
+package org.bouncycastle.asn1.x500.style;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.DERGeneralizedTime;
+import org.bouncycastle.asn1.DERIA5String;
+import org.bouncycastle.asn1.DERPrintableString;
+import org.bouncycastle.asn1.DERUTF8String;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+import org.bouncycastle.asn1.x500.AttributeTypeAndValue;
+import org.bouncycastle.asn1.x500.RDN;
+import org.bouncycastle.asn1.x500.X500Name;
+import org.bouncycastle.asn1.x500.X500NameStyle;
+import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
+
+public class BCStyle
+    implements X500NameStyle
+{
+    public static final X500NameStyle INSTANCE = new BCStyle();
+
+    /**
+     * country code - StringType(SIZE(2))
+     */
+    public static final ASN1ObjectIdentifier C = new ASN1ObjectIdentifier("2.5.4.6");
+
+    /**
+     * organization - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier O = new ASN1ObjectIdentifier("2.5.4.10");
+
+    /**
+     * organizational unit name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier OU = new ASN1ObjectIdentifier("2.5.4.11");
+
+    /**
+     * Title
+     */
+    public static final ASN1ObjectIdentifier T = new ASN1ObjectIdentifier("2.5.4.12");
+
+    /**
+     * common name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier CN = new ASN1ObjectIdentifier("2.5.4.3");
+
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier SN = new ASN1ObjectIdentifier("2.5.4.5");
+
+    /**
+     * street - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier STREET = new ASN1ObjectIdentifier("2.5.4.9");
+
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier SERIALNUMBER = SN;
+
+    /**
+     * locality name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier L = new ASN1ObjectIdentifier("2.5.4.7");
+
+    /**
+     * state, or province name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier ST = new ASN1ObjectIdentifier("2.5.4.8");
+
+    /**
+     * Naming attributes of type X520name
+     */
+    public static final ASN1ObjectIdentifier SURNAME = new ASN1ObjectIdentifier("2.5.4.4");
+    public static final ASN1ObjectIdentifier GIVENNAME = new ASN1ObjectIdentifier("2.5.4.42");
+    public static final ASN1ObjectIdentifier INITIALS = new ASN1ObjectIdentifier("2.5.4.43");
+    public static final ASN1ObjectIdentifier GENERATION = new ASN1ObjectIdentifier("2.5.4.44");
+    public static final ASN1ObjectIdentifier UNIQUE_IDENTIFIER = new ASN1ObjectIdentifier("2.5.4.45");
+
+    /**
+     * businessCategory - DirectoryString(SIZE(1..128)
+     */
+    public static final ASN1ObjectIdentifier BUSINESS_CATEGORY = new ASN1ObjectIdentifier(
+        "2.5.4.15");
+
+    /**
+     * postalCode - DirectoryString(SIZE(1..40)
+     */
+    public static final ASN1ObjectIdentifier POSTAL_CODE = new ASN1ObjectIdentifier(
+        "2.5.4.17");
+
+    /**
+     * dnQualifier - DirectoryString(SIZE(1..64)
+     */
+    public static final ASN1ObjectIdentifier DN_QUALIFIER = new ASN1ObjectIdentifier(
+        "2.5.4.46");
+
+    /**
+     * RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
+     */
+    public static final ASN1ObjectIdentifier PSEUDONYM = new ASN1ObjectIdentifier(
+        "2.5.4.65");
+
+
+    /**
+     * RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
+     */
+    public static final ASN1ObjectIdentifier DATE_OF_BIRTH = new ASN1ObjectIdentifier(
+        "1.3.6.1.5.5.7.9.1");
+
+    /**
+     * RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
+     */
+    public static final ASN1ObjectIdentifier PLACE_OF_BIRTH = new ASN1ObjectIdentifier(
+        "1.3.6.1.5.5.7.9.2");
+
+    /**
+     * RFC 3039 Gender - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
+     */
+    public static final ASN1ObjectIdentifier GENDER = new ASN1ObjectIdentifier(
+        "1.3.6.1.5.5.7.9.3");
+
+    /**
+     * RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final ASN1ObjectIdentifier COUNTRY_OF_CITIZENSHIP = new ASN1ObjectIdentifier(
+        "1.3.6.1.5.5.7.9.4");
+
+    /**
+     * RFC 3039 CountryOfResidence - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final ASN1ObjectIdentifier COUNTRY_OF_RESIDENCE = new ASN1ObjectIdentifier(
+        "1.3.6.1.5.5.7.9.5");
+
+
+    /**
+     * ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
+     */
+    public static final ASN1ObjectIdentifier NAME_AT_BIRTH = new ASN1ObjectIdentifier("1.3.36.8.3.14");
+
+    /**
+     * RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
+     * DirectoryString(SIZE(1..30))
+     */
+    public static final ASN1ObjectIdentifier POSTAL_ADDRESS = new ASN1ObjectIdentifier("2.5.4.16");
+
+    /**
+     * RFC 2256 dmdName
+     */
+    public static final ASN1ObjectIdentifier DMD_NAME = new ASN1ObjectIdentifier("2.5.4.54");
+
+    /**
+     * id-at-telephoneNumber
+     */
+    public static final ASN1ObjectIdentifier TELEPHONE_NUMBER = X509ObjectIdentifiers.id_at_telephoneNumber;
+
+    /**
+     * id-at-name
+     */
+    public static final ASN1ObjectIdentifier NAME = X509ObjectIdentifiers.id_at_name;
+
+    /**
+     * Email address (RSA PKCS#9 extension) - IA5String.
+     * <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.
+     */
+    public static final ASN1ObjectIdentifier EmailAddress = PKCSObjectIdentifiers.pkcs_9_at_emailAddress;
+
+    /**
+     * more from PKCS#9
+     */
+    public static final ASN1ObjectIdentifier UnstructuredName = PKCSObjectIdentifiers.pkcs_9_at_unstructuredName;
+    public static final ASN1ObjectIdentifier UnstructuredAddress = PKCSObjectIdentifiers.pkcs_9_at_unstructuredAddress;
+
+    /**
+     * email address in Verisign certificates
+     */
+    public static final ASN1ObjectIdentifier E = EmailAddress;
+
+    /*
+    * others...
+    */
+    public static final ASN1ObjectIdentifier DC = new ASN1ObjectIdentifier("0.9.2342.19200300.100.1.25");
+
+    /**
+     * LDAP User id.
+     */
+    public static final ASN1ObjectIdentifier UID = new ASN1ObjectIdentifier("0.9.2342.19200300.100.1.1");
+
+    /**
+     * default look up table translating OID values into their common symbols following
+     * the convention in RFC 2253 with a few extras
+     */
+    private static final Hashtable DefaultSymbols = new Hashtable();
+
+    /**
+     * look up table translating common symbols into their OIDS.
+     */
+    private static final Hashtable DefaultLookUp = new Hashtable();
+
+    static
+    {
+        DefaultSymbols.put(C, "C");
+        DefaultSymbols.put(O, "O");
+        DefaultSymbols.put(T, "T");
+        DefaultSymbols.put(OU, "OU");
+        DefaultSymbols.put(CN, "CN");
+        DefaultSymbols.put(L, "L");
+        DefaultSymbols.put(ST, "ST");
+        DefaultSymbols.put(SN, "SERIALNUMBER");
+        DefaultSymbols.put(EmailAddress, "E");
+        DefaultSymbols.put(DC, "DC");
+        DefaultSymbols.put(UID, "UID");
+        DefaultSymbols.put(STREET, "STREET");
+        DefaultSymbols.put(SURNAME, "SURNAME");
+        DefaultSymbols.put(GIVENNAME, "GIVENNAME");
+        DefaultSymbols.put(INITIALS, "INITIALS");
+        DefaultSymbols.put(GENERATION, "GENERATION");
+        DefaultSymbols.put(UnstructuredAddress, "unstructuredAddress");
+        DefaultSymbols.put(UnstructuredName, "unstructuredName");
+        DefaultSymbols.put(UNIQUE_IDENTIFIER, "UniqueIdentifier");
+        DefaultSymbols.put(DN_QUALIFIER, "DN");
+        DefaultSymbols.put(PSEUDONYM, "Pseudonym");
+        DefaultSymbols.put(POSTAL_ADDRESS, "PostalAddress");
+        DefaultSymbols.put(NAME_AT_BIRTH, "NameAtBirth");
+        DefaultSymbols.put(COUNTRY_OF_CITIZENSHIP, "CountryOfCitizenship");
+        DefaultSymbols.put(COUNTRY_OF_RESIDENCE, "CountryOfResidence");
+        DefaultSymbols.put(GENDER, "Gender");
+        DefaultSymbols.put(PLACE_OF_BIRTH, "PlaceOfBirth");
+        DefaultSymbols.put(DATE_OF_BIRTH, "DateOfBirth");
+        DefaultSymbols.put(POSTAL_CODE, "PostalCode");
+        DefaultSymbols.put(BUSINESS_CATEGORY, "BusinessCategory");
+        DefaultSymbols.put(TELEPHONE_NUMBER, "TelephoneNumber");
+        DefaultSymbols.put(NAME, "Name");
+
+        DefaultLookUp.put("c", C);
+        DefaultLookUp.put("o", O);
+        DefaultLookUp.put("t", T);
+        DefaultLookUp.put("ou", OU);
+        DefaultLookUp.put("cn", CN);
+        DefaultLookUp.put("l", L);
+        DefaultLookUp.put("st", ST);
+        DefaultLookUp.put("sn", SN);
+        DefaultLookUp.put("serialnumber", SN);
+        DefaultLookUp.put("street", STREET);
+        DefaultLookUp.put("emailaddress", E);
+        DefaultLookUp.put("dc", DC);
+        DefaultLookUp.put("e", E);
+        DefaultLookUp.put("uid", UID);
+        DefaultLookUp.put("surname", SURNAME);
+        DefaultLookUp.put("givenname", GIVENNAME);
+        DefaultLookUp.put("initials", INITIALS);
+        DefaultLookUp.put("generation", GENERATION);
+        DefaultLookUp.put("unstructuredaddress", UnstructuredAddress);
+        DefaultLookUp.put("unstructuredname", UnstructuredName);
+        DefaultLookUp.put("uniqueidentifier", UNIQUE_IDENTIFIER);
+        DefaultLookUp.put("dn", DN_QUALIFIER);
+        DefaultLookUp.put("pseudonym", PSEUDONYM);
+        DefaultLookUp.put("postaladdress", POSTAL_ADDRESS);
+        DefaultLookUp.put("nameofbirth", NAME_AT_BIRTH);
+        DefaultLookUp.put("countryofcitizenship", COUNTRY_OF_CITIZENSHIP);
+        DefaultLookUp.put("countryofresidence", COUNTRY_OF_RESIDENCE);
+        DefaultLookUp.put("gender", GENDER);
+        DefaultLookUp.put("placeofbirth", PLACE_OF_BIRTH);
+        DefaultLookUp.put("dateofbirth", DATE_OF_BIRTH);
+        DefaultLookUp.put("postalcode", POSTAL_CODE);
+        DefaultLookUp.put("businesscategory", BUSINESS_CATEGORY);
+        DefaultLookUp.put("telephonenumber", TELEPHONE_NUMBER);
+        DefaultLookUp.put("name", NAME);
+    }
+
+    protected BCStyle()
+    {
+
+    }
+    
+    public ASN1Encodable stringToValue(ASN1ObjectIdentifier oid, String value)
+    {
+        if (value.length() != 0 && value.charAt(0) == '#')
+        {
+            try
+            {
+                return IETFUtils.valueFromHexString(value, 1);
+            }
+            catch (IOException e)
+            {
+                throw new RuntimeException("can't recode value for oid " + oid.getId());
+            }
+        }
+        else
+        {
+            if (value.length() != 0 && value.charAt(0) == '\\')
+            {
+                value = value.substring(1);
+            }
+            if (oid.equals(EmailAddress) || oid.equals(DC))
+            {
+                return new DERIA5String(value);
+            }
+            else if (oid.equals(DATE_OF_BIRTH))  // accept time string as well as # (for compatibility)
+            {
+                return new DERGeneralizedTime(value);
+            }
+            else if (oid.equals(C) || oid.equals(SN) || oid.equals(DN_QUALIFIER)
+                || oid.equals(TELEPHONE_NUMBER))
+            {
+                return new DERPrintableString(value);
+            }
+        }
+
+        return new DERUTF8String(value);
+    }
+
+    public ASN1ObjectIdentifier attrNameToOID(String attrName)
+    {
+        return IETFUtils.decodeAttrName(attrName, DefaultLookUp);
+    }
+
+    public boolean areEqual(X500Name name1, X500Name name2)
+    {
+        RDN[] rdns1 = name1.getRDNs();
+        RDN[] rdns2 = name2.getRDNs();
+
+        if (rdns1.length != rdns2.length)
+        {
+            return false;
+        }
+
+        boolean reverse = false;
+
+        if (rdns1[0].getFirst() != null && rdns2[0].getFirst() != null)
+        {
+            reverse = !rdns1[0].getFirst().getType().equals(rdns2[0].getFirst().getType());  // guess forward
+        }
+
+        for (int i = 0; i != rdns1.length; i++)
+        {
+            if (!foundMatch(reverse, rdns1[i], rdns2))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean foundMatch(boolean reverse, RDN rdn, RDN[] possRDNs)
+    {
+        if (reverse)
+        {
+            for (int i = possRDNs.length - 1; i >= 0; i--)
+            {
+                if (possRDNs[i] != null && rdnAreEqual(rdn, possRDNs[i]))
+                {
+                    possRDNs[i] = null;
+                    return true;
+                }
+            }
+        }
+        else
+        {
+            for (int i = 0; i != possRDNs.length; i++)
+            {
+                if (possRDNs[i] != null && rdnAreEqual(rdn, possRDNs[i]))
+                {
+                    possRDNs[i] = null;
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected boolean rdnAreEqual(RDN rdn1, RDN rdn2)
+    {
+        if (rdn1.isMultiValued())
+        {
+            if (rdn2.isMultiValued())
+            {
+                AttributeTypeAndValue[] atvs1 = rdn1.getTypesAndValues();
+                AttributeTypeAndValue[] atvs2 = rdn2.getTypesAndValues();
+
+                if (atvs1.length != atvs2.length)
+                {
+                    return false;
+                }
+
+                for (int i = 0; i != atvs1.length; i++)
+                {
+                    if (!atvAreEqual(atvs1[i], atvs2[i]))
+                    {
+                        return false;
+                    }
+                }
+            }
+            else
+            {
+                return false;
+            }
+        }
+        else
+        {
+            if (!rdn2.isMultiValued())
+            {
+                return atvAreEqual(rdn1.getFirst(), rdn2.getFirst());
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean atvAreEqual(AttributeTypeAndValue atv1, AttributeTypeAndValue atv2)
+    {
+        if (atv1 == atv2)
+        {
+            return true;
+        }
+
+        if (atv1 == null)
+        {
+            return false;
+        }
+
+        if (atv2 == null)
+        {
+            return false;
+        }
+
+        ASN1ObjectIdentifier o1 = atv1.getType();
+        ASN1ObjectIdentifier o2 = atv2.getType();
+
+        if (!o1.equals(o2))
+        {
+            return false;
+        }
+
+        String v1 = IETFUtils.canonicalize(IETFUtils.valueToString(atv1.getValue()));
+        String v2 = IETFUtils.canonicalize(IETFUtils.valueToString(atv2.getValue()));
+
+        if (!v1.equals(v2))
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    public RDN[] fromString(String dirName)
+    {
+        return IETFUtils.rDNsFromString(dirName, this);
+    }
+
+    public int calculateHashCode(X500Name name)
+    {
+        int hashCodeValue = 0;
+        RDN[] rdns = name.getRDNs();
+
+        // this needs to be order independent, like equals
+        for (int i = 0; i != rdns.length; i++)
+        {
+            if (rdns[i].isMultiValued())
+            {
+                AttributeTypeAndValue[] atv = rdns[i].getTypesAndValues();
+
+                for (int j = 0; j != atv.length; j++)
+                {
+                    hashCodeValue ^= atv[j].getType().hashCode();
+                    hashCodeValue ^= calcHashCode(atv[j].getValue());
+                }
+            }
+            else
+            {
+                hashCodeValue ^= rdns[i].getFirst().getType().hashCode();
+                hashCodeValue ^= calcHashCode(rdns[i].getFirst().getValue());
+            }
+        }
+
+        return hashCodeValue;
+    }
+
+    private int calcHashCode(ASN1Encodable enc)
+    {
+        String value = IETFUtils.valueToString(enc);
+
+        value = IETFUtils.canonicalize(value);
+
+        return value.hashCode();
+    }
+
+    public String toString(X500Name name)
+    {
+        StringBuffer buf = new StringBuffer();
+        boolean first = true;
+
+        RDN[] rdns = name.getRDNs();
+
+        for (int i = 0; i < rdns.length; i++)
+        {
+            if (first)
+            {
+                first = false;
+            }
+            else
+            {
+                buf.append(',');
+            }
+
+            if (rdns[i].isMultiValued())
+            {
+                AttributeTypeAndValue[] atv = rdns[i].getTypesAndValues();
+                boolean firstAtv = true;
+
+                for (int j = 0; j != atv.length; j++)
+                {
+                    if (firstAtv)
+                    {
+                        firstAtv = false;
+                    }
+                    else
+                    {
+                        buf.append('+');
+                    }
+                    
+                    IETFUtils.appendTypeAndValue(buf, atv[j], DefaultSymbols);
+                }
+            }
+            else
+            {
+                IETFUtils.appendTypeAndValue(buf, rdns[i].getFirst(), DefaultSymbols);
+            }
+        }
+
+        return buf.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,294 @@
+package org.bouncycastle.asn1.x500.style;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1String;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERUniversalString;
+import org.bouncycastle.asn1.x500.AttributeTypeAndValue;
+import org.bouncycastle.asn1.x500.RDN;
+import org.bouncycastle.asn1.x500.X500NameBuilder;
+import org.bouncycastle.asn1.x500.X500NameStyle;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+public class IETFUtils
+{
+    public static RDN[] rDNsFromString(String name, X500NameStyle x500Style)
+    {
+        X500NameTokenizer nTok = new X500NameTokenizer(name);
+        X500NameBuilder builder = new X500NameBuilder(x500Style);
+
+        while (nTok.hasMoreTokens())
+        {
+            String  token = nTok.nextToken();
+            int     index = token.indexOf('=');
+
+            if (index == -1)
+            {
+                throw new IllegalArgumentException("badly formated directory string");
+            }
+
+            String               attr = token.substring(0, index);
+            String               value = token.substring(index + 1);
+            ASN1ObjectIdentifier oid = x500Style.attrNameToOID(attr);
+
+            if (value.indexOf('+') > 0)
+            {
+                X500NameTokenizer   vTok = new X500NameTokenizer(value, '+');
+                String  v = vTok.nextToken();
+
+                Vector oids = new Vector();
+                Vector values = new Vector();
+
+                oids.addElement(oid);
+                values.addElement(v);
+
+                while (vTok.hasMoreTokens())
+                {
+                    String  sv = vTok.nextToken();
+                    int     ndx = sv.indexOf('=');
+
+                    String  nm = sv.substring(0, ndx);
+                    String  vl = sv.substring(ndx + 1);
+
+                    oids.addElement(x500Style.attrNameToOID(nm));
+                    values.addElement(vl);
+                }
+
+                builder.addMultiValuedRDN(toOIDArray(oids), toValueArray(values));
+            }
+            else
+            {
+                builder.addRDN(oid, value);
+            }
+        }
+
+        return builder.build().getRDNs();
+    }
+
+    private static String[] toValueArray(Vector values)
+    {
+        String[] tmp = new String[values.size()];
+
+        for (int i = 0; i != tmp.length; i++)
+        {
+            tmp[i] = (String)values.elementAt(i);
+        }
+
+        return tmp;
+    }
+
+    private static ASN1ObjectIdentifier[] toOIDArray(Vector oids)
+    {
+        ASN1ObjectIdentifier[] tmp = new ASN1ObjectIdentifier[oids.size()];
+
+        for (int i = 0; i != tmp.length; i++)
+        {
+            tmp[i] = (ASN1ObjectIdentifier)oids.elementAt(i);
+        }
+
+        return tmp;
+    }
+
+    public static ASN1ObjectIdentifier decodeAttrName(
+        String      name,
+        Hashtable   lookUp)
+    {
+        if (Strings.toUpperCase(name).startsWith("OID."))
+        {
+            return new ASN1ObjectIdentifier(name.substring(4));
+        }
+        else if (name.charAt(0) >= '0' && name.charAt(0) <= '9')
+        {
+            return new ASN1ObjectIdentifier(name);
+        }
+
+        ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier)lookUp.get(Strings.toLowerCase(name));
+        if (oid == null)
+        {
+            throw new IllegalArgumentException("Unknown object id - " + name + " - passed to distinguished name");
+        }
+
+        return oid;
+    }
+
+    public static ASN1Encodable valueFromHexString(
+        String  str,
+        int     off)
+        throws IOException
+    {
+        str = Strings.toLowerCase(str);
+        byte[] data = new byte[(str.length() - off) / 2];
+        for (int index = 0; index != data.length; index++)
+        {
+            char left = str.charAt((index * 2) + off);
+            char right = str.charAt((index * 2) + off + 1);
+
+            if (left < 'a')
+            {
+                data[index] = (byte)((left - '0') << 4);
+            }
+            else
+            {
+                data[index] = (byte)((left - 'a' + 10) << 4);
+            }
+            if (right < 'a')
+            {
+                data[index] |= (byte)(right - '0');
+            }
+            else
+            {
+                data[index] |= (byte)(right - 'a' + 10);
+            }
+        }
+
+        return ASN1Object.fromByteArray(data);
+    }
+
+    public static void appendTypeAndValue(
+        StringBuffer          buf,
+        AttributeTypeAndValue typeAndValue,
+        Hashtable             oidSymbols)
+    {
+        String  sym = (String)oidSymbols.get(typeAndValue.getType());
+
+        if (sym != null)
+        {
+            buf.append(sym);
+        }
+        else
+        {
+            buf.append(typeAndValue.getType().getId());
+        }
+
+        buf.append('=');
+
+        buf.append(valueToString(typeAndValue.getValue()));
+    }
+
+    public static String valueToString(ASN1Encodable value)
+    {
+        StringBuffer vBuf = new StringBuffer();
+
+        if (value instanceof ASN1String && !(value instanceof DERUniversalString))
+        {
+            String v = ((ASN1String)value).getString();
+            if (v.length() > 0 && v.charAt(0) == '#')
+            {
+                vBuf.append("\\" + v);
+            }
+            else
+            {
+                vBuf.append(v);
+            }
+        }
+        else
+        {
+            vBuf.append("#" + bytesToString(Hex.encode(value.getDERObject().getDEREncoded())));
+        }
+
+        int     end = vBuf.length();
+        int     index = 0;
+
+        if (vBuf.length() >= 2 && vBuf.charAt(0) == '\\' && vBuf.charAt(1) == '#')
+        {
+            index += 2;
+        }
+
+        while (index != end)
+        {
+            if ((vBuf.charAt(index) == ',')
+               || (vBuf.charAt(index) == '"')
+               || (vBuf.charAt(index) == '\\')
+               || (vBuf.charAt(index) == '+')
+               || (vBuf.charAt(index) == '=')
+               || (vBuf.charAt(index) == '<')
+               || (vBuf.charAt(index) == '>')
+               || (vBuf.charAt(index) == ';'))
+            {
+                vBuf.insert(index, "\\");
+                index++;
+                end++;
+            }
+
+            index++;
+        }
+
+        return vBuf.toString();
+    }
+
+    private static String bytesToString(
+        byte[] data)
+    {
+        char[]  cs = new char[data.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(data[i] & 0xff);
+        }
+
+        return new String(cs);
+    }
+
+    public static String canonicalize(String s)
+    {
+        String value = Strings.toLowerCase(s.trim());
+
+        if (value.length() > 0 && value.charAt(0) == '#')
+        {
+            DERObject obj = decodeObject(value);
+
+            if (obj instanceof ASN1String)
+            {
+                value = Strings.toLowerCase(((ASN1String)obj).getString().trim());
+            }
+        }
+
+        value = stripInternalSpaces(value);
+
+        return value;
+    }
+
+    private static ASN1Object decodeObject(String oValue)
+    {
+        try
+        {
+            return ASN1Object.fromByteArray(Hex.decode(oValue.substring(1)));
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException("unknown encoding in name: " + e);
+        }
+    }
+
+    public static String stripInternalSpaces(
+        String str)
+    {
+        StringBuffer res = new StringBuffer();
+
+        if (str.length() != 0)
+        {
+            char c1 = str.charAt(0);
+
+            res.append(c1);
+
+            for (int k = 1; k < str.length(); k++)
+            {
+                char c2 = str.charAt(k);
+                if (!(c1 == ' ' && c2 == ' '))
+                {
+                    res.append(c2);
+                }
+                c1 = c2;
+            }
+        }
+
+        return res.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,99 @@
+package org.bouncycastle.asn1.x500.style;
+
+/**
+ * class for breaking up an X500 Name into it's component tokens, ala
+ * java.util.StringTokenizer. We need this class as some of the
+ * lightweight Java environment don't support classes like
+ * StringTokenizer.
+ */
+class X500NameTokenizer
+{
+    private String          value;
+    private int             index;
+    private char            seperator;
+    private StringBuffer    buf = new StringBuffer();
+
+    public X500NameTokenizer(
+        String  oid)
+    {
+        this(oid, ',');
+    }
+    
+    public X500NameTokenizer(
+        String  oid,
+        char    seperator)
+    {
+        this.value = oid;
+        this.index = -1;
+        this.seperator = seperator;
+    }
+
+    public boolean hasMoreTokens()
+    {
+        return (index != value.length());
+    }
+
+    public String nextToken()
+    {
+        if (index == value.length())
+        {
+            return null;
+        }
+
+        int     end = index + 1;
+        boolean quoted = false;
+        boolean escaped = false;
+
+        buf.setLength(0);
+
+        while (end != value.length())
+        {
+            char    c = value.charAt(end);
+
+            if (c == '"')
+            {
+                if (!escaped)
+                {
+                    quoted = !quoted;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+                escaped = false;
+            }
+            else
+            {
+                if (escaped || quoted)
+                {
+                    if (c == '#' && buf.charAt(buf.length() - 1) == '=')
+                    {
+                        buf.append('\\');
+                    }
+                    else if (c == '+' && seperator != '+')
+                    {
+                        buf.append('\\');
+                    }
+                    buf.append(c);
+                    escaped = false;
+                }
+                else if (c == '\\')
+                {
+                    escaped = true;
+                }
+                else if (c == seperator)
+                {
+                    break;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+            }
+            end++;
+        }
+
+        index = end;
+        return buf.toString().trim();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,144 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERNull;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+
+public class AlgorithmIdentifier
+    extends ASN1Encodable
+{
+    private DERObjectIdentifier objectId;
+    private DEREncodable        parameters;
+    private boolean             parametersDefined = false;
+
+    public static AlgorithmIdentifier getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+    
+    public static AlgorithmIdentifier getInstance(
+        Object  obj)
+    {
+        if (obj== null || obj instanceof AlgorithmIdentifier)
+        {
+            return (AlgorithmIdentifier)obj;
+        }
+        
+        if (obj instanceof DERObjectIdentifier)
+        {
+            return new AlgorithmIdentifier((DERObjectIdentifier)obj);
+        }
+
+        if (obj instanceof String)
+        {
+            return new AlgorithmIdentifier((String)obj);
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new AlgorithmIdentifier((ASN1Sequence)obj);
+        }
+
+        throw new IllegalArgumentException("unknown object in factory: " + obj.getClass().getName());
+    }
+
+    public AlgorithmIdentifier(
+        DERObjectIdentifier     objectId)
+    {
+        this.objectId = objectId;
+    }
+
+    public AlgorithmIdentifier(
+        String     objectId)
+    {
+        this.objectId = new DERObjectIdentifier(objectId);
+    }
+
+    public AlgorithmIdentifier(
+        DERObjectIdentifier     objectId,
+        DEREncodable            parameters)
+    {
+        parametersDefined = true;
+        this.objectId = objectId;
+        this.parameters = parameters;
+    }
+
+    public AlgorithmIdentifier(
+        ASN1Sequence   seq)
+    {
+        if (seq.size() < 1 || seq.size() > 2)
+        {
+            throw new IllegalArgumentException("Bad sequence size: "
+                    + seq.size());
+        }
+        
+        objectId = DERObjectIdentifier.getInstance(seq.getObjectAt(0));
+
+        if (seq.size() == 2)
+        {
+            parametersDefined = true;
+            parameters = seq.getObjectAt(1);
+        }
+        else
+        {
+            parameters = null;
+        }
+    }
+
+    public ASN1ObjectIdentifier getAlgorithm()
+    {
+        return new ASN1ObjectIdentifier(objectId.getId());
+    }
+
+    /**
+     * @deprecated use getAlgorithm
+     * @return
+     */
+    public DERObjectIdentifier getObjectId()
+    {
+        return objectId;
+    }
+
+    public DEREncodable getParameters()
+    {
+        return parameters;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     *      AlgorithmIdentifier ::= SEQUENCE {
+     *                            algorithm OBJECT IDENTIFIER,
+     *                            parameters ANY DEFINED BY algorithm OPTIONAL }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(objectId);
+
+        if (parametersDefined)
+        {
+            if (parameters != null)
+            {
+                v.add(parameters);
+            }
+            else
+            {
+                v.add(DERNull.INSTANCE);
+            }
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,92 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DSAParameter
+    extends ASN1Encodable
+{
+    DERInteger      p, q, g;
+
+    public static DSAParameter getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static DSAParameter getInstance(
+        Object obj)
+    {
+        if(obj == null || obj instanceof DSAParameter) 
+        {
+            return (DSAParameter)obj;
+        }
+        
+        if(obj instanceof ASN1Sequence) 
+        {
+            return new DSAParameter((ASN1Sequence)obj);
+        }
+        
+        throw new IllegalArgumentException("Invalid DSAParameter: " + obj.getClass().getName());
+    }
+
+    public DSAParameter(
+        BigInteger  p,
+        BigInteger  q,
+        BigInteger  g)
+    {
+        this.p = new DERInteger(p);
+        this.q = new DERInteger(q);
+        this.g = new DERInteger(g);
+    }
+
+    public DSAParameter(
+        ASN1Sequence  seq)
+    {
+        if (seq.size() != 3)
+        {
+            throw new IllegalArgumentException("Bad sequence size: " + seq.size());
+        }
+        
+        Enumeration     e = seq.getObjects();
+
+        p = DERInteger.getInstance(e.nextElement());
+        q = DERInteger.getInstance(e.nextElement());
+        g = DERInteger.getInstance(e.nextElement());
+    }
+
+    public BigInteger getP()
+    {
+        return p.getPositiveValue();
+    }
+
+    public BigInteger getQ()
+    {
+        return q.getPositiveValue();
+    }
+
+    public BigInteger getG()
+    {
+        return g.getPositiveValue();
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(p);
+        v.add(q);
+        v.add(g);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,77 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.DERBitString;
+
+/**
+ * The KeyUsage object.
+ * <pre>
+ *    id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
+ *
+ *    KeyUsage ::= BIT STRING {
+ *         digitalSignature        (0),
+ *         nonRepudiation          (1),
+ *         keyEncipherment         (2),
+ *         dataEncipherment        (3),
+ *         keyAgreement            (4),
+ *         keyCertSign             (5),
+ *         cRLSign                 (6),
+ *         encipherOnly            (7),
+ *         decipherOnly            (8) }
+ * </pre>
+ */
+public class KeyUsage
+    extends DERBitString
+{
+    public static final int        digitalSignature = (1 << 7); 
+    public static final int        nonRepudiation   = (1 << 6);
+    public static final int        keyEncipherment  = (1 << 5);
+    public static final int        dataEncipherment = (1 << 4);
+    public static final int        keyAgreement     = (1 << 3);
+    public static final int        keyCertSign      = (1 << 2);
+    public static final int        cRLSign          = (1 << 1);
+    public static final int        encipherOnly     = (1 << 0);
+    public static final int        decipherOnly     = (1 << 15);
+
+    public static DERBitString getInstance(Object obj)   // needs to be DERBitString for other VMs
+    {
+        if (obj instanceof KeyUsage)
+        {
+            return (KeyUsage)obj;
+        }
+
+        if (obj instanceof X509Extension)
+        {
+            return new KeyUsage(DERBitString.getInstance(X509Extension.convertValueToObject((X509Extension)obj)));
+        }
+
+        return new KeyUsage(DERBitString.getInstance(obj));
+    }
+    
+    /**
+     * Basic constructor.
+     * 
+     * @param usage - the bitwise OR of the Key Usage flags giving the
+     * allowed uses for the key.
+     * e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
+     */
+    public KeyUsage(
+        int usage)
+    {
+        super(getBytes(usage), getPadBits(usage));
+    }
+
+    public KeyUsage(
+        DERBitString usage)
+    {
+        super(usage.getBytes(), usage.getPadBits());
+    }
+
+    public String toString()
+    {
+        if (data.length == 1)
+        {
+            return "KeyUsage: 0x" + Integer.toHexString(data[0] & 0xff);
+        }
+        return "KeyUsage: 0x" + Integer.toHexString((data[1] & 0xff) << 8 | (data[0] & 0xff));
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,95 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class RSAPublicKeyStructure
+    extends ASN1Encodable
+{
+    private BigInteger  modulus;
+    private BigInteger  publicExponent;
+
+    public static RSAPublicKeyStructure getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static RSAPublicKeyStructure getInstance(
+        Object obj)
+    {
+        if(obj == null || obj instanceof RSAPublicKeyStructure) 
+        {
+            return (RSAPublicKeyStructure)obj;
+        }
+        
+        if(obj instanceof ASN1Sequence) 
+        {
+            return new RSAPublicKeyStructure((ASN1Sequence)obj);
+        }
+        
+        throw new IllegalArgumentException("Invalid RSAPublicKeyStructure: " + obj.getClass().getName());
+    }
+    
+    public RSAPublicKeyStructure(
+        BigInteger  modulus,
+        BigInteger  publicExponent)
+    {
+        this.modulus = modulus;
+        this.publicExponent = publicExponent;
+    }
+
+    public RSAPublicKeyStructure(
+        ASN1Sequence  seq)
+    {
+        if (seq.size() != 2)
+        {
+            throw new IllegalArgumentException("Bad sequence size: "
+                    + seq.size());
+        }
+
+        Enumeration e = seq.getObjects();
+
+        modulus = DERInteger.getInstance(e.nextElement()).getPositiveValue();
+        publicExponent = DERInteger.getInstance(e.nextElement()).getPositiveValue();
+    }
+
+    public BigInteger getModulus()
+    {
+        return modulus;
+    }
+
+    public BigInteger getPublicExponent()
+    {
+        return publicExponent;
+    }
+
+    /**
+     * This outputs the key in PKCS1v2 format.
+     * <pre>
+     *      RSAPublicKey ::= SEQUENCE {
+     *                          modulus INTEGER, -- n
+     *                          publicExponent INTEGER, -- e
+     *                      }
+     * </pre>
+     * <p>
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(new DERInteger(getModulus()));
+        v.add(new DERInteger(getPublicExponent()));
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+/**
+ * The object that contains the public key stored in a certficate.
+ * <p>
+ * The getEncoded() method in the public keys in the JCE produces a DER
+ * encoded one of these.
+ */
+public class SubjectPublicKeyInfo
+    extends ASN1Encodable
+{
+    private AlgorithmIdentifier     algId;
+    private DERBitString            keyData;
+
+    public static SubjectPublicKeyInfo getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static SubjectPublicKeyInfo getInstance(
+        Object  obj)
+    {
+        if (obj instanceof SubjectPublicKeyInfo)
+        {
+            return (SubjectPublicKeyInfo)obj;
+        }
+        else if (obj != null)
+        {
+            return new SubjectPublicKeyInfo(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    public SubjectPublicKeyInfo(
+        AlgorithmIdentifier algId,
+        DEREncodable        publicKey)
+    {
+        this.keyData = new DERBitString(publicKey);
+        this.algId = algId;
+    }
+
+    public SubjectPublicKeyInfo(
+        AlgorithmIdentifier algId,
+        byte[]              publicKey)
+    {
+        this.keyData = new DERBitString(publicKey);
+        this.algId = algId;
+    }
+
+    public SubjectPublicKeyInfo(
+        ASN1Sequence  seq)
+    {
+        if (seq.size() != 2)
+        {
+            throw new IllegalArgumentException("Bad sequence size: "
+                    + seq.size());
+        }
+
+        Enumeration         e = seq.getObjects();
+
+        this.algId = AlgorithmIdentifier.getInstance(e.nextElement());
+        this.keyData = DERBitString.getInstance(e.nextElement());
+    }
+
+    public AlgorithmIdentifier getAlgorithmId()
+    {
+        return algId;
+    }
+
+    /**
+     * for when the public key is an encoded object - if the bitstring
+     * can't be decoded this routine throws an IOException.
+     *
+     * @exception IOException - if the bit string doesn't represent a DER
+     * encoded object.
+     */
+    public DERObject getPublicKey()
+        throws IOException
+    {
+        ASN1InputStream         aIn = new ASN1InputStream(keyData.getBytes());
+
+        return aIn.readObject();
+    }
+
+    /**
+     * for when the public key is raw bits...
+     */
+    public DERBitString getPublicKeyData()
+    {
+        return keyData;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     * SubjectPublicKeyInfo ::= SEQUENCE {
+     *                          algorithm AlgorithmIdentifier,
+     *                          publicKey BIT STRING }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(algId);
+        v.add(keyData);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,193 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERTaggedObject;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+
+/**
+ * The TBSCertificate object.
+ * <pre>
+ * TBSCertificate ::= SEQUENCE {
+ *      version          [ 0 ]  Version DEFAULT v1(0),
+ *      serialNumber            CertificateSerialNumber,
+ *      signature               AlgorithmIdentifier,
+ *      issuer                  Name,
+ *      validity                Validity,
+ *      subject                 Name,
+ *      subjectPublicKeyInfo    SubjectPublicKeyInfo,
+ *      issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
+ *      subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
+ *      extensions        [ 3 ] Extensions OPTIONAL
+ *      }
+ * </pre>
+ * <p>
+ * Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
+ * will parse them, but you really shouldn't be creating new ones.
+ */
+public class TBSCertificateStructure
+    extends ASN1Encodable
+    implements X509ObjectIdentifiers, PKCSObjectIdentifiers
+{
+    ASN1Sequence            seq;
+
+    DERInteger              version;
+    DERInteger              serialNumber;
+    AlgorithmIdentifier     signature;
+    X509Name                issuer;
+    Time                    startDate, endDate;
+    X509Name                subject;
+    SubjectPublicKeyInfo    subjectPublicKeyInfo;
+    DERBitString            issuerUniqueId;
+    DERBitString            subjectUniqueId;
+    X509Extensions          extensions;
+
+    public static TBSCertificateStructure getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static TBSCertificateStructure getInstance(
+        Object  obj)
+    {
+        if (obj instanceof TBSCertificateStructure)
+        {
+            return (TBSCertificateStructure)obj;
+        }
+        else if (obj != null)
+        {
+            return new TBSCertificateStructure(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    public TBSCertificateStructure(
+        ASN1Sequence  seq)
+    {
+        int         seqStart = 0;
+
+        this.seq = seq;
+
+        //
+        // some certficates don't include a version number - we assume v1
+        //
+        if (seq.getObjectAt(0) instanceof DERTaggedObject)
+        {
+            version = DERInteger.getInstance((ASN1TaggedObject)seq.getObjectAt(0), true);
+        }
+        else
+        {
+            seqStart = -1;          // field 0 is missing!
+            version = new DERInteger(0);
+        }
+
+        serialNumber = DERInteger.getInstance(seq.getObjectAt(seqStart + 1));
+
+        signature = AlgorithmIdentifier.getInstance(seq.getObjectAt(seqStart + 2));
+        issuer = X509Name.getInstance(seq.getObjectAt(seqStart + 3));
+
+        //
+        // before and after dates
+        //
+        ASN1Sequence  dates = (ASN1Sequence)seq.getObjectAt(seqStart + 4);
+
+        startDate = Time.getInstance(dates.getObjectAt(0));
+        endDate = Time.getInstance(dates.getObjectAt(1));
+
+        subject = X509Name.getInstance(seq.getObjectAt(seqStart + 5));
+
+        //
+        // public key info.
+        //
+        subjectPublicKeyInfo = SubjectPublicKeyInfo.getInstance(seq.getObjectAt(seqStart + 6));
+
+        for (int extras = seq.size() - (seqStart + 6) - 1; extras > 0; extras--)
+        {
+            DERTaggedObject extra = (DERTaggedObject)seq.getObjectAt(seqStart + 6 + extras);
+
+            switch (extra.getTagNo())
+            {
+            case 1:
+                issuerUniqueId = DERBitString.getInstance(extra, false);
+                break;
+            case 2:
+                subjectUniqueId = DERBitString.getInstance(extra, false);
+                break;
+            case 3:
+                extensions = X509Extensions.getInstance(extra);
+            }
+        }
+    }
+
+    public int getVersion()
+    {
+        return version.getValue().intValue() + 1;
+    }
+
+    public DERInteger getVersionNumber()
+    {
+        return version;
+    }
+
+    public DERInteger getSerialNumber()
+    {
+        return serialNumber;
+    }
+
+    public AlgorithmIdentifier getSignature()
+    {
+        return signature;
+    }
+
+    public X509Name getIssuer()
+    {
+        return issuer;
+    }
+
+    public Time getStartDate()
+    {
+        return startDate;
+    }
+
+    public Time getEndDate()
+    {
+        return endDate;
+    }
+
+    public X509Name getSubject()
+    {
+        return subject;
+    }
+
+    public SubjectPublicKeyInfo getSubjectPublicKeyInfo()
+    {
+        return subjectPublicKeyInfo;
+    }
+
+    public DERBitString getIssuerUniqueId()
+    {
+        return issuerUniqueId;
+    }
+
+    public DERBitString getSubjectUniqueId()
+    {
+        return subjectUniqueId;
+    }
+
+    public X509Extensions getExtensions()
+    {
+        return extensions;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return seq;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/Time.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/Time.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/Time.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/Time.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/Time.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,133 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Choice;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERGeneralizedTime;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERUTCTime;
+
+// import java.text.ParseException;
+// import java.text.SimpleDateFormat;
+// import ewe.sys.Date;
+// import java.util.SimpleTimeZone;
+
+public class Time
+    extends ASN1Encodable
+    implements ASN1Choice
+{
+    DERObject   time;
+
+    public static Time getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(obj.getObject()); // must be explicitly tagged
+    }
+
+    public Time(
+        DERObject   time)
+    {
+        if (!(time instanceof DERUTCTime)
+            && !(time instanceof DERGeneralizedTime))
+        {
+            throw new IllegalArgumentException("unknown object passed to Time");
+        }
+
+        this.time = time;
+    }
+
+    /**
+     * creates a time object from a given date - if the date is between 1950
+     * and 2049 a UTCTime object is generated, otherwise a GeneralizedTime
+     * is used.
+     */
+  /*  public Time(
+        Date    date)
+    {
+        SimpleTimeZone      tz = new SimpleTimeZone(0, "Z");
+        SimpleDateFormat    dateF = new SimpleDateFormat("yyyyMMddHHmmss");
+
+        dateF.setTimeZone(tz);
+
+        String  d = dateF.format(date) + "Z";
+        int     year = Integer.parseInt(d.substring(0, 4));
+
+        if (year < 1950 || year > 2049)
+        {
+            time = new DERGeneralizedTime(d);
+        }
+        else
+        {
+            time = new DERUTCTime(d.substring(2));
+        }
+    }
+*/
+    public static Time getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof Time)
+        {
+            return (Time)obj;
+        }
+        else if (obj instanceof DERUTCTime)
+        {
+            return new Time((DERUTCTime)obj);
+        }
+        else if (obj instanceof DERGeneralizedTime)
+        {
+            return new Time((DERGeneralizedTime)obj);
+        }
+
+        throw new IllegalArgumentException("unknown object in factory: " + obj.getClass().getName());
+    }
+
+    public String getTime()
+    {
+        if (time instanceof DERUTCTime)
+        {
+            return ((DERUTCTime)time).getAdjustedTime();
+        }
+        else
+        {
+            return ((DERGeneralizedTime)time).getTime();
+        }
+    }
+/*
+    public Date getDate()
+    {
+        try
+        {
+            if (time instanceof DERUTCTime)
+            {
+                return ((DERUTCTime)time).getAdjustedDate();
+            }
+            else
+            {
+                return ((DERGeneralizedTime)time).getDate();
+            }
+        }
+        catch (ParseException e)
+        {         // this should never happen
+            throw new IllegalStateException("invalid date string: " + e.getMessage());
+        }
+    }
+*/
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     * Time ::= CHOICE {
+     *             utcTime        UTCTime,
+     *             generalTime    GeneralizedTime }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        return time;
+    }
+
+    public String toString()
+    {
+        return getTime();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,127 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+
+/**
+ * an X509Certificate structure.
+ * <pre>
+ *  Certificate ::= SEQUENCE {
+ *      tbsCertificate          TBSCertificate,
+ *      signatureAlgorithm      AlgorithmIdentifier,
+ *      signature               BIT STRING
+ *  }
+ * </pre>
+ */
+public class X509CertificateStructure
+    extends ASN1Encodable
+    implements X509ObjectIdentifiers, PKCSObjectIdentifiers
+{
+    ASN1Sequence  seq;
+    TBSCertificateStructure tbsCert;
+    AlgorithmIdentifier     sigAlgId;
+    DERBitString            sig;
+
+    public static X509CertificateStructure getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static X509CertificateStructure getInstance(
+        Object  obj)
+    {
+        if (obj instanceof X509CertificateStructure)
+        {
+            return (X509CertificateStructure)obj;
+        }
+        else if (obj != null)
+        {
+            return new X509CertificateStructure(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    public X509CertificateStructure(
+        ASN1Sequence  seq)
+    {
+        this.seq = seq;
+
+        //
+        // correct x509 certficate
+        //
+        if (seq.size() == 3)
+        {
+            tbsCert = TBSCertificateStructure.getInstance(seq.getObjectAt(0));
+            sigAlgId = AlgorithmIdentifier.getInstance(seq.getObjectAt(1));
+
+            sig = DERBitString.getInstance(seq.getObjectAt(2));
+        }
+        else
+        {
+            throw new IllegalArgumentException("sequence wrong size for a certificate");
+        }
+    }
+
+    public TBSCertificateStructure getTBSCertificate()
+    {
+        return tbsCert;
+    }
+
+    public int getVersion()
+    {
+        return tbsCert.getVersion();
+    }
+
+    public DERInteger getSerialNumber()
+    {
+        return tbsCert.getSerialNumber();
+    }
+
+    public X509Name getIssuer()
+    {
+        return tbsCert.getIssuer();
+    }
+
+    public Time getStartDate()
+    {
+        return tbsCert.getStartDate();
+    }
+
+    public Time getEndDate()
+    {
+        return tbsCert.getEndDate();
+    }
+
+    public X509Name getSubject()
+    {
+        return tbsCert.getSubject();
+    }
+
+    public SubjectPublicKeyInfo getSubjectPublicKeyInfo()
+    {
+        return tbsCert.getSubjectPublicKeyInfo();
+    }
+
+    public AlgorithmIdentifier getSignatureAlgorithm()
+    {
+        return sigAlgId;
+    }
+
+    public DERBitString getSignature()
+    {
+        return sig;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return seq;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,65 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.DERGeneralizedTime;
+import org.bouncycastle.asn1.DERIA5String;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERPrintableString;
+import org.bouncycastle.asn1.DERUTF8String;
+
+import ewe.io.IOException;
+
+/**
+ * The default converter for X509 DN entries when going from their
+ * string value to ASN.1 strings.
+ */
+public class X509DefaultEntryConverter
+    extends X509NameEntryConverter
+{
+    /**
+     * Apply default coversion for the given value depending on the oid
+     * and the character range of the value.
+     * 
+     * @param oid the object identifier for the DN entry
+     * @param value the value associated with it
+     * @return the ASN.1 equivalent for the string value.
+     */
+    public DERObject getConvertedValue(
+        DERObjectIdentifier  oid,
+        String               value)
+    {
+        if (value.length() != 0 && value.charAt(0) == '#')
+        {
+            try
+            {
+                return convertHexEncoded(value, 1);
+            }
+            catch (IOException e)
+            {
+                throw new RuntimeException("can't recode value for oid " + oid.getId());
+            }
+        }
+        else
+        {
+            if (value.length() != 0 && value.charAt(0) == '\\')
+            {
+                value = value.substring(1);
+            }
+            if (oid.equals(X509Name.EmailAddress) || oid.equals(X509Name.DC))
+            {
+                return new DERIA5String(value);
+            }
+            else if (oid.equals(X509Name.DATE_OF_BIRTH))  // accept time string as well as # (for compatibility)
+            {
+                return new DERGeneralizedTime(value);
+            }
+            else if (oid.equals(X509Name.C) || oid.equals(X509Name.SN) || oid.equals(X509Name.DN_QUALIFIER)
+                || oid.equals(X509Name.TELEPHONE_NUMBER))
+            {
+                 return new DERPrintableString(value);
+            }
+        }
+        
+        return new DERUTF8String(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extension.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509Extension.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509Extension.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,249 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.DERBoolean;
+
+/**
+ * an object for the elements in the X.509 V3 extension block.
+ */
+public class X509Extension
+{
+    /**
+     * Subject Directory Attributes
+     */
+    public static final ASN1ObjectIdentifier subjectDirectoryAttributes = new ASN1ObjectIdentifier("2.5.29.9");
+    
+    /**
+     * Subject Key Identifier 
+     */
+    public static final ASN1ObjectIdentifier subjectKeyIdentifier = new ASN1ObjectIdentifier("2.5.29.14");
+
+    /**
+     * Key Usage 
+     */
+    public static final ASN1ObjectIdentifier keyUsage = new ASN1ObjectIdentifier("2.5.29.15");
+
+    /**
+     * Private Key Usage Period 
+     */
+    public static final ASN1ObjectIdentifier privateKeyUsagePeriod = new ASN1ObjectIdentifier("2.5.29.16");
+
+    /**
+     * Subject Alternative Name 
+     */
+    public static final ASN1ObjectIdentifier subjectAlternativeName = new ASN1ObjectIdentifier("2.5.29.17");
+
+    /**
+     * Issuer Alternative Name 
+     */
+    public static final ASN1ObjectIdentifier issuerAlternativeName = new ASN1ObjectIdentifier("2.5.29.18");
+
+    /**
+     * Basic Constraints 
+     */
+    public static final ASN1ObjectIdentifier basicConstraints = new ASN1ObjectIdentifier("2.5.29.19");
+
+    /**
+     * CRL Number 
+     */
+    public static final ASN1ObjectIdentifier cRLNumber = new ASN1ObjectIdentifier("2.5.29.20");
+
+    /**
+     * Reason code 
+     */
+    public static final ASN1ObjectIdentifier reasonCode = new ASN1ObjectIdentifier("2.5.29.21");
+
+    /**
+     * Hold Instruction Code 
+     */
+    public static final ASN1ObjectIdentifier instructionCode = new ASN1ObjectIdentifier("2.5.29.23");
+
+    /**
+     * Invalidity Date 
+     */
+    public static final ASN1ObjectIdentifier invalidityDate = new ASN1ObjectIdentifier("2.5.29.24");
+
+    /**
+     * Delta CRL indicator 
+     */
+    public static final ASN1ObjectIdentifier deltaCRLIndicator = new ASN1ObjectIdentifier("2.5.29.27");
+
+    /**
+     * Issuing Distribution Point 
+     */
+    public static final ASN1ObjectIdentifier issuingDistributionPoint = new ASN1ObjectIdentifier("2.5.29.28");
+
+    /**
+     * Certificate Issuer 
+     */
+    public static final ASN1ObjectIdentifier certificateIssuer = new ASN1ObjectIdentifier("2.5.29.29");
+
+    /**
+     * Name Constraints 
+     */
+    public static final ASN1ObjectIdentifier nameConstraints = new ASN1ObjectIdentifier("2.5.29.30");
+
+    /**
+     * CRL Distribution Points 
+     */
+    public static final ASN1ObjectIdentifier cRLDistributionPoints = new ASN1ObjectIdentifier("2.5.29.31");
+
+    /**
+     * Certificate Policies 
+     */
+    public static final ASN1ObjectIdentifier certificatePolicies = new ASN1ObjectIdentifier("2.5.29.32");
+
+    /**
+     * Policy Mappings 
+     */
+    public static final ASN1ObjectIdentifier policyMappings = new ASN1ObjectIdentifier("2.5.29.33");
+
+    /**
+     * Authority Key Identifier 
+     */
+    public static final ASN1ObjectIdentifier authorityKeyIdentifier = new ASN1ObjectIdentifier("2.5.29.35");
+
+    /**
+     * Policy Constraints 
+     */
+    public static final ASN1ObjectIdentifier policyConstraints = new ASN1ObjectIdentifier("2.5.29.36");
+
+    /**
+     * Extended Key Usage 
+     */
+    public static final ASN1ObjectIdentifier extendedKeyUsage = new ASN1ObjectIdentifier("2.5.29.37");
+
+    /**
+     * Freshest CRL
+     */
+    public static final ASN1ObjectIdentifier freshestCRL = new ASN1ObjectIdentifier("2.5.29.46");
+     
+    /**
+     * Inhibit Any Policy
+     */
+    public static final ASN1ObjectIdentifier inhibitAnyPolicy = new ASN1ObjectIdentifier("2.5.29.54");
+
+    /**
+     * Authority Info Access
+     */
+    public static final ASN1ObjectIdentifier authorityInfoAccess = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.1");
+
+    /**
+     * Subject Info Access
+     */
+    public static final ASN1ObjectIdentifier subjectInfoAccess = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.11");
+    
+    /**
+     * Logo Type
+     */
+    public static final ASN1ObjectIdentifier logoType = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.12");
+
+    /**
+     * BiometricInfo
+     */
+    public static final ASN1ObjectIdentifier biometricInfo = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.2");
+    
+    /**
+     * QCStatements
+     */
+    public static final ASN1ObjectIdentifier qCStatements = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.3");
+
+    /**
+     * Audit identity extension in attribute certificates.
+     */
+    public static final ASN1ObjectIdentifier auditIdentity = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.4");
+    
+    /**
+     * NoRevAvail extension in attribute certificates.
+     */
+    public static final ASN1ObjectIdentifier noRevAvail = new ASN1ObjectIdentifier("2.5.29.56");
+
+    /**
+     * TargetInformation extension in attribute certificates.
+     */
+    public static final ASN1ObjectIdentifier targetInformation = new ASN1ObjectIdentifier("2.5.29.55");
+        
+    boolean             critical;
+    ASN1OctetString      value;
+
+    public X509Extension(
+        DERBoolean              critical,
+        ASN1OctetString         value)
+    {
+        this.critical = critical.isTrue();
+        this.value = value;
+    }
+
+    public X509Extension(
+        boolean                 critical,
+        ASN1OctetString         value)
+    {
+        this.critical = critical;
+        this.value = value;
+    }
+
+    public boolean isCritical()
+    {
+        return critical;
+    }
+
+    public ASN1OctetString getValue()
+    {
+        return value;
+    }
+
+    public ASN1Encodable getParsedValue()
+    {
+        return convertValueToObject(this);
+    }
+
+    public int hashCode()
+    {
+        if (this.isCritical())
+        {
+            return this.getValue().hashCode();
+        }
+
+        
+        return ~this.getValue().hashCode();
+    }
+
+    public boolean equals(
+        Object  o)
+    {
+        if (!(o instanceof X509Extension))
+        {
+            return false;
+        }
+
+        X509Extension   other = (X509Extension)o;
+
+        return other.getValue().equals(this.getValue())
+            && (other.isCritical() == this.isCritical());
+    }
+
+    /**
+     * Convert the value of the passed in extension to an object
+     * @param ext the extension to parse
+     * @return the object the value string contains
+     * @exception IllegalArgumentException if conversion is not possible
+     */
+    public static ASN1Object convertValueToObject(
+        X509Extension ext)
+        throws IllegalArgumentException
+    {
+        try
+        {
+            return ASN1Object.fromByteArray(ext.getValue().getOctets());
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException("can't convert extension: " +  e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,479 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBoolean;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+
+public class X509Extensions
+    extends ASN1Encodable
+{
+    /**
+     * Subject Directory Attributes
+     * @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectDirectoryAttributes = new ASN1ObjectIdentifier("2.5.29.9");
+    
+    /**
+     * Subject Key Identifier
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectKeyIdentifier = new ASN1ObjectIdentifier("2.5.29.14");
+
+    /**
+     * Key Usage
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier KeyUsage = new ASN1ObjectIdentifier("2.5.29.15");
+
+    /**
+     * Private Key Usage Period
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier PrivateKeyUsagePeriod = new ASN1ObjectIdentifier("2.5.29.16");
+
+    /**
+     * Subject Alternative Name
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectAlternativeName = new ASN1ObjectIdentifier("2.5.29.17");
+
+    /**
+     * Issuer Alternative Name
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier IssuerAlternativeName = new ASN1ObjectIdentifier("2.5.29.18");
+
+    /**
+     * Basic Constraints
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier BasicConstraints = new ASN1ObjectIdentifier("2.5.29.19");
+
+    /**
+     * CRL Number
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CRLNumber = new ASN1ObjectIdentifier("2.5.29.20");
+
+    /**
+     * Reason code
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier ReasonCode = new ASN1ObjectIdentifier("2.5.29.21");
+
+    /**
+     * Hold Instruction Code
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier InstructionCode = new ASN1ObjectIdentifier("2.5.29.23");
+
+    /**
+     * Invalidity Date
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier InvalidityDate = new ASN1ObjectIdentifier("2.5.29.24");
+
+    /**
+     * Delta CRL indicator
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier DeltaCRLIndicator = new ASN1ObjectIdentifier("2.5.29.27");
+
+    /**
+     * Issuing Distribution Point
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier IssuingDistributionPoint = new ASN1ObjectIdentifier("2.5.29.28");
+
+    /**
+     * Certificate Issuer
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CertificateIssuer = new ASN1ObjectIdentifier("2.5.29.29");
+
+    /**
+     * Name Constraints
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier NameConstraints = new ASN1ObjectIdentifier("2.5.29.30");
+
+    /**
+     * CRL Distribution Points
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CRLDistributionPoints = new ASN1ObjectIdentifier("2.5.29.31");
+
+    /**
+     * Certificate Policies
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CertificatePolicies = new ASN1ObjectIdentifier("2.5.29.32");
+
+    /**
+     * Policy Mappings
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier PolicyMappings = new ASN1ObjectIdentifier("2.5.29.33");
+
+    /**
+     * Authority Key Identifier
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier AuthorityKeyIdentifier = new ASN1ObjectIdentifier("2.5.29.35");
+
+    /**
+     * Policy Constraints
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier PolicyConstraints = new ASN1ObjectIdentifier("2.5.29.36");
+
+    /**
+     * Extended Key Usage
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier ExtendedKeyUsage = new ASN1ObjectIdentifier("2.5.29.37");
+
+    /**
+     * Freshest CRL
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier FreshestCRL = new ASN1ObjectIdentifier("2.5.29.46");
+     
+    /**
+     * Inhibit Any Policy
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier InhibitAnyPolicy = new ASN1ObjectIdentifier("2.5.29.54");
+
+    /**
+     * Authority Info Access
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier AuthorityInfoAccess = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.1");
+
+    /**
+     * Subject Info Access
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectInfoAccess = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.11");
+    
+    /**
+     * Logo Type
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier LogoType = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.12");
+
+    /**
+     * BiometricInfo
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier BiometricInfo = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.2");
+    
+    /**
+     * QCStatements
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier QCStatements = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.3");
+
+    /**
+     * Audit identity extension in attribute certificates.
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier AuditIdentity = new ASN1ObjectIdentifier("1.3.6.1.5.5.7.1.4");
+    
+    /**
+     * NoRevAvail extension in attribute certificates.
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier NoRevAvail = new ASN1ObjectIdentifier("2.5.29.56");
+
+    /**
+     * TargetInformation extension in attribute certificates.
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier TargetInformation = new ASN1ObjectIdentifier("2.5.29.55");
+    
+    private Hashtable               extensions = new Hashtable();
+    private Vector                  ordering = new Vector();
+
+    public static X509Extensions getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static X509Extensions getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof X509Extensions)
+        {
+            return (X509Extensions)obj;
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new X509Extensions((ASN1Sequence)obj);
+        }
+
+        if (obj instanceof ASN1TaggedObject)
+        {
+            return getInstance(((ASN1TaggedObject)obj).getObject());
+        }
+
+        throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
+    }
+
+    /**
+     * Constructor from ASN1Sequence.
+     *
+     * the extensions are a list of constructed sequences, either with (OID, OctetString) or (OID, Boolean, OctetString)
+     */
+    public X509Extensions(
+        ASN1Sequence  seq)
+    {
+        Enumeration e = seq.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            ASN1Sequence            s = ASN1Sequence.getInstance(e.nextElement());
+
+            if (s.size() == 3)
+            {
+                extensions.put(s.getObjectAt(0), new X509Extension(DERBoolean.getInstance(s.getObjectAt(1)), ASN1OctetString.getInstance(s.getObjectAt(2))));
+            }
+            else if (s.size() == 2)
+            {
+                extensions.put(s.getObjectAt(0), new X509Extension(false, ASN1OctetString.getInstance(s.getObjectAt(1))));
+            }
+            else
+            {
+                throw new IllegalArgumentException("Bad sequence size: " + s.size());
+            }
+
+            ordering.addElement(s.getObjectAt(0));
+        }
+    }
+
+    /**
+     * constructor from a table of extensions.
+     * <p>
+     * it's is assumed the table contains OID/String pairs.
+     */
+    public X509Extensions(
+        Hashtable  extensions)
+    {
+        this(null, extensions);
+    }
+
+    /**
+     * Constructor from a table of extensions with ordering.
+     * <p>
+     * It's is assumed the table contains OID/String pairs.
+     */
+    public X509Extensions(
+        Vector      ordering,
+        Hashtable   extensions)
+    {
+        Enumeration e;
+
+        if (ordering == null)
+        {
+            e = extensions.keys();
+        }
+        else
+        {
+            e = ordering.elements();
+        }
+
+        while (e.hasMoreElements())
+        {
+            this.ordering.addElement(new ASN1ObjectIdentifier(((DERObjectIdentifier)e.nextElement()).getId())); 
+        }
+
+        e = this.ordering.elements();
+
+        while (e.hasMoreElements())
+        {
+            ASN1ObjectIdentifier     oid = new ASN1ObjectIdentifier(((DERObjectIdentifier)e.nextElement()).getId());
+            X509Extension           ext = (X509Extension)extensions.get(oid);
+
+            this.extensions.put(oid, ext);
+        }
+    }
+
+    /**
+     * Constructor from two vectors
+     * 
+     * @param objectIDs a vector of the object identifiers.
+     * @param values a vector of the extension values.
+     */
+    public X509Extensions(
+        Vector      objectIDs,
+        Vector      values)
+    {
+        Enumeration e = objectIDs.elements();
+
+        while (e.hasMoreElements())
+        {
+            this.ordering.addElement(e.nextElement()); 
+        }
+
+        int count = 0;
+        
+        e = this.ordering.elements();
+
+        while (e.hasMoreElements())
+        {
+            ASN1ObjectIdentifier     oid = (ASN1ObjectIdentifier)e.nextElement();
+            X509Extension           ext = (X509Extension)values.elementAt(count);
+
+            this.extensions.put(oid, ext);
+            count++;
+        }
+    }
+    
+    /**
+     * return an Enumeration of the extension field's object ids.
+     */
+    public Enumeration oids()
+    {
+        return ordering.elements();
+    }
+
+    /**
+     * return the extension represented by the object identifier
+     * passed in.
+     *
+     * @return the extension if it's present, null otherwise.
+     */
+    public X509Extension getExtension(
+        ASN1ObjectIdentifier oid)
+    {
+        return (X509Extension)extensions.get(oid);
+    }
+
+    /**
+     * @deprecated
+     * @param oid
+     * @return
+     */
+    public X509Extension getExtension(
+        DERObjectIdentifier oid)
+    {
+        return (X509Extension)extensions.get(oid);
+    }
+
+    /**
+     * <pre>
+     *     Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
+     *
+     *     Extension         ::=   SEQUENCE {
+     *        extnId            EXTENSION.&amp;id ({ExtensionSet}),
+     *        critical          BOOLEAN DEFAULT FALSE,
+     *        extnValue         OCTET STRING }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector     vec = new ASN1EncodableVector();
+        Enumeration             e = ordering.elements();
+
+        while (e.hasMoreElements())
+        {
+            ASN1ObjectIdentifier     oid = (ASN1ObjectIdentifier)e.nextElement();
+            X509Extension           ext = (X509Extension)extensions.get(oid);
+            ASN1EncodableVector     v = new ASN1EncodableVector();
+
+            v.add(oid);
+
+            if (ext.isCritical())
+            {
+                v.add(new DERBoolean(true));
+            }
+
+            v.add(ext.getValue());
+
+            vec.add(new DERSequence(v));
+        }
+
+        return new DERSequence(vec);
+    }
+
+    public boolean equivalent(
+        X509Extensions other)
+    {
+        if (extensions.size() != other.extensions.size())
+        {
+            return false;
+        }
+
+        Enumeration     e1 = extensions.keys();
+
+        while (e1.hasMoreElements())
+        {
+            Object  key = e1.nextElement();
+
+            if (!extensions.get(key).equals(other.extensions.get(key)))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public ASN1ObjectIdentifier[] getExtensionOIDs()
+    {
+        return toOidArray(ordering);
+    }
+    
+    public ASN1ObjectIdentifier[] getNonCriticalExtensionOIDs()
+    {
+        return getExtensionOIDs(false);
+    }
+
+    public ASN1ObjectIdentifier[] getCriticalExtensionOIDs()
+    {
+        return getExtensionOIDs(true);
+    }
+
+    private ASN1ObjectIdentifier[] getExtensionOIDs(boolean isCritical)
+    {
+        Vector oidVec = new Vector();
+
+        for (int i = 0; i != ordering.size(); i++)
+        {
+            Object oid = ordering.elementAt(i);
+
+            if (((X509Extension)extensions.get(oid)).isCritical() == isCritical)
+            {
+                oidVec.addElement(oid);
+            }
+        }
+
+        return toOidArray(oidVec);
+    }
+
+    private ASN1ObjectIdentifier[] toOidArray(Vector oidVec)
+    {
+        ASN1ObjectIdentifier[] oids = new ASN1ObjectIdentifier[oidVec.size()];
+
+        for (int i = 0; i != oids.length; i++)
+        {
+            oids[i] = (ASN1ObjectIdentifier)oidVec.elementAt(i);
+        }
+        return oids;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509Name.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509Name.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509Name.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509Name.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509Name.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1267 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1Set;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.DERSet;
+import org.bouncycastle.asn1.DERString;
+import org.bouncycastle.asn1.DERUniversalString;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+import org.bouncycastle.asn1.x500.X500Name;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+/**
+ * <pre>
+ *     RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
+ *
+ *     RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
+ *
+ *     AttributeTypeAndValue ::= SEQUENCE {
+ *                                   type  OBJECT IDENTIFIER,
+ *                                   value ANY }
+ * </pre>
+ * @deprecated use org.bouncycastle.asn1.x500.X500Name.
+ */
+public class X509Name
+    extends ASN1Encodable
+{
+    /**
+     * country code - StringType(SIZE(2))
+     */
+    public static final DERObjectIdentifier C = new DERObjectIdentifier("2.5.4.6");
+
+    /**
+     * organization - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier O = new DERObjectIdentifier("2.5.4.10");
+
+    /**
+     * organizational unit name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier OU = new DERObjectIdentifier("2.5.4.11");
+
+    /**
+     * Title
+     */
+    public static final DERObjectIdentifier T = new DERObjectIdentifier("2.5.4.12");
+
+    /**
+     * common name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier CN = new DERObjectIdentifier("2.5.4.3");
+
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier SN = new DERObjectIdentifier("2.5.4.5");
+
+    /**
+     * street - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier STREET = new DERObjectIdentifier("2.5.4.9");
+    
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier SERIALNUMBER = SN;
+
+    /**
+     * locality name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier L = new DERObjectIdentifier("2.5.4.7");
+
+    /**
+     * state, or province name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier ST = new DERObjectIdentifier("2.5.4.8");
+
+    /**
+     * Naming attributes of type X520name
+     */
+    public static final DERObjectIdentifier SURNAME = new DERObjectIdentifier("2.5.4.4");
+    public static final DERObjectIdentifier GIVENNAME = new DERObjectIdentifier("2.5.4.42");
+    public static final DERObjectIdentifier INITIALS = new DERObjectIdentifier("2.5.4.43");
+    public static final DERObjectIdentifier GENERATION = new DERObjectIdentifier("2.5.4.44");
+    public static final DERObjectIdentifier UNIQUE_IDENTIFIER = new DERObjectIdentifier("2.5.4.45");
+
+    /**
+     * businessCategory - DirectoryString(SIZE(1..128)
+     */
+    public static final DERObjectIdentifier BUSINESS_CATEGORY = new DERObjectIdentifier(
+                    "2.5.4.15");
+
+    /**
+     * postalCode - DirectoryString(SIZE(1..40)
+     */
+    public static final DERObjectIdentifier POSTAL_CODE = new DERObjectIdentifier(
+                    "2.5.4.17");
+    
+    /**
+     * dnQualifier - DirectoryString(SIZE(1..64)
+     */
+    public static final DERObjectIdentifier DN_QUALIFIER = new DERObjectIdentifier(
+                    "2.5.4.46");
+
+    /**
+     * RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
+     */
+    public static final DERObjectIdentifier PSEUDONYM = new DERObjectIdentifier(
+                    "2.5.4.65");
+
+
+    /**
+     * RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
+     */
+    public static final DERObjectIdentifier DATE_OF_BIRTH = new DERObjectIdentifier(
+                    "1.3.6.1.5.5.7.9.1");
+
+    /**
+     * RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
+     */
+    public static final DERObjectIdentifier PLACE_OF_BIRTH = new DERObjectIdentifier(
+                    "1.3.6.1.5.5.7.9.2");
+
+    /**
+     * RFC 3039 Gender - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
+     */
+    public static final DERObjectIdentifier GENDER = new DERObjectIdentifier(
+                    "1.3.6.1.5.5.7.9.3");
+
+    /**
+     * RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final DERObjectIdentifier COUNTRY_OF_CITIZENSHIP = new DERObjectIdentifier(
+                    "1.3.6.1.5.5.7.9.4");
+
+    /**
+     * RFC 3039 CountryOfResidence - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final DERObjectIdentifier COUNTRY_OF_RESIDENCE = new DERObjectIdentifier(
+                    "1.3.6.1.5.5.7.9.5");
+
+
+    /**
+     * ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
+     */
+    public static final DERObjectIdentifier NAME_AT_BIRTH =  new DERObjectIdentifier("1.3.36.8.3.14");
+
+    /**
+     * RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
+     * DirectoryString(SIZE(1..30))
+     */
+    public static final DERObjectIdentifier POSTAL_ADDRESS = new DERObjectIdentifier("2.5.4.16");
+
+    /**
+     * RFC 2256 dmdName
+     */
+    public static final DERObjectIdentifier DMD_NAME = new DERObjectIdentifier("2.5.4.54");
+
+    /**
+     * id-at-telephoneNumber
+     */
+    public static final DERObjectIdentifier TELEPHONE_NUMBER = X509ObjectIdentifiers.id_at_telephoneNumber;
+
+    /**
+     * id-at-name
+     */
+    public static final DERObjectIdentifier NAME = X509ObjectIdentifiers.id_at_name;
+
+    /**
+     * Email address (RSA PKCS#9 extension) - IA5String.
+     * <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.
+     */
+    public static final DERObjectIdentifier EmailAddress = PKCSObjectIdentifiers.pkcs_9_at_emailAddress;
+    
+    /**
+     * more from PKCS#9
+     */
+    public static final DERObjectIdentifier UnstructuredName = PKCSObjectIdentifiers.pkcs_9_at_unstructuredName;
+    public static final DERObjectIdentifier UnstructuredAddress = PKCSObjectIdentifiers.pkcs_9_at_unstructuredAddress;
+    
+    /**
+     * email address in Verisign certificates
+     */
+    public static final DERObjectIdentifier E = EmailAddress;
+    
+    /*
+     * others...
+     */
+    public static final DERObjectIdentifier DC = new DERObjectIdentifier("0.9.2342.19200300.100.1.25");
+
+    /**
+     * LDAP User id.
+     */
+    public static final DERObjectIdentifier UID = new DERObjectIdentifier("0.9.2342.19200300.100.1.1");
+
+    /**
+     * determines whether or not strings should be processed and printed
+     * from back to front.
+     */
+    public static boolean DefaultReverse = false;
+
+    /**
+     * default look up table translating OID values into their common symbols following
+     * the convention in RFC 2253 with a few extras
+     */
+    public static final Hashtable DefaultSymbols = new Hashtable();
+
+    /**
+     * look up table translating OID values into their common symbols following the convention in RFC 2253
+     * 
+     */
+    public static final Hashtable RFC2253Symbols = new Hashtable();
+
+    /**
+     * look up table translating OID values into their common symbols following the convention in RFC 1779
+     * 
+     */
+    public static final Hashtable RFC1779Symbols = new Hashtable();
+
+    /**
+     * look up table translating common symbols into their OIDS.
+     */
+    public static final Hashtable DefaultLookUp = new Hashtable();
+
+    /**
+     * look up table translating OID values into their common symbols
+     * @deprecated use DefaultSymbols
+     */
+    public static final Hashtable OIDLookUp = DefaultSymbols;
+
+    /**
+     * look up table translating string values into their OIDS -
+     * @deprecated use DefaultLookUp
+     */
+    public static final Hashtable SymbolLookUp = DefaultLookUp;
+
+    private static final Boolean TRUE = new Boolean(true); // for J2ME compatibility
+    private static final Boolean FALSE = new Boolean(false);
+
+    static
+    {
+        DefaultSymbols.put(C, "C");
+        DefaultSymbols.put(O, "O");
+        DefaultSymbols.put(T, "T");
+        DefaultSymbols.put(OU, "OU");
+        DefaultSymbols.put(CN, "CN");
+        DefaultSymbols.put(L, "L");
+        DefaultSymbols.put(ST, "ST");
+        DefaultSymbols.put(SN, "SERIALNUMBER");
+        DefaultSymbols.put(EmailAddress, "E");
+        DefaultSymbols.put(DC, "DC");
+        DefaultSymbols.put(UID, "UID");
+        DefaultSymbols.put(STREET, "STREET");
+        DefaultSymbols.put(SURNAME, "SURNAME");
+        DefaultSymbols.put(GIVENNAME, "GIVENNAME");
+        DefaultSymbols.put(INITIALS, "INITIALS");
+        DefaultSymbols.put(GENERATION, "GENERATION");
+        DefaultSymbols.put(UnstructuredAddress, "unstructuredAddress");
+        DefaultSymbols.put(UnstructuredName, "unstructuredName");
+        DefaultSymbols.put(UNIQUE_IDENTIFIER, "UniqueIdentifier");
+        DefaultSymbols.put(DN_QUALIFIER, "DN");
+        DefaultSymbols.put(PSEUDONYM, "Pseudonym");
+        DefaultSymbols.put(POSTAL_ADDRESS, "PostalAddress");
+        DefaultSymbols.put(NAME_AT_BIRTH, "NameAtBirth");
+        DefaultSymbols.put(COUNTRY_OF_CITIZENSHIP, "CountryOfCitizenship");
+        DefaultSymbols.put(COUNTRY_OF_RESIDENCE, "CountryOfResidence");
+        DefaultSymbols.put(GENDER, "Gender");
+        DefaultSymbols.put(PLACE_OF_BIRTH, "PlaceOfBirth");
+        DefaultSymbols.put(DATE_OF_BIRTH, "DateOfBirth");
+        DefaultSymbols.put(POSTAL_CODE, "PostalCode");
+        DefaultSymbols.put(BUSINESS_CATEGORY, "BusinessCategory");
+        DefaultSymbols.put(TELEPHONE_NUMBER, "TelephoneNumber");
+        DefaultSymbols.put(NAME, "Name");
+
+        RFC2253Symbols.put(C, "C");
+        RFC2253Symbols.put(O, "O");
+        RFC2253Symbols.put(OU, "OU");
+        RFC2253Symbols.put(CN, "CN");
+        RFC2253Symbols.put(L, "L");
+        RFC2253Symbols.put(ST, "ST");
+        RFC2253Symbols.put(STREET, "STREET");
+        RFC2253Symbols.put(DC, "DC");
+        RFC2253Symbols.put(UID, "UID");
+
+        RFC1779Symbols.put(C, "C");
+        RFC1779Symbols.put(O, "O");
+        RFC1779Symbols.put(OU, "OU");
+        RFC1779Symbols.put(CN, "CN");
+        RFC1779Symbols.put(L, "L");
+        RFC1779Symbols.put(ST, "ST");
+        RFC1779Symbols.put(STREET, "STREET");
+
+        DefaultLookUp.put("c", C);
+        DefaultLookUp.put("o", O);
+        DefaultLookUp.put("t", T);
+        DefaultLookUp.put("ou", OU);
+        DefaultLookUp.put("cn", CN);
+        DefaultLookUp.put("l", L);
+        DefaultLookUp.put("st", ST);
+        DefaultLookUp.put("sn", SN);
+        DefaultLookUp.put("serialnumber", SN);
+        DefaultLookUp.put("street", STREET);
+        DefaultLookUp.put("emailaddress", E);
+        DefaultLookUp.put("dc", DC);
+        DefaultLookUp.put("e", E);
+        DefaultLookUp.put("uid", UID);
+        DefaultLookUp.put("surname", SURNAME);
+        DefaultLookUp.put("givenname", GIVENNAME);
+        DefaultLookUp.put("initials", INITIALS);
+        DefaultLookUp.put("generation", GENERATION);
+        DefaultLookUp.put("unstructuredaddress", UnstructuredAddress);
+        DefaultLookUp.put("unstructuredname", UnstructuredName);
+        DefaultLookUp.put("uniqueidentifier", UNIQUE_IDENTIFIER);
+        DefaultLookUp.put("dn", DN_QUALIFIER);
+        DefaultLookUp.put("pseudonym", PSEUDONYM);
+        DefaultLookUp.put("postaladdress", POSTAL_ADDRESS);
+        DefaultLookUp.put("nameofbirth", NAME_AT_BIRTH);
+        DefaultLookUp.put("countryofcitizenship", COUNTRY_OF_CITIZENSHIP);
+        DefaultLookUp.put("countryofresidence", COUNTRY_OF_RESIDENCE);
+        DefaultLookUp.put("gender", GENDER);
+        DefaultLookUp.put("placeofbirth", PLACE_OF_BIRTH);
+        DefaultLookUp.put("dateofbirth", DATE_OF_BIRTH);
+        DefaultLookUp.put("postalcode", POSTAL_CODE);
+        DefaultLookUp.put("businesscategory", BUSINESS_CATEGORY);
+        DefaultLookUp.put("telephonenumber", TELEPHONE_NUMBER);
+        DefaultLookUp.put("name", NAME);
+    }
+
+    private X509NameEntryConverter  converter = null;
+    private Vector                  ordering = new Vector();
+    private Vector                  values = new Vector();
+    private Vector                  added = new Vector();
+
+    private ASN1Sequence            seq;
+
+    private boolean                 isHashCodeCalculated;
+    private int                     hashCodeValue;
+
+    /**
+     * Return a X509Name based on the passed in tagged object.
+     * 
+     * @param obj tag object holding name.
+     * @param explicit true if explicitly tagged false otherwise.
+     * @return the X509Name
+     */
+    public static X509Name getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static X509Name getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof X509Name)
+        {
+            return (X509Name)obj;
+        }
+        else if (obj instanceof X500Name)
+        {
+            return new X509Name(ASN1Sequence.getInstance(((X500Name)obj).getDERObject()));
+        }
+        else if (obj != null)
+        {
+            return new X509Name(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    protected X509Name()
+    {
+        // constructure use by new X500 Name class
+    }
+    /**
+     * Constructor from ASN1Sequence
+     *
+     * the principal will be a list of constructed sets, each containing an (OID, String) pair.
+     */
+    public X509Name(
+        ASN1Sequence  seq)
+    {
+        this.seq = seq;
+
+        Enumeration e = seq.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            ASN1Set         set = ASN1Set.getInstance(((DEREncodable)e.nextElement()).getDERObject());
+
+            for (int i = 0; i < set.size(); i++) 
+            {
+                   ASN1Sequence s = ASN1Sequence.getInstance(set.getObjectAt(i));
+
+                   if (s.size() != 2)
+                   {
+                       throw new IllegalArgumentException("badly sized pair");
+                   }
+
+                   ordering.addElement(DERObjectIdentifier.getInstance(s.getObjectAt(0)));
+                   
+                   DEREncodable value = s.getObjectAt(1);
+                   if (value instanceof DERString && !(value instanceof DERUniversalString))
+                   {
+                       String v = ((DERString)value).getString();
+                       if (v.length() > 0 && v.charAt(0) == '#')
+                       {
+                           values.addElement("\\" + v);
+                       }
+                       else
+                       {
+                           values.addElement(v);
+                       }
+                   }
+                   else
+                   {
+                       values.addElement("#" + bytesToString(Hex.encode(value.getDERObject().getDEREncoded())));
+                   }
+                   added.addElement((i != 0) ? TRUE : FALSE);  // to allow earlier JDK compatibility
+            }
+        }
+    }
+
+    /**
+     * constructor from a table of attributes.
+     * <p>
+     * it's is assumed the table contains OID/String pairs, and the contents
+     * of the table are copied into an internal table as part of the
+     * construction process.
+     * <p>
+     * <b>Note:</b> if the name you are trying to generate should be
+     * following a specific ordering, you should use the constructor
+     * with the ordering specified below.
+     * @deprecated use an ordered constructor! The hashtable ordering is rarely correct
+     */
+    public X509Name(
+        Hashtable  attributes)
+    {
+        this(null, attributes);
+    }
+
+    /**
+     * Constructor from a table of attributes with ordering.
+     * <p>
+     * it's is assumed the table contains OID/String pairs, and the contents
+     * of the table are copied into an internal table as part of the
+     * construction process. The ordering vector should contain the OIDs
+     * in the order they are meant to be encoded or printed in toString.
+     */
+    public X509Name(
+        Vector      ordering,
+        Hashtable   attributes)
+    {
+        this(ordering, attributes, new X509DefaultEntryConverter());
+    }
+
+    /**
+     * Constructor from a table of attributes with ordering.
+     * <p>
+     * it's is assumed the table contains OID/String pairs, and the contents
+     * of the table are copied into an internal table as part of the
+     * construction process. The ordering vector should contain the OIDs
+     * in the order they are meant to be encoded or printed in toString.
+     * <p>
+     * The passed in converter will be used to convert the strings into their
+     * ASN.1 counterparts.
+     */
+    public X509Name(
+        Vector                   ordering,
+        Hashtable                attributes,
+        X509NameEntryConverter   converter)
+    {
+        this.converter = converter;
+
+        if (ordering != null)
+        {
+            for (int i = 0; i != ordering.size(); i++)
+            {
+                this.ordering.addElement(ordering.elementAt(i));
+                this.added.addElement(FALSE);
+            }
+        }
+        else
+        {
+            Enumeration     e = attributes.keys();
+
+            while (e.hasMoreElements())
+            {
+                this.ordering.addElement(e.nextElement());
+                this.added.addElement(FALSE);
+            }
+        }
+
+        for (int i = 0; i != this.ordering.size(); i++)
+        {
+            DERObjectIdentifier     oid = (DERObjectIdentifier)this.ordering.elementAt(i);
+
+            if (attributes.get(oid) == null)
+            {
+                throw new IllegalArgumentException("No attribute for object id - " + oid.getId() + " - passed to distinguished name");
+            }
+
+            this.values.addElement(attributes.get(oid)); // copy the hash table
+        }
+    }
+
+    /**
+     * Takes two vectors one of the oids and the other of the values.
+     */
+    public X509Name(
+        Vector  oids,
+        Vector  values)
+    {
+        this(oids, values, new X509DefaultEntryConverter());
+    }
+
+    /**
+     * Takes two vectors one of the oids and the other of the values.
+     * <p>
+     * The passed in converter will be used to convert the strings into their
+     * ASN.1 counterparts.
+     */
+    public X509Name(
+        Vector                  oids,
+        Vector                  values,
+        X509NameEntryConverter  converter)
+    {
+        this.converter = converter;
+
+        if (oids.size() != values.size())
+        {
+            throw new IllegalArgumentException("oids vector must be same length as values.");
+        }
+
+        for (int i = 0; i < oids.size(); i++)
+        {
+            this.ordering.addElement(oids.elementAt(i));
+            this.values.addElement(values.elementAt(i));
+            this.added.addElement(FALSE);
+        }
+    }
+
+//    private Boolean isEncoded(String s)
+//    {
+//        if (s.charAt(0) == '#')
+//        {
+//            return TRUE;
+//        }
+//
+//        return FALSE;
+//    }
+
+    /**
+     * Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
+     * some such, converting it into an ordered set of name attributes.
+     */
+    public X509Name(
+        String  dirName)
+    {
+        this(DefaultReverse, DefaultLookUp, dirName);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
+     * some such, converting it into an ordered set of name attributes with each
+     * string value being converted to its associated ASN.1 type using the passed
+     * in converter.
+     */
+    public X509Name(
+        String                  dirName,
+        X509NameEntryConverter  converter)
+    {
+        this(DefaultReverse, DefaultLookUp, dirName, converter);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
+     * some such, converting it into an ordered set of name attributes. If reverse
+     * is true, create the encoded version of the sequence starting from the
+     * last element in the string.
+     */
+    public X509Name(
+        boolean reverse,
+        String  dirName)
+    {
+        this(reverse, DefaultLookUp, dirName);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
+     * some such, converting it into an ordered set of name attributes with each
+     * string value being converted to its associated ASN.1 type using the passed
+     * in converter. If reverse is true the ASN.1 sequence representing the DN will
+     * be built by starting at the end of the string, rather than the start.
+     */
+    public X509Name(
+        boolean                 reverse,
+        String                  dirName,
+        X509NameEntryConverter  converter)
+    {
+        this(reverse, DefaultLookUp, dirName, converter);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
+     * some such, converting it into an ordered set of name attributes. lookUp
+     * should provide a table of lookups, indexed by lowercase only strings and
+     * yielding a DERObjectIdentifier, other than that OID. and numeric oids
+     * will be processed automatically.
+     * <br>
+     * If reverse is true, create the encoded version of the sequence
+     * starting from the last element in the string.
+     * @param reverse true if we should start scanning from the end (RFC 2553).
+     * @param lookUp table of names and their oids.
+     * @param dirName the X.500 string to be parsed.
+     */
+    public X509Name(
+        boolean     reverse,
+        Hashtable   lookUp,
+        String      dirName)
+    {
+        this(reverse, lookUp, dirName, new X509DefaultEntryConverter());
+    }
+
+    private DERObjectIdentifier decodeOID(
+        String      name,
+        Hashtable   lookUp)
+    {
+        if (Strings.toUpperCase(name).startsWith("OID."))
+        {
+            return new DERObjectIdentifier(name.substring(4));
+        }
+        else if (name.charAt(0) >= '0' && name.charAt(0) <= '9')
+        {
+            return new DERObjectIdentifier(name);
+        }
+
+        DERObjectIdentifier oid = (DERObjectIdentifier)lookUp.get(Strings.toLowerCase(name));
+        if (oid == null)
+        {
+            throw new IllegalArgumentException("Unknown object id - " + name + " - passed to distinguished name");
+        }
+
+        return oid;
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
+     * some such, converting it into an ordered set of name attributes. lookUp
+     * should provide a table of lookups, indexed by lowercase only strings and
+     * yielding a DERObjectIdentifier, other than that OID. and numeric oids
+     * will be processed automatically. The passed in converter is used to convert the
+     * string values to the right of each equals sign to their ASN.1 counterparts.
+     * <br>
+     * @param reverse true if we should start scanning from the end, false otherwise.
+     * @param lookUp table of names and oids.
+     * @param dirName the string dirName
+     * @param converter the converter to convert string values into their ASN.1 equivalents
+     */
+    public X509Name(
+        boolean                 reverse,
+        Hashtable               lookUp,
+        String                  dirName,
+        X509NameEntryConverter  converter)
+    {
+        this.converter = converter;
+        X509NameTokenizer   nTok = new X509NameTokenizer(dirName);
+
+        while (nTok.hasMoreTokens())
+        {
+            String  token = nTok.nextToken();
+            int     index = token.indexOf('=');
+
+            if (index == -1)
+            {
+                throw new IllegalArgumentException("badly formated directory string");
+            }
+
+            String              name = token.substring(0, index);
+            String              value = token.substring(index + 1);
+            DERObjectIdentifier oid = decodeOID(name, lookUp);
+
+            if (value.indexOf('+') > 0)
+            {
+                X509NameTokenizer   vTok = new X509NameTokenizer(value, '+');
+                String  v = vTok.nextToken();
+
+                this.ordering.addElement(oid);
+                this.values.addElement(v);
+                this.added.addElement(FALSE);
+
+                while (vTok.hasMoreTokens())
+                {
+                    String  sv = vTok.nextToken();
+                    int     ndx = sv.indexOf('=');
+
+                    String  nm = sv.substring(0, ndx);
+                    String  vl = sv.substring(ndx + 1);
+                    this.ordering.addElement(decodeOID(nm, lookUp));
+                    this.values.addElement(vl);
+                    this.added.addElement(TRUE);
+                }
+            }
+            else
+            {
+                this.ordering.addElement(oid);
+                this.values.addElement(value);
+                this.added.addElement(FALSE);
+            }
+        }
+
+        if (reverse)
+        {
+            Vector  o = new Vector();
+            Vector  v = new Vector();
+            Vector  a = new Vector();
+
+            int count = 1;
+
+            for (int i = 0; i < this.ordering.size(); i++)
+            {
+                if (((Boolean)this.added.elementAt(i)).booleanValue())
+                {
+                    o.insertElementAt(this.ordering.elementAt(i), count);
+                    v.insertElementAt(this.values.elementAt(i), count);
+                    a.insertElementAt(this.added.elementAt(i), count);
+                    count++;
+                }
+                else
+                {
+                    o.insertElementAt(this.ordering.elementAt(i), 0);
+                    v.insertElementAt(this.values.elementAt(i), 0);
+                    a.insertElementAt(this.added.elementAt(i), 0);
+                    count = 1;
+                }
+            }
+
+            this.ordering = o;
+            this.values = v;
+            this.added = a;
+        }
+    }
+
+    /**
+     * return a vector of the oids in the name, in the order they were found.
+     */
+    public Vector getOIDs()
+    {
+        Vector  v = new Vector();
+
+        for (int i = 0; i != ordering.size(); i++)
+        {
+            v.addElement(ordering.elementAt(i));
+        }
+
+        return v;
+    }
+
+    /**
+     * return a vector of the values found in the name, in the order they
+     * were found.
+     */
+    public Vector getValues()
+    {
+        Vector  v = new Vector();
+
+        for (int i = 0; i != values.size(); i++)
+        {
+            v.addElement(values.elementAt(i));
+        }
+
+        return v;
+    }
+
+    /**
+     * return a vector of the values found in the name, in the order they
+     * were found, with the DN label corresponding to passed in oid.
+     */
+    public Vector getValues(
+        DERObjectIdentifier oid)
+    {
+        Vector  v = new Vector();
+
+        for (int i = 0; i != values.size(); i++)
+        {
+            if (ordering.elementAt(i).equals(oid))
+            {
+                String val = (String)values.elementAt(i);
+
+                if (val.length() > 2 && val.charAt(0) == '\\' && val.charAt(1) == '#')
+                {
+                    v.addElement(val.substring(1));
+                }
+                else
+                {
+                    v.addElement(val);
+                }
+            }
+        }
+
+        return v;
+    }
+
+    public DERObject toASN1Object()
+    {
+        if (seq == null)
+        {
+            ASN1EncodableVector  vec = new ASN1EncodableVector();
+            ASN1EncodableVector  sVec = new ASN1EncodableVector();
+            DERObjectIdentifier  lstOid = null;
+            
+            for (int i = 0; i != ordering.size(); i++)
+            {
+                ASN1EncodableVector     v = new ASN1EncodableVector();
+                DERObjectIdentifier     oid = (DERObjectIdentifier)ordering.elementAt(i);
+
+                v.add(oid);
+
+                String  str = (String)values.elementAt(i);
+
+                v.add(converter.getConvertedValue(oid, str));
+ 
+                if (lstOid == null 
+                    || ((Boolean)this.added.elementAt(i)).booleanValue())
+                {
+                    sVec.add(new DERSequence(v));
+                }
+                else
+                {
+                    vec.add(new DERSet(sVec));
+                    sVec = new ASN1EncodableVector();
+                    
+                    sVec.add(new DERSequence(v));
+                }
+                
+                lstOid = oid;
+            }
+            
+            vec.add(new DERSet(sVec));
+            
+            seq = new DERSequence(vec);
+        }
+
+        return seq;
+    }
+
+    /**
+     * @param inOrder if true the order of both X509 names must be the same,
+     * as well as the values associated with each element.
+     */
+    public boolean equals(Object obj, boolean inOrder)
+    {
+        if (!inOrder)
+        {
+            return this.equals(obj);
+        }
+
+        if (obj == this)
+        {
+            return true;
+        }
+
+        if (!(obj instanceof X509Name || obj instanceof ASN1Sequence))
+        {
+            return false;
+        }
+
+        DERObject derO = ((DEREncodable)obj).getDERObject();
+
+        if (this.getDERObject().equals(derO))
+        {
+            return true;
+        }
+
+        X509Name other;
+
+        try
+        {
+            other = X509Name.getInstance(obj);
+        }
+        catch (IllegalArgumentException e)
+        {
+            return false;
+        }
+
+        int      orderingSize = ordering.size();
+
+        if (orderingSize != other.ordering.size())
+        {
+            return false;
+        }
+
+        for (int i = 0; i < orderingSize; i++)
+        {
+            DERObjectIdentifier  oid = (DERObjectIdentifier)ordering.elementAt(i);
+            DERObjectIdentifier  oOid = (DERObjectIdentifier)other.ordering.elementAt(i);
+
+            if (oid.equals(oOid))
+            {
+                String value = (String)values.elementAt(i);
+                String oValue = (String)other.values.elementAt(i);
+
+                if (!equivalentStrings(value, oValue))
+                {
+                    return false;
+                }
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public int hashCode()
+    {
+        if (isHashCodeCalculated)
+        {
+            return hashCodeValue;
+        }
+
+        isHashCodeCalculated = true;
+
+        // this needs to be order independent, like equals
+        for (int i = 0; i != ordering.size(); i += 1)
+        {
+            String value = (String)values.elementAt(i);
+
+            value = canonicalize(value);
+            value = stripInternalSpaces(value);
+
+            hashCodeValue ^= ordering.elementAt(i).hashCode();
+            hashCodeValue ^= value.hashCode();
+        }
+
+        return hashCodeValue;
+    }
+
+    /**
+     * test for equality - note: case is ignored.
+     */
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+
+        if (!(obj instanceof X509Name || obj instanceof ASN1Sequence))
+        {
+            return false;
+        }
+        
+        DERObject derO = ((DEREncodable)obj).getDERObject();
+        
+        if (this.getDERObject().equals(derO))
+        {
+            return true;
+        }
+
+        X509Name other;
+
+        try
+        {
+            other = X509Name.getInstance(obj);
+        }
+        catch (IllegalArgumentException e)
+        { 
+            return false;
+        }
+
+        int      orderingSize = ordering.size();
+
+        if (orderingSize != other.ordering.size())
+        {
+            return false;
+        }
+        
+        boolean[] indexes = new boolean[orderingSize];
+        int       start, end, delta;
+
+        if (ordering.elementAt(0).equals(other.ordering.elementAt(0)))   // guess forward
+        {
+            start = 0;
+            end = orderingSize;
+            delta = 1;
+        }
+        else  // guess reversed - most common problem
+        {
+            start = orderingSize - 1;
+            end = -1;
+            delta = -1;
+        }
+
+        for (int i = start; i != end; i += delta)
+        {
+            boolean              found = false;
+            DERObjectIdentifier  oid = (DERObjectIdentifier)ordering.elementAt(i);
+            String               value = (String)values.elementAt(i);
+
+            for (int j = 0; j < orderingSize; j++)
+            {
+                if (indexes[j])
+                {
+                    continue;
+                }
+
+                DERObjectIdentifier oOid = (DERObjectIdentifier)other.ordering.elementAt(j);
+
+                if (oid.equals(oOid))
+                {
+                    String oValue = (String)other.values.elementAt(j);
+
+                    if (equivalentStrings(value, oValue))
+                    {
+                        indexes[j] = true;
+                        found      = true;
+                        break;
+                    }
+                }
+            }
+
+            if (!found)
+            {
+                return false;
+            }
+        }
+        
+        return true;
+    }
+
+    private boolean equivalentStrings(String s1, String s2)
+    {
+        String value = canonicalize(s1);
+        String oValue = canonicalize(s2);
+        
+        if (!value.equals(oValue))
+        {
+            value = stripInternalSpaces(value);
+            oValue = stripInternalSpaces(oValue);
+
+            if (!value.equals(oValue))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private String canonicalize(String s)
+    {
+        String value = Strings.toLowerCase(s.trim());
+        
+        if (value.length() > 0 && value.charAt(0) == '#')
+        {
+            DERObject obj = decodeObject(value);
+
+            if (obj instanceof DERString)
+            {
+                value = Strings.toLowerCase(((DERString)obj).getString().trim());
+            }
+        }
+
+        return value;
+    }
+
+    private ASN1Object decodeObject(String oValue)
+    {
+        try
+        {
+            return ASN1Object.fromByteArray(Hex.decode(oValue.substring(1)));
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException("unknown encoding in name: " + e);
+        }
+    }
+
+    private String stripInternalSpaces(
+        String str)
+    {
+        StringBuffer res = new StringBuffer();
+
+        if (str.length() != 0)
+        {
+            char    c1 = str.charAt(0);
+
+            res.append(c1);
+
+            for (int k = 1; k < str.length(); k++)
+            {
+                char    c2 = str.charAt(k);
+                if (!(c1 == ' ' && c2 == ' '))
+                {
+                    res.append(c2);
+                }
+                c1 = c2;
+            }
+        }
+
+        return res.toString();
+    }
+
+    private void appendValue(
+        StringBuffer        buf,
+        Hashtable           oidSymbols,
+        DERObjectIdentifier oid,
+        String              value)
+    {
+        String  sym = (String)oidSymbols.get(oid);
+
+        if (sym != null)
+        {
+            buf.append(sym);
+        }
+        else
+        {
+            buf.append(oid.getId());
+        }
+
+        buf.append('=');
+
+        int     index = buf.length();
+        
+        buf.append(value);
+
+        int     end = buf.length();
+
+        if (value.length() >= 2 && value.charAt(0) == '\\' && value.charAt(1) == '#')
+        {
+            index += 2;   
+        }
+
+        while (index != end)
+        {
+            if ((buf.charAt(index) == ',')
+               || (buf.charAt(index) == '"')
+               || (buf.charAt(index) == '\\')
+               || (buf.charAt(index) == '+')
+               || (buf.charAt(index) == '=')
+               || (buf.charAt(index) == '<')
+               || (buf.charAt(index) == '>')
+               || (buf.charAt(index) == ';'))
+            {
+                buf.insert(index, "\\");
+                index++;
+                end++;
+            }
+
+            index++;
+        }
+    }
+
+    /**
+     * convert the structure to a string - if reverse is true the
+     * oids and values are listed out starting with the last element
+     * in the sequence (ala RFC 2253), otherwise the string will begin
+     * with the first element of the structure. If no string definition
+     * for the oid is found in oidSymbols the string value of the oid is
+     * added. Two standard symbol tables are provided DefaultSymbols, and
+     * RFC2253Symbols as part of this class.
+     *
+     * @param reverse if true start at the end of the sequence and work back.
+     * @param oidSymbols look up table strings for oids.
+     */
+    public String toString(
+        boolean     reverse,
+        Hashtable   oidSymbols)
+    {
+        StringBuffer            buf = new StringBuffer();
+        Vector                  components = new Vector();
+        boolean                 first = true;
+
+        StringBuffer ava = null;
+
+        for (int i = 0; i < ordering.size(); i++)
+        {
+            if (((Boolean)added.elementAt(i)).booleanValue())
+            {
+                ava.append('+');
+                appendValue(ava, oidSymbols,
+                    (DERObjectIdentifier)ordering.elementAt(i),
+                    (String)values.elementAt(i));
+            }
+            else
+            {
+                ava = new StringBuffer();
+                appendValue(ava, oidSymbols,
+                    (DERObjectIdentifier)ordering.elementAt(i),
+                    (String)values.elementAt(i));
+                components.addElement(ava);
+            }
+        }
+
+        if (reverse)
+        {
+            for (int i = components.size() - 1; i >= 0; i--)
+            {
+                if (first)
+                {
+                    first = false;
+                }
+                else
+                {
+                    buf.append(',');
+                }
+
+                buf.append(components.elementAt(i).toString());
+            }
+        }
+        else
+        {
+            for (int i = 0; i < components.size(); i++)
+            {
+                if (first)
+                {
+                    first = false;
+                }
+                else
+                {
+                    buf.append(',');
+                }
+
+                buf.append(components.elementAt(i).toString());
+            }
+        }
+
+        return buf.toString();
+    }
+
+    private String bytesToString(
+        byte[] data)
+    {
+        char[]  cs = new char[data.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(data[i] & 0xff);
+        }
+
+        return new String(cs);
+    }
+    
+    public String toString()
+    {
+        return toString(DefaultReverse, DefaultSymbols);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,113 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERPrintableString;
+import org.bouncycastle.util.Strings;
+
+import ewe.io.IOException;
+
+/**
+ * It turns out that the number of standard ways the fields in a DN should be 
+ * encoded into their ASN.1 counterparts is rapidly approaching the
+ * number of machines on the internet. By default the X509Name class 
+ * will produce UTF8Strings in line with the current recommendations (RFC 3280).
+ * <p>
+ * An example of an encoder look like below:
+ * <pre>
+ * public class X509DirEntryConverter
+ *     extends X509NameEntryConverter
+ * {
+ *     public DERObject getConvertedValue(
+ *         DERObjectIdentifier  oid,
+ *         String               value)
+ *     {
+ *         if (str.length() != 0 && str.charAt(0) == '#')
+ *         {
+ *             return convertHexEncoded(str, 1);
+ *         }
+ *         if (oid.equals(EmailAddress))
+ *         {
+ *             return new DERIA5String(str);
+ *         }
+ *         else if (canBePrintable(str))
+ *         {
+ *             return new DERPrintableString(str);
+ *         }
+ *         else if (canBeUTF8(str))
+ *         {
+ *             return new DERUTF8String(str);
+ *         }
+ *         else
+ *         {
+ *             return new DERBMPString(str);
+ *         }
+ *     }
+ * }
+ */
+public abstract class X509NameEntryConverter
+{
+    /**
+     * Convert an inline encoded hex string rendition of an ASN.1
+     * object back into its corresponding ASN.1 object.
+     * 
+     * @param str the hex encoded object
+     * @param off the index at which the encoding starts
+     * @return the decoded object
+     */
+    protected DERObject convertHexEncoded(
+        String  str,
+        int     off)
+        throws IOException
+    {
+        str = Strings.toLowerCase(str);
+        byte[] data = new byte[(str.length() - off) / 2];
+        for (int index = 0; index != data.length; index++)
+        {
+            char left = str.charAt((index * 2) + off);
+            char right = str.charAt((index * 2) + off + 1);
+            
+            if (left < 'a')
+            {
+                data[index] = (byte)((left - '0') << 4);
+            }
+            else
+            {
+                data[index] = (byte)((left - 'a' + 10) << 4);
+            }
+            if (right < 'a')
+            {
+                data[index] |= (byte)(right - '0');
+            }
+            else
+            {
+                data[index] |= (byte)(right - 'a' + 10);
+            }
+        }
+
+        ASN1InputStream aIn = new ASN1InputStream(data);
+                                            
+        return aIn.readObject();
+    }
+    
+    /**
+     * return true if the passed in String can be represented without
+     * loss as a PrintableString, false otherwise.
+     */
+    protected boolean canBePrintable(
+        String  str)
+    {
+        return DERPrintableString.isPrintableString(str);
+    }
+    
+    /**
+     * Convert the passed in String value into the appropriate ASN.1
+     * encoded object.
+     * 
+     * @param oid the oid associated with the value in the DN.
+     * @param value the value of the particular DN component.
+     * @return the ASN.1 equivalent for the value.
+     */
+    public abstract DERObject getConvertedValue(DERObjectIdentifier oid, String value);
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,99 @@
+package org.bouncycastle.asn1.x509;
+
+/**
+ * class for breaking up an X500 Name into it's component tokens, ala
+ * java.util.StringTokenizer. We need this class as some of the
+ * lightweight Java environment don't support classes like
+ * StringTokenizer.
+ */
+public class X509NameTokenizer
+{
+    private String          value;
+    private int             index;
+    private char            seperator;
+    private StringBuffer    buf = new StringBuffer();
+
+    public X509NameTokenizer(
+        String  oid)
+    {
+        this(oid, ',');
+    }
+    
+    public X509NameTokenizer(
+        String  oid,
+        char    seperator)
+    {
+        this.value = oid;
+        this.index = -1;
+        this.seperator = seperator;
+    }
+
+    public boolean hasMoreTokens()
+    {
+        return (index != value.length());
+    }
+
+    public String nextToken()
+    {
+        if (index == value.length())
+        {
+            return null;
+        }
+
+        int     end = index + 1;
+        boolean quoted = false;
+        boolean escaped = false;
+
+        buf.setLength(0);
+
+        while (end != value.length())
+        {
+            char    c = value.charAt(end);
+
+            if (c == '"')
+            {
+                if (!escaped)
+                {
+                    quoted = !quoted;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+                escaped = false;
+            }
+            else
+            {
+                if (escaped || quoted)
+                {
+                    if (c == '#' && buf.charAt(buf.length() - 1) == '=')
+                    {
+                        buf.append('\\');
+                    }
+                    else if (c == '+' && seperator != '+')
+                    {
+                        buf.append('\\');
+                    }
+                    buf.append(c);
+                    escaped = false;
+                }
+                else if (c == '\\')
+                {
+                    escaped = true;
+                }
+                else if (c == seperator)
+                {
+                    break;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+            }
+            end++;
+        }
+
+        index = end;
+        return buf.toString().trim();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,62 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface X509ObjectIdentifiers
+{
+    //
+    // base id
+    //
+    static final String                 id                      = "2.5.4";
+
+    static final ASN1ObjectIdentifier    commonName              = new ASN1ObjectIdentifier(id + ".3");
+    static final ASN1ObjectIdentifier    countryName             = new ASN1ObjectIdentifier(id + ".6");
+    static final ASN1ObjectIdentifier    localityName            = new ASN1ObjectIdentifier(id + ".7");
+    static final ASN1ObjectIdentifier    stateOrProvinceName     = new ASN1ObjectIdentifier(id + ".8");
+    static final ASN1ObjectIdentifier    organization            = new ASN1ObjectIdentifier(id + ".10");
+    static final ASN1ObjectIdentifier    organizationalUnitName  = new ASN1ObjectIdentifier(id + ".11");
+
+    static final ASN1ObjectIdentifier    id_at_telephoneNumber   = new ASN1ObjectIdentifier("2.5.4.20");
+    static final ASN1ObjectIdentifier    id_at_name              = new ASN1ObjectIdentifier(id + ".41");
+
+    // id-SHA1 OBJECT IDENTIFIER ::=    
+    //   {iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2) 26 }    //
+    static final ASN1ObjectIdentifier    id_SHA1                 = new ASN1ObjectIdentifier("1.3.14.3.2.26");
+
+    //
+    // ripemd160 OBJECT IDENTIFIER ::=
+    //      {iso(1) identified-organization(3) TeleTrust(36) algorithm(3) hashAlgorithm(2) RIPEMD-160(1)}
+    //
+    static final ASN1ObjectIdentifier    ripemd160               = new ASN1ObjectIdentifier("1.3.36.3.2.1");
+
+    //
+    // ripemd160WithRSAEncryption OBJECT IDENTIFIER ::=
+    //      {iso(1) identified-organization(3) TeleTrust(36) algorithm(3) signatureAlgorithm(3) rsaSignature(1) rsaSignatureWithripemd160(2) }
+    //
+    static final ASN1ObjectIdentifier    ripemd160WithRSAEncryption = new ASN1ObjectIdentifier("1.3.36.3.3.1.2");
+
+
+    static final ASN1ObjectIdentifier    id_ea_rsa = new ASN1ObjectIdentifier("2.5.8.1.1");
+    
+    // id-pkix
+    static final ASN1ObjectIdentifier id_pkix = new ASN1ObjectIdentifier("1.3.6.1.5.5.7");
+
+    //
+    // private internet extensions
+    //
+    static final ASN1ObjectIdentifier  id_pe = new ASN1ObjectIdentifier(id_pkix + ".1");
+
+    //
+    // authority information access
+    //
+    static final ASN1ObjectIdentifier  id_ad = new ASN1ObjectIdentifier(id_pkix + ".48");
+    static final ASN1ObjectIdentifier  id_ad_caIssuers = new ASN1ObjectIdentifier(id_ad + ".2");
+    static final ASN1ObjectIdentifier  id_ad_ocsp = new ASN1ObjectIdentifier(id_ad + ".1");
+
+    //
+    //    OID for ocsp and crl uri in AuthorityInformationAccess extension
+    //
+    static final ASN1ObjectIdentifier ocspAccessMethod = id_ad_ocsp;
+    static final ASN1ObjectIdentifier crlAccessMethod = id_ad_caIssuers;
+}
+

Added: trunk/src/org/bouncycastle/asn1/x509/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Support classes useful for encoding and processing X.509 certificates.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,139 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DHDomainParameters
+    extends ASN1Encodable
+{
+    private DERInteger p, g, q, j;
+    private DHValidationParms validationParms;
+
+    public static DHDomainParameters getInstance(ASN1TaggedObject obj, boolean explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static DHDomainParameters getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DHDomainParameters)
+        {
+            return (DHDomainParameters)obj;
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new DHDomainParameters((ASN1Sequence)obj);
+        }
+
+        throw new IllegalArgumentException("Invalid DHDomainParameters: "
+            + obj.getClass().getName());
+    }
+
+    public DHDomainParameters(DERInteger p, DERInteger g, DERInteger q, DERInteger j,
+        DHValidationParms validationParms)
+    {
+        if (p == null)
+        {
+            throw new IllegalArgumentException("'p' cannot be null");
+        }
+        if (g == null)
+        {
+            throw new IllegalArgumentException("'g' cannot be null");
+        }
+        if (q == null)
+        {
+            throw new IllegalArgumentException("'q' cannot be null");
+        }
+
+        this.p = p;
+        this.g = g;
+        this.q = q;
+        this.j = j;
+        this.validationParms = validationParms;
+    }
+
+    private DHDomainParameters(ASN1Sequence seq)
+    {
+        if (seq.size() < 3 || seq.size() > 5)
+        {
+            throw new IllegalArgumentException("Bad sequence size: " + seq.size());
+        }
+
+        Enumeration e = seq.getObjects();
+        this.p = DERInteger.getInstance(e.nextElement());
+        this.g = DERInteger.getInstance(e.nextElement());
+        this.q = DERInteger.getInstance(e.nextElement());
+
+        DEREncodable next = getNext(e);
+
+        if (next != null && next instanceof DERInteger)
+        {
+            this.j = DERInteger.getInstance(next);
+            next = getNext(e);
+        }
+
+        if (next != null)
+        {
+            this.validationParms = DHValidationParms.getInstance(next.getDERObject());
+        }
+    }
+
+    private static DEREncodable getNext(Enumeration e)
+    {
+        return e.hasMoreElements() ? (DEREncodable)e.nextElement() : null;
+    }
+
+    public DERInteger getP()
+    {
+        return this.p;
+    }
+
+    public DERInteger getG()
+    {
+        return this.g;
+    }
+
+    public DERInteger getQ()
+    {
+        return this.q;
+    }
+
+    public DERInteger getJ()
+    {
+        return this.j;
+    }
+
+    public DHValidationParms getValidationParms()
+    {
+        return this.validationParms;
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        v.add(this.p);
+        v.add(this.g);
+        v.add(this.q);
+
+        if (this.j != null)
+        {
+            v.add(this.j);
+        }
+
+        if (this.validationParms != null)
+        {
+            v.add(this.validationParms);
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,52 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+
+public class DHPublicKey
+    extends ASN1Encodable
+{
+    private DERInteger y;
+
+    public static DHPublicKey getInstance(ASN1TaggedObject obj, boolean explicit)
+    {
+        return getInstance(DERInteger.getInstance(obj, explicit));
+    }
+
+    public static DHPublicKey getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DHPublicKey)
+        {
+            return (DHPublicKey)obj;
+        }
+
+        if (obj instanceof DERInteger)
+        {
+            return new DHPublicKey((DERInteger)obj);
+        }
+
+        throw new IllegalArgumentException("Invalid DHPublicKey: " + obj.getClass().getName());
+    }
+
+    public DHPublicKey(DERInteger y)
+    {
+        if (y == null)
+        {
+            throw new IllegalArgumentException("'y' cannot be null");
+        }
+
+        this.y = y;
+    }
+
+    public DERInteger getY()
+    {
+        return this.y;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return this.y;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,80 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DHValidationParms extends ASN1Encodable
+{
+    private DERBitString seed;
+    private DERInteger pgenCounter;
+
+    public static DHValidationParms getInstance(ASN1TaggedObject obj, boolean explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static DHValidationParms getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DHDomainParameters)
+        {
+            return (DHValidationParms)obj;
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new DHValidationParms((ASN1Sequence)obj);
+        }
+
+        throw new IllegalArgumentException("Invalid DHValidationParms: " + obj.getClass().getName());
+    }
+
+    public DHValidationParms(DERBitString seed, DERInteger pgenCounter)
+    {
+        if (seed == null)
+        {
+            throw new IllegalArgumentException("'seed' cannot be null");
+        }
+        if (pgenCounter == null)
+        {
+            throw new IllegalArgumentException("'pgenCounter' cannot be null");
+        }
+
+        this.seed = seed;
+        this.pgenCounter = pgenCounter;
+    }
+
+    private DHValidationParms(ASN1Sequence seq)
+    {
+        if (seq.size() != 2)
+        {
+            throw new IllegalArgumentException("Bad sequence size: " + seq.size());
+        }
+
+        this.seed = DERBitString.getInstance(seq.getObjectAt(0));
+        this.pgenCounter = DERInteger.getInstance(seq.getObjectAt(1));
+    }
+
+    public DERBitString getSeed()
+    {
+        return this.seed;
+    }
+
+    public DERInteger getPgenCounter()
+    {
+        return this.pgenCounter;
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        v.add(this.seed);
+        v.add(this.pgenCounter);
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,621 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+
+/**
+ * table of the current named curves defined in X.962 EC-DSA.
+ */
+public class X962NamedCurves
+{
+    static X9ECParametersHolder prime192v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp192v1 = new ECCurve.Fp(
+                new BigInteger("6277101735386680763835789423207666416083908700390324961279"),
+                new BigInteger("fffffffffffffffffffffffffffffffefffffffffffffffc", 16),
+                new BigInteger("64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1", 16));
+
+            return new X9ECParameters(
+                cFp192v1,
+                cFp192v1.decodePoint(
+                    Hex.decode("03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012")),
+                new BigInteger("ffffffffffffffffffffffff99def836146bc9b1b4d22831", 16),
+                BigInteger.valueOf(1),
+                Hex.decode("3045AE6FC8422f64ED579528D38120EAE12196D5"));
+        }
+    };
+
+    static X9ECParametersHolder prime192v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp192v2 = new ECCurve.Fp(
+                new BigInteger("6277101735386680763835789423207666416083908700390324961279"),
+                new BigInteger("fffffffffffffffffffffffffffffffefffffffffffffffc", 16),
+                new BigInteger("cc22d6dfb95c6b25e49c0d6364a4e5980c393aa21668d953", 16));
+
+            return new X9ECParameters(
+                cFp192v2,
+                cFp192v2.decodePoint(
+                    Hex.decode("03eea2bae7e1497842f2de7769cfe9c989c072ad696f48034a")),
+                new BigInteger("fffffffffffffffffffffffe5fb1a724dc80418648d8dd31", 16),
+                BigInteger.valueOf(1),
+                Hex.decode("31a92ee2029fd10d901b113e990710f0d21ac6b6"));
+        }
+    };
+
+    static X9ECParametersHolder prime192v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp192v3 = new ECCurve.Fp(
+                new BigInteger("6277101735386680763835789423207666416083908700390324961279"),
+                new BigInteger("fffffffffffffffffffffffffffffffefffffffffffffffc", 16),
+                new BigInteger("22123dc2395a05caa7423daeccc94760a7d462256bd56916", 16));
+
+            return new X9ECParameters(
+                cFp192v3,
+                cFp192v3.decodePoint(
+                    Hex.decode("027d29778100c65a1da1783716588dce2b8b4aee8e228f1896")),
+                new BigInteger("ffffffffffffffffffffffff7a62d031c83f4294f640ec13", 16),
+                BigInteger.valueOf(1),
+                Hex.decode("c469684435deb378c4b65ca9591e2a5763059a2e"));
+        }
+    };
+
+    static X9ECParametersHolder prime239v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp239v1 = new ECCurve.Fp(
+                new BigInteger("883423532389192164791648750360308885314476597252960362792450860609699839"),
+                new BigInteger("7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc", 16),
+                new BigInteger("6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a", 16));
+
+            return new X9ECParameters(
+                cFp239v1,
+                cFp239v1.decodePoint(
+                    Hex.decode("020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf")),
+                new BigInteger("7fffffffffffffffffffffff7fffff9e5e9a9f5d9071fbd1522688909d0b", 16),
+                BigInteger.valueOf(1),
+                Hex.decode("e43bb460f0b80cc0c0b075798e948060f8321b7d"));
+        }
+    };
+
+    static X9ECParametersHolder prime239v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp239v2 = new ECCurve.Fp(
+                new BigInteger("883423532389192164791648750360308885314476597252960362792450860609699839"),
+                new BigInteger("7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc", 16),
+                new BigInteger("617fab6832576cbbfed50d99f0249c3fee58b94ba0038c7ae84c8c832f2c", 16));
+
+            return new X9ECParameters(
+                cFp239v2,
+                cFp239v2.decodePoint(
+                    Hex.decode("0238af09d98727705120c921bb5e9e26296a3cdcf2f35757a0eafd87b830e7")),
+                new BigInteger("7fffffffffffffffffffffff800000cfa7e8594377d414c03821bc582063", 16),
+                BigInteger.valueOf(1),
+                Hex.decode("e8b4011604095303ca3b8099982be09fcb9ae616"));
+        }
+    };
+
+    static X9ECParametersHolder prime239v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp239v3 = new ECCurve.Fp(
+                new BigInteger("883423532389192164791648750360308885314476597252960362792450860609699839"),
+                new BigInteger("7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc", 16),
+                new BigInteger("255705fa2a306654b1f4cb03d6a750a30c250102d4988717d9ba15ab6d3e", 16));
+
+            return new X9ECParameters(
+                cFp239v3,
+                cFp239v3.decodePoint(
+                    Hex.decode("036768ae8e18bb92cfcf005c949aa2c6d94853d0e660bbf854b1c9505fe95a")),
+                new BigInteger("7fffffffffffffffffffffff7fffff975deb41b3a6057c3c432146526551", 16),
+                BigInteger.valueOf(1),
+                Hex.decode("7d7374168ffe3471b60a857686a19475d3bfa2ff"));
+        }
+    };
+
+    static X9ECParametersHolder prime256v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp256v1 = new ECCurve.Fp(
+                new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"),
+                new BigInteger("ffffffff00000001000000000000000000000000fffffffffffffffffffffffc", 16),
+                new BigInteger("5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b", 16));
+
+            return new X9ECParameters(
+                cFp256v1,
+                cFp256v1.decodePoint(
+                    Hex.decode("036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296")),
+                new BigInteger("ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551", 16),
+                BigInteger.valueOf(1),
+                Hex.decode("c49d360886e704936a6678e1139d26b7819f7e90"));
+        }
+    };
+
+    /*
+     * F2m Curves
+     */
+    static X9ECParametersHolder c2pnb163v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m163v1n = new BigInteger("0400000000000000000001E60FC8821CC74DAEAFC1", 16);
+            BigInteger c2m163v1h = BigInteger.valueOf(2);
+
+            ECCurve c2m163v1 = new ECCurve.F2m(
+                163,
+                1, 2, 8,
+                new BigInteger("072546B5435234A422E0789675F432C89435DE5242", 16),
+                new BigInteger("00C9517D06D5240D3CFF38C74B20B6CD4D6F9DD4D9", 16),
+                c2m163v1n, c2m163v1h);
+
+            return new X9ECParameters(
+                c2m163v1,
+                c2m163v1.decodePoint(
+                    Hex.decode("0307AF69989546103D79329FCC3D74880F33BBE803CB")),
+                c2m163v1n, c2m163v1h,
+                Hex.decode("D2COFB15760860DEF1EEF4D696E6768756151754"));
+        }
+    };
+
+    static X9ECParametersHolder c2pnb163v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m163v2n = new BigInteger("03FFFFFFFFFFFFFFFFFFFDF64DE1151ADBB78F10A7", 16);
+            BigInteger c2m163v2h = BigInteger.valueOf(2);
+
+            ECCurve c2m163v2 = new ECCurve.F2m(
+                163,
+                1, 2, 8,
+                new BigInteger("0108B39E77C4B108BED981ED0E890E117C511CF072", 16),
+                new BigInteger("0667ACEB38AF4E488C407433FFAE4F1C811638DF20", 16),
+                c2m163v2n, c2m163v2h);
+
+            return new X9ECParameters(
+                c2m163v2,
+                c2m163v2.decodePoint(
+                    Hex.decode("030024266E4EB5106D0A964D92C4860E2671DB9B6CC5")),
+                c2m163v2n, c2m163v2h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb163v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m163v3n = new BigInteger("03FFFFFFFFFFFFFFFFFFFE1AEE140F110AFF961309", 16);
+            BigInteger c2m163v3h = BigInteger.valueOf(2);
+
+            ECCurve c2m163v3 = new ECCurve.F2m(
+                163,
+                1, 2, 8,
+                new BigInteger("07A526C63D3E25A256A007699F5447E32AE456B50E", 16),
+                new BigInteger("03F7061798EB99E238FD6F1BF95B48FEEB4854252B", 16),
+                c2m163v3n, c2m163v3h);
+
+            return new X9ECParameters(
+                c2m163v3,
+                c2m163v3.decodePoint(
+                    Hex.decode("0202F9F87B7C574D0BDECF8A22E6524775F98CDEBDCB")),
+                c2m163v3n, c2m163v3h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb176w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m176w1n = new BigInteger("010092537397ECA4F6145799D62B0A19CE06FE26AD", 16);
+            BigInteger c2m176w1h = BigInteger.valueOf(0xFF6E);
+
+            ECCurve c2m176w1 = new ECCurve.F2m(
+                176,
+                1, 2, 43,
+                new BigInteger("00E4E6DB2995065C407D9D39B8D0967B96704BA8E9C90B", 16),
+                new BigInteger("005DDA470ABE6414DE8EC133AE28E9BBD7FCEC0AE0FFF2", 16),
+                c2m176w1n, c2m176w1h);
+
+            return new X9ECParameters(
+                c2m176w1,
+                c2m176w1.decodePoint(
+                    Hex.decode("038D16C2866798B600F9F08BB4A8E860F3298CE04A5798")),
+                c2m176w1n, c2m176w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb191v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m191v1n = new BigInteger("40000000000000000000000004A20E90C39067C893BBB9A5", 16);
+            BigInteger c2m191v1h = BigInteger.valueOf(2);
+
+            ECCurve c2m191v1 = new ECCurve.F2m(
+                191,
+                9,
+                new BigInteger("2866537B676752636A68F56554E12640276B649EF7526267", 16),
+                new BigInteger("2E45EF571F00786F67B0081B9495A3D95462F5DE0AA185EC", 16),
+                c2m191v1n, c2m191v1h);
+
+            return new X9ECParameters(
+                c2m191v1,
+                c2m191v1.decodePoint(
+                    Hex.decode("0236B3DAF8A23206F9C4F299D7B21A9C369137F2C84AE1AA0D")),
+                c2m191v1n, c2m191v1h,
+                Hex.decode("4E13CA542744D696E67687561517552F279A8C84"));
+        }
+    };
+
+    static X9ECParametersHolder c2tnb191v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m191v2n = new BigInteger("20000000000000000000000050508CB89F652824E06B8173", 16);
+            BigInteger c2m191v2h = BigInteger.valueOf(4);
+
+            ECCurve c2m191v2 = new ECCurve.F2m(
+                191,
+                9,
+                new BigInteger("401028774D7777C7B7666D1366EA432071274F89FF01E718", 16),
+                new BigInteger("0620048D28BCBD03B6249C99182B7C8CD19700C362C46A01", 16),
+                c2m191v2n, c2m191v2h);
+
+            return new X9ECParameters(
+                c2m191v2,
+                c2m191v2.decodePoint(
+                    Hex.decode("023809B2B7CC1B28CC5A87926AAD83FD28789E81E2C9E3BF10")),
+                c2m191v2n, c2m191v2h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb191v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m191v3n = new BigInteger("155555555555555555555555610C0B196812BFB6288A3EA3", 16);
+            BigInteger c2m191v3h = BigInteger.valueOf(6);
+
+            ECCurve c2m191v3 = new ECCurve.F2m(
+                191,
+                9,
+                new BigInteger("6C01074756099122221056911C77D77E77A777E7E7E77FCB", 16),
+                new BigInteger("71FE1AF926CF847989EFEF8DB459F66394D90F32AD3F15E8", 16),
+                c2m191v3n, c2m191v3h);
+
+            return new X9ECParameters(
+                c2m191v3,
+                c2m191v3.decodePoint(
+                    Hex.decode("03375D4CE24FDE434489DE8746E71786015009E66E38A926DD")),
+                c2m191v3n, c2m191v3h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb208w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m208w1n = new BigInteger("0101BAF95C9723C57B6C21DA2EFF2D5ED588BDD5717E212F9D", 16);
+            BigInteger c2m208w1h = BigInteger.valueOf(0xFE48);
+
+            ECCurve c2m208w1 = new ECCurve.F2m(
+                208,
+                1, 2, 83,
+                new BigInteger("0", 16),
+                new BigInteger("00C8619ED45A62E6212E1160349E2BFA844439FAFC2A3FD1638F9E", 16),
+                c2m208w1n, c2m208w1h);
+
+            return new X9ECParameters(
+                c2m208w1,
+                c2m208w1.decodePoint(
+                    Hex.decode("0289FDFBE4ABE193DF9559ECF07AC0CE78554E2784EB8C1ED1A57A")),
+                c2m208w1n, c2m208w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb239v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m239v1n = new BigInteger("2000000000000000000000000000000F4D42FFE1492A4993F1CAD666E447", 16);
+            BigInteger c2m239v1h = BigInteger.valueOf(4);
+
+            ECCurve c2m239v1 = new ECCurve.F2m(
+                239,
+                36,
+                new BigInteger("32010857077C5431123A46B808906756F543423E8D27877578125778AC76", 16),
+                new BigInteger("790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16", 16),
+                c2m239v1n, c2m239v1h);
+
+            return new X9ECParameters(
+                c2m239v1,
+                c2m239v1.decodePoint(
+                    Hex.decode("0257927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D")),
+                c2m239v1n, c2m239v1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb239v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m239v2n = new BigInteger("1555555555555555555555555555553C6F2885259C31E3FCDF154624522D", 16);
+            BigInteger c2m239v2h = BigInteger.valueOf(6);
+
+            ECCurve c2m239v2 = new ECCurve.F2m(
+                239,
+                36,
+                new BigInteger("4230017757A767FAE42398569B746325D45313AF0766266479B75654E65F", 16),
+                new BigInteger("5037EA654196CFF0CD82B2C14A2FCF2E3FF8775285B545722F03EACDB74B", 16),
+                c2m239v2n, c2m239v2h);
+
+            return new X9ECParameters(
+                c2m239v2,
+                c2m239v2.decodePoint(
+                    Hex.decode("0228F9D04E900069C8DC47A08534FE76D2B900B7D7EF31F5709F200C4CA205")),
+                c2m239v2n, c2m239v2h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb239v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m239v3n = new BigInteger("0CCCCCCCCCCCCCCCCCCCCCCCCCCCCCAC4912D2D9DF903EF9888B8A0E4CFF", 16);
+            BigInteger c2m239v3h = BigInteger.valueOf(10);
+
+            ECCurve c2m239v3 = new ECCurve.F2m(
+                239,
+                36,
+                new BigInteger("01238774666A67766D6676F778E676B66999176666E687666D8766C66A9F", 16),
+                new BigInteger("6A941977BA9F6A435199ACFC51067ED587F519C5ECB541B8E44111DE1D40", 16),
+                c2m239v3n, c2m239v3h);
+
+            return new X9ECParameters(
+                c2m239v3,
+                c2m239v3.decodePoint(
+                    Hex.decode("0370F6E9D04D289C4E89913CE3530BFDE903977D42B146D539BF1BDE4E9C92")),
+                c2m239v3n, c2m239v3h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb272w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m272w1n = new BigInteger("0100FAF51354E0E39E4892DF6E319C72C8161603FA45AA7B998A167B8F1E629521", 16);
+            BigInteger c2m272w1h = BigInteger.valueOf(0xFF06);
+
+            ECCurve c2m272w1 = new ECCurve.F2m(
+                272,
+                1, 3, 56,
+                new BigInteger("0091A091F03B5FBA4AB2CCF49C4EDD220FB028712D42BE752B2C40094DBACDB586FB20", 16),
+                new BigInteger("7167EFC92BB2E3CE7C8AAAFF34E12A9C557003D7C73A6FAF003F99F6CC8482E540F7", 16),
+                c2m272w1n, c2m272w1h);
+
+            return new X9ECParameters(
+                c2m272w1,
+                c2m272w1.decodePoint(
+                    Hex.decode("026108BABB2CEEBCF787058A056CBE0CFE622D7723A289E08A07AE13EF0D10D171DD8D")),
+                c2m272w1n, c2m272w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb304w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m304w1n = new BigInteger("0101D556572AABAC800101D556572AABAC8001022D5C91DD173F8FB561DA6899164443051D", 16);
+            BigInteger c2m304w1h = BigInteger.valueOf(0xFE2E);
+
+            ECCurve c2m304w1 = new ECCurve.F2m(
+                304,
+                1, 2, 11,
+                new BigInteger("00FD0D693149A118F651E6DCE6802085377E5F882D1B510B44160074C1288078365A0396C8E681", 16),
+                new BigInteger("00BDDB97E555A50A908E43B01C798EA5DAA6788F1EA2794EFCF57166B8C14039601E55827340BE", 16),
+                c2m304w1n, c2m304w1h);
+
+            return new X9ECParameters(
+                c2m304w1,
+                c2m304w1.decodePoint(
+                    Hex.decode("02197B07845E9BE2D96ADB0F5F3C7F2CFFBD7A3EB8B6FEC35C7FD67F26DDF6285A644F740A2614")),
+                c2m304w1n, c2m304w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb359v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m359v1n = new BigInteger("01AF286BCA1AF286BCA1AF286BCA1AF286BCA1AF286BC9FB8F6B85C556892C20A7EB964FE7719E74F490758D3B", 16);
+            BigInteger c2m359v1h = BigInteger.valueOf(0x4C);
+
+            ECCurve c2m359v1 = new ECCurve.F2m(
+                359,
+                68,
+                new BigInteger("5667676A654B20754F356EA92017D946567C46675556F19556A04616B567D223A5E05656FB549016A96656A557", 16),
+                new BigInteger("2472E2D0197C49363F1FE7F5B6DB075D52B6947D135D8CA445805D39BC345626089687742B6329E70680231988", 16),
+                c2m359v1n, c2m359v1h);
+
+            return new X9ECParameters(
+                c2m359v1,
+                c2m359v1.decodePoint(
+                    Hex.decode("033C258EF3047767E7EDE0F1FDAA79DAEE3841366A132E163ACED4ED2401DF9C6BDCDE98E8E707C07A2239B1B097")),
+                c2m359v1n, c2m359v1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb368w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m368w1n = new BigInteger("010090512DA9AF72B08349D98A5DD4C7B0532ECA51CE03E2D10F3B7AC579BD87E909AE40A6F131E9CFCE5BD967", 16);
+            BigInteger c2m368w1h = BigInteger.valueOf(0xFF70);
+
+            ECCurve c2m368w1 = new ECCurve.F2m(
+                368,
+                1, 2, 85,
+                new BigInteger("00E0D2EE25095206F5E2A4F9ED229F1F256E79A0E2B455970D8D0D865BD94778C576D62F0AB7519CCD2A1A906AE30D", 16),
+                new BigInteger("00FC1217D4320A90452C760A58EDCD30C8DD069B3C34453837A34ED50CB54917E1C2112D84D164F444F8F74786046A", 16),
+                c2m368w1n, c2m368w1h);
+
+            return new X9ECParameters(
+                c2m368w1,
+                c2m368w1.decodePoint(
+                    Hex.decode("021085E2755381DCCCE3C1557AFA10C2F0C0C2825646C5B34A394CBCFA8BC16B22E7E789E927BE216F02E1FB136A5F")),
+                c2m368w1n, c2m368w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb431r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m431r1n = new BigInteger("0340340340340340340340340340340340340340340340340340340323C313FAB50589703B5EC68D3587FEC60D161CC149C1AD4A91", 16);
+            BigInteger c2m431r1h = BigInteger.valueOf(0x2760);
+
+            ECCurve c2m431r1 = new ECCurve.F2m(
+                431,
+                120,
+                new BigInteger("1A827EF00DD6FC0E234CAF046C6A5D8A85395B236CC4AD2CF32A0CADBDC9DDF620B0EB9906D0957F6C6FEACD615468DF104DE296CD8F", 16),
+                new BigInteger("10D9B4A3D9047D8B154359ABFB1B7F5485B04CEB868237DDC9DEDA982A679A5A919B626D4E50A8DD731B107A9962381FB5D807BF2618", 16),
+                c2m431r1n, c2m431r1h);
+
+            return new X9ECParameters(
+                c2m431r1,
+                c2m431r1.decodePoint(
+                    Hex.decode("02120FC05D3C67A99DE161D2F4092622FECA701BE4F50F4758714E8A87BBF2A658EF8C21E7C5EFE965361F6C2999C0C247B0DBD70CE6B7")),
+                c2m431r1n, c2m431r1h,
+                null);
+        }
+    };
+
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable curves = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid, X9ECParametersHolder holder)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+        curves.put(oid, holder);
+    }
+
+    static
+    {
+        defineCurve("prime192v1", X9ObjectIdentifiers.prime192v1, prime192v1);
+        defineCurve("prime192v2", X9ObjectIdentifiers.prime192v2, prime192v2);
+        defineCurve("prime192v3", X9ObjectIdentifiers.prime192v3, prime192v3);
+        defineCurve("prime239v1", X9ObjectIdentifiers.prime239v1, prime239v1);
+        defineCurve("prime239v2", X9ObjectIdentifiers.prime239v2, prime239v2);
+        defineCurve("prime239v3", X9ObjectIdentifiers.prime239v3, prime239v3);
+        defineCurve("prime256v1", X9ObjectIdentifiers.prime256v1, prime256v1);
+        defineCurve("c2pnb163v1", X9ObjectIdentifiers.c2pnb163v1, c2pnb163v1);
+        defineCurve("c2pnb163v2", X9ObjectIdentifiers.c2pnb163v2, c2pnb163v2);
+        defineCurve("c2pnb163v3", X9ObjectIdentifiers.c2pnb163v3, c2pnb163v3);
+        defineCurve("c2pnb176w1", X9ObjectIdentifiers.c2pnb176w1, c2pnb176w1);
+        defineCurve("c2tnb191v1", X9ObjectIdentifiers.c2tnb191v1, c2tnb191v1);
+        defineCurve("c2tnb191v2", X9ObjectIdentifiers.c2tnb191v2, c2tnb191v2);
+        defineCurve("c2tnb191v3", X9ObjectIdentifiers.c2tnb191v3, c2tnb191v3);
+        defineCurve("c2pnb208w1", X9ObjectIdentifiers.c2pnb208w1, c2pnb208w1);
+        defineCurve("c2tnb239v1", X9ObjectIdentifiers.c2tnb239v1, c2tnb239v1);
+        defineCurve("c2tnb239v2", X9ObjectIdentifiers.c2tnb239v2, c2tnb239v2);
+        defineCurve("c2tnb239v3", X9ObjectIdentifiers.c2tnb239v3, c2tnb239v3);
+        defineCurve("c2pnb272w1", X9ObjectIdentifiers.c2pnb272w1, c2pnb272w1);
+        defineCurve("c2pnb304w1", X9ObjectIdentifiers.c2pnb304w1, c2pnb304w1);
+        defineCurve("c2tnb359v1", X9ObjectIdentifiers.c2tnb359v1, c2tnb359v1);
+        defineCurve("c2pnb368w1", X9ObjectIdentifiers.c2pnb368w1, c2pnb368w1);
+        defineCurve("c2tnb431r1", X9ObjectIdentifiers.c2tnb431r1, c2tnb431r1);
+    }
+
+    public static X9ECParameters getByName(
+        String name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier oid)
+    {
+        X9ECParametersHolder holder = (X9ECParametersHolder)curves.get(oid);
+
+        if (holder != null)
+        {
+            return holder.getParameters();
+        }
+
+        return null;
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,86 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Choice;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Null;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+
+public class X962Parameters
+    extends ASN1Encodable
+    implements ASN1Choice
+{
+    private DERObject           params = null;
+
+    public static X962Parameters getInstance(
+        Object obj)
+    {
+        if (obj == null || obj instanceof X962Parameters) 
+        {
+            return (X962Parameters)obj;
+        }
+        
+        if (obj instanceof DERObject) 
+        {
+            return new X962Parameters((DERObject)obj);
+        }
+        
+        throw new IllegalArgumentException("unknown object in getInstance()");
+    }
+    
+    public static X962Parameters getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(obj.getObject()); // must be explicitly tagged
+    }
+    
+    public X962Parameters(
+        X9ECParameters      ecParameters)
+    {
+        this.params = ecParameters.getDERObject();
+    }
+
+    public X962Parameters(
+        DERObjectIdentifier  namedCurve)
+    {
+        this.params = namedCurve;
+    }
+
+    public X962Parameters(
+        DERObject           obj)
+    {
+        this.params = obj;
+    }
+
+    public boolean isNamedCurve()
+    {
+        return (params instanceof DERObjectIdentifier);
+    }
+
+    public boolean isImplicitlyCA()
+    {
+        return (params instanceof ASN1Null);
+    }
+
+    public DERObject getParameters()
+    {
+        return params;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     * Parameters ::= CHOICE {
+     *    ecParameters ECParameters,
+     *    namedCurve   CURVES.&id({CurveNames}),
+     *    implicitlyCA NULL
+     * }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        return params;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9Curve.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9Curve.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9Curve.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,161 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.math.ec.ECCurve;
+
+/**
+ * ASN.1 def for Elliptic-Curve Curve structure. See
+ * X9.62, for further details.
+ */
+public class X9Curve
+    extends ASN1Encodable
+    implements X9ObjectIdentifiers
+{
+    private ECCurve     curve;
+    private byte[]      seed;
+    private DERObjectIdentifier fieldIdentifier = null;
+
+    public X9Curve(
+        ECCurve     curve)
+    {
+        this.curve = curve;
+        this.seed = null;
+        setFieldIdentifier();
+    }
+
+    public X9Curve(
+        ECCurve     curve,
+        byte[]      seed)
+    {
+        this.curve = curve;
+        this.seed = seed;
+        setFieldIdentifier();
+    }
+
+    public X9Curve(
+        X9FieldID     fieldID,
+        ASN1Sequence  seq)
+    {
+        fieldIdentifier = fieldID.getIdentifier();
+        if (fieldIdentifier.equals(prime_field))
+        {
+            BigInteger      p = ((DERInteger)fieldID.getParameters()).getValue();
+            X9FieldElement  x9A = new X9FieldElement(p, (ASN1OctetString)seq.getObjectAt(0));
+            X9FieldElement  x9B = new X9FieldElement(p, (ASN1OctetString)seq.getObjectAt(1));
+            curve = new ECCurve.Fp(p, x9A.getValue().toBigInteger(), x9B.getValue().toBigInteger());
+        }
+        else
+        {
+            if (fieldIdentifier.equals(characteristic_two_field)) 
+            {
+                // Characteristic two field
+                DERSequence parameters = (DERSequence)fieldID.getParameters();
+                int m = ((DERInteger)parameters.getObjectAt(0)).getValue().
+                    intValue();
+                DERObjectIdentifier representation
+                    = (DERObjectIdentifier)parameters.getObjectAt(1);
+
+                int k1 = 0;
+                int k2 = 0;
+                int k3 = 0;
+                if (representation.equals(tpBasis)) 
+                {
+                    // Trinomial basis representation
+                    k1 = ((DERInteger)parameters.getObjectAt(2)).getValue().
+                        intValue();
+                }
+                else 
+                {
+                    // Pentanomial basis representation
+                    DERSequence pentanomial
+                        = (DERSequence)parameters.getObjectAt(2);
+                    k1 = ((DERInteger)pentanomial.getObjectAt(0)).getValue().
+                        intValue();
+                    k2 = ((DERInteger)pentanomial.getObjectAt(1)).getValue().
+                        intValue();
+                    k3 = ((DERInteger)pentanomial.getObjectAt(2)).getValue().
+                        intValue();
+                }
+                X9FieldElement x9A = new X9FieldElement(m, k1, k2, k3, (ASN1OctetString)seq.getObjectAt(0));
+                X9FieldElement x9B = new X9FieldElement(m, k1, k2, k3, (ASN1OctetString)seq.getObjectAt(1));
+                // TODO Is it possible to get the order (n) and cofactor(h) too?
+                curve = new ECCurve.F2m(m, k1, k2, k3, x9A.getValue().toBigInteger(), x9B.getValue().toBigInteger());
+            }
+        }
+
+        if (seq.size() == 3)
+        {
+            seed = ((DERBitString)seq.getObjectAt(2)).getBytes();
+        }
+    }
+
+    private void setFieldIdentifier()
+    {
+        if (curve instanceof ECCurve.Fp)
+        {
+            fieldIdentifier = prime_field;
+        }
+        else if (curve instanceof ECCurve.F2m)
+        {
+            fieldIdentifier = characteristic_two_field;
+        }
+        else
+        {
+            throw new IllegalArgumentException("This type of ECCurve is not "
+                    + "implemented");
+        }
+    }
+
+    public ECCurve  getCurve()
+    {
+        return curve;
+    }
+
+    public byte[]   getSeed()
+    {
+        return seed;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     *  Curve ::= SEQUENCE {
+     *      a               FieldElement,
+     *      b               FieldElement,
+     *      seed            BIT STRING      OPTIONAL
+     *  }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        if (fieldIdentifier.equals(prime_field)) 
+        { 
+            v.add(new X9FieldElement(curve.getA()).getDERObject());
+            v.add(new X9FieldElement(curve.getB()).getDERObject());
+        } 
+        else if (fieldIdentifier.equals(characteristic_two_field)) 
+        {
+            v.add(new X9FieldElement(curve.getA()).getDERObject());
+            v.add(new X9FieldElement(curve.getB()).getDERObject());
+        }
+
+        if (seed != null)
+        {
+            v.add(new DERBitString(seed));
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,161 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+
+import ewe.math.BigInteger;
+
+/**
+ * ASN.1 def for Elliptic-Curve ECParameters structure. See
+ * X9.62, for further details.
+ */
+public class X9ECParameters
+    extends ASN1Encodable
+    implements X9ObjectIdentifiers
+{
+    private static final BigInteger   ONE = BigInteger.valueOf(1);
+
+    private X9FieldID           fieldID;
+    private ECCurve             curve;
+    private ECPoint             g;
+    private BigInteger          n;
+    private BigInteger          h;
+    private byte[]              seed;
+
+    public X9ECParameters(
+        ASN1Sequence  seq)
+    {
+        if (!(seq.getObjectAt(0) instanceof DERInteger)
+           || !((DERInteger)seq.getObjectAt(0)).getValue().equals(ONE))
+        {
+            throw new IllegalArgumentException("bad version in X9ECParameters");
+        }
+
+        X9Curve     x9c = new X9Curve(
+                        new X9FieldID((ASN1Sequence)seq.getObjectAt(1)),
+                        (ASN1Sequence)seq.getObjectAt(2));
+
+        this.curve = x9c.getCurve();
+        this.g = new X9ECPoint(curve, (ASN1OctetString)seq.getObjectAt(3)).getPoint();
+        this.n = ((DERInteger)seq.getObjectAt(4)).getValue();
+        this.seed = x9c.getSeed();
+
+        if (seq.size() == 6)
+        {
+            this.h = ((DERInteger)seq.getObjectAt(5)).getValue();
+        }
+    }
+
+    public X9ECParameters(
+        ECCurve     curve,
+        ECPoint     g,
+        BigInteger  n)
+    {
+        this(curve, g, n, ONE, null);
+    }
+
+    public X9ECParameters(
+        ECCurve     curve,
+        ECPoint     g,
+        BigInteger  n,
+        BigInteger  h)
+    {
+        this(curve, g, n, h, null);
+    }
+
+    public X9ECParameters(
+        ECCurve     curve,
+        ECPoint     g,
+        BigInteger  n,
+        BigInteger  h,
+        byte[]      seed)
+    {
+        this.curve = curve;
+        this.g = g;
+        this.n = n;
+        this.h = h;
+        this.seed = seed;
+
+        if (curve instanceof ECCurve.Fp)
+        {
+            this.fieldID = new X9FieldID(((ECCurve.Fp)curve).getQ());
+        }
+        else
+        {
+            if (curve instanceof ECCurve.F2m)
+            {
+                ECCurve.F2m curveF2m = (ECCurve.F2m)curve;
+                this.fieldID = new X9FieldID(curveF2m.getM(), curveF2m.getK1(),
+                    curveF2m.getK2(), curveF2m.getK3());
+            }
+        }
+    }
+
+    public ECCurve getCurve()
+    {
+        return curve;
+    }
+
+    public ECPoint getG()
+    {
+        return g;
+    }
+
+    public BigInteger getN()
+    {
+        return n;
+    }
+
+    public BigInteger getH()
+    {
+        if (h == null)
+        {
+            return ONE;        // TODO - this should be calculated, it will cause issues with custom curves.
+        }
+
+        return h;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     *  ECParameters ::= SEQUENCE {
+     *      version         INTEGER { ecpVer1(1) } (ecpVer1),
+     *      fieldID         FieldID {{FieldTypes}},
+     *      curve           X9Curve,
+     *      base            X9ECPoint,
+     *      order           INTEGER,
+     *      cofactor        INTEGER OPTIONAL
+     *  }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(new DERInteger(1));
+        v.add(fieldID);
+        v.add(new X9Curve(curve, seed));
+        v.add(new X9ECPoint(g));
+        v.add(new DERInteger(n));
+
+        if (h != null)
+        {
+            v.add(new DERInteger(h));
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.asn1.x9;
+
+public abstract class X9ECParametersHolder
+{
+    private X9ECParameters params;
+
+    public X9ECParameters getParameters()
+    {
+        if (params == null)
+        {
+            params = createParameters();
+        }
+
+        return params;
+    }
+
+    protected abstract X9ECParameters createParameters();
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DEROctetString;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+
+/**
+ * class for describing an ECPoint as a DER object.
+ */
+public class X9ECPoint
+    extends ASN1Encodable
+{
+    ECPoint p;
+
+    public X9ECPoint(
+        ECPoint p)
+    {
+        this.p = p;
+    }
+
+    public X9ECPoint(
+        ECCurve          c,
+        ASN1OctetString  s)
+    {
+        this.p = c.decodePoint(s.getOctets());
+    }
+
+    public ECPoint getPoint()
+    {
+        return p;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     *  ECPoint ::= OCTET STRING
+     * </pre>
+     * <p>
+     * Octet string produced using ECPoint.getEncoded().
+     */
+    public DERObject toASN1Object()
+    {
+        return new DEROctetString(p.getEncoded());
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,64 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DEROctetString;
+import org.bouncycastle.math.ec.ECFieldElement;
+
+/**
+ * class for processing an FieldElement as a DER object.
+ */
+public class X9FieldElement
+    extends ASN1Encodable
+{
+    protected ECFieldElement  f;
+    
+    private static X9IntegerConverter converter = new X9IntegerConverter();
+
+    public X9FieldElement(ECFieldElement f)
+    {
+        this.f = f;
+    }
+    
+    public X9FieldElement(BigInteger p, ASN1OctetString s)
+    {
+        this(new ECFieldElement.Fp(p, new BigInteger(1, s.getOctets())));
+    }
+    
+    public X9FieldElement(int m, int k1, int k2, int k3, ASN1OctetString s)
+    {
+        this(new ECFieldElement.F2m(m, k1, k2, k3, new BigInteger(1, s.getOctets())));
+    }
+    
+    public ECFieldElement getValue()
+    {
+        return f;
+    }
+    
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * <pre>
+     *  FieldElement ::= OCTET STRING
+     * </pre>
+     * <p>
+     * <ol>
+     * <li> if <i>q</i> is an odd prime then the field element is
+     * processed as an Integer and converted to an octet string
+     * according to x 9.62 4.3.1.</li>
+     * <li> if <i>q</i> is 2<sup>m</sup> then the bit string
+     * contained in the field element is converted into an octet
+     * string with the same ordering padded at the front if necessary.
+     * </li>
+     * </ol>
+     */
+    public DERObject toASN1Object()
+    {
+        int byteCount = converter.getByteLength(f);
+        byte[] paddedBigInteger = converter.integerToBytes(f.toBigInteger(), byteCount);
+
+        return new DEROctetString(paddedBigInteger);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,109 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+
+/**
+ * ASN.1 def for Elliptic-Curve Field ID structure. See
+ * X9.62, for further details.
+ */
+public class X9FieldID
+    extends ASN1Encodable
+    implements X9ObjectIdentifiers
+{
+    private DERObjectIdentifier     id;
+    private DERObject               parameters;
+
+    /**
+     * Constructor for elliptic curves over prime fields
+     * <code>F<sub>2</sub></code>.
+     * @param primeP The prime <code>p</code> defining the prime field.
+     */
+    public X9FieldID(BigInteger primeP)
+    {
+        this.id = prime_field;
+        this.parameters = new DERInteger(primeP);
+    }
+
+    /**
+     * Constructor for elliptic curves over binary fields
+     * <code>F<sub>2<sup>m</sup></sub></code>.
+     * @param m  The exponent <code>m</code> of
+     * <code>F<sub>2<sup>m</sup></sub></code>.
+     * @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
+     * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+     * represents the reduction polynomial <code>f(z)</code>.
+     * @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
+     * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+     * represents the reduction polynomial <code>f(z)</code>.
+     * @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
+     * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+     * represents the reduction polynomial <code>f(z)</code>..
+     */
+    public X9FieldID(int m, int k1, int k2, int k3)
+    {
+        this.id = characteristic_two_field;
+        ASN1EncodableVector fieldIdParams = new ASN1EncodableVector();
+        fieldIdParams.add(new DERInteger(m));
+        
+        if (k2 == 0) 
+        {
+            fieldIdParams.add(tpBasis);
+            fieldIdParams.add(new DERInteger(k1));
+        } 
+        else 
+        {
+            fieldIdParams.add(ppBasis);
+            ASN1EncodableVector pentanomialParams = new ASN1EncodableVector();
+            pentanomialParams.add(new DERInteger(k1));
+            pentanomialParams.add(new DERInteger(k2));
+            pentanomialParams.add(new DERInteger(k3));
+            fieldIdParams.add(new DERSequence(pentanomialParams));
+        }
+        
+        this.parameters = new DERSequence(fieldIdParams);
+    }
+
+    public X9FieldID(
+        ASN1Sequence  seq)
+    {
+        this.id = (DERObjectIdentifier)seq.getObjectAt(0);
+        this.parameters = (DERObject)seq.getObjectAt(1);
+    }
+
+    public DERObjectIdentifier getIdentifier()
+    {
+        return id;
+    }
+
+    public DERObject getParameters()
+    {
+        return parameters;
+    }
+
+    /**
+     * Produce a DER encoding of the following structure.
+     * <pre>
+     *  FieldID ::= SEQUENCE {
+     *      fieldType       FIELD-ID.&amp;id({IOSet}),
+     *      parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
+     *  }
+     * </pre>
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(this.id);
+        v.add(this.parameters);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,47 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECFieldElement;
+
+import ewe.math.BigInteger;
+
+public class X9IntegerConverter
+{
+    public int getByteLength(
+        ECCurve c)
+    {
+        return (c.getFieldSize() + 7) / 8;
+    }
+
+    public int getByteLength(
+        ECFieldElement fe)
+    {
+        return (fe.getFieldSize() + 7) / 8;
+    }
+
+    public byte[] integerToBytes(
+        BigInteger s,
+        int        qLength)
+    {
+        byte[] bytes = s.toByteArray();
+        
+        if (qLength < bytes.length)
+        {
+            byte[] tmp = new byte[qLength];
+        
+            System.arraycopy(bytes, bytes.length - tmp.length, tmp, 0, tmp.length);
+            
+            return tmp;
+        }
+        else if (qLength > bytes.length)
+        {
+            byte[] tmp = new byte[qLength];
+        
+            System.arraycopy(bytes, 0, tmp, tmp.length - bytes.length, bytes.length);
+            
+            return tmp; 
+        }
+    
+        return bytes;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,132 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface X9ObjectIdentifiers
+{
+    //
+    // X9.62
+    //
+    // ansi-X9-62 OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+    //            us(840) ansi-x962(10045) }
+    //
+    static final ASN1ObjectIdentifier ansi_X9_62 = new ASN1ObjectIdentifier("1.2.840.10045");
+    static final ASN1ObjectIdentifier id_fieldType = ansi_X9_62.branch("1");
+
+    static final ASN1ObjectIdentifier prime_field = id_fieldType.branch("1");
+
+    static final ASN1ObjectIdentifier characteristic_two_field = id_fieldType.branch("2");
+
+    static final ASN1ObjectIdentifier gnBasis = id_fieldType.branch("2.3.1");
+
+    static final ASN1ObjectIdentifier tpBasis = id_fieldType.branch("2.3.2");
+
+    static final ASN1ObjectIdentifier ppBasis = id_fieldType.branch("2.3.3");
+
+    static final ASN1ObjectIdentifier id_ecSigType = ansi_X9_62.branch("4");
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA1 = new ASN1ObjectIdentifier(id_ecSigType + ".1");
+
+    static final ASN1ObjectIdentifier id_publicKeyType = ansi_X9_62.branch("2");
+
+    static final ASN1ObjectIdentifier id_ecPublicKey = id_publicKeyType.branch("1");
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA2 = id_ecSigType.branch("3");
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA224 = ecdsa_with_SHA2.branch("1");
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA256 = ecdsa_with_SHA2.branch("2");
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA384 = ecdsa_with_SHA2.branch("3");
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA512 = ecdsa_with_SHA2.branch("4");
+
+    //
+    // named curves
+    //
+    static final ASN1ObjectIdentifier ellipticCurve = ansi_X9_62.branch("3");
+
+    //
+    // Two Curves
+    //
+    static final ASN1ObjectIdentifier  cTwoCurve = ellipticCurve.branch("0");
+
+    static final ASN1ObjectIdentifier c2pnb163v1 = cTwoCurve.branch("1");
+    static final ASN1ObjectIdentifier c2pnb163v2 = cTwoCurve.branch("2");
+    static final ASN1ObjectIdentifier c2pnb163v3 = cTwoCurve.branch("3");
+    static final ASN1ObjectIdentifier c2pnb176w1 = cTwoCurve.branch("4");
+    static final ASN1ObjectIdentifier c2tnb191v1 = cTwoCurve.branch("5");
+    static final ASN1ObjectIdentifier c2tnb191v2 = cTwoCurve.branch("6");
+    static final ASN1ObjectIdentifier c2tnb191v3 = cTwoCurve.branch("7");
+    static final ASN1ObjectIdentifier c2onb191v4 = cTwoCurve.branch("8");
+    static final ASN1ObjectIdentifier c2onb191v5 = cTwoCurve.branch("9");
+    static final ASN1ObjectIdentifier c2pnb208w1 = cTwoCurve.branch("10");
+    static final ASN1ObjectIdentifier c2tnb239v1 = cTwoCurve.branch("11");
+    static final ASN1ObjectIdentifier c2tnb239v2 = cTwoCurve.branch("12");
+    static final ASN1ObjectIdentifier c2tnb239v3 = cTwoCurve.branch("13");
+    static final ASN1ObjectIdentifier c2onb239v4 = cTwoCurve.branch("14");
+    static final ASN1ObjectIdentifier c2onb239v5 = cTwoCurve.branch("15");
+    static final ASN1ObjectIdentifier c2pnb272w1 = cTwoCurve.branch("16");
+    static final ASN1ObjectIdentifier c2pnb304w1 = cTwoCurve.branch("17");
+    static final ASN1ObjectIdentifier c2tnb359v1 = cTwoCurve.branch("18");
+    static final ASN1ObjectIdentifier c2pnb368w1 = cTwoCurve.branch("19");
+    static final ASN1ObjectIdentifier c2tnb431r1 = cTwoCurve.branch("20");
+
+    //
+    // Prime
+    //
+    static final ASN1ObjectIdentifier primeCurve = ellipticCurve.branch("1");
+
+    static final ASN1ObjectIdentifier prime192v1 = primeCurve.branch("1");
+    static final ASN1ObjectIdentifier prime192v2 = primeCurve.branch("2");
+    static final ASN1ObjectIdentifier prime192v3 = primeCurve.branch("3");
+    static final ASN1ObjectIdentifier prime239v1 = primeCurve.branch("4");
+    static final ASN1ObjectIdentifier prime239v2 = primeCurve.branch("5");
+    static final ASN1ObjectIdentifier prime239v3 = primeCurve.branch("6");
+    static final ASN1ObjectIdentifier prime256v1 = primeCurve.branch("7");
+
+    //
+    // DSA
+    //
+    // dsapublicnumber OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+    //            us(840) ansi-x957(10040) number-type(4) 1 }
+    static final ASN1ObjectIdentifier id_dsa = new ASN1ObjectIdentifier("1.2.840.10040.4.1");
+
+    /**
+     * id-dsa-with-sha1 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) x9-57
+     * (10040) x9cm(4) 3 }
+     */
+    public static final ASN1ObjectIdentifier id_dsa_with_sha1 = new ASN1ObjectIdentifier("1.2.840.10040.4.3");
+
+    /**
+     * X9.63
+     */
+    public static final ASN1ObjectIdentifier x9_63_scheme = new ASN1ObjectIdentifier("1.3.133.16.840.63.0");
+    public static final ASN1ObjectIdentifier dhSinglePass_stdDH_sha1kdf_scheme = x9_63_scheme.branch("2");
+    public static final ASN1ObjectIdentifier dhSinglePass_cofactorDH_sha1kdf_scheme = x9_63_scheme.branch("3");
+    public static final ASN1ObjectIdentifier mqvSinglePass_sha1kdf_scheme = x9_63_scheme.branch("16");
+
+    /**
+     * X9.42
+     */
+
+    static final ASN1ObjectIdentifier ansi_X9_42 = new ASN1ObjectIdentifier("1.2.840.10046");
+
+    //
+    // Diffie-Hellman
+    //
+    // dhpublicnumber OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+    //            us(840) ansi-x942(10046) number-type(2) 1 }
+    //
+    public static final ASN1ObjectIdentifier dhpublicnumber = ansi_X9_42.branch("2.1");
+
+    public static final ASN1ObjectIdentifier x9_42_schemes = ansi_X9_42.branch("3");
+    public static final ASN1ObjectIdentifier dhStatic = x9_42_schemes.branch("1");
+    public static final ASN1ObjectIdentifier dhEphem = x9_42_schemes.branch("2");
+    public static final ASN1ObjectIdentifier dhOneFlow = x9_42_schemes.branch("3");
+    public static final ASN1ObjectIdentifier dhHybrid1 = x9_42_schemes.branch("4");
+    public static final ASN1ObjectIdentifier dhHybrid2 = x9_42_schemes.branch("5");
+    public static final ASN1ObjectIdentifier dhHybridOneFlow = x9_42_schemes.branch("6");
+    public static final ASN1ObjectIdentifier mqv2 = x9_42_schemes.branch("7");
+    public static final ASN1ObjectIdentifier mqv1 = x9_42_schemes.branch("8");
+}

Added: trunk/src/org/bouncycastle/asn1/x9/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Support classes useful for encoding and supporting X9.62 elliptic curve.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,45 @@
+package org.bouncycastle.crypto;
+
+
+/**
+ * base interface that a public/private key block cipher needs
+ * to conform to.
+ */
+public interface AsymmetricBlockCipher
+{
+    /**
+     * initialise the cipher.
+     *
+     * @param forEncryption if true the cipher is initialised for 
+     *  encryption, if false for decryption.
+     * @param param the key and other data required by the cipher.
+     */
+    public void init(boolean forEncryption, CipherParameters param);
+
+    /**
+     * returns the largest size an input block can be.
+     *
+     * @return maximum size for an input block.
+     */
+    public int getInputBlockSize();
+
+    /**
+     * returns the maximum size of the block produced by this cipher.
+     *
+     * @return maximum size of the output block produced by the cipher.
+     */
+    public int getOutputBlockSize();
+
+    /**
+     * process the block of len bytes stored in in from offset inOff.
+     *
+     * @param in the input data
+     * @param inOff offset into the in array where the data starts
+     * @param len the length of the block to be processed.
+     * @return the resulting byte array of the encryption/decryption process.
+     * @exception InvalidCipherTextException data decrypts improperly.
+     * @exception DataLengthException the input data is too large for the cipher.
+     */
+    public byte[] processBlock(byte[] in, int inOff, int len)
+        throws InvalidCipherTextException;
+}

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,44 @@
+package org.bouncycastle.crypto;
+
+/**
+ * a holding class for public/private parameter pairs.
+ */
+public class AsymmetricCipherKeyPair
+{
+    private CipherParameters    publicParam;
+    private CipherParameters    privateParam;
+
+    /**
+     * basic constructor.
+     *
+     * @param publicParam a public key parameters object.
+     * @param privateParam the corresponding private key parameters.
+     */
+    public AsymmetricCipherKeyPair(
+        CipherParameters    publicParam,
+        CipherParameters    privateParam)
+    {
+        this.publicParam = publicParam;
+        this.privateParam = privateParam;
+    }
+
+    /**
+     * return the public key parameters.
+     *
+     * @return the public key parameters.
+     */
+    public CipherParameters getPublic()
+    {
+        return publicParam;
+    }
+
+    /**
+     * return the private key parameters.
+     *
+     * @return the private key parameters.
+     */
+    public CipherParameters getPrivate()
+    {
+        return privateParam;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.crypto;
+
+/**
+ * interface that a public/private key pair generator should conform to.
+ */
+public interface AsymmetricCipherKeyPairGenerator
+{
+    /**
+     * intialise the key pair generator.
+     *
+     * @param param the parameters the key pair is to be initialised with.
+     */
+    public void init(KeyGenerationParameters param);
+
+    /**
+     * return an AsymmetricCipherKeyPair containing the generated keys.
+     *
+     * @return an AsymmetricCipherKeyPair containing the generated keys.
+     */
+    public AsymmetricCipherKeyPair generateKeyPair();
+}
+

Added: trunk/src/org/bouncycastle/crypto/BasicAgreement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/BasicAgreement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/BasicAgreement.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/BasicAgreement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/BasicAgreement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,21 @@
+package org.bouncycastle.crypto;
+
+import ewe.math.BigInteger;
+
+/**
+ * The basic interface that basic Diffie-Hellman implementations
+ * conforms to.
+ */
+public interface BasicAgreement
+{
+    /**
+     * initialise the agreement engine.
+     */
+    public void init(CipherParameters param);
+
+    /**
+     * given a public key from a given party calculate the next
+     * message in the agreement sequence. 
+     */
+    public BigInteger calculateAgreement(CipherParameters pubKey);
+}

Added: trunk/src/org/bouncycastle/crypto/BlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/BlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/BlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/BlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/BlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,56 @@
+package org.bouncycastle.crypto;
+
+
+/**
+ * Block cipher engines are expected to conform to this interface.
+ */
+public interface BlockCipher
+{
+    /**
+     * Initialise the cipher.
+     *
+     * @param forEncryption if true the cipher is initialised for
+     *  encryption, if false for decryption.
+     * @param params the key and other data required by the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(boolean forEncryption, CipherParameters params)
+        throws IllegalArgumentException;
+
+    /**
+     * Return the name of the algorithm the cipher implements.
+     *
+     * @return the name of the algorithm the cipher implements.
+     */
+    public String getAlgorithmName();
+
+    /**
+     * Return the block size for this cipher (in bytes).
+     *
+     * @return the block size for this cipher in bytes.
+     */
+    public int getBlockSize();
+
+    /**
+     * Process one block of input from the array in and write it to
+     * the out array.
+     *
+     * @param in the array containing the input data.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the output data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    public int processBlock(byte[] in, int inOff, byte[] out, int outOff)
+        throws DataLengthException, IllegalStateException;
+
+    /**
+     * Reset the cipher. After resetting the cipher is in the same state
+     * as it was after the last init (if there was one).
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/CipherParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/CipherParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/CipherParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/CipherParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/CipherParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,8 @@
+package org.bouncycastle.crypto;
+
+/**
+ * all parameter classes implement this.
+ */
+public interface CipherParameters
+{
+}

Added: trunk/src/org/bouncycastle/crypto/CryptoException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/CryptoException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/CryptoException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/CryptoException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/CryptoException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,26 @@
+package org.bouncycastle.crypto;
+
+/**
+ * the foundation class for the hard exceptions thrown by the crypto packages.
+ */
+public class CryptoException 
+    extends Exception
+{
+    /**
+     * base constructor.
+     */
+    public CryptoException()
+    {
+    }
+
+    /**
+     * create a CryptoException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public CryptoException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/DSA.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/DSA.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/DSA.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/DSA.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/DSA.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.crypto;
+
+import ewe.math.BigInteger;
+
+/**
+ * interface for classes implementing algorithms modeled similar to the Digital Signature Alorithm.
+ */
+public interface DSA
+{
+    /**
+     * initialise the signer for signature generation or signature
+     * verification.
+     *
+     * @param forSigning true if we are generating a signature, false
+     * otherwise.
+     * @param param key parameters for signature generation.
+     */
+    public void init(boolean forSigning, CipherParameters param);
+
+    /**
+     * sign the passed in message (usually the output of a hash function).
+     *
+     * @param message the message to be signed.
+     * @return two big integers representing the r and s values respectively.
+     */
+    public BigInteger[] generateSignature(byte[] message);
+
+    /**
+     * verify the message message against the signature values r and s.
+     *
+     * @param message the message that was supposed to have been signed.
+     * @param r the r signature value.
+     * @param s the s signature value.
+     */
+    public boolean verifySignature(byte[] message, BigInteger  r, BigInteger s);
+}

Added: trunk/src/org/bouncycastle/crypto/DataLengthException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/DataLengthException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/DataLengthException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/DataLengthException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/DataLengthException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,29 @@
+package org.bouncycastle.crypto;
+
+/**
+ * this exception is thrown if a buffer that is meant to have output
+ * copied into it turns out to be too short, or if we've been given 
+ * insufficient input. In general this exception will get thrown rather
+ * than an ArrayOutOfBounds exception.
+ */
+public class DataLengthException 
+    extends RuntimeCryptoException
+{
+    /**
+     * base constructor.
+     */
+    public DataLengthException()
+    {
+    }
+
+    /**
+     * create a DataLengthException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public DataLengthException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,51 @@
+package org.bouncycastle.crypto;
+
+/**
+ * interface that a message digest conforms to.
+ */
+public interface Digest
+{
+    /**
+     * return the algorithm name
+     *
+     * @return the algorithm name
+     */
+    public String getAlgorithmName();
+
+    /**
+     * return the size, in bytes, of the digest produced by this message digest.
+     *
+     * @return the size, in bytes, of the digest produced by this message digest.
+     */
+    public int getDigestSize();
+
+    /**
+     * update the message digest with a single byte.
+     *
+     * @param in the input byte to be entered.
+     */
+    public void update(byte in);
+
+    /**
+     * update the message digest with a block of bytes.
+     *
+     * @param in the byte array containing the data.
+     * @param inOff the offset into the byte array where the data starts.
+     * @param len the length of the data.
+     */
+    public void update(byte[] in, int inOff, int len);
+
+    /**
+     * close the digest, producing the final digest value. The doFinal
+     * call leaves the digest reset.
+     *
+     * @param out the array the digest is to be copied into.
+     * @param outOff the offset into the out array the digest is to start at.
+     */
+    public int doFinal(byte[] out, int outOff);
+
+    /**
+     * reset the digest back to it's initial state.
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/ExtendedDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/ExtendedDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/ExtendedDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,13 @@
+package org.bouncycastle.crypto;
+
+public interface ExtendedDigest 
+    extends Digest
+{
+    /**
+     * Return the size in bytes of the internal buffer the digest applies it's compression
+     * function to.
+     * 
+     * @return byte length of the digests internal buffer.
+     */
+    public int getByteLength();
+}

Added: trunk/src/org/bouncycastle/crypto/ExtensionType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/ExtensionType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/ExtensionType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/ExtensionType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/ExtensionType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto;
+
+/**
+ * RFC 4366 2.3
+ */
+public class ExtensionType
+{
+    public static final int server_name = 0;
+    public static final int max_fragment_length = 1;
+    public static final int client_certificate_url = 2;
+    public static final int trusted_ca_keys = 3;
+    public static final int truncated_hmac = 4;
+    public static final int status_request = 5;
+
+    /*
+     * RFC 4492
+     */
+    public static final int elliptic_curves = 10;
+    public static final int ec_point_formats = 11;
+
+    /*
+     * RFC 5054 2.8.1
+     */
+    public static final int srp = 12;
+
+    /*
+     * RFC 5746 6
+     */
+    public static final int renegotiation_info = 0xff01;
+}

Added: trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,27 @@
+package org.bouncycastle.crypto;
+
+/**
+ * this exception is thrown whenever we find something we don't expect in a
+ * message.
+ */
+public class InvalidCipherTextException 
+    extends CryptoException
+{
+    /**
+     * base constructor.
+     */
+    public InvalidCipherTextException()
+    {
+    }
+
+    /**
+     * create a InvalidCipherTextException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public InvalidCipherTextException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.crypto;
+
+import ewe.security.SecureRandom;
+
+/**
+ * The base class for parameters to key generators.
+ */
+public class KeyGenerationParameters
+{
+    private SecureRandom    random;
+    private int             strength;
+
+    /**
+     * initialise the generator with a source of randomness
+     * and a strength (in bits).
+     *
+     * @param random the random byte source.
+     * @param strength the size, in bits, of the keys we want to produce.
+     */
+    public KeyGenerationParameters(
+        SecureRandom    random,
+        int             strength)
+    {
+        this.random = random;
+        this.strength = strength;
+    }
+
+    /**
+     * return the random source associated with this
+     * generator.
+     *
+     * @return the generators random source.
+     */
+    public SecureRandom getRandom()
+    {
+        return random;
+    }
+
+    /**
+     * return the bit strength for keys produced by this generator,
+     *
+     * @return the strength of the keys this generator produces (in bits).
+     */
+    public int getStrength()
+    {
+        return strength;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/Mac.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/Mac.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/Mac.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/Mac.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/Mac.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,71 @@
+package org.bouncycastle.crypto;
+
+
+/**
+ * The base interface for implementations of message authentication codes (MACs).
+ */
+public interface Mac
+{
+    /**
+     * Initialise the MAC.
+     *
+     * @param params the key and other data required by the MAC.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(CipherParameters params)
+        throws IllegalArgumentException;
+
+    /**
+     * Return the name of the algorithm the MAC implements.
+     *
+     * @return the name of the algorithm the MAC implements.
+     */
+    public String getAlgorithmName();
+
+    /**
+     * Return the block size for this MAC (in bytes).
+     *
+     * @return the block size for this MAC in bytes.
+     */
+    public int getMacSize();
+
+    /**
+     * add a single byte to the mac for processing.
+     *
+     * @param in the byte to be processed.
+     * @exception IllegalStateException if the MAC is not initialised.
+     */
+    public void update(byte in)
+        throws IllegalStateException;
+
+    /**
+     * @param in the array containing the input.
+     * @param inOff the index in the array the data begins at.
+     * @param len the length of the input starting at inOff.
+     * @exception IllegalStateException if the MAC is not initialised.
+     * @exception DataLengthException if there isn't enough data in in.
+     */
+    public void update(byte[] in, int inOff, int len)
+        throws DataLengthException, IllegalStateException;
+
+    /**
+     * Compute the final stage of the MAC writing the output to the out
+     * parameter.
+     * <p>
+     * doFinal leaves the MAC in the same state it was after the last init.
+     *
+     * @param out the array the MAC is to be output to.
+     * @param outOff the offset into the out buffer the output is to start at.
+     * @exception DataLengthException if there isn't enough space in out.
+     * @exception IllegalStateException if the MAC is not initialised.
+     */
+    public int doFinal(byte[] out, int outOff)
+        throws DataLengthException, IllegalStateException;
+
+    /**
+     * Reset the MAC. At the end of resetting the MAC should be in the
+     * in the same state it was after the last init (if there was one).
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,26 @@
+package org.bouncycastle.crypto;
+
+/**
+ * the foundation class for the exceptions thrown by the crypto packages.
+ */
+public class RuntimeCryptoException 
+    extends RuntimeException
+{
+    /**
+     * base constructor.
+     */
+    public RuntimeCryptoException()
+    {
+    }
+
+    /**
+     * create a RuntimeCryptoException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public RuntimeCryptoException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/Signer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/Signer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/Signer.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/Signer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/Signer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,43 @@
+package org.bouncycastle.crypto;
+
+/**
+ * Generic signer interface for hash based and message recovery signers.
+ */
+public interface Signer 
+{
+    /**
+     * Initialise the signer for signing or verification.
+     * 
+     * @param forSigning true if for signing, false otherwise
+     * @param param necessary parameters.
+     */
+    public void init(boolean forSigning, CipherParameters param);
+
+    /**
+     * update the internal digest with the byte b
+     */
+    public void update(byte b);
+
+    /**
+     * update the internal digest with the byte array in
+     */
+    public void update(byte[] in, int off, int len);
+
+    /**
+     * generate a signature for the message we've been loaded with using
+     * the key we were initialised with.
+     */
+    public byte[] generateSignature()
+        throws CryptoException, DataLengthException;
+
+    /**
+     * return true if the internal state represents the signature described
+     * in the passed in array.
+     */
+    public boolean verifySignature(byte[] signature);
+    
+    /**
+     * reset the internal state
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,66 @@
+package org.bouncycastle.crypto.agreement;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.BasicAgreement;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+/**
+ * a Diffie-Hellman key agreement class.
+ * <p>
+ * note: This is only the basic algorithm, it doesn't take advantage of
+ * long term public keys if they are available. See the DHAgreement class
+ * for a "better" implementation.
+ */
+public class DHBasicAgreement
+    implements BasicAgreement
+{
+    private DHPrivateKeyParameters  key;
+    private DHParameters            dhParams;
+
+    public void init(
+        CipherParameters    param)
+    {
+        AsymmetricKeyParameter  kParam;
+
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom rParam = (ParametersWithRandom)param;
+            kParam = (AsymmetricKeyParameter)rParam.getParameters();
+        }
+        else
+        {
+            kParam = (AsymmetricKeyParameter)param;
+        }
+
+        if (!(kParam instanceof DHPrivateKeyParameters))
+        {
+            throw new IllegalArgumentException("DHEngine expects DHPrivateKeyParameters");
+        }
+
+        this.key = (DHPrivateKeyParameters)kParam;
+        this.dhParams = key.getParameters();
+    }
+
+    /**
+     * given a short term public key from a given party calculate the next
+     * message in the agreement sequence. 
+     */
+    public BigInteger calculateAgreement(
+        CipherParameters   pubKey)
+    {
+        DHPublicKeyParameters   pub = (DHPublicKeyParameters)pubKey;
+
+        if (!pub.getParameters().equals(dhParams))
+        {
+            throw new IllegalArgumentException("Diffie-Hellman public key has wrong parameters.");
+        }
+
+        return pub.getY().modPow(key.getX(), dhParams.getP());
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,47 @@
+package org.bouncycastle.crypto.agreement;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.math.ec.ECPoint;
+
+import org.bouncycastle.crypto.BasicAgreement;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+
+/**
+ * P1363 7.2.1 ECSVDP-DH
+ *
+ * ECSVDP-DH is Elliptic Curve Secret Value Derivation Primitive,
+ * Diffie-Hellman version. It is based on the work of [DH76], [Mil86],
+ * and [Kob87]. This primitive derives a shared secret value from one
+ * party's private key and another party's public key, where both have
+ * the same set of EC domain parameters. If two parties correctly
+ * execute this primitive, they will produce the same output. This
+ * primitive can be invoked by a scheme to derive a shared secret key;
+ * specifically, it may be used with the schemes ECKAS-DH1 and
+ * DL/ECKAS-DH2. It assumes that the input keys are valid (see also
+ * Section 7.2.2).
+ */
+public class ECDHBasicAgreement
+    implements BasicAgreement
+{
+    private ECPrivateKeyParameters key;
+
+    public void init(
+        CipherParameters key)
+    {
+        this.key = (ECPrivateKeyParameters)key;
+    }
+
+    public BigInteger calculateAgreement(
+        CipherParameters pubKey)
+    {
+        ECPublicKeyParameters pub = (ECPublicKeyParameters)pubKey;
+        ECPoint P = pub.getQ().multiply(key.getD());
+
+        // if (p.isInfinity()) throw new RuntimeException("d*Q == infinity");
+
+        return P.getX().toBigInteger();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/agreement/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/agreement/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/agreement/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Basic key agreement classes.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,135 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.ExtendedDigest;
+
+/**
+ * base implementation of MD4 family style digest as outlined in
+ * "Handbook of Applied Cryptography", pages 344 - 347.
+ */
+public abstract class GeneralDigest
+    implements ExtendedDigest
+{
+    private static final int BYTE_LENGTH = 64;
+    private byte[]  xBuf;
+    private int     xBufOff;
+
+    private long    byteCount;
+
+    /**
+     * Standard constructor
+     */
+    protected GeneralDigest()
+    {
+        xBuf = new byte[4];
+        xBufOff = 0;
+    }
+
+    /**
+     * Copy constructor.  We are using copy constructors in place
+     * of the Object.clone() interface as this interface is not
+     * supported by J2ME.
+     */
+    protected GeneralDigest(GeneralDigest t)
+    {
+        xBuf = new byte[t.xBuf.length];
+        System.arraycopy(t.xBuf, 0, xBuf, 0, t.xBuf.length);
+
+        xBufOff = t.xBufOff;
+        byteCount = t.byteCount;
+    }
+
+    public void update(
+        byte in)
+    {
+        xBuf[xBufOff++] = in;
+
+        if (xBufOff == xBuf.length)
+        {
+            processWord(xBuf, 0);
+            xBufOff = 0;
+        }
+
+        byteCount++;
+    }
+
+    public void update(
+        byte[]  in,
+        int     inOff,
+        int     len)
+    {
+        //
+        // fill the current word
+        //
+        while ((xBufOff != 0) && (len > 0))
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+
+        //
+        // process whole words.
+        //
+        while (len > xBuf.length)
+        {
+            processWord(in, inOff);
+
+            inOff += xBuf.length;
+            len -= xBuf.length;
+            byteCount += xBuf.length;
+        }
+
+        //
+        // load in the remainder.
+        //
+        while (len > 0)
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+    }
+
+    public void finish()
+    {
+        long    bitLength = (byteCount << 3);
+
+        //
+        // add the pad bytes.
+        //
+        update((byte)128);
+
+        while (xBufOff != 0)
+        {
+            update((byte)0);
+        }
+
+        processLength(bitLength);
+
+        processBlock();
+    }
+
+    public void reset()
+    {
+        byteCount = 0;
+
+        xBufOff = 0;
+        for (int i = 0; i < xBuf.length; i++)
+        {
+            xBuf[i] = 0;
+        }
+    }
+
+    public int getByteLength()
+    {
+        return BYTE_LENGTH;
+    }
+    
+    protected abstract void processWord(byte[] in, int inOff);
+
+    protected abstract void processLength(long bitLength);
+
+    protected abstract void processBlock();
+}

Added: trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/LongDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/LongDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/LongDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,354 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.ExtendedDigest;
+import org.bouncycastle.crypto.util.Pack;
+
+/**
+ * Base class for SHA-384 and SHA-512.
+ */
+public abstract class LongDigest
+    implements ExtendedDigest
+{
+    private static final int BYTE_LENGTH = 128;
+    
+    private byte[]  xBuf;
+    private int     xBufOff;
+
+    private long    byteCount1;
+    private long    byteCount2;
+
+    protected long    H1, H2, H3, H4, H5, H6, H7, H8;
+
+    private long[]  W = new long[80];
+    private int     wOff;
+
+    /**
+     * Constructor for variable length word
+     */
+    protected LongDigest()
+    {
+        xBuf = new byte[8];
+        xBufOff = 0;
+
+        reset();
+    }
+
+    /**
+     * Copy constructor.  We are using copy constructors in place
+     * of the Object.clone() interface as this interface is not
+     * supported by J2ME.
+     */
+    protected LongDigest(LongDigest t)
+    {
+        xBuf = new byte[t.xBuf.length];
+        System.arraycopy(t.xBuf, 0, xBuf, 0, t.xBuf.length);
+
+        xBufOff = t.xBufOff;
+        byteCount1 = t.byteCount1;
+        byteCount2 = t.byteCount2;
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+        H5 = t.H5;
+        H6 = t.H6;
+        H7 = t.H7;
+        H8 = t.H8;
+
+        System.arraycopy(t.W, 0, W, 0, t.W.length);
+        wOff = t.wOff;
+    }
+
+    public void update(
+        byte in)
+    {
+        xBuf[xBufOff++] = in;
+
+        if (xBufOff == xBuf.length)
+        {
+            processWord(xBuf, 0);
+            xBufOff = 0;
+        }
+
+        byteCount1++;
+    }
+
+    public void update(
+        byte[]  in,
+        int     inOff,
+        int     len)
+    {
+        //
+        // fill the current word
+        //
+        while ((xBufOff != 0) && (len > 0))
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+
+        //
+        // process whole words.
+        //
+        while (len > xBuf.length)
+        {
+            processWord(in, inOff);
+
+            inOff += xBuf.length;
+            len -= xBuf.length;
+            byteCount1 += xBuf.length;
+        }
+
+        //
+        // load in the remainder.
+        //
+        while (len > 0)
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+    }
+
+    public void finish()
+    {
+        adjustByteCounts();
+
+        long    lowBitLength = byteCount1 << 3;
+        long    hiBitLength = byteCount2;
+
+        //
+        // add the pad bytes.
+        //
+        update((byte)128);
+
+        while (xBufOff != 0)
+        {
+            update((byte)0);
+        }
+
+        processLength(lowBitLength, hiBitLength);
+
+        processBlock();
+    }
+
+    public void reset()
+    {
+        byteCount1 = 0;
+        byteCount2 = 0;
+
+        xBufOff = 0;
+        for (int i = 0; i < xBuf.length; i++)
+        {
+            xBuf[i] = 0;
+        }
+
+        wOff = 0;
+        for (int i = 0; i != W.length; i++)
+        {
+            W[i] = 0;
+        }
+    }
+
+    public int getByteLength()
+    {
+        return BYTE_LENGTH;
+    }
+    
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        W[wOff] = Pack.bigEndianToLong(in, inOff);
+
+        if (++wOff == 16)
+        {
+            processBlock();
+        }
+    }
+
+    /**
+     * adjust the byte counts so that byteCount2 represents the
+     * upper long (less 3 bits) word of the byte count.
+     */
+    private void adjustByteCounts()
+    {
+        if (byteCount1 > 0x1fffffffffffffffL)
+        {
+            byteCount2 += (byteCount1 >>> 61);
+            byteCount1 &= 0x1fffffffffffffffL;
+        }
+    }
+
+    protected void processLength(
+        long    lowW,
+        long    hiW)
+    {
+        if (wOff > 14)
+        {
+            processBlock();
+        }
+
+        W[14] = hiW;
+        W[15] = lowW;
+    }
+
+    protected void processBlock()
+    {
+        adjustByteCounts();
+
+        //
+        // expand 16 word block into 80 word blocks.
+        //
+        for (int t = 16; t <= 79; t++)
+        {
+            W[t] = Sigma1(W[t - 2]) + W[t - 7] + Sigma0(W[t - 15]) + W[t - 16];
+        }
+
+        //
+        // set up working variables.
+        //
+        long     a = H1;
+        long     b = H2;
+        long     c = H3;
+        long     d = H4;
+        long     e = H5;
+        long     f = H6;
+        long     g = H7;
+        long     h = H8;
+
+        int t = 0;     
+        for(int i = 0; i < 10; i ++)
+        {
+          // t = 8 * i
+          h += Sum1(e) + Ch(e, f, g) + K[t] + W[t++];
+          d += h;
+          h += Sum0(a) + Maj(a, b, c);
+
+          // t = 8 * i + 1
+          g += Sum1(d) + Ch(d, e, f) + K[t] + W[t++];
+          c += g;
+          g += Sum0(h) + Maj(h, a, b);
+
+          // t = 8 * i + 2
+          f += Sum1(c) + Ch(c, d, e) + K[t] + W[t++];
+          b += f;
+          f += Sum0(g) + Maj(g, h, a);
+
+          // t = 8 * i + 3
+          e += Sum1(b) + Ch(b, c, d) + K[t] + W[t++];
+          a += e;
+          e += Sum0(f) + Maj(f, g, h);
+
+          // t = 8 * i + 4
+          d += Sum1(a) + Ch(a, b, c) + K[t] + W[t++];
+          h += d;
+          d += Sum0(e) + Maj(e, f, g);
+
+          // t = 8 * i + 5
+          c += Sum1(h) + Ch(h, a, b) + K[t] + W[t++];
+          g += c;
+          c += Sum0(d) + Maj(d, e, f);
+
+          // t = 8 * i + 6
+          b += Sum1(g) + Ch(g, h, a) + K[t] + W[t++];
+          f += b;
+          b += Sum0(c) + Maj(c, d, e);
+
+          // t = 8 * i + 7
+          a += Sum1(f) + Ch(f, g, h) + K[t] + W[t++];
+          e += a;
+          a += Sum0(b) + Maj(b, c, d);
+        }
+ 
+        H1 += a;
+        H2 += b;
+        H3 += c;
+        H4 += d;
+        H5 += e;
+        H6 += f;
+        H7 += g;
+        H8 += h;
+
+        //
+        // reset the offset and clean out the word buffer.
+        //
+        wOff = 0;
+        for (int i = 0; i < 16; i++)
+        {
+            W[i] = 0;
+        }
+    }
+
+    /* SHA-384 and SHA-512 functions (as for SHA-256 but for longs) */
+    private long Ch(
+        long    x,
+        long    y,
+        long    z)
+    {
+        return ((x & y) ^ ((~x) & z));
+    }
+
+    private long Maj(
+        long    x,
+        long    y,
+        long    z)
+    {
+        return ((x & y) ^ (x & z) ^ (y & z));
+    }
+
+    private long Sum0(
+        long    x)
+    {
+        return ((x << 36)|(x >>> 28)) ^ ((x << 30)|(x >>> 34)) ^ ((x << 25)|(x >>> 39));
+    }
+
+    private long Sum1(
+        long    x)
+    {
+        return ((x << 50)|(x >>> 14)) ^ ((x << 46)|(x >>> 18)) ^ ((x << 23)|(x >>> 41));
+    }
+
+    private long Sigma0(
+        long    x)
+    {
+        return ((x << 63)|(x >>> 1)) ^ ((x << 56)|(x >>> 8)) ^ (x >>> 7);
+    }
+
+    private long Sigma1(
+        long    x)
+    {
+        return ((x << 45)|(x >>> 19)) ^ ((x << 3)|(x >>> 61)) ^ (x >>> 6);
+    }
+
+    /* SHA-384 and SHA-512 Constants
+     * (represent the first 64 bits of the fractional parts of the
+     * cube roots of the first sixty-four prime numbers)
+     */
+    static final long K[] = {
+0x428a2f98d728ae22L, 0x7137449123ef65cdL, 0xb5c0fbcfec4d3b2fL, 0xe9b5dba58189dbbcL,
+0x3956c25bf348b538L, 0x59f111f1b605d019L, 0x923f82a4af194f9bL, 0xab1c5ed5da6d8118L,
+0xd807aa98a3030242L, 0x12835b0145706fbeL, 0x243185be4ee4b28cL, 0x550c7dc3d5ffb4e2L,
+0x72be5d74f27b896fL, 0x80deb1fe3b1696b1L, 0x9bdc06a725c71235L, 0xc19bf174cf692694L,
+0xe49b69c19ef14ad2L, 0xefbe4786384f25e3L, 0x0fc19dc68b8cd5b5L, 0x240ca1cc77ac9c65L,
+0x2de92c6f592b0275L, 0x4a7484aa6ea6e483L, 0x5cb0a9dcbd41fbd4L, 0x76f988da831153b5L,
+0x983e5152ee66dfabL, 0xa831c66d2db43210L, 0xb00327c898fb213fL, 0xbf597fc7beef0ee4L,
+0xc6e00bf33da88fc2L, 0xd5a79147930aa725L, 0x06ca6351e003826fL, 0x142929670a0e6e70L,
+0x27b70a8546d22ffcL, 0x2e1b21385c26c926L, 0x4d2c6dfc5ac42aedL, 0x53380d139d95b3dfL,
+0x650a73548baf63deL, 0x766a0abb3c77b2a8L, 0x81c2c92e47edaee6L, 0x92722c851482353bL,
+0xa2bfe8a14cf10364L, 0xa81a664bbc423001L, 0xc24b8b70d0f89791L, 0xc76c51a30654be30L,
+0xd192e819d6ef5218L, 0xd69906245565a910L, 0xf40e35855771202aL, 0x106aa07032bbd1b8L,
+0x19a4c116b8d2d0c8L, 0x1e376c085141ab53L, 0x2748774cdf8eeb99L, 0x34b0bcb5e19b48a8L,
+0x391c0cb3c5c95a63L, 0x4ed8aa4ae3418acbL, 0x5b9cca4f7763e373L, 0x682e6ff3d6b2b8a3L,
+0x748f82ee5defb2fcL, 0x78a5636f43172f60L, 0x84c87814a1f0ab72L, 0x8cc702081a6439ecL,
+0x90befffa23631e28L, 0xa4506cebde82bde9L, 0xbef9a3f7b2c67915L, 0xc67178f2e372532bL,
+0xca273eceea26619cL, 0xd186b8c721c0c207L, 0xeada7dd6cde0eb1eL, 0xf57d4f7fee6ed178L,
+0x06f067aa72176fbaL, 0x0a637dc5a2c898a6L, 0x113f9804bef90daeL, 0x1b710b35131c471bL,
+0x28db77f523047d84L, 0x32caab7b40c72493L, 0x3c9ebe0a15c9bebcL, 0x431d67c49c100d4cL,
+0x4cc5d4becb3e42b6L, 0x597f299cfc657e2aL, 0x5fcb6fab3ad6faecL, 0x6c44198c4a475817L
+    };
+}

Added: trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,302 @@
+package org.bouncycastle.crypto.digests;
+
+
+/**
+ * implementation of MD5 as outlined in "Handbook of Applied Cryptography", pages 346 - 347.
+ */
+public class MD5Digest
+    extends GeneralDigest
+{
+    private static final int    DIGEST_LENGTH = 16;
+
+    private int     H1, H2, H3, H4;         // IV's
+
+    private int[]   X = new int[16];
+    private int     xOff;
+
+    /**
+     * Standard constructor
+     */
+    public MD5Digest()
+    {
+        reset();
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public MD5Digest(MD5Digest t)
+    {
+        super(t);
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+
+        System.arraycopy(t.X, 0, X, 0, t.X.length);
+        xOff = t.xOff;
+    }
+
+    public String getAlgorithmName()
+    {
+        return "MD5";
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        X[xOff++] = (in[inOff] & 0xff) | ((in[inOff + 1] & 0xff) << 8)
+            | ((in[inOff + 2] & 0xff) << 16) | ((in[inOff + 3] & 0xff) << 24); 
+
+        if (xOff == 16)
+        {
+            processBlock();
+        }
+    }
+
+    protected void processLength(
+        long    bitLength)
+    {
+        if (xOff > 14)
+        {
+            processBlock();
+        }
+
+        X[14] = (int)(bitLength & 0xffffffff);
+        X[15] = (int)(bitLength >>> 32);
+    }
+
+    private void unpackWord(
+        int     word,
+        byte[]  out,
+        int     outOff)
+    {
+        out[outOff]     = (byte)word;
+        out[outOff + 1] = (byte)(word >>> 8);
+        out[outOff + 2] = (byte)(word >>> 16);
+        out[outOff + 3] = (byte)(word >>> 24);
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        unpackWord(H1, out, outOff);
+        unpackWord(H2, out, outOff + 4);
+        unpackWord(H3, out, outOff + 8);
+        unpackWord(H4, out, outOff + 12);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables to the IV values.
+     */
+    public void reset()
+    {
+        super.reset();
+
+        H1 = 0x67452301;
+        H2 = 0xefcdab89;
+        H3 = 0x98badcfe;
+        H4 = 0x10325476;
+
+        xOff = 0;
+
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    //
+    // round 1 left rotates
+    //
+    private static final int S11 = 7;
+    private static final int S12 = 12;
+    private static final int S13 = 17;
+    private static final int S14 = 22;
+
+    //
+    // round 2 left rotates
+    //
+    private static final int S21 = 5;
+    private static final int S22 = 9;
+    private static final int S23 = 14;
+    private static final int S24 = 20;
+
+    //
+    // round 3 left rotates
+    //
+    private static final int S31 = 4;
+    private static final int S32 = 11;
+    private static final int S33 = 16;
+    private static final int S34 = 23;
+
+    //
+    // round 4 left rotates
+    //
+    private static final int S41 = 6;
+    private static final int S42 = 10;
+    private static final int S43 = 15;
+    private static final int S44 = 21;
+
+    /*
+     * rotate int x left n bits.
+     */
+    private int rotateLeft(
+        int x,
+        int n)
+    {
+        return (x << n) | (x >>> (32 - n));
+    }
+
+    /*
+     * F, G, H and I are the basic MD5 functions.
+     */
+    private int F(
+        int u,
+        int v,
+        int w)
+    {
+        return (u & v) | (~u & w);
+    }
+
+    private int G(
+        int u,
+        int v,
+        int w)
+    {
+        return (u & w) | (v & ~w);
+    }
+
+    private int H(
+        int u,
+        int v,
+        int w)
+    {
+        return u ^ v ^ w;
+    }
+
+    private int K(
+        int u,
+        int v,
+        int w)
+    {
+        return v ^ (u | ~w);
+    }
+
+    protected void processBlock()
+    {
+        int a = H1;
+        int b = H2;
+        int c = H3;
+        int d = H4;
+
+        //
+        // Round 1 - F cycle, 16 times.
+        //
+        a = rotateLeft(a + F(b, c, d) + X[ 0] + 0xd76aa478, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[ 1] + 0xe8c7b756, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[ 2] + 0x242070db, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[ 3] + 0xc1bdceee, S14) + c;
+        a = rotateLeft(a + F(b, c, d) + X[ 4] + 0xf57c0faf, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[ 5] + 0x4787c62a, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[ 6] + 0xa8304613, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[ 7] + 0xfd469501, S14) + c;
+        a = rotateLeft(a + F(b, c, d) + X[ 8] + 0x698098d8, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[ 9] + 0x8b44f7af, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[10] + 0xffff5bb1, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[11] + 0x895cd7be, S14) + c;
+        a = rotateLeft(a + F(b, c, d) + X[12] + 0x6b901122, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[13] + 0xfd987193, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[14] + 0xa679438e, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[15] + 0x49b40821, S14) + c;
+
+        //
+        // Round 2 - G cycle, 16 times.
+        //
+        a = rotateLeft(a + G(b, c, d) + X[ 1] + 0xf61e2562, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[ 6] + 0xc040b340, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[11] + 0x265e5a51, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[ 0] + 0xe9b6c7aa, S24) + c;
+        a = rotateLeft(a + G(b, c, d) + X[ 5] + 0xd62f105d, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[10] + 0x02441453, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[15] + 0xd8a1e681, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[ 4] + 0xe7d3fbc8, S24) + c;
+        a = rotateLeft(a + G(b, c, d) + X[ 9] + 0x21e1cde6, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[14] + 0xc33707d6, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[ 3] + 0xf4d50d87, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[ 8] + 0x455a14ed, S24) + c;
+        a = rotateLeft(a + G(b, c, d) + X[13] + 0xa9e3e905, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[ 2] + 0xfcefa3f8, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[ 7] + 0x676f02d9, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[12] + 0x8d2a4c8a, S24) + c;
+
+        //
+        // Round 3 - H cycle, 16 times.
+        //
+        a = rotateLeft(a + H(b, c, d) + X[ 5] + 0xfffa3942, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[ 8] + 0x8771f681, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[11] + 0x6d9d6122, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[14] + 0xfde5380c, S34) + c;
+        a = rotateLeft(a + H(b, c, d) + X[ 1] + 0xa4beea44, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[ 4] + 0x4bdecfa9, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[ 7] + 0xf6bb4b60, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[10] + 0xbebfbc70, S34) + c;
+        a = rotateLeft(a + H(b, c, d) + X[13] + 0x289b7ec6, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[ 0] + 0xeaa127fa, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[ 3] + 0xd4ef3085, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[ 6] + 0x04881d05, S34) + c;
+        a = rotateLeft(a + H(b, c, d) + X[ 9] + 0xd9d4d039, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[12] + 0xe6db99e5, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[15] + 0x1fa27cf8, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[ 2] + 0xc4ac5665, S34) + c;
+
+        //
+        // Round 4 - K cycle, 16 times.
+        //
+        a = rotateLeft(a + K(b, c, d) + X[ 0] + 0xf4292244, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[ 7] + 0x432aff97, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[14] + 0xab9423a7, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[ 5] + 0xfc93a039, S44) + c;
+        a = rotateLeft(a + K(b, c, d) + X[12] + 0x655b59c3, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[ 3] + 0x8f0ccc92, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[10] + 0xffeff47d, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[ 1] + 0x85845dd1, S44) + c;
+        a = rotateLeft(a + K(b, c, d) + X[ 8] + 0x6fa87e4f, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[15] + 0xfe2ce6e0, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[ 6] + 0xa3014314, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[13] + 0x4e0811a1, S44) + c;
+        a = rotateLeft(a + K(b, c, d) + X[ 4] + 0xf7537e82, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[11] + 0xbd3af235, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[ 2] + 0x2ad7d2bb, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[ 9] + 0xeb86d391, S44) + c;
+
+        H1 += a;
+        H2 += b;
+        H3 += c;
+        H4 += d;
+
+        //
+        // reset the offset and clean out the word buffer.
+        //
+        xOff = 0;
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/NullDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/NullDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/NullDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.crypto.digests;
+
+import ewe.io.ByteArrayOutputStream;
+
+import org.bouncycastle.crypto.Digest;
+
+
+public class NullDigest
+    implements Digest
+{
+    private ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+
+    public String getAlgorithmName()
+    {
+        return "NULL";
+    }
+
+    public int getDigestSize()
+    {
+        return bOut.size();
+    }
+
+    public void update(byte in)
+    {
+        bOut.write(in);
+    }
+
+    public void update(byte[] in, int inOff, int len)
+    {
+        bOut.write(in, inOff, len);
+    }
+
+    public int doFinal(byte[] out, int outOff)
+    {
+        byte[] res = bOut.toByteArray();
+
+        System.arraycopy(res, 0, out, outOff, res.length);
+
+        reset();
+        
+        return res.length;
+    }
+
+    public void reset()
+    {
+        bOut.reset();
+    }
+}
\ No newline at end of file

Added: trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,290 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.util.Pack;
+
+/**
+ * implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
+ *
+ * It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
+ * is the "endienness" of the word processing!
+ */
+public class SHA1Digest
+    extends GeneralDigest
+{
+    private static final int    DIGEST_LENGTH = 20;
+
+    private int     H1, H2, H3, H4, H5;
+
+    private int[]   X = new int[80];
+    private int     xOff;
+
+    /**
+     * Standard constructor
+     */
+    public SHA1Digest()
+    {
+        reset();
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA1Digest(SHA1Digest t)
+    {
+        super(t);
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+        H5 = t.H5;
+
+        System.arraycopy(t.X, 0, X, 0, t.X.length);
+        xOff = t.xOff;
+    }
+
+    public String getAlgorithmName()
+    {
+        return "SHA-1";
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        // Note: Inlined for performance
+//        X[xOff] = Pack.bigEndianToInt(in, inOff);
+        int n = in[  inOff] << 24;
+        n |= (in[++inOff] & 0xff) << 16;
+        n |= (in[++inOff] & 0xff) << 8;
+        n |= (in[++inOff] & 0xff);
+        X[xOff] = n;
+
+        if (++xOff == 16)
+        {
+            processBlock();
+        }        
+    }
+
+    protected void processLength(
+        long    bitLength)
+    {
+        if (xOff > 14)
+        {
+            processBlock();
+        }
+
+        X[14] = (int)(bitLength >>> 32);
+        X[15] = (int)(bitLength & 0xffffffff);
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.intToBigEndian(H1, out, outOff);
+        Pack.intToBigEndian(H2, out, outOff + 4);
+        Pack.intToBigEndian(H3, out, outOff + 8);
+        Pack.intToBigEndian(H4, out, outOff + 12);
+        Pack.intToBigEndian(H5, out, outOff + 16);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        H1 = 0x67452301;
+        H2 = 0xefcdab89;
+        H3 = 0x98badcfe;
+        H4 = 0x10325476;
+        H5 = 0xc3d2e1f0;
+
+        xOff = 0;
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    //
+    // Additive constants
+    //
+    private static final int    Y1 = 0x5a827999;
+    private static final int    Y2 = 0x6ed9eba1;
+    private static final int    Y3 = 0x8f1bbcdc;
+    private static final int    Y4 = 0xca62c1d6;
+   
+    private int f(
+        int    u,
+        int    v,
+        int    w)
+    {
+        return ((u & v) | ((~u) & w));
+    }
+
+    private int h(
+        int    u,
+        int    v,
+        int    w)
+    {
+        return (u ^ v ^ w);
+    }
+
+    private int g(
+        int    u,
+        int    v,
+        int    w)
+    {
+        return ((u & v) | (u & w) | (v & w));
+    }
+
+    protected void processBlock()
+    {
+        //
+        // expand 16 word block into 80 word block.
+        //
+        for (int i = 16; i < 80; i++)
+        {
+            int t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16];
+            X[i] = t << 1 | t >>> 31;
+        }
+
+        //
+        // set up working variables.
+        //
+        int     A = H1;
+        int     B = H2;
+        int     C = H3;
+        int     D = H4;
+        int     E = H5;
+
+        //
+        // round 1
+        //
+        int idx = 0;
+        
+        for (int j = 0; j < 4; j++)
+        {
+            // E = rotateLeft(A, 5) + f(B, C, D) + E + X[idx++] + Y1
+            // B = rotateLeft(B, 30)
+            E += (A << 5 | A >>> 27) + f(B, C, D) + X[idx++] + Y1;
+            B = B << 30 | B >>> 2;
+        
+            D += (E << 5 | E >>> 27) + f(A, B, C) + X[idx++] + Y1;
+            A = A << 30 | A >>> 2;
+       
+            C += (D << 5 | D >>> 27) + f(E, A, B) + X[idx++] + Y1;
+            E = E << 30 | E >>> 2;
+       
+            B += (C << 5 | C >>> 27) + f(D, E, A) + X[idx++] + Y1;
+            D = D << 30 | D >>> 2;
+
+            A += (B << 5 | B >>> 27) + f(C, D, E) + X[idx++] + Y1;
+            C = C << 30 | C >>> 2;
+        }
+        
+        //
+        // round 2
+        //
+        for (int j = 0; j < 4; j++)
+        {
+            // E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y2
+            // B = rotateLeft(B, 30)
+            E += (A << 5 | A >>> 27) + h(B, C, D) + X[idx++] + Y2;
+            B = B << 30 | B >>> 2;   
+            
+            D += (E << 5 | E >>> 27) + h(A, B, C) + X[idx++] + Y2;
+            A = A << 30 | A >>> 2;
+            
+            C += (D << 5 | D >>> 27) + h(E, A, B) + X[idx++] + Y2;
+            E = E << 30 | E >>> 2;
+            
+            B += (C << 5 | C >>> 27) + h(D, E, A) + X[idx++] + Y2;
+            D = D << 30 | D >>> 2;
+
+            A += (B << 5 | B >>> 27) + h(C, D, E) + X[idx++] + Y2;
+            C = C << 30 | C >>> 2;
+        }
+        
+        //
+        // round 3
+        //
+        for (int j = 0; j < 4; j++)
+        {
+            // E = rotateLeft(A, 5) + g(B, C, D) + E + X[idx++] + Y3
+            // B = rotateLeft(B, 30)
+            E += (A << 5 | A >>> 27) + g(B, C, D) + X[idx++] + Y3;
+            B = B << 30 | B >>> 2;
+            
+            D += (E << 5 | E >>> 27) + g(A, B, C) + X[idx++] + Y3;
+            A = A << 30 | A >>> 2;
+            
+            C += (D << 5 | D >>> 27) + g(E, A, B) + X[idx++] + Y3;
+            E = E << 30 | E >>> 2;
+            
+            B += (C << 5 | C >>> 27) + g(D, E, A) + X[idx++] + Y3;
+            D = D << 30 | D >>> 2;
+
+            A += (B << 5 | B >>> 27) + g(C, D, E) + X[idx++] + Y3;
+            C = C << 30 | C >>> 2;
+        }
+
+        //
+        // round 4
+        //
+        for (int j = 0; j <= 3; j++)
+        {
+            // E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y4
+            // B = rotateLeft(B, 30)
+            E += (A << 5 | A >>> 27) + h(B, C, D) + X[idx++] + Y4;
+            B = B << 30 | B >>> 2;
+            
+            D += (E << 5 | E >>> 27) + h(A, B, C) + X[idx++] + Y4;
+            A = A << 30 | A >>> 2;
+            
+            C += (D << 5 | D >>> 27) + h(E, A, B) + X[idx++] + Y4;
+            E = E << 30 | E >>> 2;
+            
+            B += (C << 5 | C >>> 27) + h(D, E, A) + X[idx++] + Y4;
+            D = D << 30 | D >>> 2;
+
+            A += (B << 5 | B >>> 27) + h(C, D, E) + X[idx++] + Y4;
+            C = C << 30 | C >>> 2;
+        }
+
+
+        H1 += A;
+        H2 += B;
+        H3 += C;
+        H4 += D;
+        H5 += E;
+
+        //
+        // reset start of the buffer.
+        //
+        xOff = 0;
+        for (int i = 0; i < 16; i++)
+        {
+            X[i] = 0;
+        }
+    }
+}
+
+
+
+

Added: trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,295 @@
+package org.bouncycastle.crypto.digests;
+
+
+import org.bouncycastle.crypto.digests.GeneralDigest;
+import org.bouncycastle.crypto.util.Pack;
+
+
+/**
+ * FIPS 180-2 implementation of SHA-256.
+ *
+ * <pre>
+ *         block  word  digest
+ * SHA-1   512    32    160
+ * SHA-256 512    32    256
+ * SHA-384 1024   64    384
+ * SHA-512 1024   64    512
+ * </pre>
+ */
+public class SHA256Digest
+    extends GeneralDigest
+{
+    private static final int    DIGEST_LENGTH = 32;
+
+    private int     H1, H2, H3, H4, H5, H6, H7, H8;
+
+    private int[]   X = new int[64];
+    private int     xOff;
+
+    /**
+     * Standard constructor
+     */
+    public SHA256Digest()
+    {
+        reset();
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA256Digest(SHA256Digest t)
+    {
+        super(t);
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+        H5 = t.H5;
+        H6 = t.H6;
+        H7 = t.H7;
+        H8 = t.H8;
+
+        System.arraycopy(t.X, 0, X, 0, t.X.length);
+        xOff = t.xOff;
+    }
+
+    public String getAlgorithmName()
+    {
+        return "SHA-256";
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        // Note: Inlined for performance
+//        X[xOff] = Pack.bigEndianToInt(in, inOff);
+        int n = in[inOff] << 24;
+        n |= (in[++inOff] & 0xff) << 16;
+        n |= (in[++inOff] & 0xff) << 8;
+        n |= (in[++inOff] & 0xff);
+        X[xOff] = n;
+
+        if (++xOff == 16)
+        {
+            processBlock();
+        }
+    }
+
+    protected void processLength(
+        long    bitLength)
+    {
+        if (xOff > 14)
+        {
+            processBlock();
+        }
+
+        X[14] = (int)(bitLength >>> 32);
+        X[15] = (int)(bitLength & 0xffffffff);
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.intToBigEndian(H1, out, outOff);
+        Pack.intToBigEndian(H2, out, outOff + 4);
+        Pack.intToBigEndian(H3, out, outOff + 8);
+        Pack.intToBigEndian(H4, out, outOff + 12);
+        Pack.intToBigEndian(H5, out, outOff + 16);
+        Pack.intToBigEndian(H6, out, outOff + 20);
+        Pack.intToBigEndian(H7, out, outOff + 24);
+        Pack.intToBigEndian(H8, out, outOff + 28);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        /* SHA-256 initial hash value
+         * The first 32 bits of the fractional parts of the square roots
+         * of the first eight prime numbers
+         */
+
+        H1 = 0x6a09e667;
+        H2 = 0xbb67ae85;
+        H3 = 0x3c6ef372;
+        H4 = 0xa54ff53a;
+        H5 = 0x510e527f;
+        H6 = 0x9b05688c;
+        H7 = 0x1f83d9ab;
+        H8 = 0x5be0cd19;
+
+        xOff = 0;
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    protected void processBlock()
+    {
+        //
+        // expand 16 word block into 64 word blocks.
+        //
+        for (int t = 16; t <= 63; t++)
+        {
+            X[t] = Theta1(X[t - 2]) + X[t - 7] + Theta0(X[t - 15]) + X[t - 16];
+        }
+
+        //
+        // set up working variables.
+        //
+        int     a = H1;
+        int     b = H2;
+        int     c = H3;
+        int     d = H4;
+        int     e = H5;
+        int     f = H6;
+        int     g = H7;
+        int     h = H8;
+
+        int t = 0;     
+        for(int i = 0; i < 8; i ++)
+        {
+            // t = 8 * i
+            h += Sum1(e) + Ch(e, f, g) + K[t] + X[t];
+            d += h;
+            h += Sum0(a) + Maj(a, b, c);
+            ++t;
+
+            // t = 8 * i + 1
+            g += Sum1(d) + Ch(d, e, f) + K[t] + X[t];
+            c += g;
+            g += Sum0(h) + Maj(h, a, b);
+            ++t;
+
+            // t = 8 * i + 2
+            f += Sum1(c) + Ch(c, d, e) + K[t] + X[t];
+            b += f;
+            f += Sum0(g) + Maj(g, h, a);
+            ++t;
+
+            // t = 8 * i + 3
+            e += Sum1(b) + Ch(b, c, d) + K[t] + X[t];
+            a += e;
+            e += Sum0(f) + Maj(f, g, h);
+            ++t;
+
+            // t = 8 * i + 4
+            d += Sum1(a) + Ch(a, b, c) + K[t] + X[t];
+            h += d;
+            d += Sum0(e) + Maj(e, f, g);
+            ++t;
+
+            // t = 8 * i + 5
+            c += Sum1(h) + Ch(h, a, b) + K[t] + X[t];
+            g += c;
+            c += Sum0(d) + Maj(d, e, f);
+            ++t;
+
+            // t = 8 * i + 6
+            b += Sum1(g) + Ch(g, h, a) + K[t] + X[t];
+            f += b;
+            b += Sum0(c) + Maj(c, d, e);
+            ++t;
+
+            // t = 8 * i + 7
+            a += Sum1(f) + Ch(f, g, h) + K[t] + X[t];
+            e += a;
+            a += Sum0(b) + Maj(b, c, d);
+            ++t;
+        }
+
+        H1 += a;
+        H2 += b;
+        H3 += c;
+        H4 += d;
+        H5 += e;
+        H6 += f;
+        H7 += g;
+        H8 += h;
+
+        //
+        // reset the offset and clean out the word buffer.
+        //
+        xOff = 0;
+        for (int i = 0; i < 16; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    /* SHA-256 functions */
+    private int Ch(
+        int    x,
+        int    y,
+        int    z)
+    {
+        return (x & y) ^ ((~x) & z);
+    }
+
+    private int Maj(
+        int    x,
+        int    y,
+        int    z)
+    {
+        return (x & y) ^ (x & z) ^ (y & z);
+    }
+
+    private int Sum0(
+        int    x)
+    {
+        return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^ ((x >>> 22) | (x << 10));
+    }
+
+    private int Sum1(
+        int    x)
+    {
+        return ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^ ((x >>> 25) | (x << 7));
+    }
+
+    private int Theta0(
+        int    x)
+    {
+        return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);
+    }
+
+    private int Theta1(
+        int    x)
+    {
+        return ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);
+    }
+
+    /* SHA-256 Constants
+     * (represent the first 32 bits of the fractional parts of the
+     * cube roots of the first sixty-four prime numbers)
+     */
+    static final int K[] = {
+        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+    };
+}
+

Added: trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,87 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.util.Pack;
+
+
+/**
+ * FIPS 180-2 implementation of SHA-384.
+ *
+ * <pre>
+ *         block  word  digest
+ * SHA-1   512    32    160
+ * SHA-256 512    32    256
+ * SHA-384 1024   64    384
+ * SHA-512 1024   64    512
+ * </pre>
+ */
+public class SHA384Digest
+    extends LongDigest
+{
+
+    private static final int    DIGEST_LENGTH = 48;
+
+    /**
+     * Standard constructor
+     */
+    public SHA384Digest()
+    {
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA384Digest(SHA384Digest t)
+    {
+        super(t);
+    }
+
+    public String getAlgorithmName()
+    {
+        return "SHA-384";
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.longToBigEndian(H1, out, outOff);
+        Pack.longToBigEndian(H2, out, outOff + 8);
+        Pack.longToBigEndian(H3, out, outOff + 16);
+        Pack.longToBigEndian(H4, out, outOff + 24);
+        Pack.longToBigEndian(H5, out, outOff + 32);
+        Pack.longToBigEndian(H6, out, outOff + 40);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        /* SHA-384 initial hash value
+         * The first 64 bits of the fractional parts of the square roots
+         * of the 9th through 16th prime numbers
+         */
+        H1 = 0xcbbb9d5dc1059ed8l;
+        H2 = 0x629a292a367cd507l;
+        H3 = 0x9159015a3070dd17l;
+        H4 = 0x152fecd8f70e5939l;
+        H5 = 0x67332667ffc00b31l;
+        H6 = 0x8eb44a8768581511l;
+        H7 = 0xdb0c2e0d64f98fa7l;
+        H8 = 0x47b5481dbefa4fa4l;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,89 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.util.Pack;
+
+
+/**
+ * FIPS 180-2 implementation of SHA-512.
+ *
+ * <pre>
+ *         block  word  digest
+ * SHA-1   512    32    160
+ * SHA-256 512    32    256
+ * SHA-384 1024   64    384
+ * SHA-512 1024   64    512
+ * </pre>
+ */
+public class SHA512Digest
+    extends LongDigest
+{
+    private static final int    DIGEST_LENGTH = 64;
+
+    /**
+     * Standard constructor
+     */
+    public SHA512Digest()
+    {
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA512Digest(SHA512Digest t)
+    {
+        super(t);
+    }
+
+    public String getAlgorithmName()
+    {
+        return "SHA-512";
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.longToBigEndian(H1, out, outOff);
+        Pack.longToBigEndian(H2, out, outOff + 8);
+        Pack.longToBigEndian(H3, out, outOff + 16);
+        Pack.longToBigEndian(H4, out, outOff + 24);
+        Pack.longToBigEndian(H5, out, outOff + 32);
+        Pack.longToBigEndian(H6, out, outOff + 40);
+        Pack.longToBigEndian(H7, out, outOff + 48);
+        Pack.longToBigEndian(H8, out, outOff + 56);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        /* SHA-512 initial hash value
+         * The first 64 bits of the fractional parts of the square roots
+         * of the first eight prime numbers
+         */
+        H1 = 0x6a09e667f3bcc908L;
+        H2 = 0xbb67ae8584caa73bL;
+        H3 = 0x3c6ef372fe94f82bL;
+        H4 = 0xa54ff53a5f1d36f1L;
+        H5 = 0x510e527fade682d1L;
+        H6 = 0x9b05688c2b3e6c1fL;
+        H7 = 0x1f83d9abfb41bd6bL;
+        H8 = 0x5be0cd19137e2179L;
+    }
+}
+

Added: trunk/src/org/bouncycastle/crypto/digests/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Message digest classes.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,247 @@
+package org.bouncycastle.crypto.encodings;
+
+// import java.security.AccessController;
+// import java.security.PrivilegedAction;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.AsymmetricBlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.InvalidCipherTextException;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+/**
+ * this does your basic PKCS 1 v1.5 padding - whether or not you should be using this
+ * depends on your application - see PKCS1 Version 2 for details.
+ */
+public class PKCS1Encoding
+    implements AsymmetricBlockCipher
+{
+    /**
+     * some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
+     * work with one of these set the system property org.bouncycastle.pkcs1.strict to false.
+     * <p>
+     * The system property is checked during construction of the encoding object, it is set to
+     * true by default.
+     * </p>
+     */
+    public static final String STRICT_LENGTH_ENABLED_PROPERTY = "org.bouncycastle.pkcs1.strict";
+
+    private static final int HEADER_LENGTH = 10;
+
+    private SecureRandom            random;
+    private AsymmetricBlockCipher   engine;
+    private boolean                 forEncryption;
+    private boolean                 forPrivateKey;
+    private boolean                 useStrictLength;
+
+    /**
+     * Basic constructor.
+     * @param cipher
+     */
+    public PKCS1Encoding(AsymmetricBlockCipher cipher)
+    {
+        this.engine = cipher;
+        this.useStrictLength = useStrict();
+    }
+
+    //
+    // for J2ME compatibility
+    //
+    private boolean useStrict()
+    {
+        // required if security manager has been installed.
+        String strict = null; /*(String)AccessController.doPrivileged(new PrivilegedAction()
+        {
+            public Object run()
+            {
+                return System.getProperty(STRICT_LENGTH_ENABLED_PROPERTY);
+            }
+        }); */
+
+        return strict == null || strict.equals("true");
+    }
+
+    public AsymmetricBlockCipher getUnderlyingCipher()
+    {
+        return engine;
+    }
+
+    public void init(
+        boolean             forEncryption,
+        CipherParameters    param)
+    {
+        AsymmetricKeyParameter  kParam;
+
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+            this.random = rParam.getRandom();  
+            kParam = (AsymmetricKeyParameter)rParam.getParameters();
+        }
+        else
+        {
+            this.random = new SecureRandom();
+            kParam = (AsymmetricKeyParameter)param;
+        }
+
+        engine.init(forEncryption, param);
+
+        this.forPrivateKey = kParam.isPrivate();
+        this.forEncryption = forEncryption;
+    }
+
+    public int getInputBlockSize()
+    {
+        int     baseBlockSize = engine.getInputBlockSize();
+
+        if (forEncryption)
+        {
+            return baseBlockSize - HEADER_LENGTH;
+        }
+        else
+        {
+            return baseBlockSize;
+        }
+    }
+
+    public int getOutputBlockSize()
+    {
+        int     baseBlockSize = engine.getOutputBlockSize();
+
+        if (forEncryption)
+        {
+            return baseBlockSize;
+        }
+        else
+        {
+            return baseBlockSize - HEADER_LENGTH;
+        }
+    }
+
+    public byte[] processBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+        throws InvalidCipherTextException
+    {
+        if (forEncryption)
+        {
+            return encodeBlock(in, inOff, inLen);
+        }
+        else
+        {
+            return decodeBlock(in, inOff, inLen);
+        }
+    }
+
+    private byte[] encodeBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+        throws InvalidCipherTextException
+    {
+        if (inLen > getInputBlockSize())
+        {
+            throw new IllegalArgumentException("input data too large");
+        }
+
+        byte[]  block = new byte[engine.getInputBlockSize()];
+
+        if (forPrivateKey)
+        {
+            block[0] = 0x01;                        // type code 1
+
+            for (int i = 1; i != block.length - inLen - 1; i++)
+            {
+                block[i] = (byte)0xFF;
+            }
+        }
+        else
+        {
+            random.nextBytes(block);                // random fill
+
+            block[0] = 0x02;                        // type code 2
+
+            //
+            // a zero byte marks the end of the padding, so all
+            // the pad bytes must be non-zero.
+            //
+            for (int i = 1; i != block.length - inLen - 1; i++)
+            {
+                while (block[i] == 0)
+                {
+                    block[i] = (byte)11; // 
+                    int test = random.nextInt();
+                }
+            }
+        }
+
+        block[block.length - inLen - 1] = 0x00;       // mark the end of the padding
+        System.arraycopy(in, inOff, block, block.length - inLen, inLen);
+
+        return engine.processBlock(block, 0, block.length);
+    }
+
+    /**
+     * @exception InvalidCipherTextException if the decrypted block is not in PKCS1 format.
+     */
+    private byte[] decodeBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+        throws InvalidCipherTextException
+    {
+        byte[]  block = engine.processBlock(in, inOff, inLen);
+
+        if (block.length < getOutputBlockSize())
+        {
+            throw new InvalidCipherTextException("block truncated");
+        }
+
+        byte type = block[0];
+
+        if (type != 1 && type != 2)
+        {
+            throw new InvalidCipherTextException("unknown block type");
+        }
+
+        if (useStrictLength && block.length != engine.getOutputBlockSize())
+        {
+            throw new InvalidCipherTextException("block incorrect size");
+        }
+
+        //
+        // find and extract the message block.
+        //
+        int start;
+
+        for (start = 1; start != block.length; start++)
+        {
+            byte pad = block[start];
+
+            if (pad == 0)
+            {
+                break;
+            }
+            if (type == 1 && pad != (byte)0xff)
+            {
+                throw new InvalidCipherTextException("block padding incorrect");
+            }
+        }
+
+        start++;           // data should start at the next byte
+
+        if (start > block.length || start < HEADER_LENGTH)
+        {
+            throw new InvalidCipherTextException("no data in block");
+        }
+
+        byte[]  result = new byte[block.length - start];
+
+        System.arraycopy(block, start, result, 0, result.length);
+
+        return result;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/encodings/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/encodings/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/encodings/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Block encodings for asymmetric ciphers.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,876 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * an implementation of the AES (Rijndael), from FIPS-197.
+ * <p>
+ * For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
+ *
+ * This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
+ * <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
+ *
+ * There are three levels of tradeoff of speed vs memory
+ * Because java has no preprocessor, they are written as three separate classes from which to choose
+ *
+ * The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
+ * and 4 for decryption.
+ *
+ * The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
+ * adding 12 rotate operations per round to compute the values contained in the other tables from
+ * the contents of the first
+ *
+ * The slowest version uses no static tables at all and computes the values in each round
+ * <p>
+ * This file contains the fast version with 8Kbytes of static tables for round precomputation
+ *
+ */
+public class AESFastEngine
+    implements BlockCipher
+{
+    // The S box
+    private static final byte[] S = {
+        (byte)99, (byte)124, (byte)119, (byte)123, (byte)242, (byte)107, (byte)111, (byte)197,
+        (byte)48,   (byte)1, (byte)103,  (byte)43, (byte)254, (byte)215, (byte)171, (byte)118,
+        (byte)202, (byte)130, (byte)201, (byte)125, (byte)250,  (byte)89,  (byte)71, (byte)240,
+        (byte)173, (byte)212, (byte)162, (byte)175, (byte)156, (byte)164, (byte)114, (byte)192,
+        (byte)183, (byte)253, (byte)147,  (byte)38,  (byte)54,  (byte)63, (byte)247, (byte)204,
+        (byte)52, (byte)165, (byte)229, (byte)241, (byte)113, (byte)216,  (byte)49,  (byte)21,
+        (byte)4, (byte)199,  (byte)35, (byte)195,  (byte)24, (byte)150,   (byte)5, (byte)154,
+        (byte)7,  (byte)18, (byte)128, (byte)226, (byte)235,  (byte)39, (byte)178, (byte)117,
+        (byte)9, (byte)131,  (byte)44,  (byte)26,  (byte)27, (byte)110,  (byte)90, (byte)160,
+        (byte)82,  (byte)59, (byte)214, (byte)179,  (byte)41, (byte)227,  (byte)47, (byte)132,
+        (byte)83, (byte)209,   (byte)0, (byte)237,  (byte)32, (byte)252, (byte)177,  (byte)91,
+        (byte)106, (byte)203, (byte)190,  (byte)57,  (byte)74,  (byte)76,  (byte)88, (byte)207,
+        (byte)208, (byte)239, (byte)170, (byte)251,  (byte)67,  (byte)77,  (byte)51, (byte)133,
+        (byte)69, (byte)249,   (byte)2, (byte)127,  (byte)80,  (byte)60, (byte)159, (byte)168,
+        (byte)81, (byte)163,  (byte)64, (byte)143, (byte)146, (byte)157,  (byte)56, (byte)245,
+        (byte)188, (byte)182, (byte)218,  (byte)33,  (byte)16, (byte)255, (byte)243, (byte)210,
+        (byte)205,  (byte)12,  (byte)19, (byte)236,  (byte)95, (byte)151,  (byte)68,  (byte)23,
+        (byte)196, (byte)167, (byte)126,  (byte)61, (byte)100,  (byte)93,  (byte)25, (byte)115,
+        (byte)96, (byte)129,  (byte)79, (byte)220,  (byte)34,  (byte)42, (byte)144, (byte)136,
+        (byte)70, (byte)238, (byte)184,  (byte)20, (byte)222,  (byte)94,  (byte)11, (byte)219,
+        (byte)224,  (byte)50,  (byte)58,  (byte)10,  (byte)73,   (byte)6,  (byte)36,  (byte)92,
+        (byte)194, (byte)211, (byte)172,  (byte)98, (byte)145, (byte)149, (byte)228, (byte)121,
+        (byte)231, (byte)200,  (byte)55, (byte)109, (byte)141, (byte)213,  (byte)78, (byte)169,
+        (byte)108,  (byte)86, (byte)244, (byte)234, (byte)101, (byte)122, (byte)174,   (byte)8,
+        (byte)186, (byte)120,  (byte)37,  (byte)46,  (byte)28, (byte)166, (byte)180, (byte)198,
+        (byte)232, (byte)221, (byte)116,  (byte)31,  (byte)75, (byte)189, (byte)139, (byte)138,
+        (byte)112,  (byte)62, (byte)181, (byte)102,  (byte)72,   (byte)3, (byte)246,  (byte)14,
+        (byte)97,  (byte)53,  (byte)87, (byte)185, (byte)134, (byte)193,  (byte)29, (byte)158,
+        (byte)225, (byte)248, (byte)152,  (byte)17, (byte)105, (byte)217, (byte)142, (byte)148,
+        (byte)155,  (byte)30, (byte)135, (byte)233, (byte)206,  (byte)85,  (byte)40, (byte)223,
+        (byte)140, (byte)161, (byte)137,  (byte)13, (byte)191, (byte)230,  (byte)66, (byte)104,
+        (byte)65, (byte)153,  (byte)45,  (byte)15, (byte)176,  (byte)84, (byte)187,  (byte)22,
+    };
+
+    // The inverse S-box
+    private static final byte[] Si = {
+        (byte)82,   (byte)9, (byte)106, (byte)213,  (byte)48,  (byte)54, (byte)165,  (byte)56,
+        (byte)191,  (byte)64, (byte)163, (byte)158, (byte)129, (byte)243, (byte)215, (byte)251,
+        (byte)124, (byte)227,  (byte)57, (byte)130, (byte)155,  (byte)47, (byte)255, (byte)135,
+        (byte)52, (byte)142,  (byte)67,  (byte)68, (byte)196, (byte)222, (byte)233, (byte)203,
+        (byte)84, (byte)123, (byte)148,  (byte)50, (byte)166, (byte)194,  (byte)35,  (byte)61,
+        (byte)238,  (byte)76, (byte)149,  (byte)11,  (byte)66, (byte)250, (byte)195,  (byte)78,
+        (byte)8,  (byte)46, (byte)161, (byte)102,  (byte)40, (byte)217,  (byte)36, (byte)178,
+        (byte)118,  (byte)91, (byte)162,  (byte)73, (byte)109, (byte)139, (byte)209,  (byte)37,
+        (byte)114, (byte)248, (byte)246, (byte)100, (byte)134, (byte)104, (byte)152,  (byte)22,
+        (byte)212, (byte)164,  (byte)92, (byte)204,  (byte)93, (byte)101, (byte)182, (byte)146,
+        (byte)108, (byte)112,  (byte)72,  (byte)80, (byte)253, (byte)237, (byte)185, (byte)218,
+        (byte)94,  (byte)21,  (byte)70,  (byte)87, (byte)167, (byte)141, (byte)157, (byte)132,
+        (byte)144, (byte)216, (byte)171,   (byte)0, (byte)140, (byte)188, (byte)211,  (byte)10,
+        (byte)247, (byte)228,  (byte)88,   (byte)5, (byte)184, (byte)179,  (byte)69,   (byte)6,
+        (byte)208,  (byte)44,  (byte)30, (byte)143, (byte)202,  (byte)63,  (byte)15,   (byte)2,
+        (byte)193, (byte)175, (byte)189,   (byte)3,   (byte)1,  (byte)19, (byte)138, (byte)107,
+        (byte)58, (byte)145,  (byte)17,  (byte)65,  (byte)79, (byte)103, (byte)220, (byte)234,
+        (byte)151, (byte)242, (byte)207, (byte)206, (byte)240, (byte)180, (byte)230, (byte)115,
+        (byte)150, (byte)172, (byte)116,  (byte)34, (byte)231, (byte)173,  (byte)53, (byte)133,
+        (byte)226, (byte)249,  (byte)55, (byte)232,  (byte)28, (byte)117, (byte)223, (byte)110,
+        (byte)71, (byte)241,  (byte)26, (byte)113,  (byte)29,  (byte)41, (byte)197, (byte)137,
+        (byte)111, (byte)183,  (byte)98,  (byte)14, (byte)170,  (byte)24, (byte)190,  (byte)27,
+        (byte)252,  (byte)86,  (byte)62,  (byte)75, (byte)198, (byte)210, (byte)121,  (byte)32,
+        (byte)154, (byte)219, (byte)192, (byte)254, (byte)120, (byte)205,  (byte)90, (byte)244,
+        (byte)31, (byte)221, (byte)168,  (byte)51, (byte)136,   (byte)7, (byte)199,  (byte)49,
+        (byte)177,  (byte)18,  (byte)16,  (byte)89,  (byte)39, (byte)128, (byte)236,  (byte)95,
+        (byte)96,  (byte)81, (byte)127, (byte)169,  (byte)25, (byte)181,  (byte)74,  (byte)13,
+        (byte)45, (byte)229, (byte)122, (byte)159, (byte)147, (byte)201, (byte)156, (byte)239,
+        (byte)160, (byte)224,  (byte)59,  (byte)77, (byte)174,  (byte)42, (byte)245, (byte)176,
+        (byte)200, (byte)235, (byte)187,  (byte)60, (byte)131,  (byte)83, (byte)153,  (byte)97,
+        (byte)23,  (byte)43,   (byte)4, (byte)126, (byte)186, (byte)119, (byte)214,  (byte)38,
+        (byte)225, (byte)105,  (byte)20,  (byte)99,  (byte)85,  (byte)33,  (byte)12, (byte)125,
+        };
+
+    // vector used in calculating key schedule (powers of x in GF(256))
+    private static final int[] rcon = {
+         0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
+         0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 };
+
+    // precomputation tables of calculations for rounds
+    private static final int[] T0 =
+    {
+     0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6, 0x0df2f2ff, 
+     0xbd6b6bd6, 0xb16f6fde, 0x54c5c591, 0x50303060, 0x03010102, 
+     0xa96767ce, 0x7d2b2b56, 0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 
+     0x9a7676ec, 0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa, 
+     0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb, 0xecadad41, 
+     0x67d4d4b3, 0xfda2a25f, 0xeaafaf45, 0xbf9c9c23, 0xf7a4a453, 
+     0x967272e4, 0x5bc0c09b, 0xc2b7b775, 0x1cfdfde1, 0xae93933d, 
+     0x6a26264c, 0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83, 
+     0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9, 0x937171e2, 
+     0x73d8d8ab, 0x53313162, 0x3f15152a, 0x0c040408, 0x52c7c795, 
+     0x65232346, 0x5ec3c39d, 0x28181830, 0xa1969637, 0x0f05050a, 
+     0xb59a9a2f, 0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df, 
+     0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea, 0x1b090912, 
+     0x9e83831d, 0x742c2c58, 0x2e1a1a34, 0x2d1b1b36, 0xb26e6edc, 
+     0xee5a5ab4, 0xfba0a05b, 0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 
+     0xceb3b37d, 0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413, 
+     0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1, 0x60202040, 
+     0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6, 0xbe6a6ad4, 0x46cbcb8d, 
+     0xd9bebe67, 0x4b393972, 0xde4a4a94, 0xd44c4c98, 0xe85858b0, 
+     0x4acfcf85, 0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed, 
+     0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511, 0xcf45458a, 
+     0x10f9f9e9, 0x06020204, 0x817f7ffe, 0xf05050a0, 0x443c3c78, 
+     0xba9f9f25, 0xe3a8a84b, 0xf35151a2, 0xfea3a35d, 0xc0404080, 
+     0x8a8f8f05, 0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1, 
+     0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142, 0x30101020, 
+     0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf, 0x4ccdcd81, 0x140c0c18, 
+     0x35131326, 0x2fececc3, 0xe15f5fbe, 0xa2979735, 0xcc444488, 
+     0x3917172e, 0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a, 
+     0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6, 0xa06060c0, 
+     0x98818119, 0xd14f4f9e, 0x7fdcdca3, 0x66222244, 0x7e2a2a54, 
+     0xab90903b, 0x8388880b, 0xca46468c, 0x29eeeec7, 0xd3b8b86b, 
+     0x3c141428, 0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad, 
+     0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14, 0xdb494992, 
+     0x0a06060c, 0x6c242448, 0xe45c5cb8, 0x5dc2c29f, 0x6ed3d3bd, 
+     0xefacac43, 0xa66262c4, 0xa8919139, 0xa4959531, 0x37e4e4d3, 
+     0x8b7979f2, 0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda, 
+     0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949, 0xb46c6cd8, 
+     0xfa5656ac, 0x07f4f4f3, 0x25eaeacf, 0xaf6565ca, 0x8e7a7af4, 
+     0xe9aeae47, 0x18080810, 0xd5baba6f, 0x887878f0, 0x6f25254a, 
+     0x722e2e5c, 0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697, 
+     0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e, 0xdd4b4b96, 
+     0xdcbdbd61, 0x868b8b0d, 0x858a8a0f, 0x907070e0, 0x423e3e7c, 
+     0xc4b5b571, 0xaa6666cc, 0xd8484890, 0x05030306, 0x01f6f6f7, 
+     0x120e0e1c, 0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969, 
+     0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27, 0x38e1e1d9, 
+     0x13f8f8eb, 0xb398982b, 0x33111122, 0xbb6969d2, 0x70d9d9a9, 
+     0x898e8e07, 0xa7949433, 0xb69b9b2d, 0x221e1e3c, 0x92878715, 
+     0x20e9e9c9, 0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5, 
+     0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a, 0xdabfbf65, 
+     0x31e6e6d7, 0xc6424284, 0xb86868d0, 0xc3414182, 0xb0999929, 
+     0x772d2d5a, 0x110f0f1e, 0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 
+     0x3a16162c};
+
+    private static final int[] T1 =
+    {
+     0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d, 0xf2f2ff0d, 
+     0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154, 0x30306050, 0x01010203, 
+     0x6767cea9, 0x2b2b567d, 0xfefee719, 0xd7d7b562, 0xabab4de6, 
+     0x7676ec9a, 0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87, 
+     0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b, 0xadad41ec, 
+     0xd4d4b367, 0xa2a25ffd, 0xafaf45ea, 0x9c9c23bf, 0xa4a453f7, 
+     0x7272e496, 0xc0c09b5b, 0xb7b775c2, 0xfdfde11c, 0x93933dae, 
+     0x26264c6a, 0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f, 
+     0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908, 0x7171e293, 
+     0xd8d8ab73, 0x31316253, 0x15152a3f, 0x0404080c, 0xc7c79552, 
+     0x23234665, 0xc3c39d5e, 0x18183028, 0x969637a1, 0x05050a0f, 
+     0x9a9a2fb5, 0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d, 
+     0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f, 0x0909121b, 
+     0x83831d9e, 0x2c2c5874, 0x1a1a342e, 0x1b1b362d, 0x6e6edcb2, 
+     0x5a5ab4ee, 0xa0a05bfb, 0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 
+     0xb3b37dce, 0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397, 
+     0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c, 0x20204060, 
+     0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed, 0x6a6ad4be, 0xcbcb8d46, 
+     0xbebe67d9, 0x3939724b, 0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 
+     0xcfcf854a, 0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16, 
+     0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194, 0x45458acf, 
+     0xf9f9e910, 0x02020406, 0x7f7ffe81, 0x5050a0f0, 0x3c3c7844, 
+     0x9f9f25ba, 0xa8a84be3, 0x5151a2f3, 0xa3a35dfe, 0x404080c0, 
+     0x8f8f058a, 0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104, 
+     0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263, 0x10102030, 
+     0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d, 0xcdcd814c, 0x0c0c1814, 
+     0x13132635, 0xececc32f, 0x5f5fbee1, 0x979735a2, 0x444488cc, 
+     0x17172e39, 0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47, 
+     0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695, 0x6060c0a0, 
+     0x81811998, 0x4f4f9ed1, 0xdcdca37f, 0x22224466, 0x2a2a547e, 
+     0x90903bab, 0x88880b83, 0x46468cca, 0xeeeec729, 0xb8b86bd3, 
+     0x1414283c, 0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76, 
+     0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e, 0x494992db, 
+     0x06060c0a, 0x2424486c, 0x5c5cb8e4, 0xc2c29f5d, 0xd3d3bd6e, 
+     0xacac43ef, 0x6262c4a6, 0x919139a8, 0x959531a4, 0xe4e4d337, 
+     0x7979f28b, 0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7, 
+     0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0, 0x6c6cd8b4, 
+     0x5656acfa, 0xf4f4f307, 0xeaeacf25, 0x6565caaf, 0x7a7af48e, 
+     0xaeae47e9, 0x08081018, 0xbaba6fd5, 0x7878f088, 0x25254a6f, 
+     0x2e2e5c72, 0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751, 
+     0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21, 0x4b4b96dd, 
+     0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85, 0x7070e090, 0x3e3e7c42, 
+     0xb5b571c4, 0x6666ccaa, 0x484890d8, 0x03030605, 0xf6f6f701, 
+     0x0e0e1c12, 0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0, 
+     0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9, 0xe1e1d938, 
+     0xf8f8eb13, 0x98982bb3, 0x11112233, 0x6969d2bb, 0xd9d9a970, 
+     0x8e8e0789, 0x949433a7, 0x9b9b2db6, 0x1e1e3c22, 0x87871592, 
+     0xe9e9c920, 0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a, 
+     0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17, 0xbfbf65da, 
+     0xe6e6d731, 0x424284c6, 0x6868d0b8, 0x414182c3, 0x999929b0, 
+     0x2d2d5a77, 0x0f0f1e11, 0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 
+     0x16162c3a};
+
+    private static final int[] T2 =
+    {
+     0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b, 0xf2ff0df2, 
+     0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5, 0x30605030, 0x01020301, 
+     0x67cea967, 0x2b567d2b, 0xfee719fe, 0xd7b562d7, 0xab4de6ab, 
+     0x76ec9a76, 0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d, 
+     0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0, 0xad41ecad, 
+     0xd4b367d4, 0xa25ffda2, 0xaf45eaaf, 0x9c23bf9c, 0xa453f7a4, 
+     0x72e49672, 0xc09b5bc0, 0xb775c2b7, 0xfde11cfd, 0x933dae93, 
+     0x264c6a26, 0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc, 
+     0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1, 0x71e29371, 
+     0xd8ab73d8, 0x31625331, 0x152a3f15, 0x04080c04, 0xc79552c7, 
+     0x23466523, 0xc39d5ec3, 0x18302818, 0x9637a196, 0x050a0f05, 
+     0x9a2fb59a, 0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2, 
+     0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75, 0x09121b09, 
+     0x831d9e83, 0x2c58742c, 0x1a342e1a, 0x1b362d1b, 0x6edcb26e, 
+     0x5ab4ee5a, 0xa05bfba0, 0x52a4f652, 0x3b764d3b, 0xd6b761d6, 
+     0xb37dceb3, 0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784, 
+     0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced, 0x20406020, 
+     0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b, 0x6ad4be6a, 0xcb8d46cb, 
+     0xbe67d9be, 0x39724b39, 0x4a94de4a, 0x4c98d44c, 0x58b0e858, 
+     0xcf854acf, 0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb, 
+     0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485, 0x458acf45, 
+     0xf9e910f9, 0x02040602, 0x7ffe817f, 0x50a0f050, 0x3c78443c, 
+     0x9f25ba9f, 0xa84be3a8, 0x51a2f351, 0xa35dfea3, 0x4080c040, 
+     0x8f058a8f, 0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5, 
+     0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321, 0x10203010, 
+     0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2, 0xcd814ccd, 0x0c18140c, 
+     0x13263513, 0xecc32fec, 0x5fbee15f, 0x9735a297, 0x4488cc44, 
+     0x172e3917, 0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d, 
+     0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573, 0x60c0a060, 
+     0x81199881, 0x4f9ed14f, 0xdca37fdc, 0x22446622, 0x2a547e2a, 
+     0x903bab90, 0x880b8388, 0x468cca46, 0xeec729ee, 0xb86bd3b8, 
+     0x14283c14, 0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db, 
+     0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a, 0x4992db49, 
+     0x060c0a06, 0x24486c24, 0x5cb8e45c, 0xc29f5dc2, 0xd3bd6ed3, 
+     0xac43efac, 0x62c4a662, 0x9139a891, 0x9531a495, 0xe4d337e4, 
+     0x79f28b79, 0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d, 
+     0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9, 0x6cd8b46c, 
+     0x56acfa56, 0xf4f307f4, 0xeacf25ea, 0x65caaf65, 0x7af48e7a, 
+     0xae47e9ae, 0x08101808, 0xba6fd5ba, 0x78f08878, 0x254a6f25, 
+     0x2e5c722e, 0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6, 
+     0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f, 0x4b96dd4b, 
+     0xbd61dcbd, 0x8b0d868b, 0x8a0f858a, 0x70e09070, 0x3e7c423e, 
+     0xb571c4b5, 0x66ccaa66, 0x4890d848, 0x03060503, 0xf6f701f6, 
+     0x0e1c120e, 0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9, 
+     0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e, 0xe1d938e1, 
+     0xf8eb13f8, 0x982bb398, 0x11223311, 0x69d2bb69, 0xd9a970d9, 
+     0x8e07898e, 0x9433a794, 0x9b2db69b, 0x1e3c221e, 0x87159287, 
+     0xe9c920e9, 0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf, 
+     0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d, 0xbf65dabf, 
+     0xe6d731e6, 0x4284c642, 0x68d0b868, 0x4182c341, 0x9929b099, 
+     0x2d5a772d, 0x0f1e110f, 0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 
+     0x162c3a16};
+
+    private static final int[] T3 =
+    {
+     0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b, 0xff0df2f2, 
+     0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5, 0x60503030, 0x02030101, 
+     0xcea96767, 0x567d2b2b, 0xe719fefe, 0xb562d7d7, 0x4de6abab, 
+     0xec9a7676, 0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d, 
+     0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0, 0x41ecadad, 
+     0xb367d4d4, 0x5ffda2a2, 0x45eaafaf, 0x23bf9c9c, 0x53f7a4a4, 
+     0xe4967272, 0x9b5bc0c0, 0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 
+     0x4c6a2626, 0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc, 
+     0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1, 0xe2937171, 
+     0xab73d8d8, 0x62533131, 0x2a3f1515, 0x080c0404, 0x9552c7c7, 
+     0x46652323, 0x9d5ec3c3, 0x30281818, 0x37a19696, 0x0a0f0505, 
+     0x2fb59a9a, 0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2, 
+     0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575, 0x121b0909, 
+     0x1d9e8383, 0x58742c2c, 0x342e1a1a, 0x362d1b1b, 0xdcb26e6e, 
+     0xb4ee5a5a, 0x5bfba0a0, 0xa4f65252, 0x764d3b3b, 0xb761d6d6, 
+     0x7dceb3b3, 0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484, 
+     0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded, 0x40602020, 
+     0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b, 0xd4be6a6a, 0x8d46cbcb, 
+     0x67d9bebe, 0x724b3939, 0x94de4a4a, 0x98d44c4c, 0xb0e85858, 
+     0x854acfcf, 0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb, 
+     0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585, 0x8acf4545, 
+     0xe910f9f9, 0x04060202, 0xfe817f7f, 0xa0f05050, 0x78443c3c, 
+     0x25ba9f9f, 0x4be3a8a8, 0xa2f35151, 0x5dfea3a3, 0x80c04040, 
+     0x058a8f8f, 0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5, 
+     0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121, 0x20301010, 
+     0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2, 0x814ccdcd, 0x18140c0c, 
+     0x26351313, 0xc32fecec, 0xbee15f5f, 0x35a29797, 0x88cc4444, 
+     0x2e391717, 0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d, 
+     0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373, 0xc0a06060, 
+     0x19988181, 0x9ed14f4f, 0xa37fdcdc, 0x44662222, 0x547e2a2a, 
+     0x3bab9090, 0x0b838888, 0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 
+     0x283c1414, 0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb, 
+     0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a, 0x92db4949, 
+     0x0c0a0606, 0x486c2424, 0xb8e45c5c, 0x9f5dc2c2, 0xbd6ed3d3, 
+     0x43efacac, 0xc4a66262, 0x39a89191, 0x31a49595, 0xd337e4e4, 
+     0xf28b7979, 0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d, 
+     0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9, 0xd8b46c6c, 
+     0xacfa5656, 0xf307f4f4, 0xcf25eaea, 0xcaaf6565, 0xf48e7a7a, 
+     0x47e9aeae, 0x10180808, 0x6fd5baba, 0xf0887878, 0x4a6f2525, 
+     0x5c722e2e, 0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6, 
+     0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f, 0x96dd4b4b, 
+     0x61dcbdbd, 0x0d868b8b, 0x0f858a8a, 0xe0907070, 0x7c423e3e, 
+     0x71c4b5b5, 0xccaa6666, 0x90d84848, 0x06050303, 0xf701f6f6, 
+     0x1c120e0e, 0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9, 
+     0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e, 0xd938e1e1, 
+     0xeb13f8f8, 0x2bb39898, 0x22331111, 0xd2bb6969, 0xa970d9d9, 
+     0x07898e8e, 0x33a79494, 0x2db69b9b, 0x3c221e1e, 0x15928787, 
+     0xc920e9e9, 0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf, 
+     0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d, 0x65dabfbf, 
+     0xd731e6e6, 0x84c64242, 0xd0b86868, 0x82c34141, 0x29b09999, 
+     0x5a772d2d, 0x1e110f0f, 0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 
+     0x2c3a1616};
+
+    private static final int[] Tinv0 =
+    {
+     0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 
+     0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 
+     0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 
+     0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 
+     0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 
+     0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 
+     0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 
+     0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 
+     0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 
+     0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 
+     0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 
+     0x2aab5566, 0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3, 
+     0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 
+     0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 
+     0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 
+     0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd, 
+     0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 
+     0x055dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 
+     0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 
+     0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000, 
+     0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 
+     0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 
+     0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0x0fe75793, 0xd296eeb4, 
+     0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 
+     0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0x0b0d090e, 
+     0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 
+     0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 
+     0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 
+     0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 
+     0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 
+     0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 
+     0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 
+     0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 
+     0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0x0d927850, 
+     0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 
+     0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 
+     0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x097826cd, 
+     0xf418596e, 0x01b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 
+     0x08cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 
+     0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 
+     0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 
+     0xf7daec41, 0x0e50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 
+     0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 
+     0x7f516546, 0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 
+     0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 
+     0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 
+     0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 
+     0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 
+     0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 
+     0x0c25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 
+     0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 
+     0x4257b8d0};
+
+    private static final int[] Tinv1 =
+    {
+     0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 
+     0x459d1ff1, 0x58faacab, 0x03e34b93, 0xfa302055, 0x6d76adf6, 
+     0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 
+     0xa362b58f, 0x5ab1de49, 0x1bba2567, 0x0eea4598, 0xc0fe5de1, 
+     0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 
+     0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 
+     0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 
+     0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 
+     0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 
+     0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 
+     0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x024b72e2, 0x8f1fe357, 
+     0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x0837d3a5, 
+     0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 
+     0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 
+     0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 
+     0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 
+     0x8a213ef9, 0x06dd963d, 0x053eddae, 0xbde64d46, 0x8d5491b5, 
+     0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 
+     0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 
+     0xeec879db, 0x0a7ca147, 0x0f427ce9, 0x1e84f8c9, 0x00000000, 
+     0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 
+     0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 
+     0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 
+     0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 
+     0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0x0d090e0b, 
+     0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x0775af4c, 
+     0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 
+     0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 
+     0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 
+     0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 
+     0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 
+     0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 
+     0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0x0bd49836, 0x81f5a6cf, 
+     0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 
+     0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 
+     0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 
+     0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 
+     0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 
+     0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x099fead4, 
+     0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 
+     0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 
+     0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 
+     0x4daacc54, 0x0496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 
+     0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 
+     0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 
+     0x0ca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 
+     0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 
+     0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 
+     0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 
+     0x25e2bc0c, 0x493c288b, 0x950dff41, 0x01a83971, 0xb30c08de, 
+     0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 
+     0x57b8d042};
+
+    private static final int[] Tinv2 =
+    {
+     0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 
+     0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 
+     0xcc889176, 0x02f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 
+     0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 
+     0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 
+     0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 
+     0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 
+     0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 
+     0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 
+     0x6bbb84ae, 0x81fe1ca0, 0x08f9942b, 0x48705868, 0x458f19fd, 
+     0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 
+     0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 
+     0x2830f287, 0xbf23b2a5, 0x0302ba6a, 0x16ed5c82, 0xcf8a2b1c, 
+     0x79a792b4, 0x07f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x0506d5be, 
+     0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 
+     0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 
+     0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 
+     0xc471055d, 0x06046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 
+     0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 
+     0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x00000000, 
+     0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0x0efdfbff, 
+     0x850f5638, 0xae3d1ed5, 0x2d362739, 0x0f0a64d9, 0x5c6821a6, 
+     0x5b9bd154, 0x36243a2e, 0x0a0cb167, 0x57930fe7, 0xeeb4d296, 
+     0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 
+     0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x090e0b0d, 
+     0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 
+     0x99eebbdd, 0x7fa3fd60, 0x01f79f26, 0x725cbcf5, 0x6644c53b, 
+     0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 
+     0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 
+     0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 
+     0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 
+     0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 
+     0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 
+     0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 
+     0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 
+     0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 
+     0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 
+     0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 
+     0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 
+     0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 
+     0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x04f14a98, 
+     0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 
+     0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 
+     0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0x0bfb2e41, 
+     0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 
+     0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 
+     0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 
+     0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 
+     0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 
+     0xe2bc0c25, 0x3c288b49, 0x0dff4195, 0xa8397101, 0x0c08deb3, 
+     0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 
+     0xb8d04257};
+
+    private static final int[] Tinv3 =
+    {
+     0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 
+     0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 
+     0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 
+     0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 
+     0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x03e75f8f, 
+     0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 
+     0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 
+     0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 
+     0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 
+     0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 
+     0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 
+     0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 
+     0x30f28728, 0x23b2a5bf, 0x02ba6a03, 0xed5c8216, 0x8a2b1ccf, 
+     0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x06d5be05, 
+     0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x0532e18a, 
+     0xa475ebf6, 0x0b39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 
+     0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 
+     0x71055dc4, 0x046fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 
+     0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x07888b89, 0xe7385b19, 
+     0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x00000000, 
+     0x09838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 
+     0x0f563885, 0x3d1ed5ae, 0x3627392d, 0x0a64d90f, 0x6821a65c, 
+     0x9bd1545b, 0x243a2e36, 0x0cb1670a, 0x930fe757, 0xb4d296ee, 
+     0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 
+     0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0x0e0b0d09, 
+     0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 
+     0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 
+     0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 
+     0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 
+     0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 
+     0x0dec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 
+     0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 
+     0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 
+     0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 
+     0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 
+     0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 
+     0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 
+     0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 
+     0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 
+     0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 
+     0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 
+     0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 
+     0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 
+     0x467f5165, 0x9d04ea5e, 0x015d358c, 0xfa737487, 0xfb2e410b, 
+     0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 
+     0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 
+     0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 
+     0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 
+     0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 
+     0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x08deb30c, 
+     0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 
+     0xd04257b8};
+
+    private int shift(
+        int     r,
+        int     shift)
+    {
+        return (r >>> shift) | (r << -shift);
+    }
+
+    /* multiply four bytes in GF(2^8) by 'x' {02} in parallel */
+
+    private static final int m1 = 0x80808080;
+    private static final int m2 = 0x7f7f7f7f;
+    private static final int m3 = 0x0000001b;
+
+    private int FFmulX(int x)
+    {
+        return (((x & m2) << 1) ^ (((x & m1) >>> 7) * m3));
+    }
+
+    /* 
+       The following defines provide alternative definitions of FFmulX that might
+       give improved performance if a fast 32-bit multiply is not available.
+       
+       private int FFmulX(int x) { int u = x & m1; u |= (u >> 1); return ((x & m2) << 1) ^ ((u >>> 3) | (u >>> 6)); } 
+       private static final int  m4 = 0x1b1b1b1b;
+       private int FFmulX(int x) { int u = x & m1; return ((x & m2) << 1) ^ ((u - (u >>> 7)) & m4); } 
+
+    */
+
+    private int inv_mcol(int x)
+    {
+        int f2 = FFmulX(x);
+        int f4 = FFmulX(f2);
+        int f8 = FFmulX(f4);
+        int f9 = x ^ f8;
+        
+        return f2 ^ f4 ^ f8 ^ shift(f2 ^ f9, 8) ^ shift(f4 ^ f9, 16) ^ shift(f9, 24);
+    }
+
+
+    private int subWord(int x)
+    {
+        return (S[x&255]&255 | ((S[(x>>8)&255]&255)<<8) | ((S[(x>>16)&255]&255)<<16) | S[(x>>24)&255]<<24);
+    }
+
+    /**
+     * Calculate the necessary round keys
+     * The number of calculations depends on key size and block size
+     * AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
+     * This code is written assuming those are the only possible values
+     */
+    private int[][] generateWorkingKey(
+                                    byte[] key,
+                                    boolean forEncryption)
+    {
+        int         KC = key.length / 4;  // key length in words
+        int         t;
+        
+        if (((KC != 4) && (KC != 6) && (KC != 8)) || ((KC * 4) != key.length))
+        {
+            throw new IllegalArgumentException("Key length not 128/192/256 bits.");
+        }
+
+        ROUNDS = KC + 6;  // This is not always true for the generalized Rijndael that allows larger block sizes
+        int[][] W = new int[ROUNDS+1][4];   // 4 words in a block
+        
+        //
+        // copy the key into the round key array
+        //
+        
+        t = 0;
+        int i = 0;
+        while (i < key.length)
+        {
+            W[t >> 2][t & 3] = (key[i]&0xff) | ((key[i+1]&0xff) << 8) | ((key[i+2]&0xff) << 16) | (key[i+3] << 24);
+            i+=4;
+            t++;
+        }
+        
+        //
+        // while not enough round key material calculated
+        // calculate new values
+        //
+        int k = (ROUNDS + 1) << 2;
+        for (i = KC; (i < k); i++)
+        {
+            int temp = W[(i - 1) >> 2][(i - 1) & 3];
+            if ((i % KC) == 0)
+            {
+                temp = subWord(shift(temp, 8)) ^ rcon[(i / KC) - 1];
+            }
+            else if ((KC > 6) && ((i % KC) == 4))
+            {
+                temp = subWord(temp);
+            }
+
+            W[i >> 2][i & 3] = W[(i - KC) >> 2][(i - KC) & 3] ^ temp;
+        }
+
+        if (!forEncryption)
+        {
+            for (int j = 1; j < ROUNDS; j++)
+            {
+                for (i = 0; i < 4; i++)
+                {
+                    W[j][i] = inv_mcol(W[j][i]);
+                }
+            }
+        }
+
+        return W;
+    }
+
+    private int         ROUNDS;
+    private int[][]     WorkingKey = null;
+    private int         C0, C1, C2, C3;
+    private boolean     forEncryption;
+
+    private static final int BLOCK_SIZE = 16;
+
+    /**
+     * default constructor - 128 bit block size.
+     */
+    public AESFastEngine()
+    {
+    }
+
+    /**
+     * initialise an AES cipher.
+     *
+     * @param forEncryption whether or not we are for encryption.
+     * @param params the parameters required to set up the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean           forEncryption,
+        CipherParameters  params)
+    {
+        if (params instanceof KeyParameter)
+        {
+            WorkingKey = generateWorkingKey(((KeyParameter)params).getKey(), forEncryption);
+            this.forEncryption = forEncryption;
+            return;
+        }
+
+        throw new IllegalArgumentException("invalid parameter passed to AES init - " + params.getClass().getName());
+    }
+
+    public String getAlgorithmName()
+    {
+        return "AES";
+    }
+
+    public int getBlockSize()
+    {
+        return BLOCK_SIZE;
+    }
+
+    public int processBlock(
+        byte[] in,
+        int inOff,
+        byte[] out,
+        int outOff)
+    {
+        if (WorkingKey == null)
+        {
+            throw new IllegalStateException("AES engine not initialised");
+        }
+
+        if ((inOff + (32 / 2)) > in.length)
+        {
+            throw new DataLengthException("input buffer too short");
+        }
+
+        if ((outOff + (32 / 2)) > out.length)
+        {
+            throw new DataLengthException("output buffer too short");
+        }
+
+        if (forEncryption)
+        {
+            unpackBlock(in, inOff);
+            encryptBlock(WorkingKey);
+            packBlock(out, outOff);
+        }
+        else
+        {
+            unpackBlock(in, inOff);
+            decryptBlock(WorkingKey);
+            packBlock(out, outOff);
+        }
+
+        return BLOCK_SIZE;
+    }
+
+    public void reset()
+    {
+    }
+
+    private void unpackBlock(
+        byte[]      bytes,
+        int         off)
+    {
+        int     index = off;
+
+        C0 = (bytes[index++] & 0xff);
+        C0 |= (bytes[index++] & 0xff) << 8;
+        C0 |= (bytes[index++] & 0xff) << 16;
+        C0 |= bytes[index++] << 24;
+
+        C1 = (bytes[index++] & 0xff);
+        C1 |= (bytes[index++] & 0xff) << 8;
+        C1 |= (bytes[index++] & 0xff) << 16;
+        C1 |= bytes[index++] << 24;
+
+        C2 = (bytes[index++] & 0xff);
+        C2 |= (bytes[index++] & 0xff) << 8;
+        C2 |= (bytes[index++] & 0xff) << 16;
+        C2 |= bytes[index++] << 24;
+
+        C3 = (bytes[index++] & 0xff);
+        C3 |= (bytes[index++] & 0xff) << 8;
+        C3 |= (bytes[index++] & 0xff) << 16;
+        C3 |= bytes[index++] << 24;
+    }
+
+    private void packBlock(
+        byte[]      bytes,
+        int         off)
+    {
+        int     index = off;
+
+        bytes[index++] = (byte)C0;
+        bytes[index++] = (byte)(C0 >> 8);
+        bytes[index++] = (byte)(C0 >> 16);
+        bytes[index++] = (byte)(C0 >> 24);
+
+        bytes[index++] = (byte)C1;
+        bytes[index++] = (byte)(C1 >> 8);
+        bytes[index++] = (byte)(C1 >> 16);
+        bytes[index++] = (byte)(C1 >> 24);
+
+        bytes[index++] = (byte)C2;
+        bytes[index++] = (byte)(C2 >> 8);
+        bytes[index++] = (byte)(C2 >> 16);
+        bytes[index++] = (byte)(C2 >> 24);
+
+        bytes[index++] = (byte)C3;
+        bytes[index++] = (byte)(C3 >> 8);
+        bytes[index++] = (byte)(C3 >> 16);
+        bytes[index++] = (byte)(C3 >> 24);
+    }
+
+    private void encryptBlock(int[][] KW)
+    {
+        int r, r0, r1, r2, r3;
+        
+        C0 ^= KW[0][0];
+        C1 ^= KW[0][1];
+        C2 ^= KW[0][2];
+        C3 ^= KW[0][3];
+
+        r = 1;
+        while (r < ROUNDS - 1)
+        {
+            r0 = T0[C0&255] ^ T1[(C1>>8)&255] ^ T2[(C2>>16)&255] ^ T3[(C3>>24)&255] ^ KW[r][0];
+            r1 = T0[C1&255] ^ T1[(C2>>8)&255] ^ T2[(C3>>16)&255] ^ T3[(C0>>24)&255] ^ KW[r][1];
+            r2 = T0[C2&255] ^ T1[(C3>>8)&255] ^ T2[(C0>>16)&255] ^ T3[(C1>>24)&255] ^ KW[r][2];
+            r3 = T0[C3&255] ^ T1[(C0>>8)&255] ^ T2[(C1>>16)&255] ^ T3[(C2>>24)&255] ^ KW[r++][3];
+            C0 = T0[r0&255] ^ T1[(r1>>8)&255] ^ T2[(r2>>16)&255] ^ T3[(r3>>24)&255] ^ KW[r][0];
+            C1 = T0[r1&255] ^ T1[(r2>>8)&255] ^ T2[(r3>>16)&255] ^ T3[(r0>>24)&255] ^ KW[r][1];
+            C2 = T0[r2&255] ^ T1[(r3>>8)&255] ^ T2[(r0>>16)&255] ^ T3[(r1>>24)&255] ^ KW[r][2];
+            C3 = T0[r3&255] ^ T1[(r0>>8)&255] ^ T2[(r1>>16)&255] ^ T3[(r2>>24)&255] ^ KW[r++][3];
+        }
+
+        r0 = T0[C0&255] ^ T1[(C1>>8)&255] ^ T2[(C2>>16)&255] ^ T3[(C3>>24)&255] ^ KW[r][0];
+        r1 = T0[C1&255] ^ T1[(C2>>8)&255] ^ T2[(C3>>16)&255] ^ T3[(C0>>24)&255] ^ KW[r][1];
+        r2 = T0[C2&255] ^ T1[(C3>>8)&255] ^ T2[(C0>>16)&255] ^ T3[(C1>>24)&255] ^ KW[r][2];
+        r3 = T0[C3&255] ^ T1[(C0>>8)&255] ^ T2[(C1>>16)&255] ^ T3[(C2>>24)&255] ^ KW[r++][3];
+        
+        // the final round's table is a simple function of S so we don't use a whole other four tables for it
+
+        C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((S[(r2>>16)&255]&255)<<16) ^ (S[(r3>>24)&255]<<24) ^ KW[r][0];
+        C1 = (S[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (S[(r0>>24)&255]<<24) ^ KW[r][1];
+        C2 = (S[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2];
+        C3 = (S[r3&255]&255) ^ ((S[(r0>>8)&255]&255)<<8) ^ ((S[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3];
+
+    }
+
+    private void decryptBlock(int[][] KW)
+    {
+        int r0, r1, r2, r3;
+
+        C0 ^= KW[ROUNDS][0];
+        C1 ^= KW[ROUNDS][1];
+        C2 ^= KW[ROUNDS][2];
+        C3 ^= KW[ROUNDS][3];
+
+        int r = ROUNDS-1; 
+        
+        while (r>1) 
+        {
+            r0 = Tinv0[C0&255] ^ Tinv1[(C3>>8)&255] ^ Tinv2[(C2>>16)&255] ^ Tinv3[(C1>>24)&255] ^ KW[r][0];
+            r1 = Tinv0[C1&255] ^ Tinv1[(C0>>8)&255] ^ Tinv2[(C3>>16)&255] ^ Tinv3[(C2>>24)&255] ^ KW[r][1];
+            r2 = Tinv0[C2&255] ^ Tinv1[(C1>>8)&255] ^ Tinv2[(C0>>16)&255] ^ Tinv3[(C3>>24)&255] ^ KW[r][2];
+            r3 = Tinv0[C3&255] ^ Tinv1[(C2>>8)&255] ^ Tinv2[(C1>>16)&255] ^ Tinv3[(C0>>24)&255] ^ KW[r--][3];
+            C0 = Tinv0[r0&255] ^ Tinv1[(r3>>8)&255] ^ Tinv2[(r2>>16)&255] ^ Tinv3[(r1>>24)&255] ^ KW[r][0];
+            C1 = Tinv0[r1&255] ^ Tinv1[(r0>>8)&255] ^ Tinv2[(r3>>16)&255] ^ Tinv3[(r2>>24)&255] ^ KW[r][1];
+            C2 = Tinv0[r2&255] ^ Tinv1[(r1>>8)&255] ^ Tinv2[(r0>>16)&255] ^ Tinv3[(r3>>24)&255] ^ KW[r][2];
+            C3 = Tinv0[r3&255] ^ Tinv1[(r2>>8)&255] ^ Tinv2[(r1>>16)&255] ^ Tinv3[(r0>>24)&255] ^ KW[r--][3];
+        }
+
+        r0 = Tinv0[C0&255] ^ Tinv1[(C3>>8)&255] ^ Tinv2[(C2>>16)&255] ^ Tinv3[(C1>>24)&255] ^ KW[r][0];
+        r1 = Tinv0[C1&255] ^ Tinv1[(C0>>8)&255] ^ Tinv2[(C3>>16)&255] ^ Tinv3[(C2>>24)&255] ^ KW[r][1];
+        r2 = Tinv0[C2&255] ^ Tinv1[(C1>>8)&255] ^ Tinv2[(C0>>16)&255] ^ Tinv3[(C3>>24)&255] ^ KW[r][2];
+        r3 = Tinv0[C3&255] ^ Tinv1[(C2>>8)&255] ^ Tinv2[(C1>>16)&255] ^ Tinv3[(C0>>24)&255] ^ KW[r][3];
+        
+        // the final round's table is a simple function of Si so we don't use a whole other four tables for it
+
+        C0 = (Si[r0&255]&255) ^ ((Si[(r3>>8)&255]&255)<<8) ^ ((Si[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];
+        C1 = (Si[r1&255]&255) ^ ((Si[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (Si[(r2>>24)&255]<<24) ^ KW[0][1];
+        C2 = (Si[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (Si[(r3>>24)&255]<<24) ^ KW[0][2];
+        C3 = (Si[r3&255]&255) ^ ((Si[(r2>>8)&255]&255)<<8) ^ ((Si[(r1>>16)&255]&255)<<16) ^ (Si[(r0>>24)&255]<<24) ^ KW[0][3];
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/DESEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/DESEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/DESEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,494 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * a class that provides a basic DES engine.
+ */
+public class DESEngine
+    implements BlockCipher
+{
+    protected static final int  BLOCK_SIZE = 8;
+
+    private int[]               workingKey = null;
+
+    /**
+     * standard constructor.
+     */
+    public DESEngine()
+    {
+    }
+
+    /**
+     * initialise a DES cipher.
+     *
+     * @param encrypting whether or not we are for encryption.
+     * @param params the parameters required to set up the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean           encrypting,
+        CipherParameters  params)
+    {
+        if (params instanceof KeyParameter)
+        {
+            if (((KeyParameter)params).getKey().length > 8)
+            {
+                throw new IllegalArgumentException("DES key too long - should be 8 bytes");
+            }
+            
+            workingKey = generateWorkingKey(encrypting,
+                                  ((KeyParameter)params).getKey());
+
+            return;
+        }
+
+        throw new IllegalArgumentException("invalid parameter passed to DES init - " + params.getClass().getName());
+    }
+
+    public String getAlgorithmName()
+    {
+        return "DES";
+    }
+
+    public int getBlockSize()
+    {
+        return BLOCK_SIZE;
+    }
+
+    public int processBlock(
+        byte[] in,
+        int inOff,
+        byte[] out,
+        int outOff)
+    {
+        if (workingKey == null)
+        {
+            throw new IllegalStateException("DES engine not initialised");
+        }
+
+        if ((inOff + BLOCK_SIZE) > in.length)
+        {
+            throw new DataLengthException("input buffer too short");
+        }
+
+        if ((outOff + BLOCK_SIZE) > out.length)
+        {
+            throw new DataLengthException("output buffer too short");
+        }
+
+        desFunc(workingKey, in, inOff, out, outOff);
+
+        return BLOCK_SIZE;
+    }
+
+    public void reset()
+    {
+    }
+
+    /**
+     * what follows is mainly taken from "Applied Cryptography", by
+     * Bruce Schneier, however it also bears great resemblance to Richard
+     * Outerbridge's D3DES...
+     */
+
+//    private static final short[]    Df_Key =
+//        {
+//            0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
+//            0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,
+//            0x89,0xab,0xcd,0xef,0x01,0x23,0x45,0x67
+//        };
+
+    private static final short[]    bytebit =
+        {
+            0200, 0100, 040, 020, 010, 04, 02, 01
+        };
+
+    private static final int[]    bigbyte =
+        {
+            0x800000, 0x400000, 0x200000, 0x100000,
+            0x80000,  0x40000,  0x20000,  0x10000,
+            0x8000,      0x4000,   0x2000,   0x1000,
+            0x800,    0x400,    0x200,    0x100,
+            0x80,      0x40,        0x20,     0x10,
+            0x8,      0x4,      0x2,      0x1
+        };
+
+    /*
+     * Use the key schedule specified in the Standard (ANSI X3.92-1981).
+     */
+
+    private static final byte[]    pc1 =
+        {
+            56, 48, 40, 32, 24, 16,  8,   0, 57, 49, 41, 33, 25, 17,
+             9,  1, 58, 50, 42, 34, 26,  18, 10,  2, 59, 51, 43, 35,
+            62, 54, 46, 38, 30, 22, 14,   6, 61, 53, 45, 37, 29, 21,
+            13,  5, 60, 52, 44, 36, 28,  20, 12,  4, 27, 19, 11,  3
+        };
+
+    private static final byte[] totrot =
+        {
+            1, 2, 4, 6, 8, 10, 12, 14,
+            15, 17, 19, 21, 23, 25, 27, 28
+        };
+
+    private static final byte[] pc2 =
+        {
+            13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
+            22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
+            40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
+            43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31
+        };
+
+    private static final int[] SP1 = {
+        0x01010400, 0x00000000, 0x00010000, 0x01010404,
+        0x01010004, 0x00010404, 0x00000004, 0x00010000,
+        0x00000400, 0x01010400, 0x01010404, 0x00000400,
+        0x01000404, 0x01010004, 0x01000000, 0x00000004,
+        0x00000404, 0x01000400, 0x01000400, 0x00010400,
+        0x00010400, 0x01010000, 0x01010000, 0x01000404,
+        0x00010004, 0x01000004, 0x01000004, 0x00010004,
+        0x00000000, 0x00000404, 0x00010404, 0x01000000,
+        0x00010000, 0x01010404, 0x00000004, 0x01010000,
+        0x01010400, 0x01000000, 0x01000000, 0x00000400,
+        0x01010004, 0x00010000, 0x00010400, 0x01000004,
+        0x00000400, 0x00000004, 0x01000404, 0x00010404,
+        0x01010404, 0x00010004, 0x01010000, 0x01000404,
+        0x01000004, 0x00000404, 0x00010404, 0x01010400,
+        0x00000404, 0x01000400, 0x01000400, 0x00000000,
+        0x00010004, 0x00010400, 0x00000000, 0x01010004
+    };
+
+    private static final int[] SP2 = {
+        0x80108020, 0x80008000, 0x00008000, 0x00108020,
+        0x00100000, 0x00000020, 0x80100020, 0x80008020,
+        0x80000020, 0x80108020, 0x80108000, 0x80000000,
+        0x80008000, 0x00100000, 0x00000020, 0x80100020,
+        0x00108000, 0x00100020, 0x80008020, 0x00000000,
+        0x80000000, 0x00008000, 0x00108020, 0x80100000,
+        0x00100020, 0x80000020, 0x00000000, 0x00108000,
+        0x00008020, 0x80108000, 0x80100000, 0x00008020,
+        0x00000000, 0x00108020, 0x80100020, 0x00100000,
+        0x80008020, 0x80100000, 0x80108000, 0x00008000,
+        0x80100000, 0x80008000, 0x00000020, 0x80108020,
+        0x00108020, 0x00000020, 0x00008000, 0x80000000,
+        0x00008020, 0x80108000, 0x00100000, 0x80000020,
+        0x00100020, 0x80008020, 0x80000020, 0x00100020,
+        0x00108000, 0x00000000, 0x80008000, 0x00008020,
+        0x80000000, 0x80100020, 0x80108020, 0x00108000
+    };
+
+    private static final int[] SP3 = {
+        0x00000208, 0x08020200, 0x00000000, 0x08020008,
+        0x08000200, 0x00000000, 0x00020208, 0x08000200,
+        0x00020008, 0x08000008, 0x08000008, 0x00020000,
+        0x08020208, 0x00020008, 0x08020000, 0x00000208,
+        0x08000000, 0x00000008, 0x08020200, 0x00000200,
+        0x00020200, 0x08020000, 0x08020008, 0x00020208,
+        0x08000208, 0x00020200, 0x00020000, 0x08000208,
+        0x00000008, 0x08020208, 0x00000200, 0x08000000,
+        0x08020200, 0x08000000, 0x00020008, 0x00000208,
+        0x00020000, 0x08020200, 0x08000200, 0x00000000,
+        0x00000200, 0x00020008, 0x08020208, 0x08000200,
+        0x08000008, 0x00000200, 0x00000000, 0x08020008,
+        0x08000208, 0x00020000, 0x08000000, 0x08020208,
+        0x00000008, 0x00020208, 0x00020200, 0x08000008,
+        0x08020000, 0x08000208, 0x00000208, 0x08020000,
+        0x00020208, 0x00000008, 0x08020008, 0x00020200
+    };
+
+    private static final int[] SP4 = {
+        0x00802001, 0x00002081, 0x00002081, 0x00000080,
+        0x00802080, 0x00800081, 0x00800001, 0x00002001,
+        0x00000000, 0x00802000, 0x00802000, 0x00802081,
+        0x00000081, 0x00000000, 0x00800080, 0x00800001,
+        0x00000001, 0x00002000, 0x00800000, 0x00802001,
+        0x00000080, 0x00800000, 0x00002001, 0x00002080,
+        0x00800081, 0x00000001, 0x00002080, 0x00800080,
+        0x00002000, 0x00802080, 0x00802081, 0x00000081,
+        0x00800080, 0x00800001, 0x00802000, 0x00802081,
+        0x00000081, 0x00000000, 0x00000000, 0x00802000,
+        0x00002080, 0x00800080, 0x00800081, 0x00000001,
+        0x00802001, 0x00002081, 0x00002081, 0x00000080,
+        0x00802081, 0x00000081, 0x00000001, 0x00002000,
+        0x00800001, 0x00002001, 0x00802080, 0x00800081,
+        0x00002001, 0x00002080, 0x00800000, 0x00802001,
+        0x00000080, 0x00800000, 0x00002000, 0x00802080
+    };
+
+    private static final int[] SP5 = {
+        0x00000100, 0x02080100, 0x02080000, 0x42000100,
+        0x00080000, 0x00000100, 0x40000000, 0x02080000,
+        0x40080100, 0x00080000, 0x02000100, 0x40080100,
+        0x42000100, 0x42080000, 0x00080100, 0x40000000,
+        0x02000000, 0x40080000, 0x40080000, 0x00000000,
+        0x40000100, 0x42080100, 0x42080100, 0x02000100,
+        0x42080000, 0x40000100, 0x00000000, 0x42000000,
+        0x02080100, 0x02000000, 0x42000000, 0x00080100,
+        0x00080000, 0x42000100, 0x00000100, 0x02000000,
+        0x40000000, 0x02080000, 0x42000100, 0x40080100,
+        0x02000100, 0x40000000, 0x42080000, 0x02080100,
+        0x40080100, 0x00000100, 0x02000000, 0x42080000,
+        0x42080100, 0x00080100, 0x42000000, 0x42080100,
+        0x02080000, 0x00000000, 0x40080000, 0x42000000,
+        0x00080100, 0x02000100, 0x40000100, 0x00080000,
+        0x00000000, 0x40080000, 0x02080100, 0x40000100
+    };
+
+    private static final int[] SP6 = {
+        0x20000010, 0x20400000, 0x00004000, 0x20404010,
+        0x20400000, 0x00000010, 0x20404010, 0x00400000,
+        0x20004000, 0x00404010, 0x00400000, 0x20000010,
+        0x00400010, 0x20004000, 0x20000000, 0x00004010,
+        0x00000000, 0x00400010, 0x20004010, 0x00004000,
+        0x00404000, 0x20004010, 0x00000010, 0x20400010,
+        0x20400010, 0x00000000, 0x00404010, 0x20404000,
+        0x00004010, 0x00404000, 0x20404000, 0x20000000,
+        0x20004000, 0x00000010, 0x20400010, 0x00404000,
+        0x20404010, 0x00400000, 0x00004010, 0x20000010,
+        0x00400000, 0x20004000, 0x20000000, 0x00004010,
+        0x20000010, 0x20404010, 0x00404000, 0x20400000,
+        0x00404010, 0x20404000, 0x00000000, 0x20400010,
+        0x00000010, 0x00004000, 0x20400000, 0x00404010,
+        0x00004000, 0x00400010, 0x20004010, 0x00000000,
+        0x20404000, 0x20000000, 0x00400010, 0x20004010
+    };
+
+    private static final int[] SP7 = {
+        0x00200000, 0x04200002, 0x04000802, 0x00000000,
+        0x00000800, 0x04000802, 0x00200802, 0x04200800,
+        0x04200802, 0x00200000, 0x00000000, 0x04000002,
+        0x00000002, 0x04000000, 0x04200002, 0x00000802,
+        0x04000800, 0x00200802, 0x00200002, 0x04000800,
+        0x04000002, 0x04200000, 0x04200800, 0x00200002,
+        0x04200000, 0x00000800, 0x00000802, 0x04200802,
+        0x00200800, 0x00000002, 0x04000000, 0x00200800,
+        0x04000000, 0x00200800, 0x00200000, 0x04000802,
+        0x04000802, 0x04200002, 0x04200002, 0x00000002,
+        0x00200002, 0x04000000, 0x04000800, 0x00200000,
+        0x04200800, 0x00000802, 0x00200802, 0x04200800,
+        0x00000802, 0x04000002, 0x04200802, 0x04200000,
+        0x00200800, 0x00000000, 0x00000002, 0x04200802,
+        0x00000000, 0x00200802, 0x04200000, 0x00000800,
+        0x04000002, 0x04000800, 0x00000800, 0x00200002
+    };
+
+    private static final int[] SP8 = {
+        0x10001040, 0x00001000, 0x00040000, 0x10041040,
+        0x10000000, 0x10001040, 0x00000040, 0x10000000,
+        0x00040040, 0x10040000, 0x10041040, 0x00041000,
+        0x10041000, 0x00041040, 0x00001000, 0x00000040,
+        0x10040000, 0x10000040, 0x10001000, 0x00001040,
+        0x00041000, 0x00040040, 0x10040040, 0x10041000,
+        0x00001040, 0x00000000, 0x00000000, 0x10040040,
+        0x10000040, 0x10001000, 0x00041040, 0x00040000,
+        0x00041040, 0x00040000, 0x10041000, 0x00001000,
+        0x00000040, 0x10040040, 0x00001000, 0x00041040,
+        0x10001000, 0x00000040, 0x10000040, 0x10040000,
+        0x10040040, 0x10000000, 0x00040000, 0x10001040,
+        0x00000000, 0x10041040, 0x00040040, 0x10000040,
+        0x10040000, 0x10001000, 0x10001040, 0x00000000,
+        0x10041040, 0x00041000, 0x00041000, 0x00001040,
+        0x00001040, 0x00040040, 0x10000000, 0x10041000
+    };
+
+    /**
+     * generate an integer based working key based on our secret key
+     * and what we processing we are planning to do.
+     *
+     * Acknowledgements for this routine go to James Gillogly & Phil Karn.
+     *         (whoever, and wherever they are!).
+     */
+    protected int[] generateWorkingKey(
+        boolean encrypting,
+        byte[]  key)
+    {
+        int[]       newKey = new int[32];
+        boolean[]   pc1m = new boolean[56],
+                    pcr = new boolean[56];
+
+        for (int j = 0; j < 56; j++)
+        {
+            int    l = pc1[j];
+
+            pc1m[j] = ((key[l >>> 3] & bytebit[l & 07]) != 0);
+        }
+
+        for (int i = 0; i < 16; i++)
+        {
+            int    l, m, n;
+
+            if (encrypting)
+            {
+                m = i << 1;
+            }
+            else
+            {
+                m = (15 - i) << 1;
+            }
+
+            n = m + 1;
+            newKey[m] = newKey[n] = 0;
+
+            for (int j = 0; j < 28; j++)
+            {
+                l = j + totrot[i];
+                if (l < 28)
+                {
+                    pcr[j] = pc1m[l];
+                }
+                else
+                {
+                    pcr[j] = pc1m[l - 28];
+                }
+            }
+
+            for (int j = 28; j < 56; j++)
+            {
+                l = j + totrot[i];
+                if (l < 56)
+                {
+                    pcr[j] = pc1m[l];
+                }
+                else
+                {
+                    pcr[j] = pc1m[l - 28];
+                }
+            }
+
+            for (int j = 0; j < 24; j++)
+            {
+                if (pcr[pc2[j]])
+                {
+                    newKey[m] |= bigbyte[j];
+                }
+
+                if (pcr[pc2[j + 24]])
+                {
+                    newKey[n] |= bigbyte[j];
+                }
+            }
+        }
+
+        //
+        // store the processed key
+        //
+        for (int i = 0; i != 32; i += 2)
+        {
+            int    i1, i2;
+
+            i1 = newKey[i];
+            i2 = newKey[i + 1];
+
+            newKey[i] = ((i1 & 0x00fc0000) << 6) | ((i1 & 0x00000fc0) << 10)
+                                   | ((i2 & 0x00fc0000) >>> 10) | ((i2 & 0x00000fc0) >>> 6);
+
+            newKey[i + 1] = ((i1 & 0x0003f000) << 12) | ((i1 & 0x0000003f) << 16)
+                                   | ((i2 & 0x0003f000) >>> 4) | (i2 & 0x0000003f);
+        }
+
+        return newKey;
+    }
+
+    /**
+     * the DES engine.
+     */
+    protected void desFunc(
+        int[]   wKey,
+        byte[]  in,
+        int     inOff,
+        byte[]  out,
+        int     outOff)
+    {
+        int     work, right, left;
+
+        left     = (in[inOff + 0] & 0xff) << 24;
+        left    |= (in[inOff + 1] & 0xff) << 16;
+        left    |= (in[inOff + 2] & 0xff) << 8;
+        left    |= (in[inOff + 3] & 0xff);
+
+        right     = (in[inOff + 4] & 0xff) << 24;
+        right    |= (in[inOff + 5] & 0xff) << 16;
+        right    |= (in[inOff + 6] & 0xff) << 8;
+        right    |= (in[inOff + 7] & 0xff);
+
+        work = ((left >>> 4) ^ right) & 0x0f0f0f0f;
+        right ^= work;
+        left ^= (work << 4);
+        work = ((left >>> 16) ^ right) & 0x0000ffff;
+        right ^= work;
+        left ^= (work << 16);
+        work = ((right >>> 2) ^ left) & 0x33333333;
+        left ^= work;
+        right ^= (work << 2);
+        work = ((right >>> 8) ^ left) & 0x00ff00ff;
+        left ^= work;
+        right ^= (work << 8);
+        right = ((right << 1) | ((right >>> 31) & 1)) & 0xffffffff;
+        work = (left ^ right) & 0xaaaaaaaa;
+        left ^= work;
+        right ^= work;
+        left = ((left << 1) | ((left >>> 31) & 1)) & 0xffffffff;
+
+        for (int round = 0; round < 8; round++)
+        {
+            int     fval;
+
+            work  = (right << 28) | (right >>> 4);
+            work ^= wKey[round * 4 + 0];
+            fval  = SP7[ work      & 0x3f];
+            fval |= SP5[(work >>>  8) & 0x3f];
+            fval |= SP3[(work >>> 16) & 0x3f];
+            fval |= SP1[(work >>> 24) & 0x3f];
+            work  = right ^ wKey[round * 4 + 1];
+            fval |= SP8[ work      & 0x3f];
+            fval |= SP6[(work >>>  8) & 0x3f];
+            fval |= SP4[(work >>> 16) & 0x3f];
+            fval |= SP2[(work >>> 24) & 0x3f];
+            left ^= fval;
+            work  = (left << 28) | (left >>> 4);
+            work ^= wKey[round * 4 + 2];
+            fval  = SP7[ work      & 0x3f];
+            fval |= SP5[(work >>>  8) & 0x3f];
+            fval |= SP3[(work >>> 16) & 0x3f];
+            fval |= SP1[(work >>> 24) & 0x3f];
+            work  = left ^ wKey[round * 4 + 3];
+            fval |= SP8[ work      & 0x3f];
+            fval |= SP6[(work >>>  8) & 0x3f];
+            fval |= SP4[(work >>> 16) & 0x3f];
+            fval |= SP2[(work >>> 24) & 0x3f];
+            right ^= fval;
+        }
+
+        right = (right << 31) | (right >>> 1);
+        work = (left ^ right) & 0xaaaaaaaa;
+        left ^= work;
+        right ^= work;
+        left = (left << 31) | (left >>> 1);
+        work = ((left >>> 8) ^ right) & 0x00ff00ff;
+        right ^= work;
+        left ^= (work << 8);
+        work = ((left >>> 2) ^ right) & 0x33333333;
+        right ^= work;
+        left ^= (work << 2);
+        work = ((right >>> 16) ^ left) & 0x0000ffff;
+        left ^= work;
+        right ^= (work << 16);
+        work = ((right >>> 4) ^ left) & 0x0f0f0f0f;
+        left ^= work;
+        right ^= (work << 4);
+
+        out[outOff + 0] = (byte)((right >>> 24) & 0xff);
+        out[outOff + 1] = (byte)((right >>> 16) & 0xff);
+        out[outOff + 2] = (byte)((right >>>  8) & 0xff);
+        out[outOff + 3] = (byte)(right         & 0xff);
+        out[outOff + 4] = (byte)((left >>> 24) & 0xff);
+        out[outOff + 5] = (byte)((left >>> 16) & 0xff);
+        out[outOff + 6] = (byte)((left >>>  8) & 0xff);
+        out[outOff + 7] = (byte)(left         & 0xff);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * a class that provides a basic DESede (or Triple DES) engine.
+ */
+public class DESedeEngine
+    extends DESEngine
+{
+    protected static final int  BLOCK_SIZE = 8;
+
+    private int[]               workingKey1 = null;
+    private int[]               workingKey2 = null;
+    private int[]               workingKey3 = null;
+
+    private boolean             forEncryption;
+
+    /**
+     * standard constructor.
+     */
+    public DESedeEngine()
+    {
+    }
+
+    /**
+     * initialise a DESede cipher.
+     *
+     * @param encrypting whether or not we are for encryption.
+     * @param params the parameters required to set up the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean           encrypting,
+        CipherParameters  params)
+    {
+        if (!(params instanceof KeyParameter))
+        {
+            throw new IllegalArgumentException("invalid parameter passed to DESede init - " + params.getClass().getName());
+        }
+
+        byte[] keyMaster = ((KeyParameter)params).getKey();
+
+        if (keyMaster.length > 24)
+        {
+            throw new IllegalArgumentException("key size greater than 24 bytes");
+        }
+
+        this.forEncryption = encrypting;
+
+        byte[] key1 = new byte[8];
+        System.arraycopy(keyMaster, 0, key1, 0, key1.length);
+        workingKey1 = generateWorkingKey(encrypting, key1);
+
+        byte[] key2 = new byte[8];
+        System.arraycopy(keyMaster, 8, key2, 0, key2.length);
+        workingKey2 = generateWorkingKey(!encrypting, key2);
+
+        if (keyMaster.length == 24)
+        {
+            byte[] key3 = new byte[8];
+            System.arraycopy(keyMaster, 16, key3, 0, key3.length);
+            workingKey3 = generateWorkingKey(encrypting, key3);
+        }
+        else    // 16 byte key
+        {
+            workingKey3 = workingKey1;
+        }
+    }
+
+    public String getAlgorithmName()
+    {
+        return "DESede";
+    }
+
+    public int getBlockSize()
+    {
+        return BLOCK_SIZE;
+    }
+
+    public int processBlock(
+        byte[] in,
+        int inOff,
+        byte[] out,
+        int outOff)
+    {
+        if (workingKey1 == null)
+        {
+            throw new IllegalStateException("DESede engine not initialised");
+        }
+
+        if ((inOff + BLOCK_SIZE) > in.length)
+        {
+            throw new DataLengthException("input buffer too short");
+        }
+
+        if ((outOff + BLOCK_SIZE) > out.length)
+        {
+            throw new DataLengthException("output buffer too short");
+        }
+
+        byte[] temp = new byte[BLOCK_SIZE];
+
+        if (forEncryption)
+        {
+            desFunc(workingKey1, in, inOff, temp, 0);
+            desFunc(workingKey2, temp, 0, temp, 0);
+            desFunc(workingKey3, temp, 0, out, outOff);
+        }
+        else
+        {
+            desFunc(workingKey3, in, inOff, temp, 0);
+            desFunc(workingKey2, temp, 0, temp, 0);
+            desFunc(workingKey1, temp, 0, out, outOff);
+        }
+
+        return BLOCK_SIZE;
+    }
+
+    public void reset()
+    {
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.AsymmetricBlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;
+import org.bouncycastle.util.BigIntegers;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+/**
+ * this does your basic RSA algorithm with blinding
+ */
+public class RSABlindedEngine
+    implements AsymmetricBlockCipher
+{
+    private static BigInteger ONE = BigInteger.valueOf(1);
+
+    private RSACoreEngine    core = new RSACoreEngine();
+    private RSAKeyParameters key;
+    private SecureRandom     random;
+
+    /**
+     * initialise the RSA engine.
+     *
+     * @param forEncryption true if we are encrypting, false otherwise.
+     * @param param the necessary RSA key parameters.
+     */
+    public void init(
+        boolean             forEncryption,
+        CipherParameters    param)
+    {
+        core.init(forEncryption, param);
+
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+            key = (RSAKeyParameters)rParam.getParameters();
+            random = rParam.getRandom();
+        }
+        else
+        {
+            key = (RSAKeyParameters)param;
+            random = new SecureRandom();
+        }
+    }
+
+    /**
+     * Return the maximum size for an input block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * encryption, and the same length as the key size on decryption.
+     *
+     * @return maximum size for an input block.
+     */
+    public int getInputBlockSize()
+    {
+        return core.getInputBlockSize();
+    }
+
+    /**
+     * Return the maximum size for an output block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * decryption, and the same length as the key size on encryption.
+     *
+     * @return maximum size for an output block.
+     */
+    public int getOutputBlockSize()
+    {
+        return core.getOutputBlockSize();
+    }
+
+    /**
+     * Process a single block using the basic RSA algorithm.
+     *
+     * @param in the input array.
+     * @param inOff the offset into the input buffer where the data starts.
+     * @param inLen the length of the data to be processed.
+     * @return the result of the RSA process.
+     * @exception DataLengthException the input block is too large.
+     */
+    public byte[] processBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+    {
+        if (key == null)
+        {
+            throw new IllegalStateException("RSA engine not initialised");
+        }
+
+        BigInteger input = core.convertInput(in, inOff, inLen);
+
+        BigInteger result;
+        if (key instanceof RSAPrivateCrtKeyParameters)
+        {
+            RSAPrivateCrtKeyParameters k = (RSAPrivateCrtKeyParameters)key;
+
+            BigInteger e = k.getPublicExponent();
+            if (e != null)   // can't do blinding without a public exponent
+            {
+                BigInteger m = k.getModulus();
+                BigInteger r = BigIntegers.createRandomInRange(ONE, m.subtract(ONE), random);
+
+                BigInteger blindedInput = r.modPow(e, m).multiply(input).mod(m);
+                BigInteger blindedResult = core.processBlock(blindedInput);
+
+                BigInteger rInv = r.modInverse(m);
+                result = blindedResult.multiply(rInv).mod(m);
+            }
+            else
+            {
+                result = core.processBlock(input);
+            }
+        }
+        else
+        {
+            result = core.processBlock(input);
+        }
+
+        return core.convertOutput(result);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,203 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;
+
+import ewe.math.BigInteger;
+
+/**
+ * this does your basic RSA algorithm.
+ */
+class RSACoreEngine
+{
+    private RSAKeyParameters key;
+    private boolean          forEncryption;
+
+    /**
+     * initialise the RSA engine.
+     *
+     * @param forEncryption true if we are encrypting, false otherwise.
+     * @param param the necessary RSA key parameters.
+     */
+    public void init(
+        boolean          forEncryption,
+        CipherParameters param)
+    {
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+            key = (RSAKeyParameters)rParam.getParameters();
+        }
+        else
+        {
+            key = (RSAKeyParameters)param;
+        }
+
+        this.forEncryption = forEncryption;
+    }
+
+    /**
+     * Return the maximum size for an input block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * encryption, and the same length as the key size on decryption.
+     *
+     * @return maximum size for an input block.
+     */
+    public int getInputBlockSize()
+    {
+        int     bitSize = key.getModulus().bitLength();
+
+        if (forEncryption)
+        {
+            return (bitSize + 7) / 8 - 1;
+        }
+        else
+        {
+            return (bitSize + 7) / 8;
+        }
+    }
+
+    /**
+     * Return the maximum size for an output block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * decryption, and the same length as the key size on encryption.
+     *
+     * @return maximum size for an output block.
+     */
+    public int getOutputBlockSize()
+    {
+        int     bitSize = key.getModulus().bitLength();
+
+        if (forEncryption)
+        {
+            return (bitSize + 7) / 8;
+        }
+        else
+        {
+            return (bitSize + 7) / 8 - 1;
+        }
+    }
+
+    public BigInteger convertInput(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+    {
+        if (inLen > (getInputBlockSize() + 1))
+        {
+            throw new DataLengthException("input too large for RSA cipher.");
+        }
+        else if (inLen == (getInputBlockSize() + 1) && !forEncryption)
+        {
+            throw new DataLengthException("input too large for RSA cipher.");
+        }
+
+        byte[]  block;
+
+        if (inOff != 0 || inLen != in.length)
+        {
+            block = new byte[inLen];
+
+            System.arraycopy(in, inOff, block, 0, inLen);
+        }
+        else
+        {
+            block = in;
+        }
+
+        BigInteger res = new BigInteger(1, block);
+        if (res.compareTo(key.getModulus()) >= 0)
+        {
+            throw new DataLengthException("input too large for RSA cipher.");
+        }
+
+        return res;
+    }
+
+    public byte[] convertOutput(
+        BigInteger result)
+    {
+        byte[]      output = result.toByteArray();
+
+        if (forEncryption)
+        {
+            if (output[0] == 0 && output.length > getOutputBlockSize())        // have ended up with an extra zero byte, copy down.
+            {
+                byte[]  tmp = new byte[output.length - 1];
+
+                System.arraycopy(output, 1, tmp, 0, tmp.length);
+
+                return tmp;
+            }
+
+            if (output.length < getOutputBlockSize())     // have ended up with less bytes than normal, lengthen
+            {
+                byte[]  tmp = new byte[getOutputBlockSize()];
+
+                System.arraycopy(output, 0, tmp, tmp.length - output.length, output.length);
+
+                return tmp;
+            }
+        }
+        else
+        {
+            if (output[0] == 0)        // have ended up with an extra zero byte, copy down.
+            {
+                byte[]  tmp = new byte[output.length - 1];
+
+                System.arraycopy(output, 1, tmp, 0, tmp.length);
+
+                return tmp;
+            }
+        }
+
+        return output;
+    }
+
+    public BigInteger processBlock(BigInteger input)
+    {
+        if (key instanceof RSAPrivateCrtKeyParameters)
+        {
+            //
+            // we have the extra factors, use the Chinese Remainder Theorem - the author
+            // wishes to express his thanks to Dirk Bonekaemper at rtsffm.com for
+            // advice regarding the expression of this.
+            //
+            RSAPrivateCrtKeyParameters crtKey = (RSAPrivateCrtKeyParameters)key;
+
+            BigInteger p = crtKey.getP();
+            BigInteger q = crtKey.getQ();
+            BigInteger dP = crtKey.getDP();
+            BigInteger dQ = crtKey.getDQ();
+            BigInteger qInv = crtKey.getQInv();
+
+            BigInteger mP, mQ, h, m;
+
+            // mP = ((input mod p) ^ dP)) mod p
+            mP = (input.remainder(p)).modPow(dP, p);
+
+            // mQ = ((input mod q) ^ dQ)) mod q
+            mQ = (input.remainder(q)).modPow(dQ, q);
+
+            // h = qInv * (mP - mQ) mod p
+            h = mP.subtract(mQ);
+            h = h.multiply(qInv);
+            h = h.mod(p);               // mod (in Java) returns the positive residual
+
+            // m = h * q + mQ
+            m = h.multiply(q);
+            m = m.add(mQ);
+
+            return m;
+        }
+        else
+        {
+            return input.modPow(
+                        key.getExponent(), key.getModulus());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Basic cipher classes.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,42 @@
+package org.bouncycastle.crypto.generators;
+
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;
+import org.bouncycastle.crypto.KeyGenerationParameters;
+import org.bouncycastle.crypto.params.DHKeyGenerationParameters;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+
+import ewe.math.BigInteger;
+
+/**
+ * a basic Diffie-Hellman key pair generator.
+ *
+ * This generates keys consistent for use with the basic algorithm for
+ * Diffie-Hellman.
+ */
+public class DHBasicKeyPairGenerator
+    implements AsymmetricCipherKeyPairGenerator
+{
+    private DHKeyGenerationParameters param;
+
+    public void init(
+        KeyGenerationParameters param)
+    {
+        this.param = (DHKeyGenerationParameters)param;
+    }
+
+    public AsymmetricCipherKeyPair generateKeyPair()
+    {
+        DHKeyGeneratorHelper helper = DHKeyGeneratorHelper.INSTANCE;
+        DHParameters dhp = param.getParameters();
+
+        BigInteger x = helper.calculatePrivate(dhp, param.getRandom()); 
+        BigInteger y = helper.calculatePublic(dhp, x);
+
+        return new AsymmetricCipherKeyPair(
+            new DHPublicKeyParameters(y, dhp),
+            new DHPrivateKeyParameters(x, dhp));
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,51 @@
+package org.bouncycastle.crypto.generators;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.util.BigIntegers;
+
+class DHKeyGeneratorHelper
+{
+    static final DHKeyGeneratorHelper INSTANCE = new DHKeyGeneratorHelper();
+
+    private static final BigInteger ONE = BigInteger.valueOf(1);
+    private static final BigInteger TWO = BigInteger.valueOf(2);
+
+    private DHKeyGeneratorHelper()
+    {
+    }
+
+    BigInteger calculatePrivate(DHParameters dhParams, SecureRandom random)
+    {
+        BigInteger p = dhParams.getP();
+        int limit = dhParams.getL();
+
+        if (limit != 0)
+        {
+            return new BigInteger(limit, random).setBit(limit - 1);
+        }
+
+        BigInteger min = TWO;
+        int m = dhParams.getM();
+        if (m != 0)
+        {
+            min = ONE.shiftLeft(m - 1);
+        }
+
+        BigInteger max = p.subtract(TWO);
+        BigInteger q = dhParams.getQ();
+        if (q != null)
+        {
+            max = q.subtract(TWO);
+        }
+
+        return BigIntegers.createRandomInRange(min, max, random);
+    }
+
+    BigInteger calculatePublic(DHParameters dhParams, BigInteger x)
+    {
+        return dhParams.getG().modPow(x, dhParams.getP());
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,53 @@
+package org.bouncycastle.crypto.generators;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;
+import org.bouncycastle.crypto.KeyGenerationParameters;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECKeyGenerationParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.math.ec.ECPoint;
+
+public class ECKeyPairGenerator
+    implements AsymmetricCipherKeyPairGenerator, ECConstants
+{
+    ECDomainParameters  params;
+    SecureRandom        random;
+
+    public void init(
+        KeyGenerationParameters param)
+    {
+        ECKeyGenerationParameters  ecP = (ECKeyGenerationParameters)param;
+
+        this.random = ecP.getRandom();
+        this.params = ecP.getDomainParameters();
+    }
+
+    /**
+     * Given the domain parameters this routine generates an EC key
+     * pair in accordance with X9.62 section 5.2.1 pages 26, 27.
+     */
+    public AsymmetricCipherKeyPair generateKeyPair()
+    {
+        BigInteger n = params.getN();
+        int        nBitLength = n.bitLength();
+        BigInteger d;
+
+        do
+        {
+            d = new BigInteger(nBitLength, random);
+        }
+        while (d.equals(ZERO)  || (d.compareTo(n) >= 0));
+
+        ECPoint Q = params.getG().multiply(d);
+
+        return new AsymmetricCipherKeyPair(
+            new ECPublicKeyParameters(Q, params),
+            new ECPrivateKeyParameters(d, params));
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/generators/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Generators for keys, key pairs and password based encryption algorithms.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,52 @@
+package org.bouncycastle.crypto.io;
+
+import ewe.io.FilterInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.crypto.Signer;
+
+public class SignerInputStream
+    extends FilterInputStream
+{
+    protected Signer signer;
+
+    public SignerInputStream(
+        InputStream stream,
+        Signer      signer)
+    {
+        super(stream);
+        this.signer = signer;
+    }
+
+    public int read()
+        throws IOException
+    {
+        int b = in.read();
+
+        if (b >= 0)
+        {
+            signer.update((byte)b);
+        }
+        return b;
+    }
+
+    public int read(
+        byte[] b,
+        int off,
+        int len)
+        throws IOException
+    {
+        int n = in.read(b, off, len);
+        if (n > 0)
+        {
+            signer.update(b, off, n);
+        }
+        return n;
+    }
+
+    public Signer getSigner()
+    {
+        return signer;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/io/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/io/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/io/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Classes for doing "enhanced" I/O with Digests and MACs.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/macs/HMac.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/macs/HMac.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/macs/HMac.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/macs/HMac.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/macs/HMac.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,199 @@
+package org.bouncycastle.crypto.macs;
+
+import ewe.util.Hashtable;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.ExtendedDigest;
+import org.bouncycastle.crypto.Mac;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * HMAC implementation based on RFC2104
+ *
+ * H(K XOR opad, H(K XOR ipad, text))
+ */
+public class HMac
+    implements Mac
+{
+    private final static byte IPAD = (byte)0x36;
+    private final static byte OPAD = (byte)0x5C;
+
+    private Digest digest;
+    private int digestSize;
+    private int blockLength;
+    
+    private byte[] inputPad;
+    private byte[] outputPad;
+
+    private static Hashtable blockLengths;
+    
+    static
+    {
+        blockLengths = new Hashtable();
+        
+        blockLengths.put("GOST3411", new Integer(32));
+        
+        blockLengths.put("MD2", new Integer(16));
+        blockLengths.put("MD4", new Integer(64));
+        blockLengths.put("MD5", new Integer(64));
+        
+        blockLengths.put("RIPEMD128", new Integer(64));
+        blockLengths.put("RIPEMD160", new Integer(64));
+        
+        blockLengths.put("SHA-1", new Integer(64));
+        blockLengths.put("SHA-224", new Integer(64));
+        blockLengths.put("SHA-256", new Integer(64));
+        blockLengths.put("SHA-384", new Integer(128));
+        blockLengths.put("SHA-512", new Integer(128));
+        
+        blockLengths.put("Tiger", new Integer(64));
+        blockLengths.put("Whirlpool", new Integer(64));
+    }
+    
+    private static int getByteLength(
+        Digest digest)
+    {
+        if (digest instanceof ExtendedDigest)
+        {
+            return ((ExtendedDigest)digest).getByteLength();
+        }
+        
+        Integer  b = (Integer)blockLengths.get(digest.getAlgorithmName());
+        
+        if (b == null)
+        {       
+            throw new IllegalArgumentException("unknown digest passed: " + digest.getAlgorithmName());
+        }
+        
+        return b.intValue();
+    }
+    
+    /**
+     * Base constructor for one of the standard digest algorithms that the 
+     * byteLength of the algorithm is know for.
+     * 
+     * @param digest the digest.
+     */
+    public HMac(
+        Digest digest)
+    {
+        this(digest, getByteLength(digest));
+    }
+
+    private HMac(
+        Digest digest,
+        int    byteLength)
+    {
+        this.digest = digest;
+        digestSize = digest.getDigestSize();
+
+        this.blockLength = byteLength;
+
+        inputPad = new byte[blockLength];
+        outputPad = new byte[blockLength];
+    }
+    
+    public String getAlgorithmName()
+    {
+        return digest.getAlgorithmName() + "/HMAC";
+    }
+
+    public Digest getUnderlyingDigest()
+    {
+        return digest;
+    }
+
+    public void init(
+        CipherParameters params)
+    {
+        digest.reset();
+
+        byte[] key = ((KeyParameter)params).getKey();
+
+        if (key.length > blockLength)
+        {
+            digest.update(key, 0, key.length);
+            digest.doFinal(inputPad, 0);
+            for (int i = digestSize; i < inputPad.length; i++)
+            {
+                inputPad[i] = 0;
+            }
+        }
+        else
+        {
+            System.arraycopy(key, 0, inputPad, 0, key.length);
+            for (int i = key.length; i < inputPad.length; i++)
+            {
+                inputPad[i] = 0;
+            }
+        }
+
+        outputPad = new byte[inputPad.length];
+        System.arraycopy(inputPad, 0, outputPad, 0, inputPad.length);
+
+        for (int i = 0; i < inputPad.length; i++)
+        {
+            inputPad[i] ^= IPAD;
+        }
+
+        for (int i = 0; i < outputPad.length; i++)
+        {
+            outputPad[i] ^= OPAD;
+        }
+
+        digest.update(inputPad, 0, inputPad.length);
+    }
+
+    public int getMacSize()
+    {
+        return digestSize;
+    }
+
+    public void update(
+        byte in)
+    {
+        digest.update(in);
+    }
+
+    public void update(
+        byte[] in,
+        int inOff,
+        int len)
+    {
+        digest.update(in, inOff, len);
+    }
+
+    public int doFinal(
+        byte[] out,
+        int outOff)
+    {
+        byte[] tmp = new byte[digestSize];
+        digest.doFinal(tmp, 0);
+
+        digest.update(outputPad, 0, outputPad.length);
+        digest.update(tmp, 0, tmp.length);
+
+        int     len = digest.doFinal(out, outOff);
+
+        reset();
+
+        return len;
+    }
+
+    /**
+     * Reset the mac generator.
+     */
+    public void reset()
+    {
+        /*
+         * reset the underlying digest.
+         */
+        digest.reset();
+
+        /*
+         * reinitialize the digest.
+         */
+        digest.update(inputPad, 0, inputPad.length);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/macs/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/macs/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/macs/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Classes for creating MACs and HMACs.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,235 @@
+package org.bouncycastle.crypto.modes;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.ParametersWithIV;
+import org.bouncycastle.util.Arrays;
+
+/**
+ * implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
+ */
+public class CBCBlockCipher
+    implements BlockCipher
+{
+    private byte[]          IV;
+    private byte[]          cbcV;
+    private byte[]          cbcNextV;
+
+    private int             blockSize;
+    private BlockCipher     cipher = null;
+    private boolean         encrypting;
+
+    /**
+     * Basic constructor.
+     *
+     * @param cipher the block cipher to be used as the basis of chaining.
+     */
+    public CBCBlockCipher(
+        BlockCipher cipher)
+    {
+        this.cipher = cipher;
+        this.blockSize = cipher.getBlockSize();
+
+        this.IV = new byte[blockSize];
+        this.cbcV = new byte[blockSize];
+        this.cbcNextV = new byte[blockSize];
+    }
+
+    /**
+     * return the underlying block cipher that we are wrapping.
+     *
+     * @return the underlying block cipher that we are wrapping.
+     */
+    public BlockCipher getUnderlyingCipher()
+    {
+        return cipher;
+    }
+
+    /**
+     * Initialise the cipher and, possibly, the initialisation vector (IV).
+     * If an IV isn't passed as part of the parameter, the IV will be all zeros.
+     *
+     * @param encrypting if true the cipher is initialised for
+     *  encryption, if false for decryption.
+     * @param params the key and other data required by the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean             encrypting,
+        CipherParameters    params)
+        throws IllegalArgumentException
+    {
+        this.encrypting = encrypting;
+        
+        if (params instanceof ParametersWithIV)
+        {
+                ParametersWithIV ivParam = (ParametersWithIV)params;
+                byte[]      iv = ivParam.getIV();
+
+                if (iv.length != blockSize)
+                {
+                    throw new IllegalArgumentException("initialisation vector must be the same length as block size");
+                }
+
+                System.arraycopy(iv, 0, IV, 0, iv.length);
+
+                reset();
+
+                cipher.init(encrypting, ivParam.getParameters());
+        }
+        else
+        {
+                reset();
+
+                cipher.init(encrypting, params);
+        }
+    }
+
+    /**
+     * return the algorithm name and mode.
+     *
+     * @return the name of the underlying algorithm followed by "/CBC".
+     */
+    public String getAlgorithmName()
+    {
+        return cipher.getAlgorithmName() + "/CBC";
+    }
+
+    /**
+     * return the block size of the underlying cipher.
+     *
+     * @return the block size of the underlying cipher.
+     */
+    public int getBlockSize()
+    {
+        return cipher.getBlockSize();
+    }
+
+    /**
+     * Process one block of input from the array in and write it to
+     * the out array.
+     *
+     * @param in the array containing the input data.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the output data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    public int processBlock(
+        byte[]      in,
+        int         inOff,
+        byte[]      out,
+        int         outOff)
+        throws DataLengthException, IllegalStateException
+    {
+        return (encrypting) ? encryptBlock(in, inOff, out, outOff) : decryptBlock(in, inOff, out, outOff);
+    }
+
+    /**
+     * reset the chaining vector back to the IV and reset the underlying
+     * cipher.
+     */
+    public void reset()
+    {
+        System.arraycopy(IV, 0, cbcV, 0, IV.length);
+        Arrays.fill(cbcNextV, (byte)0);
+
+        cipher.reset();
+    }
+
+    /**
+     * Do the appropriate chaining step for CBC mode encryption.
+     *
+     * @param in the array containing the data to be encrypted.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the encrypted data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    private int encryptBlock(
+        byte[]      in,
+        int         inOff,
+        byte[]      out,
+        int         outOff)
+        throws DataLengthException, IllegalStateException
+    {
+        if ((inOff + blockSize) > in.length)
+        {
+            throw new DataLengthException("input buffer too short");
+        }
+
+        /*
+         * XOR the cbcV and the input,
+         * then encrypt the cbcV
+         */
+        for (int i = 0; i < blockSize; i++)
+        {
+            cbcV[i] ^= in[inOff + i];
+        }
+
+        int length = cipher.processBlock(cbcV, 0, out, outOff);
+
+        /*
+         * copy ciphertext to cbcV
+         */
+        System.arraycopy(out, outOff, cbcV, 0, cbcV.length);
+
+        return length;
+    }
+
+    /**
+     * Do the appropriate chaining step for CBC mode decryption.
+     *
+     * @param in the array containing the data to be decrypted.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the decrypted data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    private int decryptBlock(
+        byte[]      in,
+        int         inOff,
+        byte[]      out,
+        int         outOff)
+        throws DataLengthException, IllegalStateException
+    {
+        if ((inOff + blockSize) > in.length)
+        {
+            throw new DataLengthException("input buffer too short");
+        }
+
+        System.arraycopy(in, inOff, cbcNextV, 0, blockSize);
+
+        int length = cipher.processBlock(in, inOff, out, outOff);
+
+        /*
+         * XOR the cbcV and the output
+         */
+        for (int i = 0; i < blockSize; i++)
+        {
+            out[outOff + i] ^= cbcV[i];
+        }
+
+        /*
+         * swap the back up buffer into next position
+         */
+        byte[]  tmp;
+
+        tmp = cbcV;
+        cbcV = cbcNextV;
+        cbcNextV = tmp;
+
+        return length;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/modes/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/modes/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/modes/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Modes for symmetric ciphers.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Base classes for the lightweight API.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,20 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class AsymmetricKeyParameter
+    implements CipherParameters
+{
+    boolean privateKey;
+
+    public AsymmetricKeyParameter(
+        boolean privateKey)
+    {
+        this.privateKey = privateKey;
+    }
+
+    public boolean isPrivate()
+    {
+        return privateKey;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.KeyGenerationParameters;
+
+public class DHKeyGenerationParameters
+    extends KeyGenerationParameters
+{
+    private DHParameters    params;
+
+    public DHKeyGenerationParameters(
+        SecureRandom    random,
+        DHParameters    params)
+    {
+        super(random, getStrength(params));
+
+        this.params = params;
+    }
+
+    public DHParameters getParameters()
+    {
+        return params;
+    }
+
+    static int getStrength(DHParameters params)
+    {
+        return params.getL() != 0 ? params.getL() : params.getP().bitLength();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,54 @@
+package org.bouncycastle.crypto.params;
+
+
+public class DHKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private DHParameters    params;
+
+    protected DHKeyParameters(
+        boolean         isPrivate,
+        DHParameters    params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }   
+
+    public DHParameters getParameters()
+    {
+        return params;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHKeyParameters))
+        {
+            return false;
+        }
+
+        DHKeyParameters    dhKey = (DHKeyParameters)obj;
+
+        if (params == null)
+        {
+            return dhKey.getParameters() == null;
+        }
+        else
+        { 
+            return params.equals(dhKey.getParameters());
+        }
+    }
+    
+    public int hashCode()
+    {
+        int code = isPrivate() ? 0 : 1;
+        
+        if (params != null)
+        {
+            code ^= params.hashCode();
+        }
+        
+        return code;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,188 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+import ewe.math.BigInteger;
+
+public class DHParameters
+    implements CipherParameters
+{
+    private static final int DEFAULT_MINIMUM_LENGTH = 160;
+
+    // not final due to compiler bug in "simpler" JDKs
+    private BigInteger              g;
+    private BigInteger              p;
+    private BigInteger              q;
+    private BigInteger              j;
+    private int                     m;
+    private int                     l;
+    private DHValidationParameters  validation;
+
+    private static int getDefaultMParam(
+        int lParam)
+    {
+        if (lParam == 0)
+        {
+            return DEFAULT_MINIMUM_LENGTH;
+        }
+
+        return lParam < DEFAULT_MINIMUM_LENGTH ? lParam : DEFAULT_MINIMUM_LENGTH;
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g)
+    {
+        this(p, g, null, 0);
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g,
+        BigInteger  q)
+    {
+        this(p, g, q, 0);
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g,
+        BigInteger  q,
+        int         l)
+    {
+        this(p, g, q, getDefaultMParam(l), l, null, null);
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g,
+        BigInteger  q,
+        int         m,
+        int         l)
+    {
+        this(p, g, q, m, l, null, null);
+    }
+
+    public DHParameters(
+        BigInteger              p,
+        BigInteger              g,
+        BigInteger              q,
+        BigInteger              j,
+        DHValidationParameters  validation)
+    {
+        this(p, g, q, DEFAULT_MINIMUM_LENGTH, 0, j, validation);
+    }
+
+    public DHParameters(
+        BigInteger              p,
+        BigInteger              g,
+        BigInteger              q,
+        int                     m,
+        int                     l,
+        BigInteger              j,
+        DHValidationParameters  validation)
+    {
+        if (l != 0)
+        {
+            if (l >= p.bitLength())
+            {
+                throw new IllegalArgumentException("when l value specified, it must be less than bitlength(p)");
+            }
+            if (l < m)
+            {
+                throw new IllegalArgumentException("when l value specified, it may not be less than m value");
+            }
+        }
+
+        this.g = g;
+        this.p = p;
+        this.q = q;
+        this.m = m;
+        this.l = l;
+        this.j = j;
+        this.validation = validation;
+    }
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    public BigInteger getG()
+    {
+        return g;
+    }
+
+    public BigInteger getQ()
+    {
+        return q;
+    }
+
+    /**
+     * Return the subgroup factor J.
+     *
+     * @return subgroup factor
+     */
+    public BigInteger getJ()
+    {
+        return j;
+    }
+
+    /**
+     * Return the minimum length of the private value.
+     *
+     * @return the minimum length of the private value in bits.
+     */
+    public int getM()
+    {
+        return m;
+    }
+
+    /**
+     * Return the private value length in bits - if set, zero otherwise
+     *
+     * @return the private value length in bits, zero otherwise.
+     */
+    public int getL()
+    {
+        return l;
+    }
+
+    public DHValidationParameters getValidationParameters()
+    {
+        return validation;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHParameters))
+        {
+            return false;
+        }
+
+        DHParameters    pm = (DHParameters)obj;
+
+        if (this.getQ() != null)
+        {
+            if (!this.getQ().equals(pm.getQ()))
+            {
+                return false;
+            }
+        }
+        else
+        {
+            if (pm.getQ() != null)
+            {
+                return false;
+            }
+        }
+
+        return pm.getP().equals(p) && pm.getG().equals(g);
+    }
+    
+    public int hashCode()
+    {
+        return getP().hashCode() ^ getG().hashCode() ^ (getQ() != null ? getQ().hashCode() : 0);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DHPrivateKeyParameters
+    extends DHKeyParameters
+{
+    private BigInteger      x;
+
+    public DHPrivateKeyParameters(
+        BigInteger      x,
+        DHParameters    params)
+    {
+        super(true, params);
+
+        this.x = x;
+    }   
+
+    public BigInteger getX()
+    {
+        return x;
+    }
+
+    public int hashCode()
+    {
+        return x.hashCode() ^ super.hashCode();
+    }
+    
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHPrivateKeyParameters))
+        {
+            return false;
+        }
+
+        DHPrivateKeyParameters  other = (DHPrivateKeyParameters)obj;
+
+        return other.getX().equals(this.x) && super.equals(obj);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DHPublicKeyParameters
+    extends DHKeyParameters
+{
+    private BigInteger      y;
+
+    public DHPublicKeyParameters(
+        BigInteger      y,
+        DHParameters    params)
+    {
+        super(false, params);
+
+        this.y = y;
+    }   
+
+    public BigInteger getY()
+    {
+        return y;
+    }
+
+    public int hashCode()
+    {
+        return y.hashCode() ^ super.hashCode();
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHPublicKeyParameters))
+        {
+            return false;
+        }
+
+        DHPublicKeyParameters   other = (DHPublicKeyParameters)obj;
+
+        return other.getY().equals(y) && super.equals(obj);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,50 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.util.Arrays;
+
+public class DHValidationParameters
+{
+    private byte[]  seed;
+    private int     counter;
+
+    public DHValidationParameters(
+        byte[]  seed,
+        int     counter)
+    {
+        this.seed = seed;
+        this.counter = counter;
+    }
+
+    public int getCounter()
+    {
+        return counter;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+
+    public boolean equals(
+        Object o)
+    {
+        if (!(o instanceof DHValidationParameters))
+        {
+            return false;
+        }
+
+        DHValidationParameters  other = (DHValidationParameters)o;
+
+        if (other.counter != this.counter)
+        {
+            return false;
+        }
+
+        return Arrays.areEqual(this.seed, other.seed);
+    }
+
+    public int hashCode()
+    {
+        return counter ^ Arrays.hashCode(seed);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,21 @@
+package org.bouncycastle.crypto.params;
+
+public class DSAKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private DSAParameters    params;
+
+    public DSAKeyParameters(
+        boolean         isPrivate,
+        DSAParameters   params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }   
+
+    public DSAParameters getParameters()
+    {
+        return params;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,74 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class DSAParameters
+    implements CipherParameters
+{
+    private BigInteger              g;
+    private BigInteger              q;
+    private BigInteger              p;
+    private DSAValidationParameters validation;
+
+    public DSAParameters(
+        BigInteger  p,
+        BigInteger  q,
+        BigInteger  g)
+    {
+        this.g = g;
+        this.p = p;
+        this.q = q;
+    }   
+
+    public DSAParameters(
+        BigInteger              p,
+        BigInteger              q,
+        BigInteger              g,
+        DSAValidationParameters params)
+    {
+        this.g = g;
+        this.p = p;
+        this.q = q;
+        this.validation = params;
+    }   
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    public BigInteger getQ()
+    {
+        return q;
+    }
+
+    public BigInteger getG()
+    {
+        return g;
+    }
+
+    public DSAValidationParameters getValidationParameters()
+    {
+        return validation;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DSAParameters))
+        {
+            return false;
+        }
+
+        DSAParameters    pm = (DSAParameters)obj;
+
+        return (pm.getP().equals(p) && pm.getQ().equals(q) && pm.getG().equals(g));
+    }
+    
+    public int hashCode()
+    {
+        return getP().hashCode() ^ getQ().hashCode() ^ getG().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DSAPrivateKeyParameters
+    extends DSAKeyParameters
+{
+    private BigInteger      x;
+
+    public DSAPrivateKeyParameters(
+        BigInteger      x,
+        DSAParameters   params)
+    {
+        super(true, params);
+
+        this.x = x;
+    }   
+
+    public BigInteger getX()
+    {
+        return x;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DSAPublicKeyParameters
+    extends DSAKeyParameters
+{
+    private BigInteger      y;
+
+    public DSAPublicKeyParameters(
+        BigInteger      y,
+        DSAParameters   params)
+    {
+        super(false, params);
+
+        this.y = y;
+    }   
+
+    public BigInteger getY()
+    {
+        return y;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,50 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.util.Arrays;
+
+public class DSAValidationParameters
+{
+    private byte[]  seed;
+    private int     counter;
+
+    public DSAValidationParameters(
+        byte[]  seed,
+        int     counter)
+    {
+        this.seed = seed;
+        this.counter = counter;
+    }
+
+    public int getCounter()
+    {
+        return counter;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+
+    public int hashCode()
+    {
+        return counter ^ Arrays.hashCode(seed);
+    }
+    
+    public boolean equals(
+        Object o)
+    {
+        if (!(o instanceof DSAValidationParameters))
+        {
+            return false;
+        }
+
+        DSAValidationParameters  other = (DSAValidationParameters)o;
+
+        if (other.counter != this.counter)
+        {
+            return false;
+        }
+
+        return Arrays.areEqual(this.seed, other.seed);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,81 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+
+public class ECDomainParameters
+    implements ECConstants
+{
+    ECCurve     curve;
+    byte[]      seed;
+    ECPoint     G;
+    BigInteger  n;
+    BigInteger  h;
+
+    public ECDomainParameters(
+        ECCurve     curve,
+        ECPoint     G,
+        BigInteger  n)
+    {
+        this.curve = curve;
+        this.G = G;
+        this.n = n;
+        this.h = ONE;
+        this.seed = null;
+    }
+
+    public ECDomainParameters(
+        ECCurve     curve,
+        ECPoint     G,
+        BigInteger  n,
+        BigInteger  h)
+    {
+        this.curve = curve;
+        this.G = G;
+        this.n = n;
+        this.h = h;
+        this.seed = null;
+    }
+
+    public ECDomainParameters(
+        ECCurve     curve,
+        ECPoint     G,
+        BigInteger  n,
+        BigInteger  h,
+        byte[]      seed)
+    {
+        this.curve = curve;
+        this.G = G;
+        this.n = n;
+        this.h = h;
+        this.seed = seed;
+    }
+
+    public ECCurve getCurve()
+    {
+        return curve;
+    }
+
+    public ECPoint getG()
+    {
+        return G;
+    }
+
+    public BigInteger getN()
+    {
+        return n;
+    }
+
+    public BigInteger getH()
+    {
+        return h;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.KeyGenerationParameters;
+
+public class ECKeyGenerationParameters
+    extends KeyGenerationParameters
+{
+    private ECDomainParameters  domainParams;
+
+    public ECKeyGenerationParameters(
+        ECDomainParameters      domainParams,
+        SecureRandom            random)
+    {
+        super(random, domainParams.getN().bitLength());
+
+        this.domainParams = domainParams;
+    }
+
+    public ECDomainParameters getDomainParameters()
+    {
+        return domainParams;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,21 @@
+package org.bouncycastle.crypto.params;
+
+public class ECKeyParameters
+    extends AsymmetricKeyParameter
+{
+    ECDomainParameters params;
+
+    protected ECKeyParameters(
+        boolean             isPrivate,
+        ECDomainParameters  params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }
+
+    public ECDomainParameters getParameters()
+    {
+        return params;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class ECPrivateKeyParameters
+    extends ECKeyParameters
+{
+    BigInteger d;
+
+    public ECPrivateKeyParameters(
+        BigInteger          d,
+        ECDomainParameters  params)
+    {
+        super(true, params);
+        this.d = d;
+    }
+
+    public BigInteger getD()
+    {
+        return d;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.math.ec.ECPoint;
+
+public class ECPublicKeyParameters
+    extends ECKeyParameters
+{
+    ECPoint Q;
+
+    public ECPublicKeyParameters(
+        ECPoint             Q,
+        ECDomainParameters  params)
+    {
+        super(false, params);
+        this.Q = Q;
+    }
+
+    public ECPoint getQ()
+    {
+        return Q;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,47 @@
+package org.bouncycastle.crypto.params;
+
+
+public class ElGamalKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private ElGamalParameters    params;
+
+    protected ElGamalKeyParameters(
+        boolean         isPrivate,
+        ElGamalParameters    params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }   
+
+    public ElGamalParameters getParameters()
+    {
+        return params;
+    }
+
+    public int hashCode()
+    {
+        return (params != null) ? params.hashCode() : 0;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof ElGamalKeyParameters))
+        {
+            return false;
+        }
+
+        ElGamalKeyParameters    dhKey = (ElGamalKeyParameters)obj;
+
+        if (params == null)
+        {
+            return dhKey.getParameters() == null;
+        }
+        else
+        { 
+            return params.equals(dhKey.getParameters());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,69 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class ElGamalParameters
+    implements CipherParameters
+{
+    private BigInteger              g;
+    private BigInteger              p;
+    private int                     l;
+
+    public ElGamalParameters(
+        BigInteger  p,
+        BigInteger  g)
+    {
+        this(p, g, 0);
+    }
+
+    public ElGamalParameters(
+        BigInteger  p,
+        BigInteger  g,
+        int         l)
+    {
+        this.g = g;
+        this.p = p;
+        this.l = l;
+    }
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    /**
+     * return the generator - g
+     */
+    public BigInteger getG()
+    {
+        return g;
+    }
+
+    /**
+     * return private value limit - l
+     */
+    public int getL()
+    {
+        return l;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof ElGamalParameters))
+        {
+            return false;
+        }
+
+        ElGamalParameters    pm = (ElGamalParameters)obj;
+
+        return pm.getP().equals(p) && pm.getG().equals(g) && pm.getL() == l;
+    }
+    
+    public int hashCode()
+    {
+        return (getP().hashCode() ^ getG().hashCode()) + l;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class ElGamalPublicKeyParameters
+    extends ElGamalKeyParameters
+{
+    private BigInteger      y;
+
+    public ElGamalPublicKeyParameters(
+        BigInteger      y,
+        ElGamalParameters    params)
+    {
+        super(false, params);
+
+        this.y = y;
+    }   
+
+    public BigInteger getY()
+    {
+        return y;
+    }
+
+    public int hashCode()
+    {
+        return y.hashCode() ^ super.hashCode();
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof ElGamalPublicKeyParameters))
+        {
+            return false;
+        }
+
+        ElGamalPublicKeyParameters   other = (ElGamalPublicKeyParameters)obj;
+
+        return other.getY().equals(y) && super.equals(obj);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/KeyParameter.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/KeyParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/KeyParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class KeyParameter
+    implements CipherParameters
+{
+    private byte[]  key;
+
+    public KeyParameter(
+        byte[]  key)
+    {
+        this(key, 0, key.length);
+    }
+
+    public KeyParameter(
+        byte[]  key,
+        int     keyOff,
+        int     keyLen)
+    {
+        this.key = new byte[keyLen];
+
+        System.arraycopy(key, keyOff, this.key, 0, keyLen);
+    }
+
+    public byte[] getKey()
+    {
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class ParametersWithIV
+    implements CipherParameters
+{
+    private byte[]              iv;
+    private CipherParameters    parameters;
+
+    public ParametersWithIV(
+        CipherParameters    parameters,
+        byte[]              iv)
+    {
+        this(parameters, iv, 0, iv.length);
+    }
+
+    public ParametersWithIV(
+        CipherParameters    parameters,
+        byte[]              iv,
+        int                 ivOff,
+        int                 ivLen)
+    {
+        this.iv = new byte[ivLen];
+        this.parameters = parameters;
+
+        System.arraycopy(iv, ivOff, this.iv, 0, ivLen);
+    }
+
+    public byte[] getIV()
+    {
+        return iv;
+    }
+
+    public CipherParameters getParameters()
+    {
+        return parameters;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+import ewe.security.SecureRandom;
+
+public class ParametersWithRandom
+    implements CipherParameters
+{
+    private SecureRandom        random;
+    private CipherParameters    parameters;
+
+    public ParametersWithRandom(
+        CipherParameters    parameters,
+        SecureRandom        random)
+    {
+        this.random = random;
+        this.parameters = parameters;
+    }
+
+    public ParametersWithRandom(
+        CipherParameters    parameters)
+    {
+        this(parameters, new SecureRandom());
+    }
+
+    public SecureRandom getRandom()
+    {
+        return random;
+    }
+
+    public CipherParameters getParameters()
+    {
+        return parameters;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,31 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class RSAKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private BigInteger      modulus;
+    private BigInteger      exponent;
+
+    public RSAKeyParameters(
+        boolean     isPrivate,
+        BigInteger  modulus,
+        BigInteger  exponent)
+    {
+        super(isPrivate);
+
+        this.modulus = modulus;
+        this.exponent = exponent;
+    }   
+
+    public BigInteger getModulus()
+    {
+        return modulus;
+    }
+
+    public BigInteger getExponent()
+    {
+        return exponent;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,67 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class RSAPrivateCrtKeyParameters
+    extends RSAKeyParameters
+{
+    private BigInteger  e;
+    private BigInteger  p;
+    private BigInteger  q;
+    private BigInteger  dP;
+    private BigInteger  dQ;
+    private BigInteger  qInv;
+
+    /**
+     * 
+     */
+    public RSAPrivateCrtKeyParameters(
+        BigInteger  modulus,
+        BigInteger  publicExponent,
+        BigInteger  privateExponent,
+        BigInteger  p,
+        BigInteger  q,
+        BigInteger  dP,
+        BigInteger  dQ,
+        BigInteger  qInv)
+    {
+        super(true, modulus, privateExponent);
+
+        this.e = publicExponent;
+        this.p = p;
+        this.q = q;
+        this.dP = dP;
+        this.dQ = dQ;
+        this.qInv = qInv;
+    }
+
+    public BigInteger getPublicExponent()
+    {
+        return e;
+    }
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    public BigInteger getQ()
+    {
+        return q;
+    }
+
+    public BigInteger getDP()
+    {
+        return dP;
+    }
+
+    public BigInteger getDQ()
+    {
+        return dQ;
+    }
+
+    public BigInteger getQInv()
+    {
+        return qInv;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Classes for parameter objects for ciphers and generators.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,100 @@
+package org.bouncycastle.crypto.prng;
+
+/**
+ * A thread based seed generator - one source of randomness.
+ * <p>
+ * Based on an idea from Marcus Lippert.
+ * </p>
+ */
+public class ThreadedSeedGenerator
+{
+    static ewe.security.SecureRandom rs = null;
+    private class SeedGenerator
+        /* implements Runnable */
+    {
+        /* private volatile int counter = 0;
+         private volatile boolean stop = false;
+
+        public void run()
+        {
+            while (!this.stop)
+            {
+                this.counter++;
+            }
+
+        }
+       */
+        public byte[] generateSeed(
+            int numbytes,
+            boolean fast)
+        {
+            // Thread t = new Thread(this);
+            byte[] result = new byte[numbytes];
+            if (rs == null) rs = new ewe.security.SecureRandom();
+            rs.nextBytes(result);
+
+           /* this.counter = 0;
+            this.stop = false;
+            int last = 0;
+            int end;
+
+            t.start();
+            if(fast)
+            {
+                end = numbytes;
+            }
+            else
+            {
+                end = numbytes * 8;
+            }
+            for (int i = 0; i < end; i++)
+            {
+                while (this.counter == last)
+                {
+                    try
+                    {
+                        Thread.sleep(1);
+                    }
+                    catch (InterruptedException e)
+                    {
+                        // ignore
+                    }
+                }
+                last = this.counter;
+                if (fast)
+                {
+                    result[i] = (byte) (last & 0xff);
+                }
+                else
+                {
+                    int bytepos = i/8;
+                    result[bytepos] = (byte) ((result[bytepos] << 1) | (last & 1));
+                }
+
+            }
+            stop = true;
+            */
+            return result;
+        }
+    }
+
+    /**
+     * Generate seed bytes. Set fast to false for best quality.
+     * <p>
+     * If fast is set to true, the code should be round about 8 times faster when
+     * generating a long sequence of random bytes. 20 bytes of random values using
+     * the fast mode take less than half a second on a Nokia e70. If fast is set to false,
+     * it takes round about 2500 ms.
+     * </p>
+     * @param numBytes the number of bytes to generate
+     * @param fast true if fast mode should be used
+     */
+    public byte[] generateSeed(
+        int numBytes,
+        boolean fast)
+    {
+        SeedGenerator gen = new SeedGenerator();
+
+        return gen.generateSeed(numBytes, fast);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/prng/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/prng/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/prng/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Lightweight psuedo-random number generators.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,154 @@
+package org.bouncycastle.crypto.signers;
+
+import ewe.io.IOException;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+public class DSADigestSigner
+    implements Signer
+{
+    private final Digest digest;
+    private final DSA dsaSigner;
+    private boolean forSigning;
+
+    public DSADigestSigner(
+        DSA    signer,
+        Digest digest)
+    {
+        this.digest = digest;
+        this.dsaSigner = signer;
+    }
+
+    public void init(
+        boolean           forSigning,
+        CipherParameters   parameters)
+    {
+        this.forSigning = forSigning;
+
+        AsymmetricKeyParameter k;
+
+        if (parameters instanceof ParametersWithRandom)
+        {
+            k = (AsymmetricKeyParameter)((ParametersWithRandom)parameters).getParameters();
+        }
+        else
+        {
+            k = (AsymmetricKeyParameter)parameters;
+        }
+
+        if (forSigning && !k.isPrivate())
+        {
+            throw new IllegalArgumentException("Signing Requires Private Key.");
+        }
+
+        if (!forSigning && k.isPrivate())
+        {
+            throw new IllegalArgumentException("Verification Requires Public Key.");
+        }
+
+        reset();
+
+        dsaSigner.init(forSigning, parameters);
+    }
+
+    /**
+     * update the internal digest with the byte b
+     */
+    public void update(
+        byte input)
+    {
+        digest.update(input);
+    }
+
+    /**
+     * update the internal digest with the byte array in
+     */
+    public void update(
+        byte[]  input,
+        int     inOff,
+        int     length)
+    {
+        digest.update(input, inOff, length);
+    }
+
+    /**
+     * Generate a signature for the message we've been loaded with using
+     * the key we were initialised with.
+     */
+    public byte[] generateSignature()
+    {
+        if (!forSigning)
+        {
+            throw new IllegalStateException("DSADigestSigner not initialised for signature generation.");
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        BigInteger[] sig = dsaSigner.generateSignature(hash);
+
+        return derEncode(sig[0], sig[1]);
+    }
+
+    public boolean verifySignature(
+        byte[] signature)
+    {
+        if (forSigning)
+        {
+            throw new IllegalStateException("DSADigestSigner not initialised for verification");
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        try
+        {
+            BigInteger[] sig = derDecode(signature);
+            return dsaSigner.verifySignature(hash, sig[0], sig[1]);
+        }
+        catch (IOException e)
+        {
+            return false;
+        }
+    }
+
+    public void reset()
+    {
+        digest.reset();
+    }
+
+    private byte[] derEncode(
+        BigInteger  r,
+        BigInteger  s)
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        v.add(new DERInteger(r));
+        v.add(new DERInteger(s));
+
+        return new DERSequence(v).getDEREncoded();
+    }
+
+    private BigInteger[] derDecode(
+        byte[] encoding)
+        throws IOException
+    {
+        ASN1Sequence s = (ASN1Sequence)ASN1Object.fromByteArray(encoding);
+
+        return new BigInteger[]
+        {
+            ((DERInteger)s.getObjectAt(0)).getValue(),
+            ((DERInteger)s.getObjectAt(1)).getValue()
+        };
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/DSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/DSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/DSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,138 @@
+package org.bouncycastle.crypto.signers;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.DSAKeyParameters;
+import org.bouncycastle.crypto.params.DSAParameters;
+import org.bouncycastle.crypto.params.DSAPrivateKeyParameters;
+import org.bouncycastle.crypto.params.DSAPublicKeyParameters;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+/**
+ * The Digital Signature Algorithm - as described in "Handbook of Applied
+ * Cryptography", pages 452 - 453.
+ */
+public class DSASigner
+    implements DSA
+{
+    DSAKeyParameters key;
+
+    SecureRandom    random;
+
+    public void init(
+        boolean                 forSigning,
+        CipherParameters        param)
+    {
+        if (forSigning)
+        {
+            if (param instanceof ParametersWithRandom)
+            {
+                ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+                this.random = rParam.getRandom();
+                this.key = (DSAPrivateKeyParameters)rParam.getParameters();
+            }
+            else
+            {
+                this.random = new SecureRandom();
+                this.key = (DSAPrivateKeyParameters)param;
+            }
+        }
+        else
+        {
+            this.key = (DSAPublicKeyParameters)param;
+        }
+    }
+
+    /**
+     * generate a signature for the given message using the key we were
+     * initialised with. For conventional DSA the message should be a SHA-1
+     * hash of the message of interest.
+     *
+     * @param message the message that will be verified later.
+     */
+    public BigInteger[] generateSignature(
+        byte[] message)
+    {
+        DSAParameters   params = key.getParameters();
+        BigInteger      m = calculateE(params.getQ(), message);
+        BigInteger      k;
+        int                  qBitLength = params.getQ().bitLength();
+
+        do 
+        {
+            k = new BigInteger(qBitLength, random);
+        }
+        while (k.compareTo(params.getQ()) >= 0);
+
+        BigInteger  r = params.getG().modPow(k, params.getP()).mod(params.getQ());
+
+        k = k.modInverse(params.getQ()).multiply(
+                    m.add(((DSAPrivateKeyParameters)key).getX().multiply(r)));
+
+        BigInteger  s = k.mod(params.getQ());
+
+        BigInteger[]  res = new BigInteger[2];
+
+        res[0] = r;
+        res[1] = s;
+
+        return res;
+    }
+
+    /**
+     * return true if the value r and s represent a DSA signature for
+     * the passed in message for standard DSA the message should be a
+     * SHA-1 hash of the real message to be verified.
+     */
+    public boolean verifySignature(
+        byte[]      message,
+        BigInteger  r,
+        BigInteger  s)
+    {
+        DSAParameters   params = key.getParameters();
+        BigInteger      m = calculateE(params.getQ(), message);
+        BigInteger      zero = BigInteger.valueOf(0);
+
+        if (zero.compareTo(r) >= 0 || params.getQ().compareTo(r) <= 0)
+        {
+            return false;
+        }
+
+        if (zero.compareTo(s) >= 0 || params.getQ().compareTo(s) <= 0)
+        {
+            return false;
+        }
+
+        BigInteger  w = s.modInverse(params.getQ());
+
+        BigInteger  u1 = m.multiply(w).mod(params.getQ());
+        BigInteger  u2 = r.multiply(w).mod(params.getQ());
+
+        u1 = params.getG().modPow(u1, params.getP());
+        u2 = ((DSAPublicKeyParameters)key).getY().modPow(u2, params.getP());
+
+        BigInteger  v = u1.multiply(u2).mod(params.getP()).mod(params.getQ());
+
+        return v.equals(r);
+    }
+
+    private BigInteger calculateE(BigInteger n, byte[] message)
+    {
+        if (n.bitLength() >= message.length * 8)
+        {
+            return new BigInteger(1, message);
+        }
+        else
+        {
+            byte[] trunc = new byte[n.bitLength() / 8];
+
+            System.arraycopy(message, 0, trunc, 0, trunc.length);
+
+            return new BigInteger(1, trunc);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,164 @@
+package org.bouncycastle.crypto.signers;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.ECKeyParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.math.ec.ECAlgorithms;
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.math.ec.ECPoint;
+
+/**
+ * EC-DSA as described in X9.62
+ */
+public class ECDSASigner
+    implements ECConstants, DSA
+{
+    ECKeyParameters key;
+
+    SecureRandom    random;
+
+    public void init(
+        boolean                 forSigning,
+        CipherParameters        param)
+    {
+        if (forSigning)
+        {
+            if (param instanceof ParametersWithRandom)
+            {
+                ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+                this.random = rParam.getRandom();
+                this.key = (ECPrivateKeyParameters)rParam.getParameters();
+            }
+            else
+            {
+                this.random = new SecureRandom();
+                this.key = (ECPrivateKeyParameters)param;
+            }
+        }
+        else
+        {
+            this.key = (ECPublicKeyParameters)param;
+        }
+    }
+
+    // 5.3 pg 28
+    /**
+     * generate a signature for the given message using the key we were
+     * initialised with. For conventional DSA the message should be a SHA-1
+     * hash of the message of interest.
+     *
+     * @param message the message that will be verified later.
+     */
+    public BigInteger[] generateSignature(
+        byte[] message)
+    {
+        BigInteger n = key.getParameters().getN();
+        BigInteger e = calculateE(n, message);
+        BigInteger r = null;
+        BigInteger s = null;
+
+        // 5.3.2
+        do // generate s
+        {
+            BigInteger k = null;
+            int        nBitLength = n.bitLength();
+
+            do // generate r
+            {
+                do
+                {
+                    k = new BigInteger(nBitLength, random);
+                }
+                while (k.equals(ZERO) || k.compareTo(n) >= 0);
+
+                ECPoint p = key.getParameters().getG().multiply(k);
+
+                // 5.3.3
+                BigInteger x = p.getX().toBigInteger();
+
+                r = x.mod(n);
+            }
+            while (r.equals(ZERO));
+
+            BigInteger d = ((ECPrivateKeyParameters)key).getD();
+
+            s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
+        }
+        while (s.equals(ZERO));
+
+        BigInteger[]  res = new BigInteger[2];
+
+        res[0] = r;
+        res[1] = s;
+
+        return res;
+    }
+
+    // 5.4 pg 29
+    /**
+     * return true if the value r and s represent a DSA signature for
+     * the passed in message (for standard DSA the message should be
+     * a SHA-1 hash of the real message to be verified).
+     */
+    public boolean verifySignature(
+        byte[]      message,
+        BigInteger  r,
+        BigInteger  s)
+    {
+        BigInteger n = key.getParameters().getN();
+        BigInteger e = calculateE(n, message);
+
+        // r in the range [1,n-1]
+        if (r.compareTo(ONE) < 0 || r.compareTo(n) >= 0)
+        {
+            return false;
+        }
+
+        // s in the range [1,n-1]
+        if (s.compareTo(ONE) < 0 || s.compareTo(n) >= 0)
+        {
+            return false;
+        }
+
+        BigInteger c = s.modInverse(n);
+
+        BigInteger u1 = e.multiply(c).mod(n);
+        BigInteger u2 = r.multiply(c).mod(n);
+
+        ECPoint G = key.getParameters().getG();
+        ECPoint Q = ((ECPublicKeyParameters)key).getQ();
+
+        ECPoint point = ECAlgorithms.sumOfTwoMultiplies(G, u1, Q, u2);
+
+        BigInteger v = point.getX().toBigInteger().mod(n);
+
+        return v.equals(r);
+    }
+
+    private BigInteger calculateE(BigInteger n, byte[] message)
+    {  
+        if (n.bitLength() > message.length * 8)
+        {
+            return new BigInteger(1, message);
+        }
+        else
+        {
+            int messageBitLength = message.length * 8;
+            BigInteger trunc = new BigInteger(1, message);
+
+            if (messageBitLength - n.bitLength() > 0)
+            {
+                trunc = trunc.shiftRight(messageBitLength - n.bitLength());
+            }
+
+            return trunc;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,136 @@
+package org.bouncycastle.crypto.signers;
+
+import org.bouncycastle.crypto.AsymmetricBlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.util.Arrays;
+
+public class GenericSigner
+    implements Signer
+{
+    private final AsymmetricBlockCipher engine;
+    private final Digest digest;
+    private boolean forSigning;
+
+    public GenericSigner(
+        AsymmetricBlockCipher engine,
+        Digest                digest)
+    {
+        this.engine = engine;
+        this.digest = digest;
+    }
+
+    /**
+     * initialise the signer for signing or verification.
+     *
+     * @param forSigning
+     *            true if for signing, false otherwise
+     * @param parameters
+     *            necessary parameters.
+     */
+    public void init(
+        boolean          forSigning,
+        CipherParameters parameters)
+    {
+        this.forSigning = forSigning;
+        AsymmetricKeyParameter k;
+
+        if (parameters instanceof ParametersWithRandom)
+        {
+            k = (AsymmetricKeyParameter)((ParametersWithRandom)parameters).getParameters();
+        }
+        else
+        {
+            k = (AsymmetricKeyParameter)parameters;
+        }
+
+        if (forSigning && !k.isPrivate())
+        {
+            throw new IllegalArgumentException("signing requires private key");
+        }
+
+        if (!forSigning && k.isPrivate())
+        {
+            throw new IllegalArgumentException("verification requires public key");
+        }
+
+        reset();
+
+        engine.init(forSigning, parameters);
+    }
+
+    /**
+     * update the internal digest with the byte b
+     */
+    public void update(
+        byte input)
+    {
+        digest.update(input);
+    }
+
+    /**
+     * update the internal digest with the byte array in
+     */
+    public void update(
+        byte[]  input,
+        int     inOff,
+        int     length)
+    {
+        digest.update(input, inOff, length);
+    }
+
+    /**
+     * Generate a signature for the message we've been loaded with using the key
+     * we were initialised with.
+     */
+    public byte[] generateSignature()
+        throws CryptoException, DataLengthException
+    {
+        if (!forSigning)
+        {
+            throw new IllegalStateException("GenericSigner not initialised for signature generation.");
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        return engine.processBlock(hash, 0, hash.length);
+    }
+
+    /**
+     * return true if the internal state represents the signature described in
+     * the passed in array.
+     */
+    public boolean verifySignature(
+        byte[] signature)
+    {
+        if (forSigning)
+        {
+            throw new IllegalStateException("GenericSigner not initialised for verification");
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        try
+        {
+            byte[] sig = engine.processBlock(signature, 0, signature.length);
+
+            return Arrays.constantTimeAreEqual(sig, hash);
+        }
+        catch (Exception e)
+        {
+            return false;
+        }
+    }
+
+    public void reset()
+    {
+        digest.reset();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Basic signers.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,46 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.2
+ */
+public class AlertDescription
+{
+    public static final short close_notify = 0;
+    public static final short unexpected_message = 10;
+    public static final short bad_record_mac = 20;
+    public static final short decryption_failed = 21;
+    public static final short record_overflow = 22;
+    public static final short decompression_failure = 30;
+    public static final short handshake_failure = 40;
+    /* 41 is not defined, for historical reasons */
+    public static final short bad_certificate = 42;
+    public static final short unsupported_certificate = 43;
+    public static final short certificate_revoked = 44;
+    public static final short certificate_expired = 45;
+    public static final short certificate_unknown = 46;
+    public static final short illegal_parameter = 47;
+    public static final short unknown_ca = 48;
+    public static final short access_denied = 49;
+    public static final short decode_error = 50;
+    public static final short decrypt_error = 51;
+    public static final short export_restriction = 60;
+    public static final short protocol_version = 70;
+    public static final short insufficient_security = 71;
+    public static final short internal_error = 80;
+    public static final short user_canceled = 90;
+    public static final short no_renegotiation = 100;
+
+    /*
+     *  RFC 3546
+     */
+    public static final short unsupported_extension = 110;
+    public static final short certificate_unobtainable = 111;
+    public static final short unrecognized_name = 112;
+    public static final short bad_certificate_status_response = 113;
+    public static final short bad_certificate_hash_value = 114;
+
+    /*
+     *  RFC 4279
+     */
+    public static final short unknown_psk_identity = 115;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.2
+ */
+public class AlertLevel
+{
+    public static final short warning = 1;
+    public static final short fatal = 2;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+
+/**
+ * A certificate verifyer, that will always return true.
+ * 
+ * <pre>
+ * DO NOT USE THIS FILE UNLESS YOU KNOW EXACTLY WHAT YOU ARE DOING.
+ * </pre>
+ * 
+ * @deprecated Perform certificate verification in TlsAuthentication implementation
+ */
+public class AlwaysValidVerifyer implements CertificateVerifyer
+{
+    /**
+     * Return true.
+     * 
+     * @see org.bouncycastle.crypto.tls.CertificateVerifyer#isValid(org.bouncycastle.asn1.x509.X509CertificateStructure[])
+     */
+    public boolean isValid(X509CertificateStructure[] certs)
+    {
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,123 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * A queue for bytes. This file could be more optimized.
+ */
+public class ByteQueue
+{
+    /**
+     * @return The smallest number which can be written as 2^x which is bigger than i.
+     */
+    public static final int nextTwoPow(int i)
+    {
+        /*
+         * This code is based of a lot of code I found on the Internet which mostly
+         * referenced a book called "Hacking delight".
+         */
+        i |= (i >> 1);
+        i |= (i >> 2);
+        i |= (i >> 4);
+        i |= (i >> 8);
+        i |= (i >> 16);
+        return i + 1;
+    }
+
+    /**
+     * The initial size for our buffer.
+     */
+    private static final int INITBUFSIZE = 1024;
+
+    /**
+     * The buffer where we store our data.
+     */
+    private byte[] databuf = new byte[ByteQueue.INITBUFSIZE];
+
+    /**
+     * How many bytes at the beginning of the buffer are skipped.
+     */
+    private int skipped = 0;
+
+    /**
+     * How many bytes in the buffer are valid data.
+     */
+    private int available = 0;
+
+    /**
+     * Read data from the buffer.
+     * 
+     * @param buf The buffer where the read data will be copied to.
+     * @param offset How many bytes to skip at the beginning of buf.
+     * @param len How many bytes to read at all.
+     * @param skip How many bytes from our data to skip.
+     */
+    public void read(byte[] buf, int offset, int len, int skip)
+    {
+        if ((available - skip) < len)
+        {
+            throw new TlsRuntimeException("Not enough data to read");
+        }
+        if ((buf.length - offset) < len)
+        {
+            throw new TlsRuntimeException("Buffer size of " + buf.length
+                + " is too small for a read of " + len + " bytes");
+        }
+        System.arraycopy(databuf, skipped + skip, buf, offset, len);
+        return;
+    }
+
+    /**
+     * Add some data to our buffer.
+     * 
+     * @param data A byte-array to read data from.
+     * @param offset How many bytes to skip at the beginning of the array.
+     * @param len How many bytes to read from the array.
+     */
+    public void addData(byte[] data, int offset, int len)
+    {
+        if ((skipped + available + len) > databuf.length)
+        {
+            byte[] tmp = new byte[ByteQueue.nextTwoPow(data.length)];
+            System.arraycopy(databuf, skipped, tmp, 0, available);
+            skipped = 0;
+            databuf = tmp;
+        }
+        System.arraycopy(data, offset, databuf, skipped + available, len);
+        available += len;
+    }
+
+    /**
+     * Remove some bytes from our data from the beginning.
+     * 
+     * @param i How many bytes to remove.
+     */
+    public void removeData(int i)
+    {
+        if (i > available)
+        {
+            throw new TlsRuntimeException("Cannot remove " + i + " bytes, only got " + available);
+        }
+
+        /*
+         * Skip the data.
+         */
+        available -= i;
+        skipped += i;
+
+        /*
+         * If more than half of our data is skipped, we will move the data in the buffer.
+         */
+        if (skipped > (databuf.length / 2))
+        {
+            System.arraycopy(databuf, skipped, databuf, 0, available);
+            skipped = 0;
+        }
+    }
+
+    /**
+     * @return The number of bytes which are available in this buffer.
+     */
+    public int size()
+    {
+        return available;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/Certificate.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/Certificate.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/Certificate.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/Certificate.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/Certificate.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,122 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+
+/**
+ * A representation for a certificate chain as used by a tls server.
+ */
+public class Certificate
+{
+    public static final Certificate EMPTY_CHAIN = new Certificate(new X509CertificateStructure[0]);
+
+    /**
+     * The certificates.
+     */
+    protected X509CertificateStructure[] certs;
+
+    /**
+     * Parse the ServerCertificate message.
+     * 
+     * @param is The stream where to parse from.
+     * @return A Certificate object with the certs, the server has sended.
+     * @throws IOException If something goes wrong during parsing.
+     */
+    protected static Certificate parse(InputStream is) throws IOException
+    {
+        X509CertificateStructure[] certs;
+        int left = TlsUtils.readUint24(is);
+        if (left == 0)
+        {
+            return EMPTY_CHAIN;
+        }
+        Vector tmp = new Vector();
+        while (left > 0)
+        {
+            int size = TlsUtils.readUint24(is);
+            left -= 3 + size;
+            byte[] buf = new byte[size];
+            TlsUtils.readFully(buf, is);
+            ByteArrayInputStream bis = new ByteArrayInputStream(buf);
+            ASN1InputStream ais = new ASN1InputStream(bis);
+            DERObject o = ais.readObject();
+            tmp.addElement(X509CertificateStructure.getInstance(o));
+            if (bis.available() > 0)
+            {
+                throw new IllegalArgumentException(
+                    "Sorry, there is garbage data left after the certificate");
+            }
+        }
+        certs = new X509CertificateStructure[tmp.size()];
+        for (int i = 0; i < tmp.size(); i++)
+        {
+            certs[i] = (X509CertificateStructure)tmp.elementAt(i);
+        }
+        return new Certificate(certs);
+    }
+
+    /**
+     * Encodes version of the ClientCertificate message
+     * 
+     * @param os stream to write the message to
+     * @throws IOException If something goes wrong
+     */
+    protected void encode(OutputStream os) throws IOException
+    {
+        Vector encCerts = new Vector();
+        int totalSize = 0;
+        for (int i = 0; i < this.certs.length; ++i)
+        {
+            byte[] encCert = certs[i].getEncoded(ASN1Encodable.DER);
+            encCerts.addElement(encCert);
+            totalSize += encCert.length + 3;
+        }
+
+        TlsUtils.writeUint24(totalSize + 3, os);
+        TlsUtils.writeUint24(totalSize, os);
+
+        for (int i = 0; i < encCerts.size(); ++i)
+        {
+            byte[] encCert = (byte[])encCerts.elementAt(i);
+            TlsUtils.writeOpaque24(encCert, os);
+        }
+    }
+
+    /**
+     * Private constructor from a cert array.
+     * 
+     * @param certs The certs the chain should contain.
+     */
+    public Certificate(X509CertificateStructure[] certs)
+    {
+        if (certs == null)
+        {
+            throw new IllegalArgumentException("'certs' cannot be null");
+        }
+
+        this.certs = certs;
+    }
+
+    /**
+     * @return An array which contains the certs, this chain contains.
+     */
+    public X509CertificateStructure[] getCerts()
+    {
+        X509CertificateStructure[] result = new X509CertificateStructure[certs.length];
+        System.arraycopy(certs, 0, result, 0, certs.length);
+        return result;
+    }
+
+    public boolean isEmpty()
+    {
+        return certs.length == 0;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,28 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.util.Vector;
+
+public class CertificateRequest
+{
+    private short[] certificateTypes;
+    private Vector certificateAuthorities;
+
+    public CertificateRequest(short[] certificateTypes, Vector certificateAuthorities)
+    {
+        this.certificateTypes = certificateTypes;
+        this.certificateAuthorities = certificateAuthorities;
+    }
+
+    public short[] getCertificateTypes()
+    {
+        return certificateTypes;
+    }
+
+    /**
+     * @return Vector of X500Name
+     */
+    public Vector getCertificateAuthorities()
+    {
+        return certificateAuthorities;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+
+/**
+ * This should be implemented by any class which can find out, if a given certificate
+ * chain is being accepted by an client.
+ * 
+ * @deprecated Perform certificate verification in TlsAuthentication implementation
+ */
+public interface CertificateVerifyer
+{
+    /**
+     * @param certs The certs, which are part of the chain.
+     * @return True, if the chain is accepted, false otherwise.
+     */
+    public boolean isValid(X509CertificateStructure[] certs);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,135 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 A.5
+ */
+public class CipherSuite
+{
+    public static final int TLS_NULL_WITH_NULL_NULL = 0x0000;
+    public static final int TLS_RSA_WITH_NULL_MD5 = 0x0001;
+    public static final int TLS_RSA_WITH_NULL_SHA = 0x0002;
+    public static final int TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 0x0003;
+    public static final int TLS_RSA_WITH_RC4_128_MD5 = 0x0004;
+    public static final int TLS_RSA_WITH_RC4_128_SHA = 0x0005;
+    public static final int TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 0x0006;
+    public static final int TLS_RSA_WITH_IDEA_CBC_SHA = 0x0007;
+    public static final int TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0008;
+    public static final int TLS_RSA_WITH_DES_CBC_SHA = 0x0009;
+    public static final int TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000A;
+    public static final int TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x000B;
+    public static final int TLS_DH_DSS_WITH_DES_CBC_SHA = 0x000C;
+    public static final int TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 0x000D;
+    public static final int TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x000E;
+    public static final int TLS_DH_RSA_WITH_DES_CBC_SHA = 0x000F;
+    public static final int TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 0x0010;
+    public static final int TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x0011;
+    public static final int TLS_DHE_DSS_WITH_DES_CBC_SHA = 0x0012;
+    public static final int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 0x0013;
+    public static final int TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0014;
+    public static final int TLS_DHE_RSA_WITH_DES_CBC_SHA = 0x0015;
+    public static final int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016;
+    public static final int TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 0x0017;
+    public static final int TLS_DH_anon_WITH_RC4_128_MD5 = 0x0018;
+    public static final int TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 0x0019;
+    public static final int TLS_DH_anon_WITH_DES_CBC_SHA = 0x001A;
+    public static final int TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 0x001B;
+
+    /*
+     * RFC 3268
+     */
+    public static final int TLS_RSA_WITH_AES_128_CBC_SHA = 0x002F;
+    public static final int TLS_DH_DSS_WITH_AES_128_CBC_SHA = 0x0030;
+    public static final int TLS_DH_RSA_WITH_AES_128_CBC_SHA = 0x0031;
+    public static final int TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 0x0032;
+    public static final int TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033;
+    public static final int TLS_DH_anon_WITH_AES_128_CBC_SHA = 0x0034;
+    public static final int TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035;
+    public static final int TLS_DH_DSS_WITH_AES_256_CBC_SHA = 0x0036;
+    public static final int TLS_DH_RSA_WITH_AES_256_CBC_SHA = 0x0037;
+    public static final int TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 0x0038;
+    public static final int TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039;
+    public static final int TLS_DH_anon_WITH_AES_256_CBC_SHA = 0x003A;
+
+    /*
+     * RFC 4279
+     */
+    public static final int TLS_PSK_WITH_RC4_128_SHA = 0x008A;
+    public static final int TLS_PSK_WITH_3DES_EDE_CBC_SHA = 0x008B;
+    public static final int TLS_PSK_WITH_AES_128_CBC_SHA = 0x008C;
+    public static final int TLS_PSK_WITH_AES_256_CBC_SHA = 0x008D;
+    public static final int TLS_DHE_PSK_WITH_RC4_128_SHA = 0x008E;
+    public static final int TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 0x008F;
+    public static final int TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 0x0090;
+    public static final int TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 0x0091;
+    public static final int TLS_RSA_PSK_WITH_RC4_128_SHA = 0x0092;
+    public static final int TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 0x0093;
+    public static final int TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 0x0094;
+    public static final int TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 0x0095;
+
+    /*
+     * RFC 4492
+     */
+    public static final int TLS_ECDH_ECDSA_WITH_NULL_SHA = 0xC001;
+    public static final int TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xC002;
+    public static final int TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC003;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xC004;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xC005;
+    public static final int TLS_ECDHE_ECDSA_WITH_NULL_SHA = 0xC006;
+    public static final int TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xC007;
+    public static final int TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC008;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00A;
+    public static final int TLS_ECDH_RSA_WITH_NULL_SHA = 0xC00B;
+    public static final int TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xC00C;
+    public static final int TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xC00D;
+    public static final int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xC00E;
+    public static final int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xC00F;
+    public static final int TLS_ECDHE_RSA_WITH_NULL_SHA = 0xC010;
+    public static final int TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xC011;
+    public static final int TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xC012;
+    public static final int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013;
+    public static final int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014;
+    public static final int TLS_ECDH_anon_WITH_NULL_SHA = 0xC015;
+    public static final int TLS_ECDH_anon_WITH_RC4_128_SHA = 0xC016;
+    public static final int TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = 0xC017;
+    public static final int TLS_ECDH_anon_WITH_AES_128_CBC_SHA = 0xC018;
+    public static final int TLS_ECDH_anon_WITH_AES_256_CBC_SHA = 0xC019;
+
+    /*
+     * RFC 5054
+     */
+    public static final int TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 0xC01A;
+    public static final int TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 0xC01B;
+    public static final int TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 0xC01C;
+    public static final int TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 0xC01D;
+    public static final int TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 0xC01E;
+    public static final int TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 0xC01F;
+    public static final int TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 0xC020;
+    public static final int TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 0xC021;
+    public static final int TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 0xC022;
+
+    /*
+     * RFC 5289
+     */
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC025;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC026;
+    public static final int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027;
+    public static final int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028;
+    public static final int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xC029;
+    public static final int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xC02A;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02B;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02C;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02D;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02E;
+    public static final int TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F;
+    public static final int TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030;
+    public static final int TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xC031;
+    public static final int TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xC032;
+
+    /*
+     * RFC 5746
+     */
+    public static final int TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00FF;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.4.4
+ */
+public class ClientCertificateType
+{
+    public static final short rsa_sign = 1;
+    public static final short dss_sign = 2;
+    public static final short rsa_fixed_dh = 3;
+    public static final short dss_fixed_dh = 4;
+
+    /*
+     * RFC 4492 5.5
+     */
+    public static final short ecdsa_sign = 64;
+    public static final short rsa_fixed_ecdh = 65;
+    public static final short ecdsa_fixed_ecdh = 66;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,80 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.digests.MD5Digest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+
+/**
+ * A combined hash, which implements md5(m) || sha1(m).
+ */
+class CombinedHash implements Digest
+{
+    private MD5Digest md5;
+    private SHA1Digest sha1;
+
+    CombinedHash()
+    {
+        this.md5 = new MD5Digest();
+        this.sha1 = new SHA1Digest();
+    }
+
+    CombinedHash(CombinedHash t)
+    {
+        this.md5 = new MD5Digest(t.md5);
+        this.sha1 = new SHA1Digest(t.sha1);
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#getAlgorithmName()
+     */
+    public String getAlgorithmName()
+    {
+        return md5.getAlgorithmName() + " and " + sha1.getAlgorithmName() + " for TLS 1.0";
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#getDigestSize()
+     */
+    public int getDigestSize()
+    {
+        return 16 + 20;
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#update(byte)
+     */
+    public void update(byte in)
+    {
+        md5.update(in);
+        sha1.update(in);
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#update(byte[],int,int)
+     */
+    public void update(byte[] in, int inOff, int len)
+    {
+        md5.update(in, inOff, len);
+        sha1.update(in, inOff, len);
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#doFinal(byte[],int)
+     */
+    public int doFinal(byte[] out, int outOff)
+    {
+        int i1 = md5.doFinal(out, outOff);
+        int i2 = sha1.doFinal(out, outOff + 16);
+        return i1 + i2;
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#reset()
+     */
+    public void reset()
+    {
+        md5.reset();
+        sha1.reset();
+    }
+
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 6.1
+ */
+public class CompressionMethod
+{
+    public static final short NULL = 0;
+
+    /*
+     * RFC 3749 2
+     */
+    public static final short DEFLATE = 1;
+
+    /*
+     * Values from 224 decimal (0xE0) through 255 decimal (0xFF)
+     * inclusive are reserved for private use.
+     */
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ContentType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ContentType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ContentType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ContentType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ContentType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 6.2.1
+ */
+public class ContentType
+{
+    public static final short change_cipher_spec = 20;
+    public static final short alert = 21;
+    public static final short handshake = 22;
+    public static final short application_data = 23;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,70 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.digests.MD5Digest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+import org.bouncycastle.crypto.digests.SHA256Digest;
+import org.bouncycastle.crypto.digests.SHA384Digest;
+import org.bouncycastle.crypto.engines.AESFastEngine;
+import org.bouncycastle.crypto.engines.DESedeEngine;
+import org.bouncycastle.crypto.modes.CBCBlockCipher;
+
+public class DefaultTlsCipherFactory implements TlsCipherFactory
+{
+    public TlsCipher createCipher(TlsClientContext context, int encryptionAlgorithm, int digestAlgorithm) throws IOException
+    {
+        switch (encryptionAlgorithm)
+        {
+            case EncryptionAlgorithm._3DES_EDE_CBC:
+                return createDESedeCipher(context, 24, digestAlgorithm);
+            case EncryptionAlgorithm.AES_128_CBC:
+                return createAESCipher(context, 16, digestAlgorithm);
+            case EncryptionAlgorithm.AES_256_CBC:
+                return createAESCipher(context, 32, digestAlgorithm);
+            default:
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    protected TlsCipher createAESCipher(TlsClientContext context, int cipherKeySize, int digestAlgorithm) throws IOException
+    {
+        return new TlsBlockCipher(context, createAESBlockCipher(),
+            createAESBlockCipher(), createDigest(digestAlgorithm), createDigest(digestAlgorithm), cipherKeySize);
+    }
+
+    protected TlsCipher createDESedeCipher(TlsClientContext context, int cipherKeySize, int digestAlgorithm) throws IOException
+    {
+        return new TlsBlockCipher(context, createDESedeBlockCipher(),
+            createDESedeBlockCipher(), createDigest(digestAlgorithm), createDigest(digestAlgorithm), cipherKeySize);
+    }
+
+    protected BlockCipher createAESBlockCipher()
+    {
+        return new CBCBlockCipher(new AESFastEngine());
+    }
+
+    protected BlockCipher createDESedeBlockCipher()
+    {
+        return new CBCBlockCipher(new DESedeEngine());
+    }
+
+    protected Digest createDigest(int digestAlgorithm) throws IOException
+    {
+        switch (digestAlgorithm)
+        {
+            case DigestAlgorithm.MD5:
+                return new MD5Digest();
+            case DigestAlgorithm.SHA:
+                return new SHA1Digest();
+            case DigestAlgorithm.SHA256:
+                return new SHA256Digest();
+            case DigestAlgorithm.SHA384:
+                return new SHA384Digest();
+            default:
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,238 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+
+public abstract class DefaultTlsClient implements TlsClient
+{
+    protected TlsCipherFactory cipherFactory;
+
+    protected TlsClientContext context;
+
+    protected int selectedCipherSuite;
+    protected int selectedCompressionMethod;
+
+    public DefaultTlsClient()
+    {
+        this(new DefaultTlsCipherFactory());
+    }
+
+    public DefaultTlsClient(TlsCipherFactory cipherFactory)
+    {
+        this.cipherFactory = cipherFactory;
+    }
+
+    public void init(TlsClientContext context)
+    {
+        this.context = context;
+    }
+
+    public int[] getCipherSuites()
+    {
+        return new int[] {
+            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA,
+            CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+        };
+    }
+
+    public Hashtable getClientExtensions()
+    {
+        return null;
+    }
+
+    public short[] getCompressionMethods()
+    {
+        return new short[] { CompressionMethod.NULL };
+    }
+
+    public void notifySessionID(byte[] sessionID)
+    {
+        // Currently ignored 
+    }
+
+    public void notifySelectedCipherSuite(int selectedCipherSuite)
+    {
+        this.selectedCipherSuite = selectedCipherSuite;
+    }
+
+    public void notifySelectedCompressionMethod(short selectedCompressionMethod)
+    {
+        this.selectedCompressionMethod = selectedCompressionMethod;
+    }
+
+    public void notifySecureRenegotiation(boolean secureRenegotiation) throws IOException
+    {
+        if (!secureRenegotiation)
+        {
+            /*
+             * RFC 5746 3.4. If the extension is not present, the server does not support
+             * secure renegotiation; set secure_renegotiation flag to FALSE. In this case,
+             * some clients may want to terminate the handshake instead of continuing; see
+             * Section 4.1 for discussion.
+             */
+//            throw new TlsFatalAlert(AlertDescription.handshake_failure);
+        }
+    }
+
+    public void processServerExtensions(Hashtable serverExtensions)
+    {
+    }
+
+    public TlsKeyExchange getKeyExchange() throws IOException
+    {
+        switch (selectedCipherSuite)
+        {
+            case CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA:
+                return createRSAKeyExchange();
+
+            case CipherSuite.TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_256_CBC_SHA:
+                return createDHKeyExchange(KeyExchangeAlgorithm.DH_DSS);
+
+            case CipherSuite.TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_256_CBC_SHA:
+                return createDHKeyExchange(KeyExchangeAlgorithm.DH_RSA);
+
+            case CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA:
+                return createDHEKeyExchange(KeyExchangeAlgorithm.DHE_DSS);
+
+            case CipherSuite.TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
+                return createDHEKeyExchange(KeyExchangeAlgorithm.DHE_RSA);
+
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
+                return createECDHKeyExchange(KeyExchangeAlgorithm.ECDH_ECDSA);
+
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
+                return createECDHEKeyExchange(KeyExchangeAlgorithm.ECDHE_ECDSA);
+
+            case CipherSuite.TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
+                return createECDHKeyExchange(KeyExchangeAlgorithm.ECDH_RSA);
+
+            case CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
+                return createECDHEKeyExchange(KeyExchangeAlgorithm.ECDHE_RSA);
+
+            default:
+                /*
+                 * Note: internal error here; the TlsProtocolHandler verifies that the
+                 * server-selected cipher suite was in the list of client-offered cipher
+                 * suites, so if we now can't produce an implementation, we shouldn't have
+                 * offered it!
+                 */
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public TlsCompression getCompression() throws IOException
+    {
+        switch (selectedCompressionMethod)
+        {
+            case CompressionMethod.NULL:
+                return new TlsNullCompression();
+
+            default:
+                /*
+                 * Note: internal error here; the TlsProtocolHandler verifies that the
+                 * server-selected compression method was in the list of client-offered compression
+                 * methods, so if we now can't produce an implementation, we shouldn't have
+                 * offered it!
+                 */
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public TlsCipher getCipher() throws IOException
+    {
+        switch (selectedCipherSuite)
+        {
+            case CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
+                return cipherFactory.createCipher(context, EncryptionAlgorithm._3DES_EDE_CBC, DigestAlgorithm.SHA);
+
+            case CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
+                return cipherFactory.createCipher(context, EncryptionAlgorithm.AES_128_CBC, DigestAlgorithm.SHA);
+
+            case CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
+                return cipherFactory.createCipher(context, EncryptionAlgorithm.AES_256_CBC, DigestAlgorithm.SHA);
+
+            default:
+                /*
+                 * Note: internal error here; the TlsProtocolHandler verifies that the
+                 * server-selected cipher suite was in the list of client-offered cipher
+                 * suites, so if we now can't produce an implementation, we shouldn't have
+                 * offered it!
+                 */
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    protected TlsKeyExchange createDHKeyExchange(int keyExchange)
+    {
+        return new TlsDHKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createDHEKeyExchange(int keyExchange)
+    {
+        return new TlsDHEKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createECDHKeyExchange(int keyExchange)
+    {
+        return new TlsECDHKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createECDHEKeyExchange(int keyExchange)
+    {
+        return new TlsECDHEKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createRSAKeyExchange()
+    {
+        return new TlsRSAKeyExchange(context);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.crypto.tls;
+
+public class DigestAlgorithm
+{
+    /*
+     * Note that the values here are implementation-specific and arbitrary.
+     * It is recommended not to depend on the particular values (e.g. serialization).
+     */
+    public static final int NULL = 0;
+    public static final int MD5 = 1;
+    public static final int SHA = 2;
+
+    /*
+     * RFC 5289
+     */
+    public static final int SHA256 = 3;
+    public static final int SHA384 = 4;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,28 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 4492 5.4
+ */
+public class ECCurveType
+{
+    /**
+     * Indicates the elliptic curve domain parameters are conveyed verbosely, and the
+     * underlying finite field is a prime field.
+     */
+    public static final short explicit_prime = 1;
+
+    /**
+     * Indicates the elliptic curve domain parameters are conveyed verbosely, and the
+     * underlying finite field is a characteristic-2 field.
+     */
+    public static final short explicit_char2 = 2;
+
+    /**
+     * Indicates that a named curve is used. This option SHOULD be used when applicable.
+     */
+    public static final short named_curve = 3;
+
+    /*
+     * Values 248 through 255 are reserved for private use.
+     */
+}

Added: trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,29 @@
+package org.bouncycastle.crypto.tls;
+
+public class EncryptionAlgorithm
+{
+    /*
+     * Note that the values here are implementation-specific and arbitrary.
+     * It is recommended not to depend on the particular values (e.g. serialization).
+     */
+    public static final int NULL = 0;
+    public static final int RC4_40 = 1;
+    public static final int RC4_128 = 2;
+    public static final int RC2_CBC_40 = 3;
+    public static final int IDEA_CBC = 4;
+    public static final int DES40_CBC = 5;
+    public static final int DES_CBC = 6;
+    public static final int _3DES_EDE_CBC = 7;
+
+    /*
+     * RFC 3268
+     */
+    public static final int AES_128_CBC = 8;
+    public static final int AES_256_CBC = 9;
+
+    /*
+     * RFC 5289
+     */
+    public static final int AES_128_GCM = 10;
+    public static final int AES_256_GCM = 11;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 4366 2.3
+ */
+public class ExtensionType
+{
+    public static final int server_name = 0;
+    public static final int max_fragment_length = 1;
+    public static final int client_certificate_url = 2;
+    public static final int trusted_ca_keys = 3;
+    public static final int truncated_hmac = 4;
+    public static final int status_request = 5;
+
+    /*
+     * RFC 4492
+     */
+    public static final int elliptic_curves = 10;
+    public static final int ec_point_formats = 11;
+
+    /*
+     * RFC 5054 2.8.1
+     */
+    public static final int srp = 12;
+
+    /*
+     * RFC 5746 6
+     */
+    public static final int renegotiation_info = 0xff01;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.4
+ */
+public class HandshakeType
+{
+    public static final short hello_request = 0;
+    public static final short client_hello = 1;
+    public static final short server_hello = 2;
+    public static final short certificate = 11;
+    public static final short server_key_exchange = 12;
+    public static final short certificate_request = 13;
+    public static final short server_hello_done = 14;
+    public static final short certificate_verify = 15;
+    public static final short client_key_exchange = 16;
+    public static final short finished = 20;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,33 @@
+package org.bouncycastle.crypto.tls;
+
+public class KeyExchangeAlgorithm
+{
+    /*
+     * Note that the values here are implementation-specific and arbitrary.
+     * It is recommended not to depend on the particular values (e.g. serialization).
+     */
+    public static final int NULL = 0;
+    public static final int RSA = 1;
+    public static final int RSA_EXPORT = 2;
+    public static final int DHE_DSS = 3;
+    public static final int DHE_DSS_EXPORT = 4;
+    public static final int DHE_RSA = 5;
+    public static final int DHE_RSA_EXPORT = 6;
+    public static final int DH_DSS = 7;
+    public static final int DH_DSS_EXPORT = 8;
+    public static final int DH_RSA = 9;
+    public static final int DH_RSA_EXPORT = 10;
+    public static final int DH_anon = 11;
+    public static final int DH_anon_EXPORT = 12;
+    public static final int PSK = 13;
+    public static final int DHE_PSK = 14;
+    public static final int RSA_PSK = 15;
+    public static final int ECDH_ECDSA = 16;
+    public static final int ECDHE_ECDSA = 17;
+    public static final int ECDH_RSA = 18;
+    public static final int ECDHE_RSA = 19;
+    public static final int ECDH_anon = 20;
+    public static final int SRP = 21;
+    public static final int SRP_DSS = 22;
+    public static final int SRP_RSA = 23;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,32 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+/**
+ * A temporary class to wrap old CertificateVerifyer stuff for new TlsAuthentication
+ * 
+ * @deprecated
+ */
+public class LegacyTlsAuthentication implements TlsAuthentication
+{
+    protected CertificateVerifyer verifyer;
+
+    public LegacyTlsAuthentication(CertificateVerifyer verifyer)
+    {
+        this.verifyer = verifyer;
+    }
+
+    public void notifyServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        if (!this.verifyer.isValid(serverCertificate.getCerts()))
+        {
+            throw new TlsFatalAlert(AlertDescription.user_canceled);
+        }
+    }
+
+    public TlsCredentials getClientCredentials(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        return null;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,29 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+/**
+ * A temporary class to use LegacyTlsAuthentication
+ * 
+ * @deprecated
+ */
+public class LegacyTlsClient extends DefaultTlsClient
+{
+    /** @deprecated */
+    protected CertificateVerifyer verifyer;
+
+    /**
+     * @deprecated
+     */
+    public LegacyTlsClient(CertificateVerifyer verifyer)
+    {
+        super();
+
+        this.verifyer = verifyer;
+    }
+
+    public TlsAuthentication getAuthentication() throws IOException
+    {
+        return new LegacyTlsAuthentication(verifyer);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,100 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.asn1.sec.SECNamedCurves;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+
+/**
+ * RFC 4492 5.1.1
+ * 
+ * The named curves defined here are those specified in SEC 2 [13]. Note that many of
+ * these curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11]. Values 0xFE00
+ * through 0xFEFF are reserved for private use. Values 0xFF01 and 0xFF02 indicate that the
+ * client supports arbitrary prime and characteristic-2 curves, respectively (the curve
+ * parameters must be encoded explicitly in ECParameters).
+ */
+public class NamedCurve
+{
+    public static final int sect163k1 = 1;
+    public static final int sect163r1 = 2;
+    public static final int sect163r2 = 3;
+    public static final int sect193r1 = 4;
+    public static final int sect193r2 = 5;
+    public static final int sect233k1 = 6;
+    public static final int sect233r1 = 7;
+    public static final int sect239k1 = 8;
+    public static final int sect283k1 = 9;
+    public static final int sect283r1 = 10;
+    public static final int sect409k1 = 11;
+    public static final int sect409r1 = 12;
+    public static final int sect571k1 = 13;
+    public static final int sect571r1 = 14;
+    public static final int secp160k1 = 15;
+    public static final int secp160r1 = 16;
+    public static final int secp160r2 = 17;
+    public static final int secp192k1 = 18;
+    public static final int secp192r1 = 19;
+    public static final int secp224k1 = 20;
+    public static final int secp224r1 = 21;
+    public static final int secp256k1 = 22;
+    public static final int secp256r1 = 23;
+    public static final int secp384r1 = 24;
+    public static final int secp521r1 = 25;
+
+    /*
+     * reserved (0xFE00..0xFEFF)
+     */
+
+    public static final int arbitrary_explicit_prime_curves = 0xFF01;
+    public static final int arbitrary_explicit_char2_curves = 0xFF02;
+
+    private static final String[] curveNames = new String[] {
+        "sect163k1",
+        "sect163r1",
+        "sect163r2",
+        "sect193r1",
+        "sect193r2",
+        "sect233k1",
+        "sect233r1",
+        "sect239k1",
+        "sect283k1",
+        "sect283r1",
+        "sect409k1",
+        "sect409r1",
+        "sect571k1",
+        "sect571r1",
+        "secp160k1",
+        "secp160r1",
+        "secp160r2",
+        "secp192k1",
+        "secp192r1",
+        "secp224k1",
+        "secp224r1",
+        "secp256k1",
+        "secp256r1",
+        "secp384r1",
+        "secp521r1", };
+
+    static ECDomainParameters getECParameters(int namedCurve)
+    {
+        int index = namedCurve - 1;
+        if (index < 0 || index >= curveNames.length)
+        {
+            return null;
+        }
+
+        String curveName = curveNames[index];
+
+        // Lazily created the first time a particular curve is accessed
+        X9ECParameters ecP = SECNamedCurves.getByName(curveName);
+
+        if (ecP == null)
+        {
+            return null;
+        }
+
+        // It's a bit inefficient to do this conversion every time
+        return new ECDomainParameters(ecP.getCurve(), ecP.getG(), ecP.getN(), ecP.getH(),
+            ecP.getSeed());
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/RecordStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/RecordStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/RecordStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,158 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+/**
+ * An implementation of the TLS 1.0 record layer.
+ */
+class RecordStream
+{
+    private TlsProtocolHandler handler;
+    private InputStream is;
+    private OutputStream os;
+    private CombinedHash hash;
+    private TlsCompression readCompression = null;
+    private TlsCompression writeCompression = null;
+    private TlsCipher readCipher = null;
+    private TlsCipher writeCipher = null;
+    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+
+    RecordStream(TlsProtocolHandler handler, InputStream is, OutputStream os)
+    {
+        this.handler = handler;
+        this.is = is;
+        this.os = os;
+        this.hash = new CombinedHash();
+        this.readCompression = new TlsNullCompression();
+        this.writeCompression = this.readCompression;
+        this.readCipher = new TlsNullCipher();
+        this.writeCipher = this.readCipher;
+    }
+
+    void clientCipherSpecDecided(TlsCompression tlsCompression, TlsCipher tlsCipher)
+    {
+        this.writeCompression = tlsCompression;
+        this.writeCipher = tlsCipher;
+    }
+
+    void serverClientSpecReceived()
+    {
+        this.readCompression = this.writeCompression;
+        this.readCipher = this.writeCipher;
+    }
+
+    public void readData() throws IOException
+    {
+        short type = TlsUtils.readUint8(is);
+        TlsUtils.checkVersion(is, handler);
+        int size = TlsUtils.readUint16(is);
+        byte[] buf = decodeAndVerify(type, is, size);
+        handler.processData(type, buf, 0, buf.length);
+    }
+
+    protected byte[] decodeAndVerify(short type, InputStream is, int len) throws IOException
+    {
+        byte[] buf = new byte[len];
+        TlsUtils.readFully(buf, is);
+        byte[] decoded = readCipher.decodeCiphertext(type, buf, 0, buf.length);
+
+        OutputStream cOut = readCompression.decompress(buffer);
+
+        if (cOut == buffer)
+        {
+            return decoded;
+        }
+
+        cOut.write(decoded, 0, decoded.length);
+        cOut.flush();
+        return getBufferContents();
+    }
+
+    protected void writeMessage(short type, byte[] message, int offset, int len) throws IOException
+    {
+        if (type == ContentType.handshake)
+        {
+            updateHandshakeData(message, offset, len);
+        }
+
+        OutputStream cOut = writeCompression.compress(buffer);
+
+        byte[] ciphertext;
+        if (cOut == buffer)
+        {
+            ciphertext = writeCipher.encodePlaintext(type, message, offset, len);
+        }
+        else
+        {
+            cOut.write(message, offset, len);
+            cOut.flush();
+            byte[] compressed = getBufferContents();
+            ciphertext = writeCipher.encodePlaintext(type, compressed, 0, compressed.length);
+        }
+
+        byte[] writeMessage = new byte[ciphertext.length + 5];
+        TlsUtils.writeUint8(type, writeMessage, 0);
+        TlsUtils.writeVersion(writeMessage, 1);
+        TlsUtils.writeUint16(ciphertext.length, writeMessage, 3);
+        System.arraycopy(ciphertext, 0, writeMessage, 5, ciphertext.length);
+        os.write(writeMessage);
+        os.flush();
+    }
+
+    void updateHandshakeData(byte[] message, int offset, int len)
+    {
+        hash.update(message, offset, len);
+    }
+
+    byte[] getCurrentHash()
+    {
+        return doFinal(new CombinedHash(hash));
+    }
+
+    protected void close() throws IOException
+    {
+        IOException e = null;
+        try
+        {
+            is.close();
+        }
+        catch (IOException ex)
+        {
+            e = ex;
+        }
+        try
+        {
+            os.close();
+        }
+        catch (IOException ex)
+        {
+            e = ex;
+        }
+        if (e != null)
+        {
+            throw e;
+        }
+    }
+
+    protected void flush() throws IOException
+    {
+        os.flush();
+    }
+
+    private byte[] getBufferContents()
+    {
+        byte[] contents = buffer.toByteArray();
+        buffer.reset();
+        return contents;
+    }
+
+    private static byte[] doFinal(CombinedHash ch)
+    {
+        byte[] bs = new byte[ch.getDigestSize()];
+        ch.doFinal(bs, 0);
+        return bs;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.crypto.tls;
+
+public class SecurityParameters
+{
+    byte[] clientRandom = null;
+    byte[] serverRandom = null;
+    byte[] masterSecret = null;
+
+    public byte[] getClientRandom()
+    {
+        return clientRandom;
+    }
+
+    public byte[] getServerRandom()
+    {
+        return serverRandom;
+    }
+
+    public byte[] getMasterSecret()
+    {
+        return masterSecret;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+
+public interface TlsAgreementCredentials extends TlsCredentials
+{
+    byte[] generateAgreement(AsymmetricKeyParameter serverPublicKey) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,24 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsAuthentication
+{
+    /**
+     * Called by the protocol handler to report the server certificate
+     * Note: this method is responsible for certificate verification and validation
+     * 
+     * @param serverCertificate the server certificate received
+     * @throws IOException
+     */
+    void notifyServerCertificate(Certificate serverCertificate) throws IOException;
+
+    /**
+     * Return client credentials in response to server's certificate request
+     * 
+     * @param certificateRequest details of the certificate request
+     * @return a TlsCredentials object or null for no client authentication
+     * @throws IOException
+     */
+    TlsCredentials getClientCredentials(CertificateRequest certificateRequest) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,219 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.params.KeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithIV;
+import org.bouncycastle.util.Arrays;
+
+/**
+ * A generic TLS 1.0 block cipher. This can be used for AES or 3DES for example.
+ */
+public class TlsBlockCipher implements TlsCipher
+{
+    protected TlsClientContext context;
+
+    protected BlockCipher encryptCipher;
+    protected BlockCipher decryptCipher;
+
+    protected TlsMac writeMac;
+    protected TlsMac readMac;
+
+    public TlsBlockCipher(TlsClientContext context, BlockCipher encryptCipher,
+        BlockCipher decryptCipher, Digest writeDigest, Digest readDigest, int cipherKeySize)
+    {
+        this.context = context;
+        this.encryptCipher = encryptCipher;
+        this.decryptCipher = decryptCipher;
+
+        int prfSize = (2 * cipherKeySize) + writeDigest.getDigestSize()
+            + readDigest.getDigestSize() + encryptCipher.getBlockSize()
+            + decryptCipher.getBlockSize();
+
+        SecurityParameters securityParameters = context.getSecurityParameters();
+
+        byte[] key_block = TlsUtils.PRF(securityParameters.masterSecret, "key expansion",
+            TlsUtils.concat(securityParameters.serverRandom, securityParameters.clientRandom),
+            prfSize);
+
+        int offset = 0;
+
+        // Init MACs
+        writeMac = new TlsMac(writeDigest, key_block, offset, writeDigest.getDigestSize());
+        offset += writeDigest.getDigestSize();
+        readMac = new TlsMac(readDigest, key_block, offset, readDigest.getDigestSize());
+        offset += readDigest.getDigestSize();
+
+        // Init Ciphers
+        this.initCipher(true, encryptCipher, key_block, cipherKeySize, offset, offset
+            + (cipherKeySize * 2));
+        offset += cipherKeySize;
+        this.initCipher(false, decryptCipher, key_block, cipherKeySize, offset, offset
+            + cipherKeySize + encryptCipher.getBlockSize());
+
+    }
+
+    protected void initCipher(boolean forEncryption, BlockCipher cipher, byte[] key_block,
+        int key_size, int key_offset, int iv_offset)
+    {
+        KeyParameter key_parameter = new KeyParameter(key_block, key_offset, key_size);
+        ParametersWithIV parameters_with_iv = new ParametersWithIV(key_parameter, key_block,
+            iv_offset, cipher.getBlockSize());
+        cipher.init(forEncryption, parameters_with_iv);
+    }
+
+    public byte[] encodePlaintext(short type, byte[] plaintext, int offset, int len)
+    {
+        int blocksize = encryptCipher.getBlockSize();
+
+        // Add a random number of extra blocks worth of padding
+        int minPaddingSize = blocksize - ((len + writeMac.getSize() + 1) % blocksize);
+        int maxExtraPadBlocks = (255 - minPaddingSize) / blocksize;
+        int actualExtraPadBlocks = chooseExtraPadBlocks(context.getSecureRandom(), maxExtraPadBlocks);
+        int paddingsize = minPaddingSize + (actualExtraPadBlocks * blocksize);
+
+        int totalsize = len + writeMac.getSize() + paddingsize + 1;
+        byte[] outbuf = new byte[totalsize];
+        System.arraycopy(plaintext, offset, outbuf, 0, len);
+        byte[] mac = writeMac.calculateMac(type, plaintext, offset, len);
+        System.arraycopy(mac, 0, outbuf, len, mac.length);
+        int paddoffset = len + mac.length;
+        for (int i = 0; i <= paddingsize; i++)
+        {
+            outbuf[i + paddoffset] = (byte)paddingsize;
+        }
+        for (int i = 0; i < totalsize; i += blocksize)
+        {
+            encryptCipher.processBlock(outbuf, i, outbuf, i);
+        }
+        return outbuf;
+    }
+
+    public byte[] decodeCiphertext(short type, byte[] ciphertext, int offset, int len)
+        throws IOException
+    {
+        // TODO TLS 1.1 (RFC 4346) introduces an explicit IV
+
+        int minLength = readMac.getSize() + 1;
+        int blocksize = decryptCipher.getBlockSize();
+        boolean decrypterror = false;
+
+        /*
+         * ciphertext must be at least (macsize + 1) bytes long
+         */
+        if (len < minLength)
+        {
+            throw new TlsFatalAlert(AlertDescription.decode_error);
+        }
+
+        /*
+         * ciphertext must be a multiple of blocksize
+         */
+        if (len % blocksize != 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.decryption_failed);
+        }
+
+        /*
+         * Decrypt all the ciphertext using the blockcipher
+         */
+        for (int i = 0; i < len; i += blocksize)
+        {
+            decryptCipher.processBlock(ciphertext, i + offset, ciphertext, i + offset);
+        }
+
+        /*
+         * Check if padding is correct
+         */
+        int lastByteOffset = offset + len - 1;
+
+        byte paddingsizebyte = ciphertext[lastByteOffset];
+
+        // Note: interpret as unsigned byte
+        int paddingsize = paddingsizebyte & 0xff;
+
+        int maxPaddingSize = len - minLength;
+        if (paddingsize > maxPaddingSize)
+        {
+            decrypterror = true;
+            paddingsize = 0;
+        }
+        else
+        {
+            /*
+             * Now, check all the padding-bytes (constant-time comparison).
+             */
+            byte diff = 0;
+            for (int i = lastByteOffset - paddingsize; i < lastByteOffset; ++i)
+            {
+                diff |= (ciphertext[i] ^ paddingsizebyte);
+            }
+            if (diff != 0)
+            {
+                /* Wrong padding */
+                decrypterror = true;
+                paddingsize = 0;
+            }
+        }
+
+        /*
+         * We now don't care if padding verification has failed or not, we will calculate
+         * the mac to give an attacker no kind of timing profile he can use to find out if
+         * mac verification failed or padding verification failed.
+         */
+        int plaintextlength = len - minLength - paddingsize;
+        byte[] calculatedMac = readMac.calculateMac(type, ciphertext, offset, plaintextlength);
+
+        /*
+         * Check all bytes in the mac (constant-time comparison).
+         */
+        byte[] decryptedMac = new byte[calculatedMac.length];
+        System.arraycopy(ciphertext, offset + plaintextlength, decryptedMac, 0,
+            calculatedMac.length);
+
+        if (!Arrays.constantTimeAreEqual(calculatedMac, decryptedMac))
+        {
+            decrypterror = true;
+        }
+
+        /*
+         * Now, it is safe to fail.
+         */
+        if (decrypterror)
+        {
+            throw new TlsFatalAlert(AlertDescription.bad_record_mac);
+        }
+
+        byte[] plaintext = new byte[plaintextlength];
+        System.arraycopy(ciphertext, offset, plaintext, 0, plaintextlength);
+        return plaintext;
+    }
+
+    protected int chooseExtraPadBlocks(SecureRandom r, int max)
+    {
+//        return r.nextInt(max + 1);
+
+        int x = r.nextInt();
+        int n = lowestBitSet(x);
+        return Math.min(n, max);
+    }
+
+    protected int lowestBitSet(int x)
+    {
+        if (x == 0)
+        {
+            return 32;
+        }
+
+        int n = 0;
+        while ((x & 1) == 0)
+        {
+            ++n;
+            x >>= 1;
+        }
+        return n;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsCipher
+{
+    byte[] encodePlaintext(short type, byte[] plaintext, int offset, int len) throws IOException;
+
+    byte[] decodeCiphertext(short type, byte[] ciphertext, int offset, int len) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,11 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsCipherFactory
+{
+    /**
+     * See enumeration classes EncryptionAlgorithm and DigestAlgorithm for appropriate argument values
+     */
+    TlsCipher createCipher(TlsClientContext context, int encryptionAlgorithm, int digestAlgorithm) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClient.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsClient.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsClient.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,35 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+
+public interface TlsClient
+{
+    void init(TlsClientContext context);
+
+    int[] getCipherSuites();
+
+    short[] getCompressionMethods();
+
+    // Hashtable is (Integer -> byte[])
+    Hashtable getClientExtensions() throws IOException;
+
+    void notifySessionID(byte[] sessionID);
+
+    void notifySelectedCipherSuite(int selectedCipherSuite);
+
+    void notifySelectedCompressionMethod(short selectedCompressionMethod);
+
+    void notifySecureRenegotiation(boolean secureNegotiation) throws IOException;
+
+    // Hashtable is (Integer -> byte[])
+    void processServerExtensions(Hashtable serverExtensions);
+
+    TlsKeyExchange getKeyExchange() throws IOException;
+
+    TlsAuthentication getAuthentication() throws IOException;
+
+    TlsCompression getCompression() throws IOException;
+
+    TlsCipher getCipher() throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,14 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+public interface TlsClientContext
+{
+    SecureRandom getSecureRandom();
+
+    SecurityParameters getSecurityParameters();
+
+    Object getUserObject();
+
+    void setUserObject(Object userObject);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+class TlsClientContextImpl implements TlsClientContext
+{
+    private SecureRandom secureRandom;
+    private SecurityParameters securityParameters;
+
+    private Object userObject = null;
+
+    TlsClientContextImpl(SecureRandom secureRandom, SecurityParameters securityParameters)
+    {
+        this.secureRandom = secureRandom;
+        this.securityParameters = securityParameters;
+    }
+
+    public SecureRandom getSecureRandom()
+    {
+        return secureRandom;
+    }
+
+    public SecurityParameters getSecurityParameters()
+    {
+        return securityParameters;
+    }
+
+    public Object getUserObject()
+    {
+        return userObject;
+    }
+
+    public void setUserObject(Object userObject)
+    {
+        this.userObject = userObject;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.OutputStream;
+
+public interface TlsCompression
+{
+    OutputStream compress(OutputStream output);
+
+    OutputStream decompress(OutputStream output);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,6 @@
+package org.bouncycastle.crypto.tls;
+
+public interface TlsCredentials
+{
+    Certificate getCertificate();
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,57 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.io.SignerInputStream;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+
+class TlsDHEKeyExchange extends TlsDHKeyExchange
+{
+    TlsDHEKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        super(context, keyExchange);
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        SecurityParameters securityParameters = context.getSecurityParameters();
+
+        Signer signer = initSigner(tlsSigner, securityParameters);
+        InputStream sigIn = new SignerInputStream(is, signer);
+
+        byte[] pBytes = TlsUtils.readOpaque16(sigIn);
+        byte[] gBytes = TlsUtils.readOpaque16(sigIn);
+        byte[] YsBytes = TlsUtils.readOpaque16(sigIn);
+
+        byte[] sigByte = TlsUtils.readOpaque16(is);
+        if (!signer.verifySignature(sigByte))
+        {
+            throw new TlsFatalAlert(AlertDescription.bad_certificate);
+        }
+
+        BigInteger p = new BigInteger(1, pBytes);
+        BigInteger g = new BigInteger(1, gBytes);
+        BigInteger Ys = new BigInteger(1, YsBytes);
+
+        this.dhAgreeServerPublicKey = validateDHPublicKey(new DHPublicKeyParameters(Ys,
+            new DHParameters(p, g)));
+    }
+
+    protected Signer initSigner(TlsSigner tlsSigner, SecurityParameters securityParameters)
+    {
+        Signer signer = tlsSigner.createVerifyer(this.serverPublicKey);
+        signer.update(securityParameters.clientRandom, 0, securityParameters.clientRandom.length);
+        signer.update(securityParameters.serverRandom, 0, securityParameters.serverRandom.length);
+        return signer;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,250 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.agreement.DHBasicAgreement;
+import org.bouncycastle.crypto.generators.DHBasicKeyPairGenerator;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.DHKeyGenerationParameters;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.util.PublicKeyFactory;
+import org.bouncycastle.util.BigIntegers;
+
+/**
+ * TLS 1.0 DH key exchange.
+ */
+class TlsDHKeyExchange implements TlsKeyExchange
+{
+    protected static final BigInteger ONE = BigInteger.valueOf(1);
+    protected static final BigInteger TWO = BigInteger.valueOf(2);
+
+    protected TlsClientContext context;
+    protected int keyExchange;
+    protected TlsSigner tlsSigner;
+
+    protected AsymmetricKeyParameter serverPublicKey = null;
+    protected DHPublicKeyParameters dhAgreeServerPublicKey = null;
+    protected TlsAgreementCredentials agreementCredentials;
+    protected DHPrivateKeyParameters dhAgreeClientPrivateKey = null;
+
+    TlsDHKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        switch (keyExchange)
+        {
+            case KeyExchangeAlgorithm.DH_RSA:
+            case KeyExchangeAlgorithm.DH_DSS:
+                this.tlsSigner = null;
+                break;
+            case KeyExchangeAlgorithm.DHE_RSA:
+                this.tlsSigner = new TlsRSASigner();
+                break;
+            case KeyExchangeAlgorithm.DHE_DSS:
+                this.tlsSigner = new TlsDSSSigner();
+                break;
+            default:
+                throw new IllegalArgumentException("unsupported key exchange algorithm");
+        }
+
+        this.context = context;
+        this.keyExchange = keyExchange;
+    }
+
+    public void skipServerCertificate() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        X509CertificateStructure x509Cert = serverCertificate.certs[0];
+        SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();
+
+        try
+        {
+            this.serverPublicKey = PublicKeyFactory.createKey(keyInfo);
+        }
+        catch (RuntimeException e)
+        {
+            throw new TlsFatalAlert(AlertDescription.unsupported_certificate);
+        }
+
+        if (tlsSigner == null)
+        {
+            try
+            {
+                this.dhAgreeServerPublicKey = validateDHPublicKey((DHPublicKeyParameters)this.serverPublicKey);
+            }
+            catch (ClassCastException e)
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.keyAgreement);
+        }
+        else
+        {
+            if (!tlsSigner.isValidPublicKey(this.serverPublicKey))
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.digitalSignature);
+        }
+
+        // TODO 
+        /*
+         * Perform various checks per RFC2246 7.4.2: "Unless otherwise specified, the
+         * signing algorithm for the certificate must be the same as the algorithm for the
+         * certificate key."
+         */
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        // OK
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i < types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.rsa_fixed_dh:
+                case ClientCertificateType.dss_fixed_dh:
+                case ClientCertificateType.ecdsa_sign:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void skipClientCredentials() throws IOException
+    {
+        this.agreementCredentials = null;
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (clientCredentials instanceof TlsAgreementCredentials)
+        {
+            // TODO Validate client cert has matching parameters (see 'areCompatibleParameters')?
+
+            this.agreementCredentials = (TlsAgreementCredentials)clientCredentials;
+        }
+        else if (clientCredentials instanceof TlsSignerCredentials)
+        {
+            // OK
+        }
+        else
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public void generateClientKeyExchange(OutputStream os) throws IOException
+    {
+        /*
+         * RFC 2246 7.4.7.2 If the client certificate already contains a suitable
+         * Diffie-Hellman key, then Yc is implicit and does not need to be sent again. In
+         * this case, the Client Key Exchange message will be sent, but will be empty.
+         */
+        if (agreementCredentials != null)
+        {
+            TlsUtils.writeUint24(0, os);
+        }
+        else
+        {
+            generateEphemeralClientKeyExchange(dhAgreeServerPublicKey.getParameters(), os);
+        }
+    }
+
+    public byte[] generatePremasterSecret() throws IOException
+    {
+        if (agreementCredentials != null)
+        {
+            return agreementCredentials.generateAgreement(dhAgreeServerPublicKey);
+        }
+
+        return calculateDHBasicAgreement(dhAgreeServerPublicKey, dhAgreeClientPrivateKey);
+    }
+
+    protected boolean areCompatibleParameters(DHParameters a, DHParameters b)
+    {
+        return a.getP().equals(b.getP()) && a.getG().equals(b.getG());
+    }
+
+    protected byte[] calculateDHBasicAgreement(DHPublicKeyParameters publicKey,
+        DHPrivateKeyParameters privateKey)
+    {
+        DHBasicAgreement dhAgree = new DHBasicAgreement();
+        dhAgree.init(dhAgreeClientPrivateKey);
+        BigInteger agreement = dhAgree.calculateAgreement(dhAgreeServerPublicKey);
+        return BigIntegers.asUnsignedByteArray(agreement);
+    }
+
+    protected AsymmetricCipherKeyPair generateDHKeyPair(DHParameters dhParams)
+    {
+        DHBasicKeyPairGenerator dhGen = new DHBasicKeyPairGenerator();
+        dhGen.init(new DHKeyGenerationParameters(context.getSecureRandom(), dhParams));
+        return dhGen.generateKeyPair();
+    }
+
+    protected void generateEphemeralClientKeyExchange(DHParameters dhParams, OutputStream os)
+        throws IOException
+    {
+        AsymmetricCipherKeyPair dhAgreeClientKeyPair = generateDHKeyPair(dhParams);
+        this.dhAgreeClientPrivateKey = (DHPrivateKeyParameters)dhAgreeClientKeyPair.getPrivate();
+
+        BigInteger Yc = ((DHPublicKeyParameters)dhAgreeClientKeyPair.getPublic()).getY();
+        byte[] keData = BigIntegers.asUnsignedByteArray(Yc);
+        TlsUtils.writeUint24(keData.length + 2, os);
+        TlsUtils.writeOpaque16(keData, os);
+    }
+
+    protected DHPublicKeyParameters validateDHPublicKey(DHPublicKeyParameters key)
+        throws IOException
+    {
+        BigInteger Y = key.getY();
+        DHParameters params = key.getParameters();
+        BigInteger p = params.getP();
+        BigInteger g = params.getG();
+
+        if (!p.isProbablePrime(2))
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+        if (g.compareTo(TWO) < 0 || g.compareTo(p.subtract(TWO)) > 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+        if (Y.compareTo(TWO) < 0 || Y.compareTo(p.subtract(ONE)) > 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+
+        // TODO See RFC 2631 for more discussion of Diffie-Hellman validation
+
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,34 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.digests.NullDigest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.signers.DSADigestSigner;
+
+abstract class TlsDSASigner implements TlsSigner
+{
+    public byte[] calculateRawSignature(SecureRandom secureRandom, AsymmetricKeyParameter privateKey, byte[] md5andsha1)
+        throws CryptoException
+    {
+        // Note: Only use the SHA1 part of the hash
+        Signer signer = new DSADigestSigner(createDSAImpl(), new NullDigest());
+        signer.init(true, new ParametersWithRandom(privateKey, secureRandom));
+        signer.update(md5andsha1, 16, 20);
+        return signer.generateSignature();
+    }
+
+    public Signer createVerifyer(AsymmetricKeyParameter publicKey)
+    {
+        Signer verifyer = new DSADigestSigner(createDSAImpl(), new SHA1Digest());
+        verifyer.init(false, publicKey);
+        return verifyer;
+    }
+
+    protected abstract DSA createDSAImpl();
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.DSAPublicKeyParameters;
+import org.bouncycastle.crypto.signers.DSASigner;
+
+class TlsDSSSigner extends TlsDSASigner
+{
+    public boolean isValidPublicKey(AsymmetricKeyParameter publicKey)
+    {
+        return publicKey instanceof DSAPublicKeyParameters;
+    }
+
+    protected DSA createDSAImpl()
+    {
+        return new DSASigner();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,112 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.io.SignerInputStream;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.math.ec.ECPoint;
+
+/**
+ * ECDHE key exchange (see RFC 4492)
+ */
+class TlsECDHEKeyExchange extends TlsECDHKeyExchange
+{
+    TlsECDHEKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        super(context, keyExchange);
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        SecurityParameters securityParameters = context.getSecurityParameters();
+
+        Signer signer = initSigner(tlsSigner, securityParameters);
+        InputStream sigIn = new SignerInputStream(is, signer);
+
+        short curveType = TlsUtils.readUint8(sigIn);
+        ECDomainParameters curve_params;
+
+        //  Currently, we only support named curves
+        if (curveType == ECCurveType.named_curve)
+        {
+            int namedCurve = TlsUtils.readUint16(sigIn);
+
+            // TODO Check namedCurve is one we offered?
+
+            curve_params = NamedCurve.getECParameters(namedCurve);
+        }
+        else
+        {
+            // TODO Add support for explicit curve parameters (read from sigIn)
+
+            throw new TlsFatalAlert(AlertDescription.handshake_failure);
+        }
+
+        byte[] publicBytes = TlsUtils.readOpaque8(sigIn);
+
+        byte[] sigByte = TlsUtils.readOpaque16(is);
+        if (!signer.verifySignature(sigByte))
+        {
+            throw new TlsFatalAlert(AlertDescription.bad_certificate);
+        }
+
+        // TODO Check curve_params not null
+
+        ECPoint Q = curve_params.getCurve().decodePoint(publicBytes);
+
+        this.ecAgreeServerPublicKey = validateECPublicKey(new ECPublicKeyParameters(Q, curve_params));
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        /*
+         * RFC 4492 3. [...] The ECDSA_fixed_ECDH and RSA_fixed_ECDH mechanisms are usable
+         * with ECDH_ECDSA and ECDH_RSA. Their use with ECDHE_ECDSA and ECDHE_RSA is
+         * prohibited because the use of a long-term ECDH client key would jeopardize the
+         * forward secrecy property of these algorithms.
+         */
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i < types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.ecdsa_sign:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (clientCredentials instanceof TlsSignerCredentials)
+        {
+            // OK
+        }
+        else
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    protected Signer initSigner(TlsSigner tlsSigner, SecurityParameters securityParameters)
+    {
+        Signer signer = tlsSigner.createVerifyer(this.serverPublicKey);
+        signer.update(securityParameters.clientRandom, 0, securityParameters.clientRandom.length);
+        signer.update(securityParameters.serverRandom, 0, securityParameters.serverRandom.length);
+        return signer;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,245 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement;
+import org.bouncycastle.crypto.generators.ECKeyPairGenerator;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECKeyGenerationParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.util.PublicKeyFactory;
+import org.bouncycastle.util.BigIntegers;
+
+/**
+ * ECDH key exchange (see RFC 4492)
+ */
+class TlsECDHKeyExchange implements TlsKeyExchange
+{
+    protected TlsClientContext context;
+    protected int keyExchange;
+    protected TlsSigner tlsSigner;
+
+    protected AsymmetricKeyParameter serverPublicKey;
+    protected ECPublicKeyParameters ecAgreeServerPublicKey;
+    protected TlsAgreementCredentials agreementCredentials;
+    protected ECPrivateKeyParameters ecAgreeClientPrivateKey = null;
+
+    TlsECDHKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        switch (keyExchange)
+        {
+            case KeyExchangeAlgorithm.ECDHE_RSA:
+                this.tlsSigner = new TlsRSASigner();
+                break;
+            case KeyExchangeAlgorithm.ECDHE_ECDSA:
+                this.tlsSigner = new TlsECDSASigner();
+                break;
+            case KeyExchangeAlgorithm.ECDH_RSA:
+            case KeyExchangeAlgorithm.ECDH_ECDSA:
+                this.tlsSigner = null;
+                break;
+            default:
+                throw new IllegalArgumentException("unsupported key exchange algorithm");
+        }
+
+        this.context = context;
+        this.keyExchange = keyExchange;
+    }
+
+    public void skipServerCertificate() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        X509CertificateStructure x509Cert = serverCertificate.certs[0];
+        SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();
+
+        try
+        {
+            this.serverPublicKey = PublicKeyFactory.createKey(keyInfo);
+        }
+        catch (RuntimeException e)
+        {
+            throw new TlsFatalAlert(AlertDescription.unsupported_certificate);
+        }
+
+        if (tlsSigner == null)
+        {
+            try
+            {
+                this.ecAgreeServerPublicKey = validateECPublicKey((ECPublicKeyParameters)this.serverPublicKey);
+            }
+            catch (ClassCastException e)
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.keyAgreement);
+        }
+        else
+        {
+            if (!tlsSigner.isValidPublicKey(this.serverPublicKey))
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.digitalSignature);
+        }
+        
+        // TODO 
+        /*
+         * Perform various checks per RFC2246 7.4.2: "Unless otherwise specified, the
+         * signing algorithm for the certificate must be the same as the algorithm for the
+         * certificate key."
+         */
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        // do nothing
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        /*
+         * RFC 4492 3. [...] The ECDSA_fixed_ECDH and RSA_fixed_ECDH mechanisms are usable
+         * with ECDH_ECDSA and ECDH_RSA. Their use with ECDHE_ECDSA and ECDHE_RSA is
+         * prohibited because the use of a long-term ECDH client key would jeopardize the
+         * forward secrecy property of these algorithms.
+         */
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i < types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.ecdsa_sign:
+                case ClientCertificateType.rsa_fixed_ecdh:
+                case ClientCertificateType.ecdsa_fixed_ecdh:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void skipClientCredentials() throws IOException
+    {
+        this.agreementCredentials = null;
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (clientCredentials instanceof TlsAgreementCredentials)
+        {
+            // TODO Validate client cert has matching parameters (see 'areOnSameCurve')?
+
+            this.agreementCredentials = (TlsAgreementCredentials)clientCredentials;
+        }
+        else if (clientCredentials instanceof TlsSignerCredentials)
+        {
+            // OK
+        }
+        else
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public void generateClientKeyExchange(OutputStream os) throws IOException
+    {
+        if (agreementCredentials != null)
+        {
+            TlsUtils.writeUint24(0, os);
+        }
+        else
+        {
+            generateEphemeralClientKeyExchange(ecAgreeServerPublicKey.getParameters(), os);
+        }
+    }
+
+    public byte[] generatePremasterSecret() throws IOException
+    {
+        if (agreementCredentials != null)
+        {
+            return agreementCredentials.generateAgreement(ecAgreeServerPublicKey);
+        }
+
+        return calculateECDHBasicAgreement(ecAgreeServerPublicKey, ecAgreeClientPrivateKey);
+    }
+
+    protected boolean areOnSameCurve(ECDomainParameters a, ECDomainParameters b)
+    {
+        // TODO Move to ECDomainParameters.equals() or other utility method?
+        return a.getCurve().equals(b.getCurve()) && a.getG().equals(b.getG())
+            && a.getN().equals(b.getN()) && a.getH().equals(b.getH());
+    }
+
+    protected byte[] externalizeKey(ECPublicKeyParameters keyParameters) throws IOException
+    {
+        // TODO Add support for compressed encoding and SPF extension
+
+        /*
+         * RFC 4492 5.7. ...an elliptic curve point in uncompressed or compressed format.
+         * Here, the format MUST conform to what the server has requested through a
+         * Supported Point Formats Extension if this extension was used, and MUST be
+         * uncompressed if this extension was not used.
+         */
+        return keyParameters.getQ().getEncoded();
+    }
+
+    protected AsymmetricCipherKeyPair generateECKeyPair(ECDomainParameters ecParams)
+    {
+        ECKeyPairGenerator keyPairGenerator = new ECKeyPairGenerator();
+        ECKeyGenerationParameters keyGenerationParameters = new ECKeyGenerationParameters(ecParams,
+            context.getSecureRandom());
+        keyPairGenerator.init(keyGenerationParameters);
+        return keyPairGenerator.generateKeyPair();
+    }
+
+    protected void generateEphemeralClientKeyExchange(ECDomainParameters ecParams, OutputStream os)
+        throws IOException
+    {
+        AsymmetricCipherKeyPair ecAgreeClientKeyPair = generateECKeyPair(ecParams);
+        this.ecAgreeClientPrivateKey = (ECPrivateKeyParameters)ecAgreeClientKeyPair.getPrivate();
+
+        byte[] keData = externalizeKey((ECPublicKeyParameters)ecAgreeClientKeyPair.getPublic());
+        TlsUtils.writeUint24(keData.length + 1, os);
+        TlsUtils.writeOpaque8(keData, os);
+    }
+
+    protected byte[] calculateECDHBasicAgreement(ECPublicKeyParameters publicKey,
+        ECPrivateKeyParameters privateKey)
+    {
+        ECDHBasicAgreement basicAgreement = new ECDHBasicAgreement();
+        basicAgreement.init(privateKey);
+        BigInteger agreement = basicAgreement.calculateAgreement(publicKey);
+        return BigIntegers.asUnsignedByteArray(agreement);
+    }
+
+    protected ECPublicKeyParameters validateECPublicKey(ECPublicKeyParameters key)
+        throws IOException
+    {
+        // TODO Check RFC 4492 for validation
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.signers.ECDSASigner;
+
+class TlsECDSASigner extends TlsDSASigner
+{
+    public boolean isValidPublicKey(AsymmetricKeyParameter publicKey)
+    {
+        return publicKey instanceof ECPublicKeyParameters;
+    }
+
+    protected DSA createDSAImpl()
+    {
+        return new ECDSASigner();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,20 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public class TlsFatalAlert extends IOException
+{
+    private static final long serialVersionUID = 3584313123679111168L;
+
+    private short alertDescription;
+
+    public TlsFatalAlert(short alertDescription)
+    {
+        this.alertDescription = alertDescription;
+    }
+
+    public short getAlertDescription()
+    {
+        return alertDescription;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+/**
+ * An InputStream for an TLS 1.0 connection.
+ */
+class TlsInputStream extends InputStream
+{
+    private byte[] buf = new byte[1];
+    private TlsProtocolHandler handler = null;
+
+    TlsInputStream(TlsProtocolHandler handler)
+    {
+        this.handler = handler;
+    }
+
+    public int read(byte[] buf, int offset, int len) throws IOException
+    {
+        return this.handler.readApplicationData(buf, offset, len);
+    }
+
+    public int read() throws IOException
+    {
+        if (this.read(buf) < 0)
+        {
+            return -1;
+        }
+        return buf[0] & 0xff;
+    }
+
+    public void close() throws IOException
+    {
+        handler.close();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+/**
+ * A generic interface for key exchange implementations in TLS 1.0.
+ */
+public interface TlsKeyExchange
+{
+    void skipServerCertificate() throws IOException;
+
+    void processServerCertificate(Certificate serverCertificate) throws IOException;
+
+    void skipServerKeyExchange() throws IOException;
+
+    void processServerKeyExchange(InputStream is)
+        throws IOException;
+
+    void validateCertificateRequest(CertificateRequest certificateRequest) throws IOException;
+
+    void skipClientCredentials() throws IOException;
+
+    void processClientCredentials(TlsCredentials clientCredentials) throws IOException;
+
+    void generateClientKeyExchange(OutputStream os) throws IOException;
+
+    byte[] generatePremasterSecret() throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsMac.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsMac.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsMac.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,78 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.macs.HMac;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * A generic TLS MAC implementation, which can be used with any kind of Digest to act as
+ * an HMAC.
+ */
+public class TlsMac
+{
+    protected long seqNo;
+    protected HMac mac;
+
+    /**
+     * Generate a new instance of an TlsMac.
+     * 
+     * @param digest The digest to use.
+     * @param key_block A byte-array where the key for this mac is located.
+     * @param offset The number of bytes to skip, before the key starts in the buffer.
+     * @param len The length of the key.
+     */
+    public TlsMac(Digest digest, byte[] key_block, int offset, int len)
+    {
+        this.mac = new HMac(digest);
+        KeyParameter param = new KeyParameter(key_block, offset, len);
+        this.mac.init(param);
+        this.seqNo = 0;
+    }
+
+    /**
+     * @return The Keysize of the mac.
+     */
+    public int getSize()
+    {
+        return mac.getMacSize();
+    }
+
+    /**
+     * Calculate the mac for some given data.
+     * <p/>
+     * TlsMac will keep track of the sequence number internally.
+     * 
+     * @param type The message type of the message.
+     * @param message A byte-buffer containing the message.
+     * @param offset The number of bytes to skip, before the message starts.
+     * @param len The length of the message.
+     * @return A new byte-buffer containing the mac value.
+     */
+    public byte[] calculateMac(short type, byte[] message, int offset, int len)
+    {
+        ByteArrayOutputStream bosMac = new ByteArrayOutputStream(13);
+        try
+        {
+            TlsUtils.writeUint64(seqNo++, bosMac);
+            TlsUtils.writeUint8(type, bosMac);
+            TlsUtils.writeVersion(bosMac);
+            TlsUtils.writeUint16(len, bosMac);
+        }
+        catch (IOException e)
+        {
+            // This should never happen
+            throw new IllegalStateException("Internal error during mac calculation");
+        }
+
+        byte[] macHeader = bosMac.toByteArray();
+        mac.update(macHeader, 0, macHeader.length);
+        mac.update(message, offset, len);
+
+        byte[] result = new byte[mac.getMacSize()];
+        mac.doFinal(result, 0);
+        return result;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,24 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * A NULL CipherSuite in java, this should only be used during handshake.
+ */
+public class TlsNullCipher implements TlsCipher
+{
+    public byte[] encodePlaintext(short type, byte[] plaintext, int offset, int len)
+    {
+        return copyData(plaintext, offset, len);
+    }
+
+    public byte[] decodeCiphertext(short type, byte[] ciphertext, int offset, int len)
+    {
+        return copyData(ciphertext, offset, len);
+    }
+
+    protected byte[] copyData(byte[] text, int offset, int len)
+    {
+        byte[] result = new byte[len];
+        System.arraycopy(text, offset, result, 0, len);
+        return result;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,16 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.OutputStream;
+
+public class TlsNullCompression implements TlsCompression
+{
+    public OutputStream compress(OutputStream output)
+    {
+        return output;
+    }
+
+    public OutputStream decompress(OutputStream output)
+    {
+        return output;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+/**
+ * An OutputStream for an TLS connection.
+ */
+class TlsOutputStream extends OutputStream
+{
+    private byte[] buf = new byte[1];
+    private TlsProtocolHandler handler;
+
+    TlsOutputStream(TlsProtocolHandler handler)
+    {
+        this.handler = handler;
+    }
+
+    public void write(byte buf[], int offset, int len) throws IOException
+    {
+        this.handler.writeData(buf, offset, len);
+    }
+
+    public void write(int arg0) throws IOException
+    {
+        buf[0] = (byte)arg0;
+        this.write(buf, 0, 1);
+    }
+
+    public void close() throws IOException
+    {
+        handler.close();
+    }
+
+    public void flush() throws IOException
+    {
+        handler.flush();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1210 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.security.SecureRandom;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.x500.X500Name;
+import org.bouncycastle.crypto.prng.ThreadedSeedGenerator;
+import org.bouncycastle.util.Arrays;
+
+/**
+ * An implementation of all high level protocols in TLS 1.0.
+ */
+public class TlsProtocolHandler
+{
+    private static final Integer EXT_RenegotiationInfo = new Integer(ExtensionType.renegotiation_info);
+
+    /*
+     * Our Connection states
+     */
+    private static final short CS_CLIENT_HELLO_SEND = 1;
+    private static final short CS_SERVER_HELLO_RECEIVED = 2;
+    private static final short CS_SERVER_CERTIFICATE_RECEIVED = 3;
+    private static final short CS_SERVER_KEY_EXCHANGE_RECEIVED = 4;
+    private static final short CS_CERTIFICATE_REQUEST_RECEIVED = 5;
+    private static final short CS_SERVER_HELLO_DONE_RECEIVED = 6;
+    private static final short CS_CLIENT_KEY_EXCHANGE_SEND = 7;
+    private static final short CS_CERTIFICATE_VERIFY_SEND = 8;
+    private static final short CS_CLIENT_CHANGE_CIPHER_SPEC_SEND = 9;
+    private static final short CS_CLIENT_FINISHED_SEND = 10;
+    private static final short CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED = 11;
+    private static final short CS_DONE = 12;
+
+    private static final byte[] emptybuf = new byte[0];
+
+    private static final String TLS_ERROR_MESSAGE = "Internal TLS error, this could be an attack";
+
+    /*
+     * Queues for data from some protocols.
+     */
+    private ByteQueue applicationDataQueue = new ByteQueue();
+    private ByteQueue changeCipherSpecQueue = new ByteQueue();
+    private ByteQueue alertQueue = new ByteQueue();
+    private ByteQueue handshakeQueue = new ByteQueue();
+
+    /*
+     * The Record Stream we use
+     */
+    private RecordStream rs;
+    private SecureRandom random;
+
+    private TlsInputStream tlsInputStream = null;
+    private TlsOutputStream tlsOutputStream = null;
+
+    private boolean closed = false;
+    private boolean failedWithError = false;
+    private boolean appDataReady = false;
+    private Hashtable clientExtensions;
+
+    private SecurityParameters securityParameters = null;
+
+    private TlsClientContextImpl tlsClientContext = null;
+    private TlsClient tlsClient = null;
+    private int[] offeredCipherSuites = null;
+    private short[] offeredCompressionMethods = null;
+    private TlsKeyExchange keyExchange = null;
+    private TlsAuthentication authentication = null;
+    private CertificateRequest certificateRequest = null;
+
+    private short connection_state = 0;
+
+    private static SecureRandom createSecureRandom()
+    {
+        /*
+         * We use our threaded seed generator to generate a good random seed. If the user
+         * has a better random seed, he should use the constructor with a SecureRandom.
+         */
+        ThreadedSeedGenerator tsg = new ThreadedSeedGenerator();
+        SecureRandom random = new SecureRandom();
+
+        /*
+         * Hopefully, 20 bytes in fast mode are good enough.
+         */
+        random.setSeed(tsg.generateSeed(20, true));
+
+        return random;
+    }
+
+    public TlsProtocolHandler(InputStream is, OutputStream os)
+    {
+        this(is, os, createSecureRandom());
+    }
+
+    public TlsProtocolHandler(InputStream is, OutputStream os, SecureRandom sr)
+    {
+        this.rs = new RecordStream(this, is, os);
+        this.random = sr;
+    }
+
+    protected void processData(short protocol, byte[] buf, int offset, int len) throws IOException
+    {
+        /*
+         * Have a look at the protocol type, and add it to the correct queue.
+         */
+        switch (protocol)
+        {
+            case ContentType.change_cipher_spec:
+                changeCipherSpecQueue.addData(buf, offset, len);
+                processChangeCipherSpec();
+                break;
+            case ContentType.alert:
+                alertQueue.addData(buf, offset, len);
+                processAlert();
+                break;
+            case ContentType.handshake:
+                handshakeQueue.addData(buf, offset, len);
+                processHandshake();
+                break;
+            case ContentType.application_data:
+                if (!appDataReady)
+                {
+                    this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+                applicationDataQueue.addData(buf, offset, len);
+                processApplicationData();
+                break;
+            default:
+                /*
+                 * Uh, we don't know this protocol.
+                 *
+                 * RFC2246 defines on page 13, that we should ignore this.
+                 */
+        }
+    }
+
+    private void processHandshake() throws IOException
+    {
+        boolean read;
+        do
+        {
+            read = false;
+            /*
+             * We need the first 4 bytes, they contain type and length of the message.
+             */
+            if (handshakeQueue.size() >= 4)
+            {
+                byte[] beginning = new byte[4];
+                handshakeQueue.read(beginning, 0, 4, 0);
+                ByteArrayInputStream bis = new ByteArrayInputStream(beginning);
+                short type = TlsUtils.readUint8(bis);
+                int len = TlsUtils.readUint24(bis);
+
+                /*
+                 * Check if we have enough bytes in the buffer to read the full message.
+                 */
+                if (handshakeQueue.size() >= (len + 4))
+                {
+                    /*
+                     * Read the message.
+                     */
+                    byte[] buf = new byte[len];
+                    handshakeQueue.read(buf, 0, len, 4);
+                    handshakeQueue.removeData(len + 4);
+
+                    /*
+                     * RFC 2246 7.4.9. The value handshake_messages includes all handshake
+                     * messages starting at client hello up to, but not including, this
+                     * finished message. [..] Note: [Also,] Hello Request messages are
+                     * omitted from handshake hashes.
+                     */
+                    switch (type)
+                    {
+                        case HandshakeType.hello_request:
+                        case HandshakeType.finished:
+                            break;
+                        default:
+                            rs.updateHandshakeData(beginning, 0, 4);
+                            rs.updateHandshakeData(buf, 0, len);
+                            break;
+                    }
+
+                    /*
+                     * Now, parse the message.
+                     */
+                    processHandshakeMessage(type, buf);
+                    read = true;
+                }
+            }
+        }
+        while (read);
+    }
+
+    private void processHandshakeMessage(short type, byte[] buf) throws IOException
+    {
+        ByteArrayInputStream is = new ByteArrayInputStream(buf);
+
+        switch (type)
+        {
+            case HandshakeType.certificate:
+            {
+                switch (connection_state)
+                {
+                    case CS_SERVER_HELLO_RECEIVED:
+                    {
+                        // Parse the Certificate message and send to cipher suite
+
+                        Certificate serverCertificate = Certificate.parse(is);
+
+                        assertEmpty(is);
+
+                        this.keyExchange.processServerCertificate(serverCertificate);
+
+                        this.authentication = tlsClient.getAuthentication();
+                        this.authentication.notifyServerCertificate(serverCertificate);
+
+                        break;
+                    }
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+
+                connection_state = CS_SERVER_CERTIFICATE_RECEIVED;
+                break;
+            }
+            case HandshakeType.finished:
+                switch (connection_state)
+                {
+                    case CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED:
+                        /*
+                         * Read the checksum from the finished message, it has always 12
+                         * bytes.
+                         */
+                        byte[] serverVerifyData = new byte[12];
+                        TlsUtils.readFully(serverVerifyData, is);
+
+                        assertEmpty(is);
+
+                        /*
+                         * Calculate our own checksum.
+                         */
+                        byte[] expectedServerVerifyData = TlsUtils.PRF(
+                            securityParameters.masterSecret, "server finished",
+                            rs.getCurrentHash(), 12);
+
+                        /*
+                         * Compare both checksums.
+                         */
+                        if (!Arrays.constantTimeAreEqual(expectedServerVerifyData, serverVerifyData))
+                        {
+                            /*
+                             * Wrong checksum in the finished message.
+                             */
+                            this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+                        }
+
+                        connection_state = CS_DONE;
+
+                        /*
+                         * We are now ready to receive application data.
+                         */
+                        this.appDataReady = true;
+                        break;
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+                break;
+            case HandshakeType.server_hello:
+                switch (connection_state)
+                {
+                    case CS_CLIENT_HELLO_SEND:
+                        /*
+                         * Read the server hello message
+                         */
+                        TlsUtils.checkVersion(is, this);
+
+                        /*
+                         * Read the server random
+                         */
+                        securityParameters.serverRandom = new byte[32];
+                        TlsUtils.readFully(securityParameters.serverRandom, is);
+
+                        byte[] sessionID = TlsUtils.readOpaque8(is);
+                        if (sessionID.length > 32)
+                        {
+                            this.failWithError(AlertLevel.fatal, AlertDescription.illegal_parameter);
+                        }
+
+                        this.tlsClient.notifySessionID(sessionID);
+
+                        /*
+                         * Find out which CipherSuite the server has chosen and check that
+                         * it was one of the offered ones.
+                         */
+                        int selectedCipherSuite = TlsUtils.readUint16(is);
+                        if (!arrayContains(offeredCipherSuites, selectedCipherSuite)
+                            || selectedCipherSuite == CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV)
+                        {
+                            this.failWithError(AlertLevel.fatal, AlertDescription.illegal_parameter);
+                        }
+
+                        this.tlsClient.notifySelectedCipherSuite(selectedCipherSuite);
+
+                        /*
+                         * Find out which CompressionMethod the server has chosen and check that
+                         * it was one of the offered ones.
+                         */
+                        short selectedCompressionMethod = TlsUtils.readUint8(is);
+                        if (!arrayContains(offeredCompressionMethods, selectedCompressionMethod))
+                        {
+                            this.failWithError(AlertLevel.fatal, AlertDescription.illegal_parameter);
+                        }
+
+                        this.tlsClient.notifySelectedCompressionMethod(selectedCompressionMethod);
+
+                        /*
+                         * RFC3546 2.2 The extended server hello message format MAY be
+                         * sent in place of the server hello message when the client has
+                         * requested extended functionality via the extended client hello
+                         * message specified in Section 2.1. ... Note that the extended
+                         * server hello message is only sent in response to an extended
+                         * client hello message. This prevents the possibility that the
+                         * extended server hello message could "break" existing TLS 1.0
+                         * clients.
+                         */
+
+                        /*
+                         * TODO RFC 3546 2.3 If [...] the older session is resumed, then
+                         * the server MUST ignore extensions appearing in the client
+                         * hello, and send a server hello containing no extensions.
+                         */
+
+                        // Integer -> byte[]
+                        Hashtable serverExtensions = new Hashtable();
+
+                        if (is.available() > 0)
+                        {
+                            // Process extensions from extended server hello
+                            byte[] extBytes = TlsUtils.readOpaque16(is);
+
+                            ByteArrayInputStream ext = new ByteArrayInputStream(extBytes);
+                            while (ext.available() > 0)
+                            {
+                                Integer extType = new Integer(TlsUtils.readUint16(ext));
+                                byte[] extValue = TlsUtils.readOpaque16(ext);
+
+                                /*
+                                 * RFC 5746 Note that sending a "renegotiation_info"
+                                 * extension in response to a ClientHello containing only
+                                 * the SCSV is an explicit exception to the prohibition in
+                                 * RFC 5246, Section 7.4.1.4, on the server sending
+                                 * unsolicited extensions and is only allowed because the
+                                 * client is signaling its willingness to receive the
+                                 * extension via the TLS_EMPTY_RENEGOTIATION_INFO_SCSV
+                                 * SCSV. TLS implementations MUST continue to comply with
+                                 * Section 7.4.1.4 for all other extensions.
+                                 */
+
+                                if (!extType.equals(EXT_RenegotiationInfo)
+                                    && clientExtensions.get(extType) == null)
+                                {
+                                    /*
+                                     * RFC 3546 2.3 Note that for all extension types
+                                     * (including those defined in future), the extension
+                                     * type MUST NOT appear in the extended server hello
+                                     * unless the same extension type appeared in the
+                                     * corresponding client hello. Thus clients MUST abort
+                                     * the handshake if they receive an extension type in
+                                     * the extended server hello that they did not request
+                                     * in the associated (extended) client hello.
+                                     */
+                                    this.failWithError(AlertLevel.fatal,
+                                        AlertDescription.unsupported_extension);
+                                }
+
+                                if (serverExtensions.containsKey(extType))
+                                {
+                                    /*
+                                     * RFC 3546 2.3 Also note that when multiple
+                                     * extensions of different types are present in the
+                                     * extended client hello or the extended server hello,
+                                     * the extensions may appear in any order. There MUST
+                                     * NOT be more than one extension of the same type.
+                                     */
+                                    this.failWithError(AlertLevel.fatal,
+                                        AlertDescription.illegal_parameter);
+                                }
+
+                                serverExtensions.put(extType, extValue);
+                            }
+                        }
+
+                        assertEmpty(is);
+
+                        /*
+                         * RFC 5746 3.4. When a ServerHello is received, the client MUST
+                         * check if it includes the "renegotiation_info" extension:
+                         */
+                        {
+                            boolean secure_negotiation = serverExtensions.containsKey(EXT_RenegotiationInfo);
+
+                            /*
+                             * If the extension is present, set the secure_renegotiation
+                             * flag to TRUE. The client MUST then verify that the length
+                             * of the "renegotiated_connection" field is zero, and if it
+                             * is not, MUST abort the handshake (by sending a fatal
+                             * handshake_failure alert).
+                             */
+                            if (secure_negotiation)
+                            {
+                                byte[] renegExtValue = (byte[])serverExtensions.get(EXT_RenegotiationInfo);
+
+                                if (!Arrays.constantTimeAreEqual(renegExtValue,
+                                    createRenegotiationInfo(emptybuf)))
+                                {
+                                    this.failWithError(AlertLevel.fatal,
+                                        AlertDescription.handshake_failure);
+                                }
+                            }
+
+                            tlsClient.notifySecureRenegotiation(secure_negotiation);
+                        }
+
+                        if (clientExtensions != null)
+                        {
+                            tlsClient.processServerExtensions(serverExtensions);
+                        }
+
+                        this.keyExchange = tlsClient.getKeyExchange();
+
+                        connection_state = CS_SERVER_HELLO_RECEIVED;
+                        break;
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+                break;
+            case HandshakeType.server_hello_done:
+                switch (connection_state)
+                {
+                    case CS_SERVER_CERTIFICATE_RECEIVED:
+
+                        // There was no server key exchange message; check it's OK
+                        this.keyExchange.skipServerKeyExchange();
+
+                        // NB: Fall through to next case label
+
+                    case CS_SERVER_KEY_EXCHANGE_RECEIVED:
+                    case CS_CERTIFICATE_REQUEST_RECEIVED:
+
+                        assertEmpty(is);
+
+                        connection_state = CS_SERVER_HELLO_DONE_RECEIVED;
+
+                        TlsCredentials clientCreds = null;
+                        if (certificateRequest == null)
+                        {
+                            this.keyExchange.skipClientCredentials();
+                        }
+                        else
+                        {
+                            clientCreds = this.authentication.getClientCredentials(certificateRequest);
+
+                            Certificate clientCert;
+                            if (clientCreds == null)
+                            {
+                                this.keyExchange.skipClientCredentials();
+                                clientCert = Certificate.EMPTY_CHAIN;
+                            }
+                            else
+                            {
+                                this.keyExchange.processClientCredentials(clientCreds);
+                                clientCert = clientCreds.getCertificate();
+                            }
+
+                            sendClientCertificate(clientCert);
+                        }
+
+                        /*
+                         * Send the client key exchange message, depending on the key
+                         * exchange we are using in our CipherSuite.
+                         */
+                        sendClientKeyExchange();
+
+                        connection_state = CS_CLIENT_KEY_EXCHANGE_SEND;
+
+                        if (clientCreds != null && clientCreds instanceof TlsSignerCredentials)
+                        {
+                            TlsSignerCredentials signerCreds = (TlsSignerCredentials)clientCreds;
+                            byte[] md5andsha1 = rs.getCurrentHash();
+                            byte[] clientCertificateSignature = signerCreds.generateCertificateSignature(
+                                md5andsha1);
+                            sendCertificateVerify(clientCertificateSignature);
+
+                            connection_state = CS_CERTIFICATE_VERIFY_SEND;
+                        }
+
+                        /*
+                         * Now, we send change cipher state
+                         */
+                        byte[] cmessage = new byte[1];
+                        cmessage[0] = 1;
+                        rs.writeMessage(ContentType.change_cipher_spec, cmessage, 0,
+                            cmessage.length);
+
+                        connection_state = CS_CLIENT_CHANGE_CIPHER_SPEC_SEND;
+
+                        /*
+                         * Calculate the master_secret
+                         */
+                        byte[] pms = this.keyExchange.generatePremasterSecret();
+
+                        securityParameters.masterSecret = TlsUtils.PRF(pms, "master secret",
+                            TlsUtils.concat(securityParameters.clientRandom,
+                                securityParameters.serverRandom), 48);
+
+                        // TODO Is there a way to ensure the data is really overwritten?
+                        /*
+                         * RFC 2246 8.1. The pre_master_secret should be deleted from
+                         * memory once the master_secret has been computed.
+                         */
+                        Arrays.fill(pms, (byte)0);
+
+                        /*
+                         * Initialize our cipher suite
+                         */
+                        rs.clientCipherSpecDecided(tlsClient.getCompression(), tlsClient.getCipher());
+
+                        /*
+                         * Send our finished message.
+                         */
+                        byte[] clientVerifyData = TlsUtils.PRF(securityParameters.masterSecret,
+                            "client finished", rs.getCurrentHash(), 12);
+
+                        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+                        TlsUtils.writeUint8(HandshakeType.finished, bos);
+                        TlsUtils.writeOpaque24(clientVerifyData, bos);
+                        byte[] message = bos.toByteArray();
+
+                        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+
+                        this.connection_state = CS_CLIENT_FINISHED_SEND;
+                        break;
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+                }
+                break;
+            case HandshakeType.server_key_exchange:
+            {
+                switch (connection_state)
+                {
+                    case CS_SERVER_HELLO_RECEIVED:
+
+                        // There was no server certificate message; check it's OK
+                        this.keyExchange.skipServerCertificate();
+                        this.authentication = null;
+
+                        // NB: Fall through to next case label
+
+                    case CS_SERVER_CERTIFICATE_RECEIVED:
+
+                        this.keyExchange.processServerKeyExchange(is);
+
+                        assertEmpty(is);
+                        break;
+
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+
+                this.connection_state = CS_SERVER_KEY_EXCHANGE_RECEIVED;
+                break;
+            }
+            case HandshakeType.certificate_request:
+            {
+                switch (connection_state)
+                {
+                    case CS_SERVER_CERTIFICATE_RECEIVED:
+
+                        // There was no server key exchange message; check it's OK
+                        this.keyExchange.skipServerKeyExchange();
+
+                        // NB: Fall through to next case label
+
+                    case CS_SERVER_KEY_EXCHANGE_RECEIVED:
+                    {
+                    	if (this.authentication == null)
+                    	{
+                            /*
+                             * RFC 2246 7.4.4. It is a fatal handshake_failure alert
+                             * for an anonymous server to request client identification.
+                             */
+                    		this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+                    	}
+
+                        int numTypes = TlsUtils.readUint8(is);
+                        short[] certificateTypes = new short[numTypes];
+                        for (int i = 0; i < numTypes; ++i)
+                        {
+                            certificateTypes[i] = TlsUtils.readUint8(is);
+                        }
+
+                        byte[] authorities = TlsUtils.readOpaque16(is);
+
+                        assertEmpty(is);
+
+                        Vector authorityDNs = new Vector();
+
+                        ByteArrayInputStream bis = new ByteArrayInputStream(authorities);
+                        while (bis.available() > 0)
+                        {
+                            byte[] dnBytes = TlsUtils.readOpaque16(bis);
+                            authorityDNs.addElement(X500Name.getInstance(ASN1Object.fromByteArray(dnBytes)));
+                        }
+
+                        this.certificateRequest = new CertificateRequest(certificateTypes,
+                            authorityDNs);
+                        this.keyExchange.validateCertificateRequest(this.certificateRequest);
+
+                        break;
+                    }
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+
+                this.connection_state = CS_CERTIFICATE_REQUEST_RECEIVED;
+                break;
+            }
+            case HandshakeType.hello_request:
+                /*
+                 * RFC 2246 7.4.1.1 Hello request This message will be ignored by the
+                 * client if the client is currently negotiating a session. This message
+                 * may be ignored by the client if it does not wish to renegotiate a
+                 * session, or the client may, if it wishes, respond with a
+                 * no_renegotiation alert.
+                 */
+                if (connection_state == CS_DONE)
+                {
+                    // Renegotiation not supported yet
+                    sendAlert(AlertLevel.warning, AlertDescription.no_renegotiation);
+                }
+                break;
+            case HandshakeType.client_key_exchange:
+            case HandshakeType.certificate_verify:
+            case HandshakeType.client_hello:
+            default:
+                // We do not support this!
+                this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                break;
+        }
+    }
+
+    private void processApplicationData()
+    {
+        /*
+         * There is nothing we need to do here.
+         *
+         * This function could be used for callbacks when application data arrives in the
+         * future.
+         */
+    }
+
+    private void processAlert() throws IOException
+    {
+        while (alertQueue.size() >= 2)
+        {
+            /*
+             * An alert is always 2 bytes. Read the alert.
+             */
+            byte[] tmp = new byte[2];
+            alertQueue.read(tmp, 0, 2, 0);
+            alertQueue.removeData(2);
+            short level = tmp[0];
+            short description = tmp[1];
+            if (level == AlertLevel.fatal)
+            {
+                /*
+                 * This is a fatal error.
+                 */
+                this.failedWithError = true;
+                this.closed = true;
+                /*
+                 * Now try to close the stream, ignore errors.
+                 */
+                try
+                {
+                    rs.close();
+                }
+                catch (Exception e)
+                {
+
+                }
+                throw new IOException(TLS_ERROR_MESSAGE);
+            }
+            else
+            {
+                /*
+                 * This is just a warning.
+                 */
+                if (description == AlertDescription.close_notify)
+                {
+                    /*
+                     * Close notify
+                     */
+                    this.failWithError(AlertLevel.warning, AlertDescription.close_notify);
+                }
+                /*
+                 * If it is just a warning, we continue.
+                 */
+            }
+        }
+    }
+
+    /**
+     * This method is called, when a change cipher spec message is received.
+     *
+     * @throws IOException If the message has an invalid content or the handshake is not
+     *             in the correct state.
+     */
+    private void processChangeCipherSpec() throws IOException
+    {
+        while (changeCipherSpecQueue.size() > 0)
+        {
+            /*
+             * A change cipher spec message is only one byte with the value 1.
+             */
+            byte[] b = new byte[1];
+            changeCipherSpecQueue.read(b, 0, 1, 0);
+            changeCipherSpecQueue.removeData(1);
+            if (b[0] != 1)
+            {
+                /*
+                 * This should never happen.
+                 */
+                this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+            }
+
+            /*
+             * Check if we are in the correct connection state.
+             */
+            if (this.connection_state != CS_CLIENT_FINISHED_SEND)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+            }
+
+            rs.serverClientSpecReceived();
+
+            this.connection_state = CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED;
+        }
+    }
+
+    private void sendClientCertificate(Certificate clientCert) throws IOException
+    {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.certificate, bos);
+        clientCert.encode(bos);
+        byte[] message = bos.toByteArray();
+
+        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+    }
+
+    private void sendClientKeyExchange() throws IOException
+    {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.client_key_exchange, bos);
+        this.keyExchange.generateClientKeyExchange(bos);
+        byte[] message = bos.toByteArray();
+
+        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+    }
+
+    private void sendCertificateVerify(byte[] data) throws IOException
+    {
+        /*
+         * Send signature of handshake messages so far to prove we are the owner of the
+         * cert See RFC 2246 sections 4.7, 7.4.3 and 7.4.8
+         */
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.certificate_verify, bos);
+        TlsUtils.writeUint24(data.length + 2, bos);
+        TlsUtils.writeOpaque16(data, bos);
+        byte[] message = bos.toByteArray();
+
+        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+    }
+
+    /**
+     * Connects to the remote system.
+     *
+     * @param verifyer Will be used when a certificate is received to verify that this
+     *            certificate is accepted by the client.
+     * @throws IOException If handshake was not successful.
+     *
+     * @deprecated use version taking TlsClient
+     */
+    public void connect(CertificateVerifyer verifyer) throws IOException
+    {
+        this.connect(new LegacyTlsClient(verifyer));
+    }
+
+    /**
+     * Connects to the remote system using client authentication
+     *
+     * @param tlsClient
+     * @throws IOException If handshake was not successful.
+     */
+    public void connect(TlsClient tlsClient) throws IOException
+    {
+        if (tlsClient == null)
+        {
+            throw new IllegalArgumentException("'tlsClient' cannot be null");
+        }
+        if (this.tlsClient != null)
+        {
+            throw new IllegalStateException("connect can only be called once");
+        }
+
+        /*
+         * Send Client hello
+         *
+         * First, generate some random data.
+         */
+        this.securityParameters = new SecurityParameters();
+        this.securityParameters.clientRandom = new byte[32];
+        random.nextBytes(securityParameters.clientRandom);
+        TlsUtils.writeGMTUnixTime(securityParameters.clientRandom, 0);
+
+        this.tlsClientContext = new TlsClientContextImpl(random, securityParameters);
+        this.tlsClient = tlsClient;
+        this.tlsClient.init(tlsClientContext);
+
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        TlsUtils.writeVersion(os);
+        os.write(securityParameters.clientRandom);
+
+        /*
+         * Length of Session id
+         */
+        TlsUtils.writeUint8((short)0, os);
+
+        /*
+         * Cipher suites
+         */
+        this.offeredCipherSuites = this.tlsClient.getCipherSuites();
+
+        // Integer -> byte[]
+        this.clientExtensions = this.tlsClient.getClientExtensions();
+
+        // Cipher Suites (and SCSV)
+        {
+            /*
+             * RFC 5746 3.4. The client MUST include either an empty "renegotiation_info"
+             * extension, or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV signaling cipher suite
+             * value in the ClientHello. Including both is NOT RECOMMENDED.
+             */
+            boolean noRenegExt = clientExtensions == null
+                || clientExtensions.get(EXT_RenegotiationInfo) == null;
+
+            int count = offeredCipherSuites.length;
+            if (noRenegExt)
+            {
+                // Note: 1 extra slot for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
+                ++count;
+            }
+
+            TlsUtils.writeUint16(2 * count, os);
+            TlsUtils.writeUint16Array(offeredCipherSuites, os);
+
+            if (noRenegExt)
+            {
+                TlsUtils.writeUint16(CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV, os);
+            }
+        }
+
+        // Compression methods
+        this.offeredCompressionMethods = this.tlsClient.getCompressionMethods();
+
+        TlsUtils.writeUint8((short)offeredCompressionMethods.length, os);
+        TlsUtils.writeUint8Array(offeredCompressionMethods, os);
+
+        // Extensions
+        if (clientExtensions != null)
+        {
+            ByteArrayOutputStream ext = new ByteArrayOutputStream();
+
+            Enumeration keys = clientExtensions.keys();
+            while (keys.hasMoreElements())
+            {
+                Integer extType = (Integer)keys.nextElement();
+                writeExtension(ext, extType, (byte[])clientExtensions.get(extType));
+            }
+
+            TlsUtils.writeOpaque16(ext.toByteArray(), os);
+        }
+
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.client_hello, bos);
+        TlsUtils.writeUint24(os.size(), bos);
+        bos.write(os.toByteArray());
+        byte[] message = bos.toByteArray();
+
+        safeWriteMessage(ContentType.handshake, message, 0, message.length);
+
+        connection_state = CS_CLIENT_HELLO_SEND;
+
+        /*
+         * We will now read data, until we have completed the handshake.
+         */
+        while (connection_state != CS_DONE)
+        {
+            safeReadData();
+        }
+
+        this.tlsInputStream = new TlsInputStream(this);
+        this.tlsOutputStream = new TlsOutputStream(this);
+    }
+
+    /**
+     * Read data from the network. The method will return immediately, if there is still
+     * some data left in the buffer, or block until some application data has been read
+     * from the network.
+     *
+     * @param buf The buffer where the data will be copied to.
+     * @param offset The position where the data will be placed in the buffer.
+     * @param len The maximum number of bytes to read.
+     * @return The number of bytes read.
+     * @throws IOException If something goes wrong during reading data.
+     */
+    protected int readApplicationData(byte[] buf, int offset, int len) throws IOException
+    {
+        while (applicationDataQueue.size() == 0)
+        {
+            /*
+             * We need to read some data.
+             */
+            if (this.closed)
+            {
+                if (this.failedWithError)
+                {
+                    /*
+                     * Something went terribly wrong, we should throw an IOException
+                     */
+                    throw new IOException(TLS_ERROR_MESSAGE);
+                }
+
+                /*
+                 * Connection has been closed, there is no more data to read.
+                 */
+                return -1;
+            }
+
+            safeReadData();
+        }
+        len = Math.min(len, applicationDataQueue.size());
+        applicationDataQueue.read(buf, offset, len, 0);
+        applicationDataQueue.removeData(len);
+        return len;
+    }
+
+    private void safeReadData() throws IOException
+    {
+        try
+        {
+            rs.readData();
+        }
+        catch (TlsFatalAlert e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, e.getAlertDescription());
+            }
+            throw e;
+        }
+   /*     catch (IOException e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+    */    catch (RuntimeException e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+    }
+
+    private void safeWriteMessage(short type, byte[] buf, int offset, int len) throws IOException
+    {
+        try
+        {
+            rs.writeMessage(type, buf, offset, len);
+        }
+        catch (TlsFatalAlert e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, e.getAlertDescription());
+            }
+            throw e;
+        }
+        catch (IOException e)
+        {
+            if (!closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+        catch (RuntimeException e)
+        {
+            if (!closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Send some application data to the remote system.
+     * <p/>
+     * The method will handle fragmentation internally.
+     *
+     * @param buf The buffer with the data.
+     * @param offset The position in the buffer where the data is placed.
+     * @param len The length of the data.
+     * @throws IOException If something goes wrong during sending.
+     */
+    protected void writeData(byte[] buf, int offset, int len) throws IOException
+    {
+        if (this.closed)
+        {
+            if (this.failedWithError)
+            {
+                throw new IOException(TLS_ERROR_MESSAGE);
+            }
+
+            throw new IOException("Sorry, connection has been closed, you cannot write more data");
+        }
+
+        /*
+         * Protect against known IV attack!
+         *
+         * DO NOT REMOVE THIS LINE, EXCEPT YOU KNOW EXACTLY WHAT YOU ARE DOING HERE.
+         */
+        safeWriteMessage(ContentType.application_data, emptybuf, 0, 0);
+
+        do
+        {
+            /*
+             * We are only allowed to write fragments up to 2^14 bytes.
+             */
+            int toWrite = Math.min(len, 1 << 14);
+
+            safeWriteMessage(ContentType.application_data, buf, offset, toWrite);
+
+            offset += toWrite;
+            len -= toWrite;
+        }
+        while (len > 0);
+
+    }
+
+    /**
+     * @return An OutputStream which can be used to send data.
+     */
+    public OutputStream getOutputStream()
+    {
+        return this.tlsOutputStream;
+    }
+
+    /**
+     * @return An InputStream which can be used to read data.
+     */
+    public InputStream getInputStream()
+    {
+        return this.tlsInputStream;
+    }
+
+    /**
+     * Terminate this connection with an alert.
+     * <p/>
+     * Can be used for normal closure too.
+     *
+     * @param alertLevel The level of the alert, an be AlertLevel.fatal or AL_warning.
+     * @param alertDescription The exact alert message.
+     * @throws IOException If alert was fatal.
+     */
+    private void failWithError(short alertLevel, short alertDescription) throws IOException
+    {
+        /*
+         * Check if the connection is still open.
+         */
+        if (!closed)
+        {
+            /*
+             * Prepare the message
+             */
+            this.closed = true;
+
+            if (alertLevel == AlertLevel.fatal)
+            {
+                /*
+                 * This is a fatal message.
+                 */
+                this.failedWithError = true;
+            }
+            sendAlert(alertLevel, alertDescription);
+            rs.close();
+            if (alertLevel == AlertLevel.fatal)
+            {
+                throw new IOException(TLS_ERROR_MESSAGE);
+            }
+        }
+        else
+        {
+            throw new IOException(TLS_ERROR_MESSAGE);
+        }
+    }
+
+    private void sendAlert(short alertLevel, short alertDescription) throws IOException
+    {
+        byte[] error = new byte[2];
+        error[0] = (byte)alertLevel;
+        error[1] = (byte)alertDescription;
+
+        rs.writeMessage(ContentType.alert, error, 0, 2);
+    }
+
+    /**
+     * Closes this connection.
+     *
+     * @throws IOException If something goes wrong during closing.
+     */
+    public void close() throws IOException
+    {
+        if (!closed)
+        {
+            this.failWithError(AlertLevel.warning, AlertDescription.close_notify);
+        }
+    }
+
+    /**
+     * Make sure the InputStream is now empty. Fail otherwise.
+     *
+     * @param is The InputStream to check.
+     * @throws IOException If is is not empty.
+     */
+    protected void assertEmpty(ByteArrayInputStream is) throws IOException
+    {
+        if (is.available() > 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.decode_error);
+        }
+    }
+
+    protected void flush() throws IOException
+    {
+        rs.flush();
+    }
+
+    private static boolean arrayContains(short[] a, short n)
+    {
+        for (int i = 0; i < a.length; ++i)
+        {
+            if (a[i] == n)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean arrayContains(int[] a, int n)
+    {
+        for (int i = 0; i < a.length; ++i)
+        {
+            if (a[i] == n)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static byte[] createRenegotiationInfo(byte[] renegotiated_connection)
+        throws IOException
+    {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        TlsUtils.writeOpaque8(renegotiated_connection, buf);
+        return buf.toByteArray();
+    }
+
+    private static void writeExtension(OutputStream output, Integer extType, byte[] extValue)
+        throws IOException
+    {
+        TlsUtils.writeUint16(extType.intValue(), output);
+        TlsUtils.writeOpaque16(extValue, output);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,192 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.crypto.InvalidCipherTextException;
+import org.bouncycastle.crypto.encodings.PKCS1Encoding;
+import org.bouncycastle.crypto.engines.RSABlindedEngine;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.util.PublicKeyFactory;
+
+/**
+ * TLS 1.0 RSA key exchange.
+ */
+class TlsRSAKeyExchange implements TlsKeyExchange
+{
+    protected TlsClientContext context;
+
+    protected AsymmetricKeyParameter serverPublicKey = null;
+
+    protected RSAKeyParameters rsaServerPublicKey = null;
+
+    protected byte[] premasterSecret;
+
+    TlsRSAKeyExchange(TlsClientContext context)
+    {
+        this.context = context;
+    }
+
+    public void skipServerCertificate() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        X509CertificateStructure x509Cert = serverCertificate.certs[0];
+        SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();
+
+        try
+        {
+            this.serverPublicKey = PublicKeyFactory.createKey(keyInfo);
+        }
+        catch (RuntimeException e)
+        {
+            throw new TlsFatalAlert(AlertDescription.unsupported_certificate);
+        }
+
+        // Sanity check the PublicKeyFactory
+        if (this.serverPublicKey.isPrivate())
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+
+        this.rsaServerPublicKey = validateRSAPublicKey((RSAKeyParameters)this.serverPublicKey);
+
+        TlsUtils.validateKeyUsage(x509Cert, KeyUsage.keyEncipherment);
+
+        // TODO 
+        /*
+         * Perform various checks per RFC2246 7.4.2: "Unless otherwise specified, the
+         * signing algorithm for the certificate must be the same as the algorithm for the
+         * certificate key."
+         */
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        // OK
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        // TODO
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i < types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.ecdsa_sign:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void skipClientCredentials() throws IOException
+    {
+        // OK
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (!(clientCredentials instanceof TlsSignerCredentials))
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public void generateClientKeyExchange(OutputStream os) throws IOException
+    {
+        /*
+         * Choose a PremasterSecret and send it encrypted to the server
+         */
+    	
+        premasterSecret = new byte[48];
+        context.getSecureRandom().nextBytes(premasterSecret);
+        TlsUtils.writeVersion(premasterSecret, 0);
+        RSABlindedEngine rbe = new RSABlindedEngine();
+        PKCS1Encoding encoding = new PKCS1Encoding(rbe);
+        encoding.init(true, new ParametersWithRandom(this.rsaServerPublicKey, context.getSecureRandom()));
+
+        try
+        {
+            byte[] keData = encoding.processBlock(premasterSecret, 0, premasterSecret.length);
+            TlsUtils.writeUint24(keData.length + 2, os);
+            TlsUtils.writeOpaque16(keData, os);
+        }
+        catch (InvalidCipherTextException e)
+        {
+            /*
+             * This should never happen, only during decryption.
+             */
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public byte[] generatePremasterSecret() throws IOException
+    {
+        byte[] tmp = this.premasterSecret;
+        this.premasterSecret = null;
+        return tmp;
+    }
+
+    // Would be needed to process RSA_EXPORT server key exchange
+//    protected void processRSAServerKeyExchange(InputStream is, Signer signer) throws IOException
+//    {
+//        InputStream sigIn = is;
+//        if (signer != null)
+//        {
+//            sigIn = new SignerInputStream(is, signer);
+//        }
+//
+//        byte[] modulusBytes = TlsUtils.readOpaque16(sigIn);
+//        byte[] exponentBytes = TlsUtils.readOpaque16(sigIn);
+//
+//        if (signer != null)
+//        {
+//            byte[] sigByte = TlsUtils.readOpaque16(is);
+//
+//            if (!signer.verifySignature(sigByte))
+//            {
+//                handler.failWithError(AlertLevel.fatal, AlertDescription.bad_certificate);
+//            }
+//        }
+//
+//        BigInteger modulus = new BigInteger(1, modulusBytes);
+//        BigInteger exponent = new BigInteger(1, exponentBytes);
+//
+//        this.rsaServerPublicKey = validateRSAPublicKey(new RSAKeyParameters(false, modulus,
+//            exponent));
+//    }
+
+    protected RSAKeyParameters validateRSAPublicKey(RSAKeyParameters key) throws IOException
+    {
+        // TODO What is the minimum bit length required?
+//        key.getModulus().bitLength();
+
+        if (!key.getExponent().isProbablePrime(2))
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.digests.NullDigest;
+import org.bouncycastle.crypto.encodings.PKCS1Encoding;
+import org.bouncycastle.crypto.engines.RSABlindedEngine;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.signers.GenericSigner;
+
+class TlsRSASigner implements TlsSigner
+{
+    public byte[] calculateRawSignature(SecureRandom random, AsymmetricKeyParameter privateKey, byte[] md5andsha1)
+        throws CryptoException
+    {
+        Signer sig = new GenericSigner(new PKCS1Encoding(new RSABlindedEngine()), new NullDigest());
+        sig.init(true, new ParametersWithRandom(privateKey, random));
+        sig.update(md5andsha1, 0, md5andsha1.length);
+        return sig.generateSignature();
+    }
+
+    public Signer createVerifyer(AsymmetricKeyParameter publicKey)
+    {
+        Signer s = new GenericSigner(new PKCS1Encoding(new RSABlindedEngine()), new CombinedHash());
+        s.init(false, publicKey);
+        return s;
+    }
+
+    public boolean isValidPublicKey(AsymmetricKeyParameter publicKey)
+    {
+        return publicKey instanceof RSAKeyParameters && !publicKey.isPrivate();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.crypto.tls;
+
+public class TlsRuntimeException extends RuntimeException
+{
+    private static final long serialVersionUID = 1928023487348344086L;
+
+    Throwable e;
+
+    public TlsRuntimeException(String message, Throwable e)
+    {
+        super(message);
+
+        this.e = e;
+    }
+
+    public TlsRuntimeException(String message)
+    {
+        super(message);
+    }
+
+    public Throwable getCause()
+    {
+        return e;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,17 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+
+interface TlsSigner
+{
+    byte[] calculateRawSignature(SecureRandom random, AsymmetricKeyParameter privateKey, byte[] md5andsha1)
+        throws CryptoException;
+
+    Signer createVerifyer(AsymmetricKeyParameter publicKey);
+
+    boolean isValidPublicKey(AsymmetricKeyParameter publicKey);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,8 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsSignerCredentials extends TlsCredentials
+{
+    byte[] generateCertificateSignature(byte[] md5andsha1) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,44 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.net.Socket;
+import ewe.net.UnknownHostException;
+
+
+public class TlsSocket {
+	public Socket socket;
+	public InputStream inputStream;
+	public OutputStream outputStream;
+
+	public TlsSocket(CertificateVerifyer certificateVerifyer, Socket s) throws UnknownHostException, IOException {
+		socket = s;
+
+		if (certificateVerifyer == null) {
+			inputStream = s.getInputStream();
+			outputStream = s.getOutputStream();
+		} else {
+	        OutputStream os = socket.getOutputStream();
+	        InputStream is = socket.getInputStream();
+
+	        TlsProtocolHandler tph = new TlsProtocolHandler(is, os);
+	        tph.connect(certificateVerifyer);
+
+			inputStream  = tph.getInputStream();
+			outputStream = tph.getOutputStream();
+		}
+	}
+
+	public boolean close() {
+		boolean b = true;
+		try {
+			outputStream.close();
+			inputStream.close();
+		} catch (IOException e) {
+			b = false;
+		}
+		boolean a = socket.close();
+		return a && b;
+	}
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,319 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.EOFException;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.asn1.x509.X509Extension;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.digests.MD5Digest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+import org.bouncycastle.crypto.macs.HMac;
+import org.bouncycastle.crypto.params.KeyParameter;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.io.Streams;
+
+/**
+ * Some helper fuctions for MicroTLS.
+ */
+public class TlsUtils
+{
+    protected static void writeUint8(short i, OutputStream os) throws IOException
+    {
+        os.write(i);
+    }
+
+    protected static void writeUint8(short i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)i;
+    }
+
+    protected static void writeUint16(int i, OutputStream os) throws IOException
+    {
+        os.write(i >> 8);
+        os.write(i);
+    }
+
+    protected static void writeUint16(int i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i >> 8);
+        buf[offset + 1] = (byte)i;
+    }
+
+    protected static void writeUint24(int i, OutputStream os) throws IOException
+    {
+        os.write(i >> 16);
+        os.write(i >> 8);
+        os.write(i);
+    }
+
+    protected static void writeUint24(int i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i >> 16);
+        buf[offset + 1] = (byte)(i >> 8);
+        buf[offset + 2] = (byte)(i);
+    }
+
+    protected static void writeUint32(long i, OutputStream os) throws IOException
+    {
+        os.write((int)(i >> 24));
+        os.write((int)(i >> 16));
+        os.write((int)(i >> 8));
+        os.write((int)(i));
+    }
+
+    protected static void writeUint32(long i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i >> 24);
+        buf[offset + 1] = (byte)(i >> 16);
+        buf[offset + 2] = (byte)(i >> 8);
+        buf[offset + 3] = (byte)(i);
+    }
+
+    protected static void writeUint64(long i, OutputStream os) throws IOException
+    {
+        os.write((int)(i >> 56));
+        os.write((int)(i >> 48));
+        os.write((int)(i >> 40));
+        os.write((int)(i >> 32));
+        os.write((int)(i >> 24));
+        os.write((int)(i >> 16));
+        os.write((int)(i >> 8));
+        os.write((int)(i));
+    }
+
+
+    protected static void writeUint64(long i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i >> 56);
+        buf[offset + 1] = (byte)(i >> 48);
+        buf[offset + 2] = (byte)(i >> 40);
+        buf[offset + 3] = (byte)(i >> 32);
+        buf[offset + 4] = (byte)(i >> 24);
+        buf[offset + 5] = (byte)(i >> 16);
+        buf[offset + 6] = (byte)(i >> 8);
+        buf[offset + 7] = (byte)(i);
+    }
+
+    protected static void writeOpaque8(byte[] buf, OutputStream os) throws IOException
+    {
+        writeUint8((short)buf.length, os);
+        os.write(buf);
+    }
+
+    protected static void writeOpaque16(byte[] buf, OutputStream os) throws IOException
+    {
+        writeUint16(buf.length, os);
+        os.write(buf);
+    }
+
+    protected static void writeOpaque24(byte[] buf, OutputStream os) throws IOException
+    {
+        writeUint24(buf.length, os);
+        os.write(buf);
+    }
+
+    protected static void writeUint8Array(short[] uints, OutputStream os) throws IOException
+    {
+        for (int i = 0; i < uints.length; ++i)
+        {
+            writeUint8(uints[i], os);
+        }
+    }
+
+    protected static void writeUint16Array(int[] uints, OutputStream os) throws IOException
+    {
+        for (int i = 0; i < uints.length; ++i)
+        {
+            writeUint16(uints[i], os);
+        }
+    }
+
+    protected static short readUint8(InputStream is) throws IOException
+    {
+        int i = is.read();
+        if (i == -1)
+        {
+            throw new EOFException();
+        }
+        return (short)i;
+    }
+
+    protected static int readUint16(InputStream is) throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        if ((i1 | i2) < 0)
+        {
+            throw new EOFException();
+        }
+        return i1 << 8 | i2;
+    }
+
+    protected static int readUint24(InputStream is) throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        int i3 = is.read();
+        if ((i1 | i2 | i3) < 0)
+        {
+            throw new EOFException();
+        }
+        return (i1 << 16) | (i2 << 8) | i3;
+    }
+
+    protected static long readUint32(InputStream is) throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        int i3 = is.read();
+        int i4 = is.read();
+        if ((i1 | i2 | i3 | i4) < 0)
+        {
+            throw new EOFException();
+        }
+        return (((long)i1) << 24) | (((long)i2) << 16) | (((long)i3) << 8) | ((long)i4);
+    }
+
+    protected static void readFully(byte[] buf, InputStream is) throws IOException
+    {
+        if (Streams.readFully(is, buf) != buf.length)
+        {
+            throw new EOFException();
+        }
+    }
+
+    protected static byte[] readOpaque8(InputStream is) throws IOException
+    {
+        short length = readUint8(is);
+        byte[] value = new byte[length];
+        readFully(value, is);
+        return value;
+    }
+
+    protected static byte[] readOpaque16(InputStream is) throws IOException
+    {
+        int length = readUint16(is);
+        byte[] value = new byte[length];
+        readFully(value, is);
+        return value;
+    }
+
+    protected static void checkVersion(byte[] readVersion, TlsProtocolHandler handler)
+        throws IOException
+    {
+        if ((readVersion[0] != 3) || (readVersion[1] != 1))
+        {
+            throw new TlsFatalAlert(AlertDescription.protocol_version);
+        }
+    }
+
+    protected static void checkVersion(InputStream is, TlsProtocolHandler handler)
+        throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        if ((i1 != 3) || (i2 != 1))
+        {
+            throw new TlsFatalAlert(AlertDescription.protocol_version);
+        }
+    }
+
+    protected static void writeGMTUnixTime(byte[] buf, int offset)
+    {
+        int t = (int)(System.currentTimeMillis() / 1000L);
+        buf[offset] = (byte)(t >> 24);
+        buf[offset + 1] = (byte)(t >> 16);
+        buf[offset + 2] = (byte)(t >> 8);
+        buf[offset + 3] = (byte)t;
+    }
+
+    protected static void writeVersion(OutputStream os) throws IOException
+    {
+        os.write(3);
+        os.write(1);
+    }
+
+    protected static void writeVersion(byte[] buf, int offset) throws IOException
+    {
+        buf[offset] = 3;
+        buf[offset + 1] = 1;
+    }
+
+    private static void hmac_hash(Digest digest, byte[] secret, byte[] seed, byte[] out)
+    {
+        HMac mac = new HMac(digest);
+        KeyParameter param = new KeyParameter(secret);
+        byte[] a = seed;
+        int size = digest.getDigestSize();
+        int iterations = (out.length + size - 1) / size;
+        byte[] buf = new byte[mac.getMacSize()];
+        byte[] buf2 = new byte[mac.getMacSize()];
+        for (int i = 0; i < iterations; i++)
+        {
+            mac.init(param);
+            mac.update(a, 0, a.length);
+            mac.doFinal(buf, 0);
+            a = buf;
+            mac.init(param);
+            mac.update(a, 0, a.length);
+            mac.update(seed, 0, seed.length);
+            mac.doFinal(buf2, 0);
+            System.arraycopy(buf2, 0, out, (size * i), Math.min(size, out.length - (size * i)));
+        }
+    }
+
+    protected static byte[] PRF(byte[] secret, String asciiLabel, byte[] seed, int size)
+    {
+        byte[] label = Strings.toByteArray(asciiLabel);
+
+        int s_half = (secret.length + 1) / 2;
+        byte[] s1 = new byte[s_half];
+        byte[] s2 = new byte[s_half];
+        System.arraycopy(secret, 0, s1, 0, s_half);
+        System.arraycopy(secret, secret.length - s_half, s2, 0, s_half);
+
+        byte[] ls = concat(label, seed);
+
+        byte[] buf = new byte[size];
+        byte[] prf = new byte[size];
+        hmac_hash(new MD5Digest(), s1, ls, prf);
+        hmac_hash(new SHA1Digest(), s2, ls, buf);
+        for (int i = 0; i < size; i++)
+        {
+            buf[i] ^= prf[i];
+        }
+        return buf;
+    }
+
+    static byte[] concat(byte[] a, byte[] b)
+    {
+        byte[] c = new byte[a.length + b.length];
+        System.arraycopy(a, 0, c, 0, a.length);
+        System.arraycopy(b, 0, c, a.length, b.length);
+        return c;
+    }
+
+    static void validateKeyUsage(X509CertificateStructure c, int keyUsageBits) throws IOException
+    {
+        X509Extensions exts = c.getTBSCertificate().getExtensions();
+        if (exts != null)
+        {
+            X509Extension ext = exts.getExtension(X509Extension.keyUsage);
+            if (ext != null)
+            {
+                DERBitString ku = KeyUsage.getInstance(ext);
+                int bits = ku.getBytes()[0] & 0xff;
+                if ((bits & keyUsageBits) != keyUsageBits)
+                {
+                    throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+                }
+            }
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+A lightweight TLS API.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/crypto/util/Pack.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/util/Pack.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/util/Pack.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/util/Pack.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/util/Pack.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,64 @@
+package org.bouncycastle.crypto.util;
+
+public abstract class Pack
+{
+    public static int bigEndianToInt(byte[] bs, int off)
+    {
+        int n = bs[  off] << 24;
+        n |= (bs[++off] & 0xff) << 16;
+        n |= (bs[++off] & 0xff) << 8;
+        n |= (bs[++off] & 0xff);
+        return n;
+    }
+
+    public static void intToBigEndian(int n, byte[] bs, int off)
+    {
+        bs[  off] = (byte)(n >>> 24);
+        bs[++off] = (byte)(n >>> 16);
+        bs[++off] = (byte)(n >>>  8);
+        bs[++off] = (byte)(n       );
+    }
+
+    public static long bigEndianToLong(byte[] bs, int off)
+    {
+        int hi = bigEndianToInt(bs, off);
+        int lo = bigEndianToInt(bs, off + 4);
+        return ((long)(hi & 0xffffffffL) << 32) | (long)(lo & 0xffffffffL);
+    }
+
+    public static void longToBigEndian(long n, byte[] bs, int off)
+    {
+        intToBigEndian((int)(n >>> 32), bs, off);
+        intToBigEndian((int)(n & 0xffffffffL), bs, off + 4);
+    }
+
+    public static int littleEndianToInt(byte[] bs, int off)
+    {
+        int n = bs[  off];
+        n |= (bs[++off] & 0xff) << 8;
+        n |= (bs[++off] & 0xff) << 16;
+        n |= (bs[++off] & 0xff) << 24;
+        return n;
+    }
+
+    public static void intToLittleEndian(int n, byte[] bs, int off)
+    {
+        bs[  off] = (byte)(n       );
+        bs[++off] = (byte)(n >>>  8);
+        bs[++off] = (byte)(n >>> 16);
+        bs[++off] = (byte)(n >>> 24);
+    }
+
+    public static long littleEndianToLong(byte[] bs, int off)
+    {
+        int lo = littleEndianToInt(bs, off);
+        int hi = littleEndianToInt(bs, off + 4);
+        return ((long)(hi & 0xffffffffL) << 32) | (long)(lo & 0xffffffffL);
+    }
+
+    public static void longToLittleEndian(long n, byte[] bs, int off)
+    {
+        intToLittleEndian((int)(n & 0xffffffffL), bs, off);
+        intToLittleEndian((int)(n >>> 32), bs, off + 4);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,215 @@
+package org.bouncycastle.crypto.util;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DEROctetString;
+import org.bouncycastle.asn1.nist.NISTNamedCurves;
+import org.bouncycastle.asn1.oiw.ElGamalParameter;
+import org.bouncycastle.asn1.oiw.OIWObjectIdentifiers;
+import org.bouncycastle.asn1.pkcs.DHParameter;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+import org.bouncycastle.asn1.sec.SECNamedCurves;
+import org.bouncycastle.asn1.teletrust.TeleTrusTNamedCurves;
+import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
+import org.bouncycastle.asn1.x509.DSAParameter;
+import org.bouncycastle.asn1.x509.RSAPublicKeyStructure;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
+import org.bouncycastle.asn1.x9.DHDomainParameters;
+import org.bouncycastle.asn1.x9.DHPublicKey;
+import org.bouncycastle.asn1.x9.DHValidationParms;
+import org.bouncycastle.asn1.x9.X962NamedCurves;
+import org.bouncycastle.asn1.x9.X962Parameters;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.asn1.x9.X9ECPoint;
+import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.params.DHValidationParameters;
+import org.bouncycastle.crypto.params.DSAParameters;
+import org.bouncycastle.crypto.params.DSAPublicKeyParameters;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.params.ElGamalParameters;
+import org.bouncycastle.crypto.params.ElGamalPublicKeyParameters;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+
+/**
+ * Factory to create asymmetric public key parameters for asymmetric ciphers from range of
+ * ASN.1 encoded SubjectPublicKeyInfo objects.
+ */
+public class PublicKeyFactory
+{
+    /**
+     * Create a public key from a SubjectPublicKeyInfo encoding
+     * 
+     * @param keyInfoData the SubjectPublicKeyInfo encoding
+     * @return the appropriate key parameter
+     * @throws IOException on an error decoding the key
+     */
+    public static AsymmetricKeyParameter createKey(byte[] keyInfoData) throws IOException
+    {
+        return createKey(SubjectPublicKeyInfo.getInstance(ASN1Object.fromByteArray(keyInfoData)));
+    }
+
+    /**
+     * Create a public key from a SubjectPublicKeyInfo encoding read from a stream
+     * 
+     * @param inStr the stream to read the SubjectPublicKeyInfo encoding from
+     * @return the appropriate key parameter
+     * @throws IOException on an error decoding the key
+     */
+    public static AsymmetricKeyParameter createKey(InputStream inStr) throws IOException
+    {
+        return createKey(SubjectPublicKeyInfo.getInstance(new ASN1InputStream(inStr).readObject()));
+    }
+
+    /**
+     * Create a public key from the passed in SubjectPublicKeyInfo
+     * 
+     * @param keyInfo the SubjectPublicKeyInfo containing the key data
+     * @return the appropriate key parameter
+     * @throws IOException on an error decoding the key
+     */
+    public static AsymmetricKeyParameter createKey(SubjectPublicKeyInfo keyInfo) throws IOException
+    {
+        AlgorithmIdentifier algId = keyInfo.getAlgorithmId();
+
+        if (algId.getObjectId().equals(PKCSObjectIdentifiers.rsaEncryption)
+            || algId.getObjectId().equals(X509ObjectIdentifiers.id_ea_rsa))
+        {
+            RSAPublicKeyStructure pubKey = new RSAPublicKeyStructure(
+                (ASN1Sequence)keyInfo.getPublicKey());
+
+            return new RSAKeyParameters(false, pubKey.getModulus(), pubKey.getPublicExponent());
+        }
+        else if (algId.getObjectId().equals(X9ObjectIdentifiers.dhpublicnumber))
+        {
+            DHPublicKey dhPublicKey = DHPublicKey.getInstance(keyInfo.getPublicKey());
+
+            BigInteger y = dhPublicKey.getY().getValue();
+
+            DHDomainParameters dhParams = DHDomainParameters.getInstance(keyInfo.getAlgorithmId().getParameters());
+
+            BigInteger p = dhParams.getP().getValue();
+            BigInteger g = dhParams.getG().getValue();
+            BigInteger q = dhParams.getQ().getValue();
+
+            BigInteger j = null;
+            if (dhParams.getJ() != null)
+            {
+                j = dhParams.getJ().getValue();
+            }
+
+            DHValidationParameters validation = null;
+            DHValidationParms dhValidationParms = dhParams.getValidationParms();
+            if (dhValidationParms != null)
+            {
+                byte[] seed = dhValidationParms.getSeed().getBytes();
+                BigInteger pgenCounter = dhValidationParms.getPgenCounter().getValue();
+
+                // TODO Check pgenCounter size?
+
+                validation = new DHValidationParameters(seed, pgenCounter.intValue());
+            }
+
+            return new DHPublicKeyParameters(y, new DHParameters(p, g, q, j, validation));
+        }
+        else if (algId.getObjectId().equals(PKCSObjectIdentifiers.dhKeyAgreement))
+        {
+            DHParameter params = new DHParameter(
+                (ASN1Sequence)keyInfo.getAlgorithmId().getParameters());
+            DERInteger derY = (DERInteger)keyInfo.getPublicKey();
+
+            BigInteger lVal = params.getL();
+            int l = lVal == null ? 0 : lVal.intValue();
+            DHParameters dhParams = new DHParameters(params.getP(), params.getG(), null, l);
+
+            return new DHPublicKeyParameters(derY.getValue(), dhParams);
+        }
+        else if (algId.getObjectId().equals(OIWObjectIdentifiers.elGamalAlgorithm))
+        {
+            ElGamalParameter params = new ElGamalParameter(
+                (ASN1Sequence)keyInfo.getAlgorithmId().getParameters());
+            DERInteger derY = (DERInteger)keyInfo.getPublicKey();
+
+            return new ElGamalPublicKeyParameters(derY.getValue(), new ElGamalParameters(
+                params.getP(), params.getG()));
+        }
+        else if (algId.getObjectId().equals(X9ObjectIdentifiers.id_dsa)
+            || algId.getObjectId().equals(OIWObjectIdentifiers.dsaWithSHA1))
+        {
+            DERInteger derY = (DERInteger)keyInfo.getPublicKey();
+            DEREncodable de = keyInfo.getAlgorithmId().getParameters();
+
+            DSAParameters parameters = null;
+            if (de != null)
+            {
+                DSAParameter params = DSAParameter.getInstance(de.getDERObject());
+                parameters = new DSAParameters(params.getP(), params.getQ(), params.getG());
+            }
+
+            return new DSAPublicKeyParameters(derY.getValue(), parameters);
+        }
+        else if (algId.getObjectId().equals(X9ObjectIdentifiers.id_ecPublicKey))
+        {
+            X962Parameters params = new X962Parameters(
+                (DERObject)keyInfo.getAlgorithmId().getParameters());
+            ECDomainParameters dParams = null;
+
+            if (params.isNamedCurve())
+            {
+                DERObjectIdentifier oid = (DERObjectIdentifier)params.getParameters();
+                X9ECParameters ecP = X962NamedCurves.getByOID(oid);
+
+                if (ecP == null)
+                {
+                    ecP = SECNamedCurves.getByOID(oid);
+
+                    if (ecP == null)
+                    {
+                        ecP = NISTNamedCurves.getByOID(oid);
+
+                        if (ecP == null)
+                        {
+                            ecP = TeleTrusTNamedCurves.getByOID(oid);
+                        }
+                    }
+                }
+
+                dParams = new ECDomainParameters(ecP.getCurve(), ecP.getG(), ecP.getN(),
+                    ecP.getH(), ecP.getSeed());
+            }
+            else
+            {
+                X9ECParameters ecP = new X9ECParameters((ASN1Sequence)params.getParameters());
+                dParams = new ECDomainParameters(ecP.getCurve(), ecP.getG(), ecP.getN(),
+                    ecP.getH(), ecP.getSeed());
+            }
+
+            DERBitString bits = keyInfo.getPublicKeyData();
+            byte[] data = bits.getBytes();
+            ASN1OctetString key = new DEROctetString(data);
+
+            X9ECPoint derQ = new X9ECPoint(dParams.getCurve(), key);
+
+            return new ECPublicKeyParameters(derQ.getPoint(), dParams);
+        }
+        else
+        {
+            throw new RuntimeException("algorithm identifier in key not recognised");
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/util/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/util/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/util/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Some general utility/conversion classes.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,92 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+public class ECAlgorithms
+{
+    public static ECPoint sumOfTwoMultiplies(ECPoint P, BigInteger a,
+        ECPoint Q, BigInteger b)
+    {
+        ECCurve c = P.getCurve();
+        if (!c.equals(Q.getCurve()))
+        {
+            throw new IllegalArgumentException("P and Q must be on same curve");
+        }
+
+        // Point multiplication for Koblitz curves (using WTNAF) beats Shamir's trick
+        if (c instanceof ECCurve.F2m)
+        {
+            ECCurve.F2m f2mCurve = (ECCurve.F2m)c;
+            if (f2mCurve.isKoblitz())
+            {
+                return P.multiply(a).add(Q.multiply(b));
+            }
+        }
+
+        return implShamirsTrick(P, a, Q, b);
+    }
+
+    /*
+     * "Shamir's Trick", originally due to E. G. Straus
+     * (Addition chains of vectors. American Mathematical Monthly,
+     * 71(7):806-808, Aug./Sept. 1964)
+     * <pre>
+     * Input: The points P, Q, scalar k = (km?, ... , k1, k0)
+     * and scalar l = (lm?, ... , l1, l0).
+     * Output: R = k * P + l * Q.
+     * 1: Z <- P + Q
+     * 2: R <- O
+     * 3: for i from m-1 down to 0 do
+     * 4:        R <- R + R        {point doubling}
+     * 5:        if (ki = 1) and (li = 0) then R <- R + P end if
+     * 6:        if (ki = 0) and (li = 1) then R <- R + Q end if
+     * 7:        if (ki = 1) and (li = 1) then R <- R + Z end if
+     * 8: end for
+     * 9: return R
+     * </pre>
+     */
+    public static ECPoint shamirsTrick(ECPoint P, BigInteger k,
+        ECPoint Q, BigInteger l)
+    {
+        if (!P.getCurve().equals(Q.getCurve()))
+        {
+            throw new IllegalArgumentException("P and Q must be on same curve");
+        }
+
+        return implShamirsTrick(P, k, Q, l);
+    }
+
+    private static ECPoint implShamirsTrick(ECPoint P, BigInteger k,
+        ECPoint Q, BigInteger l)
+    {
+        int m = Math.max(k.bitLength(), l.bitLength());
+        ECPoint Z = P.add(Q);
+        ECPoint R = P.getCurve().getInfinity();
+
+        for (int i = m - 1; i >= 0; --i)
+        {
+            R = R.twice();
+
+            if (k.testBit(i))
+            {
+                if (l.testBit(i))
+                {
+                    R = R.add(Z);
+                }
+                else
+                {
+                    R = R.add(P);
+                }
+            }
+            else
+            {
+                if (l.testBit(i))
+                {
+                    R = R.add(Q);
+                }
+            }
+        }
+
+        return R;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ECConstants.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECConstants.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECConstants.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECConstants.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECConstants.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+public interface ECConstants
+{
+    public static final BigInteger ZERO = BigInteger.valueOf(0);
+    public static final BigInteger ONE = BigInteger.valueOf(1);
+    public static final BigInteger TWO = BigInteger.valueOf(2);
+    public static final BigInteger THREE = BigInteger.valueOf(3);
+    public static final BigInteger FOUR = BigInteger.valueOf(4);
+}

Added: trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECCurve.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECCurve.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECCurve.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECCurve.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECCurve.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,668 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+import ewe.util.Random;
+
+/**
+ * base class for an elliptic curve
+ */
+public abstract class ECCurve
+{
+    ECFieldElement a, b;
+
+    public abstract int getFieldSize();
+
+    public abstract ECFieldElement fromBigInteger(BigInteger x);
+
+    public abstract ECPoint createPoint(BigInteger x, BigInteger y, boolean withCompression);
+
+    public abstract ECPoint decodePoint(byte[] encoded);
+
+    public abstract ECPoint getInfinity();
+
+    public ECFieldElement getA()
+    {
+        return a;
+    }
+
+    public ECFieldElement getB()
+    {
+        return b;
+    }
+
+    /**
+     * Elliptic curve over Fp
+     */
+    public static class Fp extends ECCurve
+    {
+        BigInteger q;
+        ECPoint.Fp infinity;
+
+        public Fp(BigInteger q, BigInteger a, BigInteger b)
+        {
+            this.q = q;
+            this.a = fromBigInteger(a);
+            this.b = fromBigInteger(b);
+            this.infinity = new ECPoint.Fp(this, null, null);
+        }
+
+        public BigInteger getQ()
+        {
+            return q;
+        }
+
+        public int getFieldSize()
+        {
+            return q.bitLength();
+        }
+
+        public ECFieldElement fromBigInteger(BigInteger x)
+        {
+            return new ECFieldElement.Fp(this.q, x);
+        }
+
+        public ECPoint createPoint(BigInteger x, BigInteger y, boolean withCompression)
+        {
+            return new ECPoint.Fp(this, fromBigInteger(x), fromBigInteger(y), withCompression);
+        }
+
+        /**
+         * Decode a point on this curve from its ASN.1 encoding. The different
+         * encodings are taken account of, including point compression for
+         * <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
+         * @return The decoded point.
+         */
+        public ECPoint decodePoint(byte[] encoded)
+        {
+            ECPoint p = null;
+
+            switch (encoded[0])
+            {
+                // infinity
+            case 0x00:
+                if (encoded.length > 1)
+                {
+                    throw new RuntimeException("Invalid point encoding");
+                }
+                p = getInfinity();
+                break;
+                // compressed
+            case 0x02:
+            case 0x03:
+                int ytilde = encoded[0] & 1;
+                byte[]  i = new byte[encoded.length - 1];
+
+                System.arraycopy(encoded, 1, i, 0, i.length);
+
+                ECFieldElement x = new ECFieldElement.Fp(this.q, new BigInteger(1, i));
+                ECFieldElement alpha = x.multiply(x.square().add(a)).add(b);
+                ECFieldElement beta = alpha.sqrt();
+
+                //
+                // if we can't find a sqrt we haven't got a point on the
+                // curve - run!
+                //
+                if (beta == null)
+                {
+                    throw new RuntimeException("Invalid point compression");
+                }
+
+                int bit0 = (beta.toBigInteger().testBit(0) ? 1 : 0);
+
+                if (bit0 == ytilde)
+                {
+                    p = new ECPoint.Fp(this, x, beta, true);
+                }
+                else
+                {
+                    p = new ECPoint.Fp(this, x,
+                        new ECFieldElement.Fp(this.q, q.subtract(beta.toBigInteger())), true);
+                }
+                break;
+                // uncompressed
+            case 0x04:
+                // hybrid
+            case 0x06:
+            case 0x07:
+                byte[]  xEnc = new byte[(encoded.length - 1) / 2];
+                byte[]  yEnc = new byte[(encoded.length - 1) / 2];
+
+                System.arraycopy(encoded, 1, xEnc, 0, xEnc.length);
+                System.arraycopy(encoded, xEnc.length + 1, yEnc, 0, yEnc.length);
+
+                p = new ECPoint.Fp(this,
+                        new ECFieldElement.Fp(this.q, new BigInteger(1, xEnc)),
+                        new ECFieldElement.Fp(this.q, new BigInteger(1, yEnc)));
+                break;
+            default:
+                throw new RuntimeException("Invalid point encoding 0x" + Integer.toString(encoded[0], 16));
+            }
+
+            return p;
+        }
+
+        public ECPoint getInfinity()
+        {
+            return infinity;
+        }
+
+        public boolean equals(
+            Object anObject) 
+        {
+            if (anObject == this) 
+            {
+                return true;
+            }
+
+            if (!(anObject instanceof ECCurve.Fp)) 
+            {
+                return false;
+            }
+
+            ECCurve.Fp other = (ECCurve.Fp) anObject;
+
+            return this.q.equals(other.q) 
+                    && a.equals(other.a) && b.equals(other.b);
+        }
+
+        public int hashCode() 
+        {
+            return a.hashCode() ^ b.hashCode() ^ q.hashCode();
+        }
+    }
+
+    /**
+     * Elliptic curves over F2m. The Weierstrass equation is given by
+     * <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
+     */
+    public static class F2m extends ECCurve
+    {
+        /**
+         * The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
+         */
+        private int m;  // can't be final - JDK 1.1
+
+        /**
+         * TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
+         * x<sup>k</sup> + 1</code> represents the reduction polynomial
+         * <code>f(z)</code>.<br>
+         * PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        private int k1;  // can't be final - JDK 1.1
+
+        /**
+         * TPB: Always set to <code>0</code><br>
+         * PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        private int k2;  // can't be final - JDK 1.1
+
+        /**
+         * TPB: Always set to <code>0</code><br>
+         * PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        private int k3;  // can't be final - JDK 1.1
+
+        /**
+         * The order of the base point of the curve.
+         */
+        private BigInteger n;  // can't be final - JDK 1.1
+
+        /**
+         * The cofactor of the curve.
+         */
+        private BigInteger h;  // can't be final - JDK 1.1
+        
+         /**
+         * The point at infinity on this curve.
+         */
+        private ECPoint.F2m infinity;  // can't be final - JDK 1.1
+
+        /**
+         * The parameter <code>&mu;</code> of the elliptic curve if this is
+         * a Koblitz curve.
+         */
+        private byte mu = 0;
+
+        /**
+         * The auxiliary values <code>s<sub>0</sub></code> and
+         * <code>s<sub>1</sub></code> used for partial modular reduction for
+         * Koblitz curves.
+         */
+        private BigInteger[] si = null;
+
+        /**
+         * Constructor for Trinomial Polynomial Basis (TPB).
+         * @param m  The exponent <code>m</code> of
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param k The integer <code>k</code> where <code>x<sup>m</sup> +
+         * x<sup>k</sup> + 1</code> represents the reduction
+         * polynomial <code>f(z)</code>.
+         * @param a The coefficient <code>a</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param b The coefficient <code>b</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         */
+        public F2m(
+            int m,
+            int k,
+            BigInteger a,
+            BigInteger b)
+        {
+            this(m, k, 0, 0, a, b, null, null);
+        }
+
+        /**
+         * Constructor for Trinomial Polynomial Basis (TPB).
+         * @param m  The exponent <code>m</code> of
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param k The integer <code>k</code> where <code>x<sup>m</sup> +
+         * x<sup>k</sup> + 1</code> represents the reduction
+         * polynomial <code>f(z)</code>.
+         * @param a The coefficient <code>a</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param b The coefficient <code>b</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param n The order of the main subgroup of the elliptic curve.
+         * @param h The cofactor of the elliptic curve, i.e.
+         * <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
+         */
+        public F2m(
+            int m, 
+            int k, 
+            BigInteger a, 
+            BigInteger b,
+            BigInteger n,
+            BigInteger h)
+        {
+            this(m, k, 0, 0, a, b, n, h);
+        }
+
+        /**
+         * Constructor for Pentanomial Polynomial Basis (PPB).
+         * @param m  The exponent <code>m</code> of
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param a The coefficient <code>a</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param b The coefficient <code>b</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         */
+        public F2m(
+            int m,
+            int k1,
+            int k2,
+            int k3,
+            BigInteger a,
+            BigInteger b)
+        {
+            this(m, k1, k2, k3, a, b, null, null);
+        }
+
+        /**
+         * Constructor for Pentanomial Polynomial Basis (PPB).
+         * @param m  The exponent <code>m</code> of
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param a The coefficient <code>a</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param b The coefficient <code>b</code> in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param n The order of the main subgroup of the elliptic curve.
+         * @param h The cofactor of the elliptic curve, i.e.
+         * <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
+         */
+        public F2m(
+            int m, 
+            int k1, 
+            int k2, 
+            int k3,
+            BigInteger a, 
+            BigInteger b,
+            BigInteger n,
+            BigInteger h)
+        {
+            this.m = m;
+            this.k1 = k1;
+            this.k2 = k2;
+            this.k3 = k3;
+            this.n = n;
+            this.h = h;
+
+            if (k1 == 0)
+            {
+                throw new IllegalArgumentException("k1 must be > 0");
+            }
+
+            if (k2 == 0)
+            {
+                if (k3 != 0)
+                {
+                    throw new IllegalArgumentException("k3 must be 0 if k2 == 0");
+                }
+            }
+            else
+            {
+                if (k2 <= k1)
+                {
+                    throw new IllegalArgumentException("k2 must be > k1");
+                }
+
+                if (k3 <= k2)
+                {
+                    throw new IllegalArgumentException("k3 must be > k2");
+                }
+            }
+
+            this.a = fromBigInteger(a);
+            this.b = fromBigInteger(b);
+            this.infinity = new ECPoint.F2m(this, null, null);
+        }
+
+        public int getFieldSize()
+        {
+            return m;
+        }
+
+        public ECFieldElement fromBigInteger(BigInteger x)
+        {
+            return new ECFieldElement.F2m(this.m, this.k1, this.k2, this.k3, x);
+        }
+
+        public ECPoint createPoint(BigInteger x, BigInteger y, boolean withCompression)
+        {
+            return new ECPoint.F2m(this, fromBigInteger(x), fromBigInteger(y), withCompression);
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECCurve#decodePoint(byte[])
+         */
+        public ECPoint decodePoint(byte[] encoded)
+        {
+            ECPoint p = null;
+
+            switch (encoded[0])
+            {
+                // infinity
+            case 0x00:
+                if (encoded.length > 1)
+                {
+                    throw new RuntimeException("Invalid point encoding");
+                }
+                p = getInfinity();
+                break;
+                // compressed
+            case 0x02:
+            case 0x03:
+                byte[] enc = new byte[encoded.length - 1];
+                System.arraycopy(encoded, 1, enc, 0, enc.length);
+                if (encoded[0] == 0x02) 
+                {
+                        p = decompressPoint(enc, 0);
+                }
+                else 
+                {
+                        p = decompressPoint(enc, 1);
+                }
+                break;
+                // uncompressed
+            case 0x04:
+                // hybrid
+            case 0x06:
+            case 0x07:
+                byte[] xEnc = new byte[(encoded.length - 1) / 2];
+                byte[] yEnc = new byte[(encoded.length - 1) / 2];
+
+                System.arraycopy(encoded, 1, xEnc, 0, xEnc.length);
+                System.arraycopy(encoded, xEnc.length + 1, yEnc, 0, yEnc.length);
+
+                p = new ECPoint.F2m(this,
+                    new ECFieldElement.F2m(this.m, this.k1, this.k2, this.k3,
+                        new BigInteger(1, xEnc)),
+                    new ECFieldElement.F2m(this.m, this.k1, this.k2, this.k3,
+                        new BigInteger(1, yEnc)), false);
+                break;
+
+            default:
+                throw new RuntimeException("Invalid point encoding 0x" + Integer.toString(encoded[0], 16));
+            }
+
+            return p;
+        }
+
+        public ECPoint getInfinity()
+        {
+            return infinity;
+        }
+
+        /**
+         * Returns true if this is a Koblitz curve (ABC curve).
+         * @return true if this is a Koblitz curve (ABC curve), false otherwise
+         */
+        public boolean isKoblitz()
+        {
+            return ((n != null) && (h != null) &&
+                    ((a.toBigInteger().equals(ECConstants.ZERO)) ||
+                    (a.toBigInteger().equals(ECConstants.ONE))) &&
+                    (b.toBigInteger().equals(ECConstants.ONE)));
+        }
+
+        /**
+         * Returns the parameter <code>&mu;</code> of the elliptic curve.
+         * @return <code>&mu;</code> of the elliptic curve.
+         * @throws IllegalArgumentException if the given ECCurve is not a
+         * Koblitz curve.
+         */
+        synchronized byte getMu()
+        {
+            if (mu == 0)
+            {
+                mu = Tnaf.getMu(this);
+            }
+            return mu;
+        }
+
+        /**
+         * @return the auxiliary values <code>s<sub>0</sub></code> and
+         * <code>s<sub>1</sub></code> used for partial modular reduction for
+         * Koblitz curves.
+         */
+        synchronized BigInteger[] getSi()
+        {
+            if (si == null)
+            {
+                si = Tnaf.getSi(this);
+            }
+            return si;
+        }
+
+        /**
+         * Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
+         * 
+         * @param xEnc
+         *            The encoding of field element xp.
+         * @param ypBit
+         *            ~yp, an indication bit for the decompression of yp.
+         * @return the decompressed point.
+         */
+        private ECPoint decompressPoint(
+            byte[] xEnc, 
+            int ypBit)
+        {
+            ECFieldElement xp = new ECFieldElement.F2m(
+                    this.m, this.k1, this.k2, this.k3, new BigInteger(1, xEnc));
+            ECFieldElement yp = null;
+            if (xp.toBigInteger().equals(ECConstants.ZERO))
+            {
+                yp = (ECFieldElement.F2m)b;
+                for (int i = 0; i < m - 1; i++)
+                {
+                    yp = yp.square();
+                }
+            }
+            else
+            {
+                ECFieldElement beta = xp.add(a).add(
+                        b.multiply(xp.square().invert()));
+                ECFieldElement z = solveQuadradicEquation(beta);
+                if (z == null)
+                {
+                    throw new RuntimeException("Invalid point compression");
+                }
+                int zBit = 0;
+                if (z.toBigInteger().testBit(0))
+                {
+                    zBit = 1;
+                }
+                if (zBit != ypBit)
+                {
+                    z = z.add(new ECFieldElement.F2m(this.m, this.k1, this.k2,
+                            this.k3, ECConstants.ONE));
+                }
+                yp = xp.multiply(z);
+            }
+            
+            return new ECPoint.F2m(this, xp, yp);
+        }
+        
+        /**
+         * Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
+         * D.1.6) The other solution is <code>z + 1</code>.
+         * 
+         * @param beta
+         *            The value to solve the qradratic equation for.
+         * @return the solution for <code>z<sup>2</sup> + z = beta</code> or
+         *         <code>null</code> if no solution exists.
+         */
+        private ECFieldElement solveQuadradicEquation(ECFieldElement beta)
+        {
+            ECFieldElement zeroElement = new ECFieldElement.F2m(
+                    this.m, this.k1, this.k2, this.k3, ECConstants.ZERO);
+
+            if (beta.toBigInteger().equals(ECConstants.ZERO))
+            {
+                return zeroElement;
+            }
+
+            ECFieldElement z = null;
+            ECFieldElement gamma = zeroElement;
+
+            Random rand = new Random();
+            do
+            {
+                ECFieldElement t = new ECFieldElement.F2m(this.m, this.k1,
+                        this.k2, this.k3, new BigInteger(m, rand));
+                z = zeroElement;
+                ECFieldElement w = beta;
+                for (int i = 1; i <= m - 1; i++)
+                {
+                    ECFieldElement w2 = w.square();
+                    z = z.square().add(w2.multiply(t));
+                    w = w2.add(beta);
+                }
+                if (!w.toBigInteger().equals(ECConstants.ZERO))
+                {
+                    return null;
+                }
+                gamma = z.square().add(z);
+            }
+            while (gamma.toBigInteger().equals(ECConstants.ZERO));
+
+            return z;
+        }
+        
+        public boolean equals(
+            Object anObject)
+        {
+            if (anObject == this) 
+            {
+                return true;
+            }
+
+            if (!(anObject instanceof ECCurve.F2m)) 
+            {
+                return false;
+            }
+
+            ECCurve.F2m other = (ECCurve.F2m)anObject;
+            
+            return (this.m == other.m) && (this.k1 == other.k1)
+                && (this.k2 == other.k2) && (this.k3 == other.k3)
+                && a.equals(other.a) && b.equals(other.b);
+        }
+
+        public int hashCode()
+        {
+            return this.a.hashCode() ^ this.b.hashCode() ^ m ^ k1 ^ k2 ^ k3;
+        }
+
+        public int getM()
+        {
+            return m;
+        }
+
+        /**
+         * Return true if curve uses a Trinomial basis.
+         * 
+         * @return true if curve Trinomial, false otherwise.
+         */
+        public boolean isTrinomial()
+        {
+            return k2 == 0 && k3 == 0;
+        }
+        
+        public int getK1()
+        {
+            return k1;
+        }
+
+        public int getK2()
+        {
+            return k2;
+        }
+
+        public int getK3()
+        {
+            return k3;
+        }
+
+        public BigInteger getN()
+        {
+            return n;
+        }
+
+        public BigInteger getH()
+        {
+            return h;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECFieldElement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECFieldElement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1196 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+import ewe.util.Random;
+
+public abstract class ECFieldElement
+    implements ECConstants
+{
+
+    public abstract BigInteger     toBigInteger();
+    public abstract String         getFieldName();
+    public abstract int            getFieldSize();
+    public abstract ECFieldElement add(ECFieldElement b);
+    public abstract ECFieldElement subtract(ECFieldElement b);
+    public abstract ECFieldElement multiply(ECFieldElement b);
+    public abstract ECFieldElement divide(ECFieldElement b);
+    public abstract ECFieldElement negate();
+    public abstract ECFieldElement square();
+    public abstract ECFieldElement invert();
+    public abstract ECFieldElement sqrt();
+
+    public String toString()
+    {
+        return this.toBigInteger().toString(2);
+    }
+
+    public static class Fp extends ECFieldElement
+    {
+        BigInteger x;
+
+        BigInteger q;
+        
+        public Fp(BigInteger q, BigInteger x)
+        {
+            this.x = x;
+            
+            if (x.compareTo(q) >= 0)
+            {
+                throw new IllegalArgumentException("x value too large in field element");
+            }
+
+            this.q = q;
+        }
+
+        public BigInteger toBigInteger()
+        {
+            return x;
+        }
+
+        /**
+         * return the field name for this field.
+         *
+         * @return the string "Fp".
+         */
+        public String getFieldName()
+        {
+            return "Fp";
+        }
+
+        public int getFieldSize()
+        {
+            return q.bitLength();
+        }
+
+        public BigInteger getQ()
+        {
+            return q;
+        }
+        
+        public ECFieldElement add(ECFieldElement b)
+        {
+            return new Fp(q, x.add(b.toBigInteger()).mod(q));
+        }
+
+        public ECFieldElement subtract(ECFieldElement b)
+        {
+            return new Fp(q, x.subtract(b.toBigInteger()).mod(q));
+        }
+
+        public ECFieldElement multiply(ECFieldElement b)
+        {
+            return new Fp(q, x.multiply(b.toBigInteger()).mod(q));
+        }
+
+        public ECFieldElement divide(ECFieldElement b)
+        {
+            return new Fp(q, x.multiply(b.toBigInteger().modInverse(q)).mod(q));
+        }
+
+        public ECFieldElement negate()
+        {
+            return new Fp(q, x.negate().mod(q));
+        }
+
+        public ECFieldElement square()
+        {
+            return new Fp(q, x.multiply(x).mod(q));
+        }
+
+        public ECFieldElement invert()
+        {
+            return new Fp(q, x.modInverse(q));
+        }
+
+        // D.1.4 91
+        /**
+         * return a sqrt root - the routine verifies that the calculation
+         * returns the right value - if none exists it returns null.
+         */
+        public ECFieldElement sqrt()
+        {
+            if (!q.testBit(0))
+            {
+                throw new RuntimeException("not done yet");
+            }
+
+            // note: even though this class implements ECConstants don't be tempted to
+            // remove the explicit declaration, some J2ME environments don't cope.
+            // p mod 4 == 3
+            if (q.testBit(1))
+            {
+                // z = g^(u+1) + p, p = 4u + 3
+                ECFieldElement z = new Fp(q, x.modPow(q.shiftRight(2).add(ECConstants.ONE), q));
+
+                return z.square().equals(this) ? z : null;
+            }
+
+            // p mod 4 == 1
+            BigInteger qMinusOne = q.subtract(ECConstants.ONE);
+
+            BigInteger legendreExponent = qMinusOne.shiftRight(1);
+            if (!(x.modPow(legendreExponent, q).equals(ECConstants.ONE)))
+            {
+                return null;
+            }
+
+            BigInteger u = qMinusOne.shiftRight(2);
+            BigInteger k = u.shiftLeft(1).add(ECConstants.ONE);
+
+            BigInteger Q = this.x;
+            BigInteger fourQ = Q.shiftLeft(2).mod(q);
+
+            BigInteger U, V;
+            Random rand = new Random();
+            do
+            {
+                BigInteger P;
+                do
+                {
+                    P = new BigInteger(q.bitLength(), rand);
+                }
+                while (P.compareTo(q) >= 0
+                    || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, q).equals(qMinusOne)));
+
+                BigInteger[] result = lucasSequence(q, P, Q, k);
+                U = result[0];
+                V = result[1];
+
+                if (V.multiply(V).mod(q).equals(fourQ))
+                {
+                    // Integer division by 2, mod q
+                    if (V.testBit(0))
+                    {
+                        V = V.add(q);
+                    }
+
+                    V = V.shiftRight(1);
+
+                    //assert V.multiply(V).mod(q).equals(x);
+
+                    return new ECFieldElement.Fp(q, V);
+                }
+            }
+            while (U.equals(ECConstants.ONE) || U.equals(qMinusOne));
+
+            return null;
+
+//            BigInteger qMinusOne = q.subtract(ECConstants.ONE);
+//            BigInteger legendreExponent = qMinusOne.shiftRight(1); //divide(ECConstants.TWO);
+//            if (!(x.modPow(legendreExponent, q).equals(ECConstants.ONE)))
+//            {
+//                return null;
+//            }
+//
+//            Random rand = new Random();
+//            BigInteger fourX = x.shiftLeft(2);
+//
+//            BigInteger r;
+//            do
+//            {
+//                r = new BigInteger(q.bitLength(), rand);
+//            }
+//            while (r.compareTo(q) >= 0
+//                || !(r.multiply(r).subtract(fourX).modPow(legendreExponent, q).equals(qMinusOne)));
+//
+//            BigInteger n1 = qMinusOne.shiftRight(2); //.divide(ECConstants.FOUR);
+//            BigInteger n2 = n1.add(ECConstants.ONE); //q.add(ECConstants.THREE).divide(ECConstants.FOUR);
+//
+//            BigInteger wOne = WOne(r, x, q);
+//            BigInteger wSum = W(n1, wOne, q).add(W(n2, wOne, q)).mod(q);
+//            BigInteger twoR = r.shiftLeft(1); //ECConstants.TWO.multiply(r);
+//
+//            BigInteger root = twoR.modPow(q.subtract(ECConstants.TWO), q)
+//                .multiply(x).mod(q)
+//                .multiply(wSum).mod(q);
+//
+//            return new Fp(q, root);
+        }
+
+//        private static BigInteger W(BigInteger n, BigInteger wOne, BigInteger p)
+//        {
+//            if (n.equals(ECConstants.ONE))
+//            {
+//                return wOne;
+//            }
+//            boolean isEven = !n.testBit(0);
+//            n = n.shiftRight(1);//divide(ECConstants.TWO);
+//            if (isEven)
+//            {
+//                BigInteger w = W(n, wOne, p);
+//                return w.multiply(w).subtract(ECConstants.TWO).mod(p);
+//            }
+//            BigInteger w1 = W(n.add(ECConstants.ONE), wOne, p);
+//            BigInteger w2 = W(n, wOne, p);
+//            return w1.multiply(w2).subtract(wOne).mod(p);
+//        }
+//
+//        private BigInteger WOne(BigInteger r, BigInteger x, BigInteger p)
+//        {
+//            return r.multiply(r).multiply(x.modPow(q.subtract(ECConstants.TWO), q)).subtract(ECConstants.TWO).mod(p);
+//        }
+
+        private static BigInteger[] lucasSequence(
+            BigInteger  p,
+            BigInteger  P,
+            BigInteger  Q,
+            BigInteger  k)
+        {
+            int n = k.bitLength();
+            int s = k.getLowestSetBit();
+
+            BigInteger Uh = ECConstants.ONE;
+            BigInteger Vl = ECConstants.TWO;
+            BigInteger Vh = P;
+            BigInteger Ql = ECConstants.ONE;
+            BigInteger Qh = ECConstants.ONE;
+
+            for (int j = n - 1; j >= s + 1; --j)
+            {
+                Ql = Ql.multiply(Qh).mod(p);
+
+                if (k.testBit(j))
+                {
+                    Qh = Ql.multiply(Q).mod(p);
+                    Uh = Uh.multiply(Vh).mod(p);
+                    Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
+                    Vh = Vh.multiply(Vh).subtract(Qh.shiftLeft(1)).mod(p);
+                }
+                else
+                {
+                    Qh = Ql;
+                    Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
+                    Vh = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
+                    Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
+                }
+            }
+
+            Ql = Ql.multiply(Qh).mod(p);
+            Qh = Ql.multiply(Q).mod(p);
+            Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
+            Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
+            Ql = Ql.multiply(Qh).mod(p);
+
+            for (int j = 1; j <= s; ++j)
+            {
+                Uh = Uh.multiply(Vl).mod(p);
+                Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
+                Ql = Ql.multiply(Ql).mod(p);
+            }
+
+            return new BigInteger[]{ Uh, Vl };
+        }
+        
+        public boolean equals(Object other)
+        {
+            if (other == this)
+            {
+                return true;
+            }
+
+            if (!(other instanceof ECFieldElement.Fp))
+            {
+                return false;
+            }
+            
+            ECFieldElement.Fp o = (ECFieldElement.Fp)other;
+            return q.equals(o.q) && x.equals(o.x);
+        }
+
+        public int hashCode()
+        {
+            return q.hashCode() ^ x.hashCode();
+        }
+    }
+
+//    /**
+//     * Class representing the Elements of the finite field
+//     * <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
+//     * representation. Both trinomial (TPB) and pentanomial (PPB) polynomial
+//     * basis representations are supported. Gaussian normal basis (GNB)
+//     * representation is not supported.
+//     */
+//    public static class F2m extends ECFieldElement
+//    {
+//        BigInteger x;
+//
+//        /**
+//         * Indicates gaussian normal basis representation (GNB). Number chosen
+//         * according to X9.62. GNB is not implemented at present.
+//         */
+//        public static final int GNB = 1;
+//
+//        /**
+//         * Indicates trinomial basis representation (TPB). Number chosen
+//         * according to X9.62.
+//         */
+//        public static final int TPB = 2;
+//
+//        /**
+//         * Indicates pentanomial basis representation (PPB). Number chosen
+//         * according to X9.62.
+//         */
+//        public static final int PPB = 3;
+//
+//        /**
+//         * TPB or PPB.
+//         */
+//        private int representation;
+//
+//        /**
+//         * The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
+//         */
+//        private int m;
+//
+//        /**
+//         * TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
+//         * x<sup>k</sup> + 1</code> represents the reduction polynomial
+//         * <code>f(z)</code>.<br>
+//         * PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.<br>
+//         */
+//        private int k1;
+//
+//        /**
+//         * TPB: Always set to <code>0</code><br>
+//         * PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.<br>
+//         */
+//        private int k2;
+//
+//        /**
+//         * TPB: Always set to <code>0</code><br>
+//         * PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.<br>
+//         */
+//        private int k3;
+//        
+//        /**
+//         * Constructor for PPB.
+//         * @param m  The exponent <code>m</code> of
+//         * <code>F<sub>2<sup>m</sup></sub></code>.
+//         * @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.
+//         * @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.
+//         * @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.
+//         * @param x The BigInteger representing the value of the field element.
+//         */
+//        public F2m(
+//            int m, 
+//            int k1, 
+//            int k2, 
+//            int k3,
+//            BigInteger x)
+//        {
+////            super(x);
+//            this.x = x;
+//
+//            if ((k2 == 0) && (k3 == 0))
+//            {
+//                this.representation = TPB;
+//            }
+//            else
+//            {
+//                if (k2 >= k3)
+//                {
+//                    throw new IllegalArgumentException(
+//                            "k2 must be smaller than k3");
+//                }
+//                if (k2 <= 0)
+//                {
+//                    throw new IllegalArgumentException(
+//                            "k2 must be larger than 0");
+//                }
+//                this.representation = PPB;
+//            }
+//
+//            if (x.signum() < 0)
+//            {
+//                throw new IllegalArgumentException("x value cannot be negative");
+//            }
+//
+//            this.m = m;
+//            this.k1 = k1;
+//            this.k2 = k2;
+//            this.k3 = k3;
+//        }
+//
+//        /**
+//         * Constructor for TPB.
+//         * @param m  The exponent <code>m</code> of
+//         * <code>F<sub>2<sup>m</sup></sub></code>.
+//         * @param k The integer <code>k</code> where <code>x<sup>m</sup> +
+//         * x<sup>k</sup> + 1</code> represents the reduction
+//         * polynomial <code>f(z)</code>.
+//         * @param x The BigInteger representing the value of the field element.
+//         */
+//        public F2m(int m, int k, BigInteger x)
+//        {
+//            // Set k1 to k, and set k2 and k3 to 0
+//            this(m, k, 0, 0, x);
+//        }
+//
+//        public BigInteger toBigInteger()
+//        {
+//            return x;
+//        }
+//
+//        public String getFieldName()
+//        {
+//            return "F2m";
+//        }
+//
+//        public int getFieldSize()
+//        {
+//            return m;
+//        }
+//
+//        /**
+//         * Checks, if the ECFieldElements <code>a</code> and <code>b</code>
+//         * are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
+//         * (having the same representation).
+//         * @param a field element.
+//         * @param b field element to be compared.
+//         * @throws IllegalArgumentException if <code>a</code> and <code>b</code>
+//         * are not elements of the same field
+//         * <code>F<sub>2<sup>m</sup></sub></code> (having the same
+//         * representation). 
+//         */
+//        public static void checkFieldElements(
+//            ECFieldElement a,
+//            ECFieldElement b)
+//        {
+//            if ((!(a instanceof F2m)) || (!(b instanceof F2m)))
+//            {
+//                throw new IllegalArgumentException("Field elements are not "
+//                        + "both instances of ECFieldElement.F2m");
+//            }
+//
+//            if ((a.toBigInteger().signum() < 0) || (b.toBigInteger().signum() < 0))
+//            {
+//                throw new IllegalArgumentException(
+//                        "x value may not be negative");
+//            }
+//
+//            ECFieldElement.F2m aF2m = (ECFieldElement.F2m)a;
+//            ECFieldElement.F2m bF2m = (ECFieldElement.F2m)b;
+//
+//            if ((aF2m.m != bF2m.m) || (aF2m.k1 != bF2m.k1)
+//                    || (aF2m.k2 != bF2m.k2) || (aF2m.k3 != bF2m.k3))
+//            {
+//                throw new IllegalArgumentException("Field elements are not "
+//                        + "elements of the same field F2m");
+//            }
+//
+//            if (aF2m.representation != bF2m.representation)
+//            {
+//                // Should never occur
+//                throw new IllegalArgumentException(
+//                        "One of the field "
+//                                + "elements are not elements has incorrect representation");
+//            }
+//        }
+//
+//        /**
+//         * Computes <code>z * a(z) mod f(z)</code>, where <code>f(z)</code> is
+//         * the reduction polynomial of <code>this</code>.
+//         * @param a The polynomial <code>a(z)</code> to be multiplied by
+//         * <code>z mod f(z)</code>.
+//         * @return <code>z * a(z) mod f(z)</code>
+//         */
+//        private BigInteger multZModF(final BigInteger a)
+//        {
+//            // Left-shift of a(z)
+//            BigInteger az = a.shiftLeft(1);
+//            if (az.testBit(this.m)) 
+//            {
+//                // If the coefficient of z^m in a(z) equals 1, reduction
+//                // modulo f(z) is performed: Add f(z) to to a(z):
+//                // Step 1: Unset mth coeffient of a(z)
+//                az = az.clearBit(this.m);
+//
+//                // Step 2: Add r(z) to a(z), where r(z) is defined as
+//                // f(z) = z^m + r(z), and k1, k2, k3 are the positions of
+//                // the non-zero coefficients in r(z)
+//                az = az.flipBit(0);
+//                az = az.flipBit(this.k1);
+//                if (this.representation == PPB) 
+//                {
+//                    az = az.flipBit(this.k2);
+//                    az = az.flipBit(this.k3);
+//                }
+//            }
+//            return az;
+//        }
+//
+//        public ECFieldElement add(final ECFieldElement b)
+//        {
+//            // No check performed here for performance reasons. Instead the
+//            // elements involved are checked in ECPoint.F2m
+//            // checkFieldElements(this, b);
+//            if (b.toBigInteger().signum() == 0)
+//            {
+//                return this;
+//            }
+//
+//            return new F2m(this.m, this.k1, this.k2, this.k3, this.x.xor(b.toBigInteger()));
+//        }
+//
+//        public ECFieldElement subtract(final ECFieldElement b)
+//        {
+//            // Addition and subtraction are the same in F2m
+//            return add(b);
+//        }
+//
+//
+//        public ECFieldElement multiply(final ECFieldElement b)
+//        {
+//            // Left-to-right shift-and-add field multiplication in F2m
+//            // Input: Binary polynomials a(z) and b(z) of degree at most m-1
+//            // Output: c(z) = a(z) * b(z) mod f(z)
+//
+//            // No check performed here for performance reasons. Instead the
+//            // elements involved are checked in ECPoint.F2m
+//            // checkFieldElements(this, b);
+//            final BigInteger az = this.x;
+//            BigInteger bz = b.toBigInteger();
+//            BigInteger cz;
+//
+//            // Compute c(z) = a(z) * b(z) mod f(z)
+//            if (az.testBit(0)) 
+//            {
+//                cz = bz;
+//            } 
+//            else 
+//            {
+//                cz = ECConstants.ZERO;
+//            }
+//
+//            for (int i = 1; i < this.m; i++) 
+//            {
+//                // b(z) := z * b(z) mod f(z)
+//                bz = multZModF(bz);
+//
+//                if (az.testBit(i)) 
+//                {
+//                    // If the coefficient of x^i in a(z) equals 1, b(z) is added
+//                    // to c(z)
+//                    cz = cz.xor(bz);
+//                }
+//            }
+//            return new ECFieldElement.F2m(m, this.k1, this.k2, this.k3, cz);
+//        }
+//
+//
+//        public ECFieldElement divide(final ECFieldElement b)
+//        {
+//            // There may be more efficient implementations
+//            ECFieldElement bInv = b.invert();
+//            return multiply(bInv);
+//        }
+//
+//        public ECFieldElement negate()
+//        {
+//            // -x == x holds for all x in F2m
+//            return this;
+//        }
+//
+//        public ECFieldElement square()
+//        {
+//            // Naive implementation, can probably be speeded up using modular
+//            // reduction
+//            return multiply(this);
+//        }
+//
+//        public ECFieldElement invert()
+//        {
+//            // Inversion in F2m using the extended Euclidean algorithm
+//            // Input: A nonzero polynomial a(z) of degree at most m-1
+//            // Output: a(z)^(-1) mod f(z)
+//
+//            // u(z) := a(z)
+//            BigInteger uz = this.x;
+//            if (uz.signum() <= 0) 
+//            {
+//                throw new ArithmeticException("x is zero or negative, " +
+//                        "inversion is impossible");
+//            }
+//
+//            // v(z) := f(z)
+//            BigInteger vz = ECConstants.ZERO.setBit(m);
+//            vz = vz.setBit(0);
+//            vz = vz.setBit(this.k1);
+//            if (this.representation == PPB) 
+//            {
+//                vz = vz.setBit(this.k2);
+//                vz = vz.setBit(this.k3);
+//            }
+//
+//            // g1(z) := 1, g2(z) := 0
+//            BigInteger g1z = ECConstants.ONE;
+//            BigInteger g2z = ECConstants.ZERO;
+//
+//            // while u != 1
+//            while (!(uz.equals(ECConstants.ZERO))) 
+//            {
+//                // j := deg(u(z)) - deg(v(z))
+//                int j = uz.bitLength() - vz.bitLength();
+//
+//                // If j < 0 then: u(z) <-> v(z), g1(z) <-> g2(z), j := -j
+//                if (j < 0) 
+//                {
+//                    final BigInteger uzCopy = uz;
+//                    uz = vz;
+//                    vz = uzCopy;
+//
+//                    final BigInteger g1zCopy = g1z;
+//                    g1z = g2z;
+//                    g2z = g1zCopy;
+//
+//                    j = -j;
+//                }
+//
+//                // u(z) := u(z) + z^j * v(z)
+//                // Note, that no reduction modulo f(z) is required, because
+//                // deg(u(z) + z^j * v(z)) <= max(deg(u(z)), j + deg(v(z)))
+//                // = max(deg(u(z)), deg(u(z)) - deg(v(z)) + deg(v(z))
+//                // = deg(u(z))
+//                uz = uz.xor(vz.shiftLeft(j));
+//
+//                // g1(z) := g1(z) + z^j * g2(z)
+//                g1z = g1z.xor(g2z.shiftLeft(j));
+////                if (g1z.bitLength() > this.m) {
+////                    throw new ArithmeticException(
+////                            "deg(g1z) >= m, g1z = " + g1z.toString(2));
+////                }
+//            }
+//            return new ECFieldElement.F2m(
+//                    this.m, this.k1, this.k2, this.k3, g2z);
+//        }
+//
+//        public ECFieldElement sqrt()
+//        {
+//            throw new RuntimeException("Not implemented");
+//        }
+//
+//        /**
+//         * @return the representation of the field
+//         * <code>F<sub>2<sup>m</sup></sub></code>, either of
+//         * TPB (trinomial
+//         * basis representation) or
+//         * PPB (pentanomial
+//         * basis representation).
+//         */
+//        public int getRepresentation()
+//        {
+//            return this.representation;
+//        }
+//
+//        /**
+//         * @return the degree <code>m</code> of the reduction polynomial
+//         * <code>f(z)</code>.
+//         */
+//        public int getM()
+//        {
+//            return this.m;
+//        }
+//
+//        /**
+//         * @return TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
+//         * x<sup>k</sup> + 1</code> represents the reduction polynomial
+//         * <code>f(z)</code>.<br>
+//         * PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.<br>
+//         */
+//        public int getK1()
+//        {
+//            return this.k1;
+//        }
+//
+//        /**
+//         * @return TPB: Always returns <code>0</code><br>
+//         * PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.<br>
+//         */
+//        public int getK2()
+//        {
+//            return this.k2;
+//        }
+//
+//        /**
+//         * @return TPB: Always set to <code>0</code><br>
+//         * PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
+//         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+//         * represents the reduction polynomial <code>f(z)</code>.<br>
+//         */
+//        public int getK3()
+//        {
+//            return this.k3;
+//        }
+//
+//        public boolean equals(Object anObject)
+//        {
+//            if (anObject == this) 
+//            {
+//                return true;
+//            }
+//
+//            if (!(anObject instanceof ECFieldElement.F2m)) 
+//            {
+//                return false;
+//            }
+//
+//            ECFieldElement.F2m b = (ECFieldElement.F2m)anObject;
+//            
+//            return ((this.m == b.m) && (this.k1 == b.k1) && (this.k2 == b.k2)
+//                && (this.k3 == b.k3)
+//                && (this.representation == b.representation)
+//                && (this.x.equals(b.x)));
+//        }
+//
+//        public int hashCode()
+//        {
+//            return x.hashCode() ^ m ^ k1 ^ k2 ^ k3;
+//        }
+//    }
+
+    /**
+     * Class representing the Elements of the finite field
+     * <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
+     * representation. Both trinomial (TPB) and pentanomial (PPB) polynomial
+     * basis representations are supported. Gaussian normal basis (GNB)
+     * representation is not supported.
+     */
+    public static class F2m extends ECFieldElement
+    {
+        /**
+         * Indicates gaussian normal basis representation (GNB). Number chosen
+         * according to X9.62. GNB is not implemented at present.
+         */
+        public static final int GNB = 1;
+
+        /**
+         * Indicates trinomial basis representation (TPB). Number chosen
+         * according to X9.62.
+         */
+        public static final int TPB = 2;
+
+        /**
+         * Indicates pentanomial basis representation (PPB). Number chosen
+         * according to X9.62.
+         */
+        public static final int PPB = 3;
+
+        /**
+         * TPB or PPB.
+         */
+        private int representation;
+
+        /**
+         * The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
+         */
+        private int m;
+
+        /**
+         * TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
+         * x<sup>k</sup> + 1</code> represents the reduction polynomial
+         * <code>f(z)</code>.<br>
+         * PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        private int k1;
+
+        /**
+         * TPB: Always set to <code>0</code><br>
+         * PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        private int k2;
+
+        /**
+         * TPB: Always set to <code>0</code><br>
+         * PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        private int k3;
+
+        /**
+         * The <code>IntArray</code> holding the bits.
+         */
+        private IntArray x;
+
+        /**
+         * The number of <code>int</code>s required to hold <code>m</code> bits.
+         */
+        private int t;
+
+        /**
+         * Constructor for PPB.
+         * @param m  The exponent <code>m</code> of
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.
+         * @param x The BigInteger representing the value of the field element.
+         */
+        public F2m(
+            int m, 
+            int k1, 
+            int k2, 
+            int k3,
+            BigInteger x)
+        {
+            // t = m / 32 rounded up to the next integer
+            t = (m + 31) >> 5;
+            this.x = new IntArray(x, t);
+
+            if ((k2 == 0) && (k3 == 0))
+            {
+                this.representation = TPB;
+            }
+            else
+            {
+                if (k2 >= k3)
+                {
+                    throw new IllegalArgumentException(
+                            "k2 must be smaller than k3");
+                }
+                if (k2 <= 0)
+                {
+                    throw new IllegalArgumentException(
+                            "k2 must be larger than 0");
+                }
+                this.representation = PPB;
+            }
+
+            if (x.signum() < 0)
+            {
+                throw new IllegalArgumentException("x value cannot be negative");
+            }
+
+            this.m = m;
+            this.k1 = k1;
+            this.k2 = k2;
+            this.k3 = k3;
+        }
+
+        /**
+         * Constructor for TPB.
+         * @param m  The exponent <code>m</code> of
+         * <code>F<sub>2<sup>m</sup></sub></code>.
+         * @param k The integer <code>k</code> where <code>x<sup>m</sup> +
+         * x<sup>k</sup> + 1</code> represents the reduction
+         * polynomial <code>f(z)</code>.
+         * @param x The BigInteger representing the value of the field element.
+         */
+        public F2m(int m, int k, BigInteger x)
+        {
+            // Set k1 to k, and set k2 and k3 to 0
+            this(m, k, 0, 0, x);
+        }
+
+        private F2m(int m, int k1, int k2, int k3, IntArray x)
+        {
+            t = (m + 31) >> 5;
+            this.x = x;
+            this.m = m;
+            this.k1 = k1;
+            this.k2 = k2;
+            this.k3 = k3;
+
+            if ((k2 == 0) && (k3 == 0))
+            {
+                this.representation = TPB;
+            }
+            else
+            {
+                this.representation = PPB;
+            }
+
+        }
+
+        public BigInteger toBigInteger()
+        {
+            return x.toBigInteger();
+        }
+
+        public String getFieldName()
+        {
+            return "F2m";
+        }
+
+        public int getFieldSize()
+        {
+            return m;
+        }
+
+        /**
+         * Checks, if the ECFieldElements <code>a</code> and <code>b</code>
+         * are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
+         * (having the same representation).
+         * @param a field element.
+         * @param b field element to be compared.
+         * @throws IllegalArgumentException if <code>a</code> and <code>b</code>
+         * are not elements of the same field
+         * <code>F<sub>2<sup>m</sup></sub></code> (having the same
+         * representation). 
+         */
+        public static void checkFieldElements(
+            ECFieldElement a,
+            ECFieldElement b)
+        {
+            if ((!(a instanceof F2m)) || (!(b instanceof F2m)))
+            {
+                throw new IllegalArgumentException("Field elements are not "
+                        + "both instances of ECFieldElement.F2m");
+            }
+
+            ECFieldElement.F2m aF2m = (ECFieldElement.F2m)a;
+            ECFieldElement.F2m bF2m = (ECFieldElement.F2m)b;
+
+            if ((aF2m.m != bF2m.m) || (aF2m.k1 != bF2m.k1)
+                    || (aF2m.k2 != bF2m.k2) || (aF2m.k3 != bF2m.k3))
+            {
+                throw new IllegalArgumentException("Field elements are not "
+                        + "elements of the same field F2m");
+            }
+
+            if (aF2m.representation != bF2m.representation)
+            {
+                // Should never occur
+                throw new IllegalArgumentException(
+                        "One of the field "
+                                + "elements are not elements has incorrect representation");
+            }
+        }
+
+        public ECFieldElement add(final ECFieldElement b)
+        {
+            // No check performed here for performance reasons. Instead the
+            // elements involved are checked in ECPoint.F2m
+            // checkFieldElements(this, b);
+            IntArray iarrClone = (IntArray)this.x.clone();
+            F2m bF2m = (F2m)b;
+            iarrClone.addShifted(bF2m.x, 0);
+            return new F2m(m, k1, k2, k3, iarrClone);
+        }
+
+        public ECFieldElement subtract(final ECFieldElement b)
+        {
+            // Addition and subtraction are the same in F2m
+            return add(b);
+        }
+
+        public ECFieldElement multiply(final ECFieldElement b)
+        {
+            // Right-to-left comb multiplication in the IntArray
+            // Input: Binary polynomials a(z) and b(z) of degree at most m-1
+            // Output: c(z) = a(z) * b(z) mod f(z)
+
+            // No check performed here for performance reasons. Instead the
+            // elements involved are checked in ECPoint.F2m
+            // checkFieldElements(this, b);
+            F2m bF2m = (F2m)b;
+            IntArray mult = x.multiply(bF2m.x, m);
+            mult.reduce(m, new int[]{k1, k2, k3});
+            return new F2m(m, k1, k2, k3, mult);
+        }
+
+        public ECFieldElement divide(final ECFieldElement b)
+        {
+            // There may be more efficient implementations
+            ECFieldElement bInv = b.invert();
+            return multiply(bInv);
+        }
+
+        public ECFieldElement negate()
+        {
+            // -x == x holds for all x in F2m
+            return this;
+        }
+
+        public ECFieldElement square()
+        {
+            IntArray squared = x.square(m);
+            squared.reduce(m, new int[]{k1, k2, k3});
+            return new F2m(m, k1, k2, k3, squared);
+        }
+
+
+        public ECFieldElement invert()
+        {
+            // Inversion in F2m using the extended Euclidean algorithm
+            // Input: A nonzero polynomial a(z) of degree at most m-1
+            // Output: a(z)^(-1) mod f(z)
+
+            // u(z) := a(z)
+            IntArray uz = (IntArray)this.x.clone();
+
+            // v(z) := f(z)
+            IntArray vz = new IntArray(t);
+            vz.setBit(m);
+            vz.setBit(0);
+            vz.setBit(this.k1);
+            if (this.representation == PPB) 
+            {
+                vz.setBit(this.k2);
+                vz.setBit(this.k3);
+            }
+
+            // g1(z) := 1, g2(z) := 0
+            IntArray g1z = new IntArray(t);
+            g1z.setBit(0);
+            IntArray g2z = new IntArray(t);
+
+            // while u != 0
+            while (!uz.isZero())
+//            while (uz.getUsedLength() > 0)
+//            while (uz.bitLength() > 1)
+            {
+                // j := deg(u(z)) - deg(v(z))
+                int j = uz.bitLength() - vz.bitLength();
+
+                // If j < 0 then: u(z) <-> v(z), g1(z) <-> g2(z), j := -j
+                if (j < 0) 
+                {
+                    final IntArray uzCopy = uz;
+                    uz = vz;
+                    vz = uzCopy;
+
+                    final IntArray g1zCopy = g1z;
+                    g1z = g2z;
+                    g2z = g1zCopy;
+
+                    j = -j;
+                }
+
+                // u(z) := u(z) + z^j * v(z)
+                // Note, that no reduction modulo f(z) is required, because
+                // deg(u(z) + z^j * v(z)) <= max(deg(u(z)), j + deg(v(z)))
+                // = max(deg(u(z)), deg(u(z)) - deg(v(z)) + deg(v(z))
+                // = deg(u(z))
+                // uz = uz.xor(vz.shiftLeft(j));
+                // jInt = n / 32
+                int jInt = j >> 5;
+                // jInt = n % 32
+                int jBit = j & 0x1F;
+                IntArray vzShift = vz.shiftLeft(jBit);
+                uz.addShifted(vzShift, jInt);
+
+                // g1(z) := g1(z) + z^j * g2(z)
+//                g1z = g1z.xor(g2z.shiftLeft(j));
+                IntArray g2zShift = g2z.shiftLeft(jBit);
+                g1z.addShifted(g2zShift, jInt);
+                
+            }
+            return new ECFieldElement.F2m(
+                    this.m, this.k1, this.k2, this.k3, g2z);
+        }
+
+        public ECFieldElement sqrt()
+        {
+            throw new RuntimeException("Not implemented");
+        }
+
+        /**
+         * @return the representation of the field
+         * <code>F<sub>2<sup>m</sup></sub></code>, either of
+         * TPB (trinomial
+         * basis representation) or
+         * PPB (pentanomial
+         * basis representation).
+         */
+        public int getRepresentation()
+        {
+            return this.representation;
+        }
+
+        /**
+         * @return the degree <code>m</code> of the reduction polynomial
+         * <code>f(z)</code>.
+         */
+        public int getM()
+        {
+            return this.m;
+        }
+
+        /**
+         * @return TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
+         * x<sup>k</sup> + 1</code> represents the reduction polynomial
+         * <code>f(z)</code>.<br>
+         * PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        public int getK1()
+        {
+            return this.k1;
+        }
+
+        /**
+         * @return TPB: Always returns <code>0</code><br>
+         * PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        public int getK2()
+        {
+            return this.k2;
+        }
+
+        /**
+         * @return TPB: Always set to <code>0</code><br>
+         * PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
+         * x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
+         * represents the reduction polynomial <code>f(z)</code>.<br>
+         */
+        public int getK3()
+        {
+            return this.k3;
+        }
+
+        public boolean equals(Object anObject)
+        {
+            if (anObject == this) 
+            {
+                return true;
+            }
+
+            if (!(anObject instanceof ECFieldElement.F2m)) 
+            {
+                return false;
+            }
+
+            ECFieldElement.F2m b = (ECFieldElement.F2m)anObject;
+            
+            return ((this.m == b.m) && (this.k1 == b.k1) && (this.k2 == b.k2)
+                && (this.k3 == b.k3)
+                && (this.representation == b.representation)
+                && (this.x.equals(b.x)));
+        }
+
+        public int hashCode()
+        {
+            return x.hashCode() ^ m ^ k1 ^ k2 ^ k3;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Interface for classes encapsulating a point multiplication algorithm
+ * for <code>ECPoint</code>s.
+ */
+interface ECMultiplier
+{
+    /**
+     * Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
+     * <code>p</code> is added <code>k</code> times to itself.
+     * @param p The <code>ECPoint</code> to be multiplied.
+     * @param k The factor by which <code>p</code> i multiplied.
+     * @return <code>p</code> multiplied by <code>k</code>.
+     */
+    ECPoint multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
+}

Added: trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECPoint.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECPoint.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECPoint.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECPoint.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,588 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.x9.X9IntegerConverter;
+
+/**
+ * base class for points on elliptic curves.
+ */
+public abstract class ECPoint
+{
+    ECCurve        curve;
+    ECFieldElement x;
+    ECFieldElement y;
+
+    protected boolean withCompression;
+
+    protected ECMultiplier multiplier = null;
+
+    protected PreCompInfo preCompInfo = null;
+
+    private static X9IntegerConverter converter = new X9IntegerConverter();
+
+    protected ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y)
+    {
+        this.curve = curve;
+        this.x = x;
+        this.y = y;
+    }
+    
+    public ECCurve getCurve()
+    {
+        return curve;
+    }
+    
+    public ECFieldElement getX()
+    {
+        return x;
+    }
+
+    public ECFieldElement getY()
+    {
+        return y;
+    }
+
+    public boolean isInfinity()
+    {
+        return x == null && y == null;
+    }
+
+    public boolean isCompressed()
+    {
+        return withCompression;
+    }
+
+    public boolean equals(
+        Object  other)
+    {
+        if (other == this)
+        {
+            return true;
+        }
+
+        if (!(other instanceof ECPoint))
+        {
+            return false;
+        }
+
+        ECPoint o = (ECPoint)other;
+
+        if (this.isInfinity())
+        {
+            return o.isInfinity();
+        }
+
+        return x.equals(o.x) && y.equals(o.y);
+    }
+
+    public int hashCode()
+    {
+        if (this.isInfinity())
+        {
+            return 0;
+        }
+        
+        return x.hashCode() ^ y.hashCode();
+    }
+
+//    /**
+//     * Mainly for testing. Explicitly set the <code>ECMultiplier</code>.
+//     * @param multiplier The <code>ECMultiplier</code> to be used to multiply
+//     * this <code>ECPoint</code>.
+//     */
+//    public void setECMultiplier(ECMultiplier multiplier)
+//    {
+//        this.multiplier = multiplier;
+//    }
+
+    /**
+     * Sets the <code>PreCompInfo</code>. Used by <code>ECMultiplier</code>s
+     * to save the precomputation for this <code>ECPoint</code> to store the
+     * precomputation result for use by subsequent multiplication.
+     * @param preCompInfo The values precomputed by the
+     * <code>ECMultiplier</code>.
+     */
+    void setPreCompInfo(PreCompInfo preCompInfo)
+    {
+        this.preCompInfo = preCompInfo;
+    }
+
+    public abstract byte[] getEncoded();
+
+    public abstract ECPoint add(ECPoint b);
+    public abstract ECPoint subtract(ECPoint b);
+    public abstract ECPoint negate();
+    public abstract ECPoint twice();
+
+    /**
+     * Sets the default <code>ECMultiplier</code>, unless already set. 
+     */
+    synchronized void assertECMultiplier()
+    {
+        if (this.multiplier == null)
+        {
+            this.multiplier = new FpNafMultiplier();
+        }
+    }
+
+    /**
+     * Multiplies this <code>ECPoint</code> by the given number.
+     * @param k The multiplicator.
+     * @return <code>k * this</code>.
+     */
+    public ECPoint multiply(BigInteger k)
+    {
+        if (k.signum() < 0)
+        {
+            throw new IllegalArgumentException("The multiplicator cannot be negative");
+        }
+
+        if (this.isInfinity())
+        {
+            return this;
+        }
+
+        if (k.signum() == 0)
+        {
+            return this.curve.getInfinity();
+        }
+
+        assertECMultiplier();
+        return this.multiplier.multiply(this, k, preCompInfo);
+    }
+
+    /**
+     * Elliptic curve points over Fp
+     */
+    public static class Fp extends ECPoint
+    {
+        
+        /**
+         * Create a point which encodes with point compression.
+         * 
+         * @param curve the curve to use
+         * @param x affine x co-ordinate
+         * @param y affine y co-ordinate
+         */
+        public Fp(ECCurve curve, ECFieldElement x, ECFieldElement y)
+        {
+            this(curve, x, y, false);
+        }
+
+        /**
+         * Create a point that encodes with or without point compresion.
+         * 
+         * @param curve the curve to use
+         * @param x affine x co-ordinate
+         * @param y affine y co-ordinate
+         * @param withCompression if true encode with point compression
+         */
+        public Fp(ECCurve curve, ECFieldElement x, ECFieldElement y, boolean withCompression)
+        {
+            super(curve, x, y);
+
+            if ((x != null && y == null) || (x == null && y != null))
+            {
+                throw new IllegalArgumentException("Exactly one of the field elements is null");
+            }
+
+            this.withCompression = withCompression;
+        }
+         
+        /**
+         * return the field element encoded with point compression. (S 4.3.6)
+         */
+        public byte[] getEncoded()
+        {
+            if (this.isInfinity()) 
+            {
+                return new byte[1];
+            }
+
+            int qLength = converter.getByteLength(x);
+            
+            if (withCompression)
+            {
+                byte    PC;
+    
+                if (this.getY().toBigInteger().testBit(0))
+                {
+                    PC = 0x03;
+                }
+                else
+                {
+                    PC = 0x02;
+                }
+    
+                byte[]  X = converter.integerToBytes(this.getX().toBigInteger(), qLength);
+                byte[]  PO = new byte[X.length + 1];
+    
+                PO[0] = PC;
+                System.arraycopy(X, 0, PO, 1, X.length);
+    
+                return PO;
+            }
+            else
+            {
+                byte[]  X = converter.integerToBytes(this.getX().toBigInteger(), qLength);
+                byte[]  Y = converter.integerToBytes(this.getY().toBigInteger(), qLength);
+                byte[]  PO = new byte[X.length + Y.length + 1];
+                
+                PO[0] = 0x04;
+                System.arraycopy(X, 0, PO, 1, X.length);
+                System.arraycopy(Y, 0, PO, X.length + 1, Y.length);
+
+                return PO;
+            }
+        }
+
+        // B.3 pg 62
+        public ECPoint add(ECPoint b)
+        {
+            if (this.isInfinity())
+            {
+                return b;
+            }
+
+            if (b.isInfinity())
+            {
+                return this;
+            }
+
+            // Check if b = this or b = -this
+            if (this.x.equals(b.x))
+            {
+                if (this.y.equals(b.y))
+                {
+                    // this = b, i.e. this must be doubled
+                    return this.twice();
+                }
+
+                // this = -b, i.e. the result is the point at infinity
+                return this.curve.getInfinity();
+            }
+
+            ECFieldElement gamma = b.y.subtract(this.y).divide(b.x.subtract(this.x));
+
+            ECFieldElement x3 = gamma.square().subtract(this.x).subtract(b.x);
+            ECFieldElement y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);
+
+            return new ECPoint.Fp(curve, x3, y3);
+        }
+
+        // B.3 pg 62
+        public ECPoint twice()
+        {
+            if (this.isInfinity())
+            {
+                // Twice identity element (point at infinity) is identity
+                return this;
+            }
+
+            if (this.y.toBigInteger().signum() == 0) 
+            {
+                // if y1 == 0, then (x1, y1) == (x1, -y1)
+                // and hence this = -this and thus 2(x1, y1) == infinity
+                return this.curve.getInfinity();
+            }
+
+            ECFieldElement TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));
+            ECFieldElement THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));
+            ECFieldElement gamma = this.x.square().multiply(THREE).add(curve.a).divide(y.multiply(TWO));
+
+            ECFieldElement x3 = gamma.square().subtract(this.x.multiply(TWO));
+            ECFieldElement y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);
+                
+            return new ECPoint.Fp(curve, x3, y3, this.withCompression);
+        }
+
+        // D.3.2 pg 102 (see Note:)
+        public ECPoint subtract(ECPoint b)
+        {
+            if (b.isInfinity())
+            {
+                return this;
+            }
+
+            // Add -b
+            return add(b.negate());
+        }
+
+        public ECPoint negate()
+        {
+            return new ECPoint.Fp(curve, this.x, this.y.negate(), this.withCompression);
+        }
+
+        /**
+         * Sets the default <code>ECMultiplier</code>, unless already set. 
+         */
+        synchronized void assertECMultiplier()
+        {
+            if (this.multiplier == null)
+            {
+                this.multiplier = new WNafMultiplier();
+            }
+        }
+    }
+
+    /**
+     * Elliptic curve points over F2m
+     */
+    public static class F2m extends ECPoint
+    {
+        /**
+         * @param curve base curve
+         * @param x x point
+         * @param y y point
+         */
+        public F2m(ECCurve curve, ECFieldElement x, ECFieldElement y)
+        {
+            this(curve, x, y, false);
+        }
+        
+        /**
+         * @param curve base curve
+         * @param x x point
+         * @param y y point
+         * @param withCompression true if encode with point compression.
+         */
+        public F2m(ECCurve curve, ECFieldElement x, ECFieldElement y, boolean withCompression)
+        {
+            super(curve, x, y);
+
+            if ((x != null && y == null) || (x == null && y != null))
+            {
+                throw new IllegalArgumentException("Exactly one of the field elements is null");
+            }
+            
+            if (x != null)
+            {
+                // Check if x and y are elements of the same field
+                ECFieldElement.F2m.checkFieldElements(this.x, this.y);
+    
+                // Check if x and a are elements of the same field
+                if (curve != null)
+                {
+                    ECFieldElement.F2m.checkFieldElements(this.x, this.curve.getA());
+                }
+            }
+            
+            this.withCompression = withCompression;
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#getEncoded()
+         */
+        public byte[] getEncoded()
+        {
+            if (this.isInfinity()) 
+            {
+                return new byte[1];
+            }
+
+            int byteCount = converter.getByteLength(this.x);
+            byte[] X = converter.integerToBytes(this.getX().toBigInteger(), byteCount);
+            byte[] PO;
+
+            if (withCompression)
+            {
+                // See X9.62 4.3.6 and 4.2.2
+                PO = new byte[byteCount + 1];
+
+                PO[0] = 0x02;
+                // X9.62 4.2.2 and 4.3.6:
+                // if x = 0 then ypTilde := 0, else ypTilde is the rightmost
+                // bit of y * x^(-1)
+                // if ypTilde = 0, then PC := 02, else PC := 03
+                // Note: PC === PO[0]
+                if (!(this.getX().toBigInteger().equals(ECConstants.ZERO)))
+                {
+                    if (this.getY().multiply(this.getX().invert())
+                            .toBigInteger().testBit(0))
+                    {
+                        // ypTilde = 1, hence PC = 03
+                        PO[0] = 0x03;
+                    }
+                }
+
+                System.arraycopy(X, 0, PO, 1, byteCount);
+            }
+            else
+            {
+                byte[] Y = converter.integerToBytes(this.getY().toBigInteger(), byteCount);
+    
+                PO = new byte[byteCount + byteCount + 1];
+    
+                PO[0] = 0x04;
+                System.arraycopy(X, 0, PO, 1, byteCount);
+                System.arraycopy(Y, 0, PO, byteCount + 1, byteCount);    
+            }
+
+            return PO;
+        }
+
+        /**
+         * Check, if two <code>ECPoint</code>s can be added or subtracted.
+         * @param a The first <code>ECPoint</code> to check.
+         * @param b The second <code>ECPoint</code> to check.
+         * @throws IllegalArgumentException if <code>a</code> and <code>b</code>
+         * cannot be added.
+         */
+        private static void checkPoints(ECPoint a, ECPoint b)
+        {
+            // Check, if points are on the same curve
+            if (!(a.curve.equals(b.curve)))
+            {
+                throw new IllegalArgumentException("Only points on the same "
+                        + "curve can be added or subtracted");
+            }
+
+//            ECFieldElement.F2m.checkFieldElements(a.x, b.x);
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#add(org.bouncycastle.math.ec.ECPoint)
+         */
+        public ECPoint add(ECPoint b)
+        {
+            checkPoints(this, b);
+            return addSimple((ECPoint.F2m)b);
+        }
+
+        /**
+         * Adds another <code>ECPoints.F2m</code> to <code>this</code> without
+         * checking if both points are on the same curve. Used by multiplication
+         * algorithms, because there all points are a multiple of the same point
+         * and hence the checks can be omitted.
+         * @param b The other <code>ECPoints.F2m</code> to add to
+         * <code>this</code>.
+         * @return <code>this + b</code>
+         */
+        public ECPoint.F2m addSimple(ECPoint.F2m b)
+        {
+            ECPoint.F2m other = b;
+            if (this.isInfinity())
+            {
+                return other;
+            }
+
+            if (other.isInfinity())
+            {
+                return this;
+            }
+
+            ECFieldElement.F2m x2 = (ECFieldElement.F2m)other.getX();
+            ECFieldElement.F2m y2 = (ECFieldElement.F2m)other.getY();
+
+            // Check if other = this or other = -this
+            if (this.x.equals(x2))
+            {
+                if (this.y.equals(y2))
+                {
+                    // this = other, i.e. this must be doubled
+                    return (ECPoint.F2m)this.twice();
+                }
+
+                // this = -other, i.e. the result is the point at infinity
+                return (ECPoint.F2m)this.curve.getInfinity();
+            }
+
+            ECFieldElement.F2m lambda
+                = (ECFieldElement.F2m)(this.y.add(y2)).divide(this.x.add(x2));
+
+            ECFieldElement.F2m x3
+                = (ECFieldElement.F2m)lambda.square().add(lambda).add(this.x).add(x2).add(this.curve.getA());
+
+            ECFieldElement.F2m y3
+                = (ECFieldElement.F2m)lambda.multiply(this.x.add(x3)).add(x3).add(this.y);
+
+            return new ECPoint.F2m(curve, x3, y3, withCompression);
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#subtract(org.bouncycastle.math.ec.ECPoint)
+         */
+        public ECPoint subtract(ECPoint b)
+        {
+            checkPoints(this, b);
+            return subtractSimple((ECPoint.F2m)b);
+        }
+
+        /**
+         * Subtracts another <code>ECPoints.F2m</code> from <code>this</code>
+         * without checking if both points are on the same curve. Used by
+         * multiplication algorithms, because there all points are a multiple
+         * of the same point and hence the checks can be omitted.
+         * @param b The other <code>ECPoints.F2m</code> to subtract from
+         * <code>this</code>.
+         * @return <code>this - b</code>
+         */
+        public ECPoint.F2m subtractSimple(ECPoint.F2m b)
+        {
+            if (b.isInfinity())
+            {
+                return this;
+            }
+
+            // Add -b
+            return addSimple((ECPoint.F2m)b.negate());
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#twice()
+         */
+        public ECPoint twice()
+        {
+            if (this.isInfinity()) 
+            {
+                // Twice identity element (point at infinity) is identity
+                return this;
+            }
+
+            if (this.x.toBigInteger().signum() == 0) 
+            {
+                // if x1 == 0, then (x1, y1) == (x1, x1 + y1)
+                // and hence this = -this and thus 2(x1, y1) == infinity
+                return this.curve.getInfinity();
+            }
+
+            ECFieldElement.F2m lambda
+                = (ECFieldElement.F2m)this.x.add(this.y.divide(this.x));
+
+            ECFieldElement.F2m x3
+                = (ECFieldElement.F2m)lambda.square().add(lambda).
+                    add(this.curve.getA());
+
+            ECFieldElement ONE = this.curve.fromBigInteger(ECConstants.ONE);
+            ECFieldElement.F2m y3
+                = (ECFieldElement.F2m)this.x.square().add(
+                    x3.multiply(lambda.add(ONE)));
+
+            return new ECPoint.F2m(this.curve, x3, y3, withCompression);
+        }
+
+        public ECPoint negate()
+        {
+            return new ECPoint.F2m(curve, this.getX(), this.getY().add(this.getX()), withCompression);
+        }
+
+        /**
+         * Sets the appropriate <code>ECMultiplier</code>, unless already set. 
+         */
+        synchronized void assertECMultiplier()
+        {
+            if (this.multiplier == null)
+            {
+                if (((ECCurve.F2m)this.curve).isKoblitz())
+                {
+                    this.multiplier = new WTauNafMultiplier();
+                }
+                else
+                {
+                    this.multiplier = new WNafMultiplier();
+                }
+            }
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class implementing the NAF (Non-Adjacent Form) multiplication algorithm.
+ */
+class FpNafMultiplier implements ECMultiplier
+{
+    /**
+     * D.3.2 pg 101
+     * @see org.bouncycastle.math.ec.ECMultiplier#multiply(org.bouncycastle.math.ec.ECPoint, java.math.BigInteger)
+     */
+    public ECPoint multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo)
+    {
+        // TODO Probably should try to add this
+        // BigInteger e = k.mod(n); // n == order of p
+        BigInteger e = k;
+        BigInteger h = e.multiply(BigInteger.valueOf(3));
+
+        ECPoint neg = p.negate();
+        ECPoint R = p;
+
+        for (int i = h.bitLength() - 2; i > 0; --i)
+        {             
+            R = R.twice();
+
+            boolean hBit = h.testBit(i);
+            boolean eBit = e.testBit(i);
+
+            if (hBit != eBit)
+            {
+                R = R.add(hBit ? p : neg);
+            }
+        }
+
+        return R;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/IntArray.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/IntArray.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/IntArray.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/IntArray.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/IntArray.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,518 @@
+package org.bouncycastle.math.ec;
+
+import org.bouncycastle.util.Arrays;
+
+import ewe.math.BigInteger;
+
+class IntArray
+{
+    // TODO make m fixed for the IntArray, and hence compute T once and for all
+
+    private int[] m_ints;
+
+    public IntArray(int intLen)
+    {
+        m_ints = new int[intLen];
+    }
+
+    public IntArray(int[] ints)
+    {
+        m_ints = ints;
+    }
+
+    public IntArray(BigInteger bigInt)
+    {
+        this(bigInt, 0);
+    }
+
+    public IntArray(BigInteger bigInt, int minIntLen)
+    {
+        if (bigInt.signum() == -1)
+        {
+            throw new IllegalArgumentException("Only positive Integers allowed");
+        }
+        if (bigInt.equals(ECConstants.ZERO))
+        {
+            m_ints = new int[] { 0 };
+            return;
+        }
+
+        byte[] barr = bigInt.toByteArray();
+        int barrLen = barr.length;
+        int barrStart = 0;
+        if (barr[0] == 0)
+        {
+            // First byte is 0 to enforce highest (=sign) bit is zero.
+            // In this case ignore barr[0].
+            barrLen--;
+            barrStart = 1;
+        }
+        int intLen = (barrLen + 3) / 4;
+        if (intLen < minIntLen)
+        {
+            m_ints = new int[minIntLen];
+        }
+        else
+        {
+            m_ints = new int[intLen];
+        }
+
+        int iarrJ = intLen - 1;
+        int rem = barrLen % 4 + barrStart;
+        int temp = 0;
+        int barrI = barrStart;
+        if (barrStart < rem)
+        {
+            for (; barrI < rem; barrI++)
+            {
+                temp <<= 8;
+                int barrBarrI = barr[barrI];
+                if (barrBarrI < 0)
+                {
+                    barrBarrI += 256;
+                }
+                temp |= barrBarrI;
+            }
+            m_ints[iarrJ--] = temp;
+        }
+
+        for (; iarrJ >= 0; iarrJ--)
+        {
+            temp = 0;
+            for (int i = 0; i < 4; i++)
+            {
+                temp <<= 8;
+                int barrBarrI = barr[barrI++];
+                if (barrBarrI < 0)
+                {
+                    barrBarrI += 256;
+                }
+                temp |= barrBarrI;
+            }
+            m_ints[iarrJ] = temp;
+        }
+    }
+
+    public boolean isZero()
+    {
+        return m_ints.length == 0
+            || (m_ints[0] == 0 && getUsedLength() == 0);
+    }
+
+    public int getUsedLength()
+    {
+        int highestIntPos = m_ints.length;
+
+        if (highestIntPos < 1)
+        {
+            return 0;
+        }
+
+        // Check if first element will act as sentinel
+        if (m_ints[0] != 0)
+        {
+            while (m_ints[--highestIntPos] == 0)
+            {
+            }
+            return highestIntPos + 1;
+        }
+
+        do
+        {
+            if (m_ints[--highestIntPos] != 0)
+            {
+                return highestIntPos + 1;
+            }
+        }
+        while (highestIntPos > 0);
+
+        return 0;
+    }
+
+    public int bitLength()
+    {
+        // JDK 1.5: see Integer.numberOfLeadingZeros()
+        int intLen = getUsedLength();
+        if (intLen == 0)
+        {
+            return 0;
+        }
+
+        int last = intLen - 1;
+        int highest = m_ints[last];
+        int bits = (last << 5) + 1;
+
+        // A couple of binary search steps
+        if ((highest & 0xffff0000) != 0)
+        {
+            if ((highest & 0xff000000) != 0)
+            {
+                bits += 24;
+                highest >>>= 24;
+            }
+            else
+            {
+                bits += 16;
+                highest >>>= 16;
+            }
+        }
+        else if (highest > 0x000000ff)
+        {
+            bits += 8;
+            highest >>>= 8;
+        }
+
+        while (highest != 1)
+        {
+            ++bits;
+            highest >>>= 1;
+        }
+
+        return bits;
+    }
+
+    private int[] resizedInts(int newLen)
+    {
+        int[] newInts = new int[newLen];
+        int oldLen = m_ints.length;
+        int copyLen = oldLen < newLen ? oldLen : newLen;
+        System.arraycopy(m_ints, 0, newInts, 0, copyLen);
+        return newInts;
+    }
+
+    public BigInteger toBigInteger()
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return ECConstants.ZERO;
+        }
+
+        int highestInt = m_ints[usedLen - 1];
+        byte[] temp = new byte[4];
+        int barrI = 0;
+        boolean trailingZeroBytesDone = false;
+        for (int j = 3; j >= 0; j--)
+        {
+            byte thisByte = (byte) (highestInt >>> (8 * j));
+            if (trailingZeroBytesDone || (thisByte != 0))
+            {
+                trailingZeroBytesDone = true;
+                temp[barrI++] = thisByte;
+            }
+        }
+
+        int barrLen = 4 * (usedLen - 1) + barrI;
+        byte[] barr = new byte[barrLen];
+        for (int j = 0; j < barrI; j++)
+        {
+            barr[j] = temp[j];
+        }
+        // Highest value int is done now
+
+        for (int iarrJ = usedLen - 2; iarrJ >= 0; iarrJ--)
+        {
+            for (int j = 3; j >= 0; j--)
+            {
+                barr[barrI++] = (byte) (m_ints[iarrJ] >>> (8 * j));
+            }
+        }
+        return new BigInteger(1, barr);
+    }
+
+    public void shiftLeft()
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return;
+        }
+        if (m_ints[usedLen - 1] < 0)
+        {
+            // highest bit of highest used byte is set, so shifting left will
+            // make the IntArray one byte longer
+            usedLen++;
+            if (usedLen > m_ints.length)
+            {
+                // make the m_ints one byte longer, because we need one more
+                // byte which is not available in m_ints
+                m_ints = resizedInts(m_ints.length + 1);
+            }
+        }
+
+        boolean carry = false;
+        for (int i = 0; i < usedLen; i++)
+        {
+            // nextCarry is true if highest bit is set
+            boolean nextCarry = m_ints[i] < 0;
+            m_ints[i] <<= 1;
+            if (carry)
+            {
+                // set lowest bit
+                m_ints[i] |= 1;
+            }
+            carry = nextCarry;
+        }
+    }
+
+    public IntArray shiftLeft(int n)
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return this;
+        }
+
+        if (n == 0)
+        {
+            return this;
+        }
+
+        if (n > 31)
+        {
+            throw new IllegalArgumentException("shiftLeft() for max 31 bits "
+                + ", " + n + "bit shift is not possible");
+        }
+
+        int[] newInts = new int[usedLen + 1];
+
+        int nm32 = 32 - n;
+        newInts[0] = m_ints[0] << n;
+        for (int i = 1; i < usedLen; i++)
+        {
+            newInts[i] = (m_ints[i] << n) | (m_ints[i - 1] >>> nm32);
+        }
+        newInts[usedLen] = m_ints[usedLen - 1] >>> nm32;
+
+        return new IntArray(newInts);
+    }
+
+    public void addShifted(IntArray other, int shift)
+    {
+        int usedLenOther = other.getUsedLength();
+        int newMinUsedLen = usedLenOther + shift;
+        if (newMinUsedLen > m_ints.length)
+        {
+            m_ints = resizedInts(newMinUsedLen);
+            //System.out.println("Resize required");
+        }
+
+        for (int i = 0; i < usedLenOther; i++)
+        {
+            m_ints[i + shift] ^= other.m_ints[i];
+        }
+    }
+
+    public int getLength()
+    {
+        return m_ints.length;
+    }
+
+    public boolean testBit(int n)
+    {
+        // theInt = n / 32
+        int theInt = n >> 5;
+        // theBit = n % 32
+        int theBit = n & 0x1F;
+        int tester = 1 << theBit;
+        return ((m_ints[theInt] & tester) != 0);
+    }
+
+    public void flipBit(int n)
+    {
+        // theInt = n / 32
+        int theInt = n >> 5;
+        // theBit = n % 32
+        int theBit = n & 0x1F;
+        int flipper = 1 << theBit;
+        m_ints[theInt] ^= flipper;
+    }
+
+    public void setBit(int n)
+    {
+        // theInt = n / 32
+        int theInt = n >> 5;
+        // theBit = n % 32
+        int theBit = n & 0x1F;
+        int setter = 1 << theBit;
+        m_ints[theInt] |= setter;
+    }
+
+    public IntArray multiply(IntArray other, int m)
+    {
+        // Lenght of c is 2m bits rounded up to the next int (32 bit)
+        int t = (m + 31) >> 5;
+        if (m_ints.length < t)
+        {
+            m_ints = resizedInts(t);
+        }
+
+        IntArray b = new IntArray(other.resizedInts(other.getLength() + 1));
+        IntArray c = new IntArray((m + m + 31) >> 5);
+        // IntArray c = new IntArray(t + t);
+        int testBit = 1;
+        for (int k = 0; k < 32; k++)
+        {
+            for (int j = 0; j < t; j++)
+            {
+                if ((m_ints[j] & testBit) != 0)
+                {
+                    // The kth bit of m_ints[j] is set
+                    c.addShifted(b, j);
+                }
+            }
+            testBit <<= 1;
+            b.shiftLeft();
+        }
+        return c;
+    }
+
+    // public IntArray multiplyLeftToRight(IntArray other, int m) {
+    // // Lenght of c is 2m bits rounded up to the next int (32 bit)
+    // int t = (m + 31) / 32;
+    // if (m_ints.length < t) {
+    // m_ints = resizedInts(t);
+    // }
+    //
+    // IntArray b = new IntArray(other.resizedInts(other.getLength() + 1));
+    // IntArray c = new IntArray((m + m + 31) / 32);
+    // // IntArray c = new IntArray(t + t);
+    // int testBit = 1 << 31;
+    // for (int k = 31; k >= 0; k--) {
+    // for (int j = 0; j < t; j++) {
+    // if ((m_ints[j] & testBit) != 0) {
+    // // The kth bit of m_ints[j] is set
+    // c.addShifted(b, j);
+    // }
+    // }
+    // testBit >>>= 1;
+    // if (k > 0) {
+    // c.shiftLeft();
+    // }
+    // }
+    // return c;
+    // }
+
+    // TODO note, redPol.length must be 3 for TPB and 5 for PPB
+    public void reduce(int m, int[] redPol)
+    {
+        for (int i = m + m - 2; i >= m; i--)
+        {
+            if (testBit(i))
+            {
+                int bit = i - m;
+                flipBit(bit);
+                flipBit(i);
+                int l = redPol.length;
+                while (--l >= 0)
+                {
+                    flipBit(redPol[l] + bit);
+                }
+            }
+        }
+        m_ints = resizedInts((m + 31) >> 5);
+    }
+
+    public IntArray square(int m)
+    {
+        // TODO make the table static final
+        final int[] table = { 0x0, 0x1, 0x4, 0x5, 0x10, 0x11, 0x14, 0x15, 0x40,
+            0x41, 0x44, 0x45, 0x50, 0x51, 0x54, 0x55 };
+
+        int t = (m + 31) >> 5;
+        if (m_ints.length < t)
+        {
+            m_ints = resizedInts(t);
+        }
+
+        IntArray c = new IntArray(t + t);
+
+        // TODO twice the same code, put in separate private method
+        for (int i = 0; i < t; i++)
+        {
+            int v0 = 0;
+            for (int j = 0; j < 4; j++)
+            {
+                v0 = v0 >>> 8;
+                int u = (m_ints[i] >>> (j * 4)) & 0xF;
+                int w = table[u] << 24;
+                v0 |= w;
+            }
+            c.m_ints[i + i] = v0;
+
+            v0 = 0;
+            int upper = m_ints[i] >>> 16;
+            for (int j = 0; j < 4; j++)
+            {
+                v0 = v0 >>> 8;
+                int u = (upper >>> (j * 4)) & 0xF;
+                int w = table[u] << 24;
+                v0 |= w;
+            }
+            c.m_ints[i + i + 1] = v0;
+        }
+        return c;
+    }
+
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof IntArray))
+        {
+            return false;
+        }
+        IntArray other = (IntArray) o;
+        int usedLen = getUsedLength();
+        if (other.getUsedLength() != usedLen)
+        {
+            return false;
+        }
+        for (int i = 0; i < usedLen; i++)
+        {
+            if (m_ints[i] != other.m_ints[i])
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public int hashCode()
+    {
+        int usedLen = getUsedLength();
+        int hash = 1;
+        for (int i = 0; i < usedLen; i++)
+        {
+            hash = hash * 31 + m_ints[i];
+        }
+        return hash;
+    }
+
+    public Object clone()
+    {
+        return new IntArray(Arrays.clone(m_ints));
+    }
+
+    public String toString()
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return "0";
+        }
+
+        StringBuffer sb = new StringBuffer(Integer
+            .toBinaryString(m_ints[usedLen - 1]));
+        for (int iarrJ = usedLen - 2; iarrJ >= 0; iarrJ--)
+        {
+            String hexString = Integer.toBinaryString(m_ints[iarrJ]);
+
+            // Add leading zeroes, except for highest significant int
+            for (int i = hexString.length(); i < 8; i++)
+            {
+                hexString = "0" + hexString;
+            }
+            sb.append(hexString);
+        }
+        return sb.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/PreCompInfo.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/PreCompInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/PreCompInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.math.ec;
+
+/**
+ * Interface for classes storing precomputation data for multiplication
+ * algorithms. Used as a Memento (see GOF patterns) for
+ * <code>WNafMultiplier</code>.
+ */
+interface PreCompInfo
+{
+}

Added: trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,253 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class representing a simple version of a big decimal. A
+ * <code>SimpleBigDecimal</code> is basically a
+ * {@link java.math.BigInteger BigInteger} with a few digits on the right of
+ * the decimal point. The number of (binary) digits on the right of the decimal
+ * point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
+ * Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
+ * automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
+ * taking part in the same arithmetic operation must have equal scale. The
+ * result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
+ * <code>SimpleBigDecimal</code> with double scale.
+ */
+class SimpleBigDecimal
+    //extends Number   // not in J2ME - add compatibility class?
+{
+    private static final long serialVersionUID = 1L;
+
+    private final BigInteger bigInt;
+    private final int scale;
+
+    /**
+     * Returns a <code>SimpleBigDecimal</code> representing the same numerical
+     * value as <code>value</code>.
+     * @param value The value of the <code>SimpleBigDecimal</code> to be
+     * created. 
+     * @param scale The scale of the <code>SimpleBigDecimal</code> to be
+     * created. 
+     * @return The such created <code>SimpleBigDecimal</code>.
+     */
+    public static SimpleBigDecimal getInstance(BigInteger value, int scale)
+    {
+        return new SimpleBigDecimal(value.shiftLeft(scale), scale);
+    }
+
+    /**
+     * Constructor for <code>SimpleBigDecimal</code>. The value of the
+     * constructed <code>SimpleBigDecimal</code> equals <code>bigInt / 
+     * 2<sup>scale</sup></code>.
+     * @param bigInt The <code>bigInt</code> value parameter.
+     * @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
+     */
+    public SimpleBigDecimal(BigInteger bigInt, int scale)
+    {
+        if (scale < 0)
+        {
+            throw new IllegalArgumentException("scale may not be negative");
+        }
+
+        this.bigInt = bigInt;
+        this.scale = scale;
+    }
+
+    private SimpleBigDecimal(SimpleBigDecimal limBigDec)
+    {
+        bigInt = limBigDec.bigInt;
+        scale = limBigDec.scale;
+    }
+
+    private void checkScale(SimpleBigDecimal b)
+    {
+        if (scale != b.scale)
+        {
+            throw new IllegalArgumentException("Only SimpleBigDecimal of " +
+                "same scale allowed in arithmetic operations");
+        }
+    }
+
+    public SimpleBigDecimal adjustScale(int newScale)
+    {
+        if (newScale < 0)
+        {
+            throw new IllegalArgumentException("scale may not be negative");
+        }
+
+        if (newScale == scale)
+        {
+            return new SimpleBigDecimal(this);
+        }
+
+        return new SimpleBigDecimal(bigInt.shiftLeft(newScale - scale),
+                newScale);
+    }
+
+    public SimpleBigDecimal add(SimpleBigDecimal b)
+    {
+        checkScale(b);
+        return new SimpleBigDecimal(bigInt.add(b.bigInt), scale);
+    }
+
+    public SimpleBigDecimal add(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.add(b.shiftLeft(scale)), scale);
+    }
+
+    public SimpleBigDecimal negate()
+    {
+        return new SimpleBigDecimal(bigInt.negate(), scale);
+    }
+
+    public SimpleBigDecimal subtract(SimpleBigDecimal b)
+    {
+        return add(b.negate());
+    }
+
+    public SimpleBigDecimal subtract(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.subtract(b.shiftLeft(scale)),
+                scale);
+    }
+
+    public SimpleBigDecimal multiply(SimpleBigDecimal b)
+    {
+        checkScale(b);
+        return new SimpleBigDecimal(bigInt.multiply(b.bigInt), scale + scale);
+    }
+
+    public SimpleBigDecimal multiply(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.multiply(b), scale);
+    }
+
+    public SimpleBigDecimal divide(SimpleBigDecimal b)
+    {
+        checkScale(b);
+        BigInteger dividend = bigInt.shiftLeft(scale);
+        return new SimpleBigDecimal(dividend.divide(b.bigInt), scale);
+    }
+
+    public SimpleBigDecimal divide(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.divide(b), scale);
+    }
+
+    public SimpleBigDecimal shiftLeft(int n)
+    {
+        return new SimpleBigDecimal(bigInt.shiftLeft(n), scale);
+    }
+
+    public int compareTo(SimpleBigDecimal val)
+    {
+        checkScale(val);
+        return bigInt.compareTo(val.bigInt);
+    }
+
+    public int compareTo(BigInteger val)
+    {
+        return bigInt.compareTo(val.shiftLeft(scale));
+    }
+
+    public BigInteger floor()
+    {
+        return bigInt.shiftRight(scale);
+    }
+
+    public BigInteger round()
+    {
+        SimpleBigDecimal oneHalf = new SimpleBigDecimal(ECConstants.ONE, 1);
+        return add(oneHalf.adjustScale(scale)).floor();
+    }
+
+    public int intValue()
+    {
+        return floor().intValue();
+    }
+    
+    public long longValue()
+    {
+        return floor().longValue();
+    }
+          /* NON-J2ME compliant.
+    public double doubleValue()
+    {
+        return Double.valueOf(toString()).doubleValue();
+    }
+
+    public float floatValue()
+    {
+        return Float.valueOf(toString()).floatValue();
+    }
+       */
+    public int getScale()
+    {
+        return scale;
+    }
+
+    public String toString()
+    {
+        if (scale == 0)
+        {
+            return bigInt.toString();
+        }
+
+        BigInteger floorBigInt = floor();
+        
+        BigInteger fract = bigInt.subtract(floorBigInt.shiftLeft(scale));
+        if (bigInt.signum() == -1)
+        {
+            fract = ECConstants.ONE.shiftLeft(scale).subtract(fract);
+        }
+
+        if ((floorBigInt.signum() == -1) && (!(fract.equals(ECConstants.ZERO))))
+        {
+            floorBigInt = floorBigInt.add(ECConstants.ONE);
+        }
+        String leftOfPoint = floorBigInt.toString();
+
+        char[] fractCharArr = new char[scale];
+        String fractStr = fract.toString(2);
+        int fractLen = fractStr.length();
+        int zeroes = scale - fractLen;
+        for (int i = 0; i < zeroes; i++)
+        {
+            fractCharArr[i] = '0';
+        }
+        for (int j = 0; j < fractLen; j++)
+        {
+            fractCharArr[zeroes + j] = fractStr.charAt(j);
+        }
+        String rightOfPoint = new String(fractCharArr);
+
+        StringBuffer sb = new StringBuffer(leftOfPoint);
+        sb.append(".");
+        sb.append(rightOfPoint);
+
+        return sb.toString();
+    }
+
+    public boolean equals(Object o)
+    {
+        if (this == o)
+        {
+            return true;
+        }
+
+        if (!(o instanceof SimpleBigDecimal))
+        {
+            return false;
+        }
+
+        SimpleBigDecimal other = (SimpleBigDecimal)o;
+        return ((bigInt.equals(other.bigInt)) && (scale == other.scale));
+    }
+
+    public int hashCode()
+    {
+        return bigInt.hashCode() ^ scale;
+    }
+
+}

Added: trunk/src/org/bouncycastle/math/ec/Tnaf.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/Tnaf.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/Tnaf.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/Tnaf.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/Tnaf.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,844 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class holding methods for point multiplication based on the window
+ * &tau;-adic nonadjacent form (WTNAF). The algorithms are based on the
+ * paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
+ * by Jerome A. Solinas. The paper first appeared in the Proceedings of
+ * Crypto 1997.
+ */
+class Tnaf
+{
+    private static final BigInteger MINUS_ONE = ECConstants.ONE.negate();
+    private static final BigInteger MINUS_TWO = ECConstants.TWO.negate();
+    private static final BigInteger MINUS_THREE = ECConstants.THREE.negate();
+
+    /**
+     * The window width of WTNAF. The standard value of 4 is slightly less
+     * than optimal for running time, but keeps space requirements for
+     * precomputation low. For typical curves, a value of 5 or 6 results in
+     * a better running time. When changing this value, the
+     * <code>&alpha;<sub>u</sub></code>'s must be computed differently, see
+     * e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
+     * Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
+     * p. 121-122
+     */
+    public static final byte WIDTH = 4;
+
+    /**
+     * 2<sup>4</sup>
+     */
+    public static final byte POW_2_WIDTH = 16;
+
+    /**
+     * The <code>&alpha;<sub>u</sub></code>'s for <code>a=0</code> as an array
+     * of <code>ZTauElement</code>s.
+     */
+    public static final ZTauElement[] alpha0 = {
+        null,
+        new ZTauElement(ECConstants.ONE, ECConstants.ZERO), null,
+        new ZTauElement(MINUS_THREE, MINUS_ONE), null,
+        new ZTauElement(MINUS_ONE, MINUS_ONE), null,
+        new ZTauElement(ECConstants.ONE, MINUS_ONE), null
+    };
+
+    /**
+     * The <code>&alpha;<sub>u</sub></code>'s for <code>a=0</code> as an array
+     * of TNAFs.
+     */
+    public static final byte[][] alpha0Tnaf = {
+        null, {1}, null, {-1, 0, 1}, null, {1, 0, 1}, null, {-1, 0, 0, 1}
+    };
+
+    /**
+     * The <code>&alpha;<sub>u</sub></code>'s for <code>a=1</code> as an array
+     * of <code>ZTauElement</code>s.
+     */
+    public static final ZTauElement[] alpha1 = {null,
+        new ZTauElement(ECConstants.ONE, ECConstants.ZERO), null,
+        new ZTauElement(MINUS_THREE, ECConstants.ONE), null,
+        new ZTauElement(MINUS_ONE, ECConstants.ONE), null,
+        new ZTauElement(ECConstants.ONE, ECConstants.ONE), null
+    };
+
+    /**
+     * The <code>&alpha;<sub>u</sub></code>'s for <code>a=1</code> as an array
+     * of TNAFs.
+     */
+    public static final byte[][] alpha1Tnaf = {
+        null, {1}, null, {-1, 0, 1}, null, {1, 0, 1}, null, {-1, 0, 0, -1}
+    };
+
+    /**
+     * Computes the norm of an element <code>&lambda;</code> of
+     * <code><b>Z</b>[&tau;]</code>.
+     * @param mu The parameter <code>&mu;</code> of the elliptic curve.
+     * @param lambda The element <code>&lambda;</code> of
+     * <code><b>Z</b>[&tau;]</code>.
+     * @return The norm of <code>&lambda;</code>.
+     */
+    public static BigInteger norm(final byte mu, ZTauElement lambda)
+    {
+        BigInteger norm;
+
+        // s1 = u^2
+        BigInteger s1 = lambda.u.multiply(lambda.u);
+
+        // s2 = u * v
+        BigInteger s2 = lambda.u.multiply(lambda.v);
+
+        // s3 = 2 * v^2
+        BigInteger s3 = lambda.v.multiply(lambda.v).shiftLeft(1);
+
+        if (mu == 1)
+        {
+            norm = s1.add(s2).add(s3);
+        }
+        else if (mu == -1)
+        {
+            norm = s1.subtract(s2).add(s3);
+        }
+        else
+        {
+            throw new IllegalArgumentException("mu must be 1 or -1");
+        }
+
+        return norm;
+    }
+
+    /**
+     * Computes the norm of an element <code>&lambda;</code> of
+     * <code><b>R</b>[&tau;]</code>, where <code>&lambda; = u + v&tau;</code>
+     * and <code>u</code> and <code>u</code> are real numbers (elements of
+     * <code><b>R</b></code>). 
+     * @param mu The parameter <code>&mu;</code> of the elliptic curve.
+     * @param u The real part of the element <code>&lambda;</code> of
+     * <code><b>R</b>[&tau;]</code>.
+     * @param v The <code>&tau;</code>-adic part of the element
+     * <code>&lambda;</code> of <code><b>R</b>[&tau;]</code>.
+     * @return The norm of <code>&lambda;</code>.
+     */
+    public static SimpleBigDecimal norm(final byte mu, SimpleBigDecimal u,
+            SimpleBigDecimal v)
+    {
+        SimpleBigDecimal norm;
+
+        // s1 = u^2
+        SimpleBigDecimal s1 = u.multiply(u);
+
+        // s2 = u * v
+        SimpleBigDecimal s2 = u.multiply(v);
+
+        // s3 = 2 * v^2
+        SimpleBigDecimal s3 = v.multiply(v).shiftLeft(1);
+
+        if (mu == 1)
+        {
+            norm = s1.add(s2).add(s3);
+        }
+        else if (mu == -1)
+        {
+            norm = s1.subtract(s2).add(s3);
+        }
+        else
+        {
+            throw new IllegalArgumentException("mu must be 1 or -1");
+        }
+
+        return norm;
+    }
+
+    /**
+     * Rounds an element <code>&lambda;</code> of <code><b>R</b>[&tau;]</code>
+     * to an element of <code><b>Z</b>[&tau;]</code>, such that their difference
+     * has minimal norm. <code>&lambda;</code> is given as
+     * <code>&lambda; = &lambda;<sub>0</sub> + &lambda;<sub>1</sub>&tau;</code>.
+     * @param lambda0 The component <code>&lambda;<sub>0</sub></code>.
+     * @param lambda1 The component <code>&lambda;<sub>1</sub></code>.
+     * @param mu The parameter <code>&mu;</code> of the elliptic curve. Must
+     * equal 1 or -1.
+     * @return The rounded element of <code><b>Z</b>[&tau;]</code>.
+     * @throws IllegalArgumentException if <code>lambda0</code> and
+     * <code>lambda1</code> do not have same scale.
+     */
+    public static ZTauElement round(SimpleBigDecimal lambda0,
+            SimpleBigDecimal lambda1, byte mu)
+    {
+        int scale = lambda0.getScale();
+        if (lambda1.getScale() != scale)
+        {
+            throw new IllegalArgumentException("lambda0 and lambda1 do not " +
+                    "have same scale");
+        }
+
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException("mu must be 1 or -1");
+        }
+
+        BigInteger f0 = lambda0.round();
+        BigInteger f1 = lambda1.round();
+
+        SimpleBigDecimal eta0 = lambda0.subtract(f0);
+        SimpleBigDecimal eta1 = lambda1.subtract(f1);
+
+        // eta = 2*eta0 + mu*eta1
+        SimpleBigDecimal eta = eta0.add(eta0);
+        if (mu == 1)
+        {
+            eta = eta.add(eta1);
+        }
+        else
+        {
+            // mu == -1
+            eta = eta.subtract(eta1);
+        }
+
+        // check1 = eta0 - 3*mu*eta1
+        // check2 = eta0 + 4*mu*eta1
+        SimpleBigDecimal threeEta1 = eta1.add(eta1).add(eta1);
+        SimpleBigDecimal fourEta1 = threeEta1.add(eta1);
+        SimpleBigDecimal check1;
+        SimpleBigDecimal check2;
+        if (mu == 1)
+        {
+            check1 = eta0.subtract(threeEta1);
+            check2 = eta0.add(fourEta1);
+        }
+        else
+        {
+            // mu == -1
+            check1 = eta0.add(threeEta1);
+            check2 = eta0.subtract(fourEta1);
+        }
+
+        byte h0 = 0;
+        byte h1 = 0;
+
+        // if eta >= 1
+        if (eta.compareTo(ECConstants.ONE) >= 0)
+        {
+            if (check1.compareTo(MINUS_ONE) < 0)
+            {
+                h1 = mu;
+            }
+            else
+            {
+                h0 = 1;
+            }
+        }
+        else
+        {
+            // eta < 1
+            if (check2.compareTo(ECConstants.TWO) >= 0)
+            {
+                h1 = mu;
+            }
+        }
+
+        // if eta < -1
+        if (eta.compareTo(MINUS_ONE) < 0)
+        {
+            if (check1.compareTo(ECConstants.ONE) >= 0)
+            {
+                h1 = (byte)-mu;
+            }
+            else
+            {
+                h0 = -1;
+            }
+        }
+        else
+        {
+            // eta >= -1
+            if (check2.compareTo(MINUS_TWO) < 0)
+            {
+                h1 = (byte)-mu;
+            }
+        }
+
+        BigInteger q0 = f0.add(BigInteger.valueOf(h0));
+        BigInteger q1 = f1.add(BigInteger.valueOf(h1));
+        return new ZTauElement(q0, q1);
+    }
+
+    /**
+     * Approximate division by <code>n</code>. For an integer
+     * <code>k</code>, the value <code>&lambda; = s k / n</code> is
+     * computed to <code>c</code> bits of accuracy.
+     * @param k The parameter <code>k</code>.
+     * @param s The curve parameter <code>s<sub>0</sub></code> or
+     * <code>s<sub>1</sub></code>.
+     * @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
+     * @param a The parameter <code>a</code> of the elliptic curve.
+     * @param m The bit length of the finite field
+     * <code><b>F</b><sub>m</sub></code>.
+     * @param c The number of bits of accuracy, i.e. the scale of the returned
+     * <code>SimpleBigDecimal</code>.
+     * @return The value <code>&lambda; = s k / n</code> computed to
+     * <code>c</code> bits of accuracy.
+     */
+    public static SimpleBigDecimal approximateDivisionByN(BigInteger k,
+            BigInteger s, BigInteger vm, byte a, int m, int c)
+    {
+        int _k = (m + 5)/2 + c;
+        BigInteger ns = k.shiftRight(m - _k - 2 + a);
+
+        BigInteger gs = s.multiply(ns);
+
+        BigInteger hs = gs.shiftRight(m);
+
+        BigInteger js = vm.multiply(hs);
+
+        BigInteger gsPlusJs = gs.add(js);
+        BigInteger ls = gsPlusJs.shiftRight(_k-c);
+        if (gsPlusJs.testBit(_k-c-1))
+        {
+            // round up
+            ls = ls.add(ECConstants.ONE);
+        }
+
+        return new SimpleBigDecimal(ls, c);
+    }
+
+    /**
+     * Computes the <code>&tau;</code>-adic NAF (non-adjacent form) of an
+     * element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>.
+     * @param mu The parameter <code>&mu;</code> of the elliptic curve.
+     * @param lambda The element <code>&lambda;</code> of
+     * <code><b>Z</b>[&tau;]</code>.
+     * @return The <code>&tau;</code>-adic NAF of <code>&lambda;</code>.
+     */
+    public static byte[] tauAdicNaf(byte mu, ZTauElement lambda)
+    {
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException("mu must be 1 or -1");
+        }
+        
+        BigInteger norm = norm(mu, lambda);
+
+        // Ceiling of log2 of the norm 
+        int log2Norm = norm.bitLength();
+
+        // If length(TNAF) > 30, then length(TNAF) < log2Norm + 3.52
+        int maxLength = log2Norm > 30 ? log2Norm + 4 : 34;
+
+        // The array holding the TNAF
+        byte[] u = new byte[maxLength];
+        int i = 0;
+
+        // The actual length of the TNAF
+        int length = 0;
+
+        BigInteger r0 = lambda.u;
+        BigInteger r1 = lambda.v;
+
+        while(!((r0.equals(ECConstants.ZERO)) && (r1.equals(ECConstants.ZERO))))
+        {
+            // If r0 is odd
+            if (r0.testBit(0))
+            {
+                u[i] = (byte) ECConstants.TWO.subtract((r0.subtract(r1.shiftLeft(1))).mod(ECConstants.FOUR)).intValue();
+
+                // r0 = r0 - u[i]
+                if (u[i] == 1)
+                {
+                    r0 = r0.clearBit(0);
+                }
+                else
+                {
+                    // u[i] == -1
+                    r0 = r0.add(ECConstants.ONE);
+                }
+                length = i;
+            }
+            else
+            {
+                u[i] = 0;
+            }
+
+            BigInteger t = r0;
+            BigInteger s = r0.shiftRight(1);
+            if (mu == 1)
+            {
+                r0 = r1.add(s);
+            }
+            else
+            {
+                // mu == -1
+                r0 = r1.subtract(s);
+            }
+
+            r1 = t.shiftRight(1).negate();
+            i++;
+        }
+
+        length++;
+
+        // Reduce the TNAF array to its actual length
+        byte[] tnaf = new byte[length];
+        System.arraycopy(u, 0, tnaf, 0, length);
+        return tnaf;
+    }
+
+    /**
+     * Applies the operation <code>&tau;()</code> to an
+     * <code>ECPoint.F2m</code>. 
+     * @param p The ECPoint.F2m to which <code>&tau;()</code> is applied.
+     * @return <code>&tau;(p)</code>
+     */
+    public static ECPoint.F2m tau(ECPoint.F2m p)
+    {
+        if (p.isInfinity())
+        {
+            return p;
+        }
+
+        ECFieldElement x = p.getX();
+        ECFieldElement y = p.getY();
+
+        return new ECPoint.F2m(p.getCurve(), x.square(), y.square(), p.isCompressed());
+    }
+
+    /**
+     * Returns the parameter <code>&mu;</code> of the elliptic curve.
+     * @param curve The elliptic curve from which to obtain <code>&mu;</code>.
+     * The curve must be a Koblitz curve, i.e. <code>a</code> equals
+     * <code>0</code> or <code>1</code> and <code>b</code> equals
+     * <code>1</code>. 
+     * @return <code>&mu;</code> of the elliptic curve.
+     * @throws IllegalArgumentException if the given ECCurve is not a Koblitz
+     * curve.
+     */
+    public static byte getMu(ECCurve.F2m curve)
+    {
+        BigInteger a = curve.getA().toBigInteger();
+        byte mu;
+
+        if (a.equals(ECConstants.ZERO))
+        {
+            mu = -1;
+        }
+        else if (a.equals(ECConstants.ONE))
+        {
+            mu = 1;
+        }
+        else
+        {
+            throw new IllegalArgumentException("No Koblitz curve (ABC), " +
+                    "TNAF multiplication not possible");
+        }
+        return mu;
+    }
+
+    /**
+     * Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
+     * <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
+     * <code>V<sub>k</sub></code>.
+     * @param mu The parameter <code>&mu;</code> of the elliptic curve.
+     * @param k The index of the second element of the Lucas Sequence to be
+     * returned.
+     * @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
+     * <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
+     * <code>U<sub>k</sub></code>.
+     * @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
+     * and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
+     * and <code>V<sub>k</sub></code>.
+     */
+    public static BigInteger[] getLucas(byte mu, int k, boolean doV)
+    {
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException("mu must be 1 or -1");
+        }
+
+        BigInteger u0;
+        BigInteger u1;
+        BigInteger u2;
+
+        if (doV)
+        {
+            u0 = ECConstants.TWO;
+            u1 = BigInteger.valueOf(mu);
+        }
+        else
+        {
+            u0 = ECConstants.ZERO;
+            u1 = ECConstants.ONE;
+        }
+
+        for (int i = 1; i < k; i++)
+        {
+            // u2 = mu*u1 - 2*u0;
+            BigInteger s = null;
+            if (mu == 1)
+            {
+                s = u1;
+            }
+            else
+            {
+                // mu == -1
+                s = u1.negate();
+            }
+            
+            u2 = s.subtract(u0.shiftLeft(1));
+            u0 = u1;
+            u1 = u2;
+//            System.out.println(i + ": " + u2);
+//            System.out.println();
+        }
+
+        BigInteger[] retVal = {u0, u1};
+        return retVal;
+    }
+
+    /**
+     * Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
+     * 4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
+     * <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
+     * @param mu The parameter <code>&mu;</code> of the elliptic curve.
+     * @param w The window width of the WTNAF.
+     * @return the auxiliary value <code>t<sub>w</sub></code>
+     */
+    public static BigInteger getTw(byte mu, int w)
+    {
+        if (w == 4)
+        {
+            if (mu == 1)
+            {
+                return BigInteger.valueOf(6);
+            }
+            else
+            {
+                // mu == -1
+                return BigInteger.valueOf(10);
+            }
+        }
+        else
+        {
+            // For w <> 4, the values must be computed
+            BigInteger[] us = getLucas(mu, w, false);
+            BigInteger twoToW = ECConstants.ZERO.setBit(w);
+            BigInteger u1invert = us[1].modInverse(twoToW);
+            BigInteger tw;
+            tw = ECConstants.TWO.multiply(us[0]).multiply(u1invert).mod(twoToW);
+//            System.out.println("mu = " + mu);
+//            System.out.println("tw = " + tw);
+            return tw;
+        }
+    }
+
+    /**
+     * Computes the auxiliary values <code>s<sub>0</sub></code> and
+     * <code>s<sub>1</sub></code> used for partial modular reduction. 
+     * @param curve The elliptic curve for which to compute
+     * <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
+     * @throws IllegalArgumentException if <code>curve</code> is not a
+     * Koblitz curve (Anomalous Binary Curve, ABC).
+     */
+    public static BigInteger[] getSi(ECCurve.F2m curve)
+    {
+        if (!curve.isKoblitz())
+        {
+            throw new IllegalArgumentException("si is defined for Koblitz curves only");
+        }
+
+        int m = curve.getM();
+        int a = curve.getA().toBigInteger().intValue();
+        byte mu = curve.getMu();
+        int h = curve.getH().intValue();
+        int index = m + 3 - a;
+        BigInteger[] ui = getLucas(mu, index, false);
+
+        BigInteger dividend0;
+        BigInteger dividend1;
+        if (mu == 1)
+        {
+            dividend0 = ECConstants.ONE.subtract(ui[1]);
+            dividend1 = ECConstants.ONE.subtract(ui[0]);
+        }
+        else if (mu == -1)
+        {
+            dividend0 = ECConstants.ONE.add(ui[1]);
+            dividend1 = ECConstants.ONE.add(ui[0]);
+        }
+        else
+        {
+            throw new IllegalArgumentException("mu must be 1 or -1");
+        }
+
+        BigInteger[] si = new BigInteger[2];
+
+        if (h == 2)
+        {
+            si[0] = dividend0.shiftRight(1);
+            si[1] = dividend1.shiftRight(1).negate();
+        }
+        else if (h == 4)
+        {
+            si[0] = dividend0.shiftRight(2);
+            si[1] = dividend1.shiftRight(2).negate();
+        }
+        else
+        {
+            throw new IllegalArgumentException("h (Cofactor) must be 2 or 4");
+        }
+
+        return si;
+    }
+
+    /**
+     * Partial modular reduction modulo
+     * <code>(&tau;<sup>m</sup> - 1)/(&tau; - 1)</code>.
+     * @param k The integer to be reduced.
+     * @param m The bitlength of the underlying finite field.
+     * @param a The parameter <code>a</code> of the elliptic curve.
+     * @param s The auxiliary values <code>s<sub>0</sub></code> and
+     * <code>s<sub>1</sub></code>.
+     * @param mu The parameter &mu; of the elliptic curve.
+     * @param c The precision (number of bits of accuracy) of the partial
+     * modular reduction.
+     * @return <code>&rho; := k partmod (&tau;<sup>m</sup> - 1)/(&tau; - 1)</code>
+     */
+    public static ZTauElement partModReduction(BigInteger k, int m, byte a,
+            BigInteger[] s, byte mu, byte c)
+    {
+        // d0 = s[0] + mu*s[1]; mu is either 1 or -1
+        BigInteger d0;
+        if (mu == 1)
+        {
+            d0 = s[0].add(s[1]);
+        }
+        else
+        {
+            d0 = s[0].subtract(s[1]);
+        }
+
+        BigInteger[] v = getLucas(mu, m, true);
+        BigInteger vm = v[1];
+
+        SimpleBigDecimal lambda0 = approximateDivisionByN(
+                k, s[0], vm, a, m, c);
+        
+        SimpleBigDecimal lambda1 = approximateDivisionByN(
+                k, s[1], vm, a, m, c);
+
+        ZTauElement q = round(lambda0, lambda1, mu);
+
+        // r0 = n - d0*q0 - 2*s1*q1
+        BigInteger r0 = k.subtract(d0.multiply(q.u)).subtract(
+                BigInteger.valueOf(2).multiply(s[1]).multiply(q.v));
+
+        // r1 = s1*q0 - s0*q1
+        BigInteger r1 = s[1].multiply(q.u).subtract(s[0].multiply(q.v));
+        
+        return new ZTauElement(r0, r1);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by a <code>BigInteger</code> using the reduced <code>&tau;</code>-adic
+     * NAF (RTNAF) method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param k The <code>BigInteger</code> by which to multiply <code>p</code>.
+     * @return <code>k * p</code>
+     */
+    public static ECPoint.F2m multiplyRTnaf(ECPoint.F2m p, BigInteger k)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m) p.getCurve();
+        int m = curve.getM();
+        byte a = (byte) curve.getA().toBigInteger().intValue();
+        byte mu = curve.getMu();
+        BigInteger[] s = curve.getSi();
+        ZTauElement rho = partModReduction(k, m, a, s, mu, (byte)10);
+
+        return multiplyTnaf(p, rho);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by an element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>
+     * using the <code>&tau;</code>-adic NAF (TNAF) method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param lambda The element <code>&lambda;</code> of
+     * <code><b>Z</b>[&tau;]</code>.
+     * @return <code>&lambda; * p</code>
+     */
+    public static ECPoint.F2m multiplyTnaf(ECPoint.F2m p, ZTauElement lambda)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m)p.getCurve();
+        byte mu = curve.getMu();
+        byte[] u = tauAdicNaf(mu, lambda);
+
+        ECPoint.F2m q = multiplyFromTnaf(p, u);
+
+        return q;
+    }
+
+    /**
+    * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+    * by an element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>
+    * using the <code>&tau;</code>-adic NAF (TNAF) method, given the TNAF
+    * of <code>&lambda;</code>.
+    * @param p The ECPoint.F2m to multiply.
+    * @param u The the TNAF of <code>&lambda;</code>..
+    * @return <code>&lambda; * p</code>
+    */
+    public static ECPoint.F2m multiplyFromTnaf(ECPoint.F2m p, byte[] u)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m)p.getCurve();
+        ECPoint.F2m q = (ECPoint.F2m) curve.getInfinity();
+        for (int i = u.length - 1; i >= 0; i--)
+        {
+            q = tau(q);
+            if (u[i] == 1)
+            {
+                q = (ECPoint.F2m)q.addSimple(p);
+            }
+            else if (u[i] == -1)
+            {
+                q = (ECPoint.F2m)q.subtractSimple(p);
+            }
+        }
+        return q;
+    }
+
+    /**
+     * Computes the <code>[&tau;]</code>-adic window NAF of an element
+     * <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>.
+     * @param mu The parameter &mu; of the elliptic curve.
+     * @param lambda The element <code>&lambda;</code> of
+     * <code><b>Z</b>[&tau;]</code> of which to compute the
+     * <code>[&tau;]</code>-adic NAF.
+     * @param width The window width of the resulting WNAF.
+     * @param pow2w 2<sup>width</sup>.
+     * @param tw The auxiliary value <code>t<sub>w</sub></code>.
+     * @param alpha The <code>&alpha;<sub>u</sub></code>'s for the window width.
+     * @return The <code>[&tau;]</code>-adic window NAF of
+     * <code>&lambda;</code>.
+     */
+    public static byte[] tauAdicWNaf(byte mu, ZTauElement lambda,
+            byte width, BigInteger pow2w, BigInteger tw, ZTauElement[] alpha)
+    {
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException("mu must be 1 or -1");
+        }
+
+        BigInteger norm = norm(mu, lambda);
+
+        // Ceiling of log2 of the norm 
+        int log2Norm = norm.bitLength();
+
+        // If length(TNAF) > 30, then length(TNAF) < log2Norm + 3.52
+        int maxLength = log2Norm > 30 ? log2Norm + 4 + width : 34 + width;
+
+        // The array holding the TNAF
+        byte[] u = new byte[maxLength];
+
+        // 2^(width - 1)
+        BigInteger pow2wMin1 = pow2w.shiftRight(1);
+
+        // Split lambda into two BigIntegers to simplify calculations
+        BigInteger r0 = lambda.u;
+        BigInteger r1 = lambda.v;
+        int i = 0;
+
+        // while lambda <> (0, 0)
+        while (!((r0.equals(ECConstants.ZERO))&&(r1.equals(ECConstants.ZERO))))
+        {
+            // if r0 is odd
+            if (r0.testBit(0))
+            {
+                // uUnMod = r0 + r1*tw mod 2^width
+                BigInteger uUnMod
+                    = r0.add(r1.multiply(tw)).mod(pow2w);
+                
+                byte uLocal;
+                // if uUnMod >= 2^(width - 1)
+                if (uUnMod.compareTo(pow2wMin1) >= 0)
+                {
+                    uLocal = (byte) uUnMod.subtract(pow2w).intValue();
+                }
+                else
+                {
+                    uLocal = (byte) uUnMod.intValue();
+                }
+                // uLocal is now in [-2^(width-1), 2^(width-1)-1]
+
+                u[i] = uLocal;
+                boolean s = true;
+                if (uLocal < 0)
+                {
+                    s = false;
+                    uLocal = (byte)-uLocal;
+                }
+                // uLocal is now >= 0
+
+                if (s)
+                {
+                    r0 = r0.subtract(alpha[uLocal].u);
+                    r1 = r1.subtract(alpha[uLocal].v);
+                }
+                else
+                {
+                    r0 = r0.add(alpha[uLocal].u);
+                    r1 = r1.add(alpha[uLocal].v);
+                }
+            }
+            else
+            {
+                u[i] = 0;
+            }
+
+            BigInteger t = r0;
+
+            if (mu == 1)
+            {
+                r0 = r1.add(r0.shiftRight(1));
+            }
+            else
+            {
+                // mu == -1
+                r0 = r1.subtract(r0.shiftRight(1));
+            }
+            r1 = t.shiftRight(1).negate();
+            i++;
+        }
+        return u;
+    }
+
+    /**
+     * Does the precomputation for WTNAF multiplication.
+     * @param p The <code>ECPoint</code> for which to do the precomputation.
+     * @param a The parameter <code>a</code> of the elliptic curve.
+     * @return The precomputation array for <code>p</code>. 
+     */
+    public static ECPoint.F2m[] getPreComp(ECPoint.F2m p, byte a)
+    {
+        ECPoint.F2m[] pu;
+        pu = new ECPoint.F2m[16];
+        pu[1] = p;
+        byte[][] alphaTnaf;
+        if (a == 0)
+        {
+            alphaTnaf = Tnaf.alpha0Tnaf;
+        }
+        else
+        {
+            // a == 1
+            alphaTnaf = Tnaf.alpha1Tnaf;
+        }
+
+        int precompLen = alphaTnaf.length;
+        for (int i = 3; i < precompLen; i = i + 2)
+        {
+            pu[i] = Tnaf.multiplyFromTnaf(p, alphaTnaf[i]);
+        }
+        
+        return pu;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,240 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class implementing the WNAF (Window Non-Adjacent Form) multiplication
+ * algorithm.
+ */
+class WNafMultiplier implements ECMultiplier
+{
+    /**
+     * Computes the Window NAF (non-adjacent Form) of an integer.
+     * @param width The width <code>w</code> of the Window NAF. The width is
+     * defined as the minimal number <code>w</code>, such that for any
+     * <code>w</code> consecutive digits in the resulting representation, at
+     * most one is non-zero.
+     * @param k The integer of which the Window NAF is computed.
+     * @return The Window NAF of the given width, such that the following holds:
+     * <code>k = &sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
+     * </code>, where the <code>k<sub>i</sub></code> denote the elements of the
+     * returned <code>byte[]</code>.
+     */
+    public byte[] windowNaf(byte width, BigInteger k)
+    {
+        // The window NAF is at most 1 element longer than the binary
+        // representation of the integer k. byte can be used instead of short or
+        // int unless the window width is larger than 8. For larger width use
+        // short or int. However, a width of more than 8 is not efficient for
+        // m = log2(q) smaller than 2305 Bits. Note: Values for m larger than
+        // 1000 Bits are currently not used in practice.
+        byte[] wnaf = new byte[k.bitLength() + 1];
+
+        // 2^width as short and BigInteger
+        short pow2wB = (short)(1 << width);
+        BigInteger pow2wBI = BigInteger.valueOf(pow2wB);
+
+        int i = 0;
+
+        // The actual length of the WNAF
+        int length = 0;
+
+        // while k >= 1
+        while (k.signum() > 0)
+        {
+            // if k is odd
+            if (k.testBit(0))
+            {
+                // k mod 2^width
+                BigInteger remainder = k.mod(pow2wBI);
+
+                // if remainder > 2^(width - 1) - 1
+                if (remainder.testBit(width - 1))
+                {
+                    wnaf[i] = (byte)(remainder.intValue() - pow2wB);
+                }
+                else
+                {
+                    wnaf[i] = (byte)remainder.intValue();
+                }
+                // wnaf[i] is now in [-2^(width-1), 2^(width-1)-1]
+
+                k = k.subtract(BigInteger.valueOf(wnaf[i]));
+                length = i;
+            }
+            else
+            {
+                wnaf[i] = 0;
+            }
+
+            // k = k/2
+            k = k.shiftRight(1);
+            i++;
+        }
+
+        length++;
+
+        // Reduce the WNAF array to its actual length
+        byte[] wnafShort = new byte[length];
+        System.arraycopy(wnaf, 0, wnafShort, 0, length);
+        return wnafShort;
+    }
+
+    /**
+     * Multiplies <code>this</code> by an integer <code>k</code> using the
+     * Window NAF method.
+     * @param k The integer by which <code>this</code> is multiplied.
+     * @return A new <code>ECPoint</code> which equals <code>this</code>
+     * multiplied by <code>k</code>.
+     */
+    public ECPoint multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo)
+    {
+        WNafPreCompInfo wnafPreCompInfo;
+
+        if ((preCompInfo != null) && (preCompInfo instanceof WNafPreCompInfo))
+        {
+            wnafPreCompInfo = (WNafPreCompInfo)preCompInfo;
+        }
+        else
+        {
+            // Ignore empty PreCompInfo or PreCompInfo of incorrect type
+            wnafPreCompInfo = new WNafPreCompInfo();
+        }
+
+        // floor(log2(k))
+        int m = k.bitLength();
+
+        // width of the Window NAF
+        byte width;
+
+        // Required length of precomputation array
+        int reqPreCompLen;
+
+        // Determine optimal width and corresponding length of precomputation
+        // array based on literature values
+        if (m < 13)
+        {
+            width = 2;
+            reqPreCompLen = 1;
+        }
+        else
+        {
+            if (m < 41)
+            {
+                width = 3;
+                reqPreCompLen = 2;
+            }
+            else
+            {
+                if (m < 121)
+                {
+                    width = 4;
+                    reqPreCompLen = 4;
+                }
+                else
+                {
+                    if (m < 337)
+                    {
+                        width = 5;
+                        reqPreCompLen = 8;
+                    }
+                    else
+                    {
+                        if (m < 897)
+                        {
+                            width = 6;
+                            reqPreCompLen = 16;
+                        }
+                        else
+                        {
+                            if (m < 2305)
+                            {
+                                width = 7;
+                                reqPreCompLen = 32;
+                            }
+                            else
+                            {
+                                width = 8;
+                                reqPreCompLen = 127;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        // The length of the precomputation array
+        int preCompLen = 1;
+
+        ECPoint[] preComp = wnafPreCompInfo.getPreComp();
+        ECPoint twiceP = wnafPreCompInfo.getTwiceP();
+
+        // Check if the precomputed ECPoints already exist
+        if (preComp == null)
+        {
+            // Precomputation must be performed from scratch, create an empty
+            // precomputation array of desired length
+            preComp = new ECPoint[]{ p };
+        }
+        else
+        {
+            // Take the already precomputed ECPoints to start with
+            preCompLen = preComp.length;
+        }
+
+        if (twiceP == null)
+        {
+            // Compute twice(p)
+            twiceP = p.twice();
+        }
+
+        if (preCompLen < reqPreCompLen)
+        {
+            // Precomputation array must be made bigger, copy existing preComp
+            // array into the larger new preComp array
+            ECPoint[] oldPreComp = preComp;
+            preComp = new ECPoint[reqPreCompLen];
+            System.arraycopy(oldPreComp, 0, preComp, 0, preCompLen);
+
+            for (int i = preCompLen; i < reqPreCompLen; i++)
+            {
+                // Compute the new ECPoints for the precomputation array.
+                // The values 1, 3, 5, ..., 2^(width-1)-1 times p are
+                // computed
+                preComp[i] = twiceP.add(preComp[i - 1]);
+            }            
+        }
+
+        // Compute the Window NAF of the desired width
+        byte[] wnaf = windowNaf(width, k);
+        int l = wnaf.length;
+
+        // Apply the Window NAF to p using the precomputed ECPoint values.
+        ECPoint q = p.getCurve().getInfinity();
+        for (int i = l - 1; i >= 0; i--)
+        {
+            q = q.twice();
+
+            if (wnaf[i] != 0)
+            {
+                if (wnaf[i] > 0)
+                {
+                    q = q.add(preComp[(wnaf[i] - 1)/2]);
+                }
+                else
+                {
+                    // wnaf[i] < 0
+                    q = q.subtract(preComp[(-wnaf[i] - 1)/2]);
+                }
+            }
+        }
+
+        // Set PreCompInfo in ECPoint, such that it is available for next
+        // multiplication.
+        wnafPreCompInfo.setPreComp(preComp);
+        wnafPreCompInfo.setTwiceP(twiceP);
+        p.setPreCompInfo(wnafPreCompInfo);
+        return q;
+    }
+
+}

Added: trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,44 @@
+package org.bouncycastle.math.ec;
+
+/**
+ * Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
+ * algorithm.
+ */
+class WNafPreCompInfo implements PreCompInfo
+{
+    /**
+     * Array holding the precomputed <code>ECPoint</code>s used for the Window
+     * NAF multiplication in <code>
+     * {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
+     * WNafMultiplier.multiply()}</code>.
+     */
+    private ECPoint[] preComp = null;
+
+    /**
+     * Holds an <code>ECPoint</code> representing twice(this). Used for the
+     * Window NAF multiplication in <code>
+     * {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
+     * WNafMultiplier.multiply()}</code>.
+     */
+    private ECPoint twiceP = null;
+
+    protected ECPoint[] getPreComp()
+    {
+        return preComp;
+    }
+
+    protected void setPreComp(ECPoint[] preComp)
+    {
+        this.preComp = preComp;
+    }
+
+    protected ECPoint getTwiceP()
+    {
+        return twiceP;
+    }
+
+    protected void setTwiceP(ECPoint twiceThis)
+    {
+        this.twiceP = twiceThis;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,119 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class implementing the WTNAF (Window
+ * <code>&tau;</code>-adic Non-Adjacent Form) algorithm.
+ */
+class WTauNafMultiplier implements ECMultiplier
+{
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by <code>k</code> using the reduced <code>&tau;</code>-adic NAF (RTNAF)
+     * method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param k The integer by which to multiply <code>k</code>.
+     * @return <code>p</code> multiplied by <code>k</code>.
+     */
+    public ECPoint multiply(ECPoint point, BigInteger k, PreCompInfo preCompInfo)
+    {
+        if (!(point instanceof ECPoint.F2m))
+        {
+            throw new IllegalArgumentException("Only ECPoint.F2m can be " +
+                    "used in WTauNafMultiplier");
+        }
+
+        ECPoint.F2m p = (ECPoint.F2m)point;
+
+        ECCurve.F2m curve = (ECCurve.F2m) p.getCurve();
+        int m = curve.getM();
+        byte a = curve.getA().toBigInteger().byteValue();
+        byte mu = curve.getMu();
+        BigInteger[] s = curve.getSi();
+
+        ZTauElement rho = Tnaf.partModReduction(k, m, a, s, mu, (byte)10);
+
+        return multiplyWTnaf(p, rho, preCompInfo, a, mu);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by an element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code> using
+     * the <code>&tau;</code>-adic NAF (TNAF) method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param lambda The element <code>&lambda;</code> of
+     * <code><b>Z</b>[&tau;]</code> of which to compute the
+     * <code>[&tau;]</code>-adic NAF.
+     * @return <code>p</code> multiplied by <code>&lambda;</code>.
+     */
+    private ECPoint.F2m multiplyWTnaf(ECPoint.F2m p, ZTauElement lambda,
+            PreCompInfo preCompInfo, byte a, byte mu)
+    {
+        ZTauElement[] alpha;
+        if (a == 0)
+        {
+            alpha = Tnaf.alpha0;
+        }
+        else
+        {
+            // a == 1
+            alpha = Tnaf.alpha1;
+        }
+
+        BigInteger tw = Tnaf.getTw(mu, Tnaf.WIDTH);
+
+        byte[]u = Tnaf.tauAdicWNaf(mu, lambda, Tnaf.WIDTH,
+                BigInteger.valueOf(Tnaf.POW_2_WIDTH), tw, alpha);
+
+        return multiplyFromWTnaf(p, u, preCompInfo);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by an element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>
+     * using the window <code>&tau;</code>-adic NAF (TNAF) method, given the
+     * WTNAF of <code>&lambda;</code>.
+     * @param p The ECPoint.F2m to multiply.
+     * @param u The the WTNAF of <code>&lambda;</code>..
+     * @return <code>&lambda; * p</code>
+     */
+    private static ECPoint.F2m multiplyFromWTnaf(ECPoint.F2m p, byte[] u,
+            PreCompInfo preCompInfo)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m)p.getCurve();
+        byte a = curve.getA().toBigInteger().byteValue();
+
+        ECPoint.F2m[] pu;
+        if ((preCompInfo == null) || !(preCompInfo instanceof WTauNafPreCompInfo))
+        {
+            pu = Tnaf.getPreComp(p, a);
+            p.setPreCompInfo(new WTauNafPreCompInfo(pu));
+        }
+        else
+        {
+            pu = ((WTauNafPreCompInfo)preCompInfo).getPreComp();
+        }
+
+        // q = infinity
+        ECPoint.F2m q = (ECPoint.F2m) p.getCurve().getInfinity();
+        for (int i = u.length - 1; i >= 0; i--)
+        {
+            q = Tnaf.tau(q);
+            if (u[i] != 0)
+            {
+                if (u[i] > 0)
+                {
+                    q = q.addSimple(pu[u[i]]);
+                }
+                else
+                {
+                    // u[i] < 0
+                    q = q.subtractSimple(pu[-u[i]]);
+                }
+            }
+        }
+
+        return q;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.math.ec;
+
+/**
+ * Class holding precomputation data for the WTNAF (Window
+ * <code>&tau;</code>-adic Non-Adjacent Form) algorithm.
+ */
+class WTauNafPreCompInfo implements PreCompInfo
+{
+    /**
+     * Array holding the precomputed <code>ECPoint.F2m</code>s used for the
+     * WTNAF multiplication in <code>
+     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
+     * WTauNafMultiplier.multiply()}</code>.
+     */
+    private ECPoint.F2m[] preComp = null;
+
+    /**
+     * Constructor for <code>WTauNafPreCompInfo</code>
+     * @param preComp Array holding the precomputed <code>ECPoint.F2m</code>s
+     * used for the WTNAF multiplication in <code>
+     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
+     * WTauNafMultiplier.multiply()}</code>.
+     */
+    WTauNafPreCompInfo(ECPoint.F2m[] preComp)
+    {
+        this.preComp = preComp;
+    }
+
+    /**
+     * @return the array holding the precomputed <code>ECPoint.F2m</code>s
+     * used for the WTNAF multiplication in <code>
+     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
+     * WTauNafMultiplier.multiply()}</code>.
+     */
+    protected ECPoint.F2m[] getPreComp()
+    {
+        return preComp;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ZTauElement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ZTauElement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ZTauElement.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ZTauElement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ZTauElement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class representing an element of <code><b>Z</b>[&tau;]</code>. Let
+ * <code>&lambda;</code> be an element of <code><b>Z</b>[&tau;]</code>. Then
+ * <code>&lambda;</code> is given as <code>&lambda; = u + v&tau;</code>. The
+ * components <code>u</code> and <code>v</code> may be used directly, there
+ * are no accessor methods.
+ * Immutable class.
+ */
+class ZTauElement
+{
+    /**
+     * The &quot;real&quot; part of <code>&lambda;</code>.
+     */
+    public final BigInteger u;
+
+    /**
+     * The &quot;<code>&tau;</code>-adic&quot; part of <code>&lambda;</code>.
+     */
+    public final BigInteger v;
+
+    /**
+     * Constructor for an element <code>&lambda;</code> of
+     * <code><b>Z</b>[&tau;]</code>.
+     * @param u The &quot;real&quot; part of <code>&lambda;</code>.
+     * @param v The &quot;<code>&tau;</code>-adic&quot; part of
+     * <code>&lambda;</code>.
+     */
+    public ZTauElement(BigInteger u, BigInteger v)
+    {
+        this.u = u;
+        this.v = v;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/package.html
===================================================================
--- trunk/src/org/bouncycastle/math/ec/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Math support for Elliptic Curve.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/util/Arrays.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/Arrays.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/Arrays.java
===================================================================
--- trunk/src/org/bouncycastle/util/Arrays.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/Arrays.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,244 @@
+package org.bouncycastle.util;
+
+/**
+ * General array utilities.
+ */
+public final class Arrays
+{
+    private Arrays() 
+    {
+        // static class, hide constructor
+    }
+    
+    public static boolean areEqual(
+        boolean[]  a,
+        boolean[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static boolean areEqual(
+        char[]  a,
+        char[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static boolean areEqual(
+        byte[]  a,
+        byte[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * A constant time equals comparison - does not terminate early if
+     * test will fail.
+     *
+     * @param a first array
+     * @param b second array
+     * @return true if arrays equal, false otherwise.
+     */
+    public static boolean constantTimeAreEqual(
+        byte[]  a,
+        byte[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        int nonEqual = 0;
+
+        for (int i = 0; i != a.length; i++)
+        {
+            nonEqual |= (a[i] ^ b[i]);
+        }
+
+        return nonEqual == 0;
+    }
+
+    public static boolean areEqual(
+        int[]  a,
+        int[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static void fill(
+        byte[] array,
+        byte value)
+    {
+        for (int i = 0; i < array.length; i++)
+        {
+            array[i] = value;
+        }
+    }
+    
+    public static void fill(
+        long[] array,
+        long value)
+    {
+        for (int i = 0; i < array.length; i++)
+        {
+            array[i] = value;
+        }
+    }
+
+    public static void fill(
+        short[] array, 
+        short value)
+    {
+        for (int i = 0; i < array.length; i++)
+        {
+            array[i] = value;
+        }
+    }
+
+    public static int hashCode(byte[] data)
+    {
+        if (data == null)
+        {
+            return 0;
+        }
+
+        int i = data.length;
+        int hc = i + 1;
+
+        while (--i >= 0)
+        {
+            hc *= 257;
+            hc ^= data[i];
+        }
+
+        return hc;
+    }
+
+    public static byte[] clone(byte[] data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+        byte[] copy = new byte[data.length];
+
+        System.arraycopy(data, 0, copy, 0, data.length);
+
+        return copy;
+    }
+
+    public static int[] clone(int[] data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+        int[] copy = new int[data.length];
+
+        System.arraycopy(data, 0, copy, 0, data.length);
+
+        return copy;
+    }
+}

Added: trunk/src/org/bouncycastle/util/BigIntegers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/BigIntegers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/BigIntegers.java
===================================================================
--- trunk/src/org/bouncycastle/util/BigIntegers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/BigIntegers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,78 @@
+package org.bouncycastle.util;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+/**
+ * BigInteger utilities.
+ */
+public final class BigIntegers
+{
+    private static final int MAX_ITERATIONS = 1000;
+    private static final BigInteger ZERO = BigInteger.valueOf(0);
+
+    /**
+     * Return the passed in value as an unsigned byte array.
+     * 
+     * @param value value to be converted.
+     * @return a byte array without a leading zero byte if present in the signed encoding.
+     */
+    public static byte[] asUnsignedByteArray(
+        BigInteger value)
+    {
+        byte[] bytes = value.toByteArray();
+        
+        if (bytes[0] == 0)
+        {
+            byte[] tmp = new byte[bytes.length - 1];
+            
+            System.arraycopy(bytes, 1, tmp, 0, tmp.length);
+            
+            return tmp;
+        }
+        
+        return bytes;
+    }
+
+    /**
+     * Return a random BigInteger not less than 'min' and not greater than 'max'
+     * 
+     * @param min the least value that may be generated
+     * @param max the greatest value that may be generated
+     * @param random the source of randomness
+     * @return a random BigInteger value in the range [min,max]
+     */
+    public static BigInteger createRandomInRange(
+        BigInteger      min,
+        BigInteger      max,
+        SecureRandom    random)
+    {
+        int cmp = min.compareTo(max);
+        if (cmp >= 0)
+        {
+            if (cmp > 0)
+            {
+                throw new IllegalArgumentException("'min' may not be greater than 'max'");
+            }
+
+            return min;
+        }
+
+        if (min.bitLength() > max.bitLength() / 2)
+        {
+            return createRandomInRange(ZERO, max.subtract(min), random).add(min);
+        }
+
+        for (int i = 0; i < MAX_ITERATIONS; ++i)
+        {
+            BigInteger x = new BigInteger(max.bitLength(), random);
+            if (x.compareTo(min) >= 0 && x.compareTo(max) <= 0)
+            {
+                return x;
+            }
+        }
+
+        // fall back to a faster (restricted) method
+        return new BigInteger(max.subtract(min).bitLength() - 1, random).add(min);
+    }
+}

Added: trunk/src/org/bouncycastle/util/Strings.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/Strings.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/Strings.java
===================================================================
--- trunk/src/org/bouncycastle/util/Strings.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/Strings.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,258 @@
+package org.bouncycastle.util;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.util.Vector;
+
+public final class Strings
+{
+    public static String fromUTF8ByteArray(byte[] bytes)
+    {
+        int i = 0;
+        int length = 0;
+
+        while (i < bytes.length)
+        {
+            length++;
+            if ((bytes[i] & 0xf0) == 0xf0)
+            {
+                // surrogate pair
+                length++;
+                i += 4;
+            }
+            else if ((bytes[i] & 0xe0) == 0xe0)
+            {
+                i += 3;
+            }
+            else if ((bytes[i] & 0xc0) == 0xc0)
+            {
+                i += 2;
+            }
+            else
+            {
+                i += 1;
+            }
+        }
+
+        char[] cs = new char[length];
+
+        i = 0;
+        length = 0;
+
+        while (i < bytes.length)
+        {
+            char ch;
+
+            if ((bytes[i] & 0xf0) == 0xf0)
+            {
+                int codePoint = ((bytes[i] & 0x03) << 18) | ((bytes[i+1] & 0x3F) << 12) | ((bytes[i+2] & 0x3F) << 6) | (bytes[i+3] & 0x3F);
+                int U = codePoint - 0x10000;
+                char W1 = (char)(0xD800 | (U >> 10));
+                char W2 = (char)(0xDC00 | (U & 0x3FF));
+                cs[length++] = W1;
+                ch = W2;
+                i += 4;
+            }
+            else if ((bytes[i] & 0xe0) == 0xe0)
+            {
+                ch = (char)(((bytes[i] & 0x0f) << 12)
+                        | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f));
+                i += 3;
+            }
+            else if ((bytes[i] & 0xd0) == 0xd0)
+            {
+                ch = (char)(((bytes[i] & 0x1f) << 6) | (bytes[i + 1] & 0x3f));
+                i += 2;
+            }
+            else if ((bytes[i] & 0xc0) == 0xc0)
+            {
+                ch = (char)(((bytes[i] & 0x1f) << 6) | (bytes[i + 1] & 0x3f));
+                i += 2;
+            }
+            else
+            {
+                ch = (char)(bytes[i] & 0xff);
+                i += 1;
+            }
+
+            cs[length++] = ch;
+        }
+
+        return new String(cs);
+    }
+    
+    public static byte[] toUTF8ByteArray(String string)
+    {
+        return toUTF8ByteArray(string.toCharArray());
+    }
+
+    public static byte[] toUTF8ByteArray(char[] string)
+    {
+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+        char[] c = string;
+        int i = 0;
+
+        while (i < c.length)
+        {
+            char ch = c[i];
+
+            if (ch < 0x0080)
+            {
+                bOut.write(ch);
+            }
+            else if (ch < 0x0800)
+            {
+                bOut.write(0xc0 | (ch >> 6));
+                bOut.write(0x80 | (ch & 0x3f));
+            }
+            // surrogate pair
+            else if (ch >= 0xD800 && ch <= 0xDFFF)
+            {
+                // in error - can only happen, if the Java String class has a
+                // bug.
+                if (i + 1 >= c.length)
+                {
+                    throw new IllegalStateException("invalid UTF-16 codepoint");
+                }
+                char W1 = ch;
+                ch = c[++i];
+                char W2 = ch;
+                // in error - can only happen, if the Java String class has a
+                // bug.
+                if (W1 > 0xDBFF)
+                {
+                    throw new IllegalStateException("invalid UTF-16 codepoint");
+                }
+                int codePoint = (((W1 & 0x03FF) << 10) | (W2 & 0x03FF)) + 0x10000;
+                bOut.write(0xf0 | (codePoint >> 18));
+                bOut.write(0x80 | ((codePoint >> 12) & 0x3F));
+                bOut.write(0x80 | ((codePoint >> 6) & 0x3F));
+                bOut.write(0x80 | (codePoint & 0x3F));
+            }
+            else
+            {
+                bOut.write(0xe0 | (ch >> 12));
+                bOut.write(0x80 | ((ch >> 6) & 0x3F));
+                bOut.write(0x80 | (ch & 0x3F));
+            }
+
+            i++;
+        }
+        
+        return bOut.toByteArray();
+    }
+    
+    /**
+     * A locale independent version of toUpperCase.
+     * 
+     * @param string input to be converted
+     * @return a US Ascii uppercase version
+     */
+    public static String toUpperCase(String string)
+    {
+        boolean changed = false;
+        char[] chars = string.toCharArray();
+        
+        for (int i = 0; i != chars.length; i++)
+        {
+            char ch = chars[i];
+            if ('a' <= ch && 'z' >= ch)
+            {
+                changed = true;
+                chars[i] = (char)(ch - 'a' + 'A');
+            }
+        }
+        
+        if (changed)
+        {
+            return new String(chars);
+        }
+        
+        return string;
+    }
+    
+    /**
+     * A locale independent version of toLowerCase.
+     * 
+     * @param string input to be converted
+     * @return a US ASCII lowercase version
+     */
+    public static String toLowerCase(String string)
+    {
+        boolean changed = false;
+        char[] chars = string.toCharArray();
+        
+        for (int i = 0; i != chars.length; i++)
+        {
+            char ch = chars[i];
+            if ('A' <= ch && 'Z' >= ch)
+            {
+                changed = true;
+                chars[i] = (char)(ch - 'A' + 'a');
+            }
+        }
+        
+        if (changed)
+        {
+            return new String(chars);
+        }
+        
+        return string;
+    }
+
+    public static byte[] toByteArray(char[] chars)
+    {
+        byte[] bytes = new byte[chars.length];
+
+        for (int i = 0; i != bytes.length; i++)
+        {
+            bytes[i] = (byte)chars[i];
+        }
+
+        return bytes;
+    }
+
+    public static byte[] toByteArray(String string)
+    {
+        byte[] bytes = new byte[string.length()];
+
+        for (int i = 0; i != bytes.length; i++)
+        {
+            char ch = string.charAt(i);
+
+            bytes[i] = (byte)ch;
+        }
+
+        return bytes;
+    }
+
+    public static String[] split(String input, char delimiter)
+    {
+        Vector           v = new Vector();
+        boolean moreTokens = true;
+        String subString;
+
+        while (moreTokens)
+        {
+            int tokenLocation = input.indexOf(delimiter);
+            if (tokenLocation > 0)
+            {
+                subString = input.substring(0, tokenLocation);
+                v.addElement(subString);
+                input = input.substring(tokenLocation + 1);
+            }
+            else
+            {
+                moreTokens = false;
+                v.addElement(input);
+            }
+        }
+
+        String[] res = new String[v.size()];
+
+        for (int i = 0; i != res.length; i++)
+        {
+            res[i] = (String)v.elementAt(i);
+        }
+        return res;
+    }
+}

Added: trunk/src/org/bouncycastle/util/encoders/Encoder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/encoders/Encoder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/encoders/Encoder.java
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/Encoder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/Encoder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,17 @@
+package org.bouncycastle.util.encoders;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+/**
+ * Encode and decode byte arrays (typically from binary to 7-bit ASCII 
+ * encodings).
+ */
+public interface Encoder
+{
+    int encode(byte[] data, int off, int length, OutputStream out) throws IOException;
+    
+    int decode(byte[] data, int off, int length, OutputStream out) throws IOException;
+
+    int decode(String data, OutputStream out) throws IOException;
+}

Added: trunk/src/org/bouncycastle/util/encoders/Hex.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/encoders/Hex.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/encoders/Hex.java
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/Hex.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/Hex.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,131 @@
+package org.bouncycastle.util.encoders;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class Hex
+{
+    private static final Encoder encoder = new HexEncoder();
+    
+    /**
+     * encode the input data producing a Hex encoded byte array.
+     *
+     * @return a byte array containing the Hex encoded data.
+     */
+    public static byte[] encode(
+        byte[]    data)
+    {
+        return encode(data, 0, data.length);
+    }
+    
+    /**
+     * encode the input data producing a Hex encoded byte array.
+     *
+     * @return a byte array containing the Hex encoded data.
+     */
+    public static byte[] encode(
+        byte[]    data,
+        int       off,
+        int       length)
+    {
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        
+        try
+        {
+            encoder.encode(data, off, length, bOut);
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException("exception encoding Hex string: " + e);
+        }
+        
+        return bOut.toByteArray();
+    }
+
+    /**
+     * Hex encode the byte data writing it to the given output stream.
+     *
+     * @return the number of bytes produced.
+     */
+    public static int encode(
+        byte[]         data,
+        OutputStream   out)
+        throws IOException
+    {
+        return encoder.encode(data, 0, data.length, out);
+    }
+    
+    /**
+     * Hex encode the byte data writing it to the given output stream.
+     *
+     * @return the number of bytes produced.
+     */
+    public static int encode(
+        byte[]         data,
+        int            off,
+        int            length,
+        OutputStream   out)
+        throws IOException
+    {
+        return encoder.encode(data, off, length, out);
+    }
+    
+    /**
+     * decode the Hex encoded input data. It is assumed the input data is valid.
+     *
+     * @return a byte array representing the decoded data.
+     */
+    public static byte[] decode(
+        byte[]    data)
+    {
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        
+        try
+        {
+            encoder.decode(data, 0, data.length, bOut);
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException("exception decoding Hex string: " + e);
+        }
+        
+        return bOut.toByteArray();
+    }
+    
+    /**
+     * decode the Hex encoded String data - whitespace will be ignored.
+     *
+     * @return a byte array representing the decoded data.
+     */
+    public static byte[] decode(
+        String    data)
+    {
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        
+        try
+        {
+            encoder.decode(data, bOut);
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException("exception decoding Hex string: " + e);
+        }
+        
+        return bOut.toByteArray();
+    }
+    
+    /**
+     * decode the Hex encoded String data writing it to the given output stream,
+     * whitespace characters will be ignored.
+     *
+     * @return the number of bytes produced.
+     */
+    public static int decode(
+        String          data,
+        OutputStream    out)
+        throws IOException
+    {
+        return encoder.decode(data, out);
+    }
+}

Added: trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/encoders/HexEncoder.java
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/HexEncoder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/HexEncoder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,172 @@
+package org.bouncycastle.util.encoders;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class HexEncoder
+    implements Encoder
+{
+    protected final byte[] encodingTable =
+        {
+            (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', (byte)'6', (byte)'7',
+            (byte)'8', (byte)'9', (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f'
+        };
+    
+    /*
+     * set up the decoding table.
+     */
+    protected final byte[] decodingTable = new byte[128];
+
+    protected void initialiseDecodingTable()
+    {
+        for (int i = 0; i < encodingTable.length; i++)
+        {
+            decodingTable[encodingTable[i]] = (byte)i;
+        }
+        
+        decodingTable['A'] = decodingTable['a'];
+        decodingTable['B'] = decodingTable['b'];
+        decodingTable['C'] = decodingTable['c'];
+        decodingTable['D'] = decodingTable['d'];
+        decodingTable['E'] = decodingTable['e'];
+        decodingTable['F'] = decodingTable['f'];
+    }
+    
+    public HexEncoder()
+    {
+        initialiseDecodingTable();
+    }
+    
+    /**
+     * encode the input data producing a Hex output stream.
+     *
+     * @return the number of bytes produced.
+     */
+    public int encode(
+        byte[]                data,
+        int                    off,
+        int                    length,
+        OutputStream    out) 
+        throws IOException
+    {        
+        for (int i = off; i < (off + length); i++)
+        {
+            int    v = data[i] & 0xff;
+
+            out.write(encodingTable[(v >>> 4)]);
+            out.write(encodingTable[v & 0xf]);
+        }
+
+        return length * 2;
+    }
+
+    private boolean ignore(
+        char    c)
+    {
+        return (c == '\n' || c =='\r' || c == '\t' || c == ' ');
+    }
+    
+    /**
+     * decode the Hex encoded byte data writing it to the given output stream,
+     * whitespace characters will be ignored.
+     *
+     * @return the number of bytes produced.
+     */
+    public int decode(
+        byte[]          data,
+        int             off,
+        int             length,
+        OutputStream    out)
+        throws IOException
+    {
+        byte    b1, b2;
+        int     outLen = 0;
+        
+        int     end = off + length;
+        
+        while (end > off)
+        {
+            if (!ignore((char)data[end - 1]))
+            {
+                break;
+            }
+            
+            end--;
+        }
+        
+        int i = off;
+        while (i < end)
+        {
+            while (i < end && ignore((char)data[i]))
+            {
+                i++;
+            }
+            
+            b1 = decodingTable[data[i++]];
+            
+            while (i < end && ignore((char)data[i]))
+            {
+                i++;
+            }
+            
+            b2 = decodingTable[data[i++]];
+
+            out.write((b1 << 4) | b2);
+            
+            outLen++;
+        }
+
+        return outLen;
+    }
+    
+    /**
+     * decode the Hex encoded String data writing it to the given output stream,
+     * whitespace characters will be ignored.
+     *
+     * @return the number of bytes produced.
+     */
+    public int decode(
+        String          data,
+        OutputStream    out)
+        throws IOException
+    {
+        byte    b1, b2;
+        int     length = 0;
+        
+        int     end = data.length();
+        
+        while (end > 0)
+        {
+            if (!ignore(data.charAt(end - 1)))
+            {
+                break;
+            }
+            
+            end--;
+        }
+        
+        int i = 0;
+        while (i < end)
+        {
+            while (i < end && ignore(data.charAt(i)))
+            {
+                i++;
+            }
+            
+            b1 = decodingTable[data.charAt(i++)];
+            
+            while (i < end && ignore(data.charAt(i)))
+            {
+                i++;
+            }
+            
+            b2 = decodingTable[data.charAt(i++)];
+
+            out.write((b1 << 4) | b2);
+            
+            length++;
+        }
+
+        return length;
+    }
+}

Added: trunk/src/org/bouncycastle/util/encoders/package.html
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+<html>
+<body bgcolor="#ffffff">
+Classes for producing and reading Base64 and Hex strings.
+</body>
+</html>

Added: trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/io/StreamOverflowException.java
===================================================================
--- trunk/src/org/bouncycastle/util/io/StreamOverflowException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/io/StreamOverflowException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.util.io;
+
+import ewe.io.IOException;
+
+public class StreamOverflowException
+    extends IOException
+{
+    public StreamOverflowException(String msg)
+    {
+        super(msg);
+    }
+}

Added: trunk/src/org/bouncycastle/util/io/Streams.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/io/Streams.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/io/Streams.java
===================================================================
--- trunk/src/org/bouncycastle/util/io/Streams.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/io/Streams.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,87 @@
+package org.bouncycastle.util.io;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+public final class Streams
+{
+    private static int BUFFER_SIZE = 512;
+
+    public static void drain(InputStream inStr)
+        throws IOException
+    {
+        byte[] bs = new byte[BUFFER_SIZE];
+        while (inStr.read(bs, 0, bs.length) >= 0)
+        {
+        }
+    }
+
+    public static byte[] readAll(InputStream inStr)
+        throws IOException
+    {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        pipeAll(inStr, buf);
+        return buf.toByteArray();
+    }
+
+    public static byte[] readAllLimited(InputStream inStr, int limit)
+        throws IOException
+    {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        pipeAllLimited(inStr, limit, buf);
+        return buf.toByteArray();
+    }
+
+    public static int readFully(InputStream inStr, byte[] buf)
+        throws IOException
+    {
+        return readFully(inStr, buf, 0, buf.length);
+    }
+
+    public static int readFully(InputStream inStr, byte[] buf, int off, int len)
+        throws IOException
+    {
+        int totalRead = 0;
+        while (totalRead < len)
+        {
+            int numRead = inStr.read(buf, off + totalRead, len - totalRead);
+            if (numRead < 0)
+            {
+                break;
+            }
+            totalRead += numRead;
+        }
+        return totalRead;
+    }
+
+    public static void pipeAll(InputStream inStr, OutputStream outStr)
+        throws IOException
+    {
+        byte[] bs = new byte[BUFFER_SIZE];
+        int numRead;
+        while ((numRead = inStr.read(bs, 0, bs.length)) >= 0)
+        {
+            outStr.write(bs, 0, numRead);
+        }
+    }
+
+    public static long pipeAllLimited(InputStream inStr, long limit, OutputStream outStr)
+        throws IOException
+    {
+        long total = 0;
+        byte[] bs = new byte[BUFFER_SIZE];
+        int numRead;
+        while ((numRead = inStr.read(bs, 0, bs.length)) >= 0)
+        {
+            total += numRead;
+            if (total > limit)
+            {
+                throw new StreamOverflowException("Data Overflow");
+            }
+            outStr.write(bs, 0, numRead);
+        }
+        return total;
+    }
+}



From pfeffer at mail.berlios.de  Thu Aug 25 02:59:39 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Aug 2011 02:59:39 AM +0200
Subject: [Cachewolf-svn] r3059 - in trunk/src/CacheWolf: . utils
Message-ID: <20110825005940.1997D481462@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-25 02:59:39 +0200 (Thu, 25 Aug 2011)
New Revision: 3059

Added:
   trunk/src/CacheWolf/utils/CWPartialInputStream.java
Modified:
   trunk/src/CacheWolf/HttpConnection.java
   trunk/src/CacheWolf/UrlFetcher.java
Log:
Integration of SSL/TLS Library into HttpConnection.java and UrlFetcher.java - just call the methods with "https://" instead of "http://" and SSL/TLS will be negotiated

Modified: trunk/src/CacheWolf/HttpConnection.java
===================================================================
--- trunk/src/CacheWolf/HttpConnection.java	2011-08-25 00:55:34 UTC (rev 3058)
+++ trunk/src/CacheWolf/HttpConnection.java	2011-08-25 00:59:39 UTC (rev 3059)
@@ -1,4 +1,4 @@
-    /*
+/*
     GNU General Public License
     CacheWolf is a software for PocketPC, Win and Linux that
     enables paperless caching.
@@ -22,7 +22,7 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+ */
 package CacheWolf;
 
 import ewe.data.Property;
@@ -31,11 +31,10 @@
 import ewe.io.FileBase;
 import ewe.io.IOException;
 import ewe.io.IOHandle;
-import ewe.io.IOTransfer;
 import ewe.io.InputStream;
 import ewe.io.MemoryFile;
 import ewe.io.MemoryStream;
-import ewe.io.PartialInputStream;
+import ewe.io.OutputStream;
 import ewe.io.Stream;
 import ewe.io.StreamAdapter;
 import ewe.io.StreamUtils;
@@ -51,6 +50,12 @@
 import ewe.util.Vector;
 import ewe.util.mString;
 
+import org.bouncycastle.crypto.tls.AlwaysValidVerifyer;
+import org.bouncycastle.crypto.tls.TlsProtocolHandler;
+
+import org.bouncycastle.crypto.tls.TlsSocket;
+import CacheWolf.utils.CWPartialInputStream;
+
 /**
 Use this class to create an HttpConnection with a Web Server and to read
 in the data for the connection.<p>
@@ -72,522 +77,561 @@
 <li>Call readInData() with the connected Socket to read in the raw data bytes of the requested
 document or call readInText() to read in and convert the document to text.
 </ol>
-**/
+ **/
 //##################################################################
 public class HttpConnection {
-//##################################################################
-/**
-* The host to connect to.
-**/
-private String host;
-/**
-* The port to connect to.
-**/
-private int port;
-/**
-* The document to fetch/submit.
-**/
-private String document;
-/**
-* This is the command to be sent to the server. By default it is "GET". If you call
-* setPostData() and command is "GET" then the command will be replaced by "POST".
-**/
-private String command = "GET";
-/**
-* This is the version sent to the server. By default it is "HTTP/1.1". You could
-* change it to something else if necessary.
-**/
-private String requestVersion = "HTTP/1.1";
-/**
-* These are the properties that will be sent to the WebServer. These are sent after the
-* initial GET/POST line. This is initially null, so you will have to create a new PropertyList
-* for it, or use one of the setRequestorProperty() or addRequestorProperty() methods.
-**/
-private ewe.data.PropertyList requestorProperties;
-/**
-* This is the list of properties for the server and document. It is only valid after a connection has
-* been made since it is sent by the server to the requestor. One properties that will always be in
-* this list will be "response" (the first line sent by the server in response to the request).
-* All other properties will be as specified by the server, and <b>the property names will be
-* converted to all lowercase letters</b>.
-**/
-public ewe.data.PropertyList documentProperties;
-/**
-* This is the response code from the server. It is only valid after a connection has
-* been made.
-**/
-public int responseCode;
-/**
-* If the document you supplied is already URL encoded, set this to true.
-**/
-public boolean documentIsEncoded;
-/**
-* Set this to true for keep alive mode requests.
-**/
-private boolean keepAliveMode;
-/**
-* This is the length of the document <b>read in</b>, valid after a connection call. If it is -1, then the
-* web server has not provided the length of the document.
-**/
-private int contentLength = -1;
-/**
-* This is the codec used when sending data to the server. 
-**/
-private TextCodec textCodec;
+//	##################################################################
+	/**
+	 * The host to connect to.
+	 **/
+	private String host;
+	/**
+	 * The port to connect to.
+	 **/
+	private int port;
 
-private Stream bytesToPost;
-private Object originalPostData;
+	private boolean useSslTls;
+	/**
+	 * The document to fetch/submit.
+	 **/
+	private String document;
+	/**
+	 * This is the command to be sent to the server. By default it is "GET". If you call
+	 * setPostData() and command is "GET" then the command will be replaced by "POST".
+	 **/
+	private String command = "GET";
+	/**
+	 * This is the version sent to the server. By default it is "HTTP/1.1". You could
+	 * change it to something else if necessary.
+	 **/
+	private String requestVersion = "HTTP/1.1";
+	/**
+	 * These are the properties that will be sent to the WebServer. These are sent after the
+	 * initial GET/POST line. This is initially null, so you will have to create a new PropertyList
+	 * for it, or use one of the setRequestorProperty() or addRequestorProperty() methods.
+	 **/
+	private ewe.data.PropertyList requestorProperties;
+	/**
+	 * This is the list of properties for the server and document. It is only valid after a connection has
+	 * been made since it is sent by the server to the requestor. One properties that will always be in
+	 * this list will be "response" (the first line sent by the server in response to the request).
+	 * All other properties will be as specified by the server, and <b>the property names will be
+	 * converted to all lowercase letters</b>.
+	 **/
+	public ewe.data.PropertyList documentProperties;
+	/**
+	 * This is the response code from the server. It is only valid after a connection has
+	 * been made.
+	 **/
+	public int responseCode;
+	/**
+	 * If the document you supplied is already URL encoded, set this to true.
+	 **/
+	public boolean documentIsEncoded;
+	/**
+	 * Set this to true for keep alive mode requests.
+	 **/
+	private boolean keepAliveMode;
+	/**
+	 * This is the length of the document <b>read in</b>, valid after a connection call. If it is -1, then the
+	 * web server has not provided the length of the document.
+	 **/
+	private int contentLength = -1;
+	/**
+	 * This is the codec used when sending data to the server.
+	 **/
+	private TextCodec textCodec;
 
-/**
- * Set these when the class is instantiated the first time.
- * afterwards you don't need to set proxy parameters anymore
- */
+	private Stream bytesToPost;
+	private Object originalPostData;
 
-private static String proxy = Global.getPref().myproxy;
-private static int proxyPort = Common.parseInt(Global.getPref().myproxyport);
-private static boolean useProxy = Global.getPref().proxyActive;
+	/**
+	 * Set these when the class is instantiated the first time.
+	 * afterwards you don't need to set proxy parameters anymore
+	 */
 
-//FIXME: why is this called immediately from preferences screen? shouldn't we read it from preferences instead?
-public static void setProxy(String proxyi, int proxyporti, boolean useproxyi) {
-	proxy = proxyi;
-	proxyPort = proxyporti;
-	useProxy = useproxyi;
-}
+	private static String proxy = Global.getPref().myproxy;
+	private static int proxyPort = Common.parseInt(Global.getPref().myproxyport);
+	private static boolean useProxy = Global.getPref().proxyActive;
 
-/**
- * This returns true if post data has been set for this connection.
- * FIXME: unreferenced!
- */
-//public boolean hasPostData()
-//{
+//	FIXME: why is this called immediately from preferences screen? shouldn't we read it from preferences instead?
+	public static void setProxy(String proxyi, int proxyporti, boolean useproxyi) {
+		proxy = proxyi;
+		proxyPort = proxyporti;
+		useProxy = useproxyi;
+	}
+
+	/**
+	 * This returns true if post data has been set for this connection.
+	 * FIXME: unreferenced!
+	 */
+//	public boolean hasPostData()
+//	{
 //	return bytesToPost != null;
-//}
-/**
- * Get a new HttpConnection whose parameters are copied from this HttpConnection
- * but which directs its request to a different host/document as directed by
- * a redirect response from an initial request.<p>
- * Note that if this is a POST request and if the post-data source is an InputStream
- * or Stream, then you will need to call setPostData() again to set up the post data
- * for the new connection. Otherwise, the post data will be copied to this device.
- * Call hasPostData() to determine if the post data was copied across successfully.
- * 
- * @param redirectTo the URL that the server instructed the client to redirect to.
- * @return a new HttpConnection with parameters copied from this one.
- */
-public HttpConnection getRedirectedConnection(String redirectTo)
-{
-	HttpConnection c = new HttpConnection(redirectTo);
-	c.keepAliveMode = keepAliveMode;
-	c.contentLength = contentLength;
-	c.getRequestorProperties().set(getRequestorProperties());
-	if (originalPostData != null) c.setPostData(originalPostData);
-	c.documentIsEncoded = documentIsEncoded;
-	c.command = command;
-	c.textCodec = textCodec == null ? null : (TextCodec)textCodec.getCopy();
-	c.requestVersion = requestVersion;
-	return c;
-}
-/**
+//	}
+	/**
+	 * Get a new HttpConnection whose parameters are copied from this HttpConnection
+	 * but which directs its request to a different host/document as directed by
+	 * a redirect response from an initial request.<p>
+	 * Note that if this is a POST request and if the post-data source is an InputStream
+	 * or Stream, then you will need to call setPostData() again to set up the post data
+	 * for the new connection. Otherwise, the post data will be copied to this device.
+	 * Call hasPostData() to determine if the post data was copied across successfully.
+	 *
+	 * @param redirectTo the URL that the server instructed the client to redirect to.
+	 * @return a new HttpConnection with parameters copied from this one.
+	 */
+	public HttpConnection getRedirectedConnection(String redirectTo)
+	{
+		HttpConnection c = new HttpConnection(redirectTo);
+		c.keepAliveMode = keepAliveMode;
+		c.contentLength = contentLength;
+		c.getRequestorProperties().set(getRequestorProperties());
+		if (originalPostData != null) c.setPostData(originalPostData);
+		c.documentIsEncoded = documentIsEncoded;
+		c.command = command;
+		c.textCodec = textCodec == null ? null : (TextCodec)textCodec.getCopy();
+		c.requestVersion = requestVersion;
+		return c;
+	}
+	/**
 Returns the requestor properties. These are the property commands sent to the server when the
 connection is made. You can add directly to this OR you can call setRequestorProperty() or
 addRequestorProperty();
- */
-//===================================================================
-private PropertyList getRequestorProperties()
-//===================================================================
-{
-	if (requestorProperties == null) requestorProperties = new PropertyList();
-	return requestorProperties;
-}
-/**
- * Set the data to post out as either a Stream, InputStream,byte[],ByteArray or String.
- * If the data is a Stream or InputStream then you must also call setPostDataLength() 
- * which in turn sets the "Content-Length" property of the requestor properties - otherwise
- * if "Content-Length" is not already set it will be set to the length of the byte[] or ByteArray.
- * @param data the data to post either as a Stream, InputStream, byte[] or ByteArray
- */
-//===================================================================
-public void setPostData(Object data)
-//===================================================================
-{
-	if (data instanceof Stream) bytesToPost = (Stream)data;
-	else if (data instanceof ByteArray) {
-		originalPostData = data;
-		bytesToPost = new MemoryFile((ByteArray)data);
-		getRequestorProperties().defaultTo("Content-Length",Convert.toString(((ByteArray)data).length));
+	 */
+//	===================================================================
+	private PropertyList getRequestorProperties()
+//	===================================================================
+	{
+		if (requestorProperties == null) requestorProperties = new PropertyList();
+		return requestorProperties;
 	}
-	else if (data instanceof byte[]) {
-		originalPostData = data;
-		bytesToPost = new MemoryFile(new ByteArray((byte[])data));
-		getRequestorProperties().defaultTo("Content-Length",Convert.toString(((byte[])data).length));
-	}else if (data instanceof String){
-		String s = (String)data;
-		TextCodec td = textCodec;
-		if (td == null) td = new AsciiCodec();
-		try{
-			ByteArray got = td.encodeText(Vm.getStringChars(s),0,s.length(),true,null);
-			setPostData(got.toBytes());
-		}catch(IOException e){
-			// Global.getPref().log("Ignored exception", e, true);
+	/**
+	 * Set the data to post out as either a Stream, InputStream,byte[],ByteArray or String.
+	 * If the data is a Stream or InputStream then you must also call setPostDataLength()
+	 * which in turn sets the "Content-Length" property of the requestor properties - otherwise
+	 * if "Content-Length" is not already set it will be set to the length of the byte[] or ByteArray.
+	 * @param data the data to post either as a Stream, InputStream, byte[] or ByteArray
+	 */
+//	===================================================================
+	public void setPostData(Object data)
+//	===================================================================
+	{
+		if (data instanceof Stream) bytesToPost = (Stream)data;
+		else if (data instanceof ByteArray) {
+			originalPostData = data;
+			bytesToPost = new MemoryFile((ByteArray)data);
+			getRequestorProperties().defaultTo("Content-Length",Convert.toString(((ByteArray)data).length));
 		}
+		else if (data instanceof byte[]) {
+			originalPostData = data;
+			bytesToPost = new MemoryFile(new ByteArray((byte[])data));
+			getRequestorProperties().defaultTo("Content-Length",Convert.toString(((byte[])data).length));
+		}else if (data instanceof String){
+			String s = (String)data;
+			TextCodec td = textCodec;
+			if (td == null) td = new AsciiCodec();
+			try{
+				ByteArray got = td.encodeText(Vm.getStringChars(s),0,s.length(),true,null);
+				setPostData(got.toBytes());
+			}catch(IOException e){
+				// Global.getPref().log("Ignored exception", e, true);
+			}
+		}
+		else if (data instanceof InputStream) bytesToPost = new StreamAdapter((InputStream)data);
+		if (bytesToPost != null && command.equalsIgnoreCase("get"))
+			command = "POST";
 	}
-	else if (data instanceof InputStream) bytesToPost = new StreamAdapter((InputStream)data);
-	if (bytesToPost != null && command.equalsIgnoreCase("get"))
-		command = "POST";
-}
-/**
- * This sets the "Content-Length" requestor property to be the specified length.
- * @param length the number of bytes to be posted.
- * FIXME: not referenced
- */
-//===================================================================
-//public void setPostDataLength(int length)
-////===================================================================
-//{
+	/**
+	 * This sets the "Content-Length" requestor property to be the specified length.
+	 * @param length the number of bytes to be posted.
+	 * FIXME: not referenced
+	 */
+//	===================================================================
+//	public void setPostDataLength(int length)
+////	===================================================================
+//	{
 //	getRequestorProperties().set("Content-Length",Convert.toString(length));
-//}
-/**
- * Set an exclusive requestor property. These are sent to the web server after the initial request line.
- * @param name The name of the property.
- * @param property The value of the property.
- */
-//===================================================================
-public void setRequestorProperty(String name, String property)
-//===================================================================
-{
-	getRequestorProperties().set(name,property);
-}
-public void setRequestorProperty(PropertyList pl)
-//===================================================================
-{
-	getRequestorProperties().set(pl);
-}
-/**
- * Add a non-exclusive requestor property. These are sent to the web server after the initial request line.
- * @param name The name of the property.
- * @param property The value of the property.
- * FIXME: not referenced
- */
-////===================================================================
-//public void addRequestorProperty(String name, String property)
-////===================================================================
-//{
+//	}
+	/**
+	 * Set an exclusive requestor property. These are sent to the web server after the initial request line.
+	 * @param name The name of the property.
+	 * @param property The value of the property.
+	 */
+//	===================================================================
+	public void setRequestorProperty(String name, String property)
+//	===================================================================
+	{
+		getRequestorProperties().set(name,property);
+	}
+	public void setRequestorProperty(PropertyList pl)
+//	===================================================================
+	{
+		getRequestorProperties().set(pl);
+	}
+	/**
+	 * Add a non-exclusive requestor property. These are sent to the web server after the initial request line.
+	 * @param name The name of the property.
+	 * @param property The value of the property.
+	 * FIXME: not referenced
+	 */
+////	===================================================================
+//	public void addRequestorProperty(String name, String property)
+////	===================================================================
+//	{
 //	getRequestorProperties().add(name,property);
-//}
-/**
- * Set the default value of a requestor property. If the value is already set
- * this will have no effect. Otherwise the value will be set to defaultValue.
- * @param name the name of the property.
- * @param defaultValue the value to default to.
- * FIXME: not referenced
- */
-//public void defaultRequestorProperty(String name, String defaultValue)
-//{
+//	}
+	/**
+	 * Set the default value of a requestor property. If the value is already set
+	 * this will have no effect. Otherwise the value will be set to defaultValue.
+	 * @param name the name of the property.
+	 * @param defaultValue the value to default to.
+	 * FIXME: not referenced
+	 */
+//	public void defaultRequestorProperty(String name, String defaultValue)
+//	{
 //	getRequestorProperties().defaultTo(name,defaultValue);
-//}
-protected Socket openSocket;
-protected Socket connectedSocket;
+//	}
+	protected TlsSocket openSocket;
+	protected TlsSocket connectedSocket;
 
-/**
-* If a connection has already been made to the server, then you can call
-* this method and the HttpConnection protocol will be done over this Socket.
-* @param sock The already connected socket.
-* FIXME: not referenced
-*/
-////===================================================================
-//public void setAlreadyOpenSocket(Socket sock)
-////===================================================================
-//{	
+	/**
+	 * If a connection has already been made to the server, then you can call
+	 * this method and the HttpConnection protocol will be done over this Socket.
+	 * @param sock The already connected socket.
+	 * FIXME: not referenced
+	 */
+////	===================================================================
+//	public void setAlreadyOpenSocket(Socket sock)
+////	===================================================================
+//	{
 //	openSocket = sock;
-//}
+//	}
 
-/**
- * Create a new HttpConnection to the specified host and port to fetch the specified document.
- * @param host The host to connect to.
- * @param port The port to connect on.
- * @param document the document to get.
- * FIXME: not referenced
- */
-////===================================================================
-//public HttpConnection(String host, int port, String document)
-////===================================================================
-//{
+	/**
+	 * Create a new HttpConnection to the specified host and port to fetch the specified document.
+	 * @param host The host to connect to.
+	 * @param port The port to connect on.
+	 * @param document the document to get.
+	 * FIXME: not referenced
+	 */
+////	===================================================================
+//	public HttpConnection(String host, int port, String document)
+////	===================================================================
+//	{
 //	this.host = host;
 //	this.port = port;
 //	this.document = document;
-//}
-/**
- * Create an HttpConnection with an http:// URL.
- * @param url The full url, starting with http://
- */
-//===================================================================
-public HttpConnection(String url)
-//===================================================================
-{
-	setUrl(url);
-}
-public void setUrl(String url)
-{
-	if (useProxy) { 
-		host = proxy;
-		port = proxyPort;
-		document = url;
-	} else {
-		url = FileBase.fixupPath(url);
-		port = 80;
-		String uu = url.toLowerCase();
-		if (uu.startsWith("http://")){
-			uu = url.replace('\\','/');
-			host = uu.substring(7);
-			int first = host.indexOf('/');
-			if (first == -1) document = "/";
-			else {
-				document = host.substring(first);
-				host = host.substring(0,first);
+//	}
+	/**
+	 * Create an HttpConnection with an http:// URL.
+	 * @param url The full url, starting with http://
+	 */
+//	===================================================================
+	public HttpConnection(String url)
+//	===================================================================
+	{
+		setUrl(url);
+	}
+	public void setUrl(String url)
+	{
+		if (useProxy) {
+			host = proxy;
+			port = proxyPort;
+			document = url;
+		} else {
+			url = FileBase.fixupPath(url);
+			port = 80;
+			String uu = url.toLowerCase();
+			if (uu.startsWith("https://")) {
+				useSslTls = true;
+				port = 443;
+				uu = "http://" + uu.substring(8);
+			} else useSslTls = false;
+			if (uu.startsWith("http://")){
+				uu = uu.replace('\\','/');
+				host = uu.substring(7);
+				int first = host.indexOf('/');
+				if (first == -1) document = "/";
+				else {
+					document = host.substring(first);
+					host = host.substring(0,first);
+				}
+				int colon = host.indexOf(':');
+				if (colon != -1){
+					port = ewe.sys.Convert.toInt(host.substring(colon+1));
+					host = host.substring(0,colon);
+				}
 			}
-			int colon = host.indexOf(':');
-			if (colon != -1){
-				port = ewe.sys.Convert.toInt(host.substring(colon+1));
-				host = host.substring(0,colon);
-			}
 		}
+		getRequestorProperties().clear();
+		command = "GET";
 	}
-	getRequestorProperties().clear();
-	command = "GET";
-}
 
-//FIXME: never referenced
-////===================================================================
-//public HttpConnection(URL url)
-////===================================================================
-//{
+//	FIXME: never referenced
+////	===================================================================
+//	public HttpConnection(URL url)
+////	===================================================================
+//	{
 //	this(url.toString());
 //	documentIsEncoded = true;
-//}
-//private static char [] space = {' '}, percentSpace = {'%','2','0'};
+//	}
+//	private static char [] space = {' '}, percentSpace = {'%','2','0'};
 
-// FIXME: never referenced
-////===================================================================
-//public String toURLString()
-////===================================================================
-//{
+//	FIXME: never referenced
+////	===================================================================
+//	public String toURLString()
+////	===================================================================
+//	{
 //	return "http://"+host+":"+port+document;
-//}
-//===================================================================
-private String getEncodedDocument()
-//===================================================================
-{
-	if (documentIsEncoded) return document;
-	else return URL.encodeURL(document,false);
-}
-//===================================================================
-private Object waitOnIO(Handle h,String errorMessage) throws IOException
-//===================================================================
-{
-	try{
-		h.waitOn(Handle.Success);
-		return h.returnValue;
-	}catch(Exception e){
-		if (h.errorObject instanceof IOException) throw (IOException)h.errorObject;
-		else throw new IOException(errorMessage);
+//	}
+//	===================================================================
+	private String getEncodedDocument()
+//	===================================================================
+	{
+		if (documentIsEncoded) return document;
+		else return URL.encodeURL(document,false);
 	}
-}
-private static final int SocketConnected = 0x1;
-// never referenced
-//private static final int DataReady = 0x2;
+//	===================================================================
+	private Object waitOnIO(Handle h,String errorMessage) throws IOException
+//	===================================================================
+	{
+		try{
+			h.waitOn(Handle.Success);
+			return h.returnValue;
+		}catch(Exception e){
+			if (h.errorObject instanceof IOException) throw (IOException)h.errorObject;
+			else throw new IOException(errorMessage);
+		}
+	}
+	private static final int SocketConnected = 0x1;
+//	never referenced
+//	private static final int DataReady = 0x2;
 
-private static Vector lines;
-private static SubString data;
+	private static Vector lines;
+	private static SubString data;
 
-//===================================================================
-private int makeRequest(Socket sock,TextCodec td) throws IOException
-//===================================================================
-{
-	responseCode = -1;
-	if (td == null) td = textCodec;
-	if (td == null) td = new AsciiCodec();
-	PropertyList pl = new PropertyList();
-	if (requestorProperties != null) pl.set(requestorProperties);
-	pl.defaultTo("Connection","close");
-	pl.defaultTo("Host",host);
-	StringBuffer sb = new StringBuffer();
-	sb.append(command+" "+getEncodedDocument()+" "+requestVersion+"\r\n");
-	for (int i = 0; i<pl.size(); i++){
-		Property p = (Property)pl.get(i);
-		if (p.value != null) sb.append(p.name+": "+p.value+"\r\n");
-	}
-	sb.append("\r\n");
-	String req = sb.toString();
-	char [] rc = ewe.sys.Vm.getStringChars(req);
-	ByteArray ba = ((TextCodec)td.getCopy()).encodeText(rc,0,rc.length,true,null);
-	sock.write(ba.data,0,ba.length);
-	sock.flush();
-	//
-	if (bytesToPost != null){
-		IOTransfer iot = new IOTransfer();
-		iot.transfer(bytesToPost,sock);
-		sock.flush();
-		bytesToPost.close();
-		/*
+//	===================================================================
+	private int makeRequest(InputStream is, OutputStream os,TextCodec td) throws IOException
+//	===================================================================
+	{
+		responseCode = -1;
+		if (td == null) td = textCodec;
+		if (td == null) td = new AsciiCodec();
+		PropertyList pl = new PropertyList();
+		if (requestorProperties != null) pl.set(requestorProperties);
+		pl.defaultTo("Connection","close");
+		pl.defaultTo("Host",host);
+		StringBuffer sb = new StringBuffer();
+		sb.append(command+" "+getEncodedDocument()+" "+requestVersion+"\r\n");
+		for (int i = 0; i<pl.size(); i++){
+			Property p = (Property)pl.get(i);
+			if (p.value != null) sb.append(p.name+": "+p.value+"\r\n");
+		}
+		sb.append("\r\n");
+		String req = sb.toString();
+		char [] rc = ewe.sys.Vm.getStringChars(req);
+		ByteArray ba = ((TextCodec)td.getCopy()).encodeText(rc,0,rc.length,true,null);
+		os.write(ba.data,0,ba.length);
+		os.flush();
+		//
+		if (bytesToPost != null){
+//			IOTransfer iot = new IOTransfer();
+//			iot.transfer(bytesToPost,sock);
+			transfer(bytesToPost,os);
+			os.flush();
+			bytesToPost.close();
+			/*
 		// For debugging - output eol and a blank line.
 		byte[] ret = new byte[]{(byte)'\r',(byte)'\n'};
 		sock.write(ret);
 		sock.write(ret);
 		sock.flush();
-		*/
-	}
-	//
-	int lastReceived = -1;
-	//
-	ba.clear();
-	while(true){
-		int got = sock.read();
-		if (got == -1) throw new IOException("Unexpected end of stream.");
-		if (got == 10){
-			if (lastReceived == 10) break; //Got all the data now.
-		}else if (got == 13) continue; //Ignore CR.
-		ba.append((byte)got);
-		lastReceived = got;
-	}
-	//
-	CharArray all = ((TextCodec)td.getCopy()).decodeText(ba.data,0,ba.length,true,null);
-	if (data == null){
-		data = new SubString();
-		lines = new Vector();
-	}
-	data.set(all.data,0,all.length);
-	int got = data.split('\n',lines);
-	documentProperties = new ewe.data.PropertyList();
-	if (got == 0) throw new IOException("No response");
+			 */
+		}
+		//
+		int lastReceived = -1;
+		//
+		ba.clear();
+		while(true){
+			int got = is.read();
+			if (got == -1) throw new IOException("Unexpected end of stream.");
+			if (got == 10){
+				if (lastReceived == 10) break; //Got all the data now.
+			}else if (got == 13) continue; //Ignore CR.
+			ba.append((byte)got);
+			lastReceived = got;
+		}
+		//
+		CharArray all = ((TextCodec)td.getCopy()).decodeText(ba.data,0,ba.length,true,null);
+		if (data == null){
+			data = new SubString();
+			lines = new Vector();
+		}
+		data.set(all.data,0,all.length);
+		int got = data.split('\n',lines);
+		documentProperties = new ewe.data.PropertyList();
+		if (got == 0) throw new IOException("No response");
 
 
-	String response = lines.get(0).toString();
-	documentProperties.set("response",response);
-	{
-		int idx = response.indexOf(' ');
-		if (idx != -1){
-			int id2 = response.indexOf(' ',idx+1);
-			if (id2 != -1){
-				responseCode = ewe.sys.Convert.toInt(response.substring(idx+1,id2));
+		String response = lines.get(0).toString();
+		documentProperties.set("response",response);
+		{
+			int idx = response.indexOf(' ');
+			if (idx != -1){
+				int id2 = response.indexOf(' ',idx+1);
+				if (id2 != -1){
+					responseCode = ewe.sys.Convert.toInt(response.substring(idx+1,id2));
+				}
 			}
 		}
+		for (int i = 1; i<got; i++){
+			String s = lines.get(i).toString();
+			int idx = s.indexOf(':');
+			if (idx == -1) continue;
+			String name = s.substring(0,idx).trim().toLowerCase();
+			String value = s.substring(idx+1).trim();
+			documentProperties.add(name,value);
+		}
+		contentLength = documentProperties.getInt("content-length",-1);
+		return responseCode;
 	}
-	for (int i = 1; i<got; i++){
-		String s = lines.get(i).toString();
-		int idx = s.indexOf(':');
-		if (idx == -1) continue;
-		String name = s.substring(0,idx).trim().toLowerCase();
-		String value = s.substring(idx+1).trim();
-		documentProperties.add(name,value);
-	}
-	contentLength = documentProperties.getInt("content-length",-1);
-	return responseCode;
-}
 
-private static final String [] encodings = {"transfer-coding","transfer-encoding"};
-private byte [] buffer;
+	private static final String [] encodings = {"transfer-coding","transfer-encoding"};
+	private byte [] buffer;
 
+	/**
+	 * Copy from the "in" stream to the "out" stream. The streams are NOT closed.
+	 **/
+//	===================================================================
+	public void transfer(Stream in, OutputStream out) throws IOException
+//	===================================================================
+	{
+		int bufferSize = 1;
+		byte [] buff = new byte[bufferSize];
+		while(true){
+			/**
+			 * This readBytes method will block the current Coroutine until at
+			 * least one byte is read. It will let other Coroutines run if it
+			 * has to wait.
+			 **/
+			int read = in.read(buff,0,buff.length);
+			if (read == -1) break;
+			if (read == 0) continue;
+			/**
+			 * This writeBytes method will block the current Coroutine until
+			 * all bytes are written. It will let other Coroutines run if it
+			 * has to wait.
+			 **/
+			out.write(buff,0,read);
+			// copied += read;
+			/**
+			 * Allow other threads to have some time to execute.
+			 **/
+		}
+		out.flush();
+	}
 
 
-/**
- * Call this after a successful connection. If the server requested a redirect (a 3xx code) then
- * this will return an HttpConnection to the new location which you can connect to again. You must
- * setup any post data or requestor properties again before re-connecting.
- * Alternatively you could also call getRedirectTo() and then if that returns a non-null
- * String, you can call getRedirectedConnection() to get copies.
- * If there is no redirection required or possible the method will return this same HttpConnection.
- * 
- * FIXME: never referenced
- */
-////===================================================================
-//public HttpConnection redirectTo()
-////===================================================================
-//{
+	/**
+	 * Call this after a successful connection. If the server requested a redirect (a 3xx code) then
+	 * this will return an HttpConnection to the new location which you can connect to again. You must
+	 * setup any post data or requestor properties again before re-connecting.
+	 * Alternatively you could also call getRedirectTo() and then if that returns a non-null
+	 * String, you can call getRedirectedConnection() to get copies.
+	 * If there is no redirection required or possible the method will return this same HttpConnection.
+	 *
+	 * FIXME: never referenced
+	 */
+////	===================================================================
+//	public HttpConnection redirectTo()
+////	===================================================================
+//	{
 //	if (responseCode < 300 || responseCode > 399) return this;
 //	String newURL = documentProperties.getString("location",null);
 //	if (newURL == null) return this;
 //	return new HttpConnection(newURL);
-//}					
+//	}
 
-/**
- * Call this after a success connection. If it returns a non-null String then
- * you need to redirect the connection to the new location. If this returns non-null
- * you can call getRedirectedConnection() to get a new HttpConnection that you can
- * use to redirect the connection without having to setup the connection parameters
- * again.
- * @return null if no redirection is needed, otherwise the location directed to.
- */
-public String getRedirectTo()
-{
-	if (responseCode < 300 || responseCode > 399) return null;
-	return documentProperties.getString("location",null);
-}
-//===================================================================
-private int readInChunkedHeader(Socket connection,ByteArray buff,CharArray chBuff) throws IOException
-//===================================================================
-{
- 	if (buffer == null) buffer = new byte[10240];
-	if (buff == null) buff = new ByteArray();
-	buff.clear();
-	while(true){
-		int got = connection.read();
-		if (got == -1) throw new IOException();
-		if (got == '\n') break;
-		buff.append((byte)got);
+	/**
+	 * Call this after a success connection. If it returns a non-null String then
+	 * you need to redirect the connection to the new location. If this returns non-null
+	 * you can call getRedirectedConnection() to get a new HttpConnection that you can
+	 * use to redirect the connection without having to setup the connection parameters
+	 * again.
+	 * @return null if no redirection is needed, otherwise the location directed to.
+	 */
+	public String getRedirectTo()
+	{
+		if (responseCode < 300 || responseCode > 399) return null;
+		return documentProperties.getString("location",null);
 	}
-	chBuff = new AsciiCodec().decodeText(buff.data,0,buff.length,true,chBuff);
-	String s = new String(chBuff.data,0,chBuff.length);
-	String length = mString.leftOf(s,';').trim().toUpperCase();
-	int clen = 0;
-	for (int i = 0; i<length.length(); i++){
-		char c = length.charAt(i);
-		clen *= 16;
-		clen += c <= '9' ? c-'0' : c-'A'+10;
+//	===================================================================
+	private int readInChunkedHeader(InputStream connection,ByteArray buff,CharArray chBuff) throws IOException
+//	===================================================================
+	{
+		if (buffer == null) buffer = new byte[10240];
+		if (buff == null) buff = new ByteArray();
+		buff.clear();
+		while(true){
+			int got = connection.read();
+			if (got == -1) throw new IOException();
+			if (got == '\n') break;
+			buff.append((byte)got);
+		}
+		chBuff = new AsciiCodec().decodeText(buff.data,0,buff.length,true,chBuff);
+		String s = new String(chBuff.data,0,chBuff.length);
+		String length = mString.leftOf(s,';').trim().toUpperCase();
+		int clen = 0;
+		for (int i = 0; i<length.length(); i++){
+			char c = length.charAt(i);
+			clen *= 16;
+			clen += c <= '9' ? c-'0' : c-'A'+10;
+		}
+		return clen;
 	}
-	return clen;
-}
-/**
- * Read in all the data from the Socket.
- * @param connection The socket returned by a connect() call.
- * @return A Handle with which you can monitor the connection. When the Handle
+	/**
+	 * Read in all the data from the Socket.
+	 * @param connection The Inputstream returned by a connect() call.
+	 * @return A Handle with which you can monitor the connection. When the Handle
 	reports Success, then the returnValue of the Handle will be a ewe.util.ByteArray
 	object that holds the data read in.
- */
-//===================================================================
-private Handle readInData(final Socket connection) 
-//===================================================================
-{
-	int length = documentProperties.getInt("content-length",-1);
-	if (length == 0)
-		return new Handle(Handle.Succeeded,new ByteArray());
-	getInputStream();
-	return StreamUtils.readAllBytes(getInputStream(),null,length,0);
-}
-/**
- * Read in all the data from the Socket.
- * @return A Handle with which you can monitor the connection. When the Handle
+	 */
+//	===================================================================
+	private Handle readInData(final InputStream connection)
+//	===================================================================
+	{
+		int length = documentProperties.getInt("content-length",-1);
+		if (length == 0)
+			return new Handle(Handle.Succeeded,new ByteArray());
+		getInputStream();
+		return StreamUtils.readAllBytes(getInputStream(),null,length,0);
+	}
+	/**
+	 * Read in all the data from the Socket.
+	 * @return A Handle with which you can monitor the connection. When the Handle
 	reports Success, then the returnValue of the Handle will be a ewe.util.ByteArray
 	object that holds the data read in.
-	
+
 	FIXME: never referenced
- */
-//===================================================================
-public Handle readInData() 
-//===================================================================
-{
-	return readInData(connectedSocket);
-}
-/**
-* Get an InputStream to read in the data. This is a very important method as it is used by
-* the readInData() method.
-**/
-//===================================================================
-private InputStream getInputStream()
-//===================================================================
-{
-	int length = documentProperties.getInt("content-length",-1);
-	if ("chunked".equals(documentProperties.getValue(encodings,null)))
-		return new MemoryStream(true){
+	 */
+//	===================================================================
+	public Handle readInData()
+//	===================================================================
+	{
+		return readInData(connectedSocket.inputStream);
+	}
+	/**
+	 * Get an InputStream to read in the data. This is a very important method as it is used by
+	 * the readInData() method.
+	 **/
+//	===================================================================
+	private InputStream getInputStream()
+//	===================================================================
+	{
+		int length = documentProperties.getInt("content-length",-1);
+		if ("chunked".equals(documentProperties.getValue(encodings,null)))
+			return new MemoryStream(true){
 			private byte[] buff = new byte[10240];
 			private int leftInBlock = 0;
 			private ByteArray ba = new ByteArray();
@@ -597,18 +641,18 @@
 			//-------------------------------------------------------------------
 			{
 				if (leftInBlock <= 0){
-					leftInBlock = readInChunkedHeader(connectedSocket,ba,ca);
+					leftInBlock = readInChunkedHeader(connectedSocket.inputStream,ba,ca);
 					if (leftInBlock <= 0) return false;
 				}
 				int toRead = leftInBlock;
 				if (toRead > buff.length) toRead = buff.length;
-				int got = connectedSocket.read(buff,0,toRead);
+				int got = connectedSocket.inputStream.read(buff,0,toRead);
 				if (got == -1) throw new IOException();
 				leftInBlock -= got;
 				putInBuffer(buff,0,got);
 				if (leftInBlock == 0){
 					while(true){
-						got = connectedSocket.read();
+						got = connectedSocket.inputStream.read();
 						if (got == -1) throw new IOException();
 						if (got == '\n') break;
 					}
@@ -617,36 +661,39 @@
 			}
 		}.toInputStream();
 		//throw new IOException("Cannot get input stream from this!");
-	else return 
-		new PartialInputStream(connectedSocket,length).toInputStream();
-}
-/**
- * Read in the document body from the Socket. This method blocks until the complete
- * data is read in. readInData() is a non-blocking version.
- * @param connection The socket returned by a connect() call.
- * @return A ByteArray containing the read in data.
- */
+		else return
+		new CWPartialInputStream(connectedSocket.inputStream,length).toInputStream();
+	}
+	/**
+	 * Read in the document body from the Socket. This method blocks until the complete
+	 * data is read in. readInData() is a non-blocking version.
+	 * @param connection The socket returned by a connect() call.
+	 * @return A ByteArray containing the read in data.
+	 */
+	/*
 //===================================================================
 public ByteArray readData(Socket connection) throws IOException
 //===================================================================
 {
 	return (ByteArray)waitOnIO(readInData(connection),"Error reading data.");
 }
-public ByteArray readData() throws IOException
-//===================================================================
-{
-	return (ByteArray)waitOnIO(readInData(openSocket),"Error reading data.");
-}
-/**
- * Read in all the data from the Socket, converting it to text using the specified
- * codec. 
- * @param connection The socket returned by a connect() call.
- * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
- * this is null then a simple Ascii codec will be used.
- * @return A Handle with which you can monitor the connection. When the Handle
+	 */
+	public ByteArray readData() throws IOException
+//	===================================================================
+	{
+		return (ByteArray)waitOnIO(readInData(openSocket.inputStream),"Error reading data.");
+	}
+	/**
+	 * Read in all the data from the Socket, converting it to text using the specified
+	 * codec.
+	 * @param connection The socket returned by a connect() call.
+	 * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
+	 * this is null then a simple Ascii codec will be used.
+	 * @return A Handle with which you can monitor the connection. When the Handle
 	reports Success, then the returnValue of the Handle will be a ewe.util.CharArray
 	object that holds the text read in.
- */
+	 */
+	/*
 //===================================================================
 private Handle readInText(final Socket connection,TextCodec documentTextDecoder)
 //===================================================================
@@ -668,109 +715,115 @@
 		}
 	}.startTask();
 }
-/**
- * Read in the document body from the Socket. This method blocks until the complete
- * data is read in. readInText() is a non-blocking version.
- * @param connection The socket returned by a connect() call.
- * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
- * this is null then a simple Ascii codec will be used.
- * @return A CharArray containing the text that was read in.
- */
+	 */
+	/**
+	 * Read in the document body from the Socket. This method blocks until the complete
+	 * data is read in. readInText() is a non-blocking version.
+	 * @param connection The socket returned by a connect() call.
+	 * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
+	 * this is null then a simple Ascii codec will be used.
+	 * @return A CharArray containing the text that was read in.
+	 */
+	/*
 //===================================================================
 public CharArray readText(Socket connection,TextCodec documentTextDecoder) throws IOException
 //===================================================================
 {
 	return (CharArray)waitOnIO(readInText(connection,documentTextDecoder),"Error reading data.");
 }
-/**
- * Connect asynchronously. This makes the connection, sends the request and requestor properties
- * reads in the reply and server properties and then returns the connected Socket ready for
- * for reading in the actual data.
- * @return A Handle used to monitor the connection. When the Handle reports a state of
- * Success, then the returnValue of the IOHandle will hold the connected socket.
- */
-//===================================================================
-public Handle connectAsync()
-//===================================================================
-{
-	return connectAsync(new AsciiCodec());
-}
-/**
- * Connect asynchronously. This makes the connection, sends the request and requestor properties
- * reads in the reply and server properties and then returns the connected Socket ready for
- * for reading in the actual data.
- * @param serverTextDecoder The text decoder to convert the server and requestor properties data into text.
- * @return A Handle used to monitor the connection. When the Handle reports a state of
- * Success, then the returnValue of the Handle will hold the connected socket.
- */
-//===================================================================
-private Handle connectAsync(final TextCodec serverTextDecoder)
-//===================================================================
-{
-	return new ewe.sys.TaskObject(){
-		protected void doRun(){
-			while(true){
-			//
-			// Create a Socket using an IOHandle.
-			//
-			Handle sh;
-			Socket sock;
-			if (openSocket != null) {
-				sh = new Handle(Handle.Succeeded,openSocket);
-				sock = openSocket;
-			}
-			else {
-				sh = new IOHandle();
-				sock = new Socket(host,port,(IOHandle)sh);
-				// openSocket = sock;
-			}
-			// Handle sh = (openSocket != null) ? new Handle(Handle.Succeeded,openSocket) : new IOHandle();
-			// Socket sock = (openSocket != null) ? openSocket : new Socket(host,port,(IOHandle)sh);
-			try{
-				//
-				// Now wait until connected.
-				//
-				if (!waitOnSuccess(sh,true)) return;
-				//
-				// Report that the socket connection was made.
-				// Now have to decode the data.
-				//
-				handle.setFlags(SocketConnected,0);
-				//
-				makeRequest(sock,serverTextDecoder);
-				handle.returnValue = connectedSocket = sock;
-				handle.setFlags(Handle.Success,0);
-				return;
-			}catch(Exception e){
-				if (openSocket == null){
-					handle.failed(e);
-					return;
-				}else{
-					openSocket = null;
-					continue;
-				}
-			}
-		}}
-	}.startTask();
-}
-/**
- * This makes the connection, blocking the current thread.
- * @return A Socket that you can read the data from. The document properties will be in
- * the document properties list.
- * @exception IOException if there was an error connecting or getting the data.
- */
-public Socket connect() throws IOException {
-	openSocket = (Socket)waitOnIO(connectAsync(),"Could not connect.");
-	return openSocket;
-}
-public void disconnect() {
-	if (openSocket.isOpen()) {
-		openSocket.close(); // releases the handles of the system
+	 */
+	/**
+	 * Connect asynchronously. This makes the connection, sends the request and requestor properties
+	 * reads in the reply and server properties and then returns the connected Socket ready for
+	 * for reading in the actual data.
+	 * @return A Handle used to monitor the connection. When the Handle reports a state of
+	 * Success, then the returnValue of the IOHandle will hold the connected socket.
+	 */
+//	===================================================================
+	public Handle connectAsync()
+//	===================================================================
+	{
+		return connectAsync(new AsciiCodec());
 	}
+	/**
+	 * Connect asynchronously. This makes the connection, sends the request and requestor properties
+	 * reads in the reply and server properties and then returns the connected Socket ready for
+	 * for reading in the actual data.
+	 * @param serverTextDecoder The text decoder to convert the server and requestor properties data into text.
+	 * @return A Handle used to monitor the connection. When the Handle reports a state of
+	 * Success, then the returnValue of the Handle will hold the connected socket.
+	 */
+//	===================================================================
+	private Handle connectAsync(final TextCodec serverTextDecoder)
+//	===================================================================
+	{
+		return new ewe.sys.TaskObject(){
+			protected void doRun(){
+				while(true){
+					//
+					// Create a Socket using an IOHandle.
+					//
+					Handle sh;
+					Socket sock;
+					if (openSocket != null) {
+						sh = new Handle(Handle.Succeeded,openSocket);
+						sock = openSocket.socket;
+					}
+					else {
+						sh = new IOHandle();
+						sock = new Socket(host,port,(IOHandle)sh);
+						// openSocket = sock;
+					}
+					// Handle sh = (openSocket != null) ? new Handle(Handle.Succeeded,openSocket) : new IOHandle();
+					// Socket sock = (openSocket != null) ? openSocket : new Socket(host,port,(IOHandle)sh);
+					try{
+						//
+						// Now wait until connected.
+						//
+						if (!waitOnSuccess(sh,true)) return;
+						//
+						// Report that the socket connection was made.
+						// Now have to decode the data.
+						//
+						handle.setFlags(SocketConnected,0);
+
+						TlsSocket tls = new TlsSocket(
+								(useSslTls ?  new AlwaysValidVerifyer() : null),
+								sock);
+						makeRequest(tls.inputStream, tls.outputStream, serverTextDecoder);
+						handle.returnValue = connectedSocket = tls;
+						handle.setFlags(Handle.Success,0);
+						return;
+					}catch(Exception e){
+						if (openSocket == null){
+							handle.failed(e);
+							return;
+						}else{
+							openSocket = null;
+							continue;
+						}
+					}
+				}}
+		}.startTask();
+	}
+	/**
+	 * This makes the connection, blocking the current thread.
+	 * @return A Socket that you can read the data from. The document properties will be in
+	 * the document properties list.
+	 * @exception IOException if there was an error connecting or getting the data.
+	 */
+	public TlsSocket connect() throws IOException {
+		openSocket = (TlsSocket)waitOnIO(connectAsync(),"Could not connect.");
+		return openSocket;
+	}
+	public void disconnect() {
+		if (openSocket.socket.isOpen()) {
+			openSocket.close(); // releases the handles of the system
+		}
+	}
+	public boolean isOpen() {
+		return openSocket.socket.isOpen();
+	}
 }
-public boolean isOpen() {
-	return openSocket.isOpen();
-}
-}
 
 

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-08-25 00:55:34 UTC (rev 3058)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-08-25 00:59:39 UTC (rev 3059)
@@ -109,9 +109,13 @@
 	}
 
 	public static void fetchDataFile(String address, String target) throws IOException {
-		FileOutputStream outp = new FileOutputStream(new File(target));
+		FileOutputStream outp = null;
+		try {
+		outp = new FileOutputStream(new File(target));
 		outp.write(fetchByteArray(address).toBytes());
-		outp.close();
+		} finally {
+		if (outp != null) outp.close();
+		}
 	}
 
 	/**
@@ -133,7 +137,7 @@
 				i = i - 1;
 			}
 			realUrl = urltmp;
-			if (!urltmp.startsWith("http")) {
+			if (!( urltmp.startsWith("http") || urltmp.startsWith("https") )) {
 				url = FileBase.fixupPath(url);
 				String uu = url.toLowerCase();
 				String host;
@@ -145,7 +149,7 @@
 				}
 				if (!urltmp.startsWith("/"))
 					host = host + "/";
-				urltmp = "http://" + host + urltmp;
+				urltmp = "http://" + host + urltmp; // TODO https?
 			}
 			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
@@ -226,7 +230,7 @@
 	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation<br>
 	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the
 	 * server expects, what encoding you must use.
-	 * 
+	 *
 	 * @param cc
 	 * @return
 	 * @throws IOException
@@ -246,7 +250,7 @@
 	/**
 	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all
 	 * chars to be < 127. This method is mainly copied from there
-	 * 
+	 *
 	 * @param url
 	 *            The unencoded URL.
 	 * @param spaceToPlus

Added: trunk/src/CacheWolf/utils/CWPartialInputStream.java
===================================================================
--- trunk/src/CacheWolf/utils/CWPartialInputStream.java	                        (rev 0)
+++ trunk/src/CacheWolf/utils/CWPartialInputStream.java	2011-08-25 00:59:39 UTC (rev 3059)
@@ -0,0 +1,148 @@
+/*********************************************************************************
+ *  Ewe Virtual Machine - Version 1.14, January 24, 2002                         *
+ *  Copyright (C) 1999-2002 Michael L Brereton <michael_brereton at ewesoft.com>    *
+ *  All Rights Reserved                                                          *
+ *                                                                               *
+ *  This library and virtual machine is free software; you can redistribute      *
+ *  it and/or modify it under the terms of the Amended GNU Lesser General        *
+ *  Public License distributed with this software.                               *
+ *                                                                               *
+ *  Under this license, linking this library or part thereof with other files to *
+ *  produce an executable does not in itself require the executable to be        *
+ *  covered by the GNU Lesser General Public License.                            *
+ *                                                                               *
+ *  This library and virtual machine is distributed in the hope that it will     *
+ *  be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of    *
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                         *
+ *                                                                               *
+ *  You should have received a copy of the License along with this software;     *
+ *  if not, please download it at: www.ewesoft.com/LGPL.txt                      *
+ *                                                                               *
+ *********************************************************************************/
+package CacheWolf.utils;
+// import ewe.sys.*;
+// import ewe.util.ByteArray;
+import ewe.io.InputStream;
+import ewe.io.StreamAdapter;
+import ewe.io.BufferedStream;
+import ewe.io.RandomAccessStream;
+import ewe.io.IOException;
+
+/**
+* This class is used to get a "sub-stream" of data from another Stream. The
+* partial stream can limit the amount of data which can be read from the original
+* Stream. Note the following:
+* <nl>
+* <li>Calling close() on a PartialInputStream does not close the original stream, unless closeUnderlying is true.
+* <li>Setting a limit of -1 will not impose any limit on the number of bytes which
+* can be read.
+* <li>Input begins at the current point in the source input stream.
+*</nl>
+
+**/
+//##################################################################
+public class CWPartialInputStream extends StreamAdapter{
+//##################################################################
+//
+// Do not move the next 2 variables.
+long limit;
+long filepos;
+/**
+* If this is true, then a call to close() will close the underlying stream
+* as well.
+**/
+public boolean closeUnderlying = false;
+/**
+* Creates a new PartialInputStream with the specified limit. If the limit
+* is -1, then there will be no limit imposed
+**/
+//===================================================================
+public CWPartialInputStream(InputStream input,int limit)
+//===================================================================
+{
+	super(input);
+	this.limit = limit;
+	filepos = -1;
+}
+//===================================================================
+
+/**
+* Creates a new PartialInputStream with the specified limit. If the limit
+* is -1, then there will be no limit imposed
+**/
+//===================================================================
+public CWPartialInputStream(InputStream input,long limit)
+//===================================================================
+{
+	super(input);
+	this.limit = limit;
+	filepos = -1;
+}
+//===================================================================
+
+//===================================================================
+public boolean pushback(byte [] bytes,int start,int count)
+//===================================================================
+{
+	if (stream instanceof BufferedStream)
+		return ((BufferedStream)stream).pushback(bytes,start,count);
+	return super.pushback(bytes,start,count);
+}
+//===================================================================
+public int nonBlockingWrite(byte [] buff,int start,int length) {return READWRITE_ERROR;}
+//===================================================================
+
+//===================================================================
+public int nonBlockingRead(byte [] buff,int offset,int count)
+//===================================================================
+{
+	if (limit == 0) return READWRITE_CLOSED;
+	if (limit < -1) return READWRITE_ERROR;
+	if (limit != -1)
+		if ((long)count > limit) count = (int)limit;
+	if (filepos >= 0){
+		try{
+			((RandomAccessStream)stream).seek(filepos);
+		}catch(IOException e){
+			error = e.getMessage();
+			return READWRITE_ERROR;
+		}
+	}
+	int got = super.nonBlockingRead(buff,offset,count);
+	if (got == 0) return 0;
+	if (got == READWRITE_CLOSED){
+		limit = 0;
+		return READWRITE_CLOSED;
+	}
+	if (got > 0) {
+		if (limit > 0){
+			limit -= got;
+			if (limit < 0) limit = 0;
+		}
+		if (filepos >= 0) filepos += got;
+		return got;
+	}
+	// An error occured.
+	limit = -2;
+	return READWRITE_ERROR;
+}
+/**
+* This will not close the underlying stream unless closeUnderlying is true.
+**/
+//===================================================================
+public boolean closeStream() throws ewe.io.IOException
+//===================================================================
+{
+	closed = (closeUnderlying) ?  stream.close() : true;
+	return closed;
+}
+//===================================================================
+public boolean isOpen()
+//===================================================================
+{
+	return !closed;
+}
+//##################################################################
+}
+//##################################################################
+



From pfeffer at mail.berlios.de  Thu Aug 25 03:00:23 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Aug 2011 03:00:23 AM +0200
Subject: [Cachewolf-svn] r3060 - trunk
Message-ID: <20110825010023.98659481462@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-25 03:00:23 +0200 (Thu, 25 Aug 2011)
New Revision: 3060

Modified:
   trunk/build.xml
Log:
update ant build.xml for automatic builds

Modified: trunk/build.xml
===================================================================
--- trunk/build.xml	2011-08-25 00:59:39 UTC (rev 3059)
+++ trunk/build.xml	2011-08-25 01:00:23 UTC (rev 3060)
@@ -334,7 +334,7 @@
 		<javac source="1.3" target="1.1" encoding="windows-1252"
 			classpath="./lib/CompileEwe.zip:./lib/" destdir="${classes.dir}"
 			deprecation="off" nowarn="on" srcdir="src"
-			includes="CacheWolf/*.java,CacheWolf/*/*.java" />
+			includes="CacheWolf/*.java,CacheWolf/*/*.java,org/*.java,org/*/*.java" />
 
 	</target>
 



From mik77 at mail.berlios.de  Thu Aug 25 09:22:55 2011
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Thu, 25 Aug 2011 09:22:55 AM +0200
Subject: [Cachewolf-svn] r3061 - in trunk/src/org/bouncycastle: asn1
	asn1/nist asn1/oiw asn1/pkcs asn1/sec asn1/teletrust
	asn1/x500 asn1/x500/style asn1/x509 asn1/x9 crypto
	crypto/agreement crypto/digests crypto/encodings
	crypto/engines crypto/generators crypto/io crypto/macs
	crypto/modes crypto/params crypto/prng crypto/signers
	crypto/tls crypto/util math/ec util util/encoders util/io
Message-ID: <20110825072255.6AFBB48134E@sheep.berlios.de>

Author: mik77
Date: 2011-08-25 09:22:54 +0200 (Thu, 25 Aug 2011)
New Revision: 3061

Removed:
   trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
   trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
   trunk/src/org/bouncycastle/asn1/ASN1Choice.class
   trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
   trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
   trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
   trunk/src/org/bouncycastle/asn1/ASN1Exception.class
   trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
   trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
   trunk/src/org/bouncycastle/asn1/ASN1Integer.class
   trunk/src/org/bouncycastle/asn1/ASN1Null.class
   trunk/src/org/bouncycastle/asn1/ASN1Object.class
   trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
   trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
   trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
   trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
   trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
   trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
   trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
   trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
   trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
   trunk/src/org/bouncycastle/asn1/ASN1Set.class
   trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
   trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
   trunk/src/org/bouncycastle/asn1/ASN1String.class
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
   trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
   trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
   trunk/src/org/bouncycastle/asn1/BERFactory.class
   trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
   trunk/src/org/bouncycastle/asn1/BEROutputStream.class
   trunk/src/org/bouncycastle/asn1/BERSequence.class
   trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
   trunk/src/org/bouncycastle/asn1/BERSet.class
   trunk/src/org/bouncycastle/asn1/BERSetParser.class
   trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
   trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
   trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
   trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
   trunk/src/org/bouncycastle/asn1/DERBMPString.class
   trunk/src/org/bouncycastle/asn1/DERBitString.class
   trunk/src/org/bouncycastle/asn1/DERBoolean.class
   trunk/src/org/bouncycastle/asn1/DEREncodable.class
   trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
   trunk/src/org/bouncycastle/asn1/DEREnumerated.class
   trunk/src/org/bouncycastle/asn1/DERExternal.class
   trunk/src/org/bouncycastle/asn1/DERExternalParser.class
   trunk/src/org/bouncycastle/asn1/DERFactory.class
   trunk/src/org/bouncycastle/asn1/DERGeneralString.class
   trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
   trunk/src/org/bouncycastle/asn1/DERIA5String.class
   trunk/src/org/bouncycastle/asn1/DERInteger.class
   trunk/src/org/bouncycastle/asn1/DERNull.class
   trunk/src/org/bouncycastle/asn1/DERNumericString.class
   trunk/src/org/bouncycastle/asn1/DERObject.class
   trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
   trunk/src/org/bouncycastle/asn1/DEROctetString.class
   trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
   trunk/src/org/bouncycastle/asn1/DEROutputStream.class
   trunk/src/org/bouncycastle/asn1/DERPrintableString.class
   trunk/src/org/bouncycastle/asn1/DERSequence.class
   trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
   trunk/src/org/bouncycastle/asn1/DERSet.class
   trunk/src/org/bouncycastle/asn1/DERSetParser.class
   trunk/src/org/bouncycastle/asn1/DERString.class
   trunk/src/org/bouncycastle/asn1/DERT61String.class
   trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
   trunk/src/org/bouncycastle/asn1/DERTags.class
   trunk/src/org/bouncycastle/asn1/DERUTCTime.class
   trunk/src/org/bouncycastle/asn1/DERUTF8String.class
   trunk/src/org/bouncycastle/asn1/DERUniversalString.class
   trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
   trunk/src/org/bouncycastle/asn1/DERVisibleString.class
   trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
   trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
   trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
   trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
   trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
   trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
   trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
   trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
   trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
   trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
   trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
   trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
   trunk/src/org/bouncycastle/asn1/x500/RDN.class
   trunk/src/org/bouncycastle/asn1/x500/X500Name.class
   trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
   trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
   trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
   trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
   trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
   trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
   trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
   trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
   trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
   trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
   trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
   trunk/src/org/bouncycastle/asn1/x509/Time.class
   trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
   trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
   trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
   trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
   trunk/src/org/bouncycastle/asn1/x509/X509Name.class
   trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
   trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
   trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
   trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
   trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
   trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
   trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
   trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
   trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
   trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
   trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
   trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/BasicAgreement.class
   trunk/src/org/bouncycastle/crypto/BlockCipher.class
   trunk/src/org/bouncycastle/crypto/CipherParameters.class
   trunk/src/org/bouncycastle/crypto/CryptoException.class
   trunk/src/org/bouncycastle/crypto/DSA.class
   trunk/src/org/bouncycastle/crypto/DataLengthException.class
   trunk/src/org/bouncycastle/crypto/Digest.class
   trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
   trunk/src/org/bouncycastle/crypto/ExtensionType.class
   trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
   trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/Mac.class
   trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
   trunk/src/org/bouncycastle/crypto/Signer.class
   trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
   trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
   trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
   trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
   trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
   trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
   trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
   trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
   trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
   trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
   trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
   trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
   trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
   trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
   trunk/src/org/bouncycastle/crypto/macs/HMac.class
   trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
   trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
   trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
   trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
   trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
   trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
   trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
   trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
   trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
   trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
   trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
   trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
   trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
   trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
   trunk/src/org/bouncycastle/crypto/tls/Certificate.class
   trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
   trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
   trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
   trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
   trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
   trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
   trunk/src/org/bouncycastle/crypto/tls/ContentType.class
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
   trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
   trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
   trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
   trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
   trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
   trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
   trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
   trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
   trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
   trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
   trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
   trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
   trunk/src/org/bouncycastle/crypto/util/Pack.class
   trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
   trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
   trunk/src/org/bouncycastle/math/ec/ECConstants.class
   trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECCurve.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
   trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
   trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECPoint.class
   trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/IntArray.class
   trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
   trunk/src/org/bouncycastle/math/ec/Tnaf.class
   trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/ZTauElement.class
   trunk/src/org/bouncycastle/util/Arrays.class
   trunk/src/org/bouncycastle/util/BigIntegers.class
   trunk/src/org/bouncycastle/util/Strings.class
   trunk/src/org/bouncycastle/util/encoders/Encoder.class
   trunk/src/org/bouncycastle/util/encoders/Hex.class
   trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
   trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
   trunk/src/org/bouncycastle/util/io/Streams.class
Log:
removed class files on request of Pfeffer

Deleted: trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Choice.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Exception.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Integer.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Null.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Object.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1Set.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1String.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERFactory.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BEROutputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERSequence.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERSet.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERSetParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERBMPString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERBitString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERBoolean.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DEREncodable.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DEREnumerated.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERExternal.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERExternalParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERFactory.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERGeneralString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERIA5String.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERInteger.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERNull.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERNumericString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERObject.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DEROctetString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DEROutputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERPrintableString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERSequence.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERSet.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERSetParser.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERT61String.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERTags.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERUTCTime.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERUTF8String.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERUniversalString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DERVisibleString.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/RDN.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/X500Name.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/Time.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509Name.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/BasicAgreement.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/BlockCipher.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/CipherParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/CryptoException.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/DSA.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/DataLengthException.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/Digest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/ExtensionType.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/Mac.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/Signer.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/macs/HMac.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DHParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/Certificate.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/ContentType.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/util/Pack.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECConstants.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECCurve.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ECPoint.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/IntArray.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/Tnaf.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/math/ec/ZTauElement.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/Arrays.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/BigIntegers.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/Strings.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/encoders/Encoder.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/encoders/Hex.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
===================================================================
(Binary files differ)

Deleted: trunk/src/org/bouncycastle/util/io/Streams.class
===================================================================
(Binary files differ)



From araber95 at mail.berlios.de  Thu Aug 25 02:10:27 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 25 Aug 2011 02:10:27 PM +0200
Subject: [Cachewolf-svn] r3062 - trunk
Message-ID: <20110825121027.AD3F24803AD@sheep.berlios.de>

Author: araber95
Date: 2011-08-25 14:10:27 +0200 (Thu, 25 Aug 2011)
New Revision: 3062

Modified:
   trunk/compile.bat
   trunk/compile.sh
Log:
files from mcbernie  : http://www.geoclub.de/viewtopic.php?f=40&t=57822

Modified: trunk/compile.bat
===================================================================
--- trunk/compile.bat	2011-08-25 07:22:54 UTC (rev 3061)
+++ trunk/compile.bat	2011-08-25 12:10:27 UTC (rev 3062)
@@ -1,4 +1,4 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
-javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/CacheWolf/navi/touchControls/*.java ./src/CacheWolf/exp/*.java ./src/CacheWolf/utils/*.java ./src/CacheWolf/model/*.java ./src/CacheWolf/view/*.java  ./src/CacheWolf/view/ewe/*.java  ./src/CacheWolf/view/pda/*.java
+javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./bin/ -deprecation ./src/org/bouncycastle/asn1/*.java ./src/org/bouncycastle/asn1/nist/*.java ./src/org/bouncycastle/asn1/oiw/*.java ./src/org/bouncycastle/asn1/pkcs/*.java ./src/org/bouncycastle/asn1/sec/*.java ./src/org/bouncycastle/asn1/teletrust/*.java ./src/org/bouncycastle/asn1/x9/*.java ./src/org/bouncycastle/asn1/x500/*.java ./src/org/bouncycastle/asn1/x500/style/*.java ./src/org/bouncycastle/asn1/x509/*.java ./src/org/bouncycastle/crypto/*.java ./src/org/bouncycastle/crypto/agreement/*.java ./src/org/bouncycastle/crypto/digests/*.java ./src/org/bouncycastle/crypto/encodings/*.java ./src/org/bouncycastle/crypto/engines/*.java ./src/org/bouncycastle/crypto/generators/*.java ./src/org/bouncycastle/crypto/io/*.java ./src/org/bouncycastle/crypto/macs/*.java ./src/org/bouncycastle/crypto/modes/*.java ./src/org/bouncycastle/crypto/params/*.java ./src/org/bouncycastle/crypto/modes/*.java ./src/org/bouncycast
 le/crypto/prng/*.java ./src/org/bouncycastle/crypto/signers/*.java ./src/org/bouncycastle/crypto/tls/*.java ./src/org/bouncycastle/crypto/util/*.java ./src/org/bouncycastle/math/ec/*.java ./src/org/bouncycastle/util/*.java ./src/org/bouncycastle/util/encoders/*.java ./src/org/bouncycastle/util/io/*.java ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/CacheWolf/navi/touchControls/*.java ./src/CacheWolf/exp/*.java ./src/CacheWolf/utils/*.java ./src/CacheWolf/model/*.java ./src/CacheWolf/view/*.java  ./src/CacheWolf/view/ewe/*.java  ./src/CacheWolf/view/pda/*.java
 javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./lib/ -deprecation ./lib/net/ax86/*.java ./lib/org/json/*.java
 pause

Modified: trunk/compile.sh
===================================================================
--- trunk/compile.sh	2011-08-25 07:22:54 UTC (rev 3061)
+++ trunk/compile.sh	2011-08-25 12:10:27 UTC (rev 3062)
@@ -15,6 +15,11 @@
 
 do_compile \
    -d ./bin/ \
+   ./src/org/bouncycastle/*/*.java \
+   ./src/org/bouncycastle/*/*/*.java \
+   ./src/org/bouncycastle/*/*/*/*.java \
+   ./src/CacheWolf/*/*/*.java \
+   ./src/CacheWolf/*/*.java
    ./src/CacheWolf/*.java \
    ./src/CacheWolf/*/*/*.java \
    ./src/CacheWolf/*/*.java



From pfeffer at mail.berlios.de  Thu Aug 25 10:39:47 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Aug 2011 10:39:47 PM +0200
Subject: [Cachewolf-svn] r3063 - trunk
Message-ID: <20110825203947.EDF22480BE9@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-25 22:39:47 +0200 (Thu, 25 Aug 2011)
New Revision: 3063

Modified:
   trunk/cw-jar.jnf
   trunk/cw-pc.jnf
   trunk/cw-pda.jnf
   trunk/cw-ppc2003.jnf
Log:
include SSL/TLS library in automatical build (hopefully the net works again outside of eclipse)

Modified: trunk/cw-jar.jnf
===================================================================
--- trunk/cw-jar.jnf	2011-08-25 12:10:27 UTC (rev 3062)
+++ trunk/cw-jar.jnf	2011-08-25 20:39:47 UTC (rev 3063)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%
 3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/
 jewel/EweDirEntry%253Dpath%25253Dbin/org/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico

Modified: trunk/cw-pc.jnf
===================================================================
--- trunk/cw-pc.jnf	2011-08-25 12:10:27 UTC (rev 3062)
+++ trunk/cw-pc.jnf	2011-08-25 20:39:47 UTC (rev 3063)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D-Xms%2B64M%2B-Xmx%2B192M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25
 253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D-Xms%252B64M%252B-Xmx%252B192M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D-Xms%2B64M%2B-Xmx%2B192M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25
 253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D-Xms%252B64M%252B-Xmx%252B192M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico

Modified: trunk/cw-pda.jnf
===================================================================
--- trunk/cw-pda.jnf	2011-08-25 12:10:27 UTC (rev 3062)
+++ trunk/cw-pda.jnf	2011-08-25 20:39:47 UTC (rev 3063)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25
 253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25
 253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico

Modified: trunk/cw-ppc2003.jnf
===================================================================
--- trunk/cw-ppc2003.jnf	2011-08-25 12:10:27 UTC (rev 3062)
+++ trunk/cw-ppc2003.jnf	2011-08-25 20:39:47 UTC (rev 3063)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtr
 ue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewe
 l/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico



From araber95 at mail.berlios.de  Thu Aug 25 11:15:00 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 25 Aug 2011 11:15:00 PM +0200
Subject: [Cachewolf-svn] r3064 - trunk/src/CacheWolf/imp
Message-ID: <20110825211501.06CD7480BE9@sheep.berlios.de>

Author: araber95
Date: 2011-08-25 23:15:00 +0200 (Thu, 25 Aug 2011)
New Revision: 3064

Modified:
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
https login mod frm mcbernie : http://www.geoclub.de/viewtopic.php?f=40&t=57824&p=908905#p908905

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-08-25 20:39:47 UTC (rev 3063)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-08-25 21:15:00 UTC (rev 3064)
@@ -1094,7 +1094,7 @@
 		if (loggedIn && !pref.forceLogin) {
 			return true;
 		}
-		if (pref.userID.length() > 0) {
+		/*if (pref.userID.length() > 0) {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
 			loggedIn = switchToEnglish();
 			if (loggedIn)
@@ -1103,13 +1103,13 @@
 				(new MessageBox("Login", "Check UserID in preferences | Einstellungen.\nsee http://cachewolf.aldos.de/userid.html", FormBase.OKB)).execute();
 				return false;
 			}
-		} else {
-			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
-			if (true) {
+		} else {*/
+		//	UrlFetcher.setPermanentRequestorProperty("Cookie", null);
+		/*	if (true) {
 				(new MessageBox("Login", "Check UserID in preferences| Einstellungen.\nsee http://cachewolf.aldos.de/userid.html", FormBase.OKB)).execute();
 				return false; // until SSL/https works
 			}
-		}
+		}*/
 		loggedIn = false;
 		String loginPage, loginPageUrl, loginSuccess;
 		try {
@@ -1178,23 +1178,26 @@
 					rexViewstate.search(loginPage);
 					if (rexViewstate.didMatch()) {
 						viewstate = rexViewstate.stringMatched(1);
-					} else {
+					} else {;
 						localInfB.close(0);
 						pref.log("[login]:__VIEWSTATE not found (before login): no login possible.", null);
 						// we need the __VIEWSTATE for sending loginData, so we should abort here
 						return false;
 					}
+					
 					final StringBuffer sb = new StringBuffer(1000);
-					sb.append("__VIEWSTATE=" + URL.encodeURL(viewstate, false));
-					sb.append("&ctl00%24ContentBody%24");
-					sb.append("myUsername=" + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
-					sb.append("&ctl00%24ContentBody%24");
-					sb.append("myPassword=" + encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
-					sb.append("&ctl00%24ContentBody%24");
-					sb.append("cookie=on");
-					sb.append("&ctl00%24ContentBody%24");
-					sb.append("Button1=Login");
+					sb.append("__EVENTTARGET=&__EVENTARGUMENT=&"); // added for testing 
+					sb.append("__VIEWSTATE=" + URL.encodeURL(viewstate, false));				
+					sb.append("&ctl00%24SiteContent%24"); // changed from 24BodyContent to 24SiteContent
+					sb.append("tbUsername=" + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias))); // changed myUsername to tbUsername
+					sb.append("&ctl00%24SiteContent%24");
+					sb.append("tbPassword=" + encodeUTF8URL(Utils.encodeJavaUtf8String(passwort))); // changed myPassword to tbPassword
+					sb.append("&ctl00%24SiteContent%24");
+					sb.append("cbRememberMe=on");
+					sb.append("&ctl00%24SiteContent%24");
+					sb.append("btnSignIn=Login"); // changed Button1 to btnSignIn
 					UrlFetcher.setpostData(sb.toString());
+					
 					loginPage = UrlFetcher.fetch(loginPageUrl);
 					if (loginPage.indexOf(loginSuccess) > 0) {
 						pref.log("Login successful: " + pref.myAlias);



From pfeffer at mail.berlios.de  Thu Aug 25 11:26:45 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Aug 2011 11:26:45 PM +0200
Subject: [Cachewolf-svn] r3065 - trunk
Message-ID: <20110825212646.3F79E480BE9@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-25 23:26:45 +0200 (Thu, 25 Aug 2011)
New Revision: 3065

Modified:
   trunk/cw-jar.jnf
   trunk/cw-pc.jnf
   trunk/cw-pda.jnf
   trunk/cw-ppc2003.jnf
Log:
SSL/TLS library: next try to include it in the automatic build

Modified: trunk/cw-jar.jnf
===================================================================
--- trunk/cw-jar.jnf	2011-08-25 21:15:00 UTC (rev 3064)
+++ trunk/cw-jar.jnf	2011-08-25 21:26:45 UTC (rev 3065)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/
 jewel/EweDirEntry%253Dpath%25253Dbin/org/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/
 jewel/EweDirEntry%253Dpath%25253Dbin/org/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico

Modified: trunk/cw-pc.jnf
===================================================================
--- trunk/cw-pc.jnf	2011-08-25 21:15:00 UTC (rev 3064)
+++ trunk/cw-pc.jnf	2011-08-25 21:26:45 UTC (rev 3065)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D-Xms%2B64M%2B-Xmx%2B192M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25
 253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D-Xms%252B64M%252B-Xmx%252B192M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D-Xms%2B64M%2B-Xmx%2B192M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25
 253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D-Xms%252B64M%252B-Xmx%252B192M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico

Modified: trunk/cw-pda.jnf
===================================================================
--- trunk/cw-pda.jnf	2011-08-25 21:15:00 UTC (rev 3064)
+++ trunk/cw-pda.jnf	2011-08-25 21:26:45 UTC (rev 3065)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25
 253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25
 253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico

Modified: trunk/cw-ppc2003.jnf
===================================================================
--- trunk/cw-ppc2003.jnf	2011-08-25 21:15:00 UTC (rev 3064)
+++ trunk/cw-ppc2003.jnf	2011-08-25 21:26:45 UTC (rev 3065)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewe
 l/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewe
 l/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico



From araber95 at mail.berlios.de  Fri Aug 26 12:25:12 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri, 26 Aug 2011 12:25:12 PM +0200
Subject: [Cachewolf-svn] r3066 - trunk/src/CacheWolf
Message-ID: <20110826102512.E35C8480BE9@sheep.berlios.de>

Author: araber95
Date: 2011-08-26 12:25:12 +0200 (Fri, 26 Aug 2011)
New Revision: 3066

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainTab.java
Log:
selecting correct cacheinfos : http://www.geoclub.de/viewtopic.php?f=40&t=57552

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2011-08-25 21:26:45 UTC (rev 3065)
+++ trunk/src/CacheWolf/DetailsPanel.java	2011-08-26 10:25:12 UTC (rev 3066)
@@ -573,7 +573,6 @@
 				ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 				Global.mainTab.newWaypoint(ch);
 			} else if (ev.target == btnGoto) {
-				// FIXME: if something changed saveDirtyWaypoint();
 				Global.mainTab.gotoP.setDestinationAndSwitch(cache);
 			} else if (ev.target == btnCoordinates) {
 				CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-08-25 21:26:45 UTC (rev 3065)
+++ trunk/src/CacheWolf/MainTab.java	2011-08-26 10:25:12 UTC (rev 3066)
@@ -44,7 +44,7 @@
  * This class creates the tabbed panel and sets the tabs to the respective other panels. Important is to have a look at
  * the event handler!<br>
  * Class ID = 1200
- * 
+ *
  * @see MainForm
  * @see MainMenu
  */
@@ -200,7 +200,7 @@
 
 	/**
 	 * Code to execute when leaving a panel (oldCard is the panel number)
-	 * 
+	 *
 	 */
 	private void onLeavingPanel(int panelNo) {
 		if (panelNo == MainTab.LIST_CARD) { // Leaving the list view
@@ -268,7 +268,7 @@
 
 	/**
 	 * Code to execute when entering a panel (getSelectedItem() is the panel number)
-	 * 
+	 *
 	 */
 	private void onEnteringPanel(int panelNo) {
 		MyLocale.setSIPOff();
@@ -341,7 +341,7 @@
 
 	/**
 	 * this is called from MovingMap Cache context menu
-	 * 
+	 *
 	 * @param chi
 	 *            ,
 	 *            the CacheHolder for the Cache to switch to
@@ -349,14 +349,19 @@
 	 *            1=DetailsPanel 2=Description Panel
 	 */
 	public void openPanel(CacheHolder chi, int panelNo) {
-		// To change cache we need to be in panel LIST_CARD
-		onLeavingPanel(oldCard);
-		onEnteringPanel(LIST_CARD);
-		int row = profile.getCacheIndex(chi.getWayPoint());
-		tbP.selectRow(row);
+		// oldCard could have been DETAILS_CARD or GOTO_CARD
+		// on DETAILS_CARD changes already should have been applied before entering map
+		// on GOTO_CARD there is no action
+		// onLeavingPanel(oldCard);
+
+		// do we really need this actions ???
+		// onEnteringPanel(LIST_CARD);
+
+		// to switch to cache selected on map we do action as if leaving LIST_CARD
+		tbP.selectRow(profile.getCacheIndex(chi.getWayPoint()));
+		onLeavingPanel(LIST_CARD);
+
 		if (panelNo == DETAILS_CARD) {
-			ch = chi; // possibly wrong (old) detail if map is called
-			// directly
 			onEnteringPanel(DETAILS_CARD);
 			select(detP);
 		} else if (panelNo == DESCRIPTION_CARD) {
@@ -369,7 +374,7 @@
 	/**
 	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to offer the user the possibility of
 	 * entering an new waypoint at a given position. pCh must already been preset with a valid CacheHolder object
-	 * 
+	 *
 	 * @param pCh
 	 */
 	public void newWaypoint(CacheHolder pCh) {
@@ -425,7 +430,7 @@
 
 	/**
 	 * sets posCircle Lat/Lon to centerTo
-	 * 
+	 *
 	 * @param centerTo
 	 *            true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the
 	 *            loaded map
@@ -433,6 +438,7 @@
 	 */
 	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
 		try {
+			onLeavingPanel(oldCard); // mainly for doing changes from DETAILS_CARD
 			if (!centerTo.isValid()) {
 				(new MessageBox("Error", "No valid coordinates", FormBase.OKB)).execute();
 				return;
@@ -481,7 +487,7 @@
 
 	/**
 	 * Save the index file
-	 * 
+	 *
 	 * @param askForConfirmation
 	 *            is ignored, old: If true, the save can be cancelled by user
 	 */



From araber95 at mail.berlios.de  Fri Aug 26 12:29:21 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri, 26 Aug 2011 12:29:21 PM +0200
Subject: [Cachewolf-svn] r3067 - trunk
Message-ID: <20110826102921.E706A480BE9@sheep.berlios.de>

Author: araber95
Date: 2011-08-26 12:29:21 +0200 (Fri, 26 Aug 2011)
New Revision: 3067

Modified:
   trunk/fwrtsnapshot.sh
Log:
thx to schwaller . http://www.geoclub.de/viewtopic.php?f=40&t=57822&start=10

Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2011-08-26 10:25:12 UTC (rev 3066)
+++ trunk/fwrtsnapshot.sh	2011-08-26 10:29:21 UTC (rev 3067)
@@ -19,7 +19,8 @@
 mkdir -p bin/CacheWolf
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
      -cp lib/CompileEwe.zip:lib -d bin -deprecation -nowarn \
-     src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java src/CacheWolf/view/*/*.java	 
+     src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java src/CacheWolf/view/*/*.java \
+	 src/org/bouncycastle/*/*.java src/org/bouncycastle/*/*/*.java src/org/bouncycastle/*/*/*/*.java
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
     -cp ./lib/CompileEwe.zip:lib -d lib -deprecation -nowarn \
 	lib/net/ax86/*.java ./lib/org/json/*.java



From araber95 at mail.berlios.de  Fri Aug 26 03:26:28 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri, 26 Aug 2011 03:26:28 PM +0200
Subject: [Cachewolf-svn] r3068 - trunk/src/CacheWolf/imp
Message-ID: <20110826132628.6D703481131@sheep.berlios.de>

Author: araber95
Date: 2011-08-26 15:26:28 +0200 (Fri, 26 Aug 2011)
New Revision: 3068

Modified:
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
https login : http://www.geoclub.de/viewtopic.php?f=40&t=57824&start=10

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-08-26 10:29:21 UTC (rev 3067)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-08-26 13:26:28 UTC (rev 3068)
@@ -1087,36 +1087,77 @@
 	} // getCacheCoordinates
 
 	/**
+	 * create alias Method from login for auto retry
+	 * TODO: Translation for status text!
+	 */
+	private boolean login() {
+		
+		int counter = 5;
+		boolean real_return = false;
+		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5507, "Status"), MyLocale.getMsg(5508, "Logging in..."));
+		localInfB.exec();
+		
+		while (counter > 0) {
+			counter--;
+			switch( origin_login() ) {
+				case 1:
+					real_return = true;
+					counter = 0;
+					break;
+				case 0:
+					localInfB.setInfo(MyLocale.getMsg(5523, "Login error! next try...")+ "(" + (5 - counter) + "/5)");
+					break;
+				case 2:
+					(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed! Wrong account or password?"), FormBase.OKB)).execute();
+					counter = 0;
+					break;
+				case 3:
+					localInfB.setInfo(MyLocale.getMsg(5523, "Login error! next try...")+ "(" + (5 - counter) + "/5)");
+					break;
+				case 4:
+					localInfB.setInfo(MyLocale.getMsg(5523, "Login error! next try...") + "(" + (5 - counter) + "/5)");
+					break;
+			}			
+		}
+		
+		localInfB.close(0);
+		return real_return;
+		
+	}
+
+	/**
 	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the
 	 * login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
+	 * changed return type from boolean to int
+	 * 0 = false / abort
+	 * 1 = true
+	 * 2 = wrong username or password
+	 * 3 = login exception
+	 * 4 = fetch error / offline
+	 * remove messagebox and infobox
 	 */
-	private boolean login() {
+	private int origin_login() {
 		if (loggedIn && !pref.forceLogin) {
-			return true;
+			return 1;
 		}
-		/*if (pref.userID.length() > 0) {
+
+		if (pref.userID.length() > 0) {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
 			loggedIn = switchToEnglish();
-			if (loggedIn)
-				return true;
-			else {
-				(new MessageBox("Login", "Check UserID in preferences | Einstellungen.\nsee http://cachewolf.aldos.de/userid.html", FormBase.OKB)).execute();
-				return false;
-			}
-		} else {*/
-		//	UrlFetcher.setPermanentRequestorProperty("Cookie", null);
-		/*	if (true) {
-				(new MessageBox("Login", "Check UserID in preferences| Einstellungen.\nsee http://cachewolf.aldos.de/userid.html", FormBase.OKB)).execute();
-				return false; // until SSL/https works
-			}
-		}*/
+			if (loggedIn) return 1;
+			//else {
+			//  (new MessageBox("Login", "Check UserID in preferences | Einstellungen.\nsee http://cachewolf.aldos.de/userid.html", FormBase.OKB)).execute();
+			//	return false;
+			//}
+		} 
+
 		loggedIn = false;
 		String loginPage, loginPageUrl, loginSuccess;
 		try {
 			loginPageUrl = p.getProp("loginPage");
 			loginSuccess = p.getProp("loginSuccess");
 		} catch (final Exception ex) { // Tag not found in spider.def
-			return false;
+			return 0;
 		}
 
 		// **0 Get password
@@ -1131,24 +1172,20 @@
 		}
 		localInfB.close(0);
 		if (code != FormBase.IDOK)
-			return false;
+			return 0;
 
 		// **1 now we have user and password for login
-		localInfB = new InfoBox(MyLocale.getMsg(5507, "Status"), MyLocale.getMsg(5508, "Logging in..."));
-		localInfB.exec();
+		//localInfB = new InfoBox(MyLocale.getMsg(5507, "Status"), MyLocale.getMsg(5508, "Logging in..."));
+		//localInfB.exec();
 		try {
 			loginPage = UrlFetcher.fetch(loginPageUrl); // http://www.geocaching.com/login/default.aspx
 			if (loginPage.equals("")) {
-				localInfB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 				pref.log("[login]:Could not fetch: gc.com login page " + loginPageUrl, null);
-				return false;
+				return 4;
 			}
 		} catch (final Exception ex) {
-			localInfB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 			pref.log("[login]:Could not fetch: gc.com login page", ex);
-			return false;
+			return 4;
 		}
 
 		// **2 now we can check the loginpage if logged in else log in
@@ -1163,10 +1200,8 @@
 					try {
 						loginPage = UrlFetcher.fetch("http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y");
 					} catch (final Exception ex) {
-						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 						pref.log("[login]:Could not fetch: gc.com login page", ex);
-						return false;
+						return 4;
 					}
 
 				}
@@ -1179,10 +1214,8 @@
 					if (rexViewstate.didMatch()) {
 						viewstate = rexViewstate.stringMatched(1);
 					} else {;
-						localInfB.close(0);
 						pref.log("[login]:__VIEWSTATE not found (before login): no login possible.", null);
-						// we need the __VIEWSTATE for sending loginData, so we should abort here
-						return false;
+						return 0;
 					}
 					
 					final StringBuffer sb = new StringBuffer(1000);
@@ -1215,18 +1248,19 @@
 						if (rexCookieSession.didMatch()) {
 							cookie = "ASP.NET_SessionId=" + rexCookieSession.stringMatched(1);
 						} else {
-							localInfB.close(0);
 							pref.log("[login]:SessionID not found.", null);
-							return false;
+							return 0;
 						}
 						final Regex rexCookieID = new Regex("(?i)userid=(.*?);.*");
 						rexCookieID.search(docprops);
 						if (rexCookieID.didMatch()) {
 							cookie += "; userid=" + rexCookieID.stringMatched(1);
+							// set the user id in user pref
+							pref.userID = rexCookieID.stringMatched(1);
+							pref.savePreferences();
 						} else {
-							localInfB.close(0);
 							pref.log("[login]:userID not found.", null);
-							return false;
+							return 0;
 						}
 						UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
 					} else {
@@ -1234,29 +1268,25 @@
 						pref.log("[login.url]:" + loginPageUrl, null);
 						pref.log("[login.postData]:" + sb.toString(), null);
 						pref.log("[login.Answer]:" + loginPage, null);
-						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed! Wrong account or password?"), FormBase.OKB)).execute();
-						return false;
+						return 2;
 					}
 					if (!this.switchToEnglish())
-						return false;
+						return 0;
 				} catch (final Exception ex) {
 					pref.log("[login]:Login failed with exception.", ex);
-					localInfB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed. Error loading page after login."), FormBase.OKB)).execute();
-					return false;
+					return 3;
 				}
 			}
 		}
 
-		final boolean loginAborted = localInfB.isClosed;
-		localInfB.close(0);
-		if (loginAborted)
-			return false;
-		else {
+		//final boolean loginAborted = localInfB.isClosed;
+		//localInfB.close(0);
+		//if (loginAborted)
+		//	return 0;
+		//else {
 			loggedIn = true;
-			return true;
-		}
+			return 1;
+		//}
 	}
 
 	private boolean switchToEnglish() {



From araber95 at mail.berlios.de  Sat Aug 27 12:14:22 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 27 Aug 2011 12:14:22 PM +0200
Subject: [Cachewolf-svn] r3069 - trunk/src/CacheWolf/imp
Message-ID: <20110827101422.706E0481160@sheep.berlios.de>

Author: araber95
Date: 2011-08-27 12:14:22 +0200 (Sat, 27 Aug 2011)
New Revision: 3069

Modified:
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
no popup of login-status-window if already logged in.

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-08-26 13:26:28 UTC (rev 3068)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-08-27 10:14:22 UTC (rev 3069)
@@ -1092,6 +1092,10 @@
 	 */
 	private boolean login() {
 		
+		if (loggedIn && !pref.forceLogin) {
+			return true;
+		}
+
 		int counter = 5;
 		boolean real_return = false;
 		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5507, "Status"), MyLocale.getMsg(5508, "Logging in..."));
@@ -1137,10 +1141,6 @@
 	 * remove messagebox and infobox
 	 */
 	private int origin_login() {
-		if (loggedIn && !pref.forceLogin) {
-			return 1;
-		}
-
 		if (pref.userID.length() > 0) {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
 			loggedIn = switchToEnglish();



From pfeffer at mail.berlios.de  Sat Aug 27 02:46:32 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 27 Aug 2011 02:46:32 PM +0200
Subject: [Cachewolf-svn] r3070 - trunk/src/CacheWolf
Message-ID: <20110827124633.021A2481161@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-27 14:46:32 +0200 (Sat, 27 Aug 2011)
New Revision: 3070

Modified:
   trunk/src/CacheWolf/HttpConnection.java
Log:
Fix a Bug I implemented by introduction of SSL/TLS library. Thanks for dignosis co-operation to araber95

Modified: trunk/src/CacheWolf/HttpConnection.java
===================================================================
--- trunk/src/CacheWolf/HttpConnection.java	2011-08-27 10:14:22 UTC (rev 3069)
+++ trunk/src/CacheWolf/HttpConnection.java	2011-08-27 12:46:32 UTC (rev 3070)
@@ -342,13 +342,13 @@
 		} else {
 			url = FileBase.fixupPath(url);
 			port = 80;
-			String uu = url.toLowerCase();
-			if (uu.startsWith("https://")) {
+			String uu = url;
+			if (uu.toLowerCase().startsWith("https://")) {
 				useSslTls = true;
 				port = 443;
 				uu = "http://" + uu.substring(8);
 			} else useSslTls = false;
-			if (uu.startsWith("http://")){
+			if (uu.toLowerCase().startsWith("http://")){
 				uu = uu.replace('\\','/');
 				host = uu.substring(7);
 				int first = host.indexOf('/');



From araber95 at mail.berlios.de  Sat Aug 27 02:50:35 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 27 Aug 2011 02:50:35 PM +0200
Subject: [Cachewolf-svn] r3071 - trunk/src/CacheWolf
Message-ID: <20110827125035.56AF1481161@sheep.berlios.de>

Author: araber95
Date: 2011-08-27 14:50:34 +0200 (Sat, 27 Aug 2011)
New Revision: 3071

Modified:
   trunk/src/CacheWolf/UrlFetcher.java
Log:
for no to stress a server ressources : close connection

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-08-27 12:46:32 UTC (rev 3070)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-08-27 12:50:34 UTC (rev 3071)
@@ -77,8 +77,8 @@
 	private static void initPermanentRequestorProperty() {
 		permanentRequestorProperties = new PropertyList();
 		permanentRequestorProperties.add("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-		// permanentRequestorProperties.add("Connection", "close");
-		permanentRequestorProperties.add("Connection", "keep-alive");
+		permanentRequestorProperties.add("Connection", "close");
+		// permanentRequestorProperties.add("Connection", "keep-alive");
 	}
 
 	public static void setPermanentRequestorProperty(String name, String property) {



From pfeffer at mail.berlios.de  Sat Aug 27 09:54:58 2011
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 27 Aug 2011 09:54:58 PM +0200
Subject: [Cachewolf-svn] r3072 - trunk/src/CacheWolf
Message-ID: <20110827195458.8C749481164@sheep.berlios.de>

Author: pfeffer
Date: 2011-08-27 21:54:58 +0200 (Sat, 27 Aug 2011)
New Revision: 3072

Modified:
   trunk/src/CacheWolf/HttpConnection.java
Log:
Bug I implemented by introducing SSL/TLS fixed: transferbuffer size was too small causing many small ip-packetes with less than 100 Bytes. This made espacially POST  with lots of data quite slow

Modified: trunk/src/CacheWolf/HttpConnection.java
===================================================================
--- trunk/src/CacheWolf/HttpConnection.java	2011-08-27 12:50:34 UTC (rev 3071)
+++ trunk/src/CacheWolf/HttpConnection.java	2011-08-27 19:54:58 UTC (rev 3072)
@@ -507,7 +507,7 @@
 	public void transfer(Stream in, OutputStream out) throws IOException
 //	===================================================================
 	{
-		int bufferSize = 1;
+		int bufferSize = 1024;
 		byte [] buff = new byte[bufferSize];
 		while(true){
 			/**



From engywuck at mail.berlios.de  Sun Aug 28 10:22:32 2011
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sun, 28 Aug 2011 10:22:32 AM +0200
Subject: [Cachewolf-svn] r3073 - trunk/src/CacheWolf
Message-ID: <20110828082232.4FC67481168@sheep.berlios.de>

Author: engywuck
Date: 2011-08-28 10:22:31 +0200 (Sun, 28 Aug 2011)
New Revision: 3073

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
Implementing a more sensible logic of toggling selected caches.

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-08-27 19:54:58 UTC (rev 3072)
+++ trunk/src/CacheWolf/myTableModel.java	2011-08-28 08:22:31 UTC (rev 3073)
@@ -561,7 +561,9 @@
 	}
 
 	/**
-	 * Toggle the select status for a group of caches If from==to, the addi Waypoints are also toggled if the cache is a main waypoint If from!=to, each cache is toggled irrespective of its type (main or addi)
+	 * Toggle the select status for a group of caches. Addi waypoints are set to the same state
+	 * as their main cache. (Exception: Their main cache is not in the range of toggled caches,
+	 * then they are toggled independently.)
 	 * 
 	 * @param from
 	 *            index of first cache to toggle
@@ -574,34 +576,53 @@
 		CacheHolder ch;
 		boolean singleRow = from == to;
 		for (int j = from; j <= to; j++) {
+			boolean checkAddiWpts = false;
 			ch = cacheDB.get(j);
-			ch.is_Checked = !ch.is_Checked;
+			if (singleRow) {
+				// If its a single row click, then toggle the cache. Remember to 
+				// toggle addis too, if there are.
+				ch.is_Checked = !ch.is_Checked;
+				checkAddiWpts = true;
+			} else {
+				// If not a single row click...
+				if (ch.isAddiWpt()) {
+					// Only toggle addis, if their main cache is not within the
+					// range that will be toggled
+					int mainIdx = cacheDB.getIndex(ch.mainCache);
+					if (mainIdx < from-1 || mainIdx > to) {
+						ch.is_Checked = !ch.is_Checked;
+					} else {
+						// Otherwise the addis will be toggled along with their 
+						// main caches, so nothing is to do here.
+					}
+				} else {
+					// If its a main cache, then toggle it and remember to 
+					// toggle the addis, too.
+					ch.is_Checked = !ch.is_Checked;
+					checkAddiWpts = true;
+				}
+			}
 			tcControl.repaintCell(j, x);
-			// set the ceckbox also for addi wpts
-			if (ch.hasAddiWpt()) {
+			// Now look for addi wpts.
+			if (checkAddiWpts) {
 				CacheHolder addiWpt;
 				int addiCount = ch.addiWpts.getCount();
 				for (int i = 0; i < addiCount; i++) {
+					// This code will only run when the main cache
+					// has been toggled.
 					addiWpt = (CacheHolder) ch.addiWpts.get(i);
-					int addiIdx = cacheDB.getIndex(addiWpt);
-					// Change check state of addi wpt only if
-					// it is outside the selected range and not visible
-					// - otherwise it will be touched by this 
-					// algorithm
-					// Exception: If just one cache is clicked, then check all
-					// addi wpts it has, regardless of their position.
-					if ((! addiWpt.isVisible() && (addiIdx > to || addiIdx < from))
-							|| singleRow){
-						addiWpt.is_Checked = ch.is_Checked;
-						if (addiWpt.isVisible()) {
-							tcControl.repaintCell(cacheDB.getIndex(addiWpt), x);
-						}
+					// Set all addi check states to the state of the 
+					// main cache. 
+					addiWpt.is_Checked = ch.is_Checked;
+					if (addiWpt.isVisible()) {
+						tcControl.repaintCell(cacheDB.getIndex(addiWpt), x);
 					}
 				}
+			}
 
-			}
 		}
 	}
+	
 
 	public void select(int row, int col, boolean selectOn) {
 		// super.select(row, col, selectOn);



