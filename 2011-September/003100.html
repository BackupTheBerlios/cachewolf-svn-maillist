<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3109 - in branches/r1.2: . lib/net/ax86	lib/org/json res_noewe res_noewe/languages src/CacheWolf	src/CacheWolf/exp src/CacheWolf/imp src/CacheWolf/navi	src/CacheWolf/utils src/CacheWolf/view/pda
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-September/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3109%20-%20in%20branches/r1.2%3A%20.%20lib/net/ax86%0A%09lib/org/json%20res_noewe%20res_noewe/languages%20src/CacheWolf%0A%09src/CacheWolf/exp%20src/CacheWolf/imp%20src/CacheWolf/navi%0A%09src/CacheWolf/utils%20src/CacheWolf/view/pda&In-Reply-To=%3C20110926071943.86B4C48120D%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003099.html">
   <LINK REL="Next"  HREF="003101.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3109 - in branches/r1.2: . lib/net/ax86	lib/org/json res_noewe res_noewe/languages src/CacheWolf	src/CacheWolf/exp src/CacheWolf/imp src/CacheWolf/navi	src/CacheWolf/utils src/CacheWolf/view/pda</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3109%20-%20in%20branches/r1.2%3A%20.%20lib/net/ax86%0A%09lib/org/json%20res_noewe%20res_noewe/languages%20src/CacheWolf%0A%09src/CacheWolf/exp%20src/CacheWolf/imp%20src/CacheWolf/navi%0A%09src/CacheWolf/utils%20src/CacheWolf/view/pda&In-Reply-To=%3C20110926071943.86B4C48120D%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3109 - in branches/r1.2: . lib/net/ax86	lib/org/json res_noewe res_noewe/languages src/CacheWolf	src/CacheWolf/exp src/CacheWolf/imp src/CacheWolf/navi	src/CacheWolf/utils src/CacheWolf/view/pda">araber95 at mail.berlios.de
       </A><BR>
    <I>Mon Sep 26 09:19:43 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003099.html">[Cachewolf-svn] r3108 - trunk/src/CacheWolf/imp
</A></li>
        <LI>Next message: <A HREF="003101.html">[Cachewolf-svn] r3110 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3100">[ date ]</a>
              <a href="thread.html#3100">[ thread ]</a>
              <a href="subject.html#3100">[ subject ]</a>
              <a href="author.html#3100">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-09-26 09:19:42 +0200 (Mon, 26 Sep 2011)
New Revision: 3109

Modified:
   branches/r1.2/CacheWolf.launch
   branches/r1.2/build.xml
   branches/r1.2/compile.sh
   branches/r1.2/cw-jar.jnf
   branches/r1.2/cw-pc.jnf
   branches/r1.2/cw-pda.jnf
   branches/r1.2/cw-ppc2003.jnf
   branches/r1.2/fwrtsnapshot.sh
   branches/r1.2/lib/net/ax86/GPS.class
   branches/r1.2/lib/net/ax86/GPSException.class
   branches/r1.2/lib/net/ax86/GPSHook.class
   branches/r1.2/lib/net/ax86/GPSTest.class
   branches/r1.2/lib/org/json/JSONArray.class
   branches/r1.2/lib/org/json/JSONException.class
   branches/r1.2/lib/org/json/JSONObject$Null.class
   branches/r1.2/lib/org/json/JSONObject.class
   branches/r1.2/lib/org/json/JSONString.class
   branches/r1.2/lib/org/json/JSONTokener.class
   branches/r1.2/lib/org/json/Test$1Obj.class
   branches/r1.2/lib/org/json/Test.class
   branches/r1.2/res_noewe/languages/DE.cfg
   branches/r1.2/res_noewe/languages/EN.cfg
   branches/r1.2/res_noewe/languages/FR.cfg
   branches/r1.2/res_noewe/languages/NL.cfg
   branches/r1.2/res_noewe/languages/PL.cfg
   branches/r1.2/res_noewe/languages/SV.cfg
   branches/r1.2/res_noewe/spider.def
   branches/r1.2/src/CacheWolf/Attributes.java
   branches/r1.2/src/CacheWolf/CWPoint.java
   branches/r1.2/src/CacheWolf/CacheHolder.java
   branches/r1.2/src/CacheWolf/CacheSize.java
   branches/r1.2/src/CacheWolf/CacheTerrDiff.java
   branches/r1.2/src/CacheWolf/CacheType.java
   branches/r1.2/src/CacheWolf/DetailsPanel.java
   branches/r1.2/src/CacheWolf/Extractor.java
   branches/r1.2/src/CacheWolf/MainMenu.java
   branches/r1.2/src/CacheWolf/MainTab.java
   branches/r1.2/src/CacheWolf/Matrix.java
   branches/r1.2/src/CacheWolf/Preferences.java
   branches/r1.2/src/CacheWolf/Profile.java
   branches/r1.2/src/CacheWolf/UrlFetcher.java
   branches/r1.2/src/CacheWolf/Version.java
   branches/r1.2/src/CacheWolf/exp/KMLExporter.java
   branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java
   branches/r1.2/src/CacheWolf/imp/SpiderGC.java
   branches/r1.2/src/CacheWolf/myTableModel.java
   branches/r1.2/src/CacheWolf/navi/MapLoader.java
   branches/r1.2/src/CacheWolf/navi/MovingMap.java
   branches/r1.2/src/CacheWolf/utils/URLUTF8Encoder.java
   branches/r1.2/src/CacheWolf/view/pda/PDAList.java
   branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java
   branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java
   branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java
Log:
New release based on NB 3107 (1.3) without https additions. (please insert userID manually)

Modified: branches/r1.2/CacheWolf.launch
===================================================================
--- branches/r1.2/CacheWolf.launch	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/CacheWolf.launch	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1,4 +1,4 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
+&#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;launchConfiguration type=&quot;org.eclipse.jdt.launching.localJavaApplication&quot;&gt;
 &lt;listAttribute key=&quot;org.eclipse.debug.core.MAPPED_RESOURCE_PATHS&quot;&gt;
 &lt;listEntry value=&quot;/CacheWolf&quot;/&gt;
@@ -6,6 +6,7 @@
 &lt;listAttribute key=&quot;org.eclipse.debug.core.MAPPED_RESOURCE_TYPES&quot;&gt;
 &lt;listEntry value=&quot;4&quot;/&gt;
 &lt;/listAttribute&gt;
+&lt;booleanAttribute key=&quot;org.eclipse.debug.core.appendEnvironmentVariables&quot; value=&quot;true&quot;/&gt;
 &lt;listAttribute key=&quot;org.eclipse.jdt.launching.CLASSPATH&quot;&gt;
 &lt;listEntry value=&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry path=&quot;3&quot; projectName=&quot;CacheWolf&quot; type=&quot;1&quot;/&gt;&#13;&#10;&quot;/&gt;
 &lt;listEntry value=&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry internalArchive=&quot;/CacheWolf/lib/JavaEwe.zip&quot; path=&quot;3&quot; type=&quot;2&quot;/&gt;&#13;&#10;&quot;/&gt;

Modified: branches/r1.2/build.xml
===================================================================
--- branches/r1.2/build.xml	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/build.xml	2011-09-26 07:19:42 UTC (rev 3109)
@@ -334,7 +334,7 @@
 		&lt;javac source=&quot;1.3&quot; target=&quot;1.1&quot; encoding=&quot;windows-1252&quot;
 			classpath=&quot;./lib/CompileEwe.zip:./lib/&quot; destdir=&quot;${classes.dir}&quot;
 			deprecation=&quot;off&quot; nowarn=&quot;on&quot; srcdir=&quot;src&quot;
-			includes=&quot;CacheWolf/*.java,CacheWolf/*/*.java&quot; /&gt;
+			includes=&quot;CacheWolf/*.java,CacheWolf/*/*.java,org/*.java,org/*/*.java&quot; /&gt;
 
 	&lt;/target&gt;
 

Modified: branches/r1.2/compile.sh
===================================================================
--- branches/r1.2/compile.sh	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/compile.sh	2011-09-26 07:19:42 UTC (rev 3109)
@@ -2,7 +2,7 @@
 
 ENCODING=${ENCODING:-windows-1252}
 
-do_compile() {
+compile_cw() {
    javac \
       -source 1.3 \
       -target 1.1 \
@@ -13,11 +13,27 @@
       &quot;$@&quot;
 }
 
-do_compile \
+compile_json() {
+   javac \
+      -source 1.3 \
+      -target 1.1 \
+      -encoding &quot;${ENCODING}&quot; \
+      -cp ./lib/CompileEwe.zip:./lib/ \
+      -deprecation \
+      -nowarn \
+      &quot;$@&quot;
+}
+
+compile_cw \
    -d ./bin/ \
+   ./src/org/bouncycastle/*/*.java \
+   ./src/org/bouncycastle/*/*/*.java \
+   ./src/org/bouncycastle/*/*/*/*.java \
+   ./src/CacheWolf/*/*/*.java \
+   ./src/CacheWolf/*/*.java
    ./src/CacheWolf/*.java \
    ./src/CacheWolf/*/*/*.java \
    ./src/CacheWolf/*/*.java
-do_compile \
+compile_json \
    lib/net/*/*.java \
    lib/org/*/*.java

Modified: branches/r1.2/cw-jar.jnf
===================================================================
--- branches/r1.2/cw-jar.jnf	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/cw-jar.jnf	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%
 3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/
 jewel/EweDirEntry%253Dpath%25253Dbin/org/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico

Modified: branches/r1.2/cw-pc.jnf
===================================================================
--- branches/r1.2/cw-pc.jnf	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/cw-pc.jnf	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D-Xms%2B64M%2B-Xmx%2B192M&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25
 253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D-Xms%252B64M%252B-Xmx%252B192M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D-Xms%2B64M%2B-Xmx%2B192M&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25
 253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D-Xms%252B64M%252B-Xmx%252B192M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico

Modified: branches/r1.2/cw-pda.jnf
===================================================================
--- branches/r1.2/cw-pda.jnf	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/cw-pda.jnf	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25
 253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25
 253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico

Modified: branches/r1.2/cw-ppc2003.jnf
===================================================================
--- branches/r1.2/cw-ppc2003.jnf	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/cw-ppc2003.jnf	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtr
 ue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B6M&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003&amp;createWithPnf=true&amp;eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewe
 l/EweDirEntry%253Dpath%25253Dbin/org%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253Dorg/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B6M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=resources/CacheWolf.ico

Modified: branches/r1.2/fwrtsnapshot.sh
===================================================================
--- branches/r1.2/fwrtsnapshot.sh	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/fwrtsnapshot.sh	2011-09-26 07:19:42 UTC (rev 3109)
@@ -19,7 +19,8 @@
 mkdir -p bin/CacheWolf
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
      -cp lib/CompileEwe.zip:lib -d bin -deprecation -nowarn \
-     src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java src/CacheWolf/view/*/*.java	 
+     src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java src/CacheWolf/view/*/*.java \
+	 src/org/bouncycastle/*/*.java src/org/bouncycastle/*/*/*.java src/org/bouncycastle/*/*/*/*.java
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
     -cp ./lib/CompileEwe.zip:lib -d lib -deprecation -nowarn \
 	lib/net/ax86/*.java ./lib/org/json/*.java

Modified: branches/r1.2/lib/net/ax86/GPS.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/net/ax86/GPSException.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/net/ax86/GPSHook.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/net/ax86/GPSTest.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/JSONArray.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/JSONException.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/JSONObject$Null.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/JSONObject.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/JSONString.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/JSONTokener.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/Test$1Obj.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/lib/org/json/Test.class
===================================================================
(Binary files differ)

Modified: branches/r1.2/res_noewe/languages/DE.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/DE.cfg	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/res_noewe/languages/DE.cfg	2011-09-26 07:19:42 UTC (rev 3109)
@@ -140,7 +140,6 @@
 213=Verwaiste .xml Dateien l&#195;&#182;schen
 214=Neuer Wegpunkt
 215=nach LOC
-216=Immer bei GC einloggen
 217=von GC Funde
 218=Auch in Beschreibung/Notizen
 219=Suche...
@@ -1105,8 +1104,8 @@
 7301=Stadt
 7302=Suchen
 7303=Abbr.
-7304=berlin, deutschland
-7305=Hauptbahnhof
+7304=Berlin
+7305=
 7306=suche...
 7307=abgebrochen durch Nutzer
 7308=Fehler bei der online Verbindung

Modified: branches/r1.2/res_noewe/languages/EN.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/EN.cfg	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/res_noewe/languages/EN.cfg	2011-09-26 07:19:42 UTC (rev 3109)
@@ -140,7 +140,6 @@
 213=Deleting orphans
 214=New Waypoint
 215=to LOC
-216=Always login to GC
 217=from GC finds
 218=Also in description/notes
 219=Searching...

Modified: branches/r1.2/res_noewe/languages/FR.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/FR.cfg	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/res_noewe/languages/FR.cfg	2011-09-26 07:19:42 UTC (rev 3109)
@@ -140,7 +140,6 @@
 213=Effacer les fichier .xml orpheline
 214=Nouveau waypoint
 215=&#195;&#160; LOC
-216=Toujours connecter
 217=de GC trouvailles
 218=Aussi dans description/notes
 219=Cherchant...

Modified: branches/r1.2/res_noewe/languages/NL.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/NL.cfg	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/res_noewe/languages/NL.cfg	2011-09-26 07:19:42 UTC (rev 3109)
@@ -140,7 +140,6 @@
 213=[Deleting orphans]
 214=Nieuwe Waypoint
 215=aan LOC
-216=Altijd aanmelden bij GC
 217=van GC vondsten
 218=Ook in opmerkingen/beschrijving
 219=Zoeken...

Modified: branches/r1.2/res_noewe/languages/PL.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/PL.cfg	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/res_noewe/languages/PL.cfg	2011-09-26 07:19:42 UTC (rev 3109)
@@ -140,7 +140,6 @@
 213=Usuwanie sierot
 214=Nowy WaypointUsunacUsunac
 215=LOC
-216=Zawsze loguj do GC
 217=z GC stwierdza
 218=Takze w opisie/notatkach
 219=Wyszukiwanie...

Modified: branches/r1.2/res_noewe/languages/SV.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/SV.cfg	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/res_noewe/languages/SV.cfg	2011-09-26 07:19:42 UTC (rev 3109)
@@ -140,7 +140,6 @@
 213=bort f&#195;&#182;r&#195;&#164;ldral&#195;&#182;sa
 214=Ny v&#195;&#164;gpunkt
 215=f&#195;&#182;r LOC
-216=alltid logga in till GC
 217=fr&#195;&#165;n GC finner
 218=&#195;&#164;ven i beskrivningen / Notes
 219=S&#195;&#182;ker ...

Modified: branches/r1.2/res_noewe/spider.def
===================================================================
--- branches/r1.2/res_noewe/spider.def	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/res_noewe/spider.def	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1,49 +1,5 @@
 #============================================================
 # spider.def - Definition file for reading caches from GC.COM
-# Version 1.0 - 20070526 skg
-# Version 2.0 - 20070531 nach GC &#196;nderungen
-# Version 2.1 - 20070601 TB Anpassung an GC &#196;nderung
-# Version 2.2 - 20070602 firstLine erg&#228;nzt. Damit funktionieren jetzt auch die n&#228;chsten Seiten.
-# Version 2.3 - 20070602 sizeRex an GC &#196;nderungen angepasst
-# Version 2.4 - 20070616 neu: Attribute
-# Version 2.5 - 20070629 Anpassungen an Listen&#228;nderung bei GC
-# Version 2.6 - 20070701 Bugfix: Wenn Zentrum exakt in Cachekoordinaten liegt wurde der Cache nicht gespidert
-# Version 2.7 - 20070811 Bugfix fuer verschluesselte Logs
-# Version 2.8 - 20070814 Findet jetzt auch Addi Wpts in eigenen Caches
-# Version 2.9 - 20070817 Bessere Unterscheidung zwischen Werbung vs.normalen Caches + Caches ohne Richtung/Entfenung
-# Version 2.10 - 20070825 Travelbug support
-# Version 2.11 - 20070907 get travelbug mission by tracking number
-# Version 3.0 - 20071010 adaption to new GC-design
-# Version 3.1 - 20071013 Use the given prefix for addi waypoints
-# Version 3.2 - 20071024 longer end sequence for longDescRex
-# Version 3.3 - 20080316 get travelbug name by tracking number
-# Version 3.4 - 20080227 Image comments added
-# Version 3.5 - 20080529 Modified descRex to allow for linebreaks
-# Version 3.6 - 20080531 Modified descRex to avoid Stack overflow in exe
-# Version 3.7 - 20080613 Some lines generalized for proxies replacing the images.
-# Version 4.0 - 20080725 adaption to new GC-design
-# Version 4.1 - 20080725 adaption to new GC-design (images and travelbugs)
-# Version 4.2 - 20081031 Fix for cache type (background image with name of type)
-# Version 4.3 - 20090314 maxDistance string added
-# Version 4.4 - 20090314 firstPageFinds string added
-# Version 4.5 - 20090315 strings for spidering country/state/logId
-# Version 4.6 - 20090406 Fix for country/state (did not work with US caches)
-# Version 4.7 - 20090521 Strings for single cache types added
-# Version 4.8 - 20090805 More specific unavailability detection
-# Version 4.9 - 20091018 Should work now with proxies and cachetypes as background
-# Version 4.10- 20091021 Tags in Description are now correctly closed
-# Version 4.11- 20091023 Reverted last change, because it doesn't work with EWE/EXE
-# Version 5.0 - 20091105 adaption to new GC-design
-# Version 6.0 - 20100113 adaption to new GC-design
-# Version 6.1 - 20100305 better log recognition
-# Version 7.0 - 20100402 adaption to new GC-design
-# Version 7.1 - 20100528 better description recognition
-# Version 8.0 - 20100604 adaption to new GC-design
-# Version 9.0 - 20100630 adaption to new GC-design
-# Version 10.0 - 20100729 adaption to new GC-design DateHiddenrex , optimized cacheOwnerRex araber95
-# Version 11.0 - 20101110 adaption to new GC-design (maybe not complete)
-# Version 12.0 - 20101223 first little adaption to new GC-design (logs)
-# Version 12.0 - 20101224 adaption to new GC-design (decode distance)
 #============================================================
 # A suffix of Rex indicates a regular expression
 # A suffix of ExStart indicates the start of an Extractor search pattern
@@ -51,6 +7,7 @@
 #
 # Important:
 # * When entering spaces into a string ensure to escape them or write them as \\u0020
+# * escaping space should not be necessary
 # * Be sure that you have no hidden spaces at the end of a line or the patterns will not match!
 #------------------------------------------------------------
 #loginPage          = <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
@@ -113,7 +70,7 @@
 shortDescRex       = tBody_ShortDescription&quot;&gt;((?s).*?)&lt;/span&gt;
 longDescRex        = tBody_LongDescription&quot;&gt;((?s).*?)&lt;strong&gt;\\s+Additional\ Hints&lt;/strong&gt;
 cacheNameRex       = tBody_CacheName&quot;&gt;((?s).*?)&lt;/span&gt;
-cacheOwnerRex      = &amp;wid(?:(?s).*?)&gt;((?s).*?)&lt;
+cacheOwnerRex      = &amp;wid=(?:(?s).*?)&gt;((?s).*?)&lt;
 dateHiddenRex      = (?:Hidden|Event\ Date)\\s*:\\s*((?s).*?)&lt;
 hintsRex           = &lt;div\ id=&quot;div_hint&quot;\ class=&quot;span-8\ WrapFix&quot;&gt;\\s*((?s).*?)\\s*&lt;/div&gt;
 sizeRex            = alt=&quot;Size:\ ((?s).*?)&quot;
@@ -125,25 +82,7 @@
 #--------------------------------------
 #Section2a: Logs
 #--------------------------------------
-# blockRex extrahiert zun&#228;chst aus der gesamten Seite den Logbereich
-blockRex           = &lt;table class=&quot;LogsTable&quot;&gt;((?s).*?)&lt;/table&gt;\\s+&lt;p&gt;
-# singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
-singleLogExStart   = &gt;&lt;strong&gt;&lt;img src=
-singleLogExEnd     = &lt;small&gt;&lt;a\ href=&quot;
-# iconEx, nameTempEx, dateEx, singleLogEx werden auf einen singleLog angewendet
-iconExStart        = www.geocaching.com/images/icons/
-iconExEnd          = \ alt=&quot;
-nameTempExStart    = &lt;a\ href='
-nameTempExEnd      = /a&gt;
-# Name extrahiert aus nameTemp
-nameExStart        = &gt;
-nameExEnd          = &lt;
-dateExStart        = &quot;\ /&gt;&nbsp;
-dateExEnd          = \ by\ &lt;a\ href='/profile/?guid=
-logExStart         = found)&lt;br\ /&gt;&lt;br\ /&gt;
-logExEnd           = &lt;br\ /&gt;&lt;br\ /&gt;&lt;small&gt;&lt;a\ href=&quot;
-logIdExStart         = '\ id='
-logIdExEnd           = '&gt;
+UserTokenRex       = userToken = '((?s).*?)';
 # Die Icons, die einen erfolgreichen Fund signalisieren
 icon_smile         = icon_smile.gif
 icon_camera        = icon_camera.gif
@@ -183,14 +122,15 @@
 imgBlockExStart    = &lt;IMG
 imgBlockExEnd      = &gt;
 # imgSpanEx searches for images in the image section
-imgSpanExStart     = &lt;span id=&quot;ctl00_ContentBody_Images&quot;&gt;
-imgSpanExEnd       = &lt;/p&gt;
-imgNameExStart     = &quot;\ /&gt;\ &lt;span&gt;
-imgNameExEnd       = &lt;/span&gt;&lt;/a&gt;
-imgSrcExStart      = &lt;a\ href=&quot;<A HREF="http://">http://</A>
-imgSrcExEnd        = &quot;\ rel=&quot;lightbox&quot;
-imgCommentExStart  = &lt;/a&gt;&lt;br\ /&gt;&lt;br\ /&gt;
-imgCommentExEnd    = &lt;
+imgSpanExStart     = ctl00_ContentBody_MapLinks_MapLinks
+imgSpanExStart2    = &lt;p class=&quot;NoPrint&quot;&gt;
+imgSpanExEnd       = InformationWidget Clear
+imgSrcExStart      = &lt;a href=&quot;<A HREF="http://">http://</A>
+imgSrcExEnd        = &quot; rel=&quot;lightbox&quot;
+imgNameExStart     = &lt;span&gt;
+imgNameExEnd       = &lt;/span&gt;
+imgCommentExStart  = &lt;/a&gt;&lt;br /&gt;
+imgCommentExEnd    = &lt;br /&gt;&lt;br /&gt;
 
 #--------------------------------------
 #Section2d: Additional waypoints

Modified: branches/r1.2/src/CacheWolf/Attributes.java
===================================================================
--- branches/r1.2/src/CacheWolf/Attributes.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/Attributes.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -46,7 +46,7 @@
 
 	/**
 	 * Get the number of attributes in the list
-	 * 
+	 *
 	 * @return number of attributes
 	 */
 	public int count() {
@@ -65,8 +65,7 @@
 	}
 
 	/**
-	 * Filling the Attributes from Cache.xml (CacheHolderDetail)
-	 * todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
+	 * Filling the Attributes from Cache.xml (CacheHolderDetail) todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
 	 */
 	public void XmlAttributesEnd(String elem) {
 		clear();
@@ -78,8 +77,7 @@
 	}
 
 	/**
-	 * Prepare for attributes to be written to cache.xml file
-	 * todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
+	 * Prepare for attributes to be written to cache.xml file todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
 	 */
 	public String XmlAttributesWrite() {
 		StringBuffer sb = new StringBuffer(1000);
@@ -95,7 +93,7 @@
 
 	/**
 	 * Add a new attribute to the array by Name, meaning its icon picture name
-	 * 
+	 *
 	 * @param attributeName
 	 */
 	public void add(String attributeName) {
@@ -111,11 +109,11 @@
 
 	/**
 	 * Add a new attribute to the array by ID and Inc as you get it from GC gpx-File
-	 * 
+	 *
 	 * @param GC
-	 *            attribute ID
+	 *          attribute ID
 	 * @param GC
-	 *            attribute Inc (attribute set = 0 ,attribute not set = 1)
+	 *          attribute Inc (attribute set = 0 ,attribute not set = 1)
 	 */
 	public void add(int attIdGC, String Yes1No0) {
 		if (_count &lt; attribs.length) {
@@ -142,9 +140,9 @@
 
 	/**
 	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download
-	 * 
+	 *
 	 * @param OC
-	 *            attribute ID
+	 *          attribute ID
 	 */
 	public void add(int attIdOC) {
 		Attribute attr = new Attribute(attIdOC);
@@ -161,7 +159,7 @@
 
 	/**
 	 * to get the Bit Representation of the Attributs of this Cache
-	 * 
+	 *
 	 * @return the Long array representing the Attributes of this Cache
 	 */
 	public long[] getAttribsAsBits() {
@@ -175,9 +173,9 @@
 
 	/**
 	 * Get the i-th attribute
-	 * 
+	 *
 	 * @param i
-	 *            The number for which the attribute is to be retrieved
+	 *          The number for which the attribute is to be retrieved
 	 * @return The attribute
 	 */
 	public Attribute getAttribute(int i) {

Modified: branches/r1.2/src/CacheWolf/CWPoint.java
===================================================================
--- branches/r1.2/src/CacheWolf/CWPoint.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/CWPoint.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -357,10 +357,13 @@
 	 */
 	public String getLatDeg(int format) {
 		switch (format) {
-		case TransformCoordinates.DD: 	return MyLocale.formatDouble(this.latDec, &quot;00.00000&quot;).replace(',','.');
+		case TransformCoordinates.DD: 	
+			return MyLocale.formatDouble(this.latDec, &quot;00.00000&quot;).replace(',','.');
 		case TransformCoordinates.DMM:
-		case TransformCoordinates.DMS:	return getDMS(latDec,0,format);
-		default: return &quot;&quot;;
+		case TransformCoordinates.DMS:	
+			return getDMS(latDec,0,format);
+		default: 
+			return &quot;&quot;;
 		}
 	}
 	
@@ -572,7 +575,8 @@
 	public String toString(int format){
 		if (!isValid()) return MyLocale.getMsg(999,&quot;not set&quot;);
 		switch (format) {
-		case TransformCoordinates.DD:	return getNSLetter() + &quot; &quot; + STRreplace.replace(getLatDeg(format),&quot;-&quot;,&quot;&quot;) + &quot;&#176; &quot;
+		case TransformCoordinates.DD:	
+			return getNSLetter() + &quot; &quot; + STRreplace.replace(getLatDeg(format),&quot;-&quot;,&quot;&quot;) + &quot;&#176; &quot;
 						+  getEWLetter() + &quot; &quot; + STRreplace.replace(getLonDeg(format),&quot;-&quot;,&quot;&quot;)+ &quot;&#176;&quot;;
 		case TransformCoordinates.DMM:	return getNSLetter() + &quot; &quot; + getLatDeg(format) + &quot;&#176; &quot; + getLatMin(format) + &quot; &quot;
 						+  getEWLetter() + &quot; &quot; + getLonDeg(format) + &quot;&#176; &quot; + getLonMin(format);

Modified: branches/r1.2/src/CacheWolf/CacheHolder.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheHolder.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/CacheHolder.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -48,7 +48,7 @@
 /**
  * A class to hold information on a cache.&lt;br&gt;
  * Not all attributes are filled at once. You will have to look at other classes and methods to get more information.
- * 
+ *
  */
 public class CacheHolder {
 	protected static final String NOBEARING = &quot;?&quot;;
@@ -425,7 +425,7 @@
 
 	/**
 	 * Returns the distance in formatted output. Using kilometers when metric system is active, using miles when imperial system is active.
-	 * 
+	 *
 	 * @return The current distance.
 	 */
 	public String getDistance() {
@@ -463,7 +463,7 @@
 	/**
 	 * Updates Cache information with information provided by cache given as argument. This is used to update the cache with the information retrieved from files or web: The argument cache is the one that is filled with the read information,
 	 * &lt;code&gt;this&lt;/code&gt; is the cache that is already in the database and subject to update.
-	 * 
+	 *
 	 * @param ch
 	 *            The cache who's information is updating the current one
 	 * @param overwrite
@@ -612,7 +612,14 @@
 		if (isAddiWpt()) {
 			CacheHolder ch = this.mainCache;
 			varParams.put(&quot;MAINWP&quot;, ch.getWayPoint());
-			varParams.put(&quot;MAINWPNAME&quot;, ch.getCacheName());
+			String cn = ch.getCacheName();
+			if (codec instanceof AsciiCodec) {
+				cn = Exporter.simplifyString(cn);
+			} // use for &quot;NAME&quot;
+			if (badChars != null) {
+				cn = badChars.replaceAll(cn);
+			} // use for &quot;NAME&quot;
+			varParams.put(&quot;MAINWPNAME&quot;, cn);
 			varParams.put(&quot;DIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;!&lt;!&quot; : decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
 			String sHard = Integer.toString(ch.hard);
 			varParams.put(&quot;SHORTDIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;&quot; : sHard);
@@ -697,6 +704,7 @@
 			varParams.put(&quot;COUNTRY&quot;, &quot;&quot;);
 			varParams.put(&quot;STATE&quot;, &quot;&quot;);
 		} else {
+			// todo &lt;br&gt;
 			varParams.put(&quot;URL&quot;, det.URL);
 			if (html) {
 				if (ModTyp == 0) {
@@ -844,7 +852,7 @@
 
 	/**
 	 * generate a gc.com compatible string representation of log derived from the internally stored image
-	 * 
+	 *
 	 * @param image
 	 *            name of the image to display
 	 * @return log type. will default to &quot;Write note&quot; for unknown logtypes
@@ -887,7 +895,7 @@
 
 	/**
 	 * Modify the image links in the long description so that they point to image files in the local directory Also copy the image file to the target directory so that it can be displayed.
-	 * 
+	 *
 	 * @param chD
 	 *            CacheHolderDetail
 	 * @param int ModTypLongDesc == 1 get image from profile path, == 2 get image from html-path
@@ -1045,7 +1053,7 @@
 
 	/**
 	 * True if ch and this belong to the same main cache.
-	 * 
+	 *
 	 * @param ch
 	 * @return
 	 */
@@ -1070,7 +1078,7 @@
 
 	/**
 	 * Find out of detail object of Cache is loaded. Returns &lt;code&gt;true&lt;/code&gt; if this is the case.
-	 * 
+	 *
 	 * @return True when details object is present
 	 */
 	public boolean detailsLoaded() {
@@ -1081,7 +1089,7 @@
 	 * Gets the detail object of a cache. The detail object stores information which is not needed for every cache instantaneously, but can be loaded if the user decides to look at this cache. If the cache object is already existing, the method will
 	 * return this object, otherwise it will create it and try to read it from the corresponding &lt;waypoint&gt;.xml file. Depending on the parameters it is allowed that the &lt;waypoint&gt;.xml file does not yet exist, or the user is warned that the file doesn't
 	 * exist. If more than &lt;code&gt;maxdetails&lt;/code&gt; details are loaded, then the 5 last recently loaded caches are unloaded (to save ram).
-	 * 
+	 *
 	 * @param alarmuser
 	 *            If true an error message will be displayed to the user, if the details could not be read, and the method returns null
 	 * @return The respective CacheHolderDetail, or null
@@ -1328,7 +1336,7 @@
 
 	/**
 	 * Initializes the caches states (and its addis) before updating, so that the &quot;new&quot;, &quot;updated&quot;, &quot;log_updated&quot; and &quot;incomplete&quot; properties are properly set.
-	 * 
+	 *
 	 * @param pNewCache
 	 *            &lt;code&gt;true&lt;/code&gt; if it is a new cache (i.e. a cache not existing in CacheDB), &lt;code&gt;false&lt;/code&gt; otherwise.
 	 */
@@ -1346,7 +1354,7 @@
 
 	/**
 	 * Creates a bit field of boolean values of the cache, represented as a long value. Boolean value of &lt;code&gt;true&lt;/code&gt; results in &lt;code&gt;1&lt;/code&gt; in the long values bits, and, vice versa, 0 for false.
-	 * 
+	 *
 	 * @return long value representing the boolean bit field
 	 */
 	private long boolFields2long() {
@@ -1362,7 +1370,7 @@
 	/**
 	 * Creates a field of byte values of certain properties of the cache, represented as a long value. As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8 bits. The position indicates the group of bits where the byte is packed,
 	 * counting starting from one by the right side of the long.
-	 * 
+	 *
 	 * @return long value representing the byte field
 	 */
 	private long byteFields2long() {
@@ -1372,7 +1380,7 @@
 
 	/**
 	 * Evaluates byte values from a long value for certain properties of the cache.
-	 * 
+	 *
 	 * @param value
 	 *            The long value which contains up to 8 bytes.
 	 */
@@ -1390,7 +1398,7 @@
 
 	/**
 	 * convert a v2 byte filed to the current structures
-	 * 
+	 *
 	 * @param value
 	 */
 	private void long2byteFieldsv2(long value) {
@@ -1418,7 +1426,7 @@
 
 	/**
 	 * Extracts a byte from a long value. The position is the number of the 8-bit block of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the right side of the long.
-	 * 
+	 *
 	 * @param value
 	 *            The long value which contains the bytes
 	 * @param position
@@ -1432,7 +1440,7 @@
 
 	/**
 	 * Evaluates boolean values from a long value, which is seen as bit field.
-	 * 
+	 *
 	 * @param value
 	 *            The bit field as long value
 	 */
@@ -1455,7 +1463,7 @@
 
 	/**
 	 * Represents a bit mask as long value for a boolean value which is saved at a specified position in the long field.
-	 * 
+	 *
 	 * @param value
 	 *            The boolean value we want to code
 	 * @param position
@@ -1472,7 +1480,7 @@
 
 	/**
 	 * Coding a long field which has only the bits of the byte value set. The position is the number (from 1 to 8) of the byte block which is used from the long.
-	 * 
+	 *
 	 * @param value
 	 *            Byte to encode
 	 * @param position
@@ -1487,7 +1495,7 @@
 	/**
 	 * Returns &lt;code&gt;true&lt;/code&gt; if the waypoint should appear in the cache list, &lt;code&gt;false&lt;/code&gt; if it should not appear.&lt;br&gt;
 	 * The method takes into account blacklist, filters, search results - everything that determines if a cache is visible in the list or not.
-	 * 
+	 *
 	 * @return
 	 */
 	public boolean isVisible() {
@@ -1518,7 +1526,7 @@
 
 	/**
 	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the last call of the method, the same (cached) object is returned. If the object is null or the level is different, a new object is created.&lt;br&gt;
-	 * 
+	 *
 	 * @param level
 	 *            4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
 	 * @param fm
@@ -1626,7 +1634,7 @@
 
 	/**
 	 * Gets the type of cache as integer.
-	 * 
+	 *
 	 * @return Cache type
 	 */
 	public byte getType() {
@@ -1635,7 +1643,7 @@
 
 	/**
 	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf and byte internally of CacheHolder, some conversion has to be done.
-	 * 
+	 *
 	 * @param typeId
 	 *            Cache Type
 	 */
@@ -1698,7 +1706,7 @@
 	/**
 	 * If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal filter settings apply.&lt;br&gt;
 	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
-	 * 
+	 *
 	 * @return &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
 	 */
 	public boolean showAddis() {
@@ -1708,7 +1716,7 @@
 	/**
 	 * Setter for &lt;code&gt;showAddis()&lt;/code&gt;. If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal filter settings apply.&lt;br&gt;
 	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
-	 * 
+	 *
 	 * @param value
 	 *            &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
 	 */
@@ -1748,7 +1756,7 @@
 	 * &lt;/ul&gt;
 	 * The new method for deciding if a cache is visible or not is &lt;code&gt;isVisible()
 	 * &lt;/code&gt;.
-	 * 
+	 *
 	 * @return &lt;code&gt;True&lt;/code&gt; if filter criteria are matched
 	 */
 	public boolean is_filtered() {
@@ -1835,7 +1843,7 @@
 	/**
 	 * Determines if the blacklist status is set for the cache. Do not use this method to check if the cache should be displayed. Use &lt;code&gt;isVisible()&lt;/code&gt; for this, which already does this (and other) checks.&lt;br&gt;
 	 * Only use this method if you really want to inform yourself about the black status of the cache!
-	 * 
+	 *
 	 * @return &lt;code&gt;true&lt;/code&gt; if he black status of the cache is set.
 	 */
 	public boolean is_black() {
@@ -1967,7 +1975,7 @@
 
 	/**
 	 * rename a waypoint and all its associated files
-	 * 
+	 *
 	 * @param newWptId
 	 *            new waypoint id (will be converted to upper case)
 	 * @return true on success, false on error

Modified: branches/r1.2/src/CacheWolf/CacheSize.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheSize.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/CacheSize.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1,578 +1,578 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
-
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
-package CacheWolf;
-
-/**
- * Handles all aspects of converting cache size information from
- * and to the various im- and exporters as well as for converting
- * legacy profiles to current standard
- */
-public final class CacheSize {
-
-	/*
-	 * internal representation of cache sizes in CacheHolder we just made them
-	 * up ;-)
-	 */
-	/** container size not chosen */
-	public static final byte CW_SIZE_NOTCHOSEN = 0;
-	/** container size other */
-	public static final byte CW_SIZE_OTHER = 1;
-	/** container size micro */
-	public static final byte CW_SIZE_MICRO = 2;
-	/* container size small */
-	public static final byte CW_SIZE_SMALL = 3;
-	/** container size regular */
-	public static final byte CW_SIZE_REGULAR = 4;
-	/** container size large */
-	public static final byte CW_SIZE_LARGE = 5;
-	/** container size very large */
-	public static final byte CW_SIZE_VERYLARGE = 6;
-	/** container size none */
-	public static final byte CW_SIZE_NONE = 7;
-	/** container size virtual */
-	public static final byte CW_SIZE_VIRTUAL = 8;
-	/** unparsable size or missing size information should throw IllegalArgumentExceptions when found */
-	public static final byte CW_SIZE_ERROR = -1;
-
-	/*
-	 * geocaching.com size strings as found by analyzing GPX files 
-	 * plus opencaching &amp; terracaching Very large + none
-	 */
-	public static final String GC_SIZE_MICRO = &quot;Micro&quot;;
-	public static final String GC_SIZE_SMALL = &quot;Small&quot;;
-	public static final String GC_SIZE_REGULAR = &quot;Regular&quot;;
-	public static final String GC_SIZE_LARGE = &quot;Large&quot;;
-	public static final String GC_SIZE_NOTCHOSEN = &quot;Not chosen&quot;;
-	public static final String GC_SIZE_OTHER = &quot;Other&quot;;
-	public static final String GC_SIZE_VIRTUAL = &quot;Virtual&quot;;
-	public static final String OCTC_SIZE_VERYLARGE = &quot;Very large&quot;;
-	public static final String OCTC_SIZE_NONE = &quot;None&quot;;
-
-	/*
-	 * OpenCaching Size IDs see
-	 * <A HREF="http://oc-server.svn.sourceforge.net/viewvc/oc-server/doc/sql/static-data/data.sql?view=markup">http://oc-server.svn.sourceforge.net/viewvc/oc-server/doc/sql/static-data/data.sql?view=markup</A>
-	 */
-	public static final String OC_SIZE_OTHER = &quot;1&quot;;
-	public static final String OC_SIZE_MICRO = &quot;2&quot;;
-	public static final String OC_SIZE_SMALL = &quot;3&quot;;
-	public static final String OC_SIZE_NORMAL = &quot;4&quot;;
-	public static final String OC_SIZE_LARGE = &quot;5&quot;;
-	public static final String OC_SIZE_VERYLARGE = &quot;6&quot;;
-	public static final String OC_SIZE_NONE = &quot;7&quot;;
-
-	/*
-	 * TerraCaching Size IDs taken from old GPXimporter (?? reliable source ??)
-	 */
-	public static final String TC_SIZE_MICRO = &quot;1&quot;;
-	public static final String TC_SIZE_MEDIUM = &quot;2&quot;;
-	public static final String TC_SIZE_REGULAR = &quot;3&quot;;
-	public static final String TC_SIZE_LARGE = &quot;4&quot;;
-	public static final String TC_SIZE_VERYLARGE = &quot;4&quot;;
-
-	/*
-	 * images to show in CW index panel we use less images than sizes since all
-	 * non physical caches are represented by the same symbol
-	 */
-	/** GUI image for micro caches */
-	public static final String CW_GUIIMG_MICRO = &quot;sizeMicro.png&quot;;
-	/** GUI image for small caches */
-	public static final String CW_GUIIMG_SMALL = &quot;sizeSmall.png&quot;;
-	/** GUI image for regular / normal caches */
-	public static final String CW_GUIIMG_NORMAL = &quot;sizeReg.png&quot;;
-	/** GUI image for large caches */
-	public static final String CW_GUIIMG_LARGE = &quot;sizeLarge.png&quot;;
-	/** GUI image for non physical caches */
-	public static final String CW_GUIIMG_NONPHYSICAL = &quot;sizeNonPhysical.png&quot;;
-	/** GUI image for very large caches */
-	public static final String CW_GUIIMG_VERYLARGE = &quot;sizeVLarge.png&quot;;
-
-	/*
-	 * IDs for the sizePics[] array in TableModel therefore they must start with
-	 * 0 and be consecutive
-	 */
-	public static final byte CW_GUIIMGID_MICRO = 0;
-	public static final byte CW_GUIIMGID_SMALL = 1;
-	public static final byte CW_GUIIMGID_NORMAL = 2;
-	public static final byte CW_GUIIMGID_LARGE = 3;
-	public static final byte CW_GUIIMGID_NONPHYSICAL = 4;
-	public static final byte CW_GUIIMGID_VERYLARGE = 5;
-
-	/*
-	 * total number of different size images will be used to set the dimension
-	 * of sizePics[] array in TableModel
-	 */
-	public static final byte CW_TOTAL_SIZE_IMAGES = 6;
-
-	/*
-	 * bit masks to be used with the filter function
-	 */
-	public static final byte CW_FILTER_MICRO = 0x01 &lt;&lt; 0;
-	public static final byte CW_FILTER_SMALL = 0x01 &lt;&lt; 1;
-	public static final byte CW_FILTER_NORMAL = 0x01 &lt;&lt; 2;
-	public static final byte CW_FILTER_LARGE = 0x01 &lt;&lt; 3;
-	public static final byte CW_FILTER_VERYLARGE = 0x01 &lt;&lt; 4;
-	public static final byte CW_FILTER_NONPHYSICAL = 0x01 &lt;&lt; 5;
-	public static final byte CW_FILTER_ALL = CW_FILTER_MICRO
-			| CW_FILTER_SMALL | CW_FILTER_NORMAL | CW_FILTER_LARGE
-			| CW_FILTER_NONPHYSICAL | CW_FILTER_VERYLARGE;
-	
-	/** thou shallst not instantiate this object */
-	private CacheSize() { // Nothing to do
-	}
-
-	
-	/**
-	 * map filenames of images for the different sizes to the ids used array
-	 * index for sizePics[] in TableModel
-	 * 
-	 * @param size
-	 *            size identifier matching the CW_GUIIMGID_ constants
-	 * @return filename of image to be displayed for id
-	 * @throws IllegalArgumentException
-	 *             if there is no image associated to the &lt;code&gt;id&lt;/code&gt;
-	 */
-	public static String sizeImageForId(final byte size) throws IllegalArgumentException {
-		switch (size) {
-			case CW_GUIIMGID_MICRO:
-				return CW_GUIIMG_MICRO;
-			case CW_GUIIMGID_SMALL:
-				return CW_GUIIMG_SMALL;
-			case CW_GUIIMGID_NORMAL:
-				return CW_GUIIMG_NORMAL;
-			case CW_GUIIMGID_LARGE:
-				return CW_GUIIMG_LARGE;
-			case CW_GUIIMGID_NONPHYSICAL:
-				return CW_GUIIMG_NONPHYSICAL;
-			case CW_GUIIMGID_VERYLARGE:
-				return CW_GUIIMG_VERYLARGE;
-			default:
-				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize cw2ExportString()&quot;));
-		}
-	}
-
-	/**
-	 * convert the size info from a CacheHolder to a string suitable for GPX
-	 * export
-	 * 
-	 * @param size
-	 *            CW internal representation of cache size
-	 * @return string representation of CacheWolf internal cache size
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;cwsize&lt;/code&gt; can not be mapped to a CW_SIZE constant
-	 */
-	public static String cw2ExportString(final byte size) throws IllegalArgumentException {
-		switch (size) {
-			case CW_SIZE_MICRO:
-				return GC_SIZE_MICRO;
-			case CW_SIZE_SMALL:
-				return GC_SIZE_SMALL;
-			case CW_SIZE_REGULAR:
-				return GC_SIZE_REGULAR;
-			case CW_SIZE_LARGE:
-				return GC_SIZE_LARGE;
-			case CW_SIZE_NOTCHOSEN:
-				return GC_SIZE_NOTCHOSEN;
-			case CW_SIZE_OTHER:
-				return GC_SIZE_OTHER;
-			case CW_SIZE_VIRTUAL:
-				return GC_SIZE_VIRTUAL;
-			case CW_SIZE_VERYLARGE:
-				return OCTC_SIZE_VERYLARGE;
-			case CW_SIZE_NONE:
-				return OCTC_SIZE_NONE;
-			default:
-				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize cw2ExportString()&quot;));
-		}
-	}
-
-	/**
-	 * convert the cache size information from a TerraCaching GPX import to
-	 * internal representation
-	 * 
-	 * @param tcstring
-	 *            size information extracted from a TC GPX import
-	 * @return CacheWolf internal representation of size information
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;tcstring&lt;/code&gt; can not be mapped to internal representation
-	 *             (CW_SIZE_*)
-	 */
-
-	public static byte tcGpxString2Cw(final String tcstring) throws IllegalArgumentException {
-		if (tcstring.equals(TC_SIZE_MICRO)) {
-			return CW_SIZE_MICRO;
-		} else if (tcstring.equals(TC_SIZE_MEDIUM)) {
-			return CW_SIZE_SMALL;
-		} else if (tcstring.equals(TC_SIZE_REGULAR)) {
-			return CW_SIZE_REGULAR;
-		} else if (tcstring.equals(TC_SIZE_LARGE)) {
-			return CW_SIZE_LARGE;
-		} else if (tcstring.equals(TC_SIZE_VERYLARGE)) {
-			return CW_SIZE_VERYLARGE;
-		} else {
-			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + tcstring + &quot; in CacheSize tcGpxString2Cw()&quot;));
-		}
-	}
-
-	/**
-	 * convert the cache size information from a GC GPX import to internal
-	 * representation
-	 * 
-	 * @param gcstring
-	 *            size information extracted from a GPX import
-	 * @return CacheWolf internal representation of size information
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;gcstring&lt;/code&gt; can not be mapped to internal representation
-	 *             (CW_SIZE_*)
-	 */
-
-	public static byte gcGpxString2Cw(final String gcstring) throws IllegalArgumentException {
-		if (gcstring.equalsIgnoreCase(GC_SIZE_MICRO)) {
-			return CW_SIZE_MICRO;
-		} else if (gcstring.equalsIgnoreCase(GC_SIZE_SMALL)) {
-			return CW_SIZE_SMALL;
-		} else if (gcstring.equalsIgnoreCase(GC_SIZE_REGULAR)) {
-			return CW_SIZE_REGULAR;
-		} else if (gcstring.equalsIgnoreCase(GC_SIZE_LARGE)) {
-			return CW_SIZE_LARGE;
-		} else if (gcstring.equalsIgnoreCase(GC_SIZE_NOTCHOSEN)) {
-			return CW_SIZE_NOTCHOSEN;
-		} else if (gcstring.equalsIgnoreCase(GC_SIZE_OTHER)) {
-			return CW_SIZE_OTHER;
-		} else if (gcstring.equalsIgnoreCase(GC_SIZE_VIRTUAL)) {
-			return CW_SIZE_VIRTUAL;
-		// GSAK exports wrong type information
-		} else if (gcstring.equalsIgnoreCase(&quot;Unknown&quot;)) {
-			return CW_SIZE_NOTCHOSEN;
-		} else if (gcstring.equalsIgnoreCase(&quot;not_chosen&quot;)) {
-			return CW_SIZE_NOTCHOSEN;
-		} else {
-			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + gcstring + &quot; in CacheSize gcGpxString2Cw()&quot;));
-		}
-	}
-
-	/**
-	 * convert the cache size information from GCSpider to internal
-	 * representation for CacheHolder
-	 * 
-	 * @param spiderstring
-	 *            string identified by the spider as containing size information
-	 * @return CacheWolf internal representation of size information
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;spiderstring&lt;/code&gt; can not be mapped to internal representation
-	 *             (CW_SIZE_*)
-	 */
-	public static byte gcSpiderString2Cw(final String spiderstring) throws IllegalArgumentException {
-		// at the moment both sources use the same strings
-		return gcGpxString2Cw(spiderstring);
-	}
-
-	/**
-	 * map information from an Opencaching XML cache description suitable for
-	 * CacheHolder
-	 * 
-	 * @param ocxmlstring
-	 *            string extracted from OC-XML attribute size
-	 * @return CacheWolf internal representation of size information
-	 * @trows IllegalArgumentException if &lt;code&gt;ocxmlstring&lt;/code&gt; can not be mapped to a
-	 *        CW_SIZE_*
-	 */
-	public static byte ocXmlString2Cw(final String ocxmlstring) throws IllegalArgumentException {
-		if (ocxmlstring.equals(OC_SIZE_OTHER)) {
-			return CW_SIZE_OTHER;
-		} else if (ocxmlstring.equals(OC_SIZE_MICRO)) {
-			return CW_SIZE_MICRO;
-		} else if (ocxmlstring.equals(OC_SIZE_SMALL)) {
-			return CW_SIZE_SMALL;
-		} else if (ocxmlstring.equals(OC_SIZE_NORMAL)) {
-			return CW_SIZE_REGULAR;
-		} else if (ocxmlstring.equals(OC_SIZE_LARGE)) {
-			return CW_SIZE_LARGE;
-		} else if (ocxmlstring.equals(OC_SIZE_VERYLARGE)) {
-			return CW_SIZE_VERYLARGE;
-		} else if (ocxmlstring.equals(OC_SIZE_NONE)) {
-			return CW_SIZE_NOTCHOSEN;
-		} else {
-			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + ocxmlstring + &quot; in CacheSize ocXmlString2Cw()&quot;));
-		}
-	}
-
-	/**
-	 * get name of the image to be displayed in CW index panel
-	 * 
-	 * @param size
-	 *            CW internal representation of cache size
-	 * @return filename of image to be displayed in main panel as size icon
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;size&lt;/code&gt; can not be mapped
-	 */
-	public static byte guiSizeImageId(final byte size) throws IllegalArgumentException {
-		switch (size) {
-			case CW_SIZE_MICRO:
-				return CW_GUIIMGID_MICRO;
-			case CW_SIZE_SMALL:
-				return CW_GUIIMGID_SMALL;
-			case CW_SIZE_REGULAR:
-				return CW_GUIIMGID_NORMAL;
-			case CW_SIZE_LARGE:
-				return CW_GUIIMGID_LARGE;
-			case CW_SIZE_NOTCHOSEN:
-				return CW_GUIIMGID_NONPHYSICAL;
-			case CW_SIZE_OTHER:
-				return CW_GUIIMGID_NONPHYSICAL;
-			case CW_SIZE_VIRTUAL:
-				return CW_GUIIMGID_NONPHYSICAL;
-			case CW_SIZE_VERYLARGE:
-				return CW_GUIIMGID_VERYLARGE;
-			case CW_SIZE_NONE:
-				return CW_GUIIMGID_NONPHYSICAL;
-			default:
-				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize guiSizeImage()&quot;));
-		}
-	}
-
-	/**
-	 * convert v1 style size string to the new internal representation
-	 * 
-	 * @param v1Size
-	 *            old size string
-	 * @return CW internal representation of cache size
-	 * @throws IllegalArgumentException if &lt;code&gt;v1Size&lt;/code&gt; can not be mapped
-	 * @deprecated remove once v1 file version compatibility is abandoned
-	 */
-	public static final byte v1Converter(final String v1Size) throws IllegalArgumentException {
-		if (v1Size.equals(GC_SIZE_MICRO)) {
-			return CW_SIZE_MICRO;
-		} else if (v1Size.equals(GC_SIZE_SMALL)) {
-			return CW_SIZE_SMALL;
-		} else if (v1Size.equals(GC_SIZE_REGULAR)) {
-			return CW_SIZE_REGULAR;
-		} else if (v1Size.equals(GC_SIZE_LARGE)) {
-			return CW_SIZE_LARGE;
-		} else if (v1Size.equalsIgnoreCase(GC_SIZE_NOTCHOSEN)) {
-			return CW_SIZE_NOTCHOSEN;
-		} else if (v1Size.equals(GC_SIZE_OTHER)) {
-			return CW_SIZE_OTHER;
-		} else if (v1Size.equals(GC_SIZE_VIRTUAL)) {
-			return CW_SIZE_VIRTUAL;
-		} else if (v1Size.equals(OCTC_SIZE_NONE)) {
-			return CW_SIZE_NONE;
-		} else if (v1Size.equals(OCTC_SIZE_VERYLARGE)) {
-			return CW_SIZE_VERYLARGE;
-		} else if (v1Size.equals(&quot;&quot;)) {
-			return CW_SIZE_NOTCHOSEN;
-		} else {
-			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + v1Size + &quot; in v1Converter()&quot;));
-		}
-	}
-	
-	/**
-	 * return a bit mask representing the caches size for use in the Filter
-	 * 
-	 * @param size
-	 *            CW internal representation of cache size
-	 * @return a bit mask for the filter function
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;size&lt;/code&gt; can not be mapped to a bit mask
-	 */
-	public static byte getFilterPattern(final byte size) throws IllegalArgumentException {
-		switch (size) {
-			case CW_SIZE_MICRO:
-				return CW_FILTER_MICRO;
-			case CW_SIZE_SMALL:
-				return CW_FILTER_SMALL;
-			case CW_SIZE_REGULAR:
-				return CW_FILTER_NORMAL;
-			case CW_SIZE_LARGE:
-				return CW_FILTER_LARGE;
-			case CW_SIZE_NOTCHOSEN:
-				return CW_FILTER_NONPHYSICAL;
-			case CW_SIZE_OTHER:
-				return CW_FILTER_NONPHYSICAL;
-			case CW_SIZE_VIRTUAL:
-				return CW_FILTER_NONPHYSICAL;
-			case CW_SIZE_VERYLARGE:
-				return CW_FILTER_VERYLARGE;
-			case CW_SIZE_NONE:
-				return CW_FILTER_NONPHYSICAL;
-			default:
-				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize getFilterPattern()&quot;));
-		}
-	}
-
-	/**
-	 * provides abbreviated representations of CacheSize for compact exporters
-	 * 
-	 * @param size
-	 *            CW internal representation of cache size
-	 * @return a one letter String for cache size
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;size&lt;/code&gt; can not be mapped
-	 */
-
-	public static String getExportShortId(final byte size) throws IllegalArgumentException {
-		switch (size) {
-			case CW_SIZE_MICRO:
-				return &quot;m&quot;;
-			case CW_SIZE_SMALL:
-				return &quot;s&quot;;
-			case CW_SIZE_REGULAR:
-				return &quot;r&quot;;
-			case CW_SIZE_LARGE:
-				return &quot;l&quot;;
-			case CW_SIZE_NOTCHOSEN:
-				return &quot;n&quot;;
-			case CW_SIZE_OTHER:
-				return &quot;n&quot;;
-			case CW_SIZE_VIRTUAL:
-				return &quot;n&quot;;
-			case CW_SIZE_VERYLARGE:
-				return &quot;v&quot;;
-			case CW_SIZE_NONE:
-				return &quot;n&quot;;
-			default:
-				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize getExportShortId()&quot;));
-		}
-	}
-
-	/**
-	 * generate a string array suitable to be used in DetalsPanel drop down list
-	 * 
-	 * @return strings to be displayed in the DetailsPanel Size DropDown
-	 * @see guiSizeStrings2CwSize
-	 * @see cwSizeId2GuiSizeId
-	 */
-	public static String[] guiSizeStrings() {
-		// make sure strings appear in ascending order for CW_SIZE_*
-		final String ret[] = new String[] { 
-				GC_SIZE_NOTCHOSEN, 
-				GC_SIZE_OTHER,
-				GC_SIZE_MICRO, 
-				GC_SIZE_SMALL, 
-				GC_SIZE_REGULAR, 
-				GC_SIZE_LARGE,
-				OCTC_SIZE_VERYLARGE, 
-				OCTC_SIZE_NONE, 
-				GC_SIZE_VIRTUAL 
-				};
-		return ret;
-	}
-
-	/**
-	 * map a string chosen from the DetailsPanel Size drop down list back to
-	 * internal representation
-	 * 
-	 * @param size string selected in the list
-	 * @return cw type information
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;id&lt;/code&gt; can not be mapped
-	 * @see cwSizeId2GuiSizeId
-	 * @see guiSizeStrings
-	 */
-	public static byte guiSizeStrings2CwSize(final String size) throws IllegalArgumentException {
-		// map the strings in guiSizeStrings() back to cw byte types
-		if (size.equals(GC_SIZE_NOTCHOSEN)) {
-			return CW_SIZE_NOTCHOSEN;
-		} else if (size.equals(GC_SIZE_OTHER)) {
-			return CW_SIZE_OTHER;
-		} else if (size.equals(GC_SIZE_SMALL)) {
-			return CW_SIZE_SMALL;
-		} else if (size.equals(GC_SIZE_REGULAR)) {
-			return CW_SIZE_REGULAR;
-		} else if (size.equals(GC_SIZE_LARGE)) {
-			return CW_SIZE_LARGE;
-		} else if (size.equals(OCTC_SIZE_VERYLARGE)) {
-			return CW_SIZE_VERYLARGE;
-		} else if (size.equals(OCTC_SIZE_NONE)) {
-			return CW_SIZE_NONE;
-		} else if (size.equals(GC_SIZE_MICRO)) {
-			return CW_SIZE_MICRO;
-		} else if (size.equals(GC_SIZE_VIRTUAL)) {
-			return CW_SIZE_VIRTUAL;
-		} else {
-			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in guiSizeStrings2CwSize()&quot;));
-		}
-	}
-
-	/**
-	 * map internal representation to index used in the the DetailsPanel Size
-	 * drop down list
-	 * 
-	 * @param size
-	 *            internal id to be mapped
-	 * @return index of internal size in array
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;id&lt;/code&gt; can not be mapped
-	 * @see guiSizeStrings2CwSize
-	 * @see cwSizeId2GuiSizeId
-	 */
-	public static int cwSizeId2GuiSizeId(final byte size) throws IllegalArgumentException {
-		switch (size) {
-		case CW_SIZE_NOTCHOSEN:
-			return 0;
-		case CW_SIZE_OTHER:
-			return 1;
-		case CW_SIZE_MICRO:
-			return 2;
-		case CW_SIZE_SMALL:
-			return 3;
-		case CW_SIZE_REGULAR:
-			return 4;
-		case CW_SIZE_LARGE:
-			return 5;
-		case CW_SIZE_VERYLARGE:
-			return 6;
-		case CW_SIZE_NONE:
-			return 7;
-		case CW_SIZE_VIRTUAL:
-			return 8;
-		default:
-			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize ()&quot;));
-		}
-
-	}
-	
-	/**
-	 * checks if a given size information would be valid for use with CacheWolf.
-	 * takes about 1/20th of the time a try {} catch {} block would need, so use this
-	 * function if you just want to check
-	 * @param size size information to check
-	 * @return true if size is valid, false otherwise
-	 */
-	public static boolean isValidSize(final byte size) {
-		switch (size) {
-		case CW_SIZE_NOTCHOSEN: return true;
-		case CW_SIZE_OTHER: return true;
-		case CW_SIZE_MICRO: return true;
-		case CW_SIZE_SMALL: return true;
-		case CW_SIZE_REGULAR: return true;
-		case CW_SIZE_LARGE: return true;
-		case CW_SIZE_VERYLARGE: return true;
-		case CW_SIZE_NONE: return true;
-		case CW_SIZE_VIRTUAL: return true;
-		default: return false;
-		}
-	}
-}
+    /*
+    GNU General Public License
+    CacheWolf is a software for PocketPC, Win and Linux that
+    enables paperless caching.
+    It supports the sites geocaching.com and opencaching.de
+
+    Copyright (C) 2006  CacheWolf development team
+    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+    for more information.
+    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+package CacheWolf;
+
+/**
+ * Handles all aspects of converting cache size information from
+ * and to the various im- and exporters as well as for converting
+ * legacy profiles to current standard
+ */
+public final class CacheSize {
+
+	/*
+	 * internal representation of cache sizes in CacheHolder we just made them
+	 * up ;-)
+	 */
+	/** container size not chosen */
+	public static final byte CW_SIZE_NOTCHOSEN = 0;
+	/** container size other */
+	public static final byte CW_SIZE_OTHER = 1;
+	/** container size micro */
+	public static final byte CW_SIZE_MICRO = 2;
+	/* container size small */
+	public static final byte CW_SIZE_SMALL = 3;
+	/** container size regular */
+	public static final byte CW_SIZE_REGULAR = 4;
+	/** container size large */
+	public static final byte CW_SIZE_LARGE = 5;
+	/** container size very large */
+	public static final byte CW_SIZE_VERYLARGE = 6;
+	/** container size none */
+	public static final byte CW_SIZE_NONE = 7;
+	/** container size virtual */
+	public static final byte CW_SIZE_VIRTUAL = 8;
+	/** unparsable size or missing size information should throw IllegalArgumentExceptions when found */
+	public static final byte CW_SIZE_ERROR = -1;
+
+	/*
+	 * geocaching.com size strings as found by analyzing GPX files 
+	 * plus opencaching &amp; terracaching Very large + none
+	 */
+	public static final String GC_SIZE_MICRO = &quot;Micro&quot;;
+	public static final String GC_SIZE_SMALL = &quot;Small&quot;;
+	public static final String GC_SIZE_REGULAR = &quot;Regular&quot;;
+	public static final String GC_SIZE_LARGE = &quot;Large&quot;;
+	public static final String GC_SIZE_NOTCHOSEN = &quot;Not chosen&quot;;
+	public static final String GC_SIZE_OTHER = &quot;Other&quot;;
+	public static final String GC_SIZE_VIRTUAL = &quot;Virtual&quot;;
+	public static final String OCTC_SIZE_VERYLARGE = &quot;Very large&quot;;
+	public static final String OCTC_SIZE_NONE = &quot;None&quot;;
+
+	/*
+	 * OpenCaching Size IDs see
+	 * <A HREF="http://oc-server.svn.sourceforge.net/viewvc/oc-server/doc/sql/static-data/data.sql?view=markup">http://oc-server.svn.sourceforge.net/viewvc/oc-server/doc/sql/static-data/data.sql?view=markup</A>
+	 */
+	public static final String OC_SIZE_OTHER = &quot;1&quot;;
+	public static final String OC_SIZE_MICRO = &quot;2&quot;;
+	public static final String OC_SIZE_SMALL = &quot;3&quot;;
+	public static final String OC_SIZE_NORMAL = &quot;4&quot;;
+	public static final String OC_SIZE_LARGE = &quot;5&quot;;
+	public static final String OC_SIZE_VERYLARGE = &quot;6&quot;;
+	public static final String OC_SIZE_NONE = &quot;7&quot;;
+
+	/*
+	 * TerraCaching Size IDs taken from old GPXimporter (?? reliable source ??)
+	 */
+	public static final String TC_SIZE_MICRO = &quot;1&quot;;
+	public static final String TC_SIZE_MEDIUM = &quot;2&quot;;
+	public static final String TC_SIZE_REGULAR = &quot;3&quot;;
+	public static final String TC_SIZE_LARGE = &quot;4&quot;;
+	public static final String TC_SIZE_VERYLARGE = &quot;4&quot;;
+
+	/*
+	 * images to show in CW index panel we use less images than sizes since all
+	 * non physical caches are represented by the same symbol
+	 */
+	/** GUI image for micro caches */
+	public static final String CW_GUIIMG_MICRO = &quot;sizeMicro.png&quot;;
+	/** GUI image for small caches */
+	public static final String CW_GUIIMG_SMALL = &quot;sizeSmall.png&quot;;
+	/** GUI image for regular / normal caches */
+	public static final String CW_GUIIMG_NORMAL = &quot;sizeReg.png&quot;;
+	/** GUI image for large caches */
+	public static final String CW_GUIIMG_LARGE = &quot;sizeLarge.png&quot;;
+	/** GUI image for non physical caches */
+	public static final String CW_GUIIMG_NONPHYSICAL = &quot;sizeNonPhysical.png&quot;;
+	/** GUI image for very large caches */
+	public static final String CW_GUIIMG_VERYLARGE = &quot;sizeVLarge.png&quot;;
+
+	/*
+	 * IDs for the sizePics[] array in TableModel therefore they must start with
+	 * 0 and be consecutive
+	 */
+	public static final byte CW_GUIIMGID_MICRO = 0;
+	public static final byte CW_GUIIMGID_SMALL = 1;
+	public static final byte CW_GUIIMGID_NORMAL = 2;
+	public static final byte CW_GUIIMGID_LARGE = 3;
+	public static final byte CW_GUIIMGID_NONPHYSICAL = 4;
+	public static final byte CW_GUIIMGID_VERYLARGE = 5;
+
+	/*
+	 * total number of different size images will be used to set the dimension
+	 * of sizePics[] array in TableModel
+	 */
+	public static final byte CW_TOTAL_SIZE_IMAGES = 6;
+
+	/*
+	 * bit masks to be used with the filter function
+	 */
+	public static final byte CW_FILTER_MICRO = 0x01 &lt;&lt; 0;
+	public static final byte CW_FILTER_SMALL = 0x01 &lt;&lt; 1;
+	public static final byte CW_FILTER_NORMAL = 0x01 &lt;&lt; 2;
+	public static final byte CW_FILTER_LARGE = 0x01 &lt;&lt; 3;
+	public static final byte CW_FILTER_VERYLARGE = 0x01 &lt;&lt; 4;
+	public static final byte CW_FILTER_NONPHYSICAL = 0x01 &lt;&lt; 5;
+	public static final byte CW_FILTER_ALL = CW_FILTER_MICRO
+			| CW_FILTER_SMALL | CW_FILTER_NORMAL | CW_FILTER_LARGE
+			| CW_FILTER_NONPHYSICAL | CW_FILTER_VERYLARGE;
+	
+	/** thou shallst not instantiate this object */
+	private CacheSize() { // Nothing to do
+	}
+
+	
+	/**
+	 * map filenames of images for the different sizes to the ids used array
+	 * index for sizePics[] in TableModel
+	 * 
+	 * @param size
+	 *            size identifier matching the CW_GUIIMGID_ constants
+	 * @return filename of image to be displayed for id
+	 * @throws IllegalArgumentException
+	 *             if there is no image associated to the &lt;code&gt;id&lt;/code&gt;
+	 */
+	public static String sizeImageForId(final byte size) throws IllegalArgumentException {
+		switch (size) {
+			case CW_GUIIMGID_MICRO:
+				return CW_GUIIMG_MICRO;
+			case CW_GUIIMGID_SMALL:
+				return CW_GUIIMG_SMALL;
+			case CW_GUIIMGID_NORMAL:
+				return CW_GUIIMG_NORMAL;
+			case CW_GUIIMGID_LARGE:
+				return CW_GUIIMG_LARGE;
+			case CW_GUIIMGID_NONPHYSICAL:
+				return CW_GUIIMG_NONPHYSICAL;
+			case CW_GUIIMGID_VERYLARGE:
+				return CW_GUIIMG_VERYLARGE;
+			default:
+				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize cw2ExportString()&quot;));
+		}
+	}
+
+	/**
+	 * convert the size info from a CacheHolder to a string suitable for GPX
+	 * export
+	 * 
+	 * @param size
+	 *            CW internal representation of cache size
+	 * @return string representation of CacheWolf internal cache size
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;cwsize&lt;/code&gt; can not be mapped to a CW_SIZE constant
+	 */
+	public static String cw2ExportString(final byte size) throws IllegalArgumentException {
+		switch (size) {
+			case CW_SIZE_MICRO:
+				return GC_SIZE_MICRO;
+			case CW_SIZE_SMALL:
+				return GC_SIZE_SMALL;
+			case CW_SIZE_REGULAR:
+				return GC_SIZE_REGULAR;
+			case CW_SIZE_LARGE:
+				return GC_SIZE_LARGE;
+			case CW_SIZE_NOTCHOSEN:
+				return GC_SIZE_NOTCHOSEN;
+			case CW_SIZE_OTHER:
+				return GC_SIZE_OTHER;
+			case CW_SIZE_VIRTUAL:
+				return GC_SIZE_VIRTUAL;
+			case CW_SIZE_VERYLARGE:
+				return OCTC_SIZE_VERYLARGE;
+			case CW_SIZE_NONE:
+				return OCTC_SIZE_NONE;
+			default:
+				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize cw2ExportString()&quot;));
+		}
+	}
+
+	/**
+	 * convert the cache size information from a TerraCaching GPX import to
+	 * internal representation
+	 * 
+	 * @param tcstring
+	 *            size information extracted from a TC GPX import
+	 * @return CacheWolf internal representation of size information
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;tcstring&lt;/code&gt; can not be mapped to internal representation
+	 *             (CW_SIZE_*)
+	 */
+
+	public static byte tcGpxString2Cw(final String tcstring) throws IllegalArgumentException {
+		if (tcstring.equals(TC_SIZE_MICRO)) {
+			return CW_SIZE_MICRO;
+		} else if (tcstring.equals(TC_SIZE_MEDIUM)) {
+			return CW_SIZE_SMALL;
+		} else if (tcstring.equals(TC_SIZE_REGULAR)) {
+			return CW_SIZE_REGULAR;
+		} else if (tcstring.equals(TC_SIZE_LARGE)) {
+			return CW_SIZE_LARGE;
+		} else if (tcstring.equals(TC_SIZE_VERYLARGE)) {
+			return CW_SIZE_VERYLARGE;
+		} else {
+			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + tcstring + &quot; in CacheSize tcGpxString2Cw()&quot;));
+		}
+	}
+
+	/**
+	 * convert the cache size information from a GC GPX import to internal
+	 * representation
+	 * 
+	 * @param gcstring
+	 *            size information extracted from a GPX import
+	 * @return CacheWolf internal representation of size information
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;gcstring&lt;/code&gt; can not be mapped to internal representation
+	 *             (CW_SIZE_*)
+	 */
+
+	public static byte gcGpxString2Cw(final String gcstring) throws IllegalArgumentException {
+		if (gcstring.equalsIgnoreCase(GC_SIZE_MICRO)) {
+			return CW_SIZE_MICRO;
+		} else if (gcstring.equalsIgnoreCase(GC_SIZE_SMALL)) {
+			return CW_SIZE_SMALL;
+		} else if (gcstring.equalsIgnoreCase(GC_SIZE_REGULAR)) {
+			return CW_SIZE_REGULAR;
+		} else if (gcstring.equalsIgnoreCase(GC_SIZE_LARGE)) {
+			return CW_SIZE_LARGE;
+		} else if (gcstring.equalsIgnoreCase(GC_SIZE_NOTCHOSEN)) {
+			return CW_SIZE_NOTCHOSEN;
+		} else if (gcstring.equalsIgnoreCase(GC_SIZE_OTHER)) {
+			return CW_SIZE_OTHER;
+		} else if (gcstring.equalsIgnoreCase(GC_SIZE_VIRTUAL)) {
+			return CW_SIZE_VIRTUAL;
+		// GSAK exports wrong type information
+		} else if (gcstring.equalsIgnoreCase(&quot;Unknown&quot;)) {
+			return CW_SIZE_NOTCHOSEN;
+		} else if (gcstring.equalsIgnoreCase(&quot;not_chosen&quot;)) {
+			return CW_SIZE_NOTCHOSEN;
+		} else {
+			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + gcstring + &quot; in CacheSize gcGpxString2Cw()&quot;));
+		}
+	}
+
+	/**
+	 * convert the cache size information from GCSpider to internal
+	 * representation for CacheHolder
+	 * 
+	 * @param spiderstring
+	 *            string identified by the spider as containing size information
+	 * @return CacheWolf internal representation of size information
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;spiderstring&lt;/code&gt; can not be mapped to internal representation
+	 *             (CW_SIZE_*)
+	 */
+	public static byte gcSpiderString2Cw(final String spiderstring) throws IllegalArgumentException {
+		// at the moment both sources use the same strings
+		return gcGpxString2Cw(spiderstring);
+	}
+
+	/**
+	 * map information from an Opencaching XML cache description suitable for
+	 * CacheHolder
+	 * 
+	 * @param ocxmlstring
+	 *            string extracted from OC-XML attribute size
+	 * @return CacheWolf internal representation of size information
+	 * @trows IllegalArgumentException if &lt;code&gt;ocxmlstring&lt;/code&gt; can not be mapped to a
+	 *        CW_SIZE_*
+	 */
+	public static byte ocXmlString2Cw(final String ocxmlstring) throws IllegalArgumentException {
+		if (ocxmlstring.equals(OC_SIZE_OTHER)) {
+			return CW_SIZE_OTHER;
+		} else if (ocxmlstring.equals(OC_SIZE_MICRO)) {
+			return CW_SIZE_MICRO;
+		} else if (ocxmlstring.equals(OC_SIZE_SMALL)) {
+			return CW_SIZE_SMALL;
+		} else if (ocxmlstring.equals(OC_SIZE_NORMAL)) {
+			return CW_SIZE_REGULAR;
+		} else if (ocxmlstring.equals(OC_SIZE_LARGE)) {
+			return CW_SIZE_LARGE;
+		} else if (ocxmlstring.equals(OC_SIZE_VERYLARGE)) {
+			return CW_SIZE_VERYLARGE;
+		} else if (ocxmlstring.equals(OC_SIZE_NONE)) {
+			return CW_SIZE_NOTCHOSEN;
+		} else {
+			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + ocxmlstring + &quot; in CacheSize ocXmlString2Cw()&quot;));
+		}
+	}
+
+	/**
+	 * get name of the image to be displayed in CW index panel
+	 * 
+	 * @param size
+	 *            CW internal representation of cache size
+	 * @return filename of image to be displayed in main panel as size icon
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;size&lt;/code&gt; can not be mapped
+	 */
+	public static byte guiSizeImageId(final byte size) throws IllegalArgumentException {
+		switch (size) {
+			case CW_SIZE_MICRO:
+				return CW_GUIIMGID_MICRO;
+			case CW_SIZE_SMALL:
+				return CW_GUIIMGID_SMALL;
+			case CW_SIZE_REGULAR:
+				return CW_GUIIMGID_NORMAL;
+			case CW_SIZE_LARGE:
+				return CW_GUIIMGID_LARGE;
+			case CW_SIZE_NOTCHOSEN:
+				return CW_GUIIMGID_NONPHYSICAL;
+			case CW_SIZE_OTHER:
+				return CW_GUIIMGID_NONPHYSICAL;
+			case CW_SIZE_VIRTUAL:
+				return CW_GUIIMGID_NONPHYSICAL;
+			case CW_SIZE_VERYLARGE:
+				return CW_GUIIMGID_VERYLARGE;
+			case CW_SIZE_NONE:
+				return CW_GUIIMGID_NONPHYSICAL;
+			default:
+				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize guiSizeImage()&quot;));
+		}
+	}
+
+	/**
+	 * convert v1 style size string to the new internal representation
+	 * 
+	 * @param v1Size
+	 *            old size string
+	 * @return CW internal representation of cache size
+	 * @throws IllegalArgumentException if &lt;code&gt;v1Size&lt;/code&gt; can not be mapped
+	 * @deprecated remove once v1 file version compatibility is abandoned
+	 */
+	public static final byte v1Converter(final String v1Size) throws IllegalArgumentException {
+		if (v1Size.equals(GC_SIZE_MICRO)) {
+			return CW_SIZE_MICRO;
+		} else if (v1Size.equals(GC_SIZE_SMALL)) {
+			return CW_SIZE_SMALL;
+		} else if (v1Size.equals(GC_SIZE_REGULAR)) {
+			return CW_SIZE_REGULAR;
+		} else if (v1Size.equals(GC_SIZE_LARGE)) {
+			return CW_SIZE_LARGE;
+		} else if (v1Size.equalsIgnoreCase(GC_SIZE_NOTCHOSEN)) {
+			return CW_SIZE_NOTCHOSEN;
+		} else if (v1Size.equals(GC_SIZE_OTHER)) {
+			return CW_SIZE_OTHER;
+		} else if (v1Size.equals(GC_SIZE_VIRTUAL)) {
+			return CW_SIZE_VIRTUAL;
+		} else if (v1Size.equals(OCTC_SIZE_NONE)) {
+			return CW_SIZE_NONE;
+		} else if (v1Size.equals(OCTC_SIZE_VERYLARGE)) {
+			return CW_SIZE_VERYLARGE;
+		} else if (v1Size.equals(&quot;&quot;)) {
+			return CW_SIZE_NOTCHOSEN;
+		} else {
+			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + v1Size + &quot; in v1Converter()&quot;));
+		}
+	}
+	
+	/**
+	 * return a bit mask representing the caches size for use in the Filter
+	 * 
+	 * @param size
+	 *            CW internal representation of cache size
+	 * @return a bit mask for the filter function
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;size&lt;/code&gt; can not be mapped to a bit mask
+	 */
+	public static byte getFilterPattern(final byte size) throws IllegalArgumentException {
+		switch (size) {
+			case CW_SIZE_MICRO:
+				return CW_FILTER_MICRO;
+			case CW_SIZE_SMALL:
+				return CW_FILTER_SMALL;
+			case CW_SIZE_REGULAR:
+				return CW_FILTER_NORMAL;
+			case CW_SIZE_LARGE:
+				return CW_FILTER_LARGE;
+			case CW_SIZE_NOTCHOSEN:
+				return CW_FILTER_NONPHYSICAL;
+			case CW_SIZE_OTHER:
+				return CW_FILTER_NONPHYSICAL;
+			case CW_SIZE_VIRTUAL:
+				return CW_FILTER_NONPHYSICAL;
+			case CW_SIZE_VERYLARGE:
+				return CW_FILTER_VERYLARGE;
+			case CW_SIZE_NONE:
+				return CW_FILTER_NONPHYSICAL;
+			default:
+				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize getFilterPattern()&quot;));
+		}
+	}
+
+	/**
+	 * provides abbreviated representations of CacheSize for compact exporters
+	 * 
+	 * @param size
+	 *            CW internal representation of cache size
+	 * @return a one letter String for cache size
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;size&lt;/code&gt; can not be mapped
+	 */
+
+	public static String getExportShortId(final byte size) throws IllegalArgumentException {
+		switch (size) {
+			case CW_SIZE_MICRO:
+				return &quot;m&quot;;
+			case CW_SIZE_SMALL:
+				return &quot;s&quot;;
+			case CW_SIZE_REGULAR:
+				return &quot;r&quot;;
+			case CW_SIZE_LARGE:
+				return &quot;l&quot;;
+			case CW_SIZE_NOTCHOSEN:
+				return &quot;n&quot;;
+			case CW_SIZE_OTHER:
+				return &quot;n&quot;;
+			case CW_SIZE_VIRTUAL:
+				return &quot;n&quot;;
+			case CW_SIZE_VERYLARGE:
+				return &quot;v&quot;;
+			case CW_SIZE_NONE:
+				return &quot;n&quot;;
+			default:
+				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize getExportShortId()&quot;));
+		}
+	}
+
+	/**
+	 * generate a string array suitable to be used in DetalsPanel drop down list
+	 * 
+	 * @return strings to be displayed in the DetailsPanel Size DropDown
+	 * @see guiSizeStrings2CwSize
+	 * @see cwSizeId2GuiSizeId
+	 */
+	public static String[] guiSizeStrings() {
+		// make sure strings appear in ascending order for CW_SIZE_*
+		final String ret[] = new String[] { 
+				GC_SIZE_NOTCHOSEN, 
+				GC_SIZE_OTHER,
+				GC_SIZE_MICRO, 
+				GC_SIZE_SMALL, 
+				GC_SIZE_REGULAR, 
+				GC_SIZE_LARGE,
+				OCTC_SIZE_VERYLARGE, 
+				OCTC_SIZE_NONE, 
+				GC_SIZE_VIRTUAL 
+				};
+		return ret;
+	}
+
+	/**
+	 * map a string chosen from the DetailsPanel Size drop down list back to
+	 * internal representation
+	 * 
+	 * @param size string selected in the list
+	 * @return cw type information
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;id&lt;/code&gt; can not be mapped
+	 * @see cwSizeId2GuiSizeId
+	 * @see guiSizeStrings
+	 */
+	public static byte guiSizeStrings2CwSize(final String size) throws IllegalArgumentException {
+		// map the strings in guiSizeStrings() back to cw byte types
+		if (size.equals(GC_SIZE_NOTCHOSEN)) {
+			return CW_SIZE_NOTCHOSEN;
+		} else if (size.equals(GC_SIZE_OTHER)) {
+			return CW_SIZE_OTHER;
+		} else if (size.equals(GC_SIZE_SMALL)) {
+			return CW_SIZE_SMALL;
+		} else if (size.equals(GC_SIZE_REGULAR)) {
+			return CW_SIZE_REGULAR;
+		} else if (size.equals(GC_SIZE_LARGE)) {
+			return CW_SIZE_LARGE;
+		} else if (size.equals(OCTC_SIZE_VERYLARGE)) {
+			return CW_SIZE_VERYLARGE;
+		} else if (size.equals(OCTC_SIZE_NONE)) {
+			return CW_SIZE_NONE;
+		} else if (size.equals(GC_SIZE_MICRO)) {
+			return CW_SIZE_MICRO;
+		} else if (size.equals(GC_SIZE_VIRTUAL)) {
+			return CW_SIZE_VIRTUAL;
+		} else {
+			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in guiSizeStrings2CwSize()&quot;));
+		}
+	}
+
+	/**
+	 * map internal representation to index used in the the DetailsPanel Size
+	 * drop down list
+	 * 
+	 * @param size
+	 *            internal id to be mapped
+	 * @return index of internal size in array
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;id&lt;/code&gt; can not be mapped
+	 * @see guiSizeStrings2CwSize
+	 * @see cwSizeId2GuiSizeId
+	 */
+	public static int cwSizeId2GuiSizeId(final byte size) throws IllegalArgumentException {
+		switch (size) {
+		case CW_SIZE_NOTCHOSEN:
+			return 0;
+		case CW_SIZE_OTHER:
+			return 1;
+		case CW_SIZE_MICRO:
+			return 2;
+		case CW_SIZE_SMALL:
+			return 3;
+		case CW_SIZE_REGULAR:
+			return 4;
+		case CW_SIZE_LARGE:
+			return 5;
+		case CW_SIZE_VERYLARGE:
+			return 6;
+		case CW_SIZE_NONE:
+			return 7;
+		case CW_SIZE_VIRTUAL:
+			return 8;
+		default:
+			throw (new IllegalArgumentException(&quot;unmatched argument &quot; + size + &quot; in CacheSize ()&quot;));
+		}
+
+	}
+	
+	/**
+	 * checks if a given size information would be valid for use with CacheWolf.
+	 * takes about 1/20th of the time a try {} catch {} block would need, so use this
+	 * function if you just want to check
+	 * @param size size information to check
+	 * @return true if size is valid, false otherwise
+	 */
+	public static boolean isValidSize(final byte size) {
+		switch (size) {
+		case CW_SIZE_NOTCHOSEN: return true;
+		case CW_SIZE_OTHER: return true;
+		case CW_SIZE_MICRO: return true;
+		case CW_SIZE_SMALL: return true;
+		case CW_SIZE_REGULAR: return true;
+		case CW_SIZE_LARGE: return true;
+		case CW_SIZE_VERYLARGE: return true;
+		case CW_SIZE_NONE: return true;
+		case CW_SIZE_VIRTUAL: return true;
+		default: return false;
+		}
+	}
+}

Modified: branches/r1.2/src/CacheWolf/CacheTerrDiff.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheTerrDiff.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/CacheTerrDiff.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1,159 +1,159 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
-
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
-package CacheWolf;
-
-/**
- * Handles all aspects of converting terrain and difficulty
- * informations from legacy file versions and various im-
- * and exporters
- * 
- * Only use the class in a static way, do not instantiate it
- */
-public final class CacheTerrDiff {
-	
-	/** terrain or difficulty 1.0 */
-	public static final byte CW_DT_10 = 10;
-	/** terrain or difficulty 1.5 */
-	public static final byte CW_DT_15 = 15;
-	/** terrain or difficulty 2.0 */
-	public static final byte CW_DT_20 = 20;
-	/** terrain or difficulty 2.5 */
-	public static final byte CW_DT_25 = 25;
-	/** terrain or difficulty 3.0 */
-	public static final byte CW_DT_30 = 30;
-	/** terrain or difficulty 3.5 */
-	public static final byte CW_DT_35 = 35;
-	/** terrain or difficulty 4.0 */
-	public static final byte CW_DT_40 = 40;
-	/** terrain or difficulty 4.5 */
-	public static final byte CW_DT_45 = 45;
-	/** terrain or difficulty 5.0 */
-	public static final byte CW_DT_50 = 50;
-	/** wrong terrain or difficulty */
-	public static final byte CW_DT_ERROR = -1;
-	/** terrain or difficulty for additional/custom waypoints */
-	public static final byte CW_DT_UNSET = 0;
-
-	private CacheTerrDiff() { 
-		// Nothing to do
-	}
-	
-	/**
-	 * convert &quot;old style&quot; terrain and difficulty information to the new format.
-	 * 
-	 * since it is also used by the importers it is not flagged as depreciated
-	 * @param v1TerrDiff a string representation of terrain or difficulty
-	 * @return internal representation of terrain or difficulty
-	 * @throws IllegalArgumentException if &lt;code&gt;v1TerrDiff&lt;/code&gt; can not be mapped
-	 */
-	public static byte v1Converter(String v1TerrDiff) throws IllegalArgumentException {
-		if (v1TerrDiff == null) {
-			throw new IllegalArgumentException(&quot;error mapping terrain or difficulty&quot;);
-		}
-		v1TerrDiff = v1TerrDiff.replace(',', '.');
-		if (v1TerrDiff.equals(&quot;1&quot;) || v1TerrDiff.equals(&quot;1.0&quot;)) { return CW_DT_10; }
-		if (v1TerrDiff.equals(&quot;2&quot;) || v1TerrDiff.equals(&quot;2.0&quot;)) { return CW_DT_20; }
-		if (v1TerrDiff.equals(&quot;3&quot;) || v1TerrDiff.equals(&quot;3.0&quot;)) { return CW_DT_30; }
-		if (v1TerrDiff.equals(&quot;4&quot;) || v1TerrDiff.equals(&quot;4.0&quot;)) { return CW_DT_40; }
-		if (v1TerrDiff.equals(&quot;5&quot;) || v1TerrDiff.equals(&quot;5.0&quot;)) { return CW_DT_50; }
-		
-		if (v1TerrDiff.equals(&quot;1.5&quot;)) { return CW_DT_15; }
-		if (v1TerrDiff.equals(&quot;2.5&quot;)) { return CW_DT_25; }
-		if (v1TerrDiff.equals(&quot;3.5&quot;)) { return CW_DT_35; }
-		if (v1TerrDiff.equals(&quot;4.5&quot;)) { return CW_DT_45; }
-		
-		if (v1TerrDiff.equals(&quot;-1&quot;)) { return CW_DT_UNSET; }
-		
-		throw new IllegalArgumentException(&quot;error mapping terrain or difficulty&quot;);
-	}
-	
-	/**
-	 * generate strings of terrain and difficulty for general use
-	 * @param terrdiff internal terrain or difficulty value
-	 * @return long version of terrain or difficulty (including .0)
-	 * @throws IllegalArgumentException
-	 */
-	public static String longDT(final byte terrdiff) throws IllegalArgumentException {
-		switch(terrdiff) {
-		case CW_DT_10: return &quot;1.0&quot;;
-		case CW_DT_15: return &quot;1.5&quot;;
-		case CW_DT_20: return &quot;2.0&quot;;
-		case CW_DT_25: return &quot;2.5&quot;;
-		case CW_DT_30: return &quot;3.0&quot;;
-		case CW_DT_35: return &quot;3.5&quot;;
-		case CW_DT_40: return &quot;4.0&quot;;
-		case CW_DT_45: return &quot;4.5&quot;;
-		case CW_DT_50: return &quot;5.0&quot;;
-		case CW_DT_UNSET: return &quot;-.-&quot;;
-		default: throw new IllegalArgumentException(&quot;unmapped terrain or diffulty &quot;+terrdiff);
-		}
-	}
-
-	/**
-	 * generate strings of terrain and difficulty information for GC.com-like GPX exports
-	 * @param terrdiff internal terrain or difficulty value
-	 * @return short version of terrain or difficulty (omit .0)
-	 * @throws IllegalArgumentException
-	 */
-	public static String shortDT(final byte terrdiff) throws IllegalArgumentException {
-		switch(terrdiff) {
-		case CW_DT_10: return &quot;1&quot;;
-		case CW_DT_15: return &quot;1.5&quot;;
-		case CW_DT_20: return &quot;2&quot;;
-		case CW_DT_25: return &quot;2.5&quot;;
-		case CW_DT_30: return &quot;3&quot;;
-		case CW_DT_35: return &quot;3.5&quot;;
-		case CW_DT_40: return &quot;4&quot;;
-		case CW_DT_45: return &quot;4.5&quot;;
-		case CW_DT_50: return &quot;5&quot;;
-		case CW_DT_UNSET: return &quot;-1&quot;;
-		default: throw new IllegalArgumentException(&quot;unmapped terrain or diffulty &quot;+terrdiff);
-		}
-	}
-	
-	/**
-	 * check if a given difficulty or terrain is valid
-	 * takes about 1/20th of the time a try {} catch{} block needs
-	 * so use this function instead
-	 * @param terrdiff terrain or difficulty to check
-	 * @return true if terrain or difficulty is valid, false otherwise
-	 */
-	public static boolean isValidTD(final byte terrdiff) {
-		switch (terrdiff) {
-		case CW_DT_10: return true;
-		case CW_DT_15: return true;
-		case CW_DT_20: return true;
-		case CW_DT_25: return true;
-		case CW_DT_30: return true;
-		case CW_DT_35: return true;
-		case CW_DT_40: return true;
-		case CW_DT_45: return true;
-		case CW_DT_50: return true;
-		case CW_DT_UNSET: return true;
-		default: return false;
-		}
-	}
-}
+    /*
+    GNU General Public License
+    CacheWolf is a software for PocketPC, Win and Linux that
+    enables paperless caching.
+    It supports the sites geocaching.com and opencaching.de
+
+    Copyright (C) 2006  CacheWolf development team
+    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+    for more information.
+    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+package CacheWolf;
+
+/**
+ * Handles all aspects of converting terrain and difficulty
+ * informations from legacy file versions and various im-
+ * and exporters
+ * 
+ * Only use the class in a static way, do not instantiate it
+ */
+public final class CacheTerrDiff {
+	
+	/** terrain or difficulty 1.0 */
+	public static final byte CW_DT_10 = 10;
+	/** terrain or difficulty 1.5 */
+	public static final byte CW_DT_15 = 15;
+	/** terrain or difficulty 2.0 */
+	public static final byte CW_DT_20 = 20;
+	/** terrain or difficulty 2.5 */
+	public static final byte CW_DT_25 = 25;
+	/** terrain or difficulty 3.0 */
+	public static final byte CW_DT_30 = 30;
+	/** terrain or difficulty 3.5 */
+	public static final byte CW_DT_35 = 35;
+	/** terrain or difficulty 4.0 */
+	public static final byte CW_DT_40 = 40;
+	/** terrain or difficulty 4.5 */
+	public static final byte CW_DT_45 = 45;
+	/** terrain or difficulty 5.0 */
+	public static final byte CW_DT_50 = 50;
+	/** wrong terrain or difficulty */
+	public static final byte CW_DT_ERROR = -1;
+	/** terrain or difficulty for additional/custom waypoints */
+	public static final byte CW_DT_UNSET = 0;
+
+	private CacheTerrDiff() { 
+		// Nothing to do
+	}
+	
+	/**
+	 * convert &quot;old style&quot; terrain and difficulty information to the new format.
+	 * 
+	 * since it is also used by the importers it is not flagged as depreciated
+	 * @param v1TerrDiff a string representation of terrain or difficulty
+	 * @return internal representation of terrain or difficulty
+	 * @throws IllegalArgumentException if &lt;code&gt;v1TerrDiff&lt;/code&gt; can not be mapped
+	 */
+	public static byte v1Converter(String v1TerrDiff) throws IllegalArgumentException {
+		if (v1TerrDiff == null) {
+			throw new IllegalArgumentException(&quot;error mapping terrain or difficulty&quot;);
+		}
+		v1TerrDiff = v1TerrDiff.replace(',', '.');
+		if (v1TerrDiff.equals(&quot;1&quot;) || v1TerrDiff.equals(&quot;1.0&quot;)) { return CW_DT_10; }
+		if (v1TerrDiff.equals(&quot;2&quot;) || v1TerrDiff.equals(&quot;2.0&quot;)) { return CW_DT_20; }
+		if (v1TerrDiff.equals(&quot;3&quot;) || v1TerrDiff.equals(&quot;3.0&quot;)) { return CW_DT_30; }
+		if (v1TerrDiff.equals(&quot;4&quot;) || v1TerrDiff.equals(&quot;4.0&quot;)) { return CW_DT_40; }
+		if (v1TerrDiff.equals(&quot;5&quot;) || v1TerrDiff.equals(&quot;5.0&quot;)) { return CW_DT_50; }
+		
+		if (v1TerrDiff.equals(&quot;1.5&quot;)) { return CW_DT_15; }
+		if (v1TerrDiff.equals(&quot;2.5&quot;)) { return CW_DT_25; }
+		if (v1TerrDiff.equals(&quot;3.5&quot;)) { return CW_DT_35; }
+		if (v1TerrDiff.equals(&quot;4.5&quot;)) { return CW_DT_45; }
+		
+		if (v1TerrDiff.equals(&quot;-1&quot;)) { return CW_DT_UNSET; }
+		
+		throw new IllegalArgumentException(&quot;error mapping terrain or difficulty&quot;);
+	}
+	
+	/**
+	 * generate strings of terrain and difficulty for general use
+	 * @param terrdiff internal terrain or difficulty value
+	 * @return long version of terrain or difficulty (including .0)
+	 * @throws IllegalArgumentException
+	 */
+	public static String longDT(final byte terrdiff) throws IllegalArgumentException {
+		switch(terrdiff) {
+		case CW_DT_10: return &quot;1.0&quot;;
+		case CW_DT_15: return &quot;1.5&quot;;
+		case CW_DT_20: return &quot;2.0&quot;;
+		case CW_DT_25: return &quot;2.5&quot;;
+		case CW_DT_30: return &quot;3.0&quot;;
+		case CW_DT_35: return &quot;3.5&quot;;
+		case CW_DT_40: return &quot;4.0&quot;;
+		case CW_DT_45: return &quot;4.5&quot;;
+		case CW_DT_50: return &quot;5.0&quot;;
+		case CW_DT_UNSET: return &quot;-.-&quot;;
+		default: throw new IllegalArgumentException(&quot;unmapped terrain or diffulty &quot;+terrdiff);
+		}
+	}
+
+	/**
+	 * generate strings of terrain and difficulty information for GC.com-like GPX exports
+	 * @param terrdiff internal terrain or difficulty value
+	 * @return short version of terrain or difficulty (omit .0)
+	 * @throws IllegalArgumentException
+	 */
+	public static String shortDT(final byte terrdiff) throws IllegalArgumentException {
+		switch(terrdiff) {
+		case CW_DT_10: return &quot;1&quot;;
+		case CW_DT_15: return &quot;1.5&quot;;
+		case CW_DT_20: return &quot;2&quot;;
+		case CW_DT_25: return &quot;2.5&quot;;
+		case CW_DT_30: return &quot;3&quot;;
+		case CW_DT_35: return &quot;3.5&quot;;
+		case CW_DT_40: return &quot;4&quot;;
+		case CW_DT_45: return &quot;4.5&quot;;
+		case CW_DT_50: return &quot;5&quot;;
+		case CW_DT_UNSET: return &quot;-1&quot;;
+		default: throw new IllegalArgumentException(&quot;unmapped terrain or diffulty &quot;+terrdiff);
+		}
+	}
+	
+	/**
+	 * check if a given difficulty or terrain is valid
+	 * takes about 1/20th of the time a try {} catch{} block needs
+	 * so use this function instead
+	 * @param terrdiff terrain or difficulty to check
+	 * @return true if terrain or difficulty is valid, false otherwise
+	 */
+	public static boolean isValidTD(final byte terrdiff) {
+		switch (terrdiff) {
+		case CW_DT_10: return true;
+		case CW_DT_15: return true;
+		case CW_DT_20: return true;
+		case CW_DT_25: return true;
+		case CW_DT_30: return true;
+		case CW_DT_35: return true;
+		case CW_DT_40: return true;
+		case CW_DT_45: return true;
+		case CW_DT_50: return true;
+		case CW_DT_UNSET: return true;
+		default: return false;
+		}
+	}
+}

Modified: branches/r1.2/src/CacheWolf/CacheType.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheType.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/CacheType.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1,604 +1,604 @@
-/*
-GNU General Public License
-CacheWolf is a software for PocketPC, Win and Linux that
-enables paperless caching.
-It supports the sites geocaching.com and opencaching.de
-
-Copyright (C) 2006  CacheWolf development team
-See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-for more information.
-Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; version 2 of the License.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-package CacheWolf;
-
-import ewe.fx.Image;
-
-final class CTyp {
-	public byte _cwMappedCType; // CW Cache Typ intern
-	public byte _cwCType; // CW Cache Typ intern
-	public char _cwCGroup; // Cache Typ Group intern
-	public String _cwCTypeV1; // V1 Cache Typ
-	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com
-	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com
-	public byte _cwCTypeV2; // V2 Cache Typ
-	public char _gpxShortCType; // Short Typ (one char abbreviation)
-	public String _imageName; // name of imageName for Icon, &quot;showCacheInBrowser&quot; and &quot;KML Export&quot;
-	public String _gpxWptTypeTag; // gpx wpt &lt;type&gt; tag
-	public String _gpxWptSymTag; // gpx wpt &lt;sym&gt; tag
-	public String _gpxWptGCextensionTypTag; // gpx cache extension &lt;groundspeak:type&gt; tag
-	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources
-	public int _msgNrCTypeName; // message number for gui cache Typ name
-	public int _GUIOrder; // sort Order in GUI selection //TODO more intelligent implementation (now manually change each line on new one)
-	public int _FilterStringPos; // BitNr in Filter String (profile)
-	public int _FilterPattern; // 2**BitNr in Filter int (does not correspond with BitNr in String)
-	public Image _iconImage;
-	public Image _mapImage;
-	public Image[] _modImage = { null, null, null, null, null, null, null };
-
-	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos,
-			int filterPattern) {
-
-		_cwMappedCType = cwMappedCType;
-		_cwCType = cwCType;
-		_cwCGroup = cwCGroup;
-		_cwCTypeV1 = cwCTypeV1;
-		_gcCTypeSpider = gcCTypeSpider;
-		_ocCTypeXmlImport = ocCTypeXmlImport;
-		_cwCTypeV2 = cwCTypeV2;
-		_gpxShortCType = gpxShortCType;
-		_imageName = imageName;
-		_gpxWptTypeTag = gpx[0];
-		_gpxWptSymTag = gpx[1];
-		_gpxWptGCextensionTypTag = gpx[2];
-		_gpxAlternativeWptTypTags = gpx[3];
-		_msgNrCTypeName = msgNrCTypeName;
-		_GUIOrder = gUIOrder;
-		_FilterStringPos = filterStringPos;
-		_FilterPattern = filterPattern;
-		if (!_imageName.equals(&quot;&quot;)) {
-			_iconImage = new Image(_imageName);
-			_mapImage = _iconImage;
-		}
-	}
-}
-
-/**
- * Handles all aspects of converting cache type information
- * from and to the various im- and exporters ...
- * converting legacy profiles to current standard
- *
- * Do not instantiate this class, only use it in a static way
- */
-public final class CacheType {
-
-	/** thou shallst not instantiate this object */
-	private CacheType() {
-		// Nothing to do
-	}
-
-	/** custom waypoint */
-	public static final byte CW_TYPE_CUSTOM = 0;
-	/** traditional cache (GC,OC) */
-	public static final byte CW_TYPE_TRADITIONAL = 2;
-	/** multi cache (GC,OC) */
-	public static final byte CW_TYPE_MULTI = 3;
-	/** virtual cache (GC,OC) */
-	public static final byte CW_TYPE_VIRTUAL = 4;
-	/** letterbox cache (GC) */
-	public static final byte CW_TYPE_LETTERBOX = 5;
-	/** event cache (GC,OC) */
-	public static final byte CW_TYPE_EVENT = 6;
-	/** unknown cache - Mystery (GC) */
-	public static final byte CW_TYPE_UNKNOWN = 8;
-	/** drive in cache (OC) */
-	public static final byte CW_TYPE_DRIVE_IN = 10;
-	/** webcam cache (GC,OC) */
-	public static final byte CW_TYPE_WEBCAM = 11;
-	/** locationless cache (GC) */
-	public static final byte CW_TYPE_LOCATIONLESS = 12;
-	/** CITO cache (GC) */
-	public static final byte CW_TYPE_CITO = 13;
-	/** Mega Event Cache (GC) */
-	public static final byte CW_TYPE_MEGA_EVENT = 100;
-	/** WhereIGo Cache (GC) */
-	public static final byte CW_TYPE_WHEREIGO = 101;
-	/** Earth Cache (GC) */
-	public static final byte CW_TYPE_EARTH = 104;
-	/** Additional Waypoint Parking (GC) */
-	public static final byte CW_TYPE_PARKING = 50;
-	/** Additional Waypoint Stage of a Multi (GC) */
-	public static final byte CW_TYPE_STAGE = 51;
-	/** Additional Waypoint Question to answer (GC) */
-	public static final byte CW_TYPE_QUESTION = 52;
-	/** Additional Waypoint Final (GC) */
-	public static final byte CW_TYPE_FINAL = 53;
-	/** Additional Waypoint Trailhead (GC) */
-	public static final byte CW_TYPE_TRAILHEAD = 54;
-	/** Additional Waypoint Reference (GC) */
-	public static final byte CW_TYPE_REFERENCE = 55;
-	/** unrecognized cache type or missing information */
-	public static final byte CW_TYPE_ERROR = -1;
-	String[] ggpx = { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; };
-	private static final byte found = 0;
-	private static final byte archived = 1;
-	private static final byte disabled = 2;
-	private static final byte solved = 3;
-	private static final byte bonus = 4;
-	private static final byte owned = 5;
-	private static final byte dnf = 6;
-	//
-	private static final CTyp[] cTypRef = {
-			// custom waypoints
-			new CTyp(CW_TYPE_CUSTOM, CW_TYPE_CUSTOM, 'P', &quot;0&quot;, &quot;&quot;, &quot;&quot;, (byte) -128, 'C', &quot;typeCustom.png&quot;, new String[] { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; }, 1, 0, 10, 0x000100),
-			// Cache waypoints
-			new CTyp(CW_TYPE_TRADITIONAL, CW_TYPE_TRADITIONAL, 'C', &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, (byte) -126, 'T', &quot;typeTradi.png&quot;, new String[] { &quot;Geocache|Traditional Cache&quot;, &quot;Geocache&quot;, &quot;Traditional Cache&quot;, &quot;Traditional|Classic&quot; }, 2, 1, 0, 0x000001),
-			new CTyp(CW_TYPE_MULTI, CW_TYPE_MULTI, 'C', &quot;3&quot;, &quot;3&quot;, &quot;3&quot;, (byte) -125, 'M', &quot;typeMulti.png&quot;, new String[] { &quot;Geocache|Multi-cache&quot;, &quot;Geocache&quot;, &quot;Multi-cache&quot;, &quot;Multi|Offset&quot; }, 3, 2, 1, 0x000002),
-			new CTyp(CW_TYPE_VIRTUAL, CW_TYPE_VIRTUAL, 'C', &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, (byte) -124, 'V', &quot;typeVirtual.png&quot;, new String[] { &quot;Geocache|Virtual Cache&quot;, &quot;Geocache&quot;, &quot;Virtual Cache&quot;, &quot;Virtual&quot; }, 4, 3, 2, 0x000004),
-			new CTyp(CW_TYPE_LETTERBOX, CW_TYPE_LETTERBOX, 'C', &quot;5&quot;, &quot;5&quot;, &quot;&quot;, (byte) -123, 'L', &quot;typeLetterbox.png&quot;, new String[] { &quot;Geocache|Letterbox Hybrid&quot;, &quot;Geocache&quot;, &quot;Letterbox Hybrid&quot;, &quot;Letterbox&quot; }, 5, 4, 3, 0x000008),
-			new CTyp(CW_TYPE_EVENT, CW_TYPE_EVENT, 'C', &quot;6&quot;, &quot;6&quot;, &quot;6&quot;, (byte) -122, 'X', &quot;typeEvent.png&quot;, new String[] { &quot;Geocache|Event Cache&quot;, &quot;Geocache&quot;, &quot;Event Cache&quot;, &quot;Event&quot; }, 6, 5, 4, 0x000010),
-			new CTyp(CW_TYPE_MEGA_EVENT, CW_TYPE_MEGA_EVENT, 'C', &quot;453&quot;, &quot;453&quot;, &quot;&quot;, (byte) 101, 'X', &quot;typeMegaevent.png&quot;, new String[] { &quot;Geocache|Mega-Event Cache&quot;, &quot;Geocache&quot;, &quot;Mega-Event Cache&quot;, &quot;Mega&quot; }, 14, 6, 9, 0x000200),
-			new CTyp(CW_TYPE_WEBCAM, CW_TYPE_WEBCAM, 'C', &quot;11&quot;, &quot;11&quot;, &quot;5&quot;, (byte) -117, 'W', &quot;typeWebcam.png&quot;, new String[] { &quot;Geocache|Webcam Cache&quot;, &quot;Geocache&quot;, &quot;Webcam Cache&quot;, &quot;Webcam&quot; }, 11, 7, 5, 0x000020),
-			new CTyp(CW_TYPE_UNKNOWN, CW_TYPE_UNKNOWN, 'C', &quot;8&quot;, &quot;8&quot;, &quot;&quot;, (byte) -120, 'U', &quot;typeUnknown.png&quot;, new String[] { &quot;Geocache|Unknown Cache&quot;, &quot;Geocache&quot;, &quot;Unknown Cache&quot;, &quot;Mystery&quot; }, 8, 8, 6, 0x000040),
-			new CTyp(CW_TYPE_LOCATIONLESS, CW_TYPE_LOCATIONLESS, 'C', &quot;12&quot;, &quot;12&quot;, &quot;&quot;, (byte) -116, 'O', &quot;typeLocless.png&quot;, new String[] { &quot;Geocache|Locationless (Reverse) Cache&quot;, &quot;Geocache&quot;, &quot;Locationless (Reverse) Cache&quot;, &quot;Locationless&quot; }, 12, 9, 8,
-					0x000080),
-			new CTyp(CW_TYPE_CITO, CW_TYPE_CITO, 'C', &quot;13&quot;, &quot;13&quot;, &quot;&quot;, (byte) -115, 'X', &quot;typeCito.png&quot;, new String[] { &quot;Geocache|Cache In Trash Out Event&quot;, &quot;Geocache&quot;, &quot;Cache In Trash Out Event&quot;, &quot;CITO&quot; }, 13, 10, 17, 0x020000),
-			new CTyp(CW_TYPE_EARTH, CW_TYPE_EARTH, 'C', &quot;137&quot;, &quot;137&quot;, &quot;&quot;, (byte) 9, 'E', &quot;typeEarth.png&quot;, new String[] { &quot;Geocache|Earthcache&quot;, &quot;Geocache&quot;, &quot;Earthcache&quot;, &quot;Earth&quot; }, 18, 11, 7, 0x000400),
-			new CTyp(CW_TYPE_WHEREIGO, CW_TYPE_WHEREIGO, 'C', &quot;1858&quot;, &quot;1858&quot;, &quot;&quot;, (byte) 100, 'G', &quot;typeWhereigo.png&quot;, new String[] { &quot;Geocache|Wherigo Cache&quot;, &quot;Geocache&quot;, &quot;Wherigo Cache&quot;, &quot;Wherigo&quot; }, 15, 12, 18, 0x040000),
-			// additional waypoints
-			new CTyp(CW_TYPE_PARKING, CW_TYPE_PARKING, 'A', &quot;50&quot;, &quot;&quot;, &quot;&quot;, (byte) -78, 'P', &quot;typeParking.png&quot;, new String[] { &quot;Waypoint|Parking Area&quot;, &quot;Parking Area&quot;, &quot;Parking Area&quot;, &quot;&quot; }, 50, 13, 11, 0x000800),
-			new CTyp(CW_TYPE_STAGE, CW_TYPE_STAGE, 'A', &quot;51&quot;, &quot;&quot;, &quot;&quot;, (byte) -77, 'S', &quot;typeStage.png&quot;, new String[] { &quot;Waypoint|Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;&quot; }, 51, 14, 12, 0x001000),
-			new CTyp(CW_TYPE_QUESTION, CW_TYPE_QUESTION, 'A', &quot;52&quot;, &quot;&quot;, &quot;&quot;, (byte) -76, 'Q', &quot;typeQuestion.png&quot;, new String[] { &quot;Waypoint|Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;&quot; }, 52, 15, 13, 0x002000),
-			new CTyp(CW_TYPE_FINAL, CW_TYPE_FINAL, 'A', &quot;53&quot;, &quot;&quot;, &quot;&quot;, (byte) -75, 'F', &quot;typeFinal.png&quot;, new String[] { &quot;Waypoint|Final Location&quot;, &quot;Final Location&quot;, &quot;Final Location&quot;, &quot;&quot; }, 53, 16, 14, 0x004000),
-			new CTyp(CW_TYPE_TRAILHEAD, CW_TYPE_TRAILHEAD, 'A', &quot;54&quot;, &quot;&quot;, &quot;&quot;, (byte) -74, 'H', &quot;typeTrailhead.png&quot;, new String[] { &quot;Waypoint|Trailhead&quot;, &quot;Trailhead&quot;, &quot;Trailhead&quot;, &quot;&quot; }, 54, 17, 15, 0x008000),
-			new CTyp(CW_TYPE_REFERENCE, CW_TYPE_REFERENCE, 'A', &quot;55&quot;, &quot;&quot;, &quot;&quot;, (byte) -73, 'R', &quot;typeReference.png&quot;, new String[] { &quot;Waypoint|Reference Point&quot;, &quot;Reference Point&quot;, &quot;Reference Point&quot;, &quot;&quot; }, 55, 18, 16, 0x010000),
-			// error on waypoint
-			new CTyp(CW_TYPE_ERROR, CW_TYPE_ERROR, 'E', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -1, '-', &quot;guiError.png&quot;, new String[] { &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 49, -1, -1, 0),
-			// mapped types (recognized on input from gpx or download-spider / or cw - version)
-			new CTyp(CW_TYPE_UNKNOWN, (byte) 1, 'C', &quot;&quot;, &quot;&quot;, &quot;1&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;Geocache|Other&quot;, &quot;Geocache&quot;, &quot;Other&quot;, &quot;Other&quot; }, 21, -1, -1, 0),
-			new CTyp(CW_TYPE_UNKNOWN, (byte) 7, 'C', &quot;7&quot;, &quot;&quot;, &quot;7&quot;, (byte) -121, 'U', &quot;&quot;, new String[] { &quot;Geocache|Quiz&quot;, &quot;Geocache&quot;, &quot;Quiz&quot;, &quot;Quiz&quot; }, 7, -1, -1, 0),
-			new CTyp(CW_TYPE_UNKNOWN, (byte) 9, 'C', &quot;9&quot;, &quot;&quot;, &quot;9&quot;, (byte) -119, 'U', &quot;&quot;, new String[] { &quot;Geocache|Moving&quot;, &quot;Geocache&quot;, &quot;Moving&quot;, &quot;Moving&quot; }, 9, -1, -1, 0),
-			new CTyp(CW_TYPE_TRADITIONAL, (byte) 10, 'C', &quot;10&quot;, &quot;&quot;, &quot;10&quot;, (byte) -118, 'U', &quot;&quot;, new String[] { &quot;Geocache|DriveIn&quot;, &quot;Geocache&quot;, &quot;DriveIn&quot;, &quot;DriveIn&quot; }, 10, -1, -1, 0),
-			new CTyp(CW_TYPE_EVENT, (byte) 14, 'C', &quot;&quot;, &quot;3653&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|Lost and Found Event Cache&quot;, &quot;Geocache&quot;, &quot;Lost and Found Event Cache&quot;, &quot;&quot; }, 6, -1, -1, 0),
-			new CTyp(CW_TYPE_TRADITIONAL, (byte) 102, 'C', &quot;&quot;, &quot;9&quot;, &quot;&quot;, (byte) -1, 'T', &quot;&quot;, new String[] { &quot;Geocache|Project APE Cache&quot;, &quot;Geocache&quot;, &quot;Project APE Cache&quot;, &quot;APE&quot; }, 16, -1, -1, 0),
-			new CTyp(CW_TYPE_EVENT, (byte) 103, 'C', &quot;&quot;, &quot;1304&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|GPS Adventures Exhibit&quot;, &quot;Geocache&quot;, &quot;GPS Adventures Exhibit&quot;, &quot;MAZE&quot; }, 17, -1, -1, 0),
-			new CTyp(CW_TYPE_UNKNOWN, (byte) 108, 'C', &quot;&quot;, &quot;&quot;, &quot;8&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;only on OC download&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 19, -1, -1, 0),
-			new CTyp(CW_TYPE_WHEREIGO, (byte) 15, 'C', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -62, 'G', &quot;&quot;, new String[] { &quot;Hack for V2 Typ&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, -1, -1, -1, 0), };
-	// public static final int anzCacheTyps=cTypRef.length;
-	public static final byte maxCWCType = 110;
-	static final byte[] Ref_Index = new byte[maxCWCType];
-	static {
-		// +1 cause error is -1 and array starts at 0
-		for (byte i = (byte) (cTypRef.length - 1); i &gt;= 0; i--) {
-			Ref_Index[1 + cTypRef[i]._cwCType] = i;
-		}
-	}
-
-	public static byte Ref_Index(final byte type) {
-		final byte ret = Ref_Index[cTypRef[Ref_Index[type + 1]]._cwMappedCType + 1];
-		return ret;
-	}
-
-	/**
-	 * check if a given waypoint type is an additional waypoint
-	 *
-	 * @param type
-	 *            waypoint type to check
-	 * @return true if it is an additional waypoint, false otherwise
-	 */
-	public static boolean isAddiWpt(final byte type) {
-		return cTypRef[Ref_Index(type)]._cwCGroup == 'A';
-	}
-
-	/**
-	 * check if a given waypoint type is an cache waypoint
-	 *
-	 * @param type
-	 *            waypoint type to check
-	 * @return true if it is an Cache waypoint, false otherwise
-	 */
-	public static boolean isCacheWpt(final byte type) {
-		return cTypRef[Ref_Index(type)]._cwCGroup == 'C';
-	}
-
-	/**
-	 * check if a given waypoint type is an Custom waypoint
-	 *
-	 * @param type
-	 *            waypoint type to check
-	 * @return true if it is an Custom waypint, false otherwise
-	 */
-	public static boolean isCustomWpt(final byte type) {
-		return cTypRef[Ref_Index(type)]._cwCGroup == 'P';
-	}
-
-	// done for DetailsPanel.java and KML- and TomTom-Exporter
-	/**
-	 * create list of cache types to be shown in GUI drop down lists
-	 *
-	 * @return list of cache types to be shown in GUI drop down list
-	 * @see guiSelect2Cw
-	 * @see cw2GuiSelect
-	 */
-	public static String[] guiTypeStrings() {
-		int j = 0;
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._GUIOrder &gt; j) {
-				j = cTypRef[i]._GUIOrder;
-			}
-		}
-		final String[] ret = new String[j + 1];
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._GUIOrder &gt; -1) {
-				ret[cTypRef[i]._GUIOrder] = MyLocale.getMsg(cTypRef[i]._msgNrCTypeName, &quot;&quot;);
-			}
-		}
-		return ret;
-	}
-
-	/**
-	 * translate GUI drop down index selection back to internally stored type
-	 *
-	 * @param selection
-	 *            index value from drop down list
-	 * @return internal type
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;selection&lt;/code&gt; can not be matched
-	 * @see guiTypeStrings
-	 * @see cw2GuiSelect
-	 */
-	public static byte guiSelect2Cw(final int selection) {
-		for (byte i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._GUIOrder == selection) {
-				return cTypRef[i]._cwCType;
-			}
-			;
-		}
-		return -1;
-	}
-
-	/**
-	 * translate cache type to position of index to highlight in GUI cache type drop down list
-	 *
-	 * @param typeId
-	 *            internal id of cache type
-	 * @return index of the cache type in GUI list
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;id&lt;/code&gt; can not be matched
-	 * @see guiTypeStrings
-	 * @see guiSelect2Cw
-	 */
-	public static int cw2GuiSelect(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._GUIOrder;
-	}
-
-	/**
-	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
-	 *
-	 * @param gpxType
-	 *            type information found in GPX
-	 * @return internal cache type
-	 */
-	public static byte gpxType2CwType(final String gpxType) throws IllegalArgumentException {
-		for (byte i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {
-				return cTypRef[i]._cwMappedCType;
-			}
-			;
-		}
-		for (byte i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {
-				return cTypRef[i]._cwMappedCType;
-			}
-			;
-		}
-		final String lowerCaseGPXType = gpxType.toLowerCase();
-		for (byte i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._gpxAlternativeWptTypTags.toLowerCase().indexOf(lowerCaseGPXType) != -1) {
-				return cTypRef[i]._cwMappedCType;
-			}
-			;
-		}
-		// TODO extend definition of _gpxAlternativeWptTypTags for all cases of Mystery
-		// old code was : if (!(gpxType.indexOf(&quot;Mystery&quot;)==-1)) return CW_TYPE_UNKNOWN;
-		return -1;
-	}
-
-	/**
-	 * convert the cache type information from an OC XML import to internal cache type
-	 *
-	 * @param ocType
-	 *            cache type found in OC XML
-	 * @return internal cache type
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;ocType&lt;/code&gt; can not be matched
-	 */
-	public static byte ocType2CwType(final String ocType) {
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._ocCTypeXmlImport.equals(ocType)) {
-				return cTypRef[i]._cwMappedCType;
-			}
-		}
-		return -1;
-	}
-
-	/**
-	 * convert type information discovered by GC spider to internal type information
-	 *
-	 * @param gcType
-	 *            type information from GC spider
-	 * @return internal representation of cache type
-	 * @throws IllegalArgumentException
-	 *             if &lt;code&gt;gcType&lt;/code&gt; can not be matched
-	 */
-	public static byte gcSpider2CwType(final String gcType) {
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._gcCTypeSpider.equals(gcType)) {
-				return cTypRef[i]._cwMappedCType;
-			}
-		}
-		return -1;
-	}
-
-	/**
-	 * convert version1 type information to current values
-	 *
-	 * @param type
-	 *            version1 cache type information
-	 * @return current version cache type information or -1
-	 * @deprecated remove once v1 file version compatibility is abandoned
-	 */
-	public static byte v1Converter(final String type) {
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._cwCTypeV1.equals(type)) {
-				return cTypRef[i]._cwMappedCType;
-			}
-		}
-		return -1;
-	}
-
-	/**
-	 * convert version2 type information to current values
-	 *
-	 * @param type
-	 *            version2 cache type information
-	 * @return current version cache type information or -1
-	 * @deprecated remove once v2 file version compatibility is abandoned
-	 */
-	public static byte v2Converter(final byte type) {
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._cwCTypeV2 == type) {
-				return cTypRef[i]._cwMappedCType;
-			}
-		}
-		return -1;
-	}
-
-	/**
-	 * translate cache type to a short version for compact exporters or &quot;smart&quot; cache names.
-	 *
-	 * @param typeId
-	 *            CacheWolf internal type information
-	 * @return abbreviation of cache type
-	 */
-	public static String getExportShortId(final byte typeId) {
-		return &quot;&quot; + cTypRef[Ref_Index(typeId)]._gpxShortCType;
-	}
-
-	/**
-	 * map cache types to images
-	 *
-	 * @param typeId
-	 *            internal cache type id
-	 * @return non qualified name of image
-	 */
-	public static String typeImageForId(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._imageName;
-	}
-
-	/**
-	 * generate type description matching those of GC for GPX export
-	 *
-	 * @param typeId
-	 *            internal type id
-	 * @return type information in GC.com &lt;type&gt; GPX format
-	 */
-	public static String type2TypeTag(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._gpxWptTypeTag;
-	}
-
-	/**
-	 * generate type description matching those of GC for GPX export
-	 *
-	 * @param typeId
-	 *            internal type id
-	 * @return symb information in GC.com &lt;sym&gt; GPX format
-	 */
-	public static String type2SymTag(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._gpxWptSymTag;
-	}
-
-	/**
-	 * generate type description matching those of GC for GPX export
-	 *
-	 * @param typeId
-	 *            internal type id
-	 * @return type information in GC.com &lt;groundspeak:type&gt; GPX format
-	 */
-	public static String type2GSTypeTag(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._gpxWptGCextensionTypTag;
-	}
-
-	/**
-	 * generate type description matching those of GC for GPX export
-	 *
-	 * @param typeId
-	 *            internal type id
-	 * @return Gui - string for type
-	 */
-	public static String type2Gui(final byte typeId) {
-		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName, &quot;&quot;);
-	}
-
-	/**
-	 * select image to be displayed for a given cache type
-	 *
-	 * @param typeId
-	 *            internal cache type id
-	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
-	 */
-	public static Image getTypeImage(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._iconImage;
-	}
-
-	/**
-	 * select image to be displayed for a given cache type
-	 *
-	 * @param typeId
-	 *            internal cache type id
-	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
-	 */
-	public static Image getMapImage(CacheHolder ch) {
-		byte typeId = ch.getType();
-		Image im = cTypRef[Ref_Index(typeId)]._mapImage;
-		if (ch.is_found()) {
-			if (cTypRef[Ref_Index(typeId)]._modImage[found] == null) {
-				cTypRef[Ref_Index(typeId)]._modImage[found] = newOverlayedImage(im, GuiImageBroker.found);
-			}
-			im = cTypRef[Ref_Index(typeId)]._modImage[found];
-		} else if (ch.is_archived()) {
-			if (cTypRef[Ref_Index(typeId)]._modImage[archived] == null) {
-				cTypRef[Ref_Index(typeId)]._modImage[archived] = newOverlayedImage(im, GuiImageBroker.archived);
-			}
-			im = cTypRef[Ref_Index(typeId)]._modImage[archived];
-		} else if (!ch.is_available()) {
-			if (cTypRef[Ref_Index(typeId)]._modImage[disabled] == null) {
-				cTypRef[Ref_Index(typeId)]._modImage[disabled] = newOverlayedImage(im, GuiImageBroker.disabled);
-			}
-			im = cTypRef[Ref_Index(typeId)]._modImage[disabled];
-		} else if (ch.is_owned()) {
-			if (cTypRef[Ref_Index(typeId)]._modImage[owned] == null) {
-				cTypRef[Ref_Index(typeId)]._modImage[owned] = newOverlayedImage(im, GuiImageBroker.owned);
-			}
-			im = cTypRef[Ref_Index(typeId)]._modImage[owned];
-		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(362, &quot;solved&quot;))) {
-			if (cTypRef[Ref_Index(typeId)]._modImage[solved] == null) {
-				cTypRef[Ref_Index(typeId)]._modImage[solved] = newOverlayedImage(im, GuiImageBroker.solved);
-			}
-			im = cTypRef[Ref_Index(typeId)]._modImage[solved];
-		} else if (ch.getCacheStatus().indexOf(MyLocale.getMsg(319, &quot;Not Found&quot;)) &gt; -1) {
-			if (cTypRef[Ref_Index(typeId)]._modImage[dnf] == null) {
-				cTypRef[Ref_Index(typeId)]._modImage[dnf] = newOverlayedImage(im, GuiImageBroker.dnf);
-			}
-			im = cTypRef[Ref_Index(typeId)]._modImage[dnf];
-		} else if (ch.getCacheName().toLowerCase().indexOf(&quot;bonus&quot;) &gt; -1) {
-			if (cTypRef[Ref_Index(typeId)]._modImage[bonus] == null) {
-				cTypRef[Ref_Index(typeId)]._modImage[bonus] = newOverlayedImage(im, GuiImageBroker.bonus);
-			}
-			im = cTypRef[Ref_Index(typeId)]._modImage[bonus];
-		}
-		return im;
-	}
-
-	/**
-	 * select image to be displayed for a given cache type
-	 *
-	 * @param typeId
-	 *            internal cache type id
-	 * @param Image
-	 *            object to be displayed
-	 */
-	public static void setTypeImage(final byte id, final Image iconImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
-			cTypRef[Ref_Index(id)]._iconImage.free();
-		cTypRef[Ref_Index(id)]._iconImage = iconImage;
-	}
-
-	/**
-	 * select image to be displayed for a given cache type
-	 *
-	 * @param typeId
-	 *            internal cache type id
-	 * @param Image
-	 *            object to be displayed
-	 */
-	public static void setMapImage(final byte id, final Image mapImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
-			cTypRef[Ref_Index(id)]._mapImage.free();
-		cTypRef[Ref_Index(id)]._mapImage = mapImage;
-	}
-
-	// TODO do it better in Version 4
-	public static int getCacheTypePattern(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._FilterPattern;
-	}
-
-	public static int Type_FilterString2Type_FilterPattern(final String Type_FilterString) {
-		int typeMatchPattern = 0;
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._FilterStringPos &gt; -1) {
-				if (Type_FilterString.charAt(cTypRef[i]._FilterStringPos) == '1') {
-					typeMatchPattern |= cTypRef[i]._FilterPattern;
-				}
-			}
-		}
-		return typeMatchPattern;
-	}
-
-	public static boolean hasTypeMatchPattern(final int typeMatchPattern) {
-		return typeMatchPattern != 0;
-	}
-
-	public static boolean hasMainTypeMatchPattern(final int typeMatchPattern) {
-		int TYPE_MAIN = 0;
-		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P') {
-				TYPE_MAIN |= cTypRef[i]._FilterPattern;
-			}
-		}
-		return (typeMatchPattern &amp; TYPE_MAIN) != 0;
-	}
-
-	private static Image newOverlayedImage(Image imsrc, Image imovl) {
-		// Overlay added at topleft
-		int srcWidth = imsrc.getWidth();
-		int srcHeight = imsrc.getHeight();
-		int ovlWidth = imovl.getWidth();
-		int ovlHeight = imovl.getHeight();
-		if (srcWidth &lt; ovlWidth || srcHeight &lt; ovlHeight)
-			return imsrc;
-		int[] srcPixels = imsrc.getPixels(null, 0, 0, 0, srcWidth, srcHeight, 0);
-		int[] ovlPixels = imovl.getPixels(null, 0, 0, 0, ovlWidth, ovlHeight, 0);
-		int offsrc;
-		int offovl = 0;
-		for (int y = 0; y &lt; ovlHeight; y++) { // top down
-			offsrc = y * srcWidth;
-			for (int x = 0; x &lt; ovlWidth; x++) {
-				int alphaval = (ovlPixels[offovl] &gt;&gt; 24) &amp; 0xff;
-				if (alphaval &gt; 0) {
-					srcPixels[offsrc] = ovlPixels[offovl];
-				}
-				offovl++;
-				offsrc++;
-			}
-		}
-		Image modImage = new Image(imsrc, 0);
-		modImage.setPixels(srcPixels, 0, 0, 0, srcWidth, srcHeight, 0);
-		return modImage;
-	}
-
-	// TODO it for OCXMLImporterScreen and FilterScreen ?
-}
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
+
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+package CacheWolf;
+
+import ewe.fx.Image;
+
+final class CTyp {
+	public byte _cwMappedCType; // CW Cache Typ intern
+	public byte _cwCType; // CW Cache Typ intern
+	public char _cwCGroup; // Cache Typ Group intern
+	public String _cwCTypeV1; // V1 Cache Typ
+	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com
+	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com
+	public byte _cwCTypeV2; // V2 Cache Typ
+	public char _gpxShortCType; // Short Typ (one char abbreviation)
+	public String _imageName; // name of imageName for Icon, &quot;showCacheInBrowser&quot; and &quot;KML Export&quot;
+	public String _gpxWptTypeTag; // gpx wpt &lt;type&gt; tag
+	public String _gpxWptSymTag; // gpx wpt &lt;sym&gt; tag
+	public String _gpxWptGCextensionTypTag; // gpx cache extension &lt;groundspeak:type&gt; tag
+	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources
+	public int _msgNrCTypeName; // message number for gui cache Typ name
+	public int _GUIOrder; // sort Order in GUI selection //TODO more intelligent implementation (now manually change each line on new one)
+	public int _FilterStringPos; // BitNr in Filter String (profile)
+	public int _FilterPattern; // 2**BitNr in Filter int (does not correspond with BitNr in String)
+	public Image _iconImage;
+	public Image _mapImage;
+	public Image[] _modImage = { null, null, null, null, null, null, null };
+
+	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos,
+			int filterPattern) {
+
+		_cwMappedCType = cwMappedCType;
+		_cwCType = cwCType;
+		_cwCGroup = cwCGroup;
+		_cwCTypeV1 = cwCTypeV1;
+		_gcCTypeSpider = gcCTypeSpider;
+		_ocCTypeXmlImport = ocCTypeXmlImport;
+		_cwCTypeV2 = cwCTypeV2;
+		_gpxShortCType = gpxShortCType;
+		_imageName = imageName;
+		_gpxWptTypeTag = gpx[0];
+		_gpxWptSymTag = gpx[1];
+		_gpxWptGCextensionTypTag = gpx[2];
+		_gpxAlternativeWptTypTags = gpx[3];
+		_msgNrCTypeName = msgNrCTypeName;
+		_GUIOrder = gUIOrder;
+		_FilterStringPos = filterStringPos;
+		_FilterPattern = filterPattern;
+		if (!_imageName.equals(&quot;&quot;)) {
+			_iconImage = new Image(_imageName);
+			_mapImage = _iconImage;
+		}
+	}
+}
+
+/**
+ * Handles all aspects of converting cache type information
+ * from and to the various im- and exporters ...
+ * converting legacy profiles to current standard
+ *
+ * Do not instantiate this class, only use it in a static way
+ */
+public final class CacheType {
+
+	/** thou shallst not instantiate this object */
+	private CacheType() {
+		// Nothing to do
+	}
+
+	/** custom waypoint */
+	public static final byte CW_TYPE_CUSTOM = 0;
+	/** traditional cache (GC,OC) */
+	public static final byte CW_TYPE_TRADITIONAL = 2;
+	/** multi cache (GC,OC) */
+	public static final byte CW_TYPE_MULTI = 3;
+	/** virtual cache (GC,OC) */
+	public static final byte CW_TYPE_VIRTUAL = 4;
+	/** letterbox cache (GC) */
+	public static final byte CW_TYPE_LETTERBOX = 5;
+	/** event cache (GC,OC) */
+	public static final byte CW_TYPE_EVENT = 6;
+	/** unknown cache - Mystery (GC) */
+	public static final byte CW_TYPE_UNKNOWN = 8;
+	/** drive in cache (OC) */
+	public static final byte CW_TYPE_DRIVE_IN = 10;
+	/** webcam cache (GC,OC) */
+	public static final byte CW_TYPE_WEBCAM = 11;
+	/** locationless cache (GC) */
+	public static final byte CW_TYPE_LOCATIONLESS = 12;
+	/** CITO cache (GC) */
+	public static final byte CW_TYPE_CITO = 13;
+	/** Mega Event Cache (GC) */
+	public static final byte CW_TYPE_MEGA_EVENT = 100;
+	/** WhereIGo Cache (GC) */
+	public static final byte CW_TYPE_WHEREIGO = 101;
+	/** Earth Cache (GC) */
+	public static final byte CW_TYPE_EARTH = 104;
+	/** Additional Waypoint Parking (GC) */
+	public static final byte CW_TYPE_PARKING = 50;
+	/** Additional Waypoint Stage of a Multi (GC) */
+	public static final byte CW_TYPE_STAGE = 51;
+	/** Additional Waypoint Question to answer (GC) */
+	public static final byte CW_TYPE_QUESTION = 52;
+	/** Additional Waypoint Final (GC) */
+	public static final byte CW_TYPE_FINAL = 53;
+	/** Additional Waypoint Trailhead (GC) */
+	public static final byte CW_TYPE_TRAILHEAD = 54;
+	/** Additional Waypoint Reference (GC) */
+	public static final byte CW_TYPE_REFERENCE = 55;
+	/** unrecognized cache type or missing information */
+	public static final byte CW_TYPE_ERROR = -1;
+	String[] ggpx = { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; };
+	private static final byte found = 0;
+	private static final byte archived = 1;
+	private static final byte disabled = 2;
+	private static final byte solved = 3;
+	private static final byte bonus = 4;
+	private static final byte owned = 5;
+	private static final byte dnf = 6;
+	//
+	private static final CTyp[] cTypRef = {
+			// custom waypoints
+			new CTyp(CW_TYPE_CUSTOM, CW_TYPE_CUSTOM, 'P', &quot;0&quot;, &quot;&quot;, &quot;&quot;, (byte) -128, 'C', &quot;typeCustom.png&quot;, new String[] { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; }, 1, 0, 10, 0x000100),
+			// Cache waypoints
+			new CTyp(CW_TYPE_TRADITIONAL, CW_TYPE_TRADITIONAL, 'C', &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, (byte) -126, 'T', &quot;typeTradi.png&quot;, new String[] { &quot;Geocache|Traditional Cache&quot;, &quot;Geocache&quot;, &quot;Traditional Cache&quot;, &quot;Traditional|Classic&quot; }, 2, 1, 0, 0x000001),
+			new CTyp(CW_TYPE_MULTI, CW_TYPE_MULTI, 'C', &quot;3&quot;, &quot;3&quot;, &quot;3&quot;, (byte) -125, 'M', &quot;typeMulti.png&quot;, new String[] { &quot;Geocache|Multi-cache&quot;, &quot;Geocache&quot;, &quot;Multi-cache&quot;, &quot;Multi|Offset&quot; }, 3, 2, 1, 0x000002),
+			new CTyp(CW_TYPE_VIRTUAL, CW_TYPE_VIRTUAL, 'C', &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, (byte) -124, 'V', &quot;typeVirtual.png&quot;, new String[] { &quot;Geocache|Virtual Cache&quot;, &quot;Geocache&quot;, &quot;Virtual Cache&quot;, &quot;Virtual&quot; }, 4, 3, 2, 0x000004),
+			new CTyp(CW_TYPE_LETTERBOX, CW_TYPE_LETTERBOX, 'C', &quot;5&quot;, &quot;5&quot;, &quot;&quot;, (byte) -123, 'L', &quot;typeLetterbox.png&quot;, new String[] { &quot;Geocache|Letterbox Hybrid&quot;, &quot;Geocache&quot;, &quot;Letterbox Hybrid&quot;, &quot;Letterbox&quot; }, 5, 4, 3, 0x000008),
+			new CTyp(CW_TYPE_EVENT, CW_TYPE_EVENT, 'C', &quot;6&quot;, &quot;6&quot;, &quot;6&quot;, (byte) -122, 'X', &quot;typeEvent.png&quot;, new String[] { &quot;Geocache|Event Cache&quot;, &quot;Geocache&quot;, &quot;Event Cache&quot;, &quot;Event&quot; }, 6, 5, 4, 0x000010),
+			new CTyp(CW_TYPE_MEGA_EVENT, CW_TYPE_MEGA_EVENT, 'C', &quot;453&quot;, &quot;453&quot;, &quot;&quot;, (byte) 101, 'X', &quot;typeMegaevent.png&quot;, new String[] { &quot;Geocache|Mega-Event Cache&quot;, &quot;Geocache&quot;, &quot;Mega-Event Cache&quot;, &quot;Mega&quot; }, 14, 6, 9, 0x000200),
+			new CTyp(CW_TYPE_WEBCAM, CW_TYPE_WEBCAM, 'C', &quot;11&quot;, &quot;11&quot;, &quot;5&quot;, (byte) -117, 'W', &quot;typeWebcam.png&quot;, new String[] { &quot;Geocache|Webcam Cache&quot;, &quot;Geocache&quot;, &quot;Webcam Cache&quot;, &quot;Webcam&quot; }, 11, 7, 5, 0x000020),
+			new CTyp(CW_TYPE_UNKNOWN, CW_TYPE_UNKNOWN, 'C', &quot;8&quot;, &quot;8&quot;, &quot;&quot;, (byte) -120, 'U', &quot;typeUnknown.png&quot;, new String[] { &quot;Geocache|Unknown Cache&quot;, &quot;Geocache&quot;, &quot;Unknown Cache&quot;, &quot;Mystery&quot; }, 8, 8, 6, 0x000040),
+			new CTyp(CW_TYPE_LOCATIONLESS, CW_TYPE_LOCATIONLESS, 'C', &quot;12&quot;, &quot;12&quot;, &quot;&quot;, (byte) -116, 'O', &quot;typeLocless.png&quot;, new String[] { &quot;Geocache|Locationless (Reverse) Cache&quot;, &quot;Geocache&quot;, &quot;Locationless (Reverse) Cache&quot;, &quot;Locationless&quot; }, 12, 9, 8,
+					0x000080),
+			new CTyp(CW_TYPE_CITO, CW_TYPE_CITO, 'C', &quot;13&quot;, &quot;13&quot;, &quot;&quot;, (byte) -115, 'X', &quot;typeCito.png&quot;, new String[] { &quot;Geocache|Cache In Trash Out Event&quot;, &quot;Geocache&quot;, &quot;Cache In Trash Out Event&quot;, &quot;CITO&quot; }, 13, 10, 17, 0x020000),
+			new CTyp(CW_TYPE_EARTH, CW_TYPE_EARTH, 'C', &quot;137&quot;, &quot;137&quot;, &quot;&quot;, (byte) 9, 'E', &quot;typeEarth.png&quot;, new String[] { &quot;Geocache|Earthcache&quot;, &quot;Geocache&quot;, &quot;Earthcache&quot;, &quot;Earth&quot; }, 18, 11, 7, 0x000400),
+			new CTyp(CW_TYPE_WHEREIGO, CW_TYPE_WHEREIGO, 'C', &quot;1858&quot;, &quot;1858&quot;, &quot;&quot;, (byte) 100, 'G', &quot;typeWhereigo.png&quot;, new String[] { &quot;Geocache|Wherigo Cache&quot;, &quot;Geocache&quot;, &quot;Wherigo Cache&quot;, &quot;Wherigo&quot; }, 15, 12, 18, 0x040000),
+			// additional waypoints
+			new CTyp(CW_TYPE_PARKING, CW_TYPE_PARKING, 'A', &quot;50&quot;, &quot;&quot;, &quot;&quot;, (byte) -78, 'P', &quot;typeParking.png&quot;, new String[] { &quot;Waypoint|Parking Area&quot;, &quot;Parking Area&quot;, &quot;Parking Area&quot;, &quot;&quot; }, 50, 13, 11, 0x000800),
+			new CTyp(CW_TYPE_STAGE, CW_TYPE_STAGE, 'A', &quot;51&quot;, &quot;&quot;, &quot;&quot;, (byte) -77, 'S', &quot;typeStage.png&quot;, new String[] { &quot;Waypoint|Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;&quot; }, 51, 14, 12, 0x001000),
+			new CTyp(CW_TYPE_QUESTION, CW_TYPE_QUESTION, 'A', &quot;52&quot;, &quot;&quot;, &quot;&quot;, (byte) -76, 'Q', &quot;typeQuestion.png&quot;, new String[] { &quot;Waypoint|Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;&quot; }, 52, 15, 13, 0x002000),
+			new CTyp(CW_TYPE_FINAL, CW_TYPE_FINAL, 'A', &quot;53&quot;, &quot;&quot;, &quot;&quot;, (byte) -75, 'F', &quot;typeFinal.png&quot;, new String[] { &quot;Waypoint|Final Location&quot;, &quot;Final Location&quot;, &quot;Final Location&quot;, &quot;&quot; }, 53, 16, 14, 0x004000),
+			new CTyp(CW_TYPE_TRAILHEAD, CW_TYPE_TRAILHEAD, 'A', &quot;54&quot;, &quot;&quot;, &quot;&quot;, (byte) -74, 'H', &quot;typeTrailhead.png&quot;, new String[] { &quot;Waypoint|Trailhead&quot;, &quot;Trailhead&quot;, &quot;Trailhead&quot;, &quot;&quot; }, 54, 17, 15, 0x008000),
+			new CTyp(CW_TYPE_REFERENCE, CW_TYPE_REFERENCE, 'A', &quot;55&quot;, &quot;&quot;, &quot;&quot;, (byte) -73, 'R', &quot;typeReference.png&quot;, new String[] { &quot;Waypoint|Reference Point&quot;, &quot;Reference Point&quot;, &quot;Reference Point&quot;, &quot;&quot; }, 55, 18, 16, 0x010000),
+			// error on waypoint
+			new CTyp(CW_TYPE_ERROR, CW_TYPE_ERROR, 'E', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -1, '-', &quot;guiError.png&quot;, new String[] { &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 49, -1, -1, 0),
+			// mapped types (recognized on input from gpx or download-spider / or cw - version)
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 1, 'C', &quot;&quot;, &quot;&quot;, &quot;1&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;Geocache|Other&quot;, &quot;Geocache&quot;, &quot;Other&quot;, &quot;Other&quot; }, 21, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 7, 'C', &quot;7&quot;, &quot;&quot;, &quot;7&quot;, (byte) -121, 'U', &quot;&quot;, new String[] { &quot;Geocache|Quiz&quot;, &quot;Geocache&quot;, &quot;Quiz&quot;, &quot;Quiz&quot; }, 7, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 9, 'C', &quot;9&quot;, &quot;&quot;, &quot;9&quot;, (byte) -119, 'U', &quot;&quot;, new String[] { &quot;Geocache|Moving&quot;, &quot;Geocache&quot;, &quot;Moving&quot;, &quot;Moving&quot; }, 9, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 10, 'C', &quot;10&quot;, &quot;&quot;, &quot;10&quot;, (byte) -118, 'U', &quot;&quot;, new String[] { &quot;Geocache|DriveIn&quot;, &quot;Geocache&quot;, &quot;DriveIn&quot;, &quot;DriveIn&quot; }, 10, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 14, 'C', &quot;&quot;, &quot;3653&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|Lost and Found Event Cache&quot;, &quot;Geocache&quot;, &quot;Lost and Found Event Cache&quot;, &quot;&quot; }, 6, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 102, 'C', &quot;&quot;, &quot;9&quot;, &quot;&quot;, (byte) -1, 'T', &quot;&quot;, new String[] { &quot;Geocache|Project APE Cache&quot;, &quot;Geocache&quot;, &quot;Project APE Cache&quot;, &quot;APE&quot; }, 16, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 103, 'C', &quot;&quot;, &quot;1304&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|GPS Adventures Exhibit&quot;, &quot;Geocache&quot;, &quot;GPS Adventures Exhibit&quot;, &quot;MAZE&quot; }, 17, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 108, 'C', &quot;&quot;, &quot;&quot;, &quot;8&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;only on OC download&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 19, -1, -1, 0),
+			new CTyp(CW_TYPE_WHEREIGO, (byte) 15, 'C', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -62, 'G', &quot;&quot;, new String[] { &quot;Hack for V2 Typ&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, -1, -1, -1, 0), };
+	// public static final int anzCacheTyps=cTypRef.length;
+	public static final byte maxCWCType = 110;
+	static final byte[] Ref_Index = new byte[maxCWCType];
+	static {
+		// +1 cause error is -1 and array starts at 0
+		for (byte i = (byte) (cTypRef.length - 1); i &gt;= 0; i--) {
+			Ref_Index[1 + cTypRef[i]._cwCType] = i;
+		}
+	}
+
+	public static byte Ref_Index(final byte type) {
+		final byte ret = Ref_Index[cTypRef[Ref_Index[type + 1]]._cwMappedCType + 1];
+		return ret;
+	}
+
+	/**
+	 * check if a given waypoint type is an additional waypoint
+	 *
+	 * @param type
+	 *            waypoint type to check
+	 * @return true if it is an additional waypoint, false otherwise
+	 */
+	public static boolean isAddiWpt(final byte type) {
+		return cTypRef[Ref_Index(type)]._cwCGroup == 'A';
+	}
+
+	/**
+	 * check if a given waypoint type is an cache waypoint
+	 *
+	 * @param type
+	 *            waypoint type to check
+	 * @return true if it is an Cache waypoint, false otherwise
+	 */
+	public static boolean isCacheWpt(final byte type) {
+		return cTypRef[Ref_Index(type)]._cwCGroup == 'C';
+	}
+
+	/**
+	 * check if a given waypoint type is an Custom waypoint
+	 *
+	 * @param type
+	 *            waypoint type to check
+	 * @return true if it is an Custom waypint, false otherwise
+	 */
+	public static boolean isCustomWpt(final byte type) {
+		return cTypRef[Ref_Index(type)]._cwCGroup == 'P';
+	}
+
+	// done for DetailsPanel.java and KML- and TomTom-Exporter
+	/**
+	 * create list of cache types to be shown in GUI drop down lists
+	 *
+	 * @return list of cache types to be shown in GUI drop down list
+	 * @see guiSelect2Cw
+	 * @see cw2GuiSelect
+	 */
+	public static String[] guiTypeStrings() {
+		int j = 0;
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._GUIOrder &gt; j) {
+				j = cTypRef[i]._GUIOrder;
+			}
+		}
+		final String[] ret = new String[j + 1];
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._GUIOrder &gt; -1) {
+				ret[cTypRef[i]._GUIOrder] = MyLocale.getMsg(cTypRef[i]._msgNrCTypeName, &quot;&quot;);
+			}
+		}
+		return ret;
+	}
+
+	/**
+	 * translate GUI drop down index selection back to internally stored type
+	 *
+	 * @param selection
+	 *            index value from drop down list
+	 * @return internal type
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;selection&lt;/code&gt; can not be matched
+	 * @see guiTypeStrings
+	 * @see cw2GuiSelect
+	 */
+	public static byte guiSelect2Cw(final int selection) {
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._GUIOrder == selection) {
+				return cTypRef[i]._cwCType;
+			}
+			;
+		}
+		return -1;
+	}
+
+	/**
+	 * translate cache type to position of index to highlight in GUI cache type drop down list
+	 *
+	 * @param typeId
+	 *            internal id of cache type
+	 * @return index of the cache type in GUI list
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;id&lt;/code&gt; can not be matched
+	 * @see guiTypeStrings
+	 * @see guiSelect2Cw
+	 */
+	public static int cw2GuiSelect(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._GUIOrder;
+	}
+
+	/**
+	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
+	 *
+	 * @param gpxType
+	 *            type information found in GPX
+	 * @return internal cache type
+	 */
+	public static byte gpxType2CwType(final String gpxType) throws IllegalArgumentException {
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
+		}
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
+		}
+		final String lowerCaseGPXType = gpxType.toLowerCase();
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxAlternativeWptTypTags.toLowerCase().indexOf(lowerCaseGPXType) != -1) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
+		}
+		// TODO extend definition of _gpxAlternativeWptTypTags for all cases of Mystery
+		// old code was : if (!(gpxType.indexOf(&quot;Mystery&quot;)==-1)) return CW_TYPE_UNKNOWN;
+		return -1;
+	}
+
+	/**
+	 * convert the cache type information from an OC XML import to internal cache type
+	 *
+	 * @param ocType
+	 *            cache type found in OC XML
+	 * @return internal cache type
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;ocType&lt;/code&gt; can not be matched
+	 */
+	public static byte ocType2CwType(final String ocType) {
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._ocCTypeXmlImport.equals(ocType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+		}
+		return -1;
+	}
+
+	/**
+	 * convert type information discovered by GC spider to internal type information
+	 *
+	 * @param gcType
+	 *            type information from GC spider
+	 * @return internal representation of cache type
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;gcType&lt;/code&gt; can not be matched
+	 */
+	public static byte gcSpider2CwType(final String gcType) {
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gcCTypeSpider.equals(gcType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+		}
+		return -1;
+	}
+
+	/**
+	 * convert version1 type information to current values
+	 *
+	 * @param type
+	 *            version1 cache type information
+	 * @return current version cache type information or -1
+	 * @deprecated remove once v1 file version compatibility is abandoned
+	 */
+	public static byte v1Converter(final String type) {
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._cwCTypeV1.equals(type)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+		}
+		return -1;
+	}
+
+	/**
+	 * convert version2 type information to current values
+	 *
+	 * @param type
+	 *            version2 cache type information
+	 * @return current version cache type information or -1
+	 * @deprecated remove once v2 file version compatibility is abandoned
+	 */
+	public static byte v2Converter(final byte type) {
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._cwCTypeV2 == type) {
+				return cTypRef[i]._cwMappedCType;
+			}
+		}
+		return -1;
+	}
+
+	/**
+	 * translate cache type to a short version for compact exporters or &quot;smart&quot; cache names.
+	 *
+	 * @param typeId
+	 *            CacheWolf internal type information
+	 * @return abbreviation of cache type
+	 */
+	public static String getExportShortId(final byte typeId) {
+		return &quot;&quot; + cTypRef[Ref_Index(typeId)]._gpxShortCType;
+	}
+
+	/**
+	 * map cache types to images
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @return non qualified name of image
+	 */
+	public static String typeImageForId(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._imageName;
+	}
+
+	/**
+	 * generate type description matching those of GC for GPX export
+	 *
+	 * @param typeId
+	 *            internal type id
+	 * @return type information in GC.com &lt;type&gt; GPX format
+	 */
+	public static String type2TypeTag(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._gpxWptTypeTag;
+	}
+
+	/**
+	 * generate type description matching those of GC for GPX export
+	 *
+	 * @param typeId
+	 *            internal type id
+	 * @return symb information in GC.com &lt;sym&gt; GPX format
+	 */
+	public static String type2SymTag(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._gpxWptSymTag;
+	}
+
+	/**
+	 * generate type description matching those of GC for GPX export
+	 *
+	 * @param typeId
+	 *            internal type id
+	 * @return type information in GC.com &lt;groundspeak:type&gt; GPX format
+	 */
+	public static String type2GSTypeTag(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._gpxWptGCextensionTypTag;
+	}
+
+	/**
+	 * generate type description matching those of GC for GPX export
+	 *
+	 * @param typeId
+	 *            internal type id
+	 * @return Gui - string for type
+	 */
+	public static String type2Gui(final byte typeId) {
+		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName, &quot;&quot;);
+	}
+
+	/**
+	 * select image to be displayed for a given cache type
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
+	 */
+	public static Image getTypeImage(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._iconImage;
+	}
+
+	/**
+	 * select image to be displayed for a given cache type
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
+	 */
+	public static Image getMapImage(CacheHolder ch) {
+		byte typeId = ch.getType();
+		Image im = cTypRef[Ref_Index(typeId)]._mapImage;
+		if (ch.is_found()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[found] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[found] = newOverlayedImage(im, GuiImageBroker.found);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[found];
+		} else if (ch.is_archived()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[archived] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[archived] = newOverlayedImage(im, GuiImageBroker.archived);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[archived];
+		} else if (!ch.is_available()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[disabled] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[disabled] = newOverlayedImage(im, GuiImageBroker.disabled);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[disabled];
+		} else if (ch.is_owned()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[owned] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[owned] = newOverlayedImage(im, GuiImageBroker.owned);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[owned];
+		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(362, &quot;solved&quot;))) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[solved] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[solved] = newOverlayedImage(im, GuiImageBroker.solved);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[solved];
+		} else if (ch.getCacheStatus().indexOf(MyLocale.getMsg(319, &quot;Not Found&quot;)) &gt; -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[dnf] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[dnf] = newOverlayedImage(im, GuiImageBroker.dnf);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[dnf];
+		} else if (ch.getCacheName().toLowerCase().indexOf(&quot;bonus&quot;) &gt; -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[bonus] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[bonus] = newOverlayedImage(im, GuiImageBroker.bonus);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[bonus];
+		}
+		return im;
+	}
+
+	/**
+	 * select image to be displayed for a given cache type
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
+	 */
+	public static void setTypeImage(final byte id, final Image iconImage) {
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
+			cTypRef[Ref_Index(id)]._iconImage.free();
+		cTypRef[Ref_Index(id)]._iconImage = iconImage;
+	}
+
+	/**
+	 * select image to be displayed for a given cache type
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
+	 */
+	public static void setMapImage(final byte id, final Image mapImage) {
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
+			cTypRef[Ref_Index(id)]._mapImage.free();
+		cTypRef[Ref_Index(id)]._mapImage = mapImage;
+	}
+
+	// TODO do it better in Version 4
+	public static int getCacheTypePattern(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._FilterPattern;
+	}
+
+	public static int Type_FilterString2Type_FilterPattern(final String Type_FilterString) {
+		int typeMatchPattern = 0;
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._FilterStringPos &gt; -1) {
+				if (Type_FilterString.charAt(cTypRef[i]._FilterStringPos) == '1') {
+					typeMatchPattern |= cTypRef[i]._FilterPattern;
+				}
+			}
+		}
+		return typeMatchPattern;
+	}
+
+	public static boolean hasTypeMatchPattern(final int typeMatchPattern) {
+		return typeMatchPattern != 0;
+	}
+
+	public static boolean hasMainTypeMatchPattern(final int typeMatchPattern) {
+		int TYPE_MAIN = 0;
+		for (int i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P') {
+				TYPE_MAIN |= cTypRef[i]._FilterPattern;
+			}
+		}
+		return (typeMatchPattern &amp; TYPE_MAIN) != 0;
+	}
+
+	private static Image newOverlayedImage(Image imsrc, Image imovl) {
+		// Overlay added at topleft
+		int srcWidth = imsrc.getWidth();
+		int srcHeight = imsrc.getHeight();
+		int ovlWidth = imovl.getWidth();
+		int ovlHeight = imovl.getHeight();
+		if (srcWidth &lt; ovlWidth || srcHeight &lt; ovlHeight)
+			return imsrc;
+		int[] srcPixels = imsrc.getPixels(null, 0, 0, 0, srcWidth, srcHeight, 0);
+		int[] ovlPixels = imovl.getPixels(null, 0, 0, 0, ovlWidth, ovlHeight, 0);
+		int offsrc;
+		int offovl = 0;
+		for (int y = 0; y &lt; ovlHeight; y++) { // top down
+			offsrc = y * srcWidth;
+			for (int x = 0; x &lt; ovlWidth; x++) {
+				int alphaval = (ovlPixels[offovl] &gt;&gt; 24) &amp; 0xff;
+				if (alphaval &gt; 0) {
+					srcPixels[offsrc] = ovlPixels[offovl];
+				}
+				offovl++;
+				offsrc++;
+			}
+		}
+		Image modImage = new Image(imsrc, 0);
+		modImage.setPixels(srcPixels, 0, 0, 0, srcWidth, srcHeight, 0);
+		return modImage;
+	}
+
+	// TODO it for OCXMLImporterScreen and FilterScreen ?
+}

Modified: branches/r1.2/src/CacheWolf/DetailsPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/DetailsPanel.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/DetailsPanel.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -573,7 +573,6 @@
 				ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 				Global.mainTab.newWaypoint(ch);
 			} else if (ev.target == btnGoto) {
-				// FIXME: if something changed saveDirtyWaypoint();
 				Global.mainTab.gotoP.setDestinationAndSwitch(cache);
 			} else if (ev.target == btnCoordinates) {
 				CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);

Modified: branches/r1.2/src/CacheWolf/Extractor.java
===================================================================
--- branches/r1.2/src/CacheWolf/Extractor.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/Extractor.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -47,7 +47,7 @@
 	 * startOffset = The beginning offset from which to start the search in sTxt&lt;br&gt;
 	 * betweenonly = if false the string returned will inlcude st and e;
 	 * if true it will not include st and e.
-	 * 
+	 *
 	 */
 	public Extractor(String searchText, String st, String e, int startOffset, boolean betweenonly) {
 		_startOffset = startOffset;
@@ -59,7 +59,7 @@
 
 	/**
 	 * Mehtod to set the source text to be searched through
-	 * 
+	 *
 	 */
 	public void set(String searchText, String st, String e, int startOffset, boolean betweenonly) {
 		_startOffset = startOffset;
@@ -74,11 +74,6 @@
 		_startOffset = 0;
 	}
 
-	public void set(String searchText, int startOffset) {
-		_searchText = searchText;
-		_startOffset = startOffset;
-	}
-
 	public String findFirst(String searchText) {
 		_searchText = searchText;
 		_startOffset = 0;

Modified: branches/r1.2/src/CacheWolf/MainMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainMenu.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/MainMenu.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -89,7 +89,7 @@
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
 	private MenuItem exportLOC, exportGPS, mnuSeparator = new MenuItem(&quot;-&quot;);
 	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete, orgRebuild, orgCheckNotesAndSolver;
-	public MenuItem cacheTour, orgTravelbugs, mnuForceLogin;
+	public MenuItem cacheTour, orgTravelbugs;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuDeleteProfile, mnuRenameProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
@@ -127,19 +127,15 @@
 				loadOCFinds = new MenuItem(MyLocale.getMsg(163, &quot;Finds from opencaching&quot;)), //
 				mnuSeparator, //
 				spider = new MenuItem(MyLocale.getMsg(131, &quot;Download from geocaching.com&quot;)), //
-				spiderRoute, //
 				spiderAllFinds = new MenuItem(MyLocale.getMsg(217, &quot;Spider all finds from geocaching.com&quot;)), //
+				spiderRoute, //
 				spiderQuick = new MenuItem(MyLocale.getMsg(138, &quot;from GC quick&quot;)), //
-				update = new MenuItem(MyLocale.getMsg(1014, &quot;Update cache data&quot;)), //
-				mnuSeparator, //
 				loadGCVotes = new MenuItem(MyLocale.getMsg(1208, &quot;Import ratings from GCVote&quot;)), //
 				fetchOCLink = new MenuItem(MyLocale.getMsg(1209, &quot;Fetch link to OC - Cache&quot;)), //
 				mnuSeparator, //
-				mnuForceLogin = new MenuItem(MyLocale.getMsg(216, &quot;Always login to GC&quot;)), //
+				update = new MenuItem(MyLocale.getMsg(1014, &quot;Update cache data&quot;)), //
 		};
 		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175, &quot;Import&quot;));
-		if (Global.getPref().forceLogin)
-			mnuForceLogin.modifiers ^= MenuItem.Checked;
 
 		// /////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of &quot;Application&quot; menu below
@@ -440,11 +436,6 @@
 				updateSelectedCaches(tbp);
 				pref.setOldGCLanguage();
 			}
-			if (mev.selectedItem == mnuForceLogin) {
-				mnuForceLogin.modifiers ^= MenuItem.Checked;
-				Global.getPref().forceLogin = (mnuForceLogin.modifiers &amp; MenuItem.Checked) != 0;
-				Global.getPref().savePreferences();
-			}
 			// /////////////////////////////////////////////////////////////////////
 			// subMenu for export, part of &quot;Application&quot; menu
 			// /////////////////////////////////////////////////////////////////////
@@ -885,7 +876,6 @@
 		}
 
 		int spiderErrors = 0;
-		boolean forceLogin = Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
 		for (int j = 0; j &lt; cachesToUpdate.size(); j++) {
 			int i = ((Integer) cachesToUpdate.get(j)).intValue();
 			ch = cacheDB.get(i);
@@ -893,7 +883,7 @@
 			infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + ch.getWayPoint() + &quot; (&quot; + (j + 1) + &quot; / &quot; + cachesToUpdate.size() + &quot;)&quot;);
 			infB.redisplay();
 			if (ch.getWayPoint().substring(0, 2).equalsIgnoreCase(&quot;GC&quot;)) {
-				int test = spider.spiderSingle(i, infB, forceLogin, loadAllLogs || ch.is_found());
+				int test = spider.spiderSingle(i, infB, loadAllLogs || ch.is_found());
 				if (test == SpiderGC.SPIDER_CANCEL) {
 					infB.close(0);
 					break;
@@ -902,7 +892,6 @@
 				} else {
 					// profile.hasUnsavedChanges=true;
 				}
-				forceLogin = false;
 			} else {
 				if (!ocSync.syncSingle(i, infB)) {
 					infB.close(0);

Modified: branches/r1.2/src/CacheWolf/MainTab.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainTab.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/MainTab.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -44,7 +44,7 @@
  * This class creates the tabbed panel and sets the tabs to the respective other panels. Important is to have a look at
  * the event handler!&lt;br&gt;
  * Class ID = 1200
- * 
+ *
  * @see MainForm
  * @see MainMenu
  */
@@ -148,7 +148,7 @@
 		if (pref.isBigScreen || !pref.useRadar) {
 			c = this.addCard(mapP = new ewe.ui.CellPanel(), MyLocale.getMsg(347, &quot;Show map&quot;), null);
 			MAP_CARD = this.cardPanel.cards.size() - 1;
-			c.iconize(new Image(&quot;globe_small&quot; + imagesize + &quot;.gif&quot;), true);
+			c.iconize(new Image(&quot;globe_tab&quot; + imagesize + &quot;.gif&quot;), true);
 		}
 
 		if (pref.isBigScreen || pref.useRadar) {
@@ -200,7 +200,7 @@
 
 	/**
 	 * Code to execute when leaving a panel (oldCard is the panel number)
-	 * 
+	 *
 	 */
 	private void onLeavingPanel(int panelNo) {
 		if (panelNo == MainTab.LIST_CARD) { // Leaving the list view
@@ -268,7 +268,7 @@
 
 	/**
 	 * Code to execute when entering a panel (getSelectedItem() is the panel number)
-	 * 
+	 *
 	 */
 	private void onEnteringPanel(int panelNo) {
 		MyLocale.setSIPOff();
@@ -341,7 +341,7 @@
 
 	/**
 	 * this is called from MovingMap Cache context menu
-	 * 
+	 *
 	 * @param chi
 	 *            ,
 	 *            the CacheHolder for the Cache to switch to
@@ -349,14 +349,19 @@
 	 *            1=DetailsPanel 2=Description Panel
 	 */
 	public void openPanel(CacheHolder chi, int panelNo) {
-		// To change cache we need to be in panel LIST_CARD
-		onLeavingPanel(oldCard);
-		onEnteringPanel(LIST_CARD);
-		int row = profile.getCacheIndex(chi.getWayPoint());
-		tbP.selectRow(row);
+		// oldCard could have been DETAILS_CARD or GOTO_CARD
+		// on DETAILS_CARD changes already should have been applied before entering map
+		// on GOTO_CARD there is no action
+		// onLeavingPanel(oldCard);
+
+		// do we really need this actions ???
+		// onEnteringPanel(LIST_CARD);
+
+		// to switch to cache selected on map we do action as if leaving LIST_CARD
+		tbP.selectRow(profile.getCacheIndex(chi.getWayPoint()));
+		onLeavingPanel(LIST_CARD);
+
 		if (panelNo == DETAILS_CARD) {
-			ch = chi; // possibly wrong (old) detail if map is called
-			// directly
 			onEnteringPanel(DETAILS_CARD);
 			select(detP);
 		} else if (panelNo == DESCRIPTION_CARD) {
@@ -369,7 +374,7 @@
 	/**
 	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to offer the user the possibility of
 	 * entering an new waypoint at a given position. pCh must already been preset with a valid CacheHolder object
-	 * 
+	 *
 	 * @param pCh
 	 */
 	public void newWaypoint(CacheHolder pCh) {
@@ -425,7 +430,7 @@
 
 	/**
 	 * sets posCircle Lat/Lon to centerTo
-	 * 
+	 *
 	 * @param centerTo
 	 *            true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the
 	 *            loaded map
@@ -433,6 +438,7 @@
 	 */
 	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
 		try {
+			onLeavingPanel(oldCard); // mainly for doing changes from DETAILS_CARD
 			if (!centerTo.isValid()) {
 				(new MessageBox(&quot;Error&quot;, &quot;No valid coordinates&quot;, FormBase.OKB)).execute();
 				return;
@@ -481,7 +487,7 @@
 
 	/**
 	 * Save the index file
-	 * 
+	 *
 	 * @param askForConfirmation
 	 *            is ignored, old: If true, the save can be cancelled by user
 	 */

Modified: branches/r1.2/src/CacheWolf/Matrix.java
===================================================================
--- branches/r1.2/src/CacheWolf/Matrix.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/Matrix.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -36,8 +36,8 @@
 	
 	public Matrix (Matrix srcMatrix){
 		matrix = new double[srcMatrix.matrix.length][srcMatrix.matrix[0].length];
-		for (int i = 0; i &lt; srcMatrix.matrix.length; i++)
-			for (int j = 0; j &lt; srcMatrix.matrix[i].length; j++)
+		for (int i = 0; i &lt; srcMatrix.matrix.length; i++)
+			for (int j = 0; j &lt; srcMatrix.matrix[i].length; j++)
 				matrix[i][j] = srcMatrix.matrix[i][j];
 	}
 	
@@ -59,12 +59,12 @@
 	*	Method to calculate the row column product of two matrices.
 	*	Is used by the Multiply method.
 	*/
-	private double calculateRowColumnProduct(double[][] A, int row, double[][] B, int col){
-		double product = 0;
+	private double calculateRowColumnProduct(double[][] A, int row, double[][] B, int col){
+		double product = 0;
 		for(int i = 0; i &lt; A[row].length; i++){
 			product +=A[row][i]*B[i][col];
-		}
-		return product;
+		}
+		return product;
 	}
 	
 	public void MultiplyByScalar (double f) {
@@ -90,13 +90,13 @@
 	public void Transpose(){
 		
 		double m[][] = new double[matrix[0].length][matrix.length];
-		for (int i = 0; i &lt; matrix.length; i++)
-			for (int j = 0; j &lt; matrix[i].length; j++)
+		for (int i = 0; i &lt; matrix.length; i++)
+			for (int j = 0; j &lt; matrix[i].length; j++)
 				m[j][i] = matrix[i][j];
 			
 		matrix = new double[m.length][m[0].length];
-		for (int i = 0; i &lt; m.length; i++)
-			for (int j = 0; j &lt; m[i].length; j++)
+		for (int i = 0; i &lt; m.length; i++)
+			for (int j = 0; j &lt; m[i].length; j++)
 				matrix[i][j] = m[i][j];
 	}
 	
@@ -104,21 +104,21 @@
 	*	private version of the Transpose method.
 	*	used internally in this class
 	*/
-	private double[][] Transpose2(double[][] a) {
-		
-		double m[][] = new double[a[0].length][a.length];
-
-		for (int i = 0; i &lt; a.length; i++)
-			for (int j = 0; j &lt; a[i].length; j++)
-				m[j][i] = a[i][j];
-		return m;
+	private double[][] Transpose2(double[][] a) {
+		
+		double m[][] = new double[a[0].length][a.length];
+
+		for (int i = 0; i &lt; a.length; i++)
+			for (int j = 0; j &lt; a[i].length; j++)
+				m[j][i] = a[i][j];
+		return m;
 	}
 	
 	/**
 	*	Method to display the contents of a matrix.
 	*/
 	public void DumpMatrix(){
-		for (int i = 0; i &lt; matrix.length; i++)
+		for (int i = 0; i &lt; matrix.length; i++)
 			for (int j = 0; j &lt; matrix[i].length; j++)
 				Global.getPref().log(&quot;[ &quot;+i+ &quot; &quot; + j + &quot; ] &quot; + matrix[i][j]);
 	}
@@ -126,61 +126,61 @@
 	/**
 	*	Method used to help calculate determinate
 	*/
-	private double[][] UpperTriangle(double[][] m) {
-		double f1 = 0;
-		double temp = 0;
-		int tms = m.length; // get This Matrix Size (could be smaller than
-							// global)
-		int v = 1;
-		iDF = 1;
-
-		for (int col = 0; col &lt; tms - 1; col++) {
-			for (int row = col + 1; row &lt; tms; row++) {
-				v = 1;
-				outahere: while (m[col][col] == 0) // check if 0 in diagonal
-				{ // if so switch until not
-					if (col + v &gt;= tms) // check if switched all rows
-					{
-						iDF = 0;
-						break outahere;
-					} else {
-						for (int c = 0; c &lt; tms; c++) {
-							temp = m[col][c];
-							m[col][c] = m[col + v][c]; // switch rows
-							m[col + v][c] = temp;
-						}
-						v++; // count row switchs
-						iDF = iDF * -1; // each switch changes determinant
-										// factor
-					}
-				}
-				if (m[col][col] != 0) {
-					try {
-						f1 = (-1) * m[row][col] / m[col][col];
-						for (int i = col; i &lt; tms; i++) {
-							m[row][i] = f1 * m[col][i] + m[row][i];
-						}
-					} catch (Exception e) {
-						Global.getPref().log(&quot;Still Here!!!&quot;);
-					}
-				}
-			}
-		}
-		return m;
+	private double[][] UpperTriangle(double[][] m) {
+		double f1 = 0;
+		double temp = 0;
+		int tms = m.length; // get This Matrix Size (could be smaller than
+							// global)
+		int v = 1;
+		iDF = 1;
+
+		for (int col = 0; col &lt; tms - 1; col++) {
+			for (int row = col + 1; row &lt; tms; row++) {
+				v = 1;
+				outahere: while (m[col][col] == 0) // check if 0 in diagonal
+				{ // if so switch until not
+					if (col + v &gt;= tms) // check if switched all rows
+					{
+						iDF = 0;
+						break outahere;
+					} else {
+						for (int c = 0; c &lt; tms; c++) {
+							temp = m[col][c];
+							m[col][c] = m[col + v][c]; // switch rows
+							m[col + v][c] = temp;
+						}
+						v++; // count row switchs
+						iDF = iDF * -1; // each switch changes determinant
+										// factor
+					}
+				}
+				if (m[col][col] != 0) {
+					try {
+						f1 = (-1) * m[row][col] / m[col][col];
+						for (int i = col; i &lt; tms; i++) {
+							m[row][i] = f1 * m[col][i] + m[row][i];
+						}
+					} catch (Exception e) {
+						Global.getPref().log(&quot;Still Here!!!&quot;);
+					}
+				}
+			}
+		}
+		return m;
 	}
 	
 	/**
 	*	Method to calculate the determinate of a matrix
 	*/
-	public double Determinant(double[][] pMatrix) {
-		int tms = pMatrix.length;
-		double det = 1;
-		pMatrix = UpperTriangle(pMatrix);
-		for (int i = 0; i &lt; tms; i++) {
-			det = det * pMatrix[i][i];
-		} // multiply down diagonal
-		det = det * iDF; // adjust w/ determinant factor
-		return det;
+	public double Determinant(double[][] pMatrix) {
+		int tms = pMatrix.length;
+		double det = 1;
+		pMatrix = UpperTriangle(pMatrix);
+		for (int i = 0; i &lt; tms; i++) {
+			det = det * pMatrix[i][i];
+		} // multiply down diagonal
+		det = det * iDF; // adjust w/ determinant factor
+		return det;
 	}
 	
 	
@@ -189,68 +189,68 @@
 	*	Method to calculate the inverse of this matrix.
 	*	The result is stored in this matrix!
 	*/
-	public void Inverse() {
-		// Formula used to Calculate Inverse:
-		// inv(A) = 1/det(A) * adj(A)
-		
-		int tms = matrix.length;
-
-		double m[][] = new double[tms][tms];
-		double mm[][] = Adjoint(matrix);
-
-		double det = Determinant(matrix);
-		double dd = 0;
-
-		if (det == 0) {
-			Global.getPref().log(&quot;Determinant Equals 0, Not Invertible.&quot;);
-		} else {
-			dd = 1 / det;
-		}
-		for (int i = 0; i &lt; tms; i++)
-			for (int j = 0; j &lt; tms; j++) {
-				m[i][j] = dd * mm[i][j];
+	public void Inverse() {
+		// Formula used to Calculate Inverse:
+		// inv(A) = 1/det(A) * adj(A)
+		
+		int tms = matrix.length;
+
+		double m[][] = new double[tms][tms];
+		double mm[][] = Adjoint(matrix);
+
+		double det = Determinant(matrix);
+		double dd = 0;
+
+		if (det == 0) {
+			Global.getPref().log(&quot;Determinant Equals 0, Not Invertible.&quot;);
+		} else {
+			dd = 1 / det;
+		}
+		for (int i = 0; i &lt; tms; i++)
+			for (int j = 0; j &lt; tms; j++) {
+				m[i][j] = dd * mm[i][j];
 			}
 			
 		//Store back results
 		matrix = new double[m.length][m[0].length];
-		for (int i = 0; i &lt; m.length; i++)
-			for (int j = 0; j &lt; m[i].length; j++)
-				matrix[i][j] = m[i][j];
+		for (int i = 0; i &lt; m.length; i++)
+			for (int j = 0; j &lt; m[i].length; j++)
+				matrix[i][j] = m[i][j];
 	}
 	
 	/**
 	*	Method to calculate the adjoint of a matrix.
 	*	Required to calculate the inverse of a matrix.
 	*/
-	private double[][] Adjoint(double[][] a) {
-		int tms = a.length;
-
-		double m[][] = new double[tms][tms];
-
-		int ii, jj, ia, ja;
-		double det;
-
-		for (int i = 0; i &lt; tms; i++)
-			for (int j = 0; j &lt; tms; j++) {
-				ia = ja = 0;
-				double ap[][] = new double[tms - 1][tms - 1];
-				for (ii = 0; ii &lt; tms; ii++) {
-					for (jj = 0; jj &lt; tms; jj++) {
-						if ((ii != i) &amp;&amp; (jj != j)) {
-							ap[ia][ja] = a[ii][jj];
-							ja++;
-						}
-					}
-					if ((ii != i) &amp;&amp; (jj != j)) {
-						ia++;
-					}
-					ja = 0;
-				}
-				det = Determinant(ap);
-				m[i][j] = java.lang.Math.pow(-1, i + j) * det;
-			}
-		m = Transpose2(m);
-		return m;
+	private double[][] Adjoint(double[][] a) {
+		int tms = a.length;
+
+		double m[][] = new double[tms][tms];
+
+		int ii, jj, ia, ja;
+		double det;
+
+		for (int i = 0; i &lt; tms; i++)
+			for (int j = 0; j &lt; tms; j++) {
+				ia = ja = 0;
+				double ap[][] = new double[tms - 1][tms - 1];
+				for (ii = 0; ii &lt; tms; ii++) {
+					for (jj = 0; jj &lt; tms; jj++) {
+						if ((ii != i) &amp;&amp; (jj != j)) {
+							ap[ia][ja] = a[ii][jj];
+							ja++;
+						}
+					}
+					if ((ii != i) &amp;&amp; (jj != j)) {
+						ia++;
+					}
+					ja = 0;
+				}
+				det = Determinant(ap);
+				m[i][j] = java.lang.Math.pow(-1, i + j) * det;
+			}
+		m = Transpose2(m);
+		return m;
 	}
 	
 	/**

Modified: branches/r1.2/src/CacheWolf/Preferences.java
===================================================================
--- branches/r1.2/src/CacheWolf/Preferences.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/Preferences.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -90,7 +90,7 @@
 
 	/**
 	 * Singleton pattern - return reference to Preferences
-	 * 
+	 *
 	 * @return Singleton Preferences object
 	 */
 	public static Preferences getPrefObject() {
@@ -108,7 +108,7 @@
 	 * Call this method to set the path of the config file &lt;br&gt;
 	 * If you call it with null it defaults to [program-dir]/pref.xml if p is a directory &quot;pref.xml&quot; will automatically
 	 * appended
-	 * 
+	 *
 	 * @param p
 	 */
 	public void setPathToConfigFile(String p) {
@@ -276,15 +276,14 @@
 	 * Max. length for Garmin waypoint names (for etrex which can only accept 6 chars)
 	 */
 	public int garminMaxLen = 0;
-	/** OC true = alle neu Laden false = wenn &#196;nderungsdatum neuer */
+	/** OC true = alle neu Laden false = wenn ?nderungsdatum neuer */
 	public boolean downloadAllOC = false;
 	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
 	/**
 	 * The currently used centre point, can be different from the profile's centrepoint. This is used for spidering
 	 */
 	private CWPoint curCentrePt = new CWPoint();
-	/** True if a login screen is displayed on each spider operation */
-	public boolean forceLogin = true;
+	public boolean switchGCLanguageToEnglish = false;
 	/** True if the goto panel is North centered */
 	public boolean northCenteredGoto = true;
 	/** If not null, a customs map path has been specified by the user */
@@ -343,7 +342,7 @@
 	/** Selected Size of map tiles */
 	public int mapTileSize = 1;
 	/** How many should maptiles overlap */
-	public int mapOverlapping = 100;
+	public int mapOverlapping = 2;
 	/** Width and height of free defined tile size */
 	public int tilewidth;
 	public int tileheight;
@@ -362,11 +361,11 @@
 	// ////////////////////////////////////////////
 	/**
 	 * The debug switch (Can be used to activate dormant code) by adding the line:
-	 * 
+	 *
 	 * &lt;pre&gt;
 	 * &lt;debug value=&quot;true&quot; /&gt;
 	 * &lt;/pre&gt;
-	 * 
+	 *
 	 * to the pref.xml file.
 	 */
 	public boolean debug = false;
@@ -422,7 +421,7 @@
 
 	/**
 	 * Tries to find a executable browser return &quot;&quot; if no browser found
-	 * 
+	 *
 	 * @return
 	 */
 	private String getDefaultBrowser() {
@@ -609,7 +608,6 @@
 			northCenteredGoto = Boolean.valueOf(atts.getValue(&quot;northcentered&quot;)).booleanValue();
 		} else if (name.equals(&quot;spider&quot;)) {
 			doNotGetFound = !Boolean.valueOf(atts.getValue(&quot;getFinds&quot;)).booleanValue();
-			forceLogin = Boolean.valueOf(atts.getValue(&quot;forcelogin&quot;)).booleanValue();
 			checkLog = Boolean.valueOf(atts.getValue(&quot;checkLog&quot;)).booleanValue();
 			tmp = atts.getValue(&quot;checkTBs&quot;);
 			if (tmp != null)
@@ -710,7 +708,7 @@
 			mapTileSize = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;overlapping&quot;);
 			if (tmp == null || tmp.length() == 0)
-				tmp = &quot;100&quot;;
+				tmp = &quot;2&quot;;
 			mapOverlapping = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;tilewidth&quot;);
 			tilewidth = (tmp != null &amp;&amp; tmp.length() &gt; 0) ? Convert.parseInt(tmp) : 0;
@@ -861,7 +859,6 @@
 			outp.print(&quot;    &lt;opencaching lastSite=\&quot;&quot; + lastOCSite + &quot;\&quot; downloadMissing=\&quot;&quot; + SafeXML.strxmlencode(downloadAllOC) + &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;location lat=\&quot;&quot; + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + &quot;\&quot; long=\&quot;&quot; + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;spider&quot; //
-					+ &quot; forcelogin=\&quot;&quot; + SafeXML.strxmlencode(forceLogin) + &quot;\&quot;&quot; //
 					+ &quot; spiderUpdates=\&quot;&quot; + SafeXML.strxmlencode(spiderUpdates) + &quot;\&quot;&quot; //
 					+ &quot; checkLog=\&quot;&quot; + SafeXML.strxmlencode(checkLog) + &quot;\&quot;&quot; //
 					+ &quot; checkTBs=\&quot;&quot; + SafeXML.strxmlencode(checkTBs) + &quot;\&quot;&quot; //
@@ -926,7 +923,7 @@
 
 	/**
 	 * custom = set by the user
-	 * 
+	 *
 	 * @return custom Maps Path, null if not set
 	 */
 	public String getCustomMapsPath() {
@@ -983,8 +980,8 @@
 	 * gets the path to the calibrated maps it first tries if there are manually imported maps in
 	 * &lt;baseDir&gt;/maps/standard then it tries the legacy dir: &lt;program-dir&gt;/maps In case in both locations are no
 	 * .wfl-files it returns &lt;baseDir&gt;/maps/expedia - the place where the automatically downloaded maps are placed.
-	 * 
-	 * 
+	 *
+	 *
 	 */
 	public String getMapLoadPath() {
 		saveCustomMapsPath(getMapLoadPathInternal());
@@ -1100,7 +1097,7 @@
 	/**
 	 * tries to get the home data dir of the user e.g. &quot;c:\documents and...\&lt;user&gt;\my documents&quot; or &quot;/home/&lt;user&gt;&quot; in
 	 * linux if none could be identified, &quot;/&quot; is returned.
-	 * 
+	 *
 	 * @return
 	 */
 	public String getHomeDir() {
@@ -1139,7 +1136,7 @@
 
 	/**
 	 * Open Profile selector screen
-	 * 
+	 *
 	 * @param prof
 	 * @param showProfileSelector
 	 * @return True if a profile was selected
@@ -1210,7 +1207,7 @@
 			return; // no select
 		// check selection
 		if (lastProfile.equals(f.newSelectedProfile)) {
-			// aktives Profil kann nicht gel&#246;scht / umbenannt werden;
+			// aktives Profil kann nicht gel?scht / umbenannt werden;
 			new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(ErrorMsgActive, &quot;[Profile active...]&quot;), FormBase.MBOK).execute();
 		} else {
 			boolean err = true;
@@ -1224,7 +1221,7 @@
 				p.dataDir = absoluteBaseDir + f.newSelectedProfile + &quot;/&quot;;
 				p.readIndex();
 				String mapsPath = absoluteBaseDir + &quot;maps&quot; + p.getRelativeCustomMapsPath();
-				int answer = new MessageBox(&quot;&quot;, mapsPath + &quot; &quot; + MyLocale.getMsg(143, &quot;l&#246;schen ?&quot;), FormBase.MBYESNO).execute();
+				int answer = new MessageBox(&quot;&quot;, mapsPath + &quot; &quot; + MyLocale.getMsg(143, &quot;l?schen ?&quot;), FormBase.MBYESNO).execute();
 				if (answer == 1) {
 					deleteDirectory(new FileBugfix(mapsPath));
 				}
@@ -1266,13 +1263,13 @@
 	/**
 	 * Method to log messages to a file called log.txt It will always append to an existing file. To show the message on
 	 * the console, the global variable debug must be set. This can be done by adding
-	 * 
+	 *
 	 * &lt;pre&gt;
 	 * &lt;debug value=&quot;true&quot;&gt;
 	 * &lt;/pre&gt;
-	 * 
+	 *
 	 * to the pref.xml file
-	 * 
+	 *
 	 * @param text
 	 *            to log
 	 */
@@ -1305,7 +1302,7 @@
 
 	/**
 	 * Log an exception to the log file with or without a stack trace
-	 * 
+	 *
 	 * @param text
 	 *            Optional message (Can be empty string)
 	 * @param e
@@ -1314,11 +1311,11 @@
 	 *            If true and the debug switch is true, the stack trace is appended to the log The debug switch can be
 	 *            set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file or by
 	 *            manually setting it (i.e. in BE versions or RC versions) by including the line
-	 * 
+	 *
 	 *            &lt;pre&gt;
 	 * Global.getPref().debug = true;
 	 * &lt;/pre&gt;
-	 * 
+	 *
 	 *            in Version.getRelease()
 	 */
 	public void log(String text, Throwable e, boolean withStackTrace) {
@@ -1337,7 +1334,7 @@
 	/**
 	 * Log an exception to the log file without a stack trace, i.e. where a stack trace is not needed because the
 	 * location/cause of the error is clear
-	 * 
+	 *
 	 * @param message
 	 *            Optional message (Can be empty string)
 	 * @param e
@@ -1390,7 +1387,7 @@
 	/**
 	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is saved in the
 	 * preferences.
-	 * 
+	 *
 	 * @param filterID
 	 *            ID of the filter to check
 	 * @return True or false
@@ -1402,7 +1399,7 @@
 	/**
 	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, so it may be resaved
 	 * under another ID.
-	 * 
+	 *
 	 * @param filterID
 	 *            ID of the FilterData object
 	 * @return FilterData object
@@ -1414,7 +1411,7 @@
 	/**
 	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the given ID, the old object
 	 * is removed and the new one is set at its place.
-	 * 
+	 *
 	 * @param filterID
 	 *            ID to associate with the filter object
 	 * @param filter
@@ -1427,7 +1424,7 @@
 	/**
 	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object exists, nothing
 	 * happens.
-	 * 
+	 *
 	 * @param filterID
 	 *            ID of FilterData object to remove
 	 */
@@ -1437,7 +1434,7 @@
 
 	/**
 	 * Returns a alphabetically sorted array of ID of saved FilterData objects.
-	 * 
+	 *
 	 * @return Array of IDs
 	 */
 	public String[] getFilterIDs() {
@@ -1502,6 +1499,7 @@
 		if (oldLanguageCtl.length() != 0)
 			try {
 				UrlFetcher.fetch(oldLanguageCtl);
+				switchGCLanguageToEnglish=true;
 			} catch (IOException e) {
 				// dann halt nicht
 			}

Modified: branches/r1.2/src/CacheWolf/Profile.java
===================================================================
--- branches/r1.2/src/CacheWolf/Profile.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/Profile.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -574,13 +574,36 @@
 		return &quot;Profile: Name=&quot; + name + &quot;\nCentre=&quot; + centre.toString() + &quot;\ndataDir=&quot; + dataDir + &quot;\nlastSyncOC=&quot; + getLast_sync_opencaching() + &quot;\ndistOC=&quot; + getDistOC() + &quot;\ndistGC=&quot; + getDistGC();
 	}
 
+	/**
+	 * Sets the selection state for all caches to the given state &lt;code&gt;selectStatus&lt;/code&gt;.
+	 * There is a little distinction for the &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; case:&lt;br&gt;
+	 * selectStatus &lt;code&gt;true&lt;/code&gt;: All &lt;i&gt;visible&lt;/i&gt; caches are checked, and their addi
+	 * wpts, regardless if they are visible or not.&lt;br&gt;
+	 * selectStatus &lt;code&gt;false&lt;/code&gt;: All caches are unchecked, regardless if they are visible 
+	 * or not. 
+	 * @param selectStatus If &lt;code&gt;true&lt;/code&gt; all caches are checked, if &lt;code&gt;false&lt;/code&gt;
+	 * all caches are unchecked.
+	 */
 	public void setSelectForAll(boolean selectStatus) {
+		CacheHolder ch;
 		selectionChanged = true;
-		CacheHolder ch;
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
-			if (ch.isVisible())
+			if (selectStatus) {
+				if (ch.isVisible()) {
+					ch.is_Checked = selectStatus; // set the ceckbox also for addi wpts
+					if (ch.hasAddiWpt()) {
+						CacheHolder addiWpt;
+						int addiCount = ch.addiWpts.getCount();
+						for (int j = 0; j &lt; addiCount; j++) {
+							addiWpt = (CacheHolder) ch.addiWpts.get(j);
+							addiWpt.is_Checked = selectStatus;
+						}
+					}					
+				}
+			} else /* selectStatus==false */ {
 				ch.is_Checked = selectStatus;
+			}
 		}
 	}
 

Modified: branches/r1.2/src/CacheWolf/UrlFetcher.java
===================================================================
--- branches/r1.2/src/CacheWolf/UrlFetcher.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/UrlFetcher.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -77,8 +77,8 @@
 	private static void initPermanentRequestorProperty() {
 		permanentRequestorProperties = new PropertyList();
 		permanentRequestorProperties.add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-		// permanentRequestorProperties.add(&quot;Connection&quot;, &quot;close&quot;);
-		permanentRequestorProperties.add(&quot;Connection&quot;, &quot;keep-alive&quot;);
+		permanentRequestorProperties.add(&quot;Connection&quot;, &quot;close&quot;);
+		// permanentRequestorProperties.add(&quot;Connection&quot;, &quot;keep-alive&quot;);
 	}
 
 	public static void setPermanentRequestorProperty(String name, String property) {
@@ -109,9 +109,13 @@
 	}
 
 	public static void fetchDataFile(String address, String target) throws IOException {
-		FileOutputStream outp = new FileOutputStream(new File(target));
+		FileOutputStream outp = null;
+		try {
+		outp = new FileOutputStream(new File(target));
 		outp.write(fetchByteArray(address).toBytes());
-		outp.close();
+		} finally {
+		if (outp != null) outp.close();
+		}
 	}
 
 	/**
@@ -133,7 +137,7 @@
 				i = i - 1;
 			}
 			realUrl = urltmp;
-			if (!urltmp.startsWith(&quot;http&quot;)) {
+			if (!( urltmp.startsWith(&quot;http&quot;) || urltmp.startsWith(&quot;https&quot;) )) {
 				url = FileBase.fixupPath(url);
 				String uu = url.toLowerCase();
 				String host;
@@ -145,7 +149,7 @@
 				}
 				if (!urltmp.startsWith(&quot;/&quot;))
 					host = host + &quot;/&quot;;
-				urltmp = &quot;<A HREF="http://">http://</A>&quot; + host + urltmp;
+				urltmp = &quot;<A HREF="http://">http://</A>&quot; + host + urltmp; // TODO https?
 			}
 			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
@@ -226,7 +230,7 @@
 	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation&lt;br&gt;
 	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the
 	 * server expects, what encoding you must use.
-	 * 
+	 *
 	 * @param cc
 	 * @return
 	 * @throws IOException
@@ -246,7 +250,7 @@
 	/**
 	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all
 	 * chars to be &lt; 127. This method is mainly copied from there
-	 * 
+	 *
 	 * @param url
 	 *            The unencoded URL.
 	 * @param spaceToPlus

Modified: branches/r1.2/src/CacheWolf/Version.java
===================================================================
--- branches/r1.2/src/CacheWolf/Version.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/Version.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -43,7 +43,7 @@
 	static final int VER_MINOR = 2;
 	static final String VER_SVN =&quot;$LastChangedRevision$&quot;; // the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	static final int SVN_REVISION = Common.parseInt(VER_SVN.substring(VER_SVN.indexOf(&quot; &quot;)+1, VER_SVN.lastIndexOf(&quot; &quot;)));
-	static final int VERSION_TYPE = 0;
+	static final int VERSION_TYPE = 3;
 	public static final String VERSION_TYPES(int i) {
 		if (i==0) return MyLocale.getMsg(7000,&quot;Release&quot;);
 		if (i==1) return MyLocale.getMsg(7001,&quot;Release candidate&quot;);
@@ -61,8 +61,8 @@
 	}
 
 	public static String getReleaseDetailed() {
-		// habe die SVN-Nummer doch aus der Anzeige erstmal wieder herausgenommen, weil es in einem final Release doch recht seltsam auss&#239;&#191;&#189;he.
-		// Sinnvoll w&#239;&#191;&#189;re daher vielleicht, eine Methode getReleaseDatail, die die SVN-Versionnummer mit angibt und z.B. im &quot;&#239;&#191;&#189;ber&quot;-Dialog angezeigt werden k&#239;&#191;&#189;nnte.
+		// habe die SVN-Nummer doch aus der Anzeige erstmal wieder herausgenommen, weil es in einem final Release doch recht seltsam auss?he.
+		// Sinnvoll w?re daher vielleicht, eine Methode getReleaseDatail, die die SVN-Versionnummer mit angibt und z.B. im &quot;?ber&quot;-Dialog angezeigt werden k?nnte.
 		return getRelease() + &quot; &quot; + VERSION_TYPES(VERSION_TYPE);
 	}
 
@@ -124,7 +124,6 @@
 	 * @param url
 	 * @return: 1 = newer Version available, 0 = this is up to date, 3 = check failed
 	 */
-
 	private static int checkVersion(Properties curvers, String prefix, int t) {
 		try {
 			int curvmaj = Convert.toInt(curvers.getProperty(prefix + &quot;VersionMajor&quot;, &quot;0&quot;));

Modified: branches/r1.2/src/CacheWolf/exp/KMLExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/KMLExporter.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/exp/KMLExporter.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -196,7 +196,7 @@
 		// fill structure with data from cacheDB
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			// TODO Das Argument nach STring zu casten gef&#239;&#191;&#189;llt mir nicht ganz...
+			// TODO Das Argument nach STring zu casten gef?llt mir nicht ganz...
 			if (ch.isVisible() &amp;&amp; !ch.isAddiWpt()) {
 				if (ch.is_found()) {
 					tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));

Modified: branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -139,7 +139,7 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param number
 	 * @param infB
 	 * @return true, if some change was made to the cacheDB
@@ -630,6 +630,7 @@
 		}
 		if (name.equals(&quot;latitude&quot;)) {
 			holder.setPos(new TrackPoint(Common.parseDouble(strData), longitude));
+			holder.setUpdated(false); // todo : correct definition of usage for this 
 			return;
 		}
 		if (name.equals(&quot;difficulty&quot;)) {
@@ -670,8 +671,9 @@
 				linebraek = &quot;&lt;br&gt;\n&quot;;
 			else
 				linebraek = &quot;\n&quot;;
-
-			// this is set by &quot;hint&quot; a few lines down: if a long description is already updated, then this one is likely to be in another language
+			// if a long description has been entered in this run (==holder.cache_updated is true), 
+			// then this one is added (for another language)
+			// otherwise all previous descriptions will be overwritten ( or there are none yet) 
 			if (holder.is_updated())
 				holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + &quot;:&quot; + linebraek + strData + linebraek;
 			else
@@ -679,7 +681,7 @@
 			return;
 		}
 
-		if (name.equals(&quot;desc&quot;)) { // &lt;/desc&gt;
+		if (name.equals(&quot;desc&quot;)) { // &lt;/desc&gt; 
 			if (isHTML)
 				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
 			else
@@ -696,7 +698,12 @@
 				holder.getCacheDetails(false).Hints += linebreak + &quot;[&quot; + processingDescLang + &quot;:]&quot; + linebreak + Common.rot13(strData) + linebreak;
 			else
 				holder.getCacheDetails(false).Hints = &quot;[&quot; + processingDescLang + &quot;:]&quot; + linebreak + Common.rot13(strData) + linebreak;
-			holder.setUpdated(true); // remark: this is used in &quot;shortdesc&quot; to decide weather the description should be appended or replaced
+			// remark: 
+			// holder.cache_updated will be set to true
+			// after the subtag-infos of tag &lt;cachedesc&gt; have been entered 
+			// (ending with the subtag &lt;/hint&gt;) 
+			// to possibly add the &lt;cachedesc&gt; for an additional language
+			holder.setUpdated(true);
 			return;
 		}
 	}

Modified: branches/r1.2/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/SpiderGC.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/imp/SpiderGC.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -82,6 +82,8 @@
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
+import org.json.*;
+
 /**
  * Class to spider caches from gc.com
  */
@@ -164,7 +166,7 @@
 	private static Regex RexPropType;
 	private static Regex RexPropDTS;
 	private static Regex RexPropOwn;
-	private static Regex RexLogBlock;
+	private static Regex RexUserToken;
 	private static Extractor exSingleLog;
 	private static Extractor exIcon;
 	private static Extractor exNameTemp;
@@ -991,7 +993,7 @@
 				break;
 			final CacheHolder ch = (CacheHolder) e.nextElement();
 			infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + ch.getWayPoint() + &quot; (&quot; + (cachesToLoad.size() + j) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
-			final int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
+			final int test = spiderSingle(cacheDB.getIndex(ch), infB, loadAllLogs);
 			if (test == SPIDER_CANCEL) {
 				break;
 			} else {
@@ -1008,11 +1010,11 @@
 
 	/**
 	 * Method to spider a single cache. It assumes a login has already been performed!
-	 * 
+	 *
 	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with
 	 *         next cache
 	 */
-	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin, boolean loadAllLogs) {
+	public int spiderSingle(int number, InfoBox pInfB, boolean loadAllLogs) {
 		int ret = -1;
 		this.infB = pInfB;
 		final CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
@@ -1055,7 +1057,7 @@
 
 	/**
 	 * Fetch the coordinates of a waypoint from GC
-	 * 
+	 *
 	 * @param wayPoint
 	 *            the name of the waypoint
 	 * @return the cache coordinates
@@ -1085,207 +1087,88 @@
 			return &quot;????&quot;;
 		}
 	} // getCacheCoordinates
-
-	/**
-	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the
-	 * login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
-	 */
 	private boolean login() {
-		if (loggedIn &amp;&amp; !pref.forceLogin) {
+		if (loggedIn &amp;&amp; !pref.switchGCLanguageToEnglish) {
 			return true;
 		}
+
 		if (pref.userID.length() &gt; 0) {
 			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
 			loggedIn = switchToEnglish();
 			if (loggedIn)
 				return true;
 			else {
-				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences | Einstellungen.\nsee <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A>&quot;, FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5523, &quot;Login error!&quot;), &quot;Die userID ist vermutlich nicht mehr g&#252;ltig. Siehe <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A> !&quot;, FormBase.OKB)).execute();
 				return false;
 			}
-		} else {
-			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
-			if (true) {
-				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences| Einstellungen.\nsee <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A>&quot;, FormBase.OKB)).execute();
-				return false; // until SSL/https works
-			}
 		}
-		loggedIn = false;
-		String loginPage, loginPageUrl, loginSuccess;
-		try {
-			loginPageUrl = p.getProp(&quot;loginPage&quot;);
-			loginSuccess = p.getProp(&quot;loginSuccess&quot;);
-		} catch (final Exception ex) { // Tag not found in spider.def
+		else {
+			(new MessageBox(MyLocale.getMsg(5523, &quot;Login error!&quot;), &quot;Siehe <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A> !&quot;, FormBase.OKB)).execute();
 			return false;
 		}
+	}
 
-		// **0 Get password
-		String passwort = pref.password;
-		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, &quot;Password&quot;), MyLocale.getMsg(5505, &quot;Enter Password&quot;), InfoBox.INPUT);
-		localInfB.feedback.setText(passwort);
-		localInfB.feedback.isPassword = true;
-		int code = FormBase.IDOK;
-		if (passwort.equals(&quot;&quot;)) {
-			code = localInfB.execute();
-			passwort = localInfB.getInput();
-		}
-		localInfB.close(0);
-		if (code != FormBase.IDOK)
-			return false;
+	private boolean getSessionIdAndSetCookie(String userId) {
 
-		// **1 now we have user and password for login
-		localInfB = new InfoBox(MyLocale.getMsg(5507, &quot;Status&quot;), MyLocale.getMsg(5508, &quot;Logging in...&quot;));
-		localInfB.exec();
-		try {
-			loginPage = UrlFetcher.fetch(loginPageUrl); // <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
-			if (loginPage.equals(&quot;&quot;)) {
-				localInfB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
-				pref.log(&quot;[login]:Could not fetch: gc.com login page &quot; + loginPageUrl, null);
-				return false;
+		PropertyList pl = UrlFetcher.getDocumentProperties();
+		String docprops = &quot;&quot;;
+		for (int i = 0; i &lt; pl.size(); i++) {
+			final Property p = (Property) pl.get(i);
+			if (p.name.equalsIgnoreCase(&quot;Set-Cookie&quot;)) {
+				docprops += p.value;
 			}
-		} catch (final Exception ex) {
-			localInfB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
-			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
+		}
+
+		final Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
+		rexCookieSession.search(docprops);
+		if (rexCookieSession.didMatch()) {
+			cookie = &quot;ASP.NET_SessionId=&quot; + rexCookieSession.stringMatched(1);
+		} else {
+			pref.log(&quot;[login]:SessionID not found.&quot;, null);
 			return false;
 		}
 
-		// **2 now we can check the loginpage if logged in else log in
-		if (!localInfB.isClosed) {
-			if (loginPage.indexOf(loginSuccess) &gt; 0) {
-				if (loginPage.indexOf(pref.myAlias) &gt; 0) {
-					loggedIn = true;
-					// assume language is already set to EN
-					pref.log(&quot;[login]:Already logged in as &quot; + pref.myAlias);
-				} else {
-					// it is another user, whom we should logout
-					try {
-						loginPage = UrlFetcher.fetch(&quot;<A HREF="http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y">http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y</A>&quot;);
-					} catch (final Exception ex) {
-						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
-						pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
-						return false;
-					}
-
-				}
+		if (userId.length() == 0) {
+			final Regex rexCookieID = new Regex(&quot;(?i)userid=(.*?);.*&quot;);
+			rexCookieID.search(docprops);
+			if (rexCookieID.didMatch()) {
+				cookie += &quot;; userid=&quot; + rexCookieID.stringMatched(1);
+				// set the user id in user pref
+				pref.userID = rexCookieID.stringMatched(1);
+				pref.savePreferences();
+			} else {
+				pref.log(&quot;[login]:userID not found.&quot;, null);
+				return false;
 			}
-			if (!loggedIn) {
-				try {
-					final Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-					String viewstate = &quot;&quot;;
-					rexViewstate.search(loginPage);
-					if (rexViewstate.didMatch()) {
-						viewstate = rexViewstate.stringMatched(1);
-					} else {
-						localInfB.close(0);
-						pref.log(&quot;[login]:__VIEWSTATE not found (before login): no login possible.&quot;, null);
-						// we need the __VIEWSTATE for sending loginData, so we should abort here
-						return false;
-					}
-					final StringBuffer sb = new StringBuffer(1000);
-					sb.append(&quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false));
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(&quot;myUsername=&quot; + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(&quot;myPassword=&quot; + encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(&quot;cookie=on&quot;);
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(&quot;Button1=Login&quot;);
-					UrlFetcher.setpostData(sb.toString());
-					loginPage = UrlFetcher.fetch(loginPageUrl);
-					if (loginPage.indexOf(loginSuccess) &gt; 0) {
-						pref.log(&quot;Login successful: &quot; + pref.myAlias);
-						// **3 now we are logged in and get the Cookie (there are two)
-						final PropertyList pl = UrlFetcher.getDocumentProperties();
-						String docprops = &quot;&quot;;
-						for (int i = 0; i &lt; pl.size(); i++) {
-							final Property p = (Property) pl.get(i);
-							if (p.name.equalsIgnoreCase(&quot;Set-Cookie&quot;)) {
-								docprops += p.value;
-							}
-						}
-						final Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
-						rexCookieSession.search(docprops);
-						if (rexCookieSession.didMatch()) {
-							cookie = &quot;ASP.NET_SessionId=&quot; + rexCookieSession.stringMatched(1);
-						} else {
-							localInfB.close(0);
-							pref.log(&quot;[login]:SessionID not found.&quot;, null);
-							return false;
-						}
-						final Regex rexCookieID = new Regex(&quot;(?i)userid=(.*?);.*&quot;);
-						rexCookieID.search(docprops);
-						if (rexCookieID.didMatch()) {
-							cookie += &quot;; userid=&quot; + rexCookieID.stringMatched(1);
-						} else {
-							localInfB.close(0);
-							pref.log(&quot;[login]:userID not found.&quot;, null);
-							return false;
-						}
-						UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
-					} else {
-						pref.log(&quot;Login failed. Wrong Account or Password? &quot; + pref.myAlias, null);
-						pref.log(&quot;[login.url]:&quot; + loginPageUrl, null);
-						pref.log(&quot;[login.postData]:&quot; + sb.toString(), null);
-						pref.log(&quot;[login.Answer]:&quot; + loginPage, null);
-						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
-						return false;
-					}
-					if (!this.switchToEnglish())
-						return false;
-				} catch (final Exception ex) {
-					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
-					localInfB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
-					return false;
-				}
-			}
 		}
-
-		final boolean loginAborted = localInfB.isClosed;
-		localInfB.close(0);
-		if (loginAborted)
-			return false;
 		else {
-			loggedIn = true;
-			return true;
+			cookie += &quot;; userid=&quot; + userId;
 		}
+
+		UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
+		return true;
+
 	}
 
 	private boolean switchToEnglish() {
 		// change language to EN , further operations relay on English
 		String url = &quot;<A HREF="http://www.geocaching.com/account/ManagePreferences.aspx">http://www.geocaching.com/account/ManagePreferences.aspx</A>&quot;;
 		String page = &quot;&quot;;
-		String userID = &quot;userid=&quot; + pref.userID;
 		try {
-			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, userID);
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, &quot;userid=&quot; + pref.userID);
 			page = UrlFetcher.fetch(url); // getting the sessionid
-			if (page.length() == 0)
+			if (page.length() == 0) {
+				pref.log(&quot;[switchToEnglish]:empty page getting SessionID.&quot;, null);
 				return false;
+			}
 		} catch (final Exception ex) {
+			pref.log(&quot;[switchToEnglish]:Exception getting SessionID.&quot;, ex);
 			return false;
 		}
-		PropertyList pl = UrlFetcher.getDocumentProperties();
-		String docprops = &quot;&quot;;
-		for (int i = 0; i &lt; pl.size(); i++) {
-			final Property p = (Property) pl.get(i);
-			if (p.name.equalsIgnoreCase(&quot;Set-Cookie&quot;)) {
-				docprops += p.value;
-			}
-		}
-		final Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
-		rexCookieSession.search(docprops);
-		if (rexCookieSession.didMatch()) {
-			cookie = &quot;ASP.NET_SessionId=&quot; + rexCookieSession.stringMatched(1) + &quot;; &quot; + userID;
-			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
-		} else {
-			pref.log(&quot;[switchToEnglish]:SessionID not found.&quot;, null);
+
+		if (!getSessionIdAndSetCookie(pref.userID))
 			return false;
-		}
+
 		try {
 			page = UrlFetcher.fetch(url);
 			if (page.length() == 0)
@@ -1293,34 +1176,28 @@
 		} catch (IOException e) {
 			return false;
 		}
+
 		Extractor ext = new Extractor(page, &quot;ctl00$ContentBody$uxLanguagePreference&quot;, &quot;&lt;/select&gt;&quot;, 0, true);
 		String languageBlock = ext.findNext();
 		ext.set(ext.findNext(&quot;ctl00$ContentBody$uxDateTimeFormat&quot;), &quot;selected\&quot; value=\&quot;&quot;, &quot;\&quot;&gt;&quot;, 0, true);
 		DateFormat.GCDateFormat = ext.findNext();
-		// &lt;option selected=&quot;selected&quot; value=&quot;de-DE&quot;&gt;Deutsch&lt;/option&gt;
-		ext.set(languageBlock, &quot;&lt;option selected=&quot;, &quot;/option&gt;&quot;, 0, true);
-		ext.set(ext.findNext(), &quot;&gt;&quot;, &quot;&lt;&quot;, 0, true);
+		// &lt;option selected=\&quot;selected\&quot; value=\&quot;de-DE&quot;&gt;Deutsch&lt;/option&gt;
+		ext.set(languageBlock, &quot;&lt;option selected=\&quot;selected\&quot; value=\&quot;&quot;, &quot;\&quot;&gt;&quot;, 0, true);
 		String oldLanguage = ext.findNext();
-		if (oldLanguage.equals(&quot;English&quot;)) {
+		if (oldLanguage.equals(&quot;en-US&quot;)) {
+			pref.switchGCLanguageToEnglish=false;
 			pref.log(&quot;already English&quot;);
-			pref.oldLanguageCtl = &quot;&quot;; // nothing to reset
 			return true;
 		}
 		// switch to english now goes into gc account Display Preferences
 		// (is permanent, must be reset)
-		// todo as long as Textfile Encoding is CP1252 we compare with
-		// substring(1) and think koreanisch if no merge at all
-		String languages[] = { &quot;English&quot;, &quot;Deutsch&quot;, &quot;Fran&#231;ais&quot;, &quot;Portugu&#234;s&quot;, &quot;Ce&#154;tina&quot;, &quot;Svenska&quot;, &quot;Nederlands&quot;, &quot;Catal&#224;&quot;, &quot;Polski&quot;, &quot;Eesti&quot;, &quot;Norsk, Bokm&#229;l&quot;, &quot;???&quot;, &quot;Espa&#241;ol&quot; };
+		String languages[] = { &quot;en-US&quot;, &quot;de-DE&quot;, &quot;fr-FR&quot;, &quot;pt-PT&quot;, &quot;cs-CZ&quot;, &quot;sv-SE&quot;, &quot;nl-NL&quot;, &quot;ca-ES&quot;, &quot;pl-PL&quot;, &quot;et-EE&quot;, &quot;nb-NO&quot;, &quot;ko-KR&quot;, &quot;es-ES&quot;, &quot;hu-HU&quot; };
 		for (int i = 0; i &lt; languages.length; i++) {
-			if (oldLanguage.substring(1).equals(languages[i].substring(1))) {
+			if (oldLanguage.equals(languages[i])) {
 				pref.oldLanguageCtl = url + &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(&quot;ctl00$uxLocaleList$uxLocaleList$ctl&quot; + MyLocale.formatLong(i, &quot;00&quot;) + &quot;$uxLocaleItem&quot;, false);
 				break;
 			}
 		}
-		if (pref.oldLanguageCtl.length() == 0) {
-			// koreanisch
-			pref.oldLanguageCtl = url + &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(&quot;ctl00$uxLocaleList$uxLocaleList$ctl&quot; + &quot;11&quot; + &quot;$uxLocaleItem&quot;, false);
-		}
 		final String strEnglishPage = &quot;ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem&quot;;
 		url += &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(strEnglishPage, false);
 		try {
@@ -1366,14 +1243,7 @@
 			RexPropType = new Regex(p.getProp(&quot;TypeRex&quot;));
 			RexPropDTS = new Regex(p.getProp(&quot;DTSRex&quot;));
 			RexPropOwn = new Regex(p.getProp(&quot;own&quot;));
-			RexLogBlock = new Regex(p.getProp(&quot;blockRex&quot;));
-			exSingleLog = new Extractor(&quot;&quot;, p.getProp(&quot;singleLogExStart&quot;), p.getProp(&quot;singleLogExEnd&quot;), 0, false);
-			exIcon = new Extractor(&quot;&quot;, p.getProp(&quot;iconExStart&quot;), p.getProp(&quot;iconExEnd&quot;), 0, true);
-			exNameTemp = new Extractor(&quot;&quot;, p.getProp(&quot;nameTempExStart&quot;), p.getProp(&quot;nameTempExEnd&quot;), 0, true);
-			exName = new Extractor(&quot;&quot;, p.getProp(&quot;nameExStart&quot;), p.getProp(&quot;nameExEnd&quot;), 0, true);
-			exDate = new Extractor(&quot;&quot;, p.getProp(&quot;dateExStart&quot;), p.getProp(&quot;dateExEnd&quot;), 0, true);
-			exLog = new Extractor(&quot;&quot;, p.getProp(&quot;logExStart&quot;), p.getProp(&quot;logExEnd&quot;), 0, true);
-			exLogId = new Extractor(&quot;&quot;, p.getProp(&quot;logIdExStart&quot;), p.getProp(&quot;logIdExEnd&quot;), 0, true);
+			RexUserToken = new Regex(p.getProp(&quot;UserTokenRex&quot;));
 			icon_smile = p.getProp(&quot;icon_smile&quot;);
 			icon_camera = p.getProp(&quot;icon_camera&quot;);
 			icon_attended = p.getProp(&quot;icon_attended&quot;);
@@ -1747,7 +1617,7 @@
 
 	/**
 	 * check if new Update exists
-	 * 
+	 *
 	 * @param ch
 	 *            CacheHolder
 	 * @param CacheDescription
@@ -1832,7 +1702,7 @@
 
 	/**
 	 * Get num found
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return numFound
@@ -1888,7 +1758,7 @@
 			if (ret.indexOf(&quot;ere&quot;) &gt; -1)
 				return distanceAndDirection; // zur Zeit &quot; Here -1&quot;
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
-			// da dieser von gc mal wieder ge&#195;&#131;&#194;&#164;ndert wurde.
+			// da dieser von gc mal wieder ge&#228;ndert wurde.
 			// todo Ben&#246;tigt ev noch weitere Anpassungen: | am Anfang, and calc of keylength
 			// String thereitis=&quot;|0.34 km|102.698&quot;;
 			// String page =
@@ -1921,7 +1791,7 @@
 			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
 			final String newkey = decodeXor(coded, thereitis);
 			final int keylength = 13;
-			// wenn nicht 13 dann newkey auf wiederholung pr&#195;&#131;&#194;&#188;fen
+			// wenn nicht 13 dann newkey auf wiederholung pr&#252;fen
 			DistanceCodeKey = newkey.substring(0, keylength);
 			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
 			pref.log(&quot;Automatic key: &quot; + DistanceCodeKey + &quot; result: &quot; + ret + Preferences.NEWLINE);
@@ -1952,7 +1822,7 @@
 
 	/**
 	 * Get the waypoint name
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Name of waypoint to add to list
@@ -2015,6 +1885,7 @@
 			try {
 				doc = UrlFetcher.fetchData(address);
 			} catch (final IOException e) {
+				pref.log(&quot;[SpiderGC:getDTS]&quot;,e,true);
 				return &quot;&quot;;
 			}
 			final Image idoc = new Image(doc, 0, null, 0, 0);
@@ -2177,9 +2048,9 @@
 
 	/*
 	 * @param CacheHolder ch
-	 * 
+	 *
 	 * @param String cacheDescGC
-	 * 
+	 *
 	 * @return boolean newLogExists
 	 */
 	private boolean newFoundExists(CacheHolder ch, String cacheDescription) {
@@ -2221,9 +2092,9 @@
 	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already
 	 * existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file
 	 * and fetching the images.
-	 * 
+	 *
 	 * This is the workhorse function of the spider.
-	 * 
+	 *
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
 	 * @param boolean
@@ -2429,7 +2300,7 @@
 
 	/**
 	 * Get the coordinates of the cache
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cache coordinates
@@ -2448,7 +2319,7 @@
 
 	/**
 	 * Get the long description
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the long description
@@ -2483,7 +2354,7 @@
 
 	/**
 	 * Get the cache location (country and state)
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the location (country and state) of the cache
@@ -2500,7 +2371,7 @@
 
 	/**
 	 * Get the cache name
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the name of the cache
@@ -2517,7 +2388,7 @@
 
 	/**
 	 * Get the cache owner
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the cache owner
@@ -2534,7 +2405,7 @@
 
 	/**
 	 * Get the date when the cache was hidden
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Hidden date
@@ -2551,7 +2422,7 @@
 
 	/**
 	 * Get the hints
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cachehints
@@ -2568,7 +2439,7 @@
 
 	/**
 	 * Get the cache size
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cache size
@@ -2586,7 +2457,7 @@
 
 	/**
 	 * Get the Difficulty
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return The cache difficulty
@@ -2604,7 +2475,7 @@
 
 	/**
 	 * Get the terrain rating
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Terrain rating
@@ -2622,7 +2493,7 @@
 
 	/**
 	 * Get the waypoint type
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the waypoint type (Tradi, Multi, etc.)
@@ -2639,7 +2510,7 @@
 
 	/**
 	 * Get the logs
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @param chD
@@ -2647,66 +2518,71 @@
 	 * @return A HTML string containing the logs
 	 */
 	private void getLogs(String completeWebPage, CacheHolderDetail chD) throws Exception {
-		String icon = &quot;&quot;;
-		String name = &quot;&quot;;
-		String logText = &quot;&quot;;
-		String logId = &quot;&quot;;
-		String singleLog = &quot;&quot;;
+
 		final LogList reslts = chD.CacheLogs;
-		RexLogBlock.search(completeWebPage);
-		if (!RexLogBlock.didMatch()) {
-			pref.log(&quot;[SpiderGC.java:getLogs]check blockRex!&quot;, null);
-		}
-		final String LogBlock = RexLogBlock.stringMatched(1);
 
-		exSingleLog.set(LogBlock);
+		RexUserToken.search(completeWebPage);
+		if (!RexUserToken.didMatch()) {
+			pref.log(&quot;[SpiderGC.java:getLogs]check RexUserToken!&quot;, null);
+		}
+		final String userToken = RexUserToken.stringMatched(1);
+		int idx = 0;
 		int nLogs = 0;
 		boolean foundown = false;
-		while ((singleLog = exSingleLog.findNext()).length() &gt; 0) {
-			nLogs++;
+		boolean fertig = false;
+		int num = 100;
+		do {
+			idx++;
+			String url=&quot;<A HREF="http://www.geocaching.com/seek/geocache.logbook?tkn=">http://www.geocaching.com/seek/geocache.logbook?tkn=</A>&quot;+userToken+&quot;&amp;idx=&quot;+idx+&quot;&amp;num=&quot;+num+&quot;&amp;decrypt=false&quot;;
+			UrlFetcher.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
+			final JSONObject resp = new JSONObject(UrlFetcher.fetch(url));
+			if (!resp.getString(&quot;status&quot;).equals(&quot;success&quot;)) {
+				pref.log(&quot;status is &quot; + resp.getString(&quot;status&quot;));
+			}
+			final JSONArray data = resp.getJSONArray(&quot;data&quot;);
+			fertig = data.length() &lt; num;
+			for (int index = 0; index &lt; data.length(); index++) {
+				nLogs++;
+				final JSONObject entry = data.getJSONObject(index);
 
-			icon = exIcon.findFirst(singleLog);
-			// ' changes to &quot; in UMTS-connection! first char in iconExEnd.
-			icon = icon.substring(0, icon.length() - 1);
+				final String icon = entry.getString(&quot;LogTypeImage&quot;);
+				final String name = entry.getString(&quot;UserName&quot;);
+				String logText = entry.getString(&quot;LogText&quot;);
+				logText = STRreplace.replace(logText, &quot;&lt;br/&gt;&quot;, &quot;&lt;br&gt;&quot;);
+				logText = correctSmilies(logText);
+				final String d = DateFormat.toYYMMDD(entry.getString(&quot;Visited&quot;));
+				final String logId = entry.getString(&quot;LogID&quot;);
 
-			name = exName.findFirst(exNameTemp.findFirst(singleLog));
-
-			logText = exLog.findFirst(singleLog);
-			logText = correctSmilies(logText);
-
-			logId = exLogId.findFirst(singleLog);
-
-			final String ed = exDate.findFirst(singleLog);
-			final String d = DateFormat.toYYMMDD(ed);
-
-			// if this log says this Cache is found by me
-			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) &amp;&amp; (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
-				chD.getParent().setFound(true);
-				chD.getParent().setCacheStatus(d);
-				chD.OwnLogId = logId;
-				chD.OwnLog = new Log(icon, d, name, logText);
-				foundown = true;
-				// pref.log(&quot;own log detected!&quot;);
-			}
-			if (nLogs &lt;= pref.maxLogsToSpider) {
-				reslts.add(new Log(icon, d, name, logText));
-			} else {
-				if (foundown) {
-					break;
+				// if this log says this Cache is found by me
+				if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) &amp;&amp; (name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(pref.myAlias2)))) {
+					chD.getParent().setFound(true);
+					chD.getParent().setCacheStatus(d);
+					// final String logId = entry.getString(&quot;LogID&quot;);
+					chD.OwnLogId = logId;
+					chD.OwnLog = new Log(icon, d, name, logText);
+					foundown = true;
 				}
+				if (nLogs &lt;= pref.maxLogsToSpider) {
+					reslts.add(new Log(icon, d, name, logText));
+				} else {
+					if (foundown) {
+						fertig=true;
+						break;
+					}
+				}
 			}
-		}
+		} while (!fertig);
+
 		if (nLogs &gt; pref.maxLogsToSpider) {
+			// there are more logs
 			reslts.add(Log.maxLog());
-			// pref.log(&quot;MAXLOGS reached (&quot;+pref.maxLogsToSpider+&quot;)&quot;);
 		}
-		// pref.log(nLogs+&quot; checked!&quot;);
-		// return reslts;
+
 	}
 
 	/**
 	 * This methods cleans up the path for inlined smilies in logtexts.
-	 * 
+	 *
 	 * @param logText
 	 * @return
 	 */
@@ -2724,7 +2600,7 @@
 	/**
 	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each
 	 * travelbug
-	 * 
+	 *
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
@@ -2782,7 +2658,7 @@
 	/**
 	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and
 	 * the pictures section (including the spoiler)
-	 * 
+	 *
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @param chD
@@ -2866,19 +2742,26 @@
 		// ========
 		// In the image span
 		// ========
-		Extractor spanBlock, exImgName;
+		Extractor spanBlock;
+		String imgSrcExStart, imgSrcExEnd;
+		String imgNameExStart, imgNameExEnd;
+		String imgCommentExStart, imgCommentExEnd;
 		try {
-			spanBlock = new Extractor(doc, p.getProp(&quot;imgSpanExStart&quot;), p.getProp(&quot;imgSpanExEnd&quot;), 0, true);
-			tst = spanBlock.findNext();
-			exImgName = new Extractor(tst, p.getProp(&quot;imgNameExStart&quot;), p.getProp(&quot;imgNameExEnd&quot;), 0, true);
-			exImgSrc = new Extractor(tst, p.getProp(&quot;imgSrcExStart&quot;), p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
-			exImgComment = new Extractor(tst, p.getProp(&quot;imgCommentExStart&quot;), p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
+			imgSrcExStart=p.getProp(&quot;imgSrcExStart&quot;);
+			imgSrcExEnd=p.getProp(&quot;imgSrcExEnd&quot;);
+			imgNameExStart=p.getProp(&quot;imgNameExStart&quot;);
+			imgNameExEnd=p.getProp(&quot;imgNameExEnd&quot;);
+			imgCommentExStart= p.getProp(&quot;imgCommentExStart&quot;);
+			imgCommentExEnd=p.getProp(&quot;imgCommentExEnd&quot;);
+			spanBlock = new Extractor(doc, p.getProp(&quot;imgSpanExStart&quot;), p.getProp(&quot;imgSpanExEnd&quot;), 0, false);
+			spanBlock.set(spanBlock.findNext(), p.getProp(&quot;imgSpanExStart2&quot;), p.getProp(&quot;imgSpanExEnd&quot;), 0, true);
+			spanBlock.set(spanBlock.findNext()+imgSrcExStart, imgSrcExStart, imgSrcExStart, 0, false);
 		} catch (final Exception ex) {
 			return;
 		}
-		while ((imgUrl = exImgSrc.findNext()).length() &gt; 0) {
-			imgComment = exImgComment.findNext();
-			imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+		while ((tst = spanBlock.findNext()).length() &gt; 0) {
+			exImgSrc.set(tst, imgSrcExStart, imgSrcExEnd, 0, true);
+			imgUrl = &quot;<A HREF="http://">http://</A>&quot; + exImgSrc.findNext();
 			try {
 				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
 				// imgType is now max 4 chars, starting with .
@@ -2910,7 +2793,8 @@
 						imageInfo.setFilename(fileName + imgType);
 						imageInfo.setURL(imgUrl);
 					}
-					imageInfo.setTitle(exImgName.findNext());
+					imageInfo.setTitle(exImgSrc.findNext(imgNameExStart, imgNameExEnd));
+					imgComment = exImgSrc.findNext(imgCommentExStart, imgCommentExEnd);
 					while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;))
 						imgComment = imgComment.substring(6);
 					while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;))
@@ -2969,7 +2853,7 @@
 
 	/**
 	 * Read an image from the server
-	 * 
+	 *
 	 * @param imgUrl
 	 *            The Url of the image
 	 * @param target
@@ -2991,7 +2875,7 @@
 
 	/**
 	 * Read all additional waypoints from a previously fetched cachepage.
-	 * 
+	 *
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @param wayPoint
@@ -3126,7 +3010,7 @@
 	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical
 	 * names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
 	 * Note that each bug has both an ID and a GUID.
-	 * 
+	 *
 	 * @param name
 	 *            The name (or partial name) of a travelbug
 	 * @return the id of the bug
@@ -3162,7 +3046,7 @@
 	/**
 	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be
 	 * a GUID, otherwise it is an ID.
-	 * 
+	 *
 	 * @param guid
 	 *            the guid or id of the travelbug
 	 * @return The mission
@@ -3195,7 +3079,7 @@
 
 	/**
 	 * Fetch a bug's mission for a given tracking number
-	 * 
+	 *
 	 * @param trackNr
 	 *            the tracking number of the travelbug
 	 * @return The mission
@@ -3227,7 +3111,7 @@
 
 	/**
 	 * Fetch a bug's mission and namefor a given tracking number
-	 * 
+	 *
 	 * @param TB
 	 *            the travelbug
 	 * @return true if suceeded
@@ -3274,7 +3158,7 @@
 
 		/**
 		 * Gets an entry in spider.def by its key (tag)
-		 * 
+		 *
 		 * @param key
 		 *            The key which is attributed to a specific entry
 		 * @return The value for the key
@@ -3332,14 +3216,6 @@
 					_routePoints.add(tp);
 				return;
 			}
-			if (name.equals(&quot;GeoPosition&quot;)) {
-				final double lat = Common.parseDouble(atts.getValue(&quot;Y&quot;));
-				final double lon = Common.parseDouble(atts.getValue(&quot;X&quot;));
-				final TrackPoint tp = new TrackPoint(lat, lon);
-				if (tp.isValid())
-					_routePoints.add(tp);
-				return;
-			}
 		}
 
 		public void endElement(String name) {

Modified: branches/r1.2/src/CacheWolf/myTableModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/myTableModel.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/myTableModel.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -561,7 +561,9 @@
 	}
 
 	/**
-	 * Toggle the select status for a group of caches If from==to, the addi Waypoints are also toggled if the cache is a main waypoint If from!=to, each cache is toggled irrespective of its type (main or addi)
+	 * Toggle the select status for a group of caches. Addi waypoints are set to the same state
+	 * as their main cache. (Exception: Their main cache is not in the range of toggled caches,
+	 * then they are toggled independently.)
 	 * 
 	 * @param from
 	 *            index of first cache to toggle
@@ -574,24 +576,53 @@
 		CacheHolder ch;
 		boolean singleRow = from == to;
 		for (int j = from; j &lt;= to; j++) {
+			boolean checkAddiWpts = false;
 			ch = cacheDB.get(j);
-			ch.is_Checked = !ch.is_Checked;
+			if (singleRow) {
+				// If its a single row click, then toggle the cache. Remember to 
+				// toggle addis too, if there are.
+				ch.is_Checked = !ch.is_Checked;
+				checkAddiWpts = true;
+			} else {
+				// If not a single row click...
+				if (ch.isAddiWpt()) {
+					// Only toggle addis, if their main cache is not within the
+					// range that will be toggled
+					int mainIdx = cacheDB.getIndex(ch.mainCache);
+					if (mainIdx &lt; from-1 || mainIdx &gt; to) {
+						ch.is_Checked = !ch.is_Checked;
+					} else {
+						// Otherwise the addis will be toggled along with their 
+						// main caches, so nothing is to do here.
+					}
+				} else {
+					// If its a main cache, then toggle it and remember to 
+					// toggle the addis, too.
+					ch.is_Checked = !ch.is_Checked;
+					checkAddiWpts = true;
+				}
+			}
 			tcControl.repaintCell(j, x);
-			// set the ceckbox also for addi wpts
-			if (ch.hasAddiWpt() &amp;&amp; singleRow) {
+			// Now look for addi wpts.
+			if (checkAddiWpts) {
 				CacheHolder addiWpt;
 				int addiCount = ch.addiWpts.getCount();
 				for (int i = 0; i &lt; addiCount; i++) {
+					// This code will only run when the main cache
+					// has been toggled.
 					addiWpt = (CacheHolder) ch.addiWpts.get(i);
+					// Set all addi check states to the state of the 
+					// main cache. 
 					addiWpt.is_Checked = ch.is_Checked;
 					if (addiWpt.isVisible()) {
 						tcControl.repaintCell(cacheDB.getIndex(addiWpt), x);
 					}
 				}
+			}
 
-			}
 		}
 	}
+	
 
 	public void select(int row, int col, boolean selectOn) {
 		// super.select(row, col, selectOn);

Modified: branches/r1.2/src/CacheWolf/navi/MapLoader.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapLoader.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/navi/MapLoader.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -192,8 +192,21 @@
 		// if (toplefti.latDec &lt;= bottomrighti.latDec || toplefti.lonDec &gt;= toplefti.lonDec) throw new IllegalArgumentException(&quot;topleft must be left and above bottom right&quot;);
 		topleft = new CWPoint(toplefti);
 		bottomright = new CWPoint(bottomrighti);
-		double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
+		double metersPerLat;
+		double metersPerLon;
+		if (topleft.equals(bottomright)) {
+			// veraltet: Berechnung auf Kugel: double
+			metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+			// veraltet: Berechnung auf Kugel: double
+			metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
+		} else {
+			CWPoint center = new CWPoint((topleft.latDec + bottomright.latDec) / 2.0, (toplefti.lonDec + bottomrighti.lonDec) / 2.0);
+			CWPoint centerleft = new CWPoint((topleft.latDec + bottomright.latDec) / 2.0, toplefti.lonDec);
+			CWPoint centerbottom = new CWPoint(bottomright.latDec, (toplefti.lonDec + bottomrighti.lonDec) / 2.0);
+			metersPerLat = 1000.0 * center.getDistance(centerbottom) / (center.latDec - centerbottom.latDec);
+			metersPerLon = 1000.0 * center.getDistance(centerleft) / (center.lonDec - centerleft.lonDec);
+		}
+
 		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
 		double pixelsPerLat = metersPerLat / metersperpixel;
 		double pixelsPerLon = metersPerLon / metersperpixel;
@@ -873,7 +886,7 @@
 	/**
 	 * This method gives the number in the array of coordinateReferenceSystems, which should be used
 	 * a) if only one is in the array 0 is returned
-	 * b) if there are more, find out which one matches the correct zone (e.g. Gau&#223;-K&#252;ger stripe)
+	 * b) if there are more, find out which one matches the correct zone (e.g. Gau?-K?ger stripe)
 	 * Call this routine with center of the area (use Area.getcenter())
 	 * 
 	 * @param p
@@ -884,7 +897,7 @@
 		int crsindex = 0;
 		if (coordinateReferenceSystem.length &gt; 1) {
 			int ls = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau&#223;-Kr&#252;ger stripe?
+			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau?-Kr?ger stripe?
 			int wantepsg = gkbl.getEpsgCode();
 			for (crsindex = 0; crsindex &lt; coordinateReferenceSystem.length; crsindex++) {
 				if (coordinateReferenceSystem[crsindex] == wantepsg)
@@ -900,7 +913,7 @@
 
 			}
 			if (crsindex &lt; 0)
-				throw new IllegalArgumentException(MyLocale.getMsg(4829, &quot;getUrlForBoundingBox: Point:&quot;) + &quot; &quot; + gkbl.toString() + MyLocale.getMsg(4830, &quot;no matching Gau&#223;-Kr&#252;ger-Stripe in the EPSG-code list in the .wms&quot;));
+				throw new IllegalArgumentException(MyLocale.getMsg(4829, &quot;getUrlForBoundingBox: Point:&quot;) + &quot; &quot; + gkbl.toString() + MyLocale.getMsg(4830, &quot;no matching Gau?-Kr?ger-Stripe in the EPSG-code list in the .wms&quot;));
 		}
 		return crsindex;
 	}

Modified: branches/r1.2/src/CacheWolf/navi/MovingMap.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MovingMap.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/navi/MovingMap.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1762,7 +1762,7 @@
 								// evtl. Kartenwechsel PosCircle on Screen
 								// ist. So wie es jetzt ist, kann 2mal der
 								// gleiche Aufruf zum laden
-								// unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn
+								// unterschiedlicher Karten f?hren, wenn
 								// vorher PosCircle nicht auf dem
 			// SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
@@ -1823,7 +1823,7 @@
 	public void loadMapForAllCaches() {
 		final Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#239;&#191;&#189;ckchen ausgew&#239;&#191;&#189;hlt&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H?ckchen ausgew?hlt&quot;), FormBase.OKB)).execute();
 			return;
 		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.bottomright);

Modified: branches/r1.2/src/CacheWolf/utils/URLUTF8Encoder.java
===================================================================
--- branches/r1.2/src/CacheWolf/utils/URLUTF8Encoder.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/utils/URLUTF8Encoder.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -41,10 +41,10 @@
  *
  * URLUTF8Encoder: <A HREF="http://www.w3.org/International/URLUTF8Encoder.java">http://www.w3.org/International/URLUTF8Encoder.java</A>
  *
- * Copyright &#194;&#169; 1997 World Wide Web Consortium, (Massachusetts
+ * Copyright &#169; 1997 World Wide Web Consortium, (Massachusetts
  * Institute of Technology, European Research Consortium for
  * Informatics and Mathematics, Keio University). All Rights Reserved. 
- * This work is distributed under the W3C&#194;&#174; Software License [1] in the
+ * This work is distributed under the W3C&#174; Software License [1] in the
  * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
  * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  * PURPOSE.

Modified: branches/r1.2/src/CacheWolf/view/pda/PDAList.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAList.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAList.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1,12 +1,12 @@
 package CacheWolf.view.pda;
 
+import CacheWolf.Global;
 import CacheWolf.MyLocale;
 import CacheWolf.model.DefaultListModel;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
 import ewe.ui.ControlEvent;
 import ewe.ui.Form;
-import ewe.util.Vector;
 
 public abstract class PDAList extends Form {
 	protected static final String LINE = &quot;Line&quot;;
@@ -17,6 +17,8 @@
 
 	protected static final String MENUE = &quot;Menue&quot;;
 
+	private static final String NONE = &quot;none&quot;;
+
 	public DefaultListModel model;
 	private int linesOnScreen=7;
 	PDAListButton[] listButtons;
@@ -31,7 +33,7 @@
 
 		firstLine = 0;
 		for (int i = 0; i &lt; linesOnScreen; i++) {
-			listButtons[i] = new PDAListButton(&quot;&quot;, LINE + i);
+			listButtons[i]  = createListButton(i);
 			addLast(listButtons[i], CellConstants.STRETCH, CellConstants.FILL);
 		}
 		setupTBButtons();
@@ -45,6 +47,10 @@
 		addLast(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
 	}
 
+	protected PDAListButton createListButton(int i) {
+		return new PDAListButton(&quot;&quot;, LINE + i);
+	}
+
 	public void onControlEvent(ControlEvent ev) {
 		if (ev instanceof ControlEvent) {
 			switch (ev.type) {
@@ -77,8 +83,10 @@
 			if (model != null &amp;&amp; i + firstLine &lt; model.size()) {
 				Object modelElement = model.get(i + firstLine);
 				listButtons[i].text = modelElement.toString();
+				listButtons[i].action = LINE+i;
 			} else {
 				listButtons[i].text = listButtons[i].fromText = listButtons[i].toText = &quot;&quot;;
+				listButtons[i].action = NONE;
 			}
 			listButtons[i].repaint();
 		}

Modified: branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -15,7 +15,7 @@
 	public PDAListButton(String newText, String newAction) {
 		super(newText);
 		action = newAction;
-		buttonObject = new PDAListButtonObject(this);
+		createButtonObject();
 
 		backGround = Color.White;
 		foreGround = Color.Black;
@@ -25,10 +25,14 @@
 		textPosition=2;
 	}
 
+	protected void createButtonObject() {
+		buttonObject = new PDAListButtonObject(this);
+	}
+
 	public void make(boolean paramBoolean) {
 		if (this.buttonObject != null)
 			return;
-		this.buttonObject = new PDAListButtonObject(this);
+		createButtonObject();
 	}
 	
 }

Modified: branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -1,13 +1,14 @@
 package CacheWolf.view.pda;
 
-import ewe.fx.Color;
+import CacheWolf.Global;
 import ewe.fx.Font;
 import ewe.fx.Graphics;
 import ewe.fx.Rect;
 import ewe.ui.ButtonObject;
+import ewe.ui.Gui;
 
 public class PDAListButtonObject extends ButtonObject {
-	private PDAListButton pdaListButton;
+	protected PDAListButton pdaListButton;
 
 	public PDAListButtonObject(PDAListButton pdaListButton) {
 		super(pdaListButton);
@@ -15,13 +16,16 @@
 	}
 
 	public void paint(Graphics paramGraphics) {
+		try{
 		if ((this.soft) &amp;&amp; (this.control != null))
 			this.control.doBackground(paramGraphics);
 		if (this.text == null)
 			this.text = &quot;&quot;;
 		drawButton(paramGraphics);
-		Rect localRect1 = paramGraphics.reduceClip(new Rect(this.borderWidth, this.borderWidth, this.size.width
-				- (this.borderWidth * 2), this.size.height - (this.borderWidth * 2)));
+		Rect paramRect = new Rect(this.borderWidth, this.borderWidth, this.size.width - (this.borderWidth * 2), this.size.height - (this.borderWidth * 2));
+		Rect localRect1 = paramGraphics.reduceClip(paramRect);
+		//On PocketPC2003 sometimes reduceClip returns null. If this happens, the clipping area seems to be determined by its input parameter.
+		if (localRect1 == null) localRect1=paramRect;
 		try {
 			paramGraphics.setColor(foreground);
 			int x = 10;
@@ -31,28 +35,33 @@
 				x += image.getWidth();
 				x += 10;
 			}
+			
+			int fontSize = 40;
+			font = new Font(font.getName(), Font.BOLD, fontSize);
+			boolean found = false;
+			while (!found) {
+				Rect textRect = Gui.getSize(pdaListButton.getFontMetrics(), text, 5, 0);
+				if (textRect.width &gt; localRect1.width &amp;&amp; textRect.height &gt; localRect1.height &amp;&amp; fontSize &gt; 5) {
+					fontSize--;
+					Font tmpFont = new Font(font.getName(), Font.BOLD, fontSize);
+					if (tmpFont != null){
+						font = tmpFont;
+					}
+					textRect = Gui.getSize(pdaListButton.getFontMetrics(), text, 5, 0);
+				} else {
+					found = true;
+				}
+			}
 			paramGraphics.setFont(this.font);
 			paramGraphics.drawText(text, x, 10);
 			Font tmpFont = new Font(font.getName(), Font.BOLD, 20);
 			paramGraphics.setFont(tmpFont);
-			if (pdaListButton.fromText != null) {
-				paramGraphics.drawText(pdaListButton.fromText, x + 15, 45);
-			}
-			if (!pdaListButton.fromLogged) {
-				paramGraphics.setColor(new Color(255, 0, 0));
-				paramGraphics.fillEllipse(x, 50, 10, 10);
-				paramGraphics.setColor(foreground);
-			}
-			if (pdaListButton.toText != null) {
-				paramGraphics.drawText(pdaListButton.toText, x + 15, 70);
-			}
-			if (!pdaListButton.toLogged) {
-				paramGraphics.setColor(new Color(255, 0, 0));
-				paramGraphics.fillEllipse(x, 75, 10, 10);
-				paramGraphics.setColor(foreground);
-			}
 		} finally {
 			paramGraphics.restoreClip(localRect1);
 		}
+		}
+		catch(Exception e){
+			Global.getPref().log(&quot;Mysterious Exception caught!&quot;, e, true);
+		}
 	}
 }

Modified: branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -2,6 +2,7 @@
 
 import ewe.fx.Dimension;
 import ewe.ui.ButtonObject;
+import ewe.ui.Gui;
 
 public class PDAMenuButtonObject extends ButtonObject{
 	private PDAMenuButton pdaMenuButton;
@@ -12,13 +13,12 @@
 		this.pdaMenuButton = pdaListButton;
 	}
 
-	  public Dimension calculateSize(Dimension paramDimension){
-		  calculateSize = super.calculateSize(paramDimension);
-		  if (calculateSize.height &lt; 100){
-			  calculateSize.height=100;
-			  paramDimension.height=100;
-		  }
-		  return calculateSize;
-	  }
+	public Dimension calculateSize(Dimension paramDimension) {
+		calculateSize = super.calculateSize(paramDimension);
+		if (calculateSize.height &lt; Gui.screenSize.height / 8) {
+			calculateSize.height = paramDimension.height = Gui.screenSize.height / 8;
+		}
+		return calculateSize;
+	}
 
 }

Modified: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java	2011-09-21 13:32:26 UTC (rev 3108)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java	2011-09-26 07:19:42 UTC (rev 3109)
@@ -21,17 +21,21 @@
 	public PDATravelbugScreen(TravelbugList tbl, String title, boolean allowNew) {
 		super();
 		model = new DefaultListModel();
-		for (int i=0;i &lt; tbl.size();i++){
+		for (int i = 0; i &lt; tbl.size(); i++) {
 			Travelbug tb = tbl.getTB(i);
 			model.add(tb.getName());
 		}
-		if (allowNew){
-			model.add(MyLocale.getMsg(6015,&quot;*** OTHER ***&quot;));
+		if (allowNew) {
+			model.add(MyLocale.getMsg(6015, &quot;*** OTHER ***&quot;));
 		}
 		model.createShowSet();
 		setupTBButtons();
-}
+	}
 
+	protected PDAListButton createListButton(int i) {
+		return new PDAListButton(&quot;&quot;, LINE + i);
+	}
+
 	public void onControlEvent(ControlEvent ev) {
 		if (ev instanceof ControlEvent) {
 			switch (ev.type) {
@@ -40,19 +44,8 @@
 					super.onControlEvent(ev);	
 				} else if (ev.action.startsWith(LINE)) {
 					selectedItem = ev.action.charAt(LINE.length()) - '0';
-//					Object clickedItem =  model.get(line + firstLine);
-//					Form form = new PDATravelbugDetailPanel(tbJourney, this);
-//					form.setPreferredSize(800, 600);
-//					form.execute();
-//					setupTBButtons();
 					exit(0);
 				} else if (ev.action.equals(MENUE)) {
-//					Form form = new PDATravelbugMenuPanel(this);
-//					form.setPreferredSize(800, 600);
-//					int execute = form.execute();
-//					if (execute == 1){
-//						exit(0);
-//					}
 					setupTBButtons();
 				}
 				break;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003099.html">[Cachewolf-svn] r3108 - trunk/src/CacheWolf/imp
</A></li>
	<LI>Next message: <A HREF="003101.html">[Cachewolf-svn] r3110 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3100">[ date ]</a>
              <a href="thread.html#3100">[ thread ]</a>
              <a href="subject.html#3100">[ subject ]</a>
              <a href="author.html#3100">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
