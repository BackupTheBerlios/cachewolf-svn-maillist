<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r884 - in trunk/src/CacheWolf: . navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-September/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r884%20-%20in%20trunk/src/CacheWolf%3A%20.%20navi&In-Reply-To=%3C200709051331.l85DVZH5004963%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000776.html">
   <LINK REL="Next"  HREF="000778.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r884 - in trunk/src/CacheWolf: . navi</H1>
    <B>pfeffer at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r884%20-%20in%20trunk/src/CacheWolf%3A%20.%20navi&In-Reply-To=%3C200709051331.l85DVZH5004963%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r884 - in trunk/src/CacheWolf: . navi">pfeffer at mail.berlios.de
       </A><BR>
    <I>Wed Sep  5 15:31:35 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000776.html">[Cachewolf-svn] r883 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="000778.html">[Cachewolf-svn] r885 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#777">[ date ]</a>
              <a href="thread.html#777">[ thread ]</a>
              <a href="subject.html#777">[ subject ]</a>
              <a href="author.html#777">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pfeffer
Date: 2007-09-05 15:31:24 +0200 (Wed, 05 Sep 2007)
New Revision: 884

Added:
   trunk/src/CacheWolf/navi/
   trunk/src/CacheWolf/navi/Area.java
   trunk/src/CacheWolf/navi/CWGPSPoint.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/Map.java
   trunk/src/CacheWolf/navi/MapDetailForm.java
   trunk/src/CacheWolf/navi/MapImage.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
   trunk/src/CacheWolf/navi/MapLoader.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MapSymbol.java
   trunk/src/CacheWolf/navi/MapsList.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/Navigate.java
   trunk/src/CacheWolf/navi/SelectMap.java
   trunk/src/CacheWolf/navi/SkyOrientation.java
   trunk/src/CacheWolf/navi/Track.java
   trunk/src/CacheWolf/navi/TrackOverlay.java
   trunk/src/CacheWolf/navi/TrackPoint.java
Log:
I hope, it works now

Added: trunk/src/CacheWolf/navi/Area.java
===================================================================
--- trunk/src/CacheWolf/navi/Area.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Area.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,74 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+
+public class Area {
+	 public final static int NOT_ON_EDGE = -1;
+	 public final static int AT_TOP_EDGE = 1;
+	 public final static int AT_RIGHT_EDGE = 2;
+	 public final static int AT_BUTTOM_EDGE = 3;
+	 public final static int AT_LEFT_EDGE = 4;
+	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
+
+	 CWPoint topleft;
+	 CWPoint buttomright;
+
+	 public Area(CWPoint tl, CWPoint br){
+		 topleft = new CWPoint(tl);
+		 buttomright = new CWPoint(br);
+	 }
+
+	 public boolean isInBound(CWPoint p) {
+		 if (topleft.latDec &gt;= p.latDec &amp;&amp; topleft.lonDec &lt;= p.lonDec 
+				 &amp;&amp; buttomright.latDec &lt;= p.latDec &amp;&amp; buttomright.lonDec &gt;= p.lonDec) return true;
+		 else return false;
+	 }
+	 //if(affine[4] &gt;= lati &amp;&amp; lati &gt;= lowlat &amp;&amp; affine[5] &lt;= loni &amp;&amp; loni &lt;= lowlon) isInBound = true;
+		
+	 public boolean isInBound(double lat, double lon) {
+		 if (topleft.latDec &gt;= lat &amp;&amp; topleft.lonDec &lt;= lon
+				 &amp;&amp; buttomright.latDec &lt;= lat &amp;&amp; buttomright.lonDec &gt;= lon) return true;
+		 else return false;
+	 }
+	 
+	 public boolean isOverlapping(Area a) {
+		 if (       isInBound(a.topleft) || isInBound(a.buttomright) 
+				 || isInBound(a.buttomright.latDec, a.topleft.lonDec) // buttom left
+				 || isInBound(a.topleft.latDec, a.buttomright.lonDec) // top right
+				 // in case this is completly within a, the above tests will give false, so testing the otherway around
+				 || a.isInBound(this.topleft) || a.isInBound(this.buttomright)
+				 || a.isInBound(this.buttomright.latDec, this.topleft.lonDec) // buttom left
+				 || a.isInBound(this.topleft.latDec, this.buttomright.lonDec)) // top right
+			 return true;
+		 else return false;
+	 }
+
+	 public boolean equals(Area a) {
+		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) &lt; edgeTolerance 
+				 &amp;&amp; java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) &lt; edgeTolerance
+				 &amp;&amp; java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) &lt; edgeTolerance
+				 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) &lt; edgeTolerance )
+			 return true;
+		 else return false;
+	 }
+	 
+	 public int getEdge(CWPoint tl, CWPoint br) {
+		 if (java.lang.Math.abs(topleft.latDec - br.latDec) &lt; edgeTolerance 
+				 &amp;&amp; java.lang.Math.abs(topleft.lonDec - tl.lonDec) &lt; edgeTolerance 
+				 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - br.lonDec) &lt; edgeTolerance)
+			 return AT_TOP_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - tl.lonDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - br.latDec) &lt; edgeTolerance)
+				 return AT_RIGHT_EDGE;
+			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - tl.latDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - br.lonDec) &lt; edgeTolerance)
+				 return AT_BUTTOM_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(topleft.lonDec - br.lonDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - br.latDec) &lt; edgeTolerance)
+				 return AT_LEFT_EDGE;
+			 return NOT_ON_EDGE;
+	 }
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/CWGPSPoint.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/CWGPSPoint.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,336 @@
+/*
+ * Created on 02.04.2005
+ *
+ * TODO To change the template for this generated file go to
+ * Window - Preferences - Java - Code Style - Code Templates
+ */
+package CacheWolf.navi;
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import ewe.sys.*;
+import ewe.ui.ExecTransfer;
+import ewe.io.*;
+
+
+
+/**
+ * @author Kalle
+ * Class for decoding NMEA sentences
+ */
+
+public class CWGPSPoint extends CWPoint implements TimerProc{
+	public static final int LOGNMEA = 0x01;
+	public static final int LOGRAW  = 0x02;
+	public static final int LOGALL  = LOGNMEA|LOGRAW;
+
+	public double Speed; //Speed
+	public double Bear;	//Bearing
+	public String Time; //Time
+	public String Date;
+	public int Fix; //Fix
+	public int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
+	public double HDOP; // Horizontal dilution of precision
+	public double Alt; //Altitude
+
+	//Logging
+	int logTimer = 0;
+	int logFlag = 0;
+	boolean writeLog = false;
+	boolean doLogging = false;
+	FileWriter logFile;
+	String lastStrExamined = new String();
+
+
+	public CWGPSPoint()
+	{
+		super();
+		this.Speed = 0;
+		this.Bear = 0;
+		this.Time = &quot;&quot;;
+		this.Date=&quot;&quot;;
+		this.Fix = 0;
+		this.numSat = 0;
+		this.Alt = 0;
+		this.HDOP = 0;
+	}
+
+
+	public double getSpeed(){
+		return this.Speed;
+	}
+
+	public double getBear (){
+		return this.Bear;
+	}
+	public String getTime(){
+		return this.Time;
+	}
+
+	public int getFix(){
+		return this.Fix;
+	}
+
+	/**
+	 * this method should be called, if COM-Port is closed
+	 */
+	public void noData(){
+		this.Fix = 0;
+		this.numSat = 0;
+	}
+
+	/**
+	 * this method should be called, if not data is coming from COM-Port but is expected to come
+	 */
+	public void noDataError(){
+		this.Fix = -1;
+		this.numSat = -1;
+	}
+
+	/**
+	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
+	 */
+	public void noInterpretableData(){
+		this.Fix = -2;
+		this.numSat = -2;
+	}
+
+	public void ticked(int timerId, int elapsed){
+		if (timerId == logTimer) {
+			writeLog = true;
+		}
+
+	}
+
+	/**
+	 * 
+	 * @param logFileDir directory for logfile
+	 * @param seconds	 intervall for writing to logfile
+	 * @param flag		 level of logging
+	 * @return 0 success, -1 failure
+	 */
+	public int startLog(String logFileDir, int seconds, int flag){
+
+		Time currTime = new Time();
+		currTime.getTime();
+		currTime.setFormat(&quot;yyyyMMdd'_'HHmm&quot;);
+		String logFileName = new String(logFileDir + currTime.toString()+ &quot;.log&quot;);
+		// create Logfile
+		try {
+			logFile = new FileWriter(logFileName);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error creating LogFile &quot; + logFileName);
+			return -1;
+		} 
+		// start timer
+		logTimer = Vm.requestTimer(this, 1000 * seconds);
+		logFlag = flag;
+		doLogging = true;
+		return 0;
+	}
+
+	public void stopLog() {
+		writeLog = false;
+
+		if (doLogging){
+			try {
+				logFile.close();
+			} catch (IOException e) {}
+			if (logTimer &gt; 0) {
+				Vm.cancelTimer(logTimer);
+				logTimer = 0;
+			}
+		}
+		doLogging = false;
+	}
+
+
+	public int getSats(){
+		return this.numSat;
+	}
+
+	public double getAlt(){
+		return this.Alt;
+	}
+
+	public double getHDOP(){
+		return this.HDOP;
+	}
+
+	/**
+	 * 
+	 * @param NMEA	string with data to examine
+	 * @return true if some data could be interpreted false otherwise
+	 */
+	public boolean examine(String NMEA){ 
+		boolean interpreted = false;
+		try {
+			int i, start, end;
+			String latDeg=&quot;0&quot;, latMin=&quot;0&quot;, latNS=&quot;N&quot;; 
+			String lonDeg=&quot;0&quot;, lonMin=&quot;0&quot;, lonEW=&quot;E&quot;;
+			String currToken;
+			end = 0;
+			lastStrExamined = NMEA;
+			//Vm.debug(NMEA);
+			if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){ 
+				try {
+					logFile.write(NMEA);
+					writeLog = false;
+				} catch (IOException e) {}
+			}
+			while(true){
+				start = NMEA.indexOf(&quot;$GP&quot;, end);  
+				if (start == -1) return interpreted;  
+				end = NMEA.indexOf(&quot;*&quot;, start);  
+				if ((end == -1)||(end+3 &gt; NMEA.length())) return interpreted;  
+
+
+				//Vm.debug(NMEA.substring(start,end+3));
+				if ((end - start) &lt; 15 || !checkSumOK(NMEA.substring(start,end+3))){
+					//Vm.debug(&quot;checksum wrong&quot;);
+					continue;
+				}
+				Extractor ex = new Extractor (&quot;,&quot; + NMEA.substring(start,end), &quot;,&quot;,&quot;,&quot;,0,true);
+				currToken = ex.findNext();
+				if (currToken.equals(&quot;$GPGGA&quot;)){
+					//Vm.debug(&quot;In $GPGGA&quot;);
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
+						switch (i){
+						case 1: this.Time = currToken; break;
+						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
+						case 3: latNS = currToken;
+						break;
+
+						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {}
+						break;
+						case 5: lonEW = currToken;
+						break;
+						case 6: this.Fix = Convert.toInt(currToken); interpreted = true; break;
+						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
+						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						} // switch
+					} // while
+					if (Fix &gt; 0) this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);
+
+				} // if
+
+				if (currToken.equals(&quot;$GPVTG&quot;)){
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						switch (i){
+						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
+						if (this.Bear &gt; 360) Vm.debug(&quot;Error bear VTG&quot;);
+						break;
+						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} 
+						break;
+						} // switch
+					} // while
+				} // if
+
+				if (currToken.equals(&quot;$GPRMC&quot;)){
+					//Vm.debug(&quot;In $GPRMC&quot;);
+					i = 0;
+					String status = &quot;V&quot;;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						//Vm.debug(&quot;zz: &quot; + i);
+						//Vm.debug(currToken);
+						switch (i){
+						case 1: this.Time = currToken; interpreted = true; break;
+						case 2: status = currToken; 
+						if (status.equals(&quot;A&quot;)) this.Fix = 1;
+						else this.Fix = 0;
+						interpreted = true;
+						break;
+						case 3: 	//Vm.debug(&quot;Here---&gt;&quot;);
+							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(&quot;:&quot; + latDeg);
+							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(&quot;:&quot; + latMin);
+							break;
+						case 4: latNS = currToken; interpreted = true;
+						break;
+						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
+						case 6: lonEW = currToken;
+						interpreted = true;
+						break;
+						case 7: if (status.equals(&quot;A&quot;)){
+							try {this.Speed = Common.parseDouble(currToken)*1.854;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 8: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
+							try {this.Bear = Common.parseDouble(currToken);
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 9: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
+							try {this.Date = currToken;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						} // switch
+					} // while
+					if (status.equals(&quot;A&quot;)){
+						this.set(latNS, latDeg, latMin, &quot;0&quot;,
+								lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);				
+					}
+				} // if
+				//Vm.debug(&quot;End of examine&quot;);
+			} //while
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Exception in examine in CWGPSPoint&quot;, e, true);
+			e.printStackTrace();
+			return interpreted;
+		}
+	}
+
+	private boolean checkSumOK(String nmea){
+		int startPos = 1; // begin after $
+		int endPos = nmea.length() - 3;// without * an two checksum chars
+		byte checkSum = 0;
+
+		for (int i= startPos; i&lt;endPos;i++){
+			checkSum ^= nmea.charAt(i);
+		}
+		//Vm.debug(nmea.substring(3,6)+&quot; Checksum: &quot; + nmea.substring(endPos+1) + &quot; Calculated: &quot; + Convert.intToHexString(checkSum));
+		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		} catch (IndexOutOfBoundsException e) {
+			return false;
+		} catch (NumberFormatException e) {
+			return false;
+		}
+	}
+
+
+
+	public void printAll(){
+		Vm.debug(&quot;Latitude:  &quot; + this.getLatDeg(DD));
+		Vm.debug(&quot;Longitude: &quot; + this.getLonDeg(DD));
+		Vm.debug(&quot;Speed:     &quot; + this.Speed);
+		Vm.debug(&quot;Bearing:   &quot; + this.Bear);
+		Vm.debug(&quot;Time:      &quot; + this.Time);
+		Vm.debug(&quot;Fix:       &quot; + this.Fix);
+		Vm.debug(&quot;Sats:      &quot; + this.numSat);
+		Vm.debug(&quot;HDOP:      &quot; + this.HDOP);
+		Vm.debug(&quot;Alt:       &quot; + this.Alt);
+		Vm.debug(&quot;----------------&quot;);
+	}
+}
+

Added: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,847 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CoordsScreen;
+import CacheWolf.DetailsPanel;
+import CacheWolf.Global;
+import CacheWolf.MainTab;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import ewe.ui.*;
+import ewe.util.Vector;
+import ewe.util.mString;
+import ewe.fx.*;
+import ewe.graphics.AniImage;
+import ewe.io.*;
+import ewe.net.Socket;
+//import ewe.io.IOException;
+//import ewe.io.SerialPort;
+//import ewe.io.SerialPortOptions;
+import ewe.sys.*;
+import ewe.sys.Double;
+
+/**
+ *	Class to create the panel which handles the connection to the GPS-device&lt;br&gt;
+ *	Displays: current position,speed and bearing; relation to destination waypoint&lt;br&gt;
+ *	Class ID: 1500
+ */
+
+
+public class GotoPanel extends CellPanel {
+
+	//public CWGPSPoint gpsPosition = new CWGPSPoint();
+	//public CWPoint toPoint = new CWPoint();
+	public Navigate myNavigation;
+	mButton btnGPS, btnCenter,btnSave;
+	mButton btnGoto, btnMap;
+	int currFormat;
+
+	mLabel lblGPS, lblPosition, lblDST;
+	mLabel lblLog;
+	Color gpsStatus;
+	mCheckBox chkLog;
+	mInput inpLogSeconds;
+
+	MainTab mainT;
+	Vector cacheDB;
+	DetailsPanel detP;
+
+	Preferences pref;
+	Profile profile;
+	// different panels to avoid spanning
+	CellPanel ButtonP = new CellPanel();
+	CellPanel CoordsP = new CellPanel();
+	CellPanel roseP = new CellPanel();
+	CellPanel LogP = new CellPanel();
+
+	ImageControl icRose;
+	GotoRose compassRose;
+
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+
+	final static Font BOLD = new Font(&quot;Arial&quot;, Font.BOLD, 14);
+
+	int ticker = 0;
+	
+	Menu mnuContextFormt;
+	MenuItem miDMM, miDMS, miDD, miUTM;
+	
+	Menu mnuContextRose;
+	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+	MenuItem miNorthCentered;
+	
+	/**
+	 * Create GotoPanel 
+	 * @param Preferences 	global preferences
+	 * @param MainTab		reference to MainTable
+	 * @param DetailsPanel 	reference to DetailsPanel
+	 * @param Vector		cacheDB
+	 */
+	public GotoPanel(Navigate nav) {
+		myNavigation = nav;
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		mainT = Global.mainTab;
+		detP = mainT.detP;
+		cacheDB = profile.cacheDB;
+
+		// Button
+		ButtonP.addNext(btnGPS = new mButton(&quot;Start&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,&quot;Center&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnSave = new mButton(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addLast(btnMap = new mButton(&quot;Map&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		//Format selection for coords		
+		//context menu
+		mnuContextFormt = new Menu();
+		mnuContextFormt.addItem(miDD = new MenuItem(&quot;d.d&#176;&quot;));
+		miDD.modifiers &amp;= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miDMM = new MenuItem(&quot;d&#176;m.m\'&quot;));
+		miDMM.modifiers |= MenuItem.Checked;
+		mnuContextFormt.addItem(miDMS = new MenuItem(&quot;d&#176;m\'s\&quot;&quot;));
+		miDMS.modifiers &amp;= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miUTM = new MenuItem(&quot;UTM&quot;));
+		miUTM.modifiers &amp;= ~MenuItem.Checked;
+		currFormat = CWPoint.DMM;
+
+		// Create context menu for compass rose: select luminary for orientation
+		mnuContextRose = new Menu();
+		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+			else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+		}
+
+		//Coords
+		CoordsP.addNext(lblGPS = new mLabel(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblGPS.backGround = RED;
+		lblGPS.setMenu(mnuContextFormt);
+		lblGPS.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addLast(lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		lblPosition.setMenu(mnuContextFormt);
+		lblPosition.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,&quot;DST:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblDST.backGround = new Color(0,0,255);
+		lblDST.setMenu(mnuContextFormt);
+		lblDST.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		//Rose for bearing
+		compassRose = new GotoRose(&quot;rose.png&quot;);
+		icRose = new ImageControl(compassRose);
+		icRose.setMenu(mnuContextRose);
+		icRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
+		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		
+		mnuContextRose.addItem(new MenuItem(&quot;&quot;, MenuItem.Separator, null));
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,&quot;North Centered&quot;)));
+		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
+		else miNorthCentered.modifiers &amp;= MenuItem.Checked;
+
+		//log
+		LogP.addNext(lblLog = new mLabel(&quot;Log &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addNext(chkLog = new mCheckBox(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addNext(inpLogSeconds = new mInput(&quot;10&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addLast(new mLabel(&quot;sec&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		chkLog.useCross = true;
+		chkLog.setState(false);
+		inpLogSeconds.columns = 5;
+
+		//add Panels
+		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
+		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));
+		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
+		//this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
+
+		// for debuging
+		/*		CWGPSPoint myGPS;
+		myGPS = new CWGPSPoint();
+		String ex = new String();
+		boolean test = false;
+		try { FileReader f = new FileReader(&quot;c:\\kw\\20060928_1051.log&quot;);
+		ex = f.readAll();
+		test = myGPS.examine(ex);
+		f.close();
+		} catch (IOException e ) {
+			Vm.debug(e.toString());
+		}
+		test = myGPS.examine(&quot;$GPGLL,5226.8935,N,01338.5327,E,084635.00,A,D*6E&quot;);
+		test = myGPS.examine(&quot;$GPGSA,A,3,10,28,26,29,09,,,,,,,,04.1,02.6,03.2*0F&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,1,13,08,40,072,28,10,29,201,47,27,15,079,29,28,62,102,44*7E&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,2,13,29,72,289,38,26,63,296,41,09,12,259,35,18,14,324,*79&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,3,13,19,09,025,,17,06,138,,21,06,300,,37,29,171,40*7A&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,4,13,39,29,166,38*40&quot;);
+		 */
+
+		//while (true){
+//		int notinterpreted = 0;
+//		if (myGPS.examine(&quot;@&#246;&#246;H @&#246;&#246;H&#246;@&#214;&#214;HH&#220;&#196;&#220;&#214;&#196;&#196;&#196;H&quot;)) { notinterpreted = 0;} else notinterpreted++;
+//		if (notinterpreted &gt; 5) myGPS.noInterpretableData();
+//		// myGPS.noInterpretableData();
+
+
+//		}	
+	}
+
+
+	/**
+	 * set the coords of the destination  
+	 * @param dest destination
+	 */ 
+	public void setDestination(CWPoint dest){
+		myNavigation.setDestination(dest);
+		if (!myNavigation.destination.isValid()) (new MessageBox(&quot;Error&quot;, &quot;Coordinates are out of range: \n&quot;+&quot;latitude: &quot;+myNavigation.destination.latDec+&quot;\n longditue: &quot;+myNavigation.destination.lonDec, MessageBox.OKB)).execute();
+		
+	}
+	
+	public void destChanged(CWPoint d) { // called from myNavigate
+		btnGoto.setText(getGotoBtnText());
+		updateDistance();
+	}
+	
+
+	/**
+	 * set the coords of the destination and switch to gotoPanel  
+	 * @param LatLon destination
+	 */ 
+	public void setDestinationAndSwitch(String LatLon) {
+		myNavigation.setDestination(LatLon);
+		mainT.select(this);
+	}
+	
+	/**
+	 * updates distance and bearing
+	 *
+	 */
+	
+	public void updateDistance() {
+		//update distance
+		float distance = -1.0f;
+		if (myNavigation.gpsPos.isValid() &amp;&amp; myNavigation.destination.isValid() ) {
+			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		}
+		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+	}
+
+	/**
+	 * method which is called if a timer is set up  
+	 */ 
+	public void updateGps(int fix) {
+		Double bearMov = new Double();
+		Double speed = new Double();
+		Double sunAzimut = new Double();
+		Vm.debug(&quot;ticked: voher&quot;);
+		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getHDOP());
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+			// display values only, if signal good
+			//Vm.debug(&quot;currTrack.add: nachher&quot;);
+			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
+			bearMov.set(myNavigation.gpsPos.getBear());
+			updateDistance();
+			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			// Set background to signal quality
+		}
+
+		// receiving data, but signal ist not good
+		if ((fix == 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+			gpsStatus = YELLOW;
+		}
+		// receiving no data
+		if (fix == -1) {
+			if (gpsStatus != RED) (new MessageBox(&quot;Error&quot;, &quot;No data from GPS\nConnection to serial port closed&quot;,MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps();
+		}
+		// cannot interprete data
+		if (fix == -2) {
+			if (gpsStatus != RED) (new MessageBox(&quot;Error&quot;, &quot;Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n &quot;+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps(); // TODO automatic in myNavigate?
+		}
+	}
+
+	public void gpsStarted() {
+		chkLog.modify(ControlConstants.Disabled,0);
+		btnGPS.setText(&quot;Stop&quot;);
+	}
+	
+	public void startGps() {
+		myNavigation.setRawLogging(chkLog.getState(), Convert.toInt(inpLogSeconds.getText()));
+		myNavigation.startGps();
+	}
+
+	public void gpsStoped() {
+		btnGPS.setText(&quot;Start&quot;);
+		gpsStatus = this.backGround;
+		chkLog.modify(0,ControlConstants.Disabled);
+		this.repaintNow(); // without this the change in the background color will not be displayed
+	}
+
+	
+	private String getGotoBtnText() {
+		if (myNavigation.destination == null) return &quot;not set&quot;;
+		else return myNavigation.destination.toString(currFormat);
+	}
+	
+	public void switchToMovingMap() {
+		CWPoint centerTo;
+		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		else {
+			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
+			//centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			else centerTo = new CWPoint(pref.curCentrePt); // if not goto-point defined move map to centere point
+		}  
+		mainT.SwitchToMovingMap(centerTo, false);
+	}
+	
+	/**
+	 * Eventhandler
+	 */
+
+	public void onEvent(Event ev){
+		if (ev instanceof MenuEvent) { 
+			if (ev.type == MenuEvent.SELECTED ) {
+				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem(); 
+				if (action != null) {
+					if (action == miDD) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DD;
+					}
+					if (action == miDMM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMM;
+					}
+					if (action == miDMS) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMS;
+					}
+					if (action == miUTM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.UTM;
+					}
+					miDD.modifiers &amp;= ~MenuItem.Checked;
+					miDMM.modifiers &amp;= ~MenuItem.Checked;
+					miDMS.modifiers &amp;= ~MenuItem.Checked;
+					miUTM.modifiers &amp;= ~MenuItem.Checked;
+					switch (currFormat) {
+					case CWPoint.DD: miDD.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.DMM: miDMM.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.DMS: miDMS.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.UTM: miUTM.modifiers |= MenuItem.Checked; break;
+					}
+
+					lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+					btnGoto.setText(getGotoBtnText());
+				} // end lat-lon-format context menu
+				action = (MenuItem) mnuContextRose.getSelectedItem();
+				if (action != null) {
+					for (int i=0; i&lt;miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							myNavigation.setLuminary(i);
+							miLuminary[i].modifiers |= MenuItem.Checked;
+							compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
+						} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+					}
+					if (action == miNorthCentered) {
+						if (compassRose.isNorthCentered()) {
+							compassRose.setNorthCentered(false);
+							miNorthCentered.modifiers &amp;= ~MenuItem.Checked;							
+						}
+						else
+						{
+							compassRose.setNorthCentered(true);
+							miNorthCentered.modifiers |= MenuItem.Checked;
+						}
+					}
+				}
+			}
+		}
+
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			// start/stop GPS connection
+			if (ev.target == btnGPS){
+				if (btnGPS.getText().equals(&quot;Start&quot;)) startGps();
+				else myNavigation.stopGps();
+			}
+
+			// set current position as center and recalculate distance of caches in MainTab 
+			if (ev.target == btnCenter){
+				Vm.showWait(true);
+				pref.curCentrePt.set(myNavigation.gpsPos);
+				mainT.updateBearDist();
+				Vm.showWait(false);
+			}
+			//Start moving map
+			if (ev.target == btnMap){
+				switchToMovingMap();
+			} 
+			// create new waypoint with current GPS-position
+			if (ev.target == btnSave){
+				CacheHolder ch = new CacheHolder();
+				ch.LatLon = myNavigation.gpsPos.toString();
+				ch.pos = new CWPoint(myNavigation.gpsPos);
+				mainT.newWaypoint(ch);
+			}
+			// change destination waypoint
+			if (ev.target == btnGoto){
+				CoordsScreen cs = new CoordsScreen();
+				if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, currFormat);
+				else cs.setFields(new CWPoint(0,0), currFormat);
+				if (cs.execute(null, Gui.TOP) == CoordsScreen.IDOK)
+					setDestination(cs.getCoords());
+			}
+		}
+		super.onEvent(ev);
+	}
+}
+
+/** class for displaying the compass rose
+ * including goto, sun and moving direction
+ */
+class GotoRose extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+	float distance = -1;
+	
+	int m_fix = -1;
+	int m_sats = -1;
+	double m_hdop = -1;
+	float m_speed = -1;
+	
+	String m_Luminary = MyLocale.getMsg(6100, &quot;Sun&quot;);
+	
+	FontMetrics fm;
+	
+	boolean northCentered = Global.getPref().northCenteredGoto;
+	
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+	final static Color ORANGE = new Color(255,128,0);
+	final static Color DARKGREEN = new Color(0,192,0);
+	final static Color CYAN = new Color(0,255,255);
+	final static Color MAGENTA = new Color(255,0,255);
+
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public GotoRose(String fn){
+		super(fn);
+	}
+	
+	public void setWaypointDirectionDist(float wd, float dist) {
+		gotoDir = wd;
+		distance = dist;
+	}
+	
+	public void setSunMoveDirections(float sd, float md, float speed ) {
+		sunDir = sd;
+		moveDir = md;
+		m_speed = speed;
+		refresh();
+	}
+	
+	public void setGpsStatus(int fix, int sats, double hdop) {
+		m_fix = fix;
+		m_sats = sats;
+		m_hdop = hdop;
+		refresh();
+	}
+	
+	public void setLuminaryName(String Luminary) {
+		m_Luminary = Luminary;
+		refresh();
+	}
+
+	
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+	
+	public void doDraw(Graphics g,int options) {
+		if (northCentered) {
+			super.doDraw(g, options);
+		}
+		else {
+			g.setColor(Color.White);
+			g.fillRect(0, 0, location.width, location.height);
+		}
+		Font font = new Font(&quot;Verdana&quot;, Font.BOLD, 12);
+		g.setFont(font);
+		fm = g.getFontMetrics(font);
+		drawArrows(g);
+		drawWayPointData(g);
+		drawGpsData(g);
+		drawLuminaryData(g);
+		drawGpsStatus(g);
+	}
+		
+	private void drawWayPointData(Graphics g){
+		String strTemp = &quot;WayPoint&quot;;
+		g.setColor(Color.DarkBlue);
+		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4 ,fm.getHeight());
+		g.setColor(Color.White);		
+		g.drawText(strTemp, 2, 0);
+		
+		g.setColor(Color.Black);		
+		
+		Double tmp = new Double();
+		strTemp = &quot;&quot;;
+		if ( distance &gt;= 0.0f ) {
+			tmp.set(distance);
+			if (tmp.value &gt;= 1){
+				strTemp = MyLocale.formatDouble(tmp,&quot;0.000&quot;)+ &quot; km&quot;;
+			}
+			else {
+				tmp.set(tmp.value * 1000);
+				strTemp = tmp.toString(3,0,0) + &quot; m&quot;;
+			}
+		}
+		else strTemp = &quot;--- km&quot;;
+		g.drawText(strTemp, 2, 12);
+		
+		tmp.set(gotoDir);
+		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
+			strTemp = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		else strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		g.drawText(strTemp, 2, 24);
+	}
+	
+	private void drawGpsData(Graphics g){
+		g.setColor(RED);
+		
+		String strHeadline = MyLocale.getMsg(1501,&quot;Current&quot;);
+		
+		Double tmp = new Double();
+
+		tmp.set(m_speed);
+		String strSpeed = &quot;- km/h&quot;;
+		if (m_speed &gt;= 0) {
+			if (m_speed &gt;= 100) {
+				strSpeed = MyLocale.formatDouble(tmp,&quot;0&quot;) + &quot; km/h&quot;;				
+			}
+			else {
+				strSpeed = MyLocale.formatDouble(tmp,&quot;0.0&quot;) + &quot; km/h&quot;;
+			}
+		}
+		
+		tmp.set(moveDir);
+		String strMoveDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
+			strMoveDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
+		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
+		
+		int startX = location.width - (textWidth + 4);
+		g.fillRect(startX, 0, location.width - startX ,12);
+		
+		g.setColor(Color.Black);		
+		g.drawText(strHeadline, startX + 2, 0);		
+		g.drawText(strSpeed, startX + 2, 12);
+		g.drawText(strMoveDir, startX + 2, 24);
+	}
+	
+	private void drawLuminaryData(Graphics g){
+		g.setColor(YELLOW);
+
+		String strSunDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) {
+			Double tmp = new Double();
+			tmp.set(sunDir);
+			strSunDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		}
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
+		int startY = location.height - 24;
+		g.fillRect(0, startY, textWidth + 4, location.height - startY);
+
+		g.setColor(Color.Black);		
+		g.drawText(m_Luminary, 2, startY);
+		g.drawText(strSunDir, 2, startY + 12);
+	}
+	
+	private void drawGpsStatus(Graphics g){
+		if ((m_fix &gt; 0) &amp;&amp; (m_sats &gt;= 0)) {
+			// Set background to signal quality
+			g.setColor(GREEN);
+		}
+		else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) &amp;&amp; (m_sats &gt;= 0)) {
+			g.setColor(YELLOW);
+		}
+		else {
+			g.setColor(RED);
+		}
+
+		String strSats = &quot;Sats: -&quot;;
+		if (m_sats &gt;= 0) strSats = &quot;Sats: &quot; + Convert.toString(m_sats);
+		String strHdop = &quot;HDOP: -&quot;;
+		if (m_hdop &gt;= 0) strHdop = &quot;HDOP: &quot; + Convert.toString(m_hdop);
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
+		int startX = location.width - (textWidth + 4);
+		int startY = location.height - 24;
+		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+
+		g.setColor(Color.Black);
+		g.drawText(strSats, startX + 2, startY);
+		g.drawText(strHdop, startX + 2, startY + 12);
+	}
+
+	private void drawArrows(Graphics g){
+		if (g != null)
+		{
+			// select moveDirColor according to difference to gotoDir
+			Color moveDirColor = RED;
+			
+			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360 &amp;&amp; moveDir &lt; 360 &amp;&amp; moveDir &gt; -360)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff &gt; 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff &gt; 180.0f)
+				{
+					diff = 360.0f - diff;
+				}
+				
+				if (diff &lt;= 12.25f)
+				{
+					moveDirColor = GREEN;
+				}
+				else if (diff &lt;= 22.5f)
+				{
+					moveDirColor = CYAN;
+				}
+				else if (diff &lt;= 45.0f)
+				{
+					moveDirColor = ORANGE;
+				}
+				else if (diff &lt;= 90.0f)
+				{
+					moveDirColor = MAGENTA;
+				}
+			}
+
+			// draw only valid arrows
+			if (northCentered) {
+				if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			}
+			else {
+				//moveDir centered
+				int radius = (int)((float)(java.lang.Math.min(location.width, location.height) / 2) * 0.75f);
+
+				g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
+				g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+
+				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
+					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					
+					g.setPen(new Pen(RED,Pen.SOLID,3));
+					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					
+					if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
+				}				
+			}
+		}
+	}
+
+	/**
+	 * draw single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad;
+		int x, y, centerX = location.width/2, centerY = location.height/2;
+		int arrowLength = java.lang.Math.min(centerX, centerY); 
+
+		angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
+		y = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad) * scale).intValue();
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(centerX,centerY,x,y);
+	}
+	
+	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.08f;
+		float circlePos = arrowLength * 0.7f;
+		int circleRadius = (int)(arrowLength * 0.1f);
+
+		int pointX = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		int pointY = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
+		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
+
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+//		g.setPen(new Pen(col,Pen.SOLID,3));
+//		g.drawLine(centerX,centerY,pointX,pointY);
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
+	}
+	
+	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float sideLineLength = arrowLength * 0.75f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
+		pointsY[0] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
+		pointsY[2] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
+		pointsX[3] = centerX;
+		pointsY[3] = centerY;
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+		if (colPoint != null) {
+			g.setBrush(new Brush(colPoint, Brush.SOLID));
+			g.fillPolygon(pointsX, pointsY, 3);			
+		}
+	}
+	
+	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[3];
+		int[] pointsY = new int[3];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+		
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
+	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.12f;
+		
+		int[] pointsX = new int[8];
+		int[] pointsY = new int[8];
+
+		pointsX[0] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsY[0] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsX[3] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[4] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[4] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[5] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[5] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[6] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(colRear,Pen.SOLID,1));
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 8);
+		
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
+	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+	}
+	
+	public void setNorthCentered(boolean nc) {
+		northCentered = nc;
+		if (northCentered != Global.getPref().northCenteredGoto) {
+			Global.getPref().northCenteredGoto = northCentered;
+			Global.getPref().savePreferences();
+		}
+		refresh();
+	}
+	
+	public boolean isNorthCentered() {
+		return northCentered;
+	}
+}

Added: trunk/src/CacheWolf/navi/Map.java
===================================================================
--- trunk/src/CacheWolf/navi/Map.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Map.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,500 @@
+package CacheWolf.navi;
+
+import ewe.util.*;
+import ewe.io.*;
+import ewe.filechooser.*;
+import ewe.sys.*;
+import ewe.ui.*;
+import ewe.graphics.*;
+import ewe.fx.*;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.CoordsScreen;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.Matrix;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+
+import com.stevesoft.ewe_pat.*;
+
+/**
+ *	This class is the main class for mapping,
+ *	 (moving map, georeferencing maps, etc)
+ *	in CacheWolf.
+ *	It also provides a class for importing maps
+ *	This class id=4100
+ */
+public class Map extends Form {
+	Preferences pref;
+	String mapsPath = new String();
+	String thisMap = new String();
+	public String selectedMap = new String();
+	CellPanel infPanel;
+	mLabel infLabel = new mLabel(&quot;                          &quot;);
+	Vector GCPs = new Vector();
+	MapInfoObject wfl = new MapInfoObject();
+	mButton infButton;
+	ScrollBarPanel scp;
+	AniImage mapImg;
+	int imageWidth, imageHeight = 0;
+
+	/**
+	 *	This constructor should be used when importing maps
+	 */
+	public Map(Preferences pref){
+		this.pref = pref;
+		mapsPath = pref.getMapManuallySavePath(true)+&quot;/&quot;; //File.getProgramDirectory() + &quot;/maps/&quot;;
+	}
+
+	/**
+	 *	When a user clicks on the map and more than three ground control points exist
+	 *	then the calculated coordinate based on the affine transformation is displayed in the
+	 *	info panel below the map.
+	 *	It helps to identify how good the georeferencing works based on the set GCPs.
+	 */
+	public void updatePosition(int x, int y){
+		if(GCPs.size()&gt;=3  || (wfl.affine[4] &gt; 0 &amp;&amp; wfl.affine[5] &gt; 0)){
+			double x_ = 0;
+			double y_ = 0;
+			x_ = wfl.affine[0]*x + wfl.affine[2]*y + wfl.affine[4];
+			y_ = wfl.affine[1]*x + wfl.affine[3]*y + wfl.affine[5];
+			CWPoint p = new CWPoint(x_ , y_);
+			infLabel.setText(&quot;--&gt; &quot; + p.getLatDeg(CWPoint.DMS) + &quot; &quot; +p.getLatMin(CWPoint.DMM) + &quot; / &quot; + p.getLonDeg(CWPoint.DMS) + &quot; &quot; + p.getLonMin(CWPoint.DMM));
+		}
+	}
+
+	/**
+	 *	This is the correct constructor for georeferencing maps.
+	 */
+	public Map(Preferences pref, String mapToLoad, boolean worldfileexists){
+		this.pref = pref;
+		this.title = MyLocale.getMsg(4106,&quot;Calibrate map:&quot;) + &quot; &quot; + mapToLoad;
+		this.resizable = true;
+		this.moveable = true;
+		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		thisMap = mapToLoad;
+		mapsPath = pref.getMapManuallySavePath(true)+&quot;/&quot;; //File.getProgramDirectory() + &quot;/maps/&quot;; // TDO veraltet
+		try {
+			wfl.loadwfl(mapsPath, thisMap);
+		}catch(FileNotFoundException ex){
+			//	Vm.debug(&quot;Cannot load world file!&quot;);
+		}catch (IOException ex) { // is thrown if lat/lon out of range
+			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), ex.getMessage(), MessageBox.OKB);
+			tmpMB.execute();
+			Vm.debug(&quot;Cannot load world file!&quot;);
+		}
+		mapInteractivePanel pane = new mapInteractivePanel(this);
+		scp = new ScrollBarPanel(pane);
+		Image img = new Image(Common.getImageName(mapsPath + thisMap));
+		PixelBuffer pB = new PixelBuffer(img);
+		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
+		mapImg = new AniImage(pB.toDrawableImage());
+		pane.addImage(mapImg);
+		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
+		imageWidth = mapImg.getWidth();
+		imageHeight = mapImg.getHeight();
+		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+		infPanel = new CellPanel();
+		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
+		infButton = new mButton(MyLocale.getMsg(4107,&quot;Done!&quot;));
+		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//scp.repaintNow();
+		//this.repaintNow();
+	}
+
+	/**
+	 *	Add a ground control point to the list
+	 *	If the list is longer than 3 GCPs these will be evaluated
+	 *	to obtain the required parameters for the affine
+	 *	transformation.
+	 */
+	public void addGCP(GCPoint GCP){
+		if (GCP.latDec&gt;90 || GCP.latDec&lt;-90 || GCP.lonDec&gt;360 || GCP.lonDec&lt;-180) throw new IllegalArgumentException(&quot;lat/lon out of range: &quot;+GCP.toString());
+		GCPs.add(GCP);
+		if(GCPs.size() &gt;= 3){
+			evalGCP();
+		}
+	}
+
+	/**
+	 *	Returns the number of ground control points in the list. (Vector GCPs)
+	 */
+	public int getGCPCount(){
+		return GCPs.size();
+	}
+
+	/**
+	 *	Actuall method to evaluate the ground control points and identify the parameters
+	 *	for thew affine transformation
+	 */
+	private void evalGCP(){
+		//N 48 16.000 E 11 32.000
+		//N 48 16.000 E 11 50.000
+		//N 48 9.000 E 11 32.000
+		GCPoint gcp = new GCPoint();
+		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
+		Matrix X = new Matrix(GCPs.size(),3);
+		Matrix trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i &lt; GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.latDec;
+		}
+		Matrix Xtran = new Matrix(X);
+		Xtran.Transpose();
+		Matrix XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		Matrix XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		Matrix beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		wfl.affine[0] = beta.matrix[1][0];
+		wfl.affine[2] = beta.matrix[2][0];
+		wfl.affine[4] = beta.matrix[0][0];
+
+		//Calculate parameters for longitude affine transformation (affine 1,3,5)
+		X = new Matrix(GCPs.size(),3);
+		trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i &lt; GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.lonDec;
+		}
+		Xtran = new Matrix(X);
+		Xtran.Transpose();
+		XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		wfl.affine[1] = beta.matrix[1][0];
+		wfl.affine[3] = beta.matrix[2][0];
+		wfl.affine[5] = beta.matrix[0][0];
+		double x_ = 0;
+		double y_ = 0;
+		x_ = wfl.affine[0]*imageWidth+ wfl.affine[2]*imageHeight + wfl.affine[4];
+		y_ = wfl.affine[1]*imageWidth + wfl.affine[3]*imageHeight + wfl.affine[5];
+		CWPoint p = new CWPoint(x_ , y_);
+		wfl.lowlon = p.lonDec;
+		wfl.lowlat = p.latDec;
+		//Vm.debug(&quot;A B C&quot; + affine[0] + &quot; &quot; + affine[2] + &quot; &quot; + affine[4]);
+		//Vm.debug(&quot;D E F&quot; + affine[1] + &quot; &quot; + affine[3] + &quot; &quot; + affine[5]);
+	}
+
+	/**
+	 *	Method to copy (&quot;import&quot;) a png based map
+	 *	into the maps folder in the CacheWolf base directory.
+	 *	
+	 *	If the maps directory does not exist it will create it.
+	 *	If it finds .map files it will assume these are oziexplorer calibration files.
+	 *	It will use these files to automatically georeference the files during import.
+	 */
+	public int importMap(){
+		String rawFileName = new String();
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
+		fc.addMask(&quot;*.png,*.gif,*.bmp,*.jpg&quot;);
+		fc.setTitle((String)MyLocale.getMsg(4100,&quot;Select Directory:&quot;));
+		int tmp = fc.execute() ; 
+		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
+		File inDir = fc.getChosenFile();
+		File mapFile;
+		InfoBox inf = new InfoBox(&quot;Info&quot;, MyLocale.getMsg(4109,&quot;Loading maps...            \n&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false); 
+		inf.setPreferredSize(220, 300);
+		inf.setInfoHeight(100);
+		inf.relayout(false);
+		Vm.showWait(this, true);
+		inf.exec();
+
+		//User selected a map, but maybe there are more png(s)
+		//copy all of them!
+		//at the same time try to find associated .map files!
+		//These are georeference files targeted for OziExplorer.
+		//So lets check if we have more than 1 png file:
+		String line = new String();
+		InputStream in = null;
+		OutputStream out = null;
+		FileReader inMap;
+		byte[] buf;
+		int len;
+		String[] parts;
+		String [] files = inDir.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, File.LIST_FILES_ONLY);
+
+		String currfile = null;
+		String curInFullPath;
+		String curOutFullPath;
+		int num = files.length;
+		for(int i =  num -1 ; i &gt;= 0;i--){
+			currfile = (String) files[i];
+			inf.setInfo(MyLocale.getMsg(4110,&quot;Loading: &quot;)+ &quot;\n&quot; + currfile + &quot;\n(&quot;+(num-i)+&quot;/&quot;+num+&quot;)&quot;);
+			//Copy the file
+			//Vm.debug(&quot;Copy: &quot; + inDir.getFullPath() + &quot;/&quot; +files[i]);
+			//Vm.debug(&quot;to: &quot; + mapsPath + files[i]);
+			curInFullPath = inDir.getFullPath() + &quot;/&quot; +currfile;
+			curOutFullPath = mapsPath + currfile;
+			boolean imageerror = false;
+			try {
+				in = new FileInputStream(curInFullPath);
+				buf = new byte[1024*10];
+				boolean first = true;
+				ByteArray header = new ByteArray(buf);
+				while ((len = in.read(buf)) &gt; 0) {
+					if (first) {
+						first = false;
+						header.copyFrom(buf, 0, len);
+						ImageInfo tmpII = Image.getImageInfo(header,null);
+						imageWidth = tmpII.width;
+						imageHeight = tmpII.height;
+						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
+					}
+					out.write(buf, 0, len);
+				}
+			} catch(IOException ex){
+				imageerror = true;
+				inf.addWarning(&quot;\nIO-Error while copying image from: &quot; + curInFullPath + &quot; to: &quot; + curOutFullPath + &quot; error: &quot; + ex.getMessage());
+			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
+				imageerror = true;
+				inf.addWarning(&quot;\nError: could not decode image: &quot; + curInFullPath + &quot; - image not copied&quot;);
+			} finally {
+				try {
+					if (in != null) in.close();
+					if (out  != null) out.close(); 
+				} catch (Throwable e) {}
+			}
+			//Check for a .map file
+			rawFileName = currfile.substring(0, currfile.lastIndexOf(&quot;.&quot;));
+			mapFile = new File(inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;);
+			if(!imageerror &amp;&amp; mapFile.exists()){
+				GCPoint gcp1 = new GCPoint();
+				GCPoint gcp2 = new GCPoint();
+				GCPoint gcp3 = new GCPoint();
+				GCPoint gcp4 = new GCPoint();
+				GCPoint gcpG = new GCPoint();
+				//Vm.debug(&quot;Found file: &quot; + inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;);
+				try {
+					inMap = new FileReader(inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;);
+					while((line = inMap.readLine()) != null){
+						if(line.equals(&quot;MMPNUM,4&quot;)){
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp1.bitMapX = Convert.toInt(parts[2]);
+							gcp1.bitMapY = Convert.toInt(parts[3]);
+							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
+							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp2.bitMapX = Convert.toInt(parts[2]);
+							gcp2.bitMapY = Convert.toInt(parts[3]);
+							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
+							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp3.bitMapX = Convert.toInt(parts[2]);
+							gcp3.bitMapY = Convert.toInt(parts[3]);
+							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
+							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
+							//imageWidth = gcp3.bitMapX;
+							//imageHeight = gcp3.bitMapY;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp4.bitMapX = Convert.toInt(parts[2]);
+							gcp4.bitMapY = Convert.toInt(parts[3]);
+							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
+							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp1.bitMapX;
+							gcpG.bitMapY = gcp1.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp2.bitMapX;
+							gcpG.bitMapY = gcp2.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp3.bitMapX;
+							gcpG.bitMapY = gcp3.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp4.bitMapX;
+							gcpG.bitMapY = gcp4.bitMapY;
+							addGCP(gcpG);
+							/* already read from image file itself
+							// get dimensions of image
+							while ( (line = inMap.readLine()) != null){
+								if (line.startsWith(&quot;IWH&quot;)){
+									parts = mString.split(line, ',');
+									imageWidth = Convert.toInt(parts[2]);
+									imageHeight = Convert.toInt(parts[3]);
+								}
+							}
+							 */
+							evalGCP();
+							//Vm.debug(&quot;Saving .map file to: &quot; + mapsPath + &quot;/&quot; + rawFileName + &quot;.wfl&quot;);
+							wfl.saveWFL(mapsPath, rawFileName);
+							GCPs.clear();
+						} // if
+
+					} // while
+					if (inMap != null)	inMap.close();
+				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+					inf.addWarning(&quot;\nError while importing .map-file: &quot;+ex.getMessage());
+				} catch(IOException ex){
+					inf.addWarning(&quot;\nIO-Error while reading or writing calibration file\n&quot; + ex.getMessage());
+				} 
+			} else { // if map file.exists
+				if (!imageerror) inf.addWarning(&quot;\nNo calibration file found for: &quot; + currfile + &quot; - you can calibrate it manually&quot;);
+			}
+		} // for file
+		Vm.showWait(this, false);
+		inf.addText(&quot;\ndone.&quot;);
+		inf.addOkButton();
+		//inf.addOkButton(); doesn't work
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		return Form.IDOK;
+	}
+
+
+
+	/**
+	 *	Handles button pressed event
+	 *	When the button is pressed a mapname.wfl file is saved in the
+	 *	maps directory.
+	 */
+	public void onEvent(Event ev){
+
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			// display coords in another format
+			if (ev.target == infButton){
+				boolean retry = true;
+				while (retry == true) {
+					try {
+						retry = false;
+						wfl.saveWFL(mapsPath, thisMap);
+						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+					} catch (IOException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(321, &quot;Error writing file &quot;) + e.getMessage()+MyLocale.getMsg(324, &quot; - retry?&quot;), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
+					}catch (IllegalArgumentException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(325, &quot;Map not calibrated&quot;)+MyLocale.getMsg(324, &quot; - retry?&quot;), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
+					}
+				}
+				if (!retry) close(0);
+			}
+		}
+	}
+}
+
+/**
+ *	Class that creates a panel and loads a map.
+ *	It catches click events to display a form where the user may enter the required ccordinates
+ *	The data is stored as a ground control point in the calling class: Map
+ */
+class mapInteractivePanel extends InteractivePanel{
+	Map f;
+	Locale l = Vm.getLocale();
+	LocalResource lr = l.getLocalResource(&quot;cachewolf.Languages&quot;,true);
+	public mapInteractivePanel(Map f){
+		this.f = f;
+	}
+
+	/**
+	 *	Event handler to catch clicks on the map
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		//Vm.debug(&quot;X = &quot; +pos.x + &quot; Y = &quot; + pos.y);
+		Image img = new Image(31, 31);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(0,0,0));
+		g.fillRect(0,0,31,31);
+		g.setColor(new Color(255,0,0));
+		g.drawLine(0,16,31,16);
+		g.drawLine(16,0,16,31);
+		AniImage aImg = new AniImage(img);
+		aImg.setLocation(pos.x-16,pos.y-16);
+		aImg.transparentColor = new Color(0,0,0);
+		//aImg.properties = mImage.IsNotHot;
+		aImg.properties = mImage.AlwaysOnTop;
+		this.addImage(aImg);
+		g.free();
+		this.repaintNow();
+		f.updatePosition(pos.x, pos.y);
+
+		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,&quot;Coordinates:&quot;), (String)lr.get(4108,&quot;Coordinates:&quot;), InfoBox.INPUT);
+		if (cooS.execute()==CoordsScreen.IDOK) {
+			GCPoint gcp = new GCPoint(cooS.getCoords());
+			gcp.bitMapX = pos.x;
+			gcp.bitMapY = pos.y;
+			f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
+//			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
+//			coosInputFormat();
+//			this.removeImage(aImg);
+		} else this.removeImage(aImg); // CANCEL pressed
+	}
+
+	private void coosInputFormat () {
+		MessageBox tmpMB = new MessageBox((String)lr.get(312,&quot;Error&quot;), (String)lr.get(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), MessageBox.OKB);
+		tmpMB.exec();
+
+	}
+}
+/**
+ *	Class based on CWPoint but intended to handle bitmap x and y
+ *	Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint{
+	public int bitMapX = 0;
+	public int bitMapY = 0;
+
+	public GCPoint(){
+	}
+
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
+
+	public GCPoint(double lat, double lon){
+		this.latDec = lat;
+		this.lonDec = lon;
+		this.utmValid = false;
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/MapDetailForm.java
===================================================================
--- trunk/src/CacheWolf/navi/MapDetailForm.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapDetailForm.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,65 @@
+package CacheWolf.navi;
+import CacheWolf.ImageDetailForm;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import ewe.graphics.*;
+import ewe.sys.*;
+import ewe.fx.*;
+import ewe.ui.*;
+import ewe.util.*;
+
+/**
+ *	Class to display map images in different zoom levels.
+ *	Extends ImageDetailForm that handles the resizing to screen
+ *	size. The extension in this class handles the switching between
+ *	different (map) images.
+ */
+public class MapDetailForm extends ImageDetailForm {
+ /* // it's obsolete since we have a well working moving map 
+	mButton btSwitch;
+	String cache;
+	String imgLoc = new String();
+	int status = 0;
+	Profile profile;
+	
+	public MapDetailForm(String cacheName, Preferences p, Profile prof){
+		profile=prof;  // keep ref for later use
+		cache=cacheName;
+		imgLoc = prof.dataDir + cacheName + &quot;_map.gif&quot;;
+		scp = new ScrollBarPanel(ipp);
+		setUp(imgLoc, p);
+		this.title = &quot;Maps&quot;;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		this.addLast(scp.getScrollablePanel(), this.STRETCH, this.FILL);
+		CellPanel butPanel = new CellPanel();
+		btSwitch = new mButton(&quot;Zoom&quot;);
+		butPanel.addLast(btSwitch);
+		this.addLast(butPanel, this.HSTRETCH, this.FILL);
+	}
+
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btSwitch){
+				ipp.removeImage(ai);
+				imgLoc = profile.dataDir + cache;
+				if(status == 0) {
+					imgLoc = imgLoc + &quot;_map_2.gif&quot;;
+					status = 1;
+				} else {
+					imgLoc = imgLoc + &quot;_map.gif&quot;;
+					status = 0;
+				}
+				try {
+					setUp(imgLoc, pref);
+					this.repaintNow();
+				} catch (IllegalArgumentException e) {
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht finden&quot;)+&quot;: &quot;+imgLoc, MessageBox.OKB); // @todo: language support
+					tmp.exec();
+				}
+			}
+		}
+	}
+	*/
+}
+

Added: trunk/src/CacheWolf/navi/MapImage.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImage.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapImage.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,78 @@
+package CacheWolf.navi;
+import ewe.fx.*;
+import ewe.graphics.*;
+/** 
+ * class that can be used with any x and any y
+ * it will save taht location and make itself automatically
+ * invisible if it is not on the screen. Call setscreensize to
+ * set the screensize
+ * @author pfeffer
+ *
+ */
+public class MapImage extends AniImage {
+	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
+	public static Dimension screenDim;
+	boolean hidden = false;
+	public MapImage() {
+		super();
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public MapImage(String f) {
+		super(f);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public MapImage(mImage im) {
+		super(im);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public static void setScreenSize(int w, int h) {
+		screenDim = new Dimension(w, h);
+	}
+
+	public void setImage(Image im, Color c) {
+		super.setImage(im, c);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public void setLocation (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden &amp;&amp; isOnScreen()) { 
+			super.setLocation(x, y);
+			properties &amp;= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public void move (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden &amp;&amp; isOnScreen()) { 
+			super.move(x, y);
+			properties &amp;= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public boolean isOnScreen() { 
+		if ( (locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp; 
+				(locAlways.y + location.height &gt; 0 &amp;&amp; locAlways.y &lt; screenDim.height) ) return true;
+		else return false;
+	}
+
+	public void hide() {
+		hidden = true;
+		properties |= AniImage.IsInvisible;
+	}
+	public void unhide() {
+		hidden = false;
+		move(locAlways.x, locAlways.y);
+	}
+}

Added: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,334 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.MyLocale;
+import ewe.fx.Point;
+import ewe.io.BufferedWriter;
+import ewe.io.FileReader;
+import ewe.io.FileWriter;
+import ewe.io.FilenameFilter;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.sys.*;
+
+/**
+ * @author r
+ *
+ */
+public class MapInfoObject{
+	//World file:
+	// x scale
+	// y scale
+	// x rotation
+	// y rotation
+	// lon of upper left corner of image
+	// lat of upper left corner of image
+	// lon of lower right corner of image
+	// lat of lower right corner of image
+	public double[] affine = {0,0,0,0,0,0};
+	public double lowlat = 0;
+	public double lowlon = 0;
+	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	public CWPoint center = new CWPoint();
+	public float sizeKm = 0; // diagonale
+	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
+	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
+	public Point shift = new Point (0,0);
+	public CWPoint OrigUpperLeft; // this is only valid after zooming 
+	public float rotationRad; // contains the rotation of the map == north direction in rad
+	public String fileNameWFL = new String();
+	public String fileName = new String();
+	public String mapName = new String();
+	//private Character digSep = new Character(' ');
+	static private String digSep = MyLocale.getDigSeparator();
+	/*
+	 * loads an .wfl file
+	 * throws FileNotFoundException and IOException (data out of range)
+	 * @maps Path to .wfl file
+	 * @thisMap filename of .wfl file without &quot;.wfl&quot;
+	 * @DigSep &quot;.&quot; or &quot;,&quot;
+	 */	
+
+	public MapInfoObject() {
+		//double testA = Convert.toDouble(&quot;1,50&quot;) + Convert.toDouble(&quot;3,00&quot;);
+		//if(testA == 4.5) digSep = &quot;,&quot;; else digSep = &quot;.&quot;;
+	}
+	
+	public MapInfoObject(MapInfoObject map) {
+		mapName = map.mapName;
+		affine[0] = map.affine[0];
+		affine[1] = map.affine[1];
+		affine[2] = map.affine[2];
+		affine[3] = map.affine[3];
+		affine[4] = map.affine[4];
+		affine[5] = map.affine[5];
+		lowlat = map.lowlat;
+		lowlon = map.lowlon;
+		OrigUpperLeft = new CWPoint (map.OrigUpperLeft);
+		zoomFactor = map.zoomFactor;
+		shift.set(map.shift);
+		fileName = new String(map.fileName);
+		fileNameWFL = new String(map.fileNameWFL);
+		mapName = new String(mapName);
+		doCalculations();
+	}
+
+	/*
+	 * constructes an MapInfoObject without an associated map
+	 * but with 1 Pixel = scale meters
+	 */
+	public MapInfoObject(double scalei, double lat) {
+		mapName=&quot;empty 1 Pixel = &quot;+scalei+&quot;meters&quot;;
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deg / java.lang.Math.cos(lat); //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=1; //top
+		affine[5]=0; //left
+		lowlat = 0; //buttom
+		lowlon = 1; //right
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+
+	/**
+	 * constructs an MapInfoObject with an associated map
+	 * with 1 Pixel = scale meters, center and width, hight in pixels
+	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 */
+	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
+		mapName = name+&quot;.wfl&quot;;
+
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deghorizontal; //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=center.latDec + hight / 2 *pixel2deg; //top
+		affine[5]=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		lowlat = center.latDec - hight / 2 *pixel2deg; //buttom
+		lowlon = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		fileNameWFL = name;
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+	
+
+	/** 
+	 * @return the filename of the associated map image, &quot;&quot; if no file is associated, null if associated file could not be found
+	 */
+	public String getImageFilename() {
+		if (fileName == null || fileName.length() &gt; 0) return fileName;
+		if (fileNameWFL.length() == 0) return &quot;&quot;;
+		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf(&quot;.&quot;));
+		return Common.getImageName(n);
+	}
+	
+	/**
+	 * Method to load a .wfl-file
+	 * @throws IOException when there was a problem reading .wfl-file
+	 * @throws IOException when lat/lon were out of range
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
+		FileReader in = new FileReader(mapsPath + thisMap + &quot;.wfl&quot;);
+		String line = new String();
+		try {
+			for(int i = 0; i&lt;6;i++){
+				line = in.readLine();
+				if (digSep.equals(&quot;,&quot;)) {line = line.replace('.',','); } // digSep == ',' musss genau so lauten. digsep.equals(',') wirft eine Exception auf PocketPC, digsep.equals(&quot;,&quot;) wirft keine Exception, funktioniert aber nicht! 
+				else line = line.replace(',','.');
+				affine[i] = Convert.toDouble(line);
+			}
+			line = in.readLine();
+			if (digSep.equals(&quot;,&quot;)) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			lowlat = Convert.toDouble(line);
+			line = in.readLine();
+			if (digSep.equals(&quot;,&quot;)) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			lowlon = Convert.toDouble(line);
+
+			fileNameWFL = mapsPath + thisMap + &quot;.wfl&quot;;
+			fileName = &quot;&quot;; //mapsPath + thisMap + &quot;.png&quot;;
+			mapName = thisMap;
+			in.close();
+			if(affine[4] &gt; 90 || affine[4] &lt; -90 || affine[5] &lt; -180 || affine[5] &gt; 360 ||
+					lowlat &gt; 90 || lowlat &lt; -90 || lowlon &gt; 360 || lowlon &lt; -180 ) {
+				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; affine[4] = 0; affine[5] = 0;
+				lowlat = 0; lowlon = 0;
+				throw (new IOException(&quot;Lat/Lon out of range while reading &quot;+mapsPath + thisMap + &quot;.wfl&quot;));
+			}
+		} catch (NullPointerException e) { // in.readline liefert null zur&#252;ck, wenn keine Daten mehr vorhanden sind
+			throw (new IOException(&quot;not enough lines in file &quot;+mapsPath + thisMap + &quot;.wfl&quot;));
+		}
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+
+	/**
+	 * calculates center, diagonal size of the map and inverse to affine transformation
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+
+	private void doCalculations() throws ArithmeticException {
+		try {
+			center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
+			sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
+
+			//calculate reverse affine
+			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
+			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
+			transLonX = -affine[2]/nenner;
+			transLatY = -affine[1]/nenner;
+			transLonY = affine[0]/nenner;
+
+			// calculate north direction
+			float scaleXpixels = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
+			//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
+			float rotationX2x=(float)transLonX*scaleXpixels;
+			float rotationX2y=(float)transLonY*scaleXpixels;
+			//rotationY2y=-(float)transLatY*scaleY; // lat -&gt; y = -, y -&gt; y = +
+			//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
+			rotationRad = (float)java.lang.Math.atan(rotationX2y);
+			if (rotationX2x &lt; 0) rotationRad = (float)java.lang.Math.PI - rotationRad;
+			// calculate scale in meters per pixel
+			double metersPerLat = 1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0));
+			scale = (float) java.lang.Math.abs((affine[2] * metersPerLat)); 
+		} catch (ArithmeticException ex) { throw new ArithmeticException(&quot;Not allowed values in affine\n (matrix cannot be inverted)\n in file \n&quot; + fileNameWFL); }
+	}
+
+
+	/**
+	 *	Method to save a world file (.wfl)
+	 * @param mapsPath without &quot;/&quot; at the end
+	 * @param mapFileName without file extension
+	 * @throws IOException when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException when affine[x] for all x == 0 (&quot;map not calibrated&quot;).
+	 */
+	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
+		if (affine[0]==0 &amp;&amp; affine[1]==0 &amp;&amp; affine[2]==0 &amp;&amp; affine[3]==0 &amp;&amp; 
+				affine[4]==0 &amp;&amp; affine[5]==0 ) throw (new IllegalArgumentException(&quot;map not calibrated&quot;));
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;)));
+		String towrite=Convert.toString(affine[0])+&quot;\n&quot; +
+		Convert.toString(affine[1])+&quot;\n&quot; +
+		Convert.toString(affine[2])+&quot;\n&quot; + 
+		Convert.toString(affine[3])+&quot;\n&quot; + 
+		Convert.toString(affine[4])+&quot;\n&quot; +
+		Convert.toString(affine[5])+&quot;\n&quot; +
+		Convert.toString(lowlat)+&quot;\n&quot; +
+		Convert.toString(lowlon)+&quot;\n&quot;;
+		if (digSep.equals(&quot;,&quot;)) towrite=towrite.replace(',', '.');
+		outp.print(towrite);
+		outp.close();
+		this.fileName = &quot;&quot;; // this will be set in getImageFilenam //mapsPath + &quot;/&quot; + mapFileName + &quot;.png&quot;;
+		this.fileNameWFL = mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;;
+		this.mapName = mapFileName;
+	}
+
+	public boolean inBound(CWPoint pos){
+		boolean isInBound = false;
+		/*
+		Vm.debug(mapName);
+		Vm.debug(&quot;Top: &quot; + affine[4]);
+		Vm.debug(&quot;Bottom: &quot; + lowlat);
+		Vm.debug(&quot;Test: &quot; + pos.latDec);
+		Vm.debug(&quot;Left: &quot; + affine[5]);
+		Vm.debug(&quot;Right: &quot; + lowlon);
+		Vm.debug(&quot;Test: &quot; + pos.lonDec);
+		 */
+		if(affine[4] &gt;= pos.latDec &amp;&amp; pos.latDec &gt;= lowlat &amp;&amp; affine[5] &lt;= pos.lonDec &amp;&amp; pos.lonDec &lt;= lowlon) isInBound = true;
+		return isInBound;
+	}
+
+	/**
+	 * zoom in / out
+	 * @param zf zf &gt; 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * @param diffY
+	 */
+	public void zoom(float zf, int diffX, int diffY) {
+		// restore original values to calculate corret shift (upperleft)
+		affine[4] = OrigUpperLeft.latDec;
+		affine[5] = OrigUpperLeft.lonDec;
+		affine[0] = affine[0] * zoomFactor; 
+		affine[1] = affine[1] * zoomFactor; 
+		affine[2] = affine[2] * zoomFactor;
+		affine[3] = affine[3] * zoomFactor;
+		CWPoint upperleft = calcLatLon(diffX, diffY);
+		affine[4] = upperleft.latDec;
+		affine[5] = upperleft.lonDec;
+		affine[0] = affine[0] / zf ; 
+		affine[1] = affine[1] / zf ; 
+		affine[2] = affine[2] / zf ; 
+		affine[3] = affine[3] / zf ; 
+		zoomFactor = zf ;
+		shift.x = diffX;
+		shift.y = diffY;
+		doCalculations(); // TODO lowlat neu berechnen?
+	}
+
+	public boolean inBound(CWGPSPoint pos){
+		boolean isInBound = false;
+		/*
+		Vm.debug(mapName);
+		Vm.debug(&quot;Top: &quot; + affine[4]);
+		Vm.debug(&quot;Bottom: &quot; + lowlat);
+		Vm.debug(&quot;Test: &quot; + pos.latDec);
+		Vm.debug(&quot;Left: &quot; + affine[5]);
+		Vm.debug(&quot;Right: &quot; + lowlon); // lowlon should be left?!
+		Vm.debug(&quot;Test: &quot; + pos.lonDec);
+		 */
+		if(affine[4] &gt;= pos.latDec &amp;&amp; pos.latDec &gt;= lowlat &amp;&amp; affine[5] &lt;= pos.lonDec &amp;&amp; pos.lonDec &lt;= lowlon) isInBound = true;
+		return isInBound;
+	}
+	public boolean inBound(double lati, double loni){
+		boolean isInBound = false;
+		if(affine[4] &gt;= lati &amp;&amp; lati &gt;= lowlat &amp;&amp; affine[5] &lt;= loni &amp;&amp; loni &lt;= lowlon) isInBound = true;
+		return isInBound;
+	}
+	/**
+	 * Method to calculate bitmap x,y of the current map using
+	 * lat and lon target coordinates. There ist no garanty that
+	 * the returned coordinates are inside of the map. They can be negative.
+	 * @param lat
+	 * @param lon
+	 */
+	public Point calcMapXY(double lat, double lon){
+		Point coords = new Point();
+		double b[] = new double[2];
+		b[0] = lat - affine[4];
+		b[1] = lon - affine[5];
+		double mapx=transLatX* b[0] + transLonX*b[1];
+		double mapy=transLatY* b[0] + transLonY*b[1];
+		coords.x = (int)mapx;
+		coords.y = (int)mapy;
+		//Vm.debug(&quot;mapX=mapx2: &quot;+mapx+&quot;=&quot;+mapx2+&quot;; mapy=mapy2: &quot;+mapy+&quot;=&quot;+mapy2);
+		return coords;
+	}
+
+	/**
+	 * gives back lat/lon from x, y in map
+	 * @param x
+	 * @param y
+	 * @return
+	 */
+	public CWPoint calcLatLon(int x, int y) {
+		CWPoint ll = new CWPoint();
+		ll.latDec = (double)x * affine[0] + (double)y * affine[2] + affine[4];
+		ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + affine[5];
+		return ll;
+	}
+	public CWPoint calcLatLon(Point p) {
+		return calcLatLon(p.x, p.y);
+	}
+	public Area getArea(){
+		return new Area(new CWPoint(affine[4], affine[5]), new CWPoint(lowlat, lowlon));
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,240 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.HttpConnection;
+import CacheWolf.InfoBox;
+import ewe.ui.*;
+import ewe.io.*;
+import ewe.fx.*;
+import ewe.util.*;
+import ewe.sys.*;
+import ewe.sys.Double;
+import ewe.net.*;
+
+/**
+*
+*/
+
+// Um Karten zu holen!
+// <A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|</A>
+// oder
+// <A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||</A>
+
+
+public class MapLoader {
+	String proxy = new String();
+	String port = new String();
+	InfoBox progressInfobox;
+	
+	final static float downloadMapScaleFactorExpedia_east = 3950;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL; 
+
+	int numMapsY;
+	int numMapsX;
+	double latinc;
+	double loninc;
+	CWPoint topleft;
+	CWPoint buttomright;
+	Point tilesSize;
+	int tileScale;
+
+	public MapLoader(String prxy, String prt){
+		port = prt;
+		proxy = prxy;
+		progressInfobox = null;
+	}
+	
+	/**
+	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl 
+	 * in path
+	 * @param center center of all tiles
+	 * @param radius in meters
+	 * @param scale in &quot;alti&quot; value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size in pixels
+	 * @param overlapping in pixels
+	 * @param path without &quot;/&quot; at the end
+	 * 
+	 */
+	public void setTiles (CWPoint center, float radius, int scale, Point size, int overlapping) {
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
+		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
+		
+		this.setTiles(topleft, buttomright, scale, size, overlapping);
+	}
+	
+	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, int overlapping) {
+		//if (toplefti.latDec &lt;= buttomrighti.latDec || toplefti.lonDec &gt;= toplefti.lonDec) throw new IllegalArgumentException(&quot;topleft must be left and above buttom right&quot;);
+		topleft = new CWPoint(toplefti);
+		buttomright = new CWPoint(buttomrighti);
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
+		
+		double pixelsPerLat = metersPerLat / (EXPEDIA_METERS_PER_PIXEL * scale);
+		double pixelsPerLon = metersPerLon / (EXPEDIA_METERS_PER_PIXEL * scale);
+
+		//over all pixelsize without borders
+		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat; 
+		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
+		
+		//border sizes around given area and overlapping between tiles
+		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		int borderX = overlapping;
+		int borderY = overlapping;
+		
+		numMapsY = (int) java.lang.Math.ceil( (pixelsY + (float)borderY) / (float)(size.y - borderY) );
+		numMapsX = (int) java.lang.Math.ceil( (pixelsX + (float)borderX) / (float)(size.x - borderX) );
+		
+		//increments calulated from pixel offset of tiles
+		latinc = (float)-(size.y - borderY) / pixelsPerLat;
+		loninc = (float)(size.x - borderX) / pixelsPerLon;
+		
+		//calculation of center of first tile
+		
+		//additional size for borders and rounding
+		double oversizeX = (float)(numMapsX * (size.x - borderX) + borderX) - pixelsX;
+		double oversizeY = (float)(numMapsY * (size.y - borderY) + borderY) - pixelsY;
+		
+		//offset for upper left corner
+		double offsetLat = -( ((float)size.y - oversizeY) / 2.0 ) / pixelsPerLat;
+		double offsetLon = ( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		
+		topleft.latDec += offsetLat;
+		topleft.lonDec += offsetLon;
+		
+		this.tilesSize = new Point();
+		this.tilesSize.set(size);
+		this.tileScale = scale;
+	}
+
+	public void downlaodTiles(String tilesPath) {
+		double lat = topleft.latDec;
+		double lon = topleft.lonDec;
+		for (int row = 1; row &lt;= numMapsY; row++) {
+			lon = topleft.lonDec;
+			for (int col = 1; col &lt;= numMapsX; col++) {
+				if (progressInfobox != null)
+					progressInfobox.setInfo(&quot;Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile row: &quot;+row+&quot; / &quot;+numMapsY+&quot; coloumn &quot;+ col + &quot;/&quot;+numMapsX);
+				downloadMap(lat, lon, tileScale, tilesSize.x, tilesSize.y, tilesPath);
+				lon += loninc;
+			}
+			lat += latinc;
+		}
+	}
+	
+	/*
+	public void loadTo(String a, String b) {
+		//loadTo(a, b, &quot;50.74&quot;, &quot;7.095&quot;);
+	}
+	*/
+
+	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+		progressInfobox = progrssInfoboxi;
+	}
+	/**
+	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * @param center
+	 * @param distance in meters
+	 */
+	public static int getExpediaAlti(CWPoint center, float distance, Point size) {
+		int scaleLatO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.y));
+		int scaleLonO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.x));
+		int scaleO = (scaleLatO &lt; scaleLonO ? scaleLonO : scaleLatO);
+		//loadTo((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2, scaleO, size.x, size.y, path+&quot;/expedia_alti&quot;+scaleO+&quot;_lat&quot;+latD.toString()+&quot;_lon&quot;+lonD.toString());
+		return scaleO;
+	}
+	
+	public static String createExpediaFilename(double lat, double lon, int alti) {
+		Double latD = new Double(), lonD = new Double();
+		latD.decimalPlaces = 4;
+		lonD.decimalPlaces = 4;
+		latD.set(lat);
+		lonD.set(lon);
+		return &quot;expedia_alti&quot;+alti+&quot;_lat&quot;+latD.toString().replace(',', '.')+&quot;_lon&quot;+lonD.toString().replace(',', '.')+&quot;.gif&quot;;
+	}
+	
+	public void downloadMap(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String path){
+		loadTo(lat, lon, alti, PixelWidth, PixelHeight, path+&quot;/&quot;+createExpediaFilename(lat, lon, alti));
+	}
+
+	public void loadTo(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String datei){
+		HttpConnection connImg, conn2;
+		Socket sockImg, sock2;
+		InputStream is;
+		FileOutputStream fos;
+		ByteArray daten;
+		String quelle = new String();
+		String zone;
+		if (lon &lt;= -10) zone = &quot;USA0409&quot;;
+		else zone = &quot;EUR0809&quot;;
+
+		/*
+		 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode 
+		 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&amp;ID=3XNsF.&amp;CenP={0,number,#.########},{1,number,#.########}&amp;Lang=EUR0809&amp;Alti={2,number,#}&amp;Size={3,number,#},{4,number,#}&amp;Offs=0.000000,0.000000\&amp;BCheck=1
+		 * download.map.url.expedia_east.title=Url of Expedia Europe
+		 * download.map.scale_factor.expedia_east=3950
+		 */
+		Double latD = new Double();
+		latD.decimalPlaces = 8;
+		latD.set(lat);
+		Double lonD = new Double();
+		lonD.decimalPlaces = 8;
+		lonD.set(lon);
+		quelle = &quot;<A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt">http://www.expedia.de/pub/agent.dll?qscr=mrdt</A>&quot;;
+		quelle = quelle + &quot;&amp;ID=3kQaz.&quot;;
+		quelle = quelle + &quot;&amp;CenP=&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.');
+		quelle = quelle + &quot;&amp;Alti=&quot;+Convert.toString(alti)+&quot;&amp;Lang=&quot;+zone+&quot;&amp;Size=&quot;+Convert.toString(PixelWidth)+&quot;,&quot;+Convert.toString(PixelHeight)+&quot;&amp;Offs=0,0&amp;MapS=0&quot;; //&amp;Pins=|&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.') + &quot;|5|&quot;;
+		//Vm.debug(lat + &quot;,&quot; + lon);
+		if(proxy.length()&gt;0){
+			connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
+			//Vm.debug(&quot;Loading quelle: &quot; + quelle);
+		}else{
+			connImg = new HttpConnection(quelle);
+		}
+		//datei = &quot;d:\\temp\\test_map.bmp&quot;;
+		connImg.setRequestorProperty(&quot;USER_AGENT&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+		connImg.setRequestorProperty(&quot;Cookie&quot;, &quot;jscript=1; path=/;&quot;);
+		connImg.documentIsEncoded = true;
+		try{
+			File dateiF = new File(datei);
+			if(!dateiF.exists()){
+				sockImg = connImg.connect();
+				//Vm.debug(&quot;Redirect: &quot; + connImg.getRedirectTo());
+				quelle = connImg.getRedirectTo();
+				sockImg.close();
+				if(proxy.length()&gt;0){
+					connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
+				}else{
+					connImg = new HttpConnection(quelle);
+				}
+				connImg.setRequestorProperty(&quot;USER_AGENT&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+				connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+				connImg.setRequestorProperty(&quot;Cookie&quot;, &quot;jscript=1; path=/;&quot;);
+				connImg.documentIsEncoded = true;
+				sock2 = connImg.connect();
+				daten = connImg.readData(sock2);
+				fos = new FileOutputStream(dateiF);
+				fos.write(daten.toBytes());
+				fos.close();
+				sock2.close();
+			}
+			//Vm.debug(&quot;done&quot;);
+		}catch(IOException e){
+			(new MessageBox(&quot;Error&quot;, &quot;Error while downloading or saving map:\n&quot;+e.getMessage(), MessageBox.OKB)).exec();
+		}
+		File dateiF = new File(datei); // change!!!
+		String tmp = dateiF.getName(); // contains the name and the extension
+		String name = tmp.substring(0, tmp.lastIndexOf(&quot;.&quot;));
+		float metersPerPixel = (float) (alti)*EXPEDIA_METERS_PER_PIXEL;
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, new CWPoint(lat,lon),  PixelWidth, PixelHeight, dateiF.getPath()+&quot;/&quot;+name);
+		try {
+		cal.saveWFL(dateiF.getDrivePath(), name);
+		} catch (IOException e) {
+			(new MessageBox(&quot;Error&quot;, &quot;Error saving calibration file:\n&quot;+e.getMessage(), MessageBox.OKB)).exec();
+		}
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,258 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CoordsScreen;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import ewe.io.File;
+import ewe.sys.Convert;
+import ewe.sys.Vm;
+import ewe.ui.*;
+import ewe.util.Vector;
+
+/**
+ * @author pfeffer
+ * This Class is the Dialog for Download calibrated from expedia.com
+ * is called from 
+ */
+
+public class MapLoaderGui extends Form {
+	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
+	Preferences pref;
+	mTabbedPanel mTab = new mTabbedPanel();
+	CellPanel pnlTiles = new CellPanel();
+	CellPanel pnlPerCache = new CellPanel();
+
+	final String descString = &quot;Download georeferenced maps from expedia.com&quot;;
+	mCheckBox forCachesChkBox = new mCheckBox(&quot;for&quot;);
+	mChoice forSelectedChkBox = new mChoice(new String[] {&quot;all&quot;, &quot;selected&quot;}, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {&quot;all&quot;, &quot;selected&quot;}, 1);
+	mLabel cachesLbl = new mLabel(&quot;caches&quot;);
+	mInput distanceInput;
+	mLabel distLbl;
+	mLabel km = new mLabel(&quot;km&quot;);
+	mLabel coosLbl;
+	mButton coosBtn;
+	mLabel scaleLbl = new mLabel(&quot;Approx. m per pixel:&quot;);
+	mInput scaleInput = new mInput (&quot;3&quot;);
+	mInput scaleInputPerCache = new mInput (&quot;1&quot;);
+	mLabel overlappingLbl = new mLabel(&quot;overlapping in pixel:&quot;);
+	mInput overlappingInput = new mInput(&quot;100&quot;);
+	mCheckBox overviewChkBox = new mCheckBox(&quot;download an overview map&quot;);
+	mCheckBox overviewChkBoxPerCache = new mCheckBox(&quot;download an overview map&quot;);
+
+	CWPoint center;
+	Vector cacheDB;
+	boolean perCache;
+	boolean onlySelected;
+	float radius;
+	float scale;
+	int overlapping;
+	boolean overviewmap;
+	int numCaches;
+
+	public MapLoaderGui(Vector cacheDBi) {
+		super();
+		this.title = MyLocale.getMsg(1800, &quot;Download georeferenced maps&quot;); 
+		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
+		center = new CWPoint(pref.curCentrePt);
+		cacheDB = cacheDBi;
+		// tiles panel
+		MessageArea desc = new MessageArea(descString);
+		desc.modifyAll(mTextPad.NotEditable | mTextPad.DisplayOnly | mTextPad.NoFocus, mTextPad.TakesKeyFocus);
+		desc.borderStyle = mTextPad.BDR_NOBORDER;
+		pnlTiles.addLast(desc);
+		pnlTiles.addNext(forCachesChkBox);
+		pnlTiles.addNext(forSelectedChkBox);
+		pnlTiles.addLast(cachesLbl);
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1802,&quot;Within a rectangle of:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		distanceInput = new mInput();
+		int tmp = Convert.toInt((Global.getProfile().distOC));
+		distanceInput.setText(Convert.toString((tmp &gt; 0 ? tmp : 15)));
+		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(km);
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1803, &quot;around the center: &quot;)));
+		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
+		pnlTiles.addNext(scaleLbl);
+		scaleInput.setText(&quot;5&quot;);
+		this.focusFirst();
+		pnlTiles.addLast(scaleInput);
+		//	pnlTiles.addLast(resolutionLbl);
+		pnlTiles.addNext(overlappingLbl);
+		pnlTiles.addLast(overlappingInput);
+		overviewChkBox.setState(true);
+		pnlTiles.addLast(overviewChkBox);
+		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBtiles.setHotKey(0, IKeys.ACTION);
+		okBtiles.setHotKey(0, IKeys.ENTER);
+		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		updateForCachesState();
+		mTab.addCard(pnlTiles, MyLocale.getMsg(1804, &quot;Tiles&quot;), MyLocale.getMsg(1804, &quot;Tiles&quot;));
+
+		// per cache panel
+		pnlPerCache.addLast(new MessageArea(descString));
+		pnlPerCache.addNext(new mLabel(&quot;Download one map for&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(new mLabel(&quot;caches&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(new mLabel(&quot;Approx. m per pixel&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
+		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		okBPerCache = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBPerCache.setHotKey(0, IKeys.ACTION);
+		okBPerCache.setHotKey(0, IKeys.ENTER);
+		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		mTab.addCard(pnlPerCache, MyLocale.getMsg(1805, &quot;Per cache&quot;), MyLocale.getMsg(1805, &quot;Per Cache&quot;));
+		this.addLast(mTab);
+	}
+	public String getMapsDir() {
+		return Global.getPref().getMapExpediaSavePath();
+	}
+	public void downloadTiles() {
+		String mapsDir = getMapsDir();
+		if (mapsDir == null) return;
+		InfoBox progressBox = new InfoBox(&quot;Downloading georeferenced maps&quot;, &quot;Downloading georeferenced maps\n from www.expedia.com&quot;);
+		progressBox.setPreferredSize(230, 150);
+		progressBox.exec();
+		Vm.showWait(true);
+		ewe.fx.Point size = new ewe.fx.Point(1000,1000); // Size of the downloaded maps
+		MapLoader ml = new MapLoader(Global.getPref().myproxy, Global.getPref().myproxyport);
+		if (forCachesChkBox.getState() || perCache) {
+			Area surArea = Global.getProfile().getSourroundingArea(onlySelected); // calculate map boundaries from cacheDB
+			if (surArea == null) {
+				(new MessageBox(&quot;Error&quot;, &quot;No Caches are seleted&quot;, MessageBox.OKB)).execute();
+				Vm.showWait(false);
+				progressBox.close(0);
+				return;
+			}
+			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, overlapping );
+			// calculate radius and center for overview map
+			center = new CWPoint((surArea.topleft.latDec + surArea.buttomright.latDec)/2, (surArea.topleft.lonDec + surArea.buttomright.lonDec)/2);
+			double radiuslat = (new CWPoint(center.latDec, surArea.buttomright.lonDec)).getDistance(surArea.buttomright);
+			double radiuslon = (new CWPoint(surArea.buttomright.latDec, center.lonDec)).getDistance(surArea.buttomright);
+			radius = (float) (radiuslat &lt; radiuslon ? radiuslon : radiuslat);
+		} else 
+		{ // calculate from center point an radius
+			ml.setTiles(center, radius * 1000, (int)scale, size, overlapping);
+		}
+		if (overviewmap) {
+			progressBox.setInfo(&quot;downloading overview map&quot;); 
+			int expediaAlti = MapLoader.getExpediaAlti(center, radius * 1000, size);
+			ml.downloadMap(center.latDec, center.lonDec, expediaAlti, size.x, size.y, mapsDir);
+		}
+		if (!perCache){  // download tiles
+			ml.setProgressInfoBox(progressBox);
+			ml.downlaodTiles(mapsDir);
+		} else { // per cache
+			CacheHolder ch; 
+			CWPoint tmpca = new CWPoint();
+			int numdownloaded = 0;
+			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
+			int numCaches = Global.getProfile().numCachesInArea;
+			for (int i=cacheDB.size()-1; i &gt;= 0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (!this.onlySelected || ch.is_Checked) {
+					if (ch.pos == null) { // this can not happen
+						tmpca.set(ch.LatLon);
+						ch.pos = new CWPoint(tmpca);
+					}
+					if (ch.pos.isValid() &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos &#252;berall korrekt ist
+						numdownloaded++;
+						progressBox.setInfo(&quot;Downloading map from expedia.de\n&quot;+numdownloaded+&quot; / &quot;+numCaches+&quot;\n for cache:\n&quot;+ch.CacheName);
+						ml.downloadMap(ch.pos.latDec, ch.pos.lonDec, (int)scale, size.x, size.y, mapsDir);
+					}
+				}
+			}
+		}
+		Vm.showWait(false);
+		ml.setProgressInfoBox(null);
+		progressBox.close(0);
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		(new MessageBox(&quot;Expedia maps&quot;, &quot;Downloaded and calibrated the maps successfully&quot;, MessageBox.OKB)).execute();
+	}
+
+
+	private void updateForCachesState() {
+		int a, b;
+		if (forCachesChkBox.getState()) {
+			// create map rectangle from caches
+			a = 0;
+			b = Control.Disabled;
+		}
+		else { // use center and distance input
+			a = Control.Disabled;
+			b = 0;
+		}
+		forSelectedChkBox.modify(a, b);
+		cachesLbl.modify(a, b);
+		distanceInput.modify(b, a);
+		distLbl.modify(b, a);
+		coosBtn.modify(b, a);
+		coosLbl.modify(b, a);
+		km.modify(b,a);
+		repaintNow();
+
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB || ev.target == cancelBPerCache){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okBtiles || ev.target == okBPerCache){
+				if (ev.target == okBtiles) { // get tiles
+					perCache = false;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(&quot;all&quot;)) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBox.getState();
+					radius = Convert.toFloat(distanceInput.getText());
+					scale = Convert.toFloat(scaleInput.getText());
+					overlapping = Convert.toInt(overlappingInput.getText());
+					if (!forCachesChkBox.getState()) {
+						if (radius &lt;= 0) { 
+							(new MessageBox(&quot;Error&quot;, &quot;'radius' must be graeter than null&quot;, MessageBox.OKB)).execute();
+							return;
+						}
+						if (overlapping &lt; 0) { 
+							(new MessageBox(&quot;Error&quot;, &quot;'overlapping' must be greater or equal 0 &quot;, MessageBox.OKB)).execute();
+							return;
+						}
+					}
+				} else { // per cache
+					perCache = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(&quot;all&quot;)) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBoxPerCache.getState();
+					scale = Convert.toFloat(scaleInputPerCache.getText());
+				}
+				if (scale &lt; 1 || scale != java.lang.Math.floor(scale)) {
+					(new MessageBox(&quot;Error&quot;, &quot;'Approx. meter pro pixel' must be greater than 0 and must not contain a point&quot;, MessageBox.OKB)).execute();
+					return;
+				}
+				this.close(Form.IDOK); 
+				this.downloadTiles();
+			}
+			if (ev.target == coosBtn) {
+				CoordsScreen cs = new CoordsScreen();
+				cs.setFields(center, CWPoint.CW);
+				if (cs.execute() != CoordsScreen.IDCANCEL) {
+					center = cs.getCoords();
+					coosBtn.setText(center.toString());
+				}
+			}
+			if (ev.target == forCachesChkBox) {
+				updateForCachesState();
+			}
+		} // if controllEvent...
+		super.onEvent(ev);
+	}
+}

Added: trunk/src/CacheWolf/navi/MapSymbol.java
===================================================================
--- trunk/src/CacheWolf/navi/MapSymbol.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapSymbol.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,28 @@
+package CacheWolf.navi;
+
+import ewe.fx.*;
+import ewe.graphics.*;
+
+public class MapSymbol extends AniImage { // TODO make this implement MapImage, so that it will be invisible automatically if not on screen. When doing so, test if setgoto-pos -&gt; open map from gotopanel shows the map symbols (directly after starting CW)
+	Object mapObject;
+	String name;
+	String filename;
+	double lat, lon;
+	public MapSymbol(String namei, String filenamei, double lati, double loni) {
+		name = namei;
+		filename = filenamei;
+		lat = lati;
+		lon = loni;
+	}
+	public MapSymbol(String namei, Object mapObjecti, Image fromIm, double lati, double loni) {
+		name = namei;
+		lat = lati;
+		lon = loni;
+		mapObject = mapObjecti;
+		setImage(fromIm);
+	}
+	public void loadImage(){
+		setImage(new Image(filename),0); freeSource();;
+		//properties = AniImage.AlwaysOnTop;
+	}
+}

Added: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapsList.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,326 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import utils.FileBugfix;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.sys.Double;
+import ewe.ui.MessageBox;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+import ewe.fx.*;
+/**
+ * class to handle a list of maps
+ * it loads the list, finds the best map for a given location,
+ * says if a map is available for a given lat lon at a given scale
+ * @author r
+ *
+ */
+public class MapsList extends Vector {
+	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
+	public Hashtable scales2Area;
+
+	/**
+	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
+	 * @param mapsPath
+	 */
+	public MapsList(String mapsPath) {
+		super(); // forget already loaded maps
+		//if (mmp.mapImage != null) 
+		String dateien[];
+		FileBugfix files = new FileBugfix(mapsPath);
+		String rawFileName = new String();
+		String[] dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
+		Vector dirs;
+		if (dirstmp != null) dirs = new Vector(dirstmp);
+		else dirs = new Vector();
+		dirs.add(&quot;.&quot;); // include the mapsPath itself
+		MapInfoObject tempMIO;
+		MessageBox f = null;
+		for (int j = dirs.size()-1; j &gt;= 0; j--) {
+			files = new FileBugfix(mapsPath+&quot;/&quot;+dirs.get(j));
+			//ewe.sys.Vm.debug(&quot;mapd-Dirs:&quot;+files);
+			dateien = files.list(&quot;*.wfl&quot;, File.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+			for(int i = 0; i &lt; dateien.length;i++){
+				// if (!dateien[i].endsWith(&quot;.wfl&quot;)) continue;
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf(&quot;.&quot;));
+				try {
+					tempMIO = new MapInfoObject();
+					if (dirs.get(j).equals(&quot;.&quot;)) // the notation dir/./filename doesn't work on all platforms anyhow
+						tempMIO.loadwfl(mapsPath+&quot;/&quot;, rawFileName);
+					else tempMIO.loadwfl(mapsPath+&quot;/&quot;+dirs.get(j)+&quot;/&quot;, rawFileName);
+					add(tempMIO);
+				}catch(IOException ex){ 
+					if (f == null) (f=new MessageBox(&quot;Warning&quot;, &quot;Ignoring error while \n reading calibration file \n&quot;+ex.toString(), MessageBox.OKB)).exec();
+				}catch(ArithmeticException ex){ // affine contain not allowed values 
+					if (f == null) (f=new MessageBox(&quot;Warning&quot;, &quot;Ignoring error while \n reading calibration file \n&quot;+ex.toString(), MessageBox.OKB)).exec();
+				} 
+			}
+		}
+	}
+
+	public void addEmptyMaps(double lat) {
+		MapInfoObject tempMIO;
+		tempMIO = new MapInfoObject(1.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(5.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(50.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(250.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(1000.0, lat);
+		add(tempMIO);
+	}
+
+	/**
+	 * find the best map for lat/lon in the list of maps
+	 * currently the best map is the one, whose center is nearest to lat/lon
+	 * and in Area with its scale nearest to scale.
+	 * it always returns a map (if the list is not empty) 
+	 * even if the map is not inbound
+	 * lat/lon
+	 * @param lat
+	 * @param lon
+	 * @param forceScale: when true, return null if no map with specified scale could be found
+	 * @return
+	 */
+	public MapInfoObject getBestMap(double lat, double lon, Rect screen, float scale, boolean forceScale) {
+		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i &gt;= 0 ;i--) { 
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (screenArea == null || !scaleEquals(lastscale, mi) ) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
+				if (!forceScale || (forceScale &amp;&amp; !scaleEquals(scale, mi))) { // different scale?
+					if (!forceScale &amp;&amp; (mi.inBound(lat, lon) &amp;&amp; (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.inBound(lat, lon)))) 
+						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-&gt; better
+					else {
+						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
+							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
+							lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
+							if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+							else {
+								if ( (latNearer || lonNearer )) { 
+									if (bestMap == null || mi.center.getDistanceRad(lat, lon) &lt; bestMap.center.getDistanceRad(lat, lon) ) better = true;
+								}
+							}
+						}
+					}
+					if (better) {
+						minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+						minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+						bestMap = mi;
+						// Vm.debug(&quot;better&quot;+ i);
+					}
+				}
+			}
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
+	}
+	/*
+	public MapInfoObject getBestMapNotStrictScale(double lat, double lon, Area screen, float scale) {
+		MapInfoObject ret = getBestMap(lat, lon, screen, scale, true);
+		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
+		return ret;
+	}
+	 */
+	/**
+	 * @return a map which includs topleft and bottomright, 
+	 * if no map includes both it returns null
+	 * @param if more than one map includes topleft and bottomright than the one will
+	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
+	 * as topleft and buttomright use gps as topleft.
+	 * if topleft is really topleft or if it is buttomright is not relevant.  
+	 */
+	
+	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
+		MapInfoObject mi;
+		MapInfoObject fittingmap = null;
+		boolean latNearer, lonNearer;
+		boolean better;
+		double minDistLat = 10000000000000000000000.0;
+		double minDistLon = 10000000000000000000000.0;
+		for (int i=size() -1; i&gt;=0 ;i--) {
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (mi.inBound(topleft) &amp;&amp; mi.inBound(bottomright)) { // both points are inside the map
+				if (fittingmap == null || fittingmap.scale &gt; mi.scale * scaleTolerance) {
+					better = true; // mi map has a better (lower) scale than the last knwon good map
+				} else {
+					if (fittingmap != null &amp;&amp; scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -&gt; test if its center is nearer to the gps-point = topleft
+						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
+						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
+						if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+						else {
+							if ( (latNearer || lonNearer )) { 
+								if (mi.center.getDistanceRad(topleft.latDec, topleft.lonDec) &lt; fittingmap.center.getDistanceRad(topleft.latDec, topleft.lonDec) ) better = true;
+							}
+						}
+
+					}
+				}
+				if (better) {
+					fittingmap = mi;
+					minDistLat = java.lang.Math.abs(topleft.latDec - mi.center.latDec);
+					minDistLon = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec);
+				}
+			}
+		} // for
+		if (fittingmap == null) return null;
+		return new MapInfoObject(fittingmap);
+	}
+
+	/**
+	 * 
+	 * @param lat a point to be inside the map
+	 * @param lon
+	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
+	 * @param curScale reference scale to be changed
+	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
+	 * @return
+	 */
+	public MapInfoObject getMapChangeResolution(double lat, double lon, Rect screen, float curScale, boolean moreDetails){
+		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i &gt;= 0 ;i--) { 
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (mi.fileNameWFL == &quot;&quot;) continue; // exclude &quot;maps&quot; without image // TODO make this a boolean in MapInfoObject
+			if (screenArea == null || !scaleEquals(lastscale, mi)) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi.getArea())) { // is on screen
+				if (bestMap == null || !scaleEquals(mi, bestMap)) { // different scale than known bestMap?
+					if (mi.inBound(lat, lon) &amp;&amp; (      // more details wanted and this map has more details?                                // less details than bestmap
+							(moreDetails &amp;&amp; (curScale &gt; mi.scale * scaleTolerance) &amp;&amp; (bestMap == null || mi.scale &gt; bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
+							|| (!moreDetails &amp;&amp; (curScale *  scaleTolerance &lt; mi.scale) &amp;&amp; (bestMap == null || mi.scale * scaleTolerance &lt; bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
+					) )	better = true;	// inbound and higher resolution if higher res wanted -&gt; better
+				} else { // same scale as bestmap -&gt; look if naerer 
+					latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
+					lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
+					if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+					else {
+						if ( (latNearer || lonNearer )) { 
+							if (bestMap == null || mi.center.getDistanceRad(lat, lon) &lt; bestMap.center.getDistanceRad(lat, lon) ) better = true;
+						}
+					}
+				} // same scale
+				if (better) {
+					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+					bestMap = mi;
+					// Vm.debug(&quot;better&quot;+ i);
+				}
+			}
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap);
+	}
+	/**
+	 * returns an area in lat/lon of the screen
+	 * @param a screen width / height and position of lat/lon on the screen
+	 * @param lat a (reference) point on the screen
+	 * @param lon
+	 * @param scale scale (meters per pixel) of the map for which the screen edges are wanted
+	 * @param map map for which the screen edges are wanted
+	 * @return
+	 */
+	private Area getAreaForScreen(Rect a, double lat, double lon, float scale, MapInfoObject map) {
+		Area ret = null;
+/*		if (scales2Area == null) scales2Area = new Hashtable();
+		else ret = (Area)scales2Area.get(scale);
+		if (ret != null) return ret;
+	*/	// calculate screen Area
+		Point xy = map.calcMapXY(lat, lon);
+		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
+		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
+		//scales2Area.put(new Float(scale), ret);
+		return ret; 
+	}
+	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
+		//return java.lang.Math.abs(a.scale - b.scale) &lt; scaleTolerance;
+		if (a.scale &gt; b.scale) return a.scale / b.scale &lt; scaleTolerance; 
+		else return b.scale / a.scale &lt; scaleTolerance;
+	}
+	public static boolean scaleEquals(float s, MapInfoObject b) {
+		//return java.lang.Math.abs(s - b.scale) &lt; scaleTolerance;
+		if (s &gt; b.scale) return s / b.scale &lt; scaleTolerance;
+		else return b.scale / s &lt; scaleTolerance;
+	}
+	
+	/**
+	 * 
+	 * @param test
+	 * @param old
+	 * @param wanted
+	 * @return true if test is nearer to wanted than old, false if the change in the scale is lower than scaleTolerance
+	 */
+	public static boolean scaleNearer(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test &gt; wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old &gt; wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta * scaleTolerance &lt; olda/wantb; 
+	}
+
+	public static boolean scaleNearerOrEuqal(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test &gt; wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old &gt; wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta &lt; olda/wantb * scaleTolerance ; 
+	}
+
+	/** for determining if a new map should be downloaded
+	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
+		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
+			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
+			return false;
+	}
+	 */
+}

Added: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,2025 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.MainTab;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.myTableModel;
+import ewe.ui.*;
+import ewe.graphics.*;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.sys.*;
+import ewe.filechooser.FileChooser;
+import ewe.fx.*;
+import ewe.util.Vector;
+
+/**
+ *	Class to handle a moving map.
+ */
+public class MovingMap extends Form {
+	public final static int gotFix = 4; //green
+	public final static int lostFix = 3; //yellow
+	public final static int noGPSData = 2; // red
+	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
+	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
+
+	public MapSymbol gotoPos = null;
+	public int GpsStatus;
+	Preferences pref;
+	MovingMapPanel mmp;
+	MapsList maps;
+	Vector symbols;
+	Vector cacheDB;
+	TrackOverlay[] TrackOverlays;
+	CWPoint TrackOverlaySetCenterTopLeft;
+	Vector tracks;
+	MapInfoObject currentMap = null;
+	String mapPath;
+	Navigate myNavigation;
+	boolean running = false;
+
+	MapImage mapImage1to1;
+	ArrowsOnMap directionArrows = new ArrowsOnMap();
+	AniImage statusImageHaveSignal = new AniImage(&quot;position_green.png&quot;);
+	AniImage statusImageNoSignal = new AniImage(&quot;position_yellow.png&quot;);
+	AniImage statusImageNoGps = new AniImage(&quot;position_red.png&quot;);
+	AniImage bottonImageClose;
+	AniImage bottonImageChooseMap = new AniImage(&quot;choose_map.gif&quot;); 
+	AniImage buttonImageGpsOn = new AniImage(&quot;snap2gps.gif&quot;);
+	AniImage buttonImageLens = new AniImage(&quot;lupe.png&quot;);
+	AniImage buttonImageLensActivated = new AniImage(&quot;lupe_activated.png&quot;);
+	AniImage buttonImageZoom1to1 = new AniImage(&quot;zoom1to1.png&quot;);
+	AniImage DistanceImage;
+	Graphics DistanceImageGraphics;
+	AniImage ScaleImage;
+	Graphics ScaleImageGraphics;
+	MapImage posCircle = new MapImage(&quot;position_green.png&quot;);
+	public static final String MARK_CACHE_IMAGE = &quot;mark_cache.png&quot;;
+	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
+	double posCircleLat, posCircleLon;
+	FontMetrics fm;
+
+	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean ignoreGps = false; // ignores updateGps-calls if true
+	boolean autoSelectMap = true;
+	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean mapHidden = false;
+	boolean noMapsAvailable;
+	boolean zoomingMode = false;
+	boolean mapsloaded = false;
+	
+	Point lastRepaintMapPos = null;
+	double lastDistance = -1;
+
+	public MovingMap(Navigate nav, Vector cacheDB){
+		this.cacheDB = cacheDB;
+		this.myNavigation = nav;
+		this.pref = Global.getPref();
+		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)	this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
+		this.windowFlagsToClear = Window.FLAG_HAS_TITLE | Window.BDR_NOBORDER;
+		this.hasTopBar = false;
+		this.noBorder = true;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		this.title = &quot;Moving Map&quot;;
+		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.mapPath = Global.getPref().getMapLoadPath();
+
+		mmp = new MovingMapPanel(this);
+		this.addLast(mmp);
+		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
+		bottonImageClose = new AniImage(new Image(closeX.getWidth(), closeX.getHeight()));
+		Graphics tmp = new Graphics(bottonImageClose.image);
+		tmp.setColor(255, 255, 255);
+		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
+		closeX.doDraw(tmp, 0);
+		bottonImageClose.properties |= AniImage.AlwaysOnTop;
+		mmp.addImage(bottonImageClose);
+		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageGpsOn);
+		bottonImageChooseMap.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(bottonImageChooseMap);
+		directionArrows.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(directionArrows);
+		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageLens);
+		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageZoom1to1);
+		//target distance
+		Font font = new Font(&quot;Helvetica&quot;, Font.PLAIN, 13);
+		fm = getFontMetrics(font);
+		DistanceImage = new AniImage();
+		DistanceImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
+		DistanceImageGraphics = new Graphics(DistanceImage.image);
+		DistanceImageGraphics.setFont(font);
+		DistanceImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(DistanceImage);
+		//scale
+		ScaleImage = new AniImage();
+		ScaleImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
+		ScaleImageGraphics = new Graphics(ScaleImage.image);
+		ScaleImageGraphics.setFont(font);
+		ScaleImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(ScaleImage);
+		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
+		setGpsStatus(noGPS);
+		posCircle.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(posCircle);
+		mmp.startDragResolution = 5;
+		mapsloaded = false;
+		posCircleLat = -361;
+		posCircleLon = -361; // make them invalid
+		//updateDistance(); // fill Rect with transparent color
+		scaleWanted = 1;
+		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		
+		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+	}
+
+	public void resizeTo(int w,int h) {
+		super.resizeTo(w, h);
+		updateFormSize(w, h);
+	}
+
+	public void updateFormSize(int w, int h) {
+		MapImage.setScreenSize(w, h);
+		bottonImageClose.setLocation(w- bottonImageClose.getWidth()- 5, 5);
+		buttonImageGpsOn.setLocation(w- bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
+		bottonImageChooseMap.setLocation(10,10);
+		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
+		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
+		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
+		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
+		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
+		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
+		if (tracks != null) addOverlaySet();
+	}
+
+	boolean loadingMapList = false;
+	/**
+	 * loads the list of maps
+	 * @param mapsPath must not have a trailing end &quot;/&quot;
+	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 */
+	public void loadMaps(String mapsPath, double lat){
+		if (loadingMapList) return;
+		loadingMapList = true;
+		this.mapPath = mapsPath;
+		Vm.showWait(this, true);
+		resetCenterOfMap();
+		InfoBox inf = new InfoBox(&quot;Info&quot;, &quot;Loading list of maps...&quot;);
+		inf.exec();
+		inf.waitUntilPainted(100);
+		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		maps = new MapsList(mapsPath); // this actually loads the maps
+		if (maps.isEmpty()) {
+			(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), MyLocale.getMsg(326, &quot;Es steht keine kalibrierte Karte zur Verf&#252;gung \n Bitte w&#228;hlen Sie einen Ma&#223;stab,\n in dem der Track und die markierten Caches angezeigt werden sollen&quot;), MessageBox.OKB)).execute();
+			noMapsAvailable = true;
+		} else noMapsAvailable = false;
+		maps.addEmptyMaps(lat);
+		dontUpdatePos = saveGpsIgnoreStatus;
+		inf.close(0);
+		Vm.showWait(this, false);
+		this.mapsloaded = true;
+		loadingMapList = false;
+	}
+
+	public void updateScale() {
+		ScaleImageGraphics.setColor(ScaleImage.transparentColor);
+		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
+		
+		if (currentMap != null)
+		{
+			float lineLengthMeters = 40 * currentMap.scale;
+			float digits = (float)java.lang.Math.floor( java.lang.Math.log(lineLengthMeters) / java.lang.Math.log(10.0) );
+			lineLengthMeters = (float)java.lang.Math.ceil( lineLengthMeters / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+
+			String lineLengthString;
+			if (lineLengthMeters &lt; 1000)
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters) + &quot;m&quot;;
+			}
+			else
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + &quot;km&quot;;
+			}
+			
+			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
+			
+			ScaleImageGraphics.setColor(new Color(250,250,250));
+			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
+
+			ScaleImageGraphics.setPen(new Pen(Color.DarkBlue,Pen.SOLID,3));
+			ScaleImageGraphics.drawLine(backgroundStartX + 2, ScaleImage.location.height / 2, backgroundStartX+2+lineLengthPixels, ScaleImage.location.height / 2);
+			ScaleImageGraphics.setColor(Color.DarkBlue);
+			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
+		}
+		
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+	}
+	
+	public void updateDistance(boolean repaint) {
+		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
+		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
+		if (gotoPos != null &amp;&amp; posCircleLat &gt;= -360)
+		{
+			double currentDistance = (new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon));
+			if (currentDistance != lastDistance)
+			{
+				lastDistance = currentDistance;
+				ewe.sys.Double dd = new ewe.sys.Double();
+				dd.set(currentDistance);
+				String d;
+				if (dd.value &lt; 1) {
+					dd.value = dd.value * 1000; 
+					dd.decimalPlaces = 0;
+					d = &quot;Dist: &quot; + dd.toString() + &quot;m&quot;;
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				} 
+				else {
+					dd.decimalPlaces = 2;
+					d = &quot;Dist: &quot; + dd.toString() + &quot;km&quot;;
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				}
+				
+				int backgroundWidth = fm.getTextWidth(d) + 4;
+
+				DistanceImageGraphics.setColor(new Color(250,250,250));
+				DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
+
+				DistanceImageGraphics.setColor(Color.DarkBlue);
+				DistanceImageGraphics.drawText(d, 2, 0);
+				
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+				if (repaint)
+				{
+					DistanceImage.refreshNow();
+				}
+			}
+		}
+		else
+		{
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+		}
+	}
+
+	public void forceMapLoad() {
+		forceMapLoad = true;
+		updatePosition(posCircleLat, posCircleLon); // this sets forceMapLoad to false after loading a map
+	}
+
+	public final FormFrame myExec() {
+		// update cache symbols in map
+		running = true;
+		MainTab mainT = Global.mainTab;
+		if (Global.getProfile().selectionChanged) {
+			Global.getProfile().selectionChanged = false;
+			removeAllMapSymbolsButGoto();
+			CacheHolder ch;
+			for (int i=cacheDB.size()-1; i&gt;=0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (ch.is_Checked &amp;&amp; !ch.is_filtered &amp;&amp; ch != mainT.ch) {
+					int ct = Convert.parseInt(ch.type);
+					addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+				}
+			}
+		}
+		setMarkedCache(mainT.ch);
+		addTrack(myNavigation.curTrack);
+		if (tracks != null &amp;&amp; tracks.size() &gt; 0 &amp;&amp; ((Track)tracks.get(0)).num &gt; 0) 
+			addOverlaySet(); // show points which where added when MavingMap was not running
+		destChanged(myNavigation.destination);
+		FormFrame ret = exec();
+		return ret;
+	}
+	
+	CacheHolder markedCache = null;
+	public void setMarkedCache(CacheHolder ch) {
+		if (ch == markedCache) return;
+		if (markedCache != null) {
+			removeMapSymbol(&quot;selectedCache&quot;);
+			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
+		}
+		if (ch != null) {
+			addSymbol(&quot;selectedCache&quot;, MARK_CACHE_IMAGE, ch.pos.latDec, ch.pos.lonDec);
+			int ct = Convert.parseInt(ch.type);
+			addSymbolIfNecessary(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+		}
+		markedCache = ch;
+	}
+	
+	public void addTrack(Track tr) {
+		if (tr == null) return;
+		if (tracks == null) tracks = new Vector();
+		if (tracks.find(tr) &gt;= 0 ) return; // track already in list
+		tracks.add(tr);
+		addOverlaySet();
+	}
+
+	public void addTracks(Track[] trs) {
+		if (trs==null || trs.length == 0) return;
+		for (int i=0; i&lt;trs.length; i++) {
+			addTrack(trs[i]);
+		}
+		addOverlaySet();
+	}
+
+	/**
+	 * adds an 3x3 set of overlays to the map-window which contain the track
+	 * 
+	 * add tracks with addtrack(track) before
+	 */
+
+	public void addOverlaySet() {
+		destroyOverlaySet();
+		if (tracks == null) return; // no tracks
+		try {
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+			addMissingOverlays();
+		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
+		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null 
+	}
+
+	public void destroyOverlaySet() {
+		if (TrackOverlays != null) {
+			for (int i=0; i&lt; TrackOverlays.length; i++) {	destroyOverlay(i);	}
+		}
+		Vm.getUsedMemory(true); // call garbage collection
+		Vm.gc();
+	}
+
+
+	public void addMissingOverlays() {
+		if (currentMap == null || posCircleLat &lt; -360 || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (TrackOverlays == null) {
+			TrackOverlays = new TrackOverlay[9];
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+		}
+		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		dontUpdatePos = true;
+		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec); // TrackOverlay[4] == center of Trackoverlays 
+		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
+		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		int i;
+		for (int yi=0; yi&lt;3; yi++) {
+			for (int xi=0; xi&lt;3; xi++) {
+				i = yi*3+xi;
+				if (TrackOverlays[i]==null) { 
+					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap); 
+					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
+					TrackOverlays[i].tracks = this.tracks;
+					TrackOverlays[i].paintTracks();
+					mmp.addImage(TrackOverlays[i]);
+				}
+			}
+		}
+		updateOverlayOnlyPos();
+		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		dontUpdatePos = saveGPSIgnoreStatus;
+	}
+
+	private void destroyOverlay(int ov) {
+		if (TrackOverlays[ov] == null) return; 
+		mmp.removeImage(TrackOverlays[ov]);
+		TrackOverlays[ov].free();
+		TrackOverlays[ov]=null;
+	}
+	public void rearangeOverlays() {
+		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec);
+		if (TrackOverlays[1].isOnScreen()) { // oben raus
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			destroyOverlay(6);
+			destroyOverlay(7);
+			destroyOverlay(8);
+			mmp.removeImage(TrackOverlays[0]);
+			mmp.removeImage(TrackOverlays[1]);
+			mmp.removeImage(TrackOverlays[2]);
+			TrackOverlays[6]=TrackOverlays[0];
+			TrackOverlays[7]=TrackOverlays[1];
+			TrackOverlays[8]=TrackOverlays[2];
+			mmp.addImage(TrackOverlays[6]);
+			mmp.addImage(TrackOverlays[7]);
+			mmp.addImage(TrackOverlays[8]);
+			TrackOverlays[0] = null;
+			TrackOverlays[1] = null;
+			TrackOverlays[2] = null;
+			destroyOverlay(3);
+			destroyOverlay(4);
+			destroyOverlay(5);
+		} else {
+			if (TrackOverlays[3].isOnScreen()) { // links raus
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				destroyOverlay(2);
+				destroyOverlay(5);
+				destroyOverlay(8);
+				mmp.removeImage(TrackOverlays[0]);
+				mmp.removeImage(TrackOverlays[3]);
+				mmp.removeImage(TrackOverlays[6]);
+				TrackOverlays[2]=TrackOverlays[0];
+				TrackOverlays[5]=TrackOverlays[3];
+				TrackOverlays[8]=TrackOverlays[6];
+				mmp.addImage(TrackOverlays[2]);
+				mmp.addImage(TrackOverlays[5]);
+				mmp.addImage(TrackOverlays[8]);
+				TrackOverlays[0] = null;
+				TrackOverlays[3] = null;
+				TrackOverlays[6] = null;
+				destroyOverlay(1);
+				destroyOverlay(4);
+				destroyOverlay(7);
+			} else {
+				if (TrackOverlays[5].isOnScreen()) { // rechts raus
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					destroyOverlay(0);
+					destroyOverlay(3);
+					destroyOverlay(6);
+					mmp.removeImage(TrackOverlays[2]);
+					mmp.removeImage(TrackOverlays[5]);
+					mmp.removeImage(TrackOverlays[8]);
+					TrackOverlays[0]=TrackOverlays[2];
+					TrackOverlays[3]=TrackOverlays[5];
+					TrackOverlays[6]=TrackOverlays[8];
+					mmp.addImage(TrackOverlays[0]);
+					mmp.addImage(TrackOverlays[3]);
+					mmp.addImage(TrackOverlays[6]);
+					TrackOverlays[2] = null;
+					TrackOverlays[5] = null;
+					TrackOverlays[8] = null;
+					destroyOverlay(1);
+					destroyOverlay(4);
+					destroyOverlay(7);
+				} else {
+					if (TrackOverlays[7].isOnScreen()) { // unten raus
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						destroyOverlay(0);
+						destroyOverlay(1);
+						destroyOverlay(2);
+						mmp.removeImage(TrackOverlays[6]);
+						mmp.removeImage(TrackOverlays[7]);
+						mmp.removeImage(TrackOverlays[8]);
+						TrackOverlays[0]=TrackOverlays[6];
+						TrackOverlays[1]=TrackOverlays[7];
+						TrackOverlays[2]=TrackOverlays[8];
+						mmp.addImage(TrackOverlays[0]);
+						mmp.addImage(TrackOverlays[1]);
+						mmp.addImage(TrackOverlays[2]);
+						TrackOverlays[6] = null;
+						TrackOverlays[7] = null;
+						TrackOverlays[8] = null;
+						destroyOverlay(3);
+						destroyOverlay(4);
+						destroyOverlay(5);
+					} else { // it is important to test for diagonal only if the other didn't match
+						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+							destroyOverlay(8);
+							mmp.removeImage(TrackOverlays[0]);
+							TrackOverlays[8]=TrackOverlays[0];
+							mmp.addImage(TrackOverlays[8]);
+							TrackOverlays[0] = null;
+							destroyOverlay(1);
+							destroyOverlay(2);
+							destroyOverlay(3);
+							destroyOverlay(4);
+							destroyOverlay(5);
+							destroyOverlay(6);
+							destroyOverlay(7);
+						} else {
+							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+								destroyOverlay(6);
+								mmp.removeImage(TrackOverlays[2]);
+								TrackOverlays[6]=TrackOverlays[2];
+								mmp.addImage(TrackOverlays[6]);
+								TrackOverlays[2] = null;
+								destroyOverlay(0);
+								destroyOverlay(1);
+								destroyOverlay(3);
+								destroyOverlay(4);
+								destroyOverlay(5);
+								destroyOverlay(7);
+								destroyOverlay(8);
+							} else {
+								if (TrackOverlays[6].isOnScreen()) { // links unten raus
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+									destroyOverlay(2);
+									mmp.removeImage(TrackOverlays[6]);
+									TrackOverlays[2]=TrackOverlays[6];
+									mmp.addImage(TrackOverlays[2]);
+									TrackOverlays[6] = null;
+									destroyOverlay(0);
+									destroyOverlay(1);
+									destroyOverlay(3);
+									destroyOverlay(4);
+									destroyOverlay(5);
+									destroyOverlay(7);
+									destroyOverlay(8);
+								} else {
+									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+										destroyOverlay(0);
+										mmp.removeImage(TrackOverlays[8]);
+										TrackOverlays[0]=TrackOverlays[8];
+										mmp.addImage(TrackOverlays[0]);
+										TrackOverlays[8] = null;
+										destroyOverlay(1);
+										destroyOverlay(2);
+										destroyOverlay(3);
+										destroyOverlay(4);
+										destroyOverlay(5);
+										destroyOverlay(6);
+										destroyOverlay(7);
+									}else
+										for (int i=0; i&lt;TrackOverlays.length; i++) {
+											destroyOverlay(i);
+											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+										} // this happens if a position jump occured
+								}}}}}}} // close all IFs
+		Vm.gc(); // call garbage collection
+		Vm.debug(&quot;Overlayrearanged&quot;+TrackOverlays.toString());
+	}
+
+	public void ShowLastAddedPoint(Track tr) {
+		if (TrackOverlays == null || tr == null) return;
+		for (int i=0; i&lt;TrackOverlays.length; i++){
+			TrackOverlays[i].paintLastAddedPoint(tr);
+		}
+	}
+
+	public void updateOverlayOnlyPos() {
+		if (TrackOverlays == null || TrackOverlays[4] == null) return;
+		//	Point upperleft = getMapXYPosition();
+		Point posOnScreen;
+		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft.latDec, TrackOverlays[4].topLeft.lonDec);
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
+		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		int num, x, y;
+		for (int yi=0; yi&lt;3; yi++) {
+			for (int xi=0; xi&lt;3; xi++) {
+				num = yi*3+xi;
+				x = posOnScreen.x+(xi-1)*ww;
+				y = posOnScreen.y+(yi-1)*wh; 
+				TrackOverlays[num].setLocation(x, y);
+			}
+		}
+	}
+
+	public void updateOverlayPos() {
+		if (tracks == null || tracks.size() == 0) return;
+		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		else {
+			updateOverlayOnlyPos();
+			if (TrackOverlays[0].locAlways.x &gt; 0 || TrackOverlays[2].locAlways.x &lt; 0
+					|| TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
+				rearangeOverlays();
+				addMissingOverlays();
+				// updateOverlayOnlyPos(); is called from addMissingOverlays 
+			}
+		}
+	}
+
+	/**
+	 * move posCircle to the Center of the Screen
+	 *
+	 */
+	public void resetCenterOfMap() {
+		if (width != 0) {
+			posCircleX = width /2;
+			posCircleY = height /2;
+		} else {
+			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight/2;
+		}
+		posCircle.hidden = false;
+		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -&gt; hiding the posCircle in some situation
+	}
+
+	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
+	}
+
+	public void setCenterOfScreen (CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	}
+
+	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
+		Point mappos = getMapPositionOnScreen();
+		Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
+		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
+		if (repaint) mmp.repaintNow();
+	}
+
+	/** call this if the map moved on the screen (by dragging)
+	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * @param diffX
+	 * @param diffY
+	 */
+	public void mapMoved(int diffX, int diffY) {
+		int w = posCircle.getWidth();
+		int h = posCircle.getHeight();
+		int npx = posCircleX-w/2+diffX; 
+		int npy = posCircleY-h/2+diffY;
+		posCircle.move(npx, npy);
+		posCircleX = posCircleX+diffX;
+		posCircleY = posCircleY+diffY;
+		updateSymbolPositions();
+		updateOverlayPos();
+	}
+
+	/**
+	 * get upper left corner of map on window
+	 * this is called when the map needs to be moved / the position of the map is wanted
+	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos);
+	 * but also works if mmp == null and is used to move the map to the correct point
+	 * @return
+	 */
+	public Point getMapPositionOnScreen() {
+		if (currentMap == null || posCircleLon &lt; -360) return new Point(pref.myAppWidth +1, pref.myAppHeight +1); // in case no calculation is possible return somthing outside of the screen
+		Point mapPos = new Point(); 
+		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		//else {
+		Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
+		mapPos.x = posCircleX - mapposint.x;
+		mapPos.y = posCircleY - mapposint.y;
+		//}
+		return mapPos;
+	}
+
+	/**
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Point getXYonScreen(double lat, double lon){
+		if (currentMap == null) return null;
+		Point coords = currentMap.calcMapXY(lat, lon);
+		Point mapPos = getMapPositionOnScreen();
+		//		Vm.debug(&quot;getXYinMap, posCiLat: &quot;+posCircleLat+&quot;poscLOn: &quot;+ posCircleLon+&quot;gotoLat: &quot;+ lat + &quot;gotoLon: &quot;+ lon+&quot; mapPosX: &quot;+mapPos.x+&quot;mapposY&quot;+mapPos.y);
+		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
+	}
+
+	public CWPoint ScreenXY2LatLon (int x, int y){
+		Point mapPos = getMapPositionOnScreen();
+		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
+	}
+
+
+	public void updateSymbolPositions() {
+		if (symbols == null) return;
+		Point pOnScreen;
+		MapSymbol symb;
+		int ww = this.width;
+		int wh = this.height;
+		int w, h;
+		for (int i=symbols.size()-1; i&gt;=0; i--) {
+			symb = (MapSymbol)symbols.get(i);
+			pOnScreen = getXYonScreen(symb.lat, symb.lon);
+			w=symb.getWidth();
+			h=symb.getHeight();
+			if (pOnScreen.x+w &gt;= 0 &amp;&amp; pOnScreen.x &lt;= ww &amp;&amp; pOnScreen.y+h &gt;= 0 &amp;&amp;  pOnScreen.y &lt;= wh) 
+			{
+				symb.properties &amp;= ~mImage.IsInvisible;
+				symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+			}
+			else 
+			{symb.properties |= mImage.IsInvisible;
+			symb.move(30, 30);
+			}
+			//symb.pic.move(ww+1, wh+1);
+		}
+	}
+
+	public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
+		ms.loadImage();
+		ms.properties |= AniImage.AlwaysOnTop;
+		Point pOnScreen = getXYonScreen(lat, lon);
+		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+		return ms;
+	}
+	
+	public void addSymbolIfNecessary(String name, Object mapObject, Image imSymb, double lat, double lon) {
+		if (findMapSymbol(name) &gt;= 0) return;
+		else addSymbol(name, mapObject, imSymb, lat, lon);
+		
+	}
+		
+	public void addSymbol(String name, Object mapObject, Image imSymb, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, lat, lon);
+		ms.properties = AniImage.AlwaysOnTop;
+		Point pOnScreen=getXYonScreen(lat, lon);
+		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+	}
+
+	public void destChanged(CWPoint d) {
+		if(!running || (d == null &amp;&amp; gotoPos == null) || 
+				(d != null &amp;&amp; gotoPos != null &amp;&amp; d.latDec == gotoPos.lat &amp;&amp; d.lonDec == gotoPos.lon)) return;
+		removeGotoPosition();
+		if (d == null || !d.isValid() ) return;
+		gotoPos = addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, d.latDec, d.lonDec);
+		//updateDistance(); - this is called from updatePosition
+		forceMapLoad = true;
+		if (this.width != 0) updatePosition(posCircleLat, posCircleLon); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+	}
+
+	public void removeGotoPosition() {
+		removeMapSymbol(&quot;goto&quot;);
+	}
+
+	public CWPoint getGotoPos(){
+		if (gotoPos == null) return null;
+		return new CWPoint(gotoPos.lat, gotoPos.lon);
+	}
+
+	public void removeAllMapSymbolsButGoto(){
+		if (symbols == null) return;
+		for (int i = symbols.size()-1; i &gt;= 0; i--) {
+			mmp.removeImage((MapSymbol)symbols.get(i));
+		}
+		symbols.removeAllElements();
+		if (gotoPos != null) symbols.add(gotoPos);
+	}
+
+	public void removeMapSymbol(String name) {
+		int symbNr = findMapSymbol(name);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+	public void removeMapSymbol(Object obj) {
+		int symbNr = findMapSymbol(obj);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+
+	public void removeMapSymbol(int SymNr) {
+		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		symbols.removeElementAt(SymNr);
+	}
+
+	public int findMapSymbol(String name) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.name == name) return i;
+		}
+		return -1;
+	}
+	
+	public int findMapSymbol(Object obj) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.mapObject == obj) return i;
+		}
+		return -1;
+	}
+
+	/**
+	 * Move the map so that the posCircle is at lat/lon
+	 * 
+	 * @param  
+	 */
+	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
+		//Point oldMapPos = getMapPositionOnScreen();
+		posCircleLat = lat;
+		posCircleLon = lon;
+		Point mapPos = getMapPositionOnScreen();
+		//Vm.debug(&quot;mapx = &quot; + mapx);
+		//Vm.debug(&quot;mapy = &quot; + mapy);
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1)) 
+		{
+			lastRepaintMapPos = mapPos;
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			updateSymbolPositions();
+			updateDistance(false);
+			if (updateOverlay ) updateOverlayPos(); // &amp;&amp; TrackOverlays != null
+			mmp.repaintNow(); 
+		}
+		else
+		{
+			updateDistance(true);
+		}
+		//Vm.debug(&quot;update only position&quot;);			
+	}
+	/**
+	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 */
+	public void updatePosition(double lat, double lon){
+		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+		Vm.debug(&quot;updatepors, lat: &quot;+lat+&quot; lon: &quot;+lon);
+		if (!mapsloaded) {
+			loadMaps(mapPath, lat);
+			lastCompareX = Integer.MAX_VALUE;
+			lastCompareY = Integer.MAX_VALUE;
+			autoSelectMap = true;
+			setBestMap(lat, lon, true);
+			forceMapLoad = false;
+			return;
+		}
+		updateOnlyPosition(lat, lon, true);
+		if (!autoSelectMap) return;
+		Point mapPos = getMapPositionOnScreen();
+		boolean screenNotCompletlyCovered =  mmp.mapImage == null || (mmp.mapImage != null &amp;&amp; ( mapPos.y &gt; 0 || mapPos.x &gt; 0 || mapPos.y+mmp.mapImage.getHeight()&lt;this.height	|| mapPos.x+mmp.mapImage.getWidth()&lt;this.width));
+		if (forceMapLoad || wantMapTest|| screenNotCompletlyCovered) 	{ // if force || want || map doesn't cover the scree completly
+			//Vm.debug(&quot;Screen not completly covered by map&quot;);
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) &gt; this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) &gt; this.height/10)) {
+				// more then 1/10 of screen moved since last time we tried to find a better map
+				lastCompareX = mapPos.x;
+				lastCompareY = mapPos.y;
+				setBestMap(lat, lon, screenNotCompletlyCovered);
+				forceMapLoad = false;
+			}
+		}
+	}
+
+	public void updateGps(int fix) {
+		if (!running || ignoreGps) return;
+		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
+			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
+					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+			setGpsStatus(MovingMap.gotFix);
+			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
+			ShowLastAddedPoint(myNavigation.curTrack);
+		}
+		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
+		if (fix &lt; 0 )	setGpsStatus(MovingMap.noGPSData);
+	}
+	
+	public void gpsStarted() {
+		addTrack(myNavigation.curTrack);
+		ignoreGps = false;
+	}
+	public void gpsStoped() {
+		setGpsStatus(MovingMap.noGPS);
+	}
+
+	int mapChangeModus;
+	float scaleWanted;
+	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	public final static int HIGHEST_RESOLUTION = 2;
+	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
+	boolean inBestMap = false; // to avoid multi-threading problems
+
+	/**
+	 * loads the best map for lat/lon according to mapChangeModus
+	 * lat/lon will be at the screen-pos of posCircle
+	 * when posCircle is not on the screen (shifted outside my the user)
+	 * then this routine uses the center of the screen to find the best map
+	 * but anyway the map will be adjusted (moved) relativ to posCircle
+	 * when a better map was found the called method updateposition will set
+	 * posCirleLat/-Lon to lat/lon.
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @param loadIfSameScale false: will not change the map if the better map has the same scale as the current - this is used not to change the map if it covers already the screen completely
+	 * true: willchange the map, regardless of change in scale
+	 */
+	public void setBestMap(double lat, double lon, boolean loadIfSameScale) {
+		if (inBestMap) return;
+		inBestMap = true;
+		Object [] s = getRectForMapChange(lat, lon);
+		CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		MapInfoObject newmap = null;
+		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		wantMapTest = true;
+		switch (mapChangeModus) {
+		case NORMAL_KEEP_RESOLUTION: 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, scaleWanted, false);
+			if (newmap == null) newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			break;
+		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
+		case HIGHEST_RESOLUTION_GPS_DEST: 
+			if (gotoPos!= null &amp;&amp; GpsStatus != noGPS &amp;&amp; posCircleLat&gt;= -90 &amp;&amp; posCircleLat &lt;= 90 &amp;&amp; posCircleLon &gt;= -360 &amp;&amp; posCircleLon &lt;= 360) {
+				newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon)); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
+				if (newmap == null) newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
+			}
+			//	either Goto-Pos or GPS-Pos not set
+			else newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); 
+			break;
+		default: (new MessageBox(&quot;Error&quot;, &quot;Programmfehler: \nillegal mapChangeModus: &quot; + mapChangeModus, MessageBox.OKB)).execute(); break;
+		}
+		if ( newmap != null &amp;&amp; (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+				Vm.debug(&quot;better map found&quot;);
+				setMap(newmap, lat, lon);
+				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
+			}
+			inBestMap = false;
+			return;
+		}
+		if (currentMap == null &amp;&amp; newmap == null) {
+			(new MessageBox(&quot;Information&quot;, &quot;F&#252;r die aktuelle Position steht keine Karte zur Verf&#252;ng, bitte w&#228;hlen Sie eine manuell&quot;, MessageBox.OKB)).execute();
+			posCircleLat = cll.latDec;
+			posCircleLon = cll.lonDec; // choosemap calls setmap with posCircle-coos
+			while (currentMap == null) {
+				mmp.chooseMap(); // force the user to select a scale // TODO empty maps on top?
+				if (currentMap == null) (new MessageBox(&quot;Error&quot;, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;, MessageBox.OKB)).execute();
+			}
+		}
+		inBestMap = false;
+	}
+
+	public void setResModus (int modus) {
+		scaleWanted = currentMap.scale;
+		if (mapChangeModus == modus) return;
+		mapChangeModus = modus;
+		if (modus != NORMAL_KEEP_RESOLUTION) setBestMap(posCircleLat, posCircleLon, true);
+	}
+	/**
+	 * method to get a point on the screen which must be included in the map
+	 * the map methods are looking for. If the poscircle is on the screen this will be 
+	 * that point. If it is outside then the center of the screen will be used.
+	 * 
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Object[] getRectForMapChange(double lat, double lon) {
+		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		int h = (height != 0 ? height : pref.myAppHeight);
+		int x, y;
+		CWPoint cll;
+		if (posCircleX &gt;= 0 &amp;&amp; posCircleX &lt;= w &amp;&amp; posCircleY &gt;= 0 &amp;&amp; posCircleY &lt;= h) {
+			x = posCircleX; // posCircle is inside the screen
+			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#252;hren, wenn voher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			cll = new CWPoint(lat, lon);
+		} else { // when posCircle out of screen - use center of screen as point which as to be included in the map
+			cll = ScreenXY2LatLon(w/2, h/2);
+			x = w/2;
+			y = h/2;
+		} 
+		Object[] ret = new Object[2];
+		ret[0] = cll;
+		ret[1] = new Rect(x, y, w, h);
+		return ret; 
+	}
+
+	/**
+	 * 
+	 * @param betterOverview true: getmap with better overview
+	 * @return
+	 */
+	public void loadMoreDetailedMap(boolean betterOverview){
+		Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+		CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
+		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale / currentMap.zoomFactor, !betterOverview);
+		if (m != null) {
+			boolean saveGpsIgnStatus = dontUpdatePos;
+			dontUpdatePos = true;
+			setMap(m, posCircleLat, posCircleLon);
+			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+			dontUpdatePos = saveGpsIgnStatus;
+		}
+		else (new MessageBox(&quot;Error&quot;, &quot;No &quot;+ (betterOverview ? &quot;less&quot; : &quot;more&quot;) + &quot; deteiled map available&quot;, MessageBox.OKB)).execute();
+	}
+
+	public void loadMapForAllCaches(){
+		Area sur = Global.getProfile().getSourroundingArea(true);
+		if (sur == null) {
+			(new MessageBox(&quot;Error&quot;, &quot;Keine  Caches mit H&#228;ckchen ausgew&#228;hlt&quot;, MessageBox.OKB)).execute();
+			return;
+		}
+		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
+		if (newmap == null ) { // no map that includs all caches is available -&gt; load map with lowest resolution
+			Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+			CWPoint cll = (CWPoint) s[0]; 
+			Rect screen = (Rect) s[1]; 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, Float.MAX_VALUE -1, false);
+		}
+		boolean saveGpsIgnStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		setMap(newmap, posCircleLat, posCircleLon);
+		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+		dontUpdatePos = saveGpsIgnStatus;
+	}
+
+	public void setGpsStatus (int status) {
+		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		GpsStatus = status;
+		dontUpdatePos = false;
+		ignoreGps = false;
+		switch (status) {
+		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
+		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
+		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		}
+		posCircle.refreshNow();
+	}
+
+	public void SnapToGps() {
+		resetCenterOfMap();
+		dontUpdatePos = false;
+		ignoreGps = false;
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareY = Integer.MAX_VALUE;
+		autoSelectMap = true;
+		forceMapLoad = true;
+		showMap();
+		if (myNavigation.gpsPos.Fix &lt;=0) updatePosition(posCircleLat, posCircleLon);
+		else updateGps(myNavigation.gpsPos.getFix());
+	}
+
+	/** sets and displays the map
+	 * 
+	 * @param newmap
+	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
+	 * @param lon -361: don't adust to lat/lon
+	 */
+	public void setMap(MapInfoObject newmap, double lat, double lon) {
+		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text 
+			updateOnlyPosition(lat, lon, true); 
+			return;
+		}
+		Vm.showWait(true);
+		boolean saveIgnoreStatus;
+		saveIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
+		InfoBox inf;
+		inf = new InfoBox(&quot;Info&quot;, &quot;Loading map...&quot;);
+		inf.show();
+		inf.waitUntilPainted(100);
+		try {
+			this.currentMap = newmap; 
+			this.title = currentMap.mapName;
+			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+			lastCompareY = Integer.MAX_VALUE;
+			if (mmp.mapImage != null ) {
+				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
+				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+
+				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
+				Vm.getUsedMemory(true); // calls the garbage collection
+			} // give memory free before loading the new map to avoid out of memory error
+			String ImageFilename = currentMap.getImageFilename(); 
+			if (ImageFilename == null ) {
+				mmp.mapImage = new MapImage();
+				(new MessageBox(&quot;Error&quot;, &quot;Could not find image associated with: \n&quot;+currentMap.fileNameWFL, MessageBox.OKB)).execute();
+			}
+			else { 
+				if (ImageFilename.length() &gt; 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new MapImage();
+			}
+			mapImage1to1 = mmp.mapImage;
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.mapImage.move(0,0);
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			addOverlaySet();
+			forceMapLoad = true; // forces updateOnlyPosition to redraw
+			updateOnlyPosition(lat, lon, false);
+			forceMapLoad = false;
+			directionArrows.setMap(currentMap);
+			updateScale();
+			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
+			Vm.showWait(false);
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox(&quot;Error&quot;, &quot;Could not load map: &quot;+ newmap.getImageFilename(), MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (OutOfMemoryError e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox(&quot;Error&quot;, &quot;Not enough memory to load map: &quot;+ newmap.getImageFilename()+&quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;, MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}catch (SystemResourceException e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox(&quot;Error&quot;, &quot;Not enough ressources to load map: &quot;+ newmap.getImageFilename()+&quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;, MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}
+	}
+
+	public void hideMap() {
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.hide();
+		mapHidden = true;
+		repaintNow();
+	}
+
+	public void showMap() {
+		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.unhide();
+		mapHidden = false;
+		repaintNow();
+	}
+
+	public void setZoomingMode() {
+		mmp.removeImage(buttonImageLens);
+		mmp.addImage(buttonImageLensActivated);
+		repaintNow();
+		zoomingMode = true;
+	}
+
+	/**
+	 * zommes in if w&gt;0 and out if w&lt;0
+	 * @param firstclickpoint
+	 * @param w
+	 * @param h
+	 */
+	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
+		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
+		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
+		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		float zoomFactor;
+		if (w &gt; 0)  zoomFactor = (float)this.width / (float)w; // zoom in
+		else {
+			w = java.lang.Math.abs(w);
+			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+			zoomFactor = (float)w / (float)this.width;
+		}
+		if (h &lt; 0) {
+			h = java.lang.Math.abs(h);
+			firstclickpoint.y = firstclickpoint.y - h;
+		}
+		// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
+		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
+		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
+		Point mappos = getMapPositionOnScreen();
+		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
+		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
+		{
+			// try to avoid overlapping by shifting
+			if (newImageRect.x &lt; 0) 
+				newImageRect.x = 0; // align left if left overlapping
+			if (newImageRect.y &lt; 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+			// crop if after shifting still overlapping
+			if (newImageRect.x &lt; 0) 
+				newImageRect.x = 0;
+			if (newImageRect.y &lt; 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+		}
+		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+	}
+
+	public void zoom1to1() {
+		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+	}
+
+	/**
+	 * do the actual scaling
+	 * @param zoomFactor relative to original image
+	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * @param center
+	 */		
+	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+		Vm.showWait(this, true);
+		boolean savegpsstatus = dontUpdatePos;
+		if (mapImage1to1 != null) {
+			dontUpdatePos = true; // avoid multi-thread problems
+			int saveprop = AniImage.IsMoveable;
+			MapImage tmp = null; // = mmp.mapImage;
+			if (mmp.mapImage != null) {
+				tmp = mmp.mapImage;
+				saveprop = mmp.mapImage.properties;
+				mmp.removeImage(mmp.mapImage);
+				if (mmp.mapImage != mapImage1to1) {
+					mmp.mapImage.free();
+					mmp.mapImage = null;
+				} else tmp = mapImage1to1;
+			}
+			Vm.getUsedMemory(true);
+			try {
+				if (zoomFactor == 1) tmp = mapImage1to1;
+				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+			} catch (OutOfMemoryError e) {
+				(new MessageBox(&quot;Error&quot;, &quot;Out of memory error&quot;, MessageBox.OKB)).execute();
+				//tmp = mapImage1to1;
+			} //if (tmp != null) currentMap.zoom();}
+			Vm.getUsedMemory(true);
+			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage.properties = saveprop;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
+			{
+				Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x,mappos.y);
+			}
+		} else // no map image loaded 
+		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
+		destroyOverlaySet();
+		Vm.getUsedMemory(true); // call garbage collection
+		setCenterOfScreen(center, false);
+		addOverlaySet();
+		updateScale();
+		this.repaintNow();
+		Vm.showWait(this, false);
+		dontUpdatePos = savegpsstatus;
+	}
+
+	/*	public void gotFocus(int how) {
+		super.gotFocus(how);
+		Dimension ws = getSize(null);
+		onWindowResize(ws.width, ws.height);
+		Vm.debug(ws.width + &quot; h: &quot;+ws.height);
+		this.setPreferredSize(width, height)
+	}
+	 */
+	public void onEvent(Event ev){
+		if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
+			running = false;
+		}  
+		if(ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; ((KeyEvent)ev).key == IKeys.ESCAPE) {
+			this.close(0);
+			ev.consumed = true;
+		}
+		super.onEvent(ev);
+	}
+}
+
+/**
+ *	Class to display the map bitmap and to select another bitmap to display.
+ */
+class MovingMapPanel extends InteractivePanel implements EventListener {
+	Menu kontextMenu;
+	MenuItem gotoMenuItem = new MenuItem(&quot;Goto here$g&quot;, 0, null);
+	MenuItem newWayPointMenuItem = new MenuItem(&quot;Create new Waypoint here$n&quot;, 0, null);;
+	MenuItem openCacheDescMenuItem,addCachetoListMenuItem;
+	
+	MenuItem miLuminary[];
+
+	Menu mapsMenu;
+	MenuItem selectMapMI = new MenuItem(&quot;Select a map manually$s&quot;, 0, null);
+	MenuItem changeMapDirMI = new MenuItem(&quot;Change map directory$c&quot;, 0, null);
+	MenuItem showMapMI = new MenuItem(&quot;Show map&quot;, 0, null);
+	MenuItem hideMapMI = new MenuItem(&quot;Hide map&quot;, 0, null);
+	// automatic
+	MenuItem mapChangeModusMI = new MenuItem(&quot;Modus for automatic map change&quot;, MenuItem.Separator, null);;
+	MenuItem highestResGpsDestMI = new MenuItem(&quot;Highest res. containing dest. &amp; cur. position&quot;, 0, null); //immer h&#246;chste Aufl&#246;sung w&#228;hlen, die akt. Pos. und Ziel enthalten 
+	MenuItem highestResolutionMI = new MenuItem(&quot;Highest resolution&quot;, 0, null); //immer h&#246;chste Aufl&#246;sung w&#228;hlen 
+	MenuItem keepManResolutionMI = new MenuItem(&quot;Keep manual resolution&quot;, 0, null); // manuell gew&#228;hlte Aufl&#246;sung beibehalten  
+	// manuell
+	MenuItem mapChangeResMI = new MenuItem(&quot;Change resolution manually&quot;, MenuItem.Separator, null);;
+	MenuItem AllCachesResMI = new MenuItem(&quot;Load a map containing all marked caches&quot;, 0, null); // Karte w&#228;hlen, die alle markierten Caches enth&#228;lt  
+	MenuItem moreDetailsMI = new MenuItem(&quot;Load a map with more details&quot;, 0, null); // detailreichere Karte laden 
+	MenuItem moreOverviewMI = new MenuItem(&quot;Load a map for a better overview&quot;, 0, null); // Karte mit mehr &#220;bersicht w&#228;hlen  
+	// move map to
+	MenuItem moveToMI = new MenuItem(&quot;Move map to an load map&quot;, MenuItem.Separator, null);;
+	MenuItem moveToDestMI = new MenuItem(&quot;move to goto point&quot;, 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
+	MenuItem moveToGpsMI = new MenuItem(&quot;move to GPS position&quot;, 0, null);   
+	MenuItem moveToCenterMI = new MenuItem(&quot;move to Center&quot;, 0, null);   
+
+	CacheHolder clickedCache;
+	MovingMap mm;
+	MapImage mapImage;
+	Point saveMapLoc = null;
+	boolean saveGpsIgnoreStatus;
+	boolean paintingZoomArea;
+	ImageList saveImageList = null;
+	int lastZoomWidth , lastZoomHeight;
+	public MovingMapPanel(MovingMap f){
+		this.mm = f;
+		set(Control.WantHoldDown, true); // want to get simulated right-clicks
+	}
+
+	public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (mm.zoomingMode == true) { // zoom
+//			saveMapLoc = pos;
+			//		saveGpsIgnoreStatus = mm.ignoreGps;
+			//	mm.ignoreGps = true;
+			return false;
+		}
+		// move (drag) map
+		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		saveGpsIgnoreStatus = mm.dontUpdatePos; 
+		mm.dontUpdatePos = true;
+		saveMapLoc = pos;
+		bringMapToTop();
+		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
+		else return super.imageBeginDragged(null, pos);
+	}
+
+	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+		boolean ret = super.imageNotDragged(dc, pos);
+		bringMaptoBack();
+		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		mm.dontUpdatePos = saveGpsIgnoreStatus;
+		this.repaintNow();
+		return ret;
+	}
+
+	public void onPenEvent(PenEvent ev) {
+		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
+		}
+		if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN) {
+			saveGpsIgnoreStatus = mm.dontUpdatePos;
+			mm.dontUpdatePos = true;
+			saveMapLoc = new Point (ev.x, ev.y);
+			paintingZoomArea = true;
+			mm.zoomingMode = true;
+		} 
+		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.modifiers == PenEvent.RIGHT_BUTTON) {
+			penHeld(new Point (ev.x, ev.y));
+		}
+		if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_UP ) {
+			paintingZoomArea = false;
+			mm.zoomingMode = false;
+			mm.dontUpdatePos = saveGpsIgnoreStatus;
+			removeImage(mm.buttonImageLensActivated);
+			addImage(mm.buttonImageLens);
+			if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15)  {
+				repaintNow();
+				return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+			}
+			mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
+		}
+
+		if (mm.zoomingMode &amp;&amp; paintingZoomArea &amp;&amp; (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+			int left, top;
+			Graphics dr = this.getGraphics();
+			if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			left -= 2;
+			top -= 2;
+			if (top &lt; 0) top = 0;
+			if (left &lt; 0) left = 0;
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+			lastZoomWidth = ev.x - saveMapLoc.x;
+			lastZoomHeight =  ev.y - saveMapLoc.y;
+			if (lastZoomWidth &lt; 0) left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
+		}
+		super.onPenEvent(ev);
+	}
+
+	private void bringMapToTop() {
+		if (mapImage == null || mapImage.hidden) {
+			saveImageList = null;
+			return;
+		}
+		saveImageList = new ImageList();
+		saveImageList.copyFrom(images);
+		images.removeAllElements();
+		images.add(mapImage);
+	}
+	private void bringMaptoBack() {
+		if (saveImageList == null) return;
+		images = saveImageList;
+		saveImageList = null;
+	}
+
+	public void moveMap(int diffX, int diffY) {
+		Point p = new Point();
+		if (mapImage!= null) {
+			p = mapImage.locAlways;
+			mapImage.move(p.x+diffX,p.y+diffY);
+			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+		}
+		mapMoved(diffX, diffY);
+	}
+
+	public void mapMoved(int diffX, int diffY){
+		mm.mapMoved(diffX, diffY);
+		this.repaintNow();
+	}
+
+	public void doPaint(Graphics g,Rect area) {
+		super.doPaint(g, area);
+		if (mm.gotoPos != null) {
+			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
+			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
+			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
+		}
+	}
+
+	public void chooseMap() {
+		CWPoint gpspos;
+		if (mm.myNavigation.gpsPos.Fix &gt; 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else gpspos = null;
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
+		if(l.execute() == FormBase.IDOK){
+//			Vm.debug(&quot;Trying map: &quot; + l.selectedMap.fileName);
+			mm.autoSelectMap = false;
+			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				mm.ignoreGps = false;
+			} else {
+				mm.setGpsStatus(MovingMap.noGPS);
+				mm.ignoreGps = true;
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); 
+				if (mm.currentMap.fileNameWFL.length() &gt; 0)
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+				//mm.posCircleX = 0; // place map to the upper left corner of windows
+				//mm.posCircleY = 0;
+				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+			}
+		}
+	}
+
+	/**
+	 *	Method to react to user.
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		if (which == mm.bottonImageChooseMap){
+			mapsMenu = new Menu();
+			mapsMenu.addItem(selectMapMI);
+			mapsMenu.addItem(changeMapDirMI);
+			if (!mm.noMapsAvailable) 
+			{
+				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
+				else mapsMenu.addItem(hideMapMI);
+			}
+
+			// automatic
+			highestResGpsDestMI.modifiers &amp;= ~MenuItem.Checked;
+			highestResolutionMI.modifiers &amp;= ~MenuItem.Checked;
+			keepManResolutionMI.modifiers &amp;= ~MenuItem.Checked;
+			switch (mm.mapChangeModus) {
+			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;   
+			}
+			mapsMenu.addItem(mapChangeModusMI);
+			mapsMenu.addItem(highestResGpsDestMI);
+			mapsMenu.addItem(highestResolutionMI);
+			mapsMenu.addItem(keepManResolutionMI);
+			// manuell
+			mapsMenu.addItem(mapChangeResMI);
+			mapsMenu.addItem(AllCachesResMI);
+			mapsMenu.addItem(moreDetailsMI);
+			mapsMenu.addItem(moreOverviewMI);
+			// move map to
+			mapsMenu.addItem(moveToMI);
+			if (mm.gotoPos != null) moveToDestMI.modifiers &amp;= ~MenuItem.Disabled;
+			else moveToDestMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToDestMI);
+			if (Global.getPref().curCentrePt.isValid()) moveToCenterMI.modifiers &amp;= ~MenuItem.Disabled;
+			else moveToCenterMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToCenterMI);
+			mapsMenu.addItem(moveToGpsMI);
+
+			//m.set(Menu., status)
+			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
+		}
+		if (which == mm.buttonImageGpsOn) {
+			this.snapToGps();
+		}
+		if (which == mm.buttonImageLens) {
+			mm.setZoomingMode();
+			lastZoomWidth = 0;
+			lastZoomHeight = 0;
+		}
+		if (which == mm.buttonImageZoom1to1) {
+			mm.zoom1to1(); 
+		}
+		if (which == mm.bottonImageClose) {
+			WindowEvent tmp = new WindowEvent();
+			tmp.type = WindowEvent.CLOSE;
+			mm.postEvent(tmp);
+		}
+	}
+
+	public void snapToGps() {
+		mm.myNavigation.startGps();
+		mm.SnapToGps();
+	}
+
+	public void penHeld(Point p){
+		//	if (!menuIsActive()) doMenu(p);
+		if (!mm.zoomingMode) { 
+			//( (ev.type == PenEvent.PEN_DOWN) &amp;&amp; ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
+			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---&gt; these events are not posted --&gt; this overridering is the only solution 
+			kontextMenu = new Menu();
+			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
+				kontextMenu.addItem(gotoMenuItem);
+				kontextMenu.addItem(newWayPointMenuItem);
+				AniImage clickedOnImage = images.findHotImage(p);
+				if (clickedOnImage != null &amp;&amp; clickedOnImage instanceof MapSymbol) {
+					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
+					if (clickedCache != null) openCacheDescMenuItem = new MenuItem(&quot;Open '&quot;+(clickedCache.CacheName.length()&gt;0?clickedCache.CacheName:clickedCache.wayPoint)+&quot;'$o&quot;); // clickedCache == null can happen if clicked on the goto-symbol
+					kontextMenu.addItem(openCacheDescMenuItem);
+					if (clickedCache !=null &amp;&amp; Global.mainForm.cacheListVisible) { 
+						addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,&quot;Add to cachetour&quot;));
+						kontextMenu.addItem(addCachetoListMenuItem);
+					}
+				}
+			}
+			else {			
+				miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+
+				for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+					kontextMenu.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+					else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+				}
+			}
+			kontextMenu.exec(this, new Point(p.x, p.y), this);
+		}
+	}
+
+	public void onEvent(Event ev){
+		if (mapsMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {mapsMenu.close(); mapsMenu = null;}
+		if (kontextMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {kontextMenu.close(); kontextMenu = null; }
+
+		if (ev instanceof MenuEvent) { 
+			if (ev.target == mapsMenu) {
+				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
+				if (ev.type == MenuEvent.SELECTED ) {
+					MenuItem action = (MenuItem) mapsMenu.getSelectedItem(); 
+					if (mapsMenu.getSelectedItem() != null) {
+						//maps
+						if (action == selectMapMI)	{ 
+							mapsMenu.close();
+							chooseMap();
+						}
+						if (action == changeMapDirMI)	{
+							mapsMenu.close();
+							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+&quot;maps&quot;);
+							fc.addMask(&quot;*.wfl&quot;);
+							fc.setTitle((String)MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
+							if(fc.execute() != FileChooser.IDCANCEL){
+								mm.loadMaps(fc.getChosen().toString(), mm.posCircleLat);
+								mm.forceMapLoad();
+							}
+						}
+						//dont show map
+						if (action == hideMapMI) {
+							mapsMenu.close();
+							mm.hideMap();
+						}
+						// show map
+						if (action == showMapMI) {
+							mapsMenu.close();
+							mm.showMap();
+						}
+						// map change modus
+						if (action == highestResGpsDestMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION_GPS_DEST);
+						}
+						if (action == highestResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
+						}
+						if (action == keepManResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+						}
+						// manually change map resolution
+						if (action == moreDetailsMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(false);
+						} 
+						if (action == moreOverviewMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(true);
+						}
+						if (action == AllCachesResMI) {
+							mapsMenu.close();
+							mm.loadMapForAllCaches();
+						}
+						// moveto position
+						if (action == moveToCenterMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(Global.getPref().curCentrePt, true);
+						}
+						if (action == moveToDestMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(new CWPoint(mm.gotoPos.lat, mm.gotoPos.lon), true);
+						}
+						if (action == moveToGpsMI) {
+							mapsMenu.close();
+							this.snapToGps();						
+						}
+
+					}
+				}
+			} // if (ev.target == mapsMenu)
+			if (ev.target == kontextMenu) {
+				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
+					if (action == gotoMenuItem) {
+						kontextMenu.close();
+						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+					}
+					if (action == openCacheDescMenuItem) {
+						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm;
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						MainTab mainT = Global.mainTab;
+						mainT.openDesciptionPanel(clickedCache);
+					}
+					if (action == newWayPointMenuItem) {
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm; 
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						CacheHolder newWP = new CacheHolder();
+						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
+						newWP.LatLon=newWP.pos.toString(); 
+						Global.mainTab.newWaypoint(newWP);
+					}
+					if (action == addCachetoListMenuItem) {
+						kontextMenu.close();
+						Global.mainForm.cacheList.addCache(clickedCache.wayPoint);
+					}
+					for (int i=0; i&lt;miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							kontextMenu.close();
+							mm.myNavigation.setLuminary(i);
+							mm.updateGps(mm.myNavigation.gpsPos.getFix());
+							miLuminary[i].modifiers |= MenuItem.Checked;
+						} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+					}
+				}
+			} // if (ev.target == kontextMenu)
+		} // if (ev instanceof ControlEvent ) 
+		super.onEvent(ev);
+	}
+}
+
+
+/**
+ *	Class to display maps to choose from
+ */
+class ListBox extends Form{
+	public MapInfoObject selectedMap = new MapInfoObject();
+	mButton cancelButton, okButton;
+	mList list = new mList(4,1,false);
+	public boolean selected = false;
+	Vector maps;
+
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+		this.title = &quot;Maps&quot;;
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		this.maps = maps;
+		MapInfoObject map;
+		ScrollBarPanel scb;
+		int oldmap = -1;
+		boolean curMapFound = false;
+		boolean[] inList = new boolean[maps.size()];
+		int row = -1;
+		if (curMap == null) curMapFound = true;
+		if (gotopos != null &amp;&amp; Gps != null) {
+			list.addItem(&quot;--- Karten von akt. Position und Ziel ---&quot;);
+			row++;
+			for(int i = 0; i&lt;maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if( map.inBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.inBound(gotopos) ) 
+				{
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound &amp;&amp; map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				} else inList[i] = false;
+			}
+		}
+		if (Gps != null) {
+			list.addItem(&quot;--- Karten der aktuellen Position ---&quot;);
+			row++;
+			for(int i = 0; i&lt;maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
+				{
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  &amp;&amp; map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		if (gotopos != null) {
+			list.addItem(&quot;--- Karten des Ziels ---&quot;);
+			row++;
+			for(int i = 0; i&lt;maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if(map.inBound(gotopos)) {
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  &amp;&amp; map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		list.addItem(&quot;--- andere Karten ---&quot;);
+		row++;
+		for(int i = 0; i&lt;maps.size();i++){
+			map = new MapInfoObject();
+			map = (MapInfoObject)maps.get(i);
+			if(!inList[i]) {
+				list.addItem(i + &quot;: &quot; + map.mapName);
+				row++;
+				if (!curMapFound  &amp;&amp; map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+			}
+		}
+		list.selectItem(oldmap, true);
+		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		cancelButton = new mButton(&quot;Cancel&quot;);
+		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
+		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton = new mButton(&quot;Select&quot;);
+		okButton.setHotKey(0, KeyEvent.getActionKey(true));
+		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton.takeFocus(0);
+	}
+	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
+		String testitem = new String();
+		int testitemnr;
+		for (int i=0; i&lt;list.countListItems(); i++) {
+			try { 
+				testitem = ((MenuItem)list.items.get(i)).label;
+				testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
+				if ( testitemnr == mapNr) return true;
+			} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain &quot;:&quot;
+			catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain &quot;:&quot;
+		}
+		return false;
+	}
+
+	public void mapSelected() {
+		try { 
+			selectedMap = null;
+			int mapNum = 0;
+			String it = new String();
+			it = list.getText();
+			if (it != &quot;&quot;){
+				it = it.substring(0,it.indexOf(':'));
+				mapNum = Convert.toInt(it);
+				//	Vm.debug(&quot;Kartennummer: &quot; + mapNum);
+				selectedMap = (MapInfoObject)maps.get(mapNum);
+				selected = true;
+				this.close(FormBase.IDOK);
+			}
+			else {
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+	}
+
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelButton){
+				selectedMap = null;
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+				mapSelected();
+			}
+		}
+		super.onEvent(ev);
+	}
+
+	public void  penDoubleClicked(Point where) {
+		mapSelected();
+	}
+}
+
+class ArrowsOnMap extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+
+	int minY;
+	Graphics draw;
+	private MapInfoObject map=null;
+
+	Color moveDirColor = new Color(255,0,0); // RED 
+	final static Color sunDirColor = new Color(255,255,0); // Yellow
+	//final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0,0,128); // dark blue
+	final static Color northDirColor = new Color(0,0,255); // Blue
+	Point[] sunDirArrow = null;
+	Point[] gotoDirArrow = null;
+	Point[] moveDirArrow = null;
+	Point[] northDirArrow = null;
+	
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public ArrowsOnMap(){
+		super();
+		newImage();
+		//	setDirections(90, 180, -90);
+	}
+
+	public void newImage() {
+		setImage(new Image(80,80), Color.White);
+		draw = new Graphics(image);
+	}
+	public void setMap(MapInfoObject m) {
+		map = m;
+		makeArrows();
+	}
+
+	public void setDirections(float gd, float sd, float md ) {
+		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) &gt; 1
+				|| java.lang.Math.abs(moveDir - md) &gt; 1)
+		{
+			//dirsChanged = false;
+			gotoDir = gd;
+			sunDir = sd;
+			moveDir = md;
+			makeArrows();
+		}
+	}
+
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+
+	public void doDraw(Graphics g,int options) {
+		if (map == null || g == null) return;
+		drawArrows(g);
+		return;
+/*		if (!dirsChanged) {
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 
+			return;
+		}
+		dirsChanged = false;
+		//super.doDraw(g, options);
+		draw.setColor(Color.White);
+		draw.fillRect(0, 0, location.width, location.height);
+		minY = Integer.MAX_VALUE;
+		drawArrows(draw);
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+*/	}
+
+	private void makeArrows(){
+			// draw only valid arrows
+			if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
+				if (moveDirArrow == null) moveDirArrow = new Point[2];
+				makeArrow(moveDirArrow, moveDir, 1.0f);
+			} else moveDirArrow = null;
+			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) {
+				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
+				makeArrow(gotoDirArrow, gotoDir, 1.0f);
+			} else gotoDirArrow = null;
+			if (sunDir &lt; 360 &amp;&amp; sunDir&gt; -360) {
+				if (sunDirArrow == null ) sunDirArrow = new Point[2];
+				makeArrow(sunDirArrow, sunDir, 0.75f);
+			} else sunDirArrow = null;
+			if (java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+				if (northDirArrow == null) northDirArrow = new Point[2];
+				makeArrow(northDirArrow, 0, 1.0f); // north direction
+			} else northDirArrow = null;
+			
+			//select moveDirColor according to difference to gotoDir
+			moveDirColor = new Color(255,0,0); // red
+			
+			if (moveDirArrow != null &amp;&amp; gotoDirArrow != null)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff &gt; 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff &gt; 180)
+				{
+					diff = 360.0f - diff;
+				}
+				
+				if (diff &lt;= 5.0)
+				{
+					moveDirColor = new Color(0,192,0);// darkgreen
+				}
+				else if (diff &lt;= 22.5)
+				{
+					moveDirColor = new Color(0,255,0);// green
+				}
+				else if (diff &lt;= 45.0)
+				{
+					moveDirColor = new Color(255,128,0);// orange
+				}
+			}
+		}
+
+	/**
+	 * make (calculate) Pixel array for a single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void makeArrow(Point[] arrow, float angle, float scale) {
+		if (map == null) return;
+
+		float angleRad;
+		int centerX = location.width/2, centerY = location.height/2;
+		if (arrow[0] == null) arrow[0] = new Point();
+		if (arrow[1] == null) arrow[1] = new Point();
+		arrow[0].x = centerX;
+		arrow[0].y = centerY;
+		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
+		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
+		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		//	g.drawLine(centerX,centerY,x,y);
+	}
+
+	public void drawArrows(Graphics g) {
+		drawArrow(g, northDirArrow, northDirColor);
+		drawArrow(g, gotoDirArrow, gotoDirColor);
+		drawArrow(g, moveDirArrow, moveDirColor);
+		drawArrow(g, sunDirArrow, sunDirColor);
+	}
+	
+	public void drawArrow(Graphics g, Point[] arrow, Color col) {
+		if (arrow == null) return;
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+	}
+}
+
+

Added: trunk/src/CacheWolf/navi/Navigate.java
===================================================================
--- trunk/src/CacheWolf/navi/Navigate.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Navigate.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,235 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Global;
+import CacheWolf.Preferences;
+import ewe.fx.Color;
+import ewe.io.IOException;
+import ewe.io.SerialPort;
+import ewe.io.SerialPortOptions;
+import ewe.net.Socket;
+import ewe.sys.Convert;
+import ewe.sys.mThread;
+import ewe.ui.MessageBox;
+import ewe.util.mString;
+
+public class Navigate {
+	public CWPoint destination = new CWPoint();
+	public CWGPSPoint gpsPos = new CWGPSPoint();
+	public Track curTrack = null;
+	Color trackColor = new Color(255,0,0); // red
+	public CWPoint skyOrientationDir = new CWPoint();
+	public int luminary = SkyOrientation.SUN;
+
+	public GotoPanel gotoPanel = null;
+	public MovingMap movingMap = null;
+	public SerialThread serThread = null;
+	public Preferences pref = Global.getPref();
+	public UpdateThread tickerThread;
+	public boolean gpsRunning = false;
+	boolean lograw = false;
+	int logIntervall = 10;
+
+	public void setGotoPanel(GotoPanel gp) {
+		gotoPanel = gp;
+	}
+	public void setMovingMap (MovingMap mm) {
+		movingMap = mm;
+		if (gpsRunning) mm.gpsStarted();
+	}
+
+	public void startGps() {
+		if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
+		try {
+			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : &quot;&quot;));
+			if (pref.forwardGPS &amp;&amp; !serThread.tcpForward) {
+				(new MessageBox(&quot;Warning&quot;, &quot;Ignoring error:\n could not forward GPS data to host:\n&quot;+pref.forwardGpsHost+&quot;\n&quot;+serThread.lastError+&quot;\nstop and start GPS to retry&quot;,MessageBox.OKB)).exec();
+			}
+			if (gpsPos.latDec == 0 &amp;&amp; gpsPos.lonDec == 0) { // TODO use isValid() // TODO raus damit?
+				gpsPos.latDec = destination.latDec; // setze Zielpunkt als Ausgangspunkt
+				gpsPos.lonDec = destination.lonDec;
+			}
+			serThread.start();
+			startDisplayTimer();
+			gpsRunning = true;
+			curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+			if (gotoPanel != null) gotoPanel.gpsStarted();
+			if (movingMap != null) movingMap.gpsStarted();
+		} catch (IOException e) {
+			(new MessageBox(&quot;Error&quot;, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot; + e.getMessage()+&quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;, MessageBox.OKB)).execute(); 
+		}
+	}
+
+	public void setRawLogging(boolean on, int intervall) {
+		lograw = on;
+		logIntervall = intervall; // TODO switch on and off during serthread running
+	}
+	public void startDisplayTimer() {
+		tickerThread = new UpdateThread(this, 1000);
+		tickerThread.start();
+	}
+
+	public void stopDisplayTimer(){
+		if (tickerThread != null) tickerThread.stop();
+	}
+
+	public void stopGps() {
+		serThread.stop();
+		stopDisplayTimer();
+		gpsPos.stopLog();
+		gpsRunning = false;
+		if (gotoPanel != null) gotoPanel.gpsStoped();
+		if (movingMap != null) movingMap.gpsStoped();
+	}
+
+	public boolean isGpsPosValid() {
+		return 	serThread != null &amp;&amp; serThread.isAlive() &amp;&amp; gpsPos.isValid() ; // &amp;&amp; gpsPos.getfiex();
+
+	}
+
+
+	public void setDestination(String LatLon) { 
+		setDestination(new CWPoint(LatLon));
+	}
+
+
+	public void setDestination(CWPoint d) {
+		destination = new CWPoint (d);
+		if (gotoPanel != null) gotoPanel.destChanged(destination);
+		if (movingMap != null) movingMap.destChanged(destination);
+	}
+	/**
+	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * @param lu
+	 */
+	public void setLuminary(int lu) {
+		luminary = lu;
+	}
+	public void ticked() {
+		int fix = gpsPos.getFix();
+		if (fix &gt; 0 &amp;&amp; (gpsPos.getSats()&gt;= 0)) {
+			//gpsPosition.printAll();
+			//Vm.debug(&quot;currTrack.add: voher&quot;);
+			if (curTrack == null) curTrack = new Track(trackColor);
+			try {
+				curTrack.add(gpsPos);
+			} catch (IndexOutOfBoundsException e) { // track full -&gt; create a new one
+				curTrack = new Track(trackColor); 
+				curTrack.add(gpsPos);
+				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
+			}
+			try {
+				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
+				double jd = SkyOrientation.utc2juliandate(gpsPos.Time, gpsPos.Date);
+				skyOrientationDir = SkyOrientation.getLuminaryDir(luminary, jd, gpsPos);
+				ewe.sys.Vm.debug(&quot;neu: &quot;+ skyOrientationDir.lonDec+ &quot;jd: &quot; + jd);
+			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf&#252;gbar wenn es einen Fix gibt)
+				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
+			}
+
+		} else {
+			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it		
+		}
+		gotoPanel.updateGps(fix);
+		if (movingMap != null) movingMap.updateGps(fix);
+	}
+}
+
+/**
+ * Thread for reading data from COM-port
+ *
+ */
+class SerialThread extends mThread{
+	SerialPort comSp;   
+	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	int comLength = 0;
+	CWGPSPoint myGPS;
+	boolean run, tcpForward;
+	Socket tcpConn;
+	String lastError = new String();
+
+	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
+		try{
+			comSp = new SerialPort(spo);
+		} catch (IOException e) {
+			throw new IOException(spo.portName);
+		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
+		if (forwardIP.length()&gt;0) { 
+			try {
+				tcpConn = new Socket(forwardIP, 23);
+				tcpForward = true;
+			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
+			}
+		}
+		myGPS = GPSPoint;
+	}
+
+	public void run() {
+		int noData = 0;
+		int notinterpreted = 0;
+		run = true;
+		while (run){
+			try {
+				sleep(1000);
+				//Vm.debug(&quot;Loop? &quot; + noData);
+				noData++;
+				if (noData &gt; 5) { myGPS.noDataError(); }
+			} catch (InterruptedException e) {}
+			if (comSp != null)	{
+				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
+				//Vm.debug(&quot;Length: &quot; + comBuff.length);
+				if (comLength &gt; 0)	{
+					noData = 0;
+					String str = mString.fromAscii(comBuff, 0, comLength); 
+					if (tcpForward) {
+						try {
+							tcpConn.write(comBuff, 0, comLength);
+						} catch (IOException e) { tcpForward = false; }
+					}
+					//Vm.debug(str);
+					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
+					if (notinterpreted &gt; 22) myGPS.noInterpretableData();
+				}
+			}
+		} // while
+		myGPS.noData();
+		tcpConn.close();
+	}
+
+	public void stop() {
+		run = false;
+		if (comSp != null) comSp.close();
+	}
+}
+
+/** 
+ * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
+ * Using the Vm.requestTimer-Method causes &quot;ewe.sys.EventDirectionException: This task cannot be done within 
+ * a Timer Tick.&quot; in the ewe-vm when form.close is called.  
+ */
+
+class UpdateThread extends mThread {
+	public boolean run;
+	public int calldelay;
+	public Navigate ticked;
+
+	public UpdateThread (Navigate gp, int cd) {
+		ticked = gp;
+		calldelay = cd;
+	}
+
+	public void run () {
+		run = true;
+		while (run) {
+			try { sleep (calldelay);} catch (InterruptedException e) {}
+			ticked.ticked();
+		}
+	}
+
+	public void stop() {
+		run = false;
+	}
+}
+

Added: trunk/src/CacheWolf/navi/SelectMap.java
===================================================================
--- trunk/src/CacheWolf/navi/SelectMap.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/SelectMap.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,90 @@
+package CacheWolf.navi;
+
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import utils.FileBugfix;
+import ewe.util.*;
+import ewe.io.*;
+import ewe.filechooser.*;
+import ewe.sys.*;
+import ewe.ui.*;
+
+/**
+*	This class displays a user interface to select maps that should be or are already calibrated
+*	class id = 4100
+*/
+public class SelectMap extends Form{
+	ScrollBarPanel top;
+	ScrollBarPanel bot;
+	mButton mBCancel, mBLoad;
+	Locale l = Vm.getLocale();
+	LocalResource lr = l.getLocalResource(&quot;cachewolf.Languages&quot;,true);
+	String mapsPath = new String();
+	mList nonCMaps = new mList(3,1,false);
+	mList CMaps = new mList(3,1,false);
+	String dateien[];
+	String selectedMap = new String();
+	public boolean worldfileexists = false;
+	
+	public SelectMap(){
+		mapsPath = Global.getPref().getMapManuallySavePath(false)+&quot;/&quot;; //  File.getProgramDirectory() + &quot;/maps/&quot;;
+		top = new ScrollBarPanel(CMaps);
+		bot = new ScrollBarPanel(nonCMaps);
+		this.title = (String)lr.get(4101,&quot;Maps&quot;);
+		this.addLast(new mLabel((String)lr.get(4102,&quot;Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(top, CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new mLabel((String)lr.get(4103,&quot;Non Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(bot, CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(mBCancel = new mButton((String)lr.get(4104,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(mBLoad = new mButton((String)lr.get(4105,&quot;Open&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		InfoBox inf = new InfoBox(&quot;Info&quot;, (String)lr.get(4109,&quot;Loading maps...&quot;)); 
+		inf.show();
+		try{
+			File files = new FileBugfix(mapsPath);
+			File checkWFL;
+			String rawFileName = new String();
+			dateien = files.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, File.LIST_FILES_ONLY);
+			for(int i = 0; i &lt; dateien.length;i++){
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf(&quot;.&quot;));
+				checkWFL = new File(mapsPath + rawFileName + &quot;.wfl&quot;);
+				
+				if(checkWFL.exists()){
+					CMaps.addItem(rawFileName);
+				} else {
+					nonCMaps.addItem(rawFileName);
+				}
+			}
+		}catch(Exception ex){
+			//Vm.debug(&quot;Problem retrieveing map files&quot;);
+		}
+		inf.close(0);
+	}
+	
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if(ev.target == mBCancel){
+				this.close(0);
+			}
+			if(ev.target == mBLoad){
+				this.close(0);
+			}
+		}
+		if(ev instanceof ListEvent &amp;&amp; ev.type == ListEvent.SELECTED){
+			if(ev.target == nonCMaps){
+				selectedMap = nonCMaps.getText();
+				CMaps.deleteSelection();
+				worldfileexists = false;
+			}
+			if(ev.target == CMaps){
+				selectedMap = CMaps.getText();
+				nonCMaps.deleteSelection();
+				worldfileexists = true;
+			}
+		}
+		super.onEvent(ev);
+	}
+	
+	public String getSelectedMap(){
+		return selectedMap;
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/SkyOrientation.java
===================================================================
--- trunk/src/CacheWolf/navi/SkyOrientation.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/SkyOrientation.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,354 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.MyLocale;
+import ewe.sys.Convert;
+
+/** Class to caculate positions of luminaries
+ * all methods are static
+ * usage:
+ * call utc2juliandate and then getLuminaryDir
+ * in ressources/cachewolf.languages messege numbers from 6100
+ * 
+ * @author Pfeffer
+ *
+ */
+public class SkyOrientation {
+
+	public final static int SUN = 0;
+	public final static int MOON = 1;
+	public static final int ALIOTH = 2; // brightest star in Grater Bear (Grosser Wagen) Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36&quot;
+	public static final int GREATER_BEAR = ALIOTH;
+	public static final int ALNILAM = 3; //Orion = Alnilam = mittlerer Guertelstern Aequinoktium 2000): Rektaszension 5h36m13s; Deklination -1 Grad 12'7&quot;
+	public static final int ORION = ALNILAM; 
+	public static final int CASSIOPEIA_GAMMA = 4; // Kassiopeia Gamma: 00h 56m 42.50s	+60 Grad 43' 00.3&quot;
+	public static final int CASSIOPEIA = CASSIOPEIA_GAMMA;
+	public static final int DENEB = 5;
+	public static final int CYGNUS = DENEB; // Cygnus = Schwan
+	public static final int MIMOSA = 6; // second brightest star in Southern Cross
+	public static final int SOUTHERN_CROSS = MIMOSA; // SOUTHERN_CROSS = Kreus des S&#252;dens = Crux australia
+	
+	public static final CWPoint[] STARS = {
+		// (Deklination, Rektaszension)
+		/*ALIOTH*/		new CWPoint(55. +57./60. + 36./3600., (12. + 54./60. + 2./3600.)*15.), // ALIOTH: Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36&quot;
+		/*ALNILAM*/		new CWPoint(-1. -12./60. -7./3600., (5.+36./60. + 13./3600.)*15.), // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) &lt;- wikipedia // -1.19748, 5.60978 * 15.) &lt;- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  &lt;- Stellarium 
+		/*Cassiopeia*/	new CWPoint(60. + 43./60. + 0.3/3600., (0 + 56./60. +42.5/3600.)*15.), // CASSIOPALA_GAMMA 00h 56m 42.50s, 60 Grad 43' 00.3&quot; &lt;-- wikipedia, Stellarium: 57m 11s, 60 Grad 45' 29&quot;
+		/*Deneb*/		new CWPoint(45. + 16./60. + 49.2/3600., (20 + 41./60. +25.6/3600.)*15.), // im Schwan (Sommerdreieck) Quelle: Stellarium
+		/*Mimosa*/		new CWPoint(-59. - 41./60. - 19./3600., (12 + 47./60. +43.2/3600.)*15.) // im Schwan (Sommerdreieck) Quelle: Stellarium
+		// Sirius
+	};
+	
+	public static String [] LUMINARY_NAMES = { // TODO MyLocale.getMsg(xxx, &quot;Sun&quot;),
+		MyLocale.getMsg(6100, &quot;Sun&quot;), 
+		MyLocale.getMsg(6101, &quot;Moon&quot;), 
+		MyLocale.getMsg(6102, &quot;Grater Bear&quot;),
+		MyLocale.getMsg(6103, &quot;Orion&quot;),
+		MyLocale.getMsg(6104, &quot;Cassiopeia&quot;), 
+		MyLocale.getMsg(6105, &quot;Cygnus&quot;),
+		MyLocale.getMsg(6106, &quot;Southern Cross&quot;)
+	};
+
+	public static String [] LUMINARY_DESC = { // TODO MyLocale.getMsg(xxx, &quot;Sun&quot;),
+		MyLocale.getMsg(6100, &quot;Sun&quot;), 
+		MyLocale.getMsg(6101, &quot;Moon&quot;), 
+		MyLocale.getMsg(6122, &quot;Alioth in Greater Bear&quot;),
+		MyLocale.getMsg(6123, &quot;Alnilam in Orion&quot;),
+		MyLocale.getMsg(6124, &quot;Cassiopeia Gamma&quot;), 
+		MyLocale.getMsg(6125, &quot;Deneb in Cygnus&quot;),
+		MyLocale.getMsg(6126, &quot;Becrux in Southern Cross&quot;)
+	};
+
+	/**
+	 * Get the friendly name of the luminary
+	 * @param luminary
+	 * @return
+	 */
+	public static String getLuminaryName(int luminary) {
+		return LUMINARY_NAMES[luminary]; 
+	}
+	
+	/**
+	 * Get a more exact description of the luminary 
+	 * @param lu
+	 * @return
+	 */
+	public static String getLuminaryDesc(int lu) {
+		return LUMINARY_DESC[lu];
+	}
+
+	/**
+	 * get azimuth from north and elevation for horizont for a given 
+	 * Luminary (planet or star) 
+	 * @param luminary one of SUN, MOON, ALIOTH, GRAETER_BEAR, ALNILAM, ORION, CASSIOPEIA_GAMMA, CASSIOPEIA
+	 * @param jd julian date must be calculated in advance e.g. from utc2julian
+	 * @param onEarth place on earth of the observer
+	 * @return lon = azimuth from north, lat = elevation from horizont
+	 */
+	public static CWPoint getLuminaryDir(int luminary, double jd, CWPoint onEarth) {
+		switch (luminary) {
+		case SUN: return getSunDir(jd, onEarth);
+		case MOON: return getMoonDir(jd, onEarth);
+		default: 
+			return equatorial2AzimutCoos(onEarth, jd, STARS[luminary-MOON-1]);
+		}
+	}
+
+	/**
+	 * @param utc in the format as it comes from gps DDMMYY
+	 * @param datum in the format as it comes from gps HHMMSS
+	 * @return juliandate
+	 * @throws NumberFormatException if utc / datum could not be parsed successfully
+	 */
+	public static double utc2juliandate(String utc, String datum) {
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag     = Convert.parseInt(datum.substring(0, 2));
+			monat   = Convert.parseInt(datum.substring(2, 4));
+			jahr    = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde  = Convert.parseInt(utc.substring(0, 2));
+			minute  = Convert.parseInt(utc.substring(2, 4));
+			sekunde = Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
+			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			return jd;
+			//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird au&#223;erdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	/**
+	 * old version, gives the same as the new one
+	 * @param utc
+	 * @param datum
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
+		//	(new MessageBox(&quot;test&quot;, &quot;utc:&quot;+utc+&quot; datum: &quot;+datum+&quot;, lat: &quot;+lat+&quot;, len: &quot;+lon, MessageBox.OKB)).exec();
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag = Convert.parseInt(datum.substring(0, 2));
+			monat = Convert.parseInt(datum.substring(2, 4));
+			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde=Convert.parseInt(utc.substring(0, 2));
+			minute=Convert.parseInt(utc.substring(2, 4));
+			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
+			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+			// Ekliptikalkoordinaten der Sonne berechnen (see <A HREF="http://de.wikipedia.org/wiki/Sonnenstand">http://de.wikipedia.org/wiki/Sonnenstand</A> )
+			double n = jd - 2451545.0;
+			double l = 280.46 + 0.9856474 * n;
+			double g = 357.528 + 0.9856003 * n;
+			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+			// Rektaszension alpha und Deklination delta der Sonne berechnen
+			double e = 23.439 -0.0000004 * n;
+			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
+			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
+			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
+			if (alphaNenner&lt;0) {alpha +=180;}
+			// Azimut
+			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60. + (double)sekunde/3600.);
+			double theta = thetaHG * 15. + lon;
+			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
+			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
+			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
+					azimutNenner);
+			azimut = (float) (azimut * 180f / java.lang.Math.PI);
+			if (azimutNenner&lt;0) azimut +=180.;
+			// null = Sueden auf Null = Norden umrechnen
+			azimut +=180.;
+			if (azimut &gt;360.) azimut -=360.;
+			ewe.sys.Vm.debug(&quot;sunAzimut1: &quot; + azimut);
+			ewe.sys.Vm.debug(&quot;sun Elevation: &quot; +getSunAzimut2 (utc, datum, lat, lon).latDec);
+			CWPoint MoonDir = getMoonDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug(&quot;Moon Elevation: &quot; + MoonDir.latDec + &quot;Moon Azimut: &quot; + MoonDir.lonDec);
+			CWPoint OrionDir = getAlnilamDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug(&quot;Alnilam (Orion) Elevation: &quot; + OrionDir.latDec + &quot;Alnilam (Orion) Azimut: &quot; + OrionDir.lonDec );
+			
+			return azimut;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird ausserdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	public static CWPoint getSunAzimut2 (String utc, String datum, double lat, double lon) {
+		double jd = utc2juliandate(utc, datum);
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(new CWPoint(lat, lon), jd, eclCoos);
+	}
+
+	public static CWPoint getSunDir (double jd, CWPoint onEarth) {
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoos);
+	}
+
+	public static CWPoint getMoonDir(double jd, CWPoint onEarth) {
+		CWPoint eclCoo = getMoonEclipticCoos(jd);
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoo);
+	}
+
+	public static CWPoint getAlnilamDir(double jd, CWPoint onEarth) {
+		// Koordinaten Alnilam (mittlerer Guertelstern des Orion), Rektaszension 5h36m13s; Deklination -1&#176;12'7 TODO Aequinoktium 2000
+		// Source: wikipedia
+		return equatorial2AzimutCoos(onEarth, jd, new CWPoint(-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) ); // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) &lt;- wikipedia // -1.19748, 5.60978 * 15.) &lt;- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  &lt;- Stellarium
+	}
+
+	/**
+	 * get the ecliptic coordinates of the sun
+	 * @param juliandate
+	 * @return
+	 */
+	public static CWPoint getSunEclipticCoos(double juliandate) {
+		double n = juliandate - 2451545.0;
+		double l = 280.46 + 0.9856474 * n;
+		double g = 357.528 + 0.9856003 * n;
+		double lambda = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+		return new CWPoint(0, lambda);
+	}
+
+
+	// the following code is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A>
+	// ignores the time difference between juliandate and TDT, which is something like 1 minute
+	public static CWPoint getMoonEclipticCoos(double julianDate) {
+		final double DEG = Math.PI / 180;  
+		final double RAD = 1/DEG;
+		double sunAnomalyMean = 360*DEG/365.242191*(julianDate - 2447891.5) + 279.403303*DEG - 282.768422*DEG;
+		double D = julianDate-2447891.5;
+
+		// Mean Moon orbit elements as of 1990.0
+		double l0 = 318.351648*DEG;
+		double P0 =  36.340410*DEG;
+		double N0 = 318.510107*DEG;
+		double i  = 5.145396*DEG;
+
+		double l = 13.1763966*DEG*D+l0;
+		double MMoon = l-0.1114041*DEG*D-P0; // Moon's mean anomaly M
+		double N = N0-0.0529539*DEG*D;       // Moon's mean ascending node longitude
+
+		double sunlon = getSunEclipticCoos(julianDate).lonDec; 
+		double C = l-sunlon;
+		double Ev = 1.2739*DEG*Math.sin(2*C-MMoon);
+		double Ae = 0.1858*DEG*Math.sin(sunAnomalyMean);
+		double A3 = 0.37*DEG*Math.sin(sunAnomalyMean);
+
+		double MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
+		double Ec = 6.2886*DEG*Math.sin(MMoon2);  // equation of centre
+		double A4 = 0.214*DEG*Math.sin(2*MMoon2);
+		double l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
+		double V = 0.6583*DEG*Math.sin(2*(l2-sunlon));
+
+		double l3 = l2+V; // true orbital longitude;
+		double N2 = N-0.16*DEG*Math.sin(sunAnomalyMean);
+
+		CWPoint moonCoor = new CWPoint();  
+		moonCoor.lonDec = (( N2 + Math.atan2( Math.sin(l3-N2)*Math.cos(i), Math.cos(l3-N2) ) ) * RAD)% 360;
+		moonCoor.latDec = Math.asin( Math.sin(l3-N2)*Math.sin(i) ) * RAD;
+		//moonCoor.orbitLon = l3;
+		return moonCoor;
+
+		/*
+		double e  = 0.054900;
+		double a  = 384401; // km
+		double diameter0 = 0.5181*DEG; // angular diameter of Moon at a distance
+		double parallax0 = 0.9507*DEG; // parallax at distance a
+
+		  // relative distance to semi mayor axis of lunar oribt
+		  moonCoor.distance = (1-sqr(e)) / (1+e*Math.cos(MMoon2+Ec) );
+		  moonCoor.diameter = diameter0/moonCoor.distance; // angular diameter in radians
+		  moonCoor.parallax = parallax0/moonCoor.distance; // horizontal parallax in radians
+		  moonCoor.distance *= a;	// distance in km
+
+		  // Age of Moon in radians since New Moon (0) - Full Moon (pi)
+		  moonCoor.moonAge = Mod2Pi(l3-sunCoor.lon);   
+		  moonCoor.phase   = 0.5*(1-Math.cos(moonCoor.moonAge)); // Moon phase, 0-1
+
+		  var phases = new Array(&quot;Neumond&quot;, &quot;Zunehmende Sichel&quot;, &quot;Erstes Viertel&quot;, &quot;Zunnehmender Mond&quot;, 
+		  	&quot;Vollmond&quot;, &quot;Abnehmender Mond&quot;, &quot;Letztes Viertel&quot;, &quot;Abnehmende Sichel&quot;, &quot;Neumond&quot;);
+		  var mainPhase = 1./29.53*360*DEG; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
+		  var p = Mod(moonCoor.moonAge, 90.*DEG);
+		  if (p &lt; mainPhase || p &gt; 90*DEG-mainPhase) p = 2*Math.round(moonCoor.moonAge / (90.*DEG));
+		  else p = 2*Math.floor(moonCoor.moonAge / (90.*DEG))+1;
+		  moonCoor.moonPhase = phases[p];
+
+		  moonCoor.sign = Sign(moonCoor.lon);
+		  return (float) moonCoor.lonDec;
+		return 0;
+	}
+		 */
+	}
+
+	public static CWPoint ecliptic2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint ecliptic) {
+		CWPoint equat = ecliptic2Equatorial(ecliptic, julianDate);
+		return equatorial2AzimutCoos(onEarth, julianDate, equat);
+	}
+	/**
+	 * convert rektaszension alpha and deklination delta to azimuth / elevation
+	 * @param onEarth pos. on earth for which the azimut is wanted
+	 * @param julianDate
+	 * @param equatorial: lonDec = rektaszension (alpha), latDec = Deklination (delta)
+	 * @return lonDec: azimuth in degrees from north, lat: elevation in degrees from horizont
+	 * alogithism from wikipedia sonnenbahn
+	 */
+	public static CWPoint equatorial2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint equatorial) {
+		double stunde = ((julianDate + 0.5) % 1) * 24;
+		double jd0 = julianDate - stunde /24; // julian date at UTC 0:00
+		double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+		double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * stunde; // + (double)minute/60.);
+		double theta = thetaHG * 15. + onEarth.lonDec;
+		double tau = (theta - equatorial.lonDec ) /180*Math.PI;
+		double phi = onEarth.latDec/180*Math.PI;
+		double azimutNenner = Math.cos(tau)*Math.sin(phi)-
+		Math.tan(equatorial.latDec/180*Math.PI)*Math.cos(onEarth.latDec/180*java.lang.Math.PI);
+		float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-equatorial.lonDec)/180*Math.PI)/
+				azimutNenner);
+		azimut = (float) (azimut * 180f / java.lang.Math.PI);
+		if (azimutNenner&lt;0) azimut +=180.;
+		double h = 180 / Math.PI * Math.asin(Math.cos(equatorial.latDec/180*Math.PI) * Math.cos(tau)*Math.cos(phi) + Math.sin(equatorial.latDec/180 *Math.PI) * Math.sin(phi));
+		// null = Sueden auf Null = Norden umrechnen
+		azimut +=180.;
+		if (azimut &gt;360.) azimut -=360.;
+		return new CWPoint(h, azimut);
+	}
+
+	/**
+	 * convert from eliptical to equatorial coordinates
+	 * @param juliandate
+	 * @param eklipCoo ecliptic coos in degrees  
+	 * @return lon: Deklination (delta), lat: Rektaszension (alpha) in degree
+	 * this is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A> 
+	 */
+	public static CWPoint ecliptic2Equatorial(CWPoint eklipCoo, double juliandate) {
+		double T = (juliandate - 2451545.0)/36525.; // Epoch 2000 January 1.5
+		double eps = (23.+(26+21.45/60)/60 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600 ) / 180 * java.lang.Math.PI; // schiefe der Ekliptik
+		double coseps = Math.cos(eps);
+		double sineps = Math.sin(eps);
+
+		double sinlon = Math.sin(eklipCoo.lonDec / 180 * Math.PI);
+		CWPoint equatorial = new CWPoint();
+		equatorial.lonDec = (180 / Math.PI * Math.atan2( (sinlon*coseps-Math.tan(eklipCoo.latDec /180 * Math.PI)*sineps), Math.cos(eklipCoo.lonDec/180 * Math.PI) ) ) % 360; // rektaszension (alpha)
+		equatorial.latDec = 180 / Math.PI * Math.asin( Math.sin(eklipCoo.latDec/180 * Math.PI)*coseps + Math.cos(eklipCoo.latDec/180 * Math.PI)*sineps*sinlon ); // deklination (delta)
+
+		return equatorial;
+	}
+}
+

Added: trunk/src/CacheWolf/navi/Track.java
===================================================================
--- trunk/src/CacheWolf/navi/Track.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Track.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,56 @@
+package CacheWolf.navi;
+
+import ewe.fx.*;
+
+public class Track {
+	public Color trackColor;
+	public TrackPoint TrackPoints[];
+	public int num;
+	
+	public Track(Color f) {
+		trackColor = f;
+		TrackPoints = new TrackPoint[5000];
+		num = 0;
+	}
+/*===== add is currently not used	
+	public void add(double lat, double lon) {
+		TrackPoints[num] = new TrackPoint(lat, lon);
+		num++;
+	}
+=====*/	
+	/*
+	 * throws IndexOutOfBoundsException when track is full
+	 */
+	public void add(TrackPoint t) { 
+		if (TrackPoints == null || t == null) return;
+		TrackPoints[num] = new TrackPoint(t);
+		num++;
+	}
+/*===== loadTrack/saveTrack are currently not used
+	public void loadTrack(String filename){ // TODO untested!
+		byte [] all = ewe.sys.Vm.readResource(null,filename);
+		if (all == null) return; // TODO error handling
+		num = Utils.readInt(all, 0, 4);
+		for (int i=0; i&lt;=num; i++){
+			TrackPoints[i].latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
+			TrackPoints[i].lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+		}
+	}
+	
+	public void saveTrack(String filename){  // TODO untested!
+	//ByteArray ba=new ByteArray();
+	byte[] ba = new byte[8*2*num+4]; // 8 bytes is one double int has size 4
+	Utils.writeInt(num, ba, 0, 4);
+	for (int i=0; i&lt;=num; i++){
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].latDec), ba, (i*2)*8 + 4);
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].lonDec), ba, (i*2+1)*8 + 4);
+	}
+	try{
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(filename)));
+		outp.print(ba.toString());
+	}catch (IOException e) {
+		(new MessageBox(&quot;Error&quot;, &quot;Error reading trackfile:\n&quot;+e.toString(), MessageBox.OKB)).execute();}
+	}
+=====*/
+
+}

Added: trunk/src/CacheWolf/navi/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/navi/TrackOverlay.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/TrackOverlay.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,299 @@
+package CacheWolf.navi;
+
+//import java.awt.image.BufferedImage;
+
+import ewe.fx.Color;
+import ewe.fx.Graphics;
+import ewe.fx.IImage;
+import ewe.fx.Image;
+import ewe.fx.Pen;
+import ewe.graphics.AniImage;
+import ewe.sys.Convert;
+import ewe.fx.Point;
+import ewe.fx.Mask;
+
+import ewe.util.Vector;
+
+
+public class TrackOverlay extends MapImage {
+	public TrackPoint topLeft;
+	public TrackPoint bottomRight;
+	Graphics draw;
+	Graphics drawMask;
+	int test;
+	MapInfoObject trans; 
+	public Vector tracks;
+	boolean imageChangesDontShow = false;
+	public Point trackPixels[] = null;
+	public Color trackPixelsColor[] = null;
+	public int numPixels = 0;
+	final static int maxPixelsInCache = 100;
+	final static Color transparentColorForOverlay = Color.White; // only for use when transparent color is used
+	static boolean useTransparentColor;
+	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
+		super();
+		topLeft = new TrackPoint(topLefti);
+		trans = transi;
+		bottomRight = calcLatLonInImage(widthi, highti);
+		if (ewe.sys.Vm.getPlatform().equalsIgnoreCase(&quot;java&quot;)) {
+			useTransparentColor = true; 
+			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+		} else {
+			useTransparentColor = false; // // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
+			Image maski = new Image(widthi, highti);
+			drawMask = new Graphics(maski);
+			drawMask.setColor(Color.White);
+			drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
+			setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+			maski.free(); //setimage produces an inverted copy of the mask
+			maski = null;
+		}
+		//properties = AlwaysOnTop; // arrows are above, so dont set it.
+		draw = new Graphics(image);
+		draw.setDrawOp(Graphics.DRAW_OVER);
+		if (useTransparentColor) draw.setColor(transparentColorForOverlay);
+		else draw.setColor(Color.White);
+		draw.fillRect(0, 0, widthi, highti);
+		//int[] markImage = {0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};
+		//int[] markMaskOpaque = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+		//mask.setPixels( markMaskOpaque, 0, 50, 50, 2, 2, 0);
+		//draw.fillRectRGB(50, 50, 52, 52, 0x00ff0000); // fillRectRGB has a Bug - it never returns - use fillRect instead
+		//image.setPixels(markImage, 0, 50, 50, 2, 2, 0); // out of an to me unkwon reason this doesn't work here, but it does in painttracks
+	}
+	public void imageSet()
+//	==================================================================
+	{
+		IImage i = drawable;
+		if (i == null) i = image;
+		if (i != null){
+			location.width = i.getWidth();
+			location.height = i.getHeight();
+		}
+		if (image != null &amp;&amp; image != sourceImage) image.freeze();
+//		if (mask != null &amp;&amp; mask != sourceMask) mask.freeze(); // dont freeze the mask, it could change. Anyway momentanously it doesnt change, because when the image contains non-white in the opaque areas, it will be opaque without changing the mask
+		properties &amp;= ~HasChanged;
+	}
+
+
+	public void paintTracks() {
+	// for debugging TrackOverlayPositions
+	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
+	// draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
+		//draw.setColor(255,0,0);
+		//draw.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+		//draw.fillRect(50, 50, 4, 4); // fillRectRGB has a Bug - it never returns - use fillRect instead
+
+		if (tracks == null || tracks.size() == 0) return;
+		int tri, i;
+		Track tr;
+		for (tri=tracks.size()-1; tri &gt;= 0; tri--) {
+			tr = (Track)tracks.get(tri);
+			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+			draw.setColor(tr.trackColor);
+			if (tr.num &gt; 0) {
+				for (i=0; i &lt; tr.num; i++) {
+					paintPoint(tr.trackColor, tr.TrackPoints[i].latDec, tr.TrackPoints[i].lonDec);
+				}
+			}
+		}
+	}
+	
+
+	/**
+	 * 
+	 * @param f
+	 * @param lat
+	 * @param lon
+	 * @return true if point was on this overlay
+	 */
+	public boolean paintPoint(Color f, double lat, double lon){
+		if (lat&lt;bottomRight.latDec || lat &gt; topLeft.latDec || lon&lt;topLeft.lonDec || lon&gt;bottomRight.lonDec) return false;
+		//ewe.sys.Vm.debug(&quot;showlastaddedpoint, lat: &quot;+lat+&quot;   lon: &quot;+lon);
+		double b[] = new double[2];
+		int x, y;
+		b[0] = lat - topLeft.latDec; // see calcXYinImage (TrackPoint p) 
+		b[1] = lon - topLeft.lonDec; 
+		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
+		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
+		//draw.drawLine(x, y, x, y);
+		//ewe.sys.Vm.debug(&quot;showlastaddedpoint, x: &quot;+x+&quot;   y: &quot;+y+&quot;loc.x: &quot;+location.x+&quot;  loc.y:&quot;+location.y);
+		draw.fillRect(x-1, y-1, 3, 3);
+		//drawMask.fillRect(x-1, y-1, 3, 3);
+		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
+			int yd;
+			for  (int xd=-1; xd&lt;=1; xd++) {
+				for (yd=-1; yd&lt;=1; yd++) {
+					((BufferedImage)image.bufferedImage).setRGB(x+xd, y+yd, -65536);
+				}
+			} */
+		if (imageChangesDontShow) {
+			try {addPixelIfNeccessary(x, y, f); }
+			catch (IndexOutOfBoundsException e) // thrown when there are more than pixels stored than possible
+			{ fixate();  }
+		}
+		return true;
+	}
+
+	/**
+	 * this method forces ewe to transfer the drawn points
+	 * from _awtImage to bufferedImage, which is drawn to the screen
+	 *
+	 */
+	private void fixate() {
+		if (numPixels == 0) return;
+		//	draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		draw.drawImage(image, null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
+		imageChangesDontShow = false;
+		removeAllPixels();
+	}
+
+	private void removeAllPixels() {
+		numPixels = 0;
+		trackPixels = null;
+		trackPixelsColor = null;
+	}
+
+	public Point calcXYinImage (TrackPoint p) {
+		double b[] = new double[2]; // see method paintPoint it should actually call this method but it doesn't because of speed raesons
+		int x, y;
+		b[0] = p.latDec - topLeft.latDec;
+		b[1] = p.lonDec - topLeft.lonDec;
+		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
+		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
+		return new Point(x,y);
+	}
+
+	public TrackPoint calcLatLonInImage (double x, double y) {
+		// see trans.calcLatLon(p);
+		TrackPoint ll = new TrackPoint(); 
+		ll.latDec = (double)x * trans.affine[0] + (double)y * trans.affine[2] + topLeft.latDec;
+		ll.lonDec = (double)x * trans.affine[1] + (double)y * trans.affine[3] + topLeft.lonDec;
+		return ll;
+	}
+
+	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
+		if (trackPixels==null) { trackPixels = new Point[maxPixelsInCache]; trackPixelsColor = new Color[maxPixelsInCache]; } 
+		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
+		trackPixelsColor[numPixels] = f.getCopy();
+		numPixels++;
+	}
+
+	public void addPixelIfNeccessary(int x, int y, Color f){
+		if (trackPixels != null) {
+			int ll =(numPixels&lt;30 ? 0 : numPixels-30); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
+			for (int i=numPixels-1; i&gt;=ll; i--) {
+				if (trackPixels[i].x == x &amp;&amp; trackPixels[i].y == y &amp;&amp; f.equals(trackPixelsColor[i])) 
+				{ return; } 
+			}
+		}
+		addPixel(x, y, f);
+	}
+
+	public static final int FIXATE_IF_NO_PIXELS_NUM = 60;
+	private int notOnThisOverlaySince = 0;
+
+	public void paintLastAddedPoint(Track tr) { 
+		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+		draw.setColor(tr.trackColor);
+		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec)) notOnThisOverlaySince = 0;
+		else notOnThisOverlaySince++;
+		if (notOnThisOverlaySince &gt; FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f&#252;r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
+			fixate();
+			notOnThisOverlaySince = 0;
+		}
+
+	}
+
+	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
+		super.doDraw(g, options);
+		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
+		// draw trackpoints which were added after image changes don't show up on the screen
+		if (tracks == null || tracks.size() == 0) return;
+		int i;
+		for (i=0; i&lt;numPixels; i++) {
+			g.setColor(trackPixelsColor[i]);
+			g.fillRect(trackPixels[i].x-1, trackPixels[i].y-1, 3, 3);
+		}
+		//g.drawText(Convert.toString(test), 10, 10);
+		//g.drawRect(10 + test, 10, 10, 10);
+		//test++;
+	}
+}
+
+
+/* draw zeichnet auf _awtImage
+ * image.drawImage erzeugt bufferedImage, wenn es vorher null war 
+ * und kopiert den entsprechenden Teil in das &#252;bergebene Surface
+ * Das Problem ist, dass bufferedImage nicht mehr upgedatet wird, wenn
+ * es einmal erzugt wurde. Es wird nur dann upgedatet, wenn das Image ein anderes wird
+ * oder die Maske eine andere. Das Update erfolgt dann &#252;ber doDraw, was doCheckMask aufruft,
+ * das das eigentliche kopieren aus _awtImage vornimmt.
+ * 
+ *  Problem: das kopieren von _awtImage in BufferedImage ist sehr zeitaufw&#228;ndig, weil
+ *  es keine native Routine ist und jedes Pixel einzeln gepr&#252;ft wird.
+ *  Deswegen w&#228;re die beste L&#246;sung, wenn ich bufferedImage direkt updaten k&#246;nnte.
+ *  Aber bufferedImage ist privat, ich kann auch in abgeleiteten Klassen nicht drauf
+ *  zugreifen. 
+ *  
+ *  Zur Not w&#228;re auch denkbar, doDraw zu &#252;berschreiben, um bei jedem Aufruf alle 
+ *  Trackpoints neu zu zeichnen.
+ *  Work-Aorund: draw.drawImage(image,null,Color.Pink,0,0,1,1); bewirkt, dass awtImage ins
+ *  bufferedImage kopiert wird. Dabei wird die transparentColor (in mImage) nicht ge&#228;ndert
+ *  und beim Aufruf von doDraw wird wieder die urspr&#252;ngliche transparentColor verwendet
+ *  
+ */
+//was alles nicht funktioniert:
+//drawmask.setDrawOp(Graphics.DRAW_OVER);
+//drawmask.drawRect(x-1, y-1, 2, 2, 1);
+//this.setImage(image, mask);
+//n&#228;chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
+//image.rgb
+//draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
+//((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
+//image
+//((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats&#228;chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
+//int[] markPixels = new int[4];
+//for (int i = 0; i&lt;markPixels.length; i++) { markPixels[i] = -65536; }
+//image.transparent = null; hilft auhc nicht
+//image.mask = null;
+//image.bufferedImage = null;
+//image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
+//ewe.fx.mImage mark = new mImage();
+//Image mark = new Image(2,2);
+//new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
+//mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
+//image.bufferedImage = null; // this solves the problem
+//toCursor(null);
+//this.draw(draw);
+//image=(BufferedImage)this.toNativeImage(transparentColor);
+//(java.awt.Image.b)
+//image.bufferedImage=null;
+//draw.flush();
+//ewe.ui.PenEvent.refreshTip(draw.surface);
+//draw.setPixelRGB(x, y, -65536);
+//this.changed(); hilft auch nicht
+//this.refresh(); // hilft nicht :-(
+//lastDrawn.x = lastDrawn.x -10; hilft auch nicht
+//imageMayChange = true; // hilft auch nicht :-(
+
+/*
+ * In der ewe-VM f&#252;r PocketPC-ARM funktioniert die Festlegung einer 
+ * transparenten Farbe nicht (Hintergrund wird wei&#223; statt durchsichtig)
+ * deswegen (und weil in ewe-VM effizienter) Umstellung auf Transparenzmaske
+ * statt transparenter Farbe
+ * TODO Dies ist in Java-VM allerdings extrem Speicher fressend -&gt; evtl abfragen 
+static int fixMask(WObject image,WObject col,int isMask):
+	in Maske: 0 an durchsichtiger Stelle, sonst ff
+	in Image: ffffff an durchsichtiger Stelle
+
+	in java-VM
+	in Maske: ffffffff in image.mask, wenn nicht durchsichtig
+	          ff000000 an durchsichtiger Stelle
+	image.doCheckMask erzeugt ein Image mit 0 an den durchsichtigen Stellen, die dadurch definiert sind, dass im image 0xffffff und in (mask &amp; 0xffffff == 0) steht.
+ */
+/*
+ * this class is only needed to have a fast access to the list of pixels
+ * which are added but aniimage.draw will not lead to a change on the screen
+ * so that these pixels will be drawn seperately by doDraw
+ * 
+ */

Added: trunk/src/CacheWolf/navi/TrackPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/TrackPoint.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/TrackPoint.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,38 @@
+package CacheWolf.navi;
+
+import ewe.io.BufferedWriter;
+import ewe.io.FileWriter;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.ui.MessageBox;
+import ewe.util.Utils;
+
+/**
+ * this is not CWPoint because it should be as small as possible
+ * @author pfeffer
+ *
+ */
+
+public class TrackPoint  {
+	public double latDec;
+	public double lonDec;
+	
+	public TrackPoint(){
+		latDec = -91;
+		lonDec = -361;
+	}
+	
+	public TrackPoint(TrackPoint t) {
+		latDec = t.latDec;
+		lonDec = t.lonDec;
+	}
+	public TrackPoint(double lat, double lon) {
+		latDec = lat;
+		lonDec = lon;
+	}
+	public boolean equals(TrackPoint tp) {
+		return latDec == tp.latDec &amp;&amp; lonDec == tp.lonDec;
+	}
+
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000776.html">[Cachewolf-svn] r883 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="000778.html">[Cachewolf-svn] r885 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#777">[ date ]</a>
              <a href="thread.html#777">[ thread ]</a>
              <a href="subject.html#777">[ subject ]</a>
              <a href="author.html#777">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
