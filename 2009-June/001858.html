<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1939 - trunk/src/exp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1939%20-%20trunk/src/exp&In-Reply-To=%3C200906232130.n5NLURG9003088%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001857.html">
   <LINK REL="Next"  HREF="001859.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1939 - trunk/src/exp</H1>
    <B>greiol at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1939%20-%20trunk/src/exp&In-Reply-To=%3C200906232130.n5NLURG9003088%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1939 - trunk/src/exp">greiol at mail.berlios.de
       </A><BR>
    <I>Tue Jun 23 23:30:27 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001857.html">[Cachewolf-svn] r1938 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="001859.html">[Cachewolf-svn] r1940 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1858">[ date ]</a>
              <a href="thread.html#1858">[ thread ]</a>
              <a href="subject.html#1858">[ subject ]</a>
              <a href="author.html#1858">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: greiol
Date: 2009-06-23 23:30:25 +0200 (Tue, 23 Jun 2009)
New Revision: 1939

Added:
   trunk/src/exp/GarminMap.java
Removed:
   trunk/src/exp/GpxExportNgForm.java
Modified:
   trunk/src/exp/GpxExportNg.java
Log:
added custom icons and validated output via validome.org

Added: trunk/src/exp/GarminMap.java
===================================================================
--- trunk/src/exp/GarminMap.java	2009-06-23 20:32:58 UTC (rev 1938)
+++ trunk/src/exp/GarminMap.java	2009-06-23 21:30:25 UTC (rev 1939)
@@ -0,0 +1,108 @@
+package exp;
+
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheSize;
+import CacheWolf.CacheTerrDiff;
+import CacheWolf.Global;
+import ewe.io.FileBase;
+import ewe.util.Vector;
+import ewesoft.xml.MinML;
+import ewesoft.xml.sax.AttributeList;
+
+/**
+ * This class implements user defined icons which depend on the cache type and the found status.
+ * See also <A HREF="http://www.geoclub.de/ftopic10413.html">http://www.geoclub.de/ftopic10413.html</A>
+ * @author salzkammergut
+ *
+ */
+class GarminMap extends MinML {
+
+	private Vector symbols=new Vector(24);
+
+	String lastName;
+	public void readGarminMap(){
+		try{
+			String datei = FileBase.getProgramDirectory() + &quot;/garminmap.xml&quot;;
+			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(datei));
+			parse(r);
+			r.close();
+		}catch(Exception e){
+			if (e instanceof NullPointerException)
+				Global.getPref().log(&quot;Error reading garminmap.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+			else
+				Global.getPref().log(&quot;Error reading garminmap.xml: &quot;, e);
+		}
+	}
+	public void startElement(String name, AttributeList atts){
+		lastName=name;
+		if (name.equals(&quot;icon&quot;)) {
+			symbols.add(new IconMap(atts.getValue(&quot;type&quot;),atts.getValue(&quot;name&quot;),atts.getValue(&quot;found&quot;),
+					atts.getValue(&quot;size&quot;),atts.getValue(&quot;terrain&quot;),atts.getValue(&quot;difficulty&quot;),
+					atts.getValue(&quot;status&quot;),atts.getValue(&quot;poiid&quot;)));
+		}
+	}
+
+	public String getIcon(CacheHolder ch) {
+		int mapSize=symbols.size();
+		// Try each icon in turn
+		for (int i=0; i&lt;mapSize; i++) {
+			IconMap icon=(IconMap) symbols.get(i);
+			boolean match=true;
+			// If a certain attribute is not null it must match the current caches values
+			match=match &amp;&amp; ((icon.type==null) || ch.getType()==0 || icon.type.equals(String.valueOf(ch.getType())));
+			match=match &amp;&amp; ((icon.size==null) || ch.getCacheSize()==0 || icon.size.equalsIgnoreCase(CacheSize.getExportShortId(ch.getCacheSize())));
+			match=match &amp;&amp; ((icon.terrain==null) || ch.getTerrain()==0 || icon.terrain.equals(CacheTerrDiff.shortDT(ch.getTerrain())));
+			match=match &amp;&amp; ((icon.difficulty==null) ||  ch.getHard()==0 || icon.difficulty.equals(CacheTerrDiff.shortDT(ch.getHard())));
+			match=match &amp;&amp; ((icon.status==null) ||  ch.getCacheStatus().startsWith(icon.status));
+			match=match &amp;&amp; ((icon.found==null) || ch.is_found());
+			if (match) return icon.name;
+		}
+
+		// If it is not a mapped type, just use the standard mapping
+		if (ch.is_found())
+			return &quot;Geocache Found&quot;;
+		else
+			return &quot;Geocache&quot;;
+	}
+	
+	public String getPoiId(CacheHolder ch) {
+		int mapSize=symbols.size();
+		// Try each icon in turn
+		for (int i=0; i&lt;mapSize; i++) {
+			IconMap icon=(IconMap) symbols.get(i);
+			boolean match=true;
+			// If a certain attribute is not null it must match the current caches values
+			match=match &amp;&amp; ((icon.type==null) || ch.getType()==0 || icon.type.equals(String.valueOf(ch.getType())));
+			match=match &amp;&amp; ((icon.size==null) || ch.getCacheSize()==0 || icon.size.equalsIgnoreCase(CacheSize.getExportShortId(ch.getCacheSize())));
+			match=match &amp;&amp; ((icon.terrain==null) || ch.getTerrain()==0 || icon.terrain.equals(CacheTerrDiff.shortDT(ch.getTerrain())));
+			match=match &amp;&amp; ((icon.difficulty==null) ||  ch.getHard()==0 || icon.difficulty.equals(CacheTerrDiff.shortDT(ch.getHard())));
+			match=match &amp;&amp; ((icon.status==null) ||  ch.getCacheStatus().startsWith(icon.status));
+			match=match &amp;&amp; ((icon.found==null) || ch.is_found());
+			if (match) return icon.poiId;
+		}
+		return null;
+	}
+
+	private class IconMap {
+		public String type;
+		public String name;
+		public String size;
+		public String terrain;
+		public String difficulty;
+		public String found;
+		public String status;
+		public String poiId;
+
+		IconMap(String type, String name, String found, String size, String terrain, String difficulty, String status, String poiId) {
+			this.type=type;
+			this.name=name;
+			this.found=found;
+			this.size=size;
+			this.terrain=terrain;
+			this.difficulty=difficulty;
+			this.status=status;
+			this.poiId = poiId;
+		}
+	}
+
+}

Modified: trunk/src/exp/GpxExportNg.java
===================================================================
--- trunk/src/exp/GpxExportNg.java	2009-06-23 20:32:58 UTC (rev 1938)
+++ trunk/src/exp/GpxExportNg.java	2009-06-23 21:30:25 UTC (rev 1939)
@@ -1,13 +1,15 @@
 package exp;
 
+import utils.FileBugfix;
+import CacheWolf.CWPoint;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheSize;
 import CacheWolf.CacheTerrDiff;
 import CacheWolf.CacheType;
 import CacheWolf.Global;
-import CacheWolf.CWPoint;
+import CacheWolf.Log;
 import CacheWolf.LogList;
-import CacheWolf.Log;
+import CacheWolf.SafeXML;
 
 import com.stevesoft.ewe_pat.Regex;
 import com.stevesoft.ewe_pat.Transformer;
@@ -16,23 +18,36 @@
 import ewe.filechooser.FileChooserBase;
 import ewe.io.BufferedWriter;
 import ewe.io.File;
+import ewe.io.FileBase;
 import ewe.io.FileWriter;
 import ewe.io.PrintWriter;
 import ewe.sys.Date;
+import ewe.sys.Handle;
 import ewe.sys.Vm;
+import ewe.ui.CheckBoxGroup;
+import ewe.ui.Control;
+import ewe.ui.ControlEvent;
+import ewe.ui.Event;
+import ewe.ui.Form;
 import ewe.ui.FormBase;
+import ewe.ui.ProgressBarForm;
+import ewe.ui.mButton;
+import ewe.ui.mCheckBox;
+import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Random;
 
 //TODO: use safexml a lot more (at least start using it ;) )
 
 /**
- * experimental GPX exporter that should better handle the various tasks that can be accomplished with GPX
- * it is not yet linked to any menu, so if you want to play around with it, first you have to create a menu item
- *
+ * experimental GPX exporter that should better handle the various tasks that
+ * can be accomplished with GPX it is not yet linked to any menu, so if you want
+ * to play around with it, first you have to create a menu item
+ * 
  */
 public class GpxExportNg {
-	
+
 	/** export is in compact format */
 	final static int GPX_COMPACT = 0;
 	/** export is PQ like */
@@ -40,134 +55,283 @@
 	/** export follows gc.com myfinds format */
 	final static int GPX_MYFINDSPQ = 2;
 
-	final static String expName=&quot;GpxExportNG&quot;;
-	final static String TRUE=&quot;True&quot;;
-	final static String FALSE=&quot;False&quot;;
-	
+	final static String expName = &quot;GpxExportNG&quot;;
+	final static String TRUE = &quot;True&quot;;
+	final static String FALSE = &quot;False&quot;;
+	private static GarminMap gm;
+
 	final static String GPXHEADER = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\n&quot;
-		.concat(&quot;&lt;gpx xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot; version=\&quot;1.0\&quot; creator=\&quot;CacheWolf <A HREF="http://www.cachewolf.de/\">http://www.cachewolf.de/\</A>&quot; xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> <A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> <A HREF="http://www.groundspeak.com/cache/1/0">http://www.groundspeak.com/cache/1/0</A> <A HREF="http://www.groundspeak.com/cache/1/0/cache.xsd\">http://www.groundspeak.com/cache/1/0/cache.xsd\</A>&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&gt;\n&quot;)
-		.concat(&quot;&lt;name&gt;Waypoints for Cache Listings, Generated by CacheWolf&lt;/name&gt;\n&quot;)
-		.concat(&quot;&lt;desc&gt;This is a list of waypoints for geocaches generated by CacheWolf&lt;/desc&gt;\n&quot;)
-		.concat(&quot;&lt;author&gt;Various users from geocaching.com and/or opencaching.de&lt;/author&gt;\n&quot;)
-		.concat(&quot;&lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">contact at cachewolf.de</A>&lt;/email&gt;\n&quot;)
-		.concat(&quot;&lt;url&gt;<A HREF="http://www.cachewolf.de/&lt;/url">http://www.cachewolf.de/&lt;/url</A>&gt;\n&quot;)
-		.concat(&quot;&lt;urlname&gt;CacheWolf - Paperless Geocaching&lt;/urlname&gt;\n&quot;)
-		.concat(&quot;&lt;time&gt;@@CREATEDATE@@T00:00:00Z&lt;/time&gt;\n&quot;)
-		.concat(&quot;&lt;keywords&gt;cache, geocache, waypoints&lt;/keywords&gt;\n&quot;)
-// TODO: is it worth a second loop?
-//		.concat(&quot;&lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot; maxlon=\&quot;6.918817\&quot; /&gt;&quot;)
-		;
-	
+			.concat(&quot;&lt;gpx xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot; version=\&quot;1.0\&quot; creator=\&quot;CacheWolf\&quot; xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> <A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> <A HREF="http://www.groundspeak.com/cache/1/0">http://www.groundspeak.com/cache/1/0</A> <A HREF="http://www.groundspeak.com/cache/1/0/cache.xsd\">http://www.groundspeak.com/cache/1/0/cache.xsd\</A>&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&gt;\n&quot;)
+			.concat(&quot;&lt;name&gt;Waypoints for Cache Listings, Generated by CacheWolf&lt;/name&gt;\n&quot;)
+			.concat(&quot;&lt;desc&gt;This is a list of waypoints for geocaches generated by CacheWolf&lt;/desc&gt;\n&quot;)
+			.concat(&quot;&lt;author&gt;Various users from geocaching.com and/or opencaching.de&lt;/author&gt;\n&quot;)
+			.concat(&quot;&lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">contact at cachewolf.de</A>&lt;/email&gt;\n&quot;)
+			.concat(&quot;&lt;url&gt;<A HREF="http://www.cachewolf.de/&lt;/url">http://www.cachewolf.de/&lt;/url</A>&gt;\n&quot;)
+			.concat(&quot;&lt;urlname&gt;CacheWolf - Paperless Geocaching&lt;/urlname&gt;\n&quot;)
+			.concat(&quot;&lt;time&gt;@@CREATEDATE@@T00:00:00Z&lt;/time&gt;\n&quot;)
+			.concat(&quot;&lt;keywords&gt;cache, geocache, waypoints&lt;/keywords&gt;\n&quot;)
+	// TODO: is it worth a second loop?
+	// .concat(&quot;&lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot; maxlon=\&quot;6.918817\&quot; /&gt;&quot;)
+			;
+
 	final static String GPXCOMPACT = &quot;\t&lt;wpt lat=\&quot;@@WPLAT@@\&quot; lon=\&quot;@@WPLON@@\&quot;&gt;\n&quot;
-						.concat(&quot;\t\t&lt;time&gt;@@CACHETIME@@T00:00:00&lt;/time&gt;\n&quot;)
-						.concat(&quot;\t\t&lt;name&gt;@@WPNAME@@&lt;/name&gt;\n&quot;)
-						.concat(&quot;\t\t&lt;cmt&gt;@@WPCMT@@&lt;/cmt&gt;\n&quot;)
-						.concat(&quot;\t\t&lt;desc&gt;@@WPDESC@@&lt;/desc&gt;\n&quot;)
-						.concat(&quot;\t\t&lt;url&gt;@@WPURL@@&lt;/url&gt;\n&quot;)
-						.concat(&quot;\t\t&lt;urlname&gt;@@WPURLNAME@@&lt;/urlname&gt;\n&quot;)
-						.concat(&quot;\t\t&lt;sym&gt;@@WPSYMBOL@@&lt;/sym&gt;\n&quot;)
-						.concat(&quot;\t\t&lt;type&gt;@@WPTYPE@@&lt;/type&gt;\n&quot;);
-	
-	final static String GPXEXTENSION =&quot;\t\t&lt;groundspeak:cache id=\&quot;@@CACHEID@@\&quot; available=\&quot;@@CACHEAVAILABLE@@\&quot; archived=\&quot;@@CACHEARCHIVED\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.geocaching.com/cache/1/0\">http://www.geocaching.com/cache/1/0\</A>&quot;&gt;\n&quot;
-						.concat(&quot;\t\t\t&lt;groundspeak:name&gt;@@CACHENAME@@&lt;/groundspeak:name&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:placed_by&gt;@@CACHEPLACEDBY@@&lt;groundspeak:placed_by&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:owner_id id=\&quot;@@CACHEOWNERID@@\&quot;&gt;@@CACHEOWNER@@&lt;/groundspeak:owner_id&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:type&gt;@@CACHETYPE@@&lt;/groundspeak:type&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:container&gt;@@CACHECONTAINER@@&lt;/groundspeak:container&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:difficulty&gt;@@CACHEDIFFICULTY@@&lt;/groundspeak:difficulty&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:terrain&gt;@@CACHETERRAIN@@&lt;/groundspeak:terrain&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:country&gt;@@CACHECOUNTRY@@&lt;/groundspeak:country&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:state&gt;@@CACHESTATE@@&lt;/groundspeak:state&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:short_description html=\&quot;@@CACHEHTML@@\&quot;&gt;@@CACHESHORTDESCRIPTION@@&lt;/groundspeak:short_description&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:long_description html=\&quot;@@CACHEHTML@@\&quot;&gt;@@CACHELONGDESCRIPTION@@&lt;/groundspeak:long_description&gt;\n&quot;)
-						.concat(&quot;\t\t\t&lt;groundspeak:encoded_hints&gt;@@CACHEHINT@@&lt;/groundspeak:encoded_hints&gt;\n&quot;);
+			.concat(&quot;\t\t&lt;time&gt;@@CACHETIME@@T00:00:00&lt;/time&gt;\n&quot;)
+			.concat(&quot;\t\t&lt;name&gt;@@WPNAME@@&lt;/name&gt;\n&quot;)
+			.concat(&quot;\t\t&lt;cmt&gt;@@WPCMT@@&lt;/cmt&gt;\n&quot;)
+			.concat(&quot;\t\t&lt;desc&gt;@@WPDESC@@&lt;/desc&gt;\n&quot;)
+			.concat(&quot;\t\t&lt;url&gt;@@WPURL@@&lt;/url&gt;\n&quot;)
+			.concat(&quot;\t\t&lt;urlname&gt;@@WPURLNAME@@&lt;/urlname&gt;\n&quot;)
+			.concat(&quot;\t\t&lt;sym&gt;@@WPSYMBOL@@&lt;/sym&gt;\n&quot;)
+			.concat(&quot;\t\t&lt;type&gt;@@WPTYPE@@&lt;/type&gt;\n&quot;);
 
+	final static String GPXEXTENSION = &quot;\t\t&lt;groundspeak:cache id=\&quot;@@CACHEID@@\&quot; available=\&quot;@@CACHEAVAILABLE@@\&quot; archived=\&quot;@@CACHEARCHIVED\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;\n&quot;
+			.concat(&quot;\t\t\t&lt;groundspeak:name&gt;@@CACHENAME@@&lt;/groundspeak:name&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:placed_by&gt;@@CACHEPLACEDBY@@&lt;/groundspeak:placed_by&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:owner id=\&quot;@@CACHEOWNERID@@\&quot;&gt;@@CACHEOWNER@@&lt;/groundspeak:owner&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:type&gt;@@CACHETYPE@@&lt;/groundspeak:type&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:container&gt;@@CACHECONTAINER@@&lt;/groundspeak:container&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:difficulty&gt;@@CACHEDIFFICULTY@@&lt;/groundspeak:difficulty&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:terrain&gt;@@CACHETERRAIN@@&lt;/groundspeak:terrain&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:country&gt;@@CACHECOUNTRY@@&lt;/groundspeak:country&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:state&gt;@@CACHESTATE@@&lt;/groundspeak:state&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:short_description html=\&quot;@@CACHEHTML@@\&quot;&gt;@@CACHESHORTDESCRIPTION@@&lt;/groundspeak:short_description&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:long_description html=\&quot;@@CACHEHTML@@\&quot;&gt;@@CACHELONGDESCRIPTION@@&lt;/groundspeak:long_description&gt;\n&quot;)
+			.concat(&quot;\t\t\t&lt;groundspeak:encoded_hints&gt;@@CACHEHINT@@&lt;/groundspeak:encoded_hints&gt;\n&quot;);
+
 	final static String GPXLOG = &quot;\t\t\t\t&lt;groundspeak:log id=\&quot;@@LOGID@@\&quot;&gt;\n&quot;
-						.concat(&quot;\t\t\t\t\t&lt;groundspeak:date&gt;@@LOGDATE@@T00:00:00&lt;/groundspeak:date&gt;\n&quot;)
-						.concat(&quot;\t\t\t\t\t&lt;groundspeak:type&gt;@@LOGTYPE@@&lt;/groundspeak:type&gt;\n&quot;)
-						.concat(&quot;\t\t\t\t\t&lt;groundspeak:finder id=\&quot;@@LOGFINDERID@@\&quot;&gt;@@LOGFINDER@@&lt;/groundspeak:finder&gt;\n&quot;)
-						.concat(&quot;\t\t\t\t\t&lt;groundspeak:text encoded=\&quot;@@LOGENCODE@@\&quot;&gt;@@LOGTEXT@@&lt;/groundspeak:text&gt;\n&quot;)
-						.concat(&quot;\t\t\t\t&lt;/groundspeak:log&gt;\n&quot;);
-	
+			.concat(&quot;\t\t\t\t\t&lt;groundspeak:date&gt;@@LOGDATE@@T00:00:00&lt;/groundspeak:date&gt;\n&quot;)
+			.concat(&quot;\t\t\t\t\t&lt;groundspeak:type&gt;@@LOGTYPE@@&lt;/groundspeak:type&gt;\n&quot;)
+			.concat(&quot;\t\t\t\t\t&lt;groundspeak:finder id=\&quot;@@LOGFINDERID@@\&quot;&gt;@@LOGFINDER@@&lt;/groundspeak:finder&gt;\n&quot;)
+			.concat(&quot;\t\t\t\t\t&lt;groundspeak:text encoded=\&quot;@@LOGENCODE@@\&quot;&gt;@@LOGTEXT@@&lt;/groundspeak:text&gt;\n&quot;)
+			.concat(&quot;\t\t\t\t&lt;/groundspeak:log&gt;\n&quot;);
+
 	final static String GPXTB = &quot;\t\t\t\t&lt;groundspeak:travelbug id=\&quot;@@TBID@@\&quot; ref=\&quot;@@TBREF@@\&quot;&gt;\n&quot;
-						.concat(&quot;\t\t\t\t\t&lt;groundspeak:name&gt;@@TBNAME@@&lt;/groundspeak:name&gt;\n&quot;)
-						.concat(&quot;\t\t\t\t&lt;/groundspeak:travelbug&gt;\n&quot;);
-	
-	//FIXME: don't use this until GPX import can strip this off as well
+			.concat(&quot;\t\t\t\t\t&lt;groundspeak:name&gt;@@TBNAME@@&lt;/groundspeak:name&gt;\n&quot;)
+			.concat(&quot;\t\t\t\t&lt;/groundspeak:travelbug&gt;\n&quot;);
+
+	// FIXME: don't use this until GPX import can strip this off as well
 	final static String GPXADDIINMAIN = &quot;@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@&quot;
-						.concat(&quot;@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@&quot;)
-						.concat(&quot;@@ADDILONG@@@@ADDIDELIM@@&quot;);
-	
+			.concat(&quot;@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@&quot;)
+			.concat(&quot;@@ADDILONG@@@@ADDIDELIM@@&quot;);
+
 	static boolean smartIds;
 	static boolean customIcons;
 	static boolean separateFiles;
 	static boolean sendToGarmin;
 	static int outType;
-	
-	
-	
+
 	public GpxExportNg() {
 		GpxExportNgForm exportOptions;
 		int ret;
 
 		exportOptions = new GpxExportNgForm();
 		ret = exportOptions.execute();
-		
+
 		if (FormBase.IDCANCEL == ret) {
 			return;
 		}
-		
+
 		outType = exportOptions.getExportType();
 		smartIds = exportOptions.getSmartIds();
 		separateFiles = exportOptions.getSeparateFiles();
 		sendToGarmin = exportOptions.getSendToGarmin();
 		customIcons = exportOptions.getCustomIcons();
-		
+
 		if (separateFiles) {
-			final Hashtable fileHandles;
-			final String directoryName;
-			//TODO: get directory
-			//TODO: initialize files
-			//TODO: iterate through caches
-			//TODO: remove old files with prefix
-			//TODO: write new files
+			final Hashtable fileHandles = new Hashtable();
+			final String outDir;
+			final String tempDir;
+			final String baseDir = FileBase.getProgramDirectory();
+			final String prefix=&quot;GC-&quot;;
+			final FileChooser fc;
+			
+			if (sendToGarmin) { 
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,Global.getPref().getExportPath(expName+&quot;-GPI&quot;));
+			} else {
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,Global.getPref().getExportPath(expName+&quot;-POI&quot;));
+			}
+			
+			fc.setTitle(&quot;Select target directory:&quot;);
+			
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
+
+			outDir = fc.getChosenFile().getFullPath();
+			if (sendToGarmin) {
+				Global.getPref().setExportPath(expName+&quot;-GPI&quot;, outDir);
+			} else {
+				Global.getPref().setExportPath(expName+&quot;-POI&quot;, outDir);
+			}
+			
+			if ((new File(baseDir+&quot;/garminmap.xml&quot;)).exists()) {
+				gm=new GarminMap();
+				gm.readGarminMap();
+			} else {
+				//TODO: display warning
+				Global.getPref().log(&quot;unable to load garminmap.xml&quot;);
+				return;
+			}
+			
+			if (sendToGarmin) {
+				tempDir = baseDir+File.separator+this.getClass().toString(); //FIXME: get from dialog
+				new File(tempDir).mkdir();
+			} else {
+				tempDir = outDir;
+				String tmp[] = new FileBugfix(tempDir).list(prefix + &quot;*.gpx&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+				for (int i=0; i &lt; tmp.length;i++){
+					FileBugfix tmpFile = new FileBugfix(tempDir + tmp[i]);
+					tmpFile.delete();
+				}
+				tmp = new FileBugfix(tempDir).list(prefix + &quot;*.bmp&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+				for (int i=0; i &lt; tmp.length;i++){
+					FileBugfix tmpFile = new FileBugfix(tempDir + tmp[i]);
+					tmpFile.delete();
+				}
+			}
+
+			ProgressBarForm pbf = new ProgressBarForm();
+			try {
+				Handle h = new Handle();
+
+				int expCount = 0;
+				int totalCount = Global.getProfile().cacheDB.countVisible();
+				
+				pbf.showMainTask = false;
+				pbf.setTask(h, &quot;Exporting ...&quot;);
+				pbf.exec();
+				
+				for (int i = 0; i &lt; Global.getProfile().cacheDB.size(); i++) {
+					CacheHolder ch = Global.getProfile().cacheDB.get(i);
+					if (!ch.isVisible()) {
+						continue;
+					} else if (ch.is_incomplete()) {
+						Global.getPref().log(
+								&quot;skipping export of incomplete waypoint &quot;
+										+ ch.getWayPoint());
+					} else {
+						String poiId = gm.getPoiId(ch);
+						if (null == poiId) {
+							Global.getPref().log(&quot;unmatched POI ID for &quot;+ch.getWayPoint());
+						} else {
+							File outFile;
+							PrintWriter writer;
+							if (fileHandles.containsKey(poiId)) {
+								writer = (PrintWriter) fileHandles.get(poiId);
+							} else {
+								writer = new PrintWriter(new BufferedWriter(new FileWriter(new File(tempDir + File.separator + prefix+poiId+&quot;.gpx&quot;))));
+								fileHandles.put(poiId, writer);
+								writer.print(formatHeader());
+							}
+							writer.print(formatCache(ch));
+						}
+						
+					}
+					expCount++;
+					h.progress = (float) expCount / (float) totalCount;
+					h.changed();
+				}
+				
+				Enumeration keys = fileHandles.keys();
+				while (keys.hasMoreElements()) {
+					String key = (String) keys.nextElement();
+					PrintWriter writer = (PrintWriter) fileHandles.get(key);
+					writer.print(&quot;&lt;/gpx&gt;\n&quot;);
+					writer.close();
+				}
+				
+				if (sendToGarmin) {
+					String tmp[] = new FileBugfix(outDir).list(prefix + &quot;*.gpi&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+					for (int i=0; i &lt; tmp.length;i++){
+						FileBugfix tmpFile = new FileBugfix(tempDir + tmp[i]);
+						tmpFile.delete();
+					}				
+
+					// TODO: create GPI files
+					FileBugfix tmpdir = new FileBugfix(tempDir);
+					tmpdir.delete();
+				}
+				
+				pbf.exit(0);
+				
+				//TODO: connect with image and build garmin poi file
+			} catch (Exception e) {
+				e.printStackTrace();
+				pbf.exit(0);
+			}
 		} else {
+			if (customIcons) {
+				if ((new File(FileBase.getProgramDirectory()+&quot;/garminmap.xml&quot;)).exists()) {
+					gm=new GarminMap();
+					gm.readGarminMap();
+				} else {
+					customIcons = false;
+					Global.getPref().log(&quot;unable to load garminmap.xml&quot;);
+				}
+			}
 			final File file;
-			final FileChooser fc = new FileChooser(FileChooserBase.SAVE, Global.getPref().getExportPath(expName));
+			final FileChooser fc = new FileChooser(FileChooserBase.SAVE, 
+					Global.getPref().getExportPath(expName+&quot;-GPX&quot;));
+			
 			fc.setTitle(&quot;Select target GPX file:&quot;);
 			fc.addMask(&quot;*.gpx&quot;);
-			if(fc.execute() == FormBase.IDCANCEL) return;
 			
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
+
 			file = fc.getChosenFile();
-			Global.getPref().setExportPath(expName, file.getPath());
+			Global.getPref().setExportPath(expName+&quot;-GPX&quot;, file.getPath());
 
 			try {
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(file)));
+				ProgressBarForm pbf = new ProgressBarForm();
+				Handle h = new Handle();
+				PrintWriter outp = new PrintWriter(new BufferedWriter(
+						new FileWriter(file)));
+				int expCount = 0;
+				int totalCount = Global.getProfile().cacheDB.countVisible();
+
 				outp.print(formatHeader());
-				for(int i = 0; i&lt;Global.getProfile().cacheDB.size(); i++){
-					CacheHolder ch=Global.getProfile().cacheDB.get(i);
-					if (ch.is_incomplete()) {
-						Vm.debug(&quot;skipping incomplete waypoint &quot;+ch.getWayPoint());
+
+				pbf.showMainTask = false;
+				pbf.setTask(h, &quot;Exporting ...&quot;);
+				pbf.exec();
+
+				for (int i = 0; i &lt; Global.getProfile().cacheDB.size(); i++) {
+					CacheHolder ch = Global.getProfile().cacheDB.get(i);
+					if (!ch.isVisible()) {
 						continue;
+					} else if (ch.is_incomplete()) {
+						Global.getPref().log(
+								&quot;skipping export of incomplete waypoint &quot;
+										+ ch.getWayPoint());
+					} else {
+						outp.print(formatCache(ch));
 					}
-					outp.print(formatCache(ch));
+					expCount++;
+					h.progress = (float) expCount / (float) totalCount;
+					h.changed();
 				}
+
+				pbf.exit(0);
+
 				outp.print(&quot;&lt;/gpx&gt;\n&quot;);
 				outp.close();
 			} catch (Exception ex) {
-				if (Global.getPref().debug) Global.getPref().log(&quot;unable to write GPX output to &quot;+file.toString(), ex);
-				else Global.getPref().log(&quot;unable to write GPX output to &quot;+file.toString());
-				//TODO: give a message to the user
+				if (Global.getPref().debug)
+					Global.getPref().log(&quot;unable to write GPX output to &quot; + file.toString(),ex);
+				else
+					Global.getPref().log(&quot;unable to write GPX output to &quot; + file.toString());
+				// TODO: give a message to the user
 			}
 		}
 	}
-	
+
 	private String formatCache(CacheHolder ch) {
 		// no addis or custom in MyFindsPq - and of course only finds
-		if ((GPX_MYFINDSPQ == outType) &amp;&amp; 
-				((ch.getType() == CacheType.CW_TYPE_CUSTOM) || ch.isAddiWpt() || ! ch.is_found())) 
-				return &quot;&quot;;
+		if ((GPX_MYFINDSPQ == outType) &amp;&amp; ((ch.getType() == CacheType.CW_TYPE_CUSTOM) || ch.isAddiWpt() || !ch.is_found()))
+			return &quot;&quot;;
 		
+		if (!ch.pos.isValid()) return &quot;&quot;; 
+
 		StringBuffer ret = new StringBuffer();
 
 		ret.append(formatCompact(ch));
@@ -175,211 +339,231 @@
 		if (outType != GPX_COMPACT &amp;&amp; !(ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt())) {
 			ret.append(formatPqExtensions(ch));
 		}
+		
 		ret.append(&quot;\t&lt;/wpt&gt;\n&quot;);
+
 		return ret.toString();
 	}
-	
+
 	private String formatCompact(CacheHolder ch) {
+		
 		Transformer trans = new Transformer(true);
-		
-		trans.add(new Regex(&quot;@@WPLAT@@&quot;, 
-				((ch.pos.latDec &gt;= -90) &amp;&amp; (ch.pos.latDec &lt;= 90)?String.valueOf(ch.pos.latDec):&quot;&quot;)
-			));
-		
-		trans.add(new Regex(&quot;@@WPLON@@&quot;,
-				((ch.pos.lonDec &gt;= -180) &amp;&amp; (ch.pos.lonDec &lt;= 180)?String.valueOf(ch.pos.lonDec):&quot;&quot;)
-			));
-		
-		trans.add(new Regex(&quot;@@CACHETIME@@&quot;, ch.getDateHidden()));
-		
+
+		trans.add(new Regex(&quot;@@WPLAT@@&quot;, String.valueOf(ch.pos.latDec)));
+
+		trans.add(new Regex(&quot;@@WPLON@@&quot;, String.valueOf(ch.pos.lonDec)));
+
+		if (ch.isAddiWpt()) {
+			try {
+				trans.add(new Regex(&quot;@@CACHETIME@@&quot;, ch.mainCache.getDateHidden()));
+			} catch (Exception e) {
+				Global.getPref().log(ch.getWayPoint()+&quot; has no parent&quot;);
+				trans.add(new Regex(&quot;@@CACHETIME@@&quot;, &quot;1970-01-01&quot;));
+			}
+		} else if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
+			trans.add(new Regex(&quot;@@CACHETIME@@&quot;, &quot;1970-01-01&quot;));
+		} else {
+			trans.add(new Regex(&quot;@@CACHETIME@@&quot;, ch.getDateHidden()));
+		}
+
 		if (smartIds &amp;&amp; ch.getType() != CacheType.CW_TYPE_CUSTOM) {
 			if (ch.isAddiWpt()) {
-				trans.add(new Regex(&quot;@@WPNAME@@&quot;,ch.mainCache.getWayPoint()
-						.concat(&quot; &quot;)
-						.concat(ch.getWayPoint().substring(0,2))));
+				trans.add(new Regex(&quot;@@WPNAME@@&quot;, ch.mainCache.getWayPoint()
+						.concat(&quot; &quot;).concat(ch.getWayPoint().substring(0, 2))));
 			} else {
-				trans.add(new Regex(&quot;@@WPNAME@@&quot;,ch.getWayPoint()
+				trans.add(new Regex(&quot;@@WPNAME@@&quot;, ch.getWayPoint()
 						.concat(&quot; &quot;)
 						.concat(CacheType.getExportShortId(ch.getType()))
 						.concat(String.valueOf(ch.getTerrain()))
 						.concat(String.valueOf(ch.getHard()))
-						.concat(CacheSize.getExportShortId(ch.getCacheSize()))
-					));
+						.concat(CacheSize.getExportShortId(ch.getCacheSize()))));
 			}
 		} else {
-			trans.add(new Regex(&quot;@@WPNAME@@&quot;,ch.getWayPoint()));
+			trans.add(new Regex(&quot;@@WPNAME@@&quot;, ch.getWayPoint()));
 		}
-		
+
 		if (ch.isAddiWpt() || ch.getType() == CacheType.CW_TYPE_CUSTOM) {
-			trans.add(new Regex(&quot;@@WPCMT@@&quot;,ch.getFreshDetails().LongDescription));
+			trans.add(new Regex(&quot;@@WPCMT@@&quot;,
+					SafeXML.cleanGPX(ch.getFreshDetails().LongDescription)));
 		} else {
-			trans.add(new Regex(&quot;@@WPCMT@@&quot;,&quot;&quot;));
+			trans.add(new Regex(&quot;@@WPCMT@@&quot;, &quot;&quot;));
 		}
-		
+
 		if (ch.isAddiWpt()) {
-			trans.add(new Regex(&quot;@@WPDESC@@&quot;,ch.getCacheName()));
+			trans.add(new Regex(&quot;@@WPDESC@@&quot;, SafeXML.cleanGPX(ch.getCacheName())));
 		} else {
-			trans.add(new Regex(&quot;@@WPDESC@@&quot;,
-					ch.getCacheName()
+			trans.add(new Regex(&quot;@@WPDESC@@&quot;, SafeXML.cleanGPX(ch.getCacheName()
 					.concat(&quot; by &quot;)
 					.concat(ch.getCacheOwner())
 					.concat(&quot;, &quot;)
 					.concat(CacheType.cw2ExportString(ch.getType()))
-					.concat(&quot; (&quot;)
-					.concat(CacheTerrDiff.shortDT(ch.getHard()))
-					.concat(&quot;/&quot;)
-					.concat(CacheTerrDiff.shortDT(ch.getTerrain()))
-					.concat(&quot;)&quot;)
-				));
+					.concat(&quot; (&quot;).concat(CacheTerrDiff.shortDT(ch.getHard()))
+					.concat(&quot;/&quot;).concat(CacheTerrDiff.shortDT(ch.getTerrain()))
+					.concat(&quot;)&quot;))));
 		}
-		
+
 		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
-			trans.add(new Regex(&quot;@@WPURL@@&quot;,&quot;&quot;));
+			trans.add(new Regex(&quot;@@WPURL@@&quot;, &quot;&quot;));
 		} else {
 			if (ch.isAddiWpt()) {
-				//TODO: find out URL schema for additional waypoints
-				//TODO: check for OC caches
-				trans.add(new Regex(&quot;@@WPURL@@&quot;,&quot;<A HREF="http://www.geocaching.com/seek/wpt.aspx?wp=">http://www.geocaching.com/seek/wpt.aspx?wp=</A>&quot;.concat(ch.getWayPoint())));
+				// TODO: find out URL schema for additional waypoints
+				// TODO: check for OC caches
+				trans.add(new Regex(&quot;@@WPURL@@&quot;,
+						&quot;<A HREF="http://www.geocaching.com/seek/wpt.aspx?wp=">http://www.geocaching.com/seek/wpt.aspx?wp=</A>&quot;
+						.concat(ch.getWayPoint())));
 			} else {
-				//TODO: check for OC caches
-				trans.add(new Regex(&quot;@@WPURL@@&quot;,&quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;.concat(ch.getWayPoint())));
+				// TODO: check for OC caches
+				trans.add(new Regex(&quot;@@WPURL@@&quot;,
+						&quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;
+						.concat(ch.getWayPoint())));
 			}
 		}
-		
+
 		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
-			trans.add(new Regex(&quot;@@WPURLNAME@@&quot;,&quot;&quot;));
+			trans.add(new Regex(&quot;@@WPURLNAME@@&quot;, &quot;&quot;));
 		} else {
-			trans.add(new Regex(&quot;@@WPURLNAME@@&quot;,ch.getCacheName()));
+			trans.add(new Regex(&quot;@@WPURLNAME@@&quot;, SafeXML.cleanGPX(ch.getCacheName())));
 		}
-		
+
 		if (customIcons) {
-			//TODO: replace with SKGs custom symbol code
-			trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;,&quot;Geocache&quot;));
+			trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;, gm.getIcon(ch)));
 		} else {
 			if (ch.isAddiWpt()) {
-				trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;, CacheType.id2GpxString(ch.getType()).substring(CacheType.id2GpxString(ch.getType()).indexOf(&quot;|&quot;)+1)));
+				trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;, CacheType.id2GpxString(
+					ch.getType()).substring(CacheType.id2GpxString(ch.getType()).indexOf(&quot;|&quot;) + 1)
+					));
 			} else if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
 				trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;, &quot;Custom&quot;));
 			} else if (ch.is_found()) {
-				trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;,&quot;Geocache found&quot;));
+				trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;, &quot;Geocache found&quot;));
 			} else {
-				trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;,&quot;Geocache&quot;));
+				trans.add(new Regex(&quot;@@WPSYMBOL@@&quot;, &quot;Geocache&quot;));
 			}
 		}
-		
-		trans.add(new Regex(&quot;@@WPTYPE@@&quot;,CacheType.id2GpxString(ch.getType())));
-		
+
+		trans.add(new Regex(&quot;@@WPTYPE@@&quot;, CacheType.id2GpxString(ch.getType())));
+
 		return trans.replaceFirst(GPXCOMPACT);
 	}
-	
+
 	private String formatPqExtensions(CacheHolder ch) {
 		// no details pq details for addis or custom waypoints
-		if (ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt()) return &quot;&quot;;
-		
+		if (ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt())
+			return &quot;&quot;;
+
 		StringBuffer ret = new StringBuffer();
 		Transformer trans = new Transformer(true);
 		ch.getFreshDetails();
-		trans.add(new Regex(&quot;@@CACHEID@@&quot;,ch.GetCacheID()));
-		trans.add(new Regex(&quot;@@CACHEAVAILABLE@@&quot;,ch.is_available()?TRUE:FALSE));
-		trans.add(new Regex(&quot;@@CACHEARCHIVED&quot;,ch.is_archived()?TRUE:FALSE));
-		trans.add(new Regex(&quot;@@CACHENAME@@&quot;,ch.getCacheName()));
-		trans.add(new Regex(&quot;@@CACHEPLACEDBY@@&quot;,ch.getCacheOwner()));
-		trans.add(new Regex(&quot;@@CACHEOWNERID@@&quot;,&quot;31415&quot;));
-		trans.add(new Regex(&quot;@@CACHEOWNER@@&quot;,ch.getCacheOwner()));
-		trans.add(new Regex(&quot;@@CACHETYPE@@&quot;,CacheType.id2GpxString(ch.getType())));
-		trans.add(new Regex(&quot;@@CACHECONTAINER@@&quot;,CacheSize.cw2ExportString(ch.getCacheSize())));
-		trans.add(new Regex(&quot;@@CACHEDIFFICULTY@@&quot;,CacheTerrDiff.shortDT(ch.getHard())));
-		trans.add(new Regex(&quot;@@CACHETERRAIN@@&quot;,CacheTerrDiff.shortDT(ch.getTerrain())));
-		trans.add(new Regex(&quot;@@CACHECOUNTRY@@&quot;,ch.details.Country));
-		trans.add(new Regex(&quot;@@CACHESTATE@@&quot;,ch.details.State));
-		trans.add(new Regex(&quot;@@CACHEHTML@@&quot;,ch.is_HTML()?TRUE:FALSE));
-		trans.add(new Regex(&quot;@@CACHESHORTDESCRIPTION@@&quot;,&quot;CacheWolf can not provide Short description&quot;));
-		trans.add(new Regex(&quot;@@CACHELONGDESCRIPTION@@&quot;,formatLongDescription(ch)));
-		trans.add(new Regex(&quot;@@CACHEHINT@@&quot;,ch.details.Hints));
-		
+		trans.add(new Regex(&quot;@@CACHEID@@&quot;, ch.GetCacheID()));
+		trans.add(new Regex(&quot;@@CACHEAVAILABLE@@&quot;, ch.is_available() ? TRUE : FALSE));
+		trans.add(new Regex(&quot;@@CACHEARCHIVED&quot;, ch.is_archived() ? TRUE : FALSE));
+		trans.add(new Regex(&quot;@@CACHENAME@@&quot;, SafeXML.cleanGPX(ch.getCacheName())));
+		trans.add(new Regex(&quot;@@CACHEPLACEDBY@@&quot;, SafeXML.cleanGPX(ch.getCacheOwner())));
+		trans.add(new Regex(&quot;@@CACHEOWNERID@@&quot;, &quot;31415&quot;));
+		trans.add(new Regex(&quot;@@CACHEOWNER@@&quot;, SafeXML.cleanGPX(ch.getCacheOwner())));
+		trans.add(new Regex(&quot;@@CACHETYPE@@&quot;, CacheType.id2GpxString(ch.getType())));
+		trans.add(new Regex(&quot;@@CACHECONTAINER@@&quot;, CacheSize.cw2ExportString(ch.getCacheSize())));
+		trans.add(new Regex(&quot;@@CACHEDIFFICULTY@@&quot;, CacheTerrDiff.shortDT(ch.getHard())));
+		trans.add(new Regex(&quot;@@CACHETERRAIN@@&quot;, CacheTerrDiff.shortDT(ch.getTerrain())));
+		trans.add(new Regex(&quot;@@CACHECOUNTRY@@&quot;, SafeXML.cleanGPX(ch.details.Country)));
+		trans.add(new Regex(&quot;@@CACHESTATE@@&quot;, SafeXML.cleanGPX((ch.details.State))));
+		trans.add(new Regex(&quot;@@CACHEHTML@@&quot;, ch.is_HTML() ? TRUE : FALSE));
+		trans.add(new Regex(&quot;@@CACHESHORTDESCRIPTION@@&quot;,
+				&quot;CacheWolf can not provide a short description&quot;));
+		trans.add(new Regex(&quot;@@CACHELONGDESCRIPTION@@&quot;,
+				SafeXML.cleanGPX(formatLongDescription(ch))));
+		trans.add(new Regex(&quot;@@CACHEHINT@@&quot;, SafeXML.cleanGPX(ch.details.Hints)));
+
 		ret.append(trans.replaceAll(GPXEXTENSION));
-		
+
 		ret.append(&quot;\t\t\t&lt;groundspeak:logs&gt;\n&quot;);
 		ret.append(formatLogs(ch));
 		ret.append(&quot;\t\t\t&lt;/groundspeak:logs&gt;\n&quot;);
-		
-//		ret.append(&quot;\t\t\t&lt;groundspeak:travelbugs&gt;\n&quot;);
-//		ret.append(formatTbs(ch));
-//		ret.append(&quot;\t\t\t&lt;/groundspeak:travelbugs&gt;\n&quot;);
-		
+
+		// ret.append(&quot;\t\t\t&lt;groundspeak:travelbugs&gt;\n&quot;);
+		// ret.append(formatTbs(ch));
+		// ret.append(&quot;\t\t\t&lt;/groundspeak:travelbugs&gt;\n&quot;);
+
 		ret.append(&quot;\t\t&lt;/groundspeak:cache&gt;\n&quot;);
 		return ret.toString();
 	}
-	
+
 	public void doit() {
-		
+
 	}
-	
+
 	public String formatTbs(CacheHolder ch) {
 		Transformer trans = new Transformer(true);
 		return &quot;&quot;;
-//		return trans.replaceFirst(GPXTB);
+		// return trans.replaceFirst(GPXTB);
 	}
-	
+
 	public String formatLogs(CacheHolder ch) {
 		LogList logs = ch.getFreshDetails().CacheLogs;
 		StringBuffer ret = new StringBuffer();
-		if (0 == logs.size()) return &quot;&quot;;
+		
+		if (0 == logs.size())
+			return &quot;&quot;;
+		
 		for (int i = 0; i &lt; logs.size(); i++) {
 			Log log = logs.getLog(i);
-			if (outType == GPX_MYFINDSPQ &amp;&amp; !log.getLogger().equals(Global.getPref().myAlias)) continue;
+			
+			if (outType == GPX_MYFINDSPQ
+					&amp;&amp; !log.getLogger().equals(Global.getPref().myAlias))
+				continue;
+			
 			Transformer trans = new Transformer(true);
-			trans.add(new Regex(&quot;@@LOGID@@&quot;,&quot;&quot;));
-			trans.add(new Regex(&quot;@@LOGDATE@@&quot;,log.getDate()));
-			trans.add(new Regex(&quot;@@LOGTYPE@@&quot;,image2TypeText(log.getIcon())));
-			trans.add(new Regex(&quot;@@LOGFINDERID@@&quot;,&quot;&quot;));
-			trans.add(new Regex(&quot;@@LOGFINDER@@&quot;,log.getLogger()));
-			trans.add(new Regex(&quot;@@LOGENCODE@@&quot;,&quot;&quot;));
-			trans.add(new Regex(&quot;@@LOGTEXT@@&quot;,log.getMessage()));
+			trans.add(new Regex(&quot;@@LOGID@@&quot;, &quot;&quot;));
+			trans.add(new Regex(&quot;@@LOGDATE@@&quot;, log.getDate()));
+			trans.add(new Regex(&quot;@@LOGTYPE@@&quot;, image2TypeText(log.getIcon())));
+			trans.add(new Regex(&quot;@@LOGFINDERID@@&quot;, &quot;&quot;));
+			trans.add(new Regex(&quot;@@LOGFINDER@@&quot;, SafeXML.cleanGPX(log.getLogger())));
+			trans.add(new Regex(&quot;@@LOGENCODE@@&quot;, &quot;&quot;));
+			trans.add(new Regex(&quot;@@LOGTEXT@@&quot;, SafeXML.cleanGPX(log.getMessage())));
 			ret.append(trans.replaceAll(GPXLOG));
 		}
+		
 		return ret.toString();
 	}
-	
+
 	public String formatHeader() {
 		Transformer trans = new Transformer(true);
-		trans.add(new Regex(&quot;@@CREATEDATE@@&quot;,new Date().setFormat(&quot;yyyy-MM-dd&quot;).toString()));
+		trans.add(new Regex(&quot;@@CREATEDATE@@&quot;, new Date()
+				.setFormat(&quot;yyyy-MM-dd&quot;).toString()));
 		return trans.replaceFirst(GPXHEADER);
 	}
-	
+
 	public String formatLongDescription(CacheHolder ch) {
 		if (ch.isAddiWpt() || ch.getType() == CacheType.CW_TYPE_CUSTOM) {
 			return ch.details.LongDescription;
 		} else {
-
 			StringBuffer ret = new StringBuffer();
 			String delim = &quot;&quot;;
 			ret.append(ch.details.LongDescription);
 			if (ch.is_HTML()) {
-				delim=&quot;&lt;br /&gt;&quot;;
+				delim = &quot;&lt;br /&gt;&quot;;
 			} else {
-				delim=&quot;\n&quot;;
+				delim = &quot;\n&quot;;
 			}
-			//FIXME: format is not quite right yet
-			//FIXME: cut Addis off in GPXimporter otherwise people who use GPX to feed CacheWolf have them doubled
+			// FIXME: format is not quite right yet
+			// FIXME: cut Addis off in GPXimporter otherwise people who use GPX to feed CacheWolf have them doubled
 			if (ch.addiWpts.size() &gt; 0) {
-
 				if (ch.is_HTML()) {
-					ret.append(&quot;&lt;p&gt;Additional Waypoints&lt;/p&gt;&quot;);
+					ret.append(&quot;\n\n&lt;p&gt;Additional Waypoints&lt;/p&gt;&quot;);
 				} else {
-					ret.append(&quot;Additional Waypoints\n&quot;);
+					ret.append(&quot;\n\nAdditional Waypoints\n&quot;);
 				}
 
 				Iterator iter = ch.addiWpts.iterator();
 				while (iter.hasNext()) {
 					CacheHolder addi = (CacheHolder) iter.next();
 					Transformer trans = new Transformer(true);
-					trans.add(new Regex(&quot;@@ADDIID@@&quot;,addi.getWayPoint()));
-					trans.add(new Regex(&quot;@@ADDISHORT@@&quot;,addi.getCacheName()));
-					trans.add(new Regex(&quot;@@ADDIDELIM@@&quot;,delim));
-					trans.add(new Regex(&quot;@@ADDILAT@@&quot;,formatAddiLatLon(addi.pos)));
-					trans.add(new Regex(&quot;@@ADDILON@@&quot;,&quot;&quot;));
-					trans.add(new Regex(&quot;@@ADDILONG@@&quot;,addi.getFreshDetails().LongDescription));
+					trans.add(new Regex(&quot;@@ADDIID@@&quot;, addi.getWayPoint()));
+					trans.add(new Regex(&quot;@@ADDISHORT@@&quot;, addi.getCacheName()));
+					trans.add(new Regex(&quot;@@ADDIDELIM@@&quot;, delim));
+					trans.add(new Regex(&quot;@@ADDILAT@@&quot;, formatAddiLatLon(addi.pos)));
+					trans.add(new Regex(&quot;@@ADDILON@@&quot;, &quot;&quot;));
+					trans.add(new Regex(&quot;@@ADDILONG@@&quot;, addi.getFreshDetails().LongDescription));
 					ret.append(trans.replaceAll(GPXADDIINMAIN));
 				}
 				ret.append(delim).append(&quot;\n&quot;);
@@ -387,27 +571,42 @@
 			return ret.toString();
 		}
 	}
-	
-	public static String image2TypeText(String image){
-		if (image.equals(&quot;icon_smile.gif&quot;)) return &quot;Found it&quot;;
-		if (image.equals(&quot;icon_sad.gif&quot;)) return &quot;Didn't find it&quot;;
-		if (image.equals(&quot;icon_note.gif&quot;)) return &quot;Write note&quot;;
-		if (image.equals(&quot;icon_enabled.gif&quot;)) return &quot;Enable Listing&quot;;
-		if (image.equals(&quot;icon_disabled.gif&quot;)) return &quot;Temporarily Disable Listing&quot;;
-		if (image.equals(&quot;icon_camera.gif&quot;)) return &quot;Webcam Photo Taken&quot;;
-		if (image.equals(&quot;11.png&quot;)) return &quot;Webcam Photo Taken&quot;;
-		if (image.equals(&quot;icon_attended.gif&quot;)) return &quot;Attended&quot;;
-		if (image.equals(&quot;green.gif&quot;)) return &quot;Publish Listing&quot;;
-		if (image.equals(&quot;icon_rsvp.gif&quot;)) return &quot;Will Attend&quot;;
-		if (image.equals(&quot;big_smile.gif&quot;)) return &quot;Post Reviewer Note&quot;;
-		if (image.equals(&quot;traffic_cone.gif&quot;)) return &quot;Archive (show)&quot;;
-		if (image.equals(&quot;icon_maint.gif&quot;)) return &quot;Owner Maintenance&quot;;
-		if (image.equals(&quot;icon_needsmaint.gif&quot;)) return &quot;Needs Maintenance&quot;;
-		if (image.equals(&quot;coord_update.gif&quot;)) return &quot;Update Coordinates&quot;;
 
+	public static String image2TypeText(String image) {
+		if (image.equals(&quot;icon_smile.gif&quot;))
+			return &quot;Found it&quot;;
+		if (image.equals(&quot;icon_sad.gif&quot;))
+			return &quot;Didn't find it&quot;;
+		if (image.equals(&quot;icon_note.gif&quot;))
+			return &quot;Write note&quot;;
+		if (image.equals(&quot;icon_enabled.gif&quot;))
+			return &quot;Enable Listing&quot;;
+		if (image.equals(&quot;icon_disabled.gif&quot;))
+			return &quot;Temporarily Disable Listing&quot;;
+		if (image.equals(&quot;icon_camera.gif&quot;))
+			return &quot;Webcam Photo Taken&quot;;
+		if (image.equals(&quot;11.png&quot;))
+			return &quot;Webcam Photo Taken&quot;;
+		if (image.equals(&quot;icon_attended.gif&quot;))
+			return &quot;Attended&quot;;
+		if (image.equals(&quot;green.gif&quot;))
+			return &quot;Publish Listing&quot;;
+		if (image.equals(&quot;icon_rsvp.gif&quot;))
+			return &quot;Will Attend&quot;;
+		if (image.equals(&quot;big_smile.gif&quot;))
+			return &quot;Post Reviewer Note&quot;;
+		if (image.equals(&quot;traffic_cone.gif&quot;))
+			return &quot;Archive (show)&quot;;
+		if (image.equals(&quot;icon_maint.gif&quot;))
+			return &quot;Owner Maintenance&quot;;
+		if (image.equals(&quot;icon_needsmaint.gif&quot;))
+			return &quot;Needs Maintenance&quot;;
+		if (image.equals(&quot;coord_update.gif&quot;))
+			return &quot;Update Coordinates&quot;;
+
 		return image;
 	}
-	
+
 	private String formatAddiLatLon(CWPoint pos) {
 		if (pos.isValid()) {
 			return pos.toString();
@@ -415,4 +614,155 @@
 			return &quot;N/S  __ &#176; __ . ___ W/E ___ &#176; __ . ___&quot;;
 		}
 	}
+
+	/**
+	 * dialog to set the GPX exporter options
+	 */
+	private class GpxExportNgForm extends Form {
+		private CheckBoxGroup cbgExportType;
+		private mCheckBox cbCompact, cbPqLike, cbMyFinds, cbCustomIcons,
+				cbSeperateFiles, cbSendToGarmin, cbSmartId;
+		private mButton btnOk, btnCancel;
+
+		/**
+		 * set up the form / dialog
+		 */
+		public GpxExportNgForm() {
+			// TODO: get defaults from profile
+
+			this.setTitle(&quot;GPX Export&quot;);
+
+			cbgExportType = new CheckBoxGroup();
+
+			cbCompact = new mCheckBox(&quot;Compact&quot;);
+			cbCompact.setGroup(cbgExportType);
+
+			cbPqLike = new mCheckBox(&quot;PQ like&quot;);
+			cbPqLike.setGroup(cbgExportType);
+
+			cbMyFinds = new mCheckBox(&quot;MyFinds&quot;);
+			cbMyFinds.setGroup(cbgExportType);
+
+			cbgExportType.setText(&quot;Compact&quot;);
+
+			cbCustomIcons = new mCheckBox(&quot;custom icons&quot;);
+
+			cbSeperateFiles = new mCheckBox(&quot;one file per type&quot;);
+
+			cbSendToGarmin = new mCheckBox(&quot;send to Garmin GPSr&quot;);
+			cbSendToGarmin.modify(Control.Disabled, 0); // not yet
+
+			cbSmartId = new mCheckBox(&quot;use smart IDs&quot;);
+
+			btnOk = new mButton(&quot;OK&quot;);
+			btnCancel = new mButton(&quot;Cancel&quot;);
+
+			addNext(cbCustomIcons);
+			addLast(cbCompact);
+			addNext(cbSeperateFiles);
+			addLast(cbPqLike);
+			addNext(cbSendToGarmin);
+			addLast(cbMyFinds);
+			addLast(cbSmartId);
+
+			addButton(btnOk);
+			addButton(btnCancel);
+		}
+
+		/**
+		 * react to GUI events and toogle access to the checkboxes according to
+		 * radio button settings pass everything else to &lt;code&gt;super()&lt;/code&gt;
+		 */
+		public void onEvent(Event ev) {
+			if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+
+				if (ev.target == cbgExportType) {
+					if (cbgExportType.getSelected() == cbCompact) {
+						if (cbCustomIcons.change(0, Control.Disabled))
+							cbCustomIcons.repaint();
+						if (cbSeperateFiles.change(0, Control.Disabled))
+							cbSeperateFiles.repaint();
+						// if (cbSendToGarmin.change(0,Control.Disabled))
+						// cbSendToGarmin.repaint();
+						if (cbSmartId.change(0, Control.Disabled))
+							cbSmartId.repaint();
+					} else if (cbgExportType.getSelected() == cbPqLike) {
+						cbSeperateFiles.setState(false);
+						if (cbCustomIcons.change(0, Control.Disabled))
+							cbCustomIcons.repaint();
+						if (cbSeperateFiles.change(Control.Disabled, 0))
+							cbSeperateFiles.repaint();
+						// if (cbSendToGarmin.change(0,Control.Disabled))
+						// cbSendToGarmin.repaint();
+						if (cbSmartId.change(0, Control.Disabled))
+							cbSmartId.repaint();
+					} else if (cbgExportType.getSelected() == cbMyFinds) {
+						cbCustomIcons.setState(false);
+						cbSeperateFiles.setState(false);
+						cbSendToGarmin.setState(false);
+						cbSmartId.setState(false);
+						if (cbCustomIcons.change(Control.Disabled, 0))
+							cbCustomIcons.repaint();
+						if (cbSeperateFiles.change(Control.Disabled, 0))
+							cbSeperateFiles.repaint();
+						// if (cbSendToGarmin.change(Control.Disabled,0))
+						// cbSendToGarmin.repaint();
+						if (cbSmartId.change(Control.Disabled, 0))
+							cbSmartId.repaint();
+					}
+				} else if (ev.target == btnOk) {
+					close(1);
+				} else if (ev.target == btnCancel) {
+					close(-1);
+				}
+			}
+			super.onEvent(ev);
+		}
+
+		/**
+		 * get the export type the user selected
+		 * 
+		 * @return index of selected option in checkboxgroup
+		 * @see GpxExportNg
+		 */
+		public int getExportType() {
+			return cbgExportType.getSelectedIndex();
+		}
+
+		/**
+		 * check if the user wants smart IDs
+		 * 
+		 * @return true for smart IDs, false otherwise
+		 */
+		public boolean getSmartIds() {
+			return cbSmartId.state;
+		}
+
+		/**
+		 * check if user wants to send output straight to a Garmin GPSr
+		 * 
+		 * @return true for GPSr transfer, false otherwise
+		 */
+		public boolean getSendToGarmin() {
+			return cbSendToGarmin.state;
+		}
+
+		/**
+		 * check if user wants custom icons
+		 * 
+		 * @return true if user wants custom icons, false otherwise
+		 */
+		public boolean getCustomIcons() {
+			return cbCustomIcons.state;
+		}
+
+		/**
+		 * check if user wants separate files (POI loader)
+		 * 
+		 * @return true for separate files, false for single file
+		 */
+		public boolean getSeparateFiles() {
+			return cbSeperateFiles.state;
+		}
+	}
 }

Deleted: trunk/src/exp/GpxExportNgForm.java
===================================================================
--- trunk/src/exp/GpxExportNgForm.java	2009-06-23 20:32:58 UTC (rev 1938)
+++ trunk/src/exp/GpxExportNgForm.java	2009-06-23 21:30:25 UTC (rev 1939)
@@ -1,137 +0,0 @@
-package exp;
-
-import ewe.ui.*;
-
-/**
- * GUI for GpxExporterNg with checkboxes for the options 
- *
- */
-public class GpxExportNgForm extends Form {
-	private CheckBoxGroup cbgExportType;
-	private mCheckBox cbCompact, cbPqLike, cbMyFinds, cbCustomIcons, cbSeperateFiles, cbSendToGarmin, cbSmartId;
-	private mButton btnOk, btnCancel;
-	
-	/**
-	 * set up the form / dialog
-	 */
-	public GpxExportNgForm() {
-		//TODO: get defaults from profile
-		
-		this.setTitle(&quot;GPX Export&quot;);
-		
-		cbgExportType = new CheckBoxGroup();
-		
-		cbCompact = new mCheckBox(&quot;Compact&quot;);
-		cbCompact.setGroup(cbgExportType);
-		
-		cbPqLike = new mCheckBox(&quot;PQ like&quot;);
-		cbPqLike.setGroup(cbgExportType);
-		
-		cbMyFinds = new mCheckBox(&quot;MyFinds&quot;);
-		cbMyFinds.setGroup(cbgExportType);
-		
-		cbgExportType.setText(&quot;Compact&quot;);
-		
-		cbCustomIcons = new mCheckBox(&quot;custom icons&quot;);
-		
-		cbSeperateFiles = new mCheckBox(&quot;one file per type&quot;);
-				
-		cbSendToGarmin = new mCheckBox(&quot;send to Garmin GPSr&quot;);
-		cbSendToGarmin.modify(Control.Disabled, 0); // not yet
-		
-		cbSmartId = new mCheckBox(&quot;use smart IDs&quot;);
-		
-		btnOk = new mButton(&quot;OK&quot;);
-		btnCancel = new mButton(&quot;Cancel&quot;);
-		
-		addNext(cbCustomIcons);
-		addLast(cbCompact);
-		addNext(cbSeperateFiles);
-		addLast(cbPqLike);
-		addNext(cbSendToGarmin);
-		addLast(cbMyFinds);
-		addLast(cbSmartId);
-
-		addButton(btnOk);
-		addButton(btnCancel);
-	}
-	
-	/**
-	 * react to GUI events and toogle access to the checkboxes according to radio button settings
-	 * pass everything else to &lt;code&gt;super()&lt;/code&gt;
-	 */
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
-						
-			if (ev.target == cbgExportType) {
-				if (cbgExportType.getSelected() == cbCompact) {
-					if (cbCustomIcons.change(0,Control.Disabled)) cbCustomIcons.repaint();
-					if (cbSeperateFiles.change(0,Control.Disabled)) cbSeperateFiles.repaint();
-//					if (cbSendToGarmin.change(0,Control.Disabled)) cbSendToGarmin.repaint();
-					if (cbSmartId.change(0,Control.Disabled)) cbSmartId.repaint();
-				} else if (cbgExportType.getSelected() == cbPqLike) {
-					cbSeperateFiles.setState(false);
-					if (cbCustomIcons.change(0,Control.Disabled)) cbCustomIcons.repaint();
-					if (cbSeperateFiles.change(Control.Disabled,0)) cbSeperateFiles.repaint();
-//					if (cbSendToGarmin.change(0,Control.Disabled)) cbSendToGarmin.repaint();
-					if (cbSmartId.change(0,Control.Disabled)) cbSmartId.repaint();
-				} else if (cbgExportType.getSelected() == cbMyFinds) {
-					cbCustomIcons.setState(false);
-					cbSeperateFiles.setState(false);
-					cbSendToGarmin.setState(false);
-					cbSmartId.setState(false);
-					if (cbCustomIcons.change(Control.Disabled,0)) cbCustomIcons.repaint();
-					if (cbSeperateFiles.change(Control.Disabled,0)) cbSeperateFiles.repaint();
-//					if (cbSendToGarmin.change(Control.Disabled,0)) cbSendToGarmin.repaint();
-					if (cbSmartId.change(Control.Disabled,0)) cbSmartId.repaint();
-				}
-			} else if (ev.target == btnOk) {
-				close(1);
-			} else if (ev.target == btnCancel) {
-				close(-1);
-			}
-		}
-		super.onEvent(ev);
-	}
-	
-	/**
-	 * get the export type the user selected
-	 * @return index of selected option in checkboxgroup
-	 * @see GpxExportNg
-	 */
-	public int getExportType() {
-		return cbgExportType.getSelectedIndex();
-	}
-	
-	/**
-	 * check if the user wants smart IDs
-	 * @return true for smart IDs, false otherwise
-	 */
-	public boolean getSmartIds() {
-		return cbSmartId.state;
-	}
-	
-	/**
-	 * check if user wants to send output straight to a Garmin GPSr
-	 * @return true for GPSr transfer, false otherwise
-	 */
-	public boolean getSendToGarmin() {
-		return cbSendToGarmin.state;
-	}
-	
-	/**
-	 * check if user wants custom icons
-	 * @return true if user wants custom icons, false otherwise
-	 */
-	public boolean getCustomIcons() {
-		return cbCustomIcons.state;
-	}
-	
-	/**
-	 * check if user wants separate files (POI loader)
-	 * @return true for separate files, false for single file
-	 */
-	public boolean getSeparateFiles() {
-		return cbSeperateFiles.state;
-	}
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001857.html">[Cachewolf-svn] r1938 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="001859.html">[Cachewolf-svn] r1940 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1858">[ date ]</a>
              <a href="thread.html#1858">[ thread ]</a>
              <a href="subject.html#1858">[ subject ]</a>
              <a href="author.html#1858">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
