<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1950 - in trunk/src/CacheWolf: . imp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1950%20-%20in%20trunk/src/CacheWolf%3A%20.%20imp&In-Reply-To=%3C200906261854.n5QIs5Oc015058%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001868.html">
   <LINK REL="Next"  HREF="001870.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1950 - in trunk/src/CacheWolf: . imp</H1>
    <B>greiol at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1950%20-%20in%20trunk/src/CacheWolf%3A%20.%20imp&In-Reply-To=%3C200906261854.n5QIs5Oc015058%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1950 - in trunk/src/CacheWolf: . imp">greiol at mail.berlios.de
       </A><BR>
    <I>Fri Jun 26 20:54:05 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001868.html">[Cachewolf-svn] r1949 - trunk/src/exp
</A></li>
        <LI>Next message: <A HREF="001870.html">[Cachewolf-svn] r1951 - trunk/src/exp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1869">[ date ]</a>
              <a href="thread.html#1869">[ thread ]</a>
              <a href="subject.html#1869">[ subject ]</a>
              <a href="author.html#1869">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: greiol
Date: 2009-06-26 20:53:49 +0200 (Fri, 26 Jun 2009)
New Revision: 1950

Added:
   trunk/src/CacheWolf/imp/GPXImporter.java
   trunk/src/CacheWolf/imp/OCXMLImporter.java
   trunk/src/CacheWolf/imp/OCXMLImporterScreen.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Removed:
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/SpiderGC.java
Modified:
   trunk/src/CacheWolf/CacheTerrDiff.java
   trunk/src/CacheWolf/CoordsScreen.java
   trunk/src/CacheWolf/DateFormat.java
   trunk/src/CacheWolf/GuiImageBroker.java
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/Log.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
Log:
moved gpximporter, ocxmlimporter and gcspider to package cachewolf.imp

Modified: trunk/src/CacheWolf/CacheTerrDiff.java
===================================================================
--- trunk/src/CacheWolf/CacheTerrDiff.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/CacheTerrDiff.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -10,27 +10,27 @@
 public class CacheTerrDiff {
 	
 	/** terrain or difficulty 1.0 */
-	protected static final byte CW_DT_10 = 10;
+	public static final byte CW_DT_10 = 10;
 	/** terrain or difficulty 1.5 */
-	protected static final byte CW_DT_15 = 15;
+	public static final byte CW_DT_15 = 15;
 	/** terrain or difficulty 2.0 */
-	protected static final byte CW_DT_20 = 20;
+	public static final byte CW_DT_20 = 20;
 	/** terrain or difficulty 2.5 */
-	protected static final byte CW_DT_25 = 25;
+	public static final byte CW_DT_25 = 25;
 	/** terrain or difficulty 3.0 */
-	protected static final byte CW_DT_30 = 30;
+	public static final byte CW_DT_30 = 30;
 	/** terrain or difficulty 3.5 */
-	protected static final byte CW_DT_35 = 35;
+	public static final byte CW_DT_35 = 35;
 	/** terrain or difficulty 4.0 */
-	protected static final byte CW_DT_40 = 40;
+	public static final byte CW_DT_40 = 40;
 	/** terrain or difficulty 4.5 */
-	protected static final byte CW_DT_45 = 45;
+	public static final byte CW_DT_45 = 45;
 	/** terrain or difficulty 5.0 */
-	protected static final byte CW_DT_50 = 50;
+	public static final byte CW_DT_50 = 50;
 	/** wrong terrain or difficulty */
-	protected static final byte CW_DT_ERROR = -1;
+	public static final byte CW_DT_ERROR = -1;
 	/** terrain or difficulty for additional/custom waypoints */
-	protected static final byte CW_DT_UNSET = 0;
+	public static final byte CW_DT_UNSET = 0;
 
 	/** constructor dies nothing */
 	private CacheTerrDiff() { // no instantiation needed 
@@ -44,7 +44,7 @@
 	 * @return internal representation of terrain or difficulty
 	 * @throws IllegalArgumentException if &lt;code&gt;v1TerrDiff&lt;/code&gt; can not be mapped
 	 */
-	static final byte v1Converter(String v1TerrDiff) throws IllegalArgumentException {
+	public static final byte v1Converter(String v1TerrDiff) throws IllegalArgumentException {
 		if (v1TerrDiff == null) {
 			throw new IllegalArgumentException(&quot;error mapping terrain or difficulty&quot;);
 		}

Modified: trunk/src/CacheWolf/CoordsScreen.java
===================================================================
--- trunk/src/CacheWolf/CoordsScreen.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/CoordsScreen.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import CacheWolf.imp.SpiderGC;
 import CacheWolf.navi.Navigate;
 import ewe.ui.*;
 import ewe.fx.Dimension;

Modified: trunk/src/CacheWolf/DateFormat.java
===================================================================
--- trunk/src/CacheWolf/DateFormat.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/DateFormat.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,4 +1,5 @@
 package CacheWolf;
+
 /* Several date formats are used by GC.COM
  *    2/27/2004   - Hidden dates are in format mm/dd/yyyy (=US style)
  *    February 27 - Found dates which happened this year
@@ -6,48 +7,54 @@
  * The internal standard is sortable:
  *    2004-02-27    - YYYY-MM-DD   
  */
-import ewe.sys.*;
 
+import ewe.sys.Convert;
+import ewe.sys.Time;
+
 public class DateFormat {
 
-/** Convert the US Format into a sortable format */
-static String MDY2YMD(String date) {
-	// Dates are in format M/D/Y
-	int p1,p2=-1;
-	p1=date.indexOf(&quot;/&quot;);
-	if (p1&gt;0) p2=date.indexOf(&quot;/&quot;,p1+1);
-	if (p1&gt;0 &amp;&amp; p2&gt;0) {
-		return date.substring(p2+1)+&quot;-&quot;+
-		        (p1==1?&quot;0&quot;:&quot;&quot;)+date.substring(0,p1)+&quot;-&quot;+
-		        (p1+2==p2?&quot;0&quot;:&quot;&quot;)+date.substring(p1+1,p2);
-	} else
-		return date;
-}
+	/** Convert the US Format into a sortable format */
+	public static String MDY2YMD(String date) {
+		// Dates are in format M/D/Y
+		int p1, p2 = -1;
+		p1 = date.indexOf(&quot;/&quot;);
+		if (p1 &gt; 0)
+			p2 = date.indexOf(&quot;/&quot;, p1 + 1);
+		if (p1 &gt; 0 &amp;&amp; p2 &gt; 0) {
+			return date.substring(p2 + 1) + &quot;-&quot; + (p1 == 1 ? &quot;0&quot; : &quot;&quot;)
+					+ date.substring(0, p1) + &quot;-&quot; + (p1 + 2 == p2 ? &quot;0&quot; : &quot;&quot;)
+					+ date.substring(p1 + 1, p2);
+		} else
+			return date;
+	}
 
-/* Convert the sortable date into a US date */
-//static String YMD2MDY(String date) {
-//	return date.substring(4,6)+&quot;/&quot;+date.substring(6,8)+&quot;/&quot;+date.substring(0,4);
-//}
+	/* Convert the sortable date into a US date */
+	// static String YMD2MDY(String date) {
+	// return
+	// date.substring(4,6)+&quot;/&quot;+date.substring(6,8)+&quot;/&quot;+date.substring(0,4);
+	// }
+	/** Convert the log format into a sortable format */
+	public static String logdate2YMD(String logdate) {
+		String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;,
+				&quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;,
+				&quot;December&quot; };
+		Time t = new Time();
+		String year, month, day;
+		int i, m;
+		logdate += &quot;, &quot; + t.year; // If logdate already has a year, this one is
+									// ignored
+		i = logdate.indexOf(',');
+		year = logdate.substring(i + 2, i + 6);
+		for (m = 0; m &lt; 12; m++) {
+			if (logdate.startsWith(monthNames[m])) {
+				month = (m &lt; 9 ? &quot;0&quot; : &quot;&quot;) + Convert.formatInt(m + 1);
+				day = logdate.substring(monthNames[m].length() + 1, i);
+				if (day.length() == 1)
+					day = &quot;0&quot; + day;
+				return year + &quot;-&quot; + month + &quot;-&quot; + day;
+			}
+		}
+		return &quot;&quot;;
+	}
 
-/** Convert the log format into a sortable format */
-static String logdate2YMD(String logdate) {
-   String monthNames[]={&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;};
-   Time t=new Time();
-   String year,month,day;
-   int i,m;
-   logdate+=&quot;, &quot;+t.year; // If logdate already has a year, this one is ignored
-   i=logdate.indexOf(',');
-   year=logdate.substring(i+2,i+6);
-   for (m=0; m&lt;12; m++) {
-	   if (logdate.startsWith(monthNames[m])) {
-		   month=(m&lt;9?&quot;0&quot;:&quot;&quot;)+Convert.formatInt(m+1);
-		   day=logdate.substring(monthNames[m].length()+1,i);
-		   if (day.length()==1)day=&quot;0&quot;+day;
-		   return year+&quot;-&quot;+month+&quot;-&quot;+day;
-	   }
-   }
-   return &quot;&quot;;
 }
-
-
-}

Deleted: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,576 +0,0 @@
-package CacheWolf;
-
-import ewesoft.xml.*;
-import ewesoft.xml.sax.*;
-import ewe.sys.*;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
-import ewe.util.zip.*;
-
-/**
-*	Class to import Data from an GPX File. If cache data exists, the data from 
-*	the GPX-File is ignored.
-*	Class ID = 4000
-*/
-public class GPXImporter extends MinML {
-	
-	static Preferences pref;
-	Profile profile;
-	CacheDB cacheDB;
-	CacheHolder holder;
-	String strData, saveDir, logData, logIcon, logDate, logFinder, logId;
-	boolean inWpt, inCache, inLogs, inBug;
-	public XMLElement document;
-	private Vector files = new Vector();
-	private boolean debugGPX = false; 
-	InfoBox infB;
-	boolean spiderOK = true;
-	boolean doSpider = false;
-	boolean fromOC = false;
-	boolean fromTC = false;
-	boolean nameFound = false;
-	static final Time gpxDate = new Time();
-	int zaehlerGel = 0;
-	public static final int DOIT_ASK = 0;
-	public static final int DOIT_NOSPOILER = 1;
-	public static final int DOIT_WITHSPOILER = 2;
-	boolean getMaps = false;
-	SpiderGC imgSpider;
-	StringBuffer strBuf;
-	
-	public GPXImporter(Preferences p, Profile prof, String f )
-	{
-		profile=prof;
-		pref = p;
-		cacheDB = profile.cacheDB;
-		//file = f;
-		files.add(f);
-		saveDir = profile.dataDir;
-		//msgA = msgArea;
-		inWpt = false;
-		inCache = false;
-		inLogs = false;
-		inBug =false;
-	}
-/*	skg: This Constructor is not referenced, therefore commented out 
-	public GPXImporter(Vector DB, String[] f,String d, Preferences p)
-	{
-		pref = p;
-		cacheDB = DB;
-		saveDir = pref.mydatadir;
-		for (int i=0;i&lt;f.length;i++){
-			files.add(d + &quot;/&quot; + f[i]);
-		}
-		
-		//msgA = msgArea;
-		inWpt = false;
-		inCache = false;
-		inLogs = false;
-		inBug =false;
-		strData = new String();
-		//index db for faster search
-		CacheHolder ch;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			DBindex.put((String)ch.wayPoint, new Integer(i));
-		}//for
-	}
-*/	
-	public void doIt(int how){
-		Filter flt = new Filter();
-		boolean wasFiltered = (profile.getFilterActive()==Filter.FILTER_ACTIVE);
-		flt.clearFilter();
-		try{
-			ewe.io.Reader r;
-			String file;
-			
-			OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
-			if (options.execute() == FormBase.IDCANCEL) {	return; }
-			//String dist = options.distanceInput.getText();
-			//if (dist.length()== 0) return;
-			//getMaps = options.mapsCheckBox.getState();
-			boolean getImages = options.imagesCheckBox.getState();
-			doSpider = false;
-			if(getImages){
-				doSpider = true;
-				imgSpider = new SpiderGC(pref, profile, false);
-			}
-			options.close(0);
-			
-			//Vm.debug(&quot;State of: &quot; + doSpider);
-			Vm.showWait(true);
-			for (int i=0; i&lt;files.size();i++){
-				//Test for zip.file
-				file = (String)files.get(i);
-				if (file.indexOf(&quot;.zip&quot;) &gt; 0){
-					ZipFile zif = new ZipFile (file);
-					ZipEntry zipEnt;
-					Enumeration zipEnum = zif.entries();
-					// there could be more than one file in the archive
-					while (zipEnum.hasMoreElements())
-					{
-						zipEnt = (ZipEntry) zipEnum.nextElement();
-						// skip over PRC-files
-						if (zipEnt.getName().endsWith(&quot;gpx&quot;)){
-							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
-							infB.exec();
-							if (r.read() != 65279)
-								r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							parse(r);
-							r.close();
-							infB.close(0);
-						}
-					}
-				}
-				else {
-					r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
-					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
-					infB.show();
-					if (r.read() != 65279)
-						r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
-					parse(r);
-					r.close();
-					infB.close(0);
-				}
-				// save Index 
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-				infB.close(0);
-			}
-				Vm.showWait(false);
-			}catch(Exception e){
-				e.printStackTrace();
-				Vm.showWait(false);
-			}
-		if(wasFiltered){
-			flt.setFilter();
-			flt.doFilter();
-		}
-	}
-	public void startElement(String name, AttributeList atts){
-		strBuf=new StringBuffer(300);
-		if (name.equals(&quot;gpx&quot;)){
-			// check for opencaching
-			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;)&gt; 0) fromOC = true;
-			else fromOC = false;
-			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;)) fromTC = true;
-			else fromTC = false;
-
-			if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
-			zaehlerGel = 0;
-		}
-		if (name.equals(&quot;wpt&quot;)) {
-			holder = new CacheHolder();
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			holder.LatLon=holder.pos.toString();
-			inWpt = true;
-			inLogs = false;
-			inBug = false;
-			nameFound = false;
-			zaehlerGel++;
-			infB.setInfo(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel);
-			return;
-		}
-		
-		if (name.equals(&quot;link&quot;)&amp;&amp; inWpt){
-			holder.getFreshDetails().URL = atts.getValue(&quot;href&quot;);
-			return;
-		}
-
-		if (name.equals(&quot;groundspeak:cache&quot;)) {
-			inCache = true;
-			holder.setAvailable(atts.getValue(&quot;available&quot;).equals(&quot;True&quot;));
-			holder.setArchived(atts.getValue(&quot;archived&quot;).equals(&quot;True&quot;));
-			return;
-		}
-
-		if (name.equals(&quot;geocache&quot;)) {
-			boolean available = false;
-			boolean archived  = false;
-			inCache=true;
-			// get status
-			String status = new String(atts.getValue(&quot;status&quot;));
-			if (status.equals(&quot;Available&quot;)) available = true;
-			else if (status.equals(&quot;Unavailable&quot;)) available = false;
-			else if (status.equals(&quot;Draft&quot;)) available = false;
-			else if (status.equals(&quot;Archived&quot;)) archived = true;
-			holder.setArchived(archived);
-			holder.setAvailable(available);
-			return;
-		}
-		
-		if (name.equals(&quot;terra:terracache&quot;)) {
-			inCache=true;
-		}
-
-		
-		if (name.equals(&quot;groundspeak:long_description&quot;)) {
-			holder.setHTML(atts.getValue(&quot;html&quot;).toLowerCase().equals(&quot;true&quot;));
-		}
-		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;) ) {
-			//set HTML always to true if from oc.de or TC
-			holder.setHTML(true);
-		}
-
-		if (name.equals(&quot;groundspeak:logs&quot;) || name.equals(&quot;logs&quot;) || name.equals(&quot;terra:logs&quot;)) {
-			inLogs = true;
-			return;
-		}
-		if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;)) {
-			inLogs = true;
-			logId = atts.getValue(&quot;id&quot;);
-			return;
-		}
-		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
-			inBug = true;
-			return;
-		}
-		if (debugGPX){
-			for (int i = 0; i &lt; atts.getLength(); i++) {
-				Vm.debug(&quot;Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
-			}
-		}
-	}
-	
-	public void endElement(String name){
-		strData=strBuf.toString();
-		//Vm.debug(&quot;Ende: &quot; + name);
-		
-		// logs
-		if (inLogs){
-			if (name.equals(&quot;groundspeak:date&quot;)|| name.equals(&quot;time&quot;)|| name.equals(&quot;terra:date&quot;))  {
-				logDate = new String(strData.substring(0,10));
-				return;
-			}
-			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)){
-				logIcon = new String(typeText2Image(strData));
-				return;
-			}
-			if (name.equals(&quot;groundspeak:finder&quot;)|| name.equals(&quot;geocacher&quot;)|| name.equals(&quot;terra:user&quot;)){
-				logFinder = new String(strData);
-				return;
-			}
-			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){ 
-				logData = new String(strData);
-				return;
-			}
-			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;) ) {
-				holder.getFreshDetails().CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
-				if((logIcon.equals(&quot;icon_smile.gif&quot;) || logIcon.equals(&quot;11.png&quot;) || logIcon.equals(&quot;icon_attended.gif&quot;)) &amp;&amp; 
-						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; logFinder.equalsIgnoreCase(pref.myAlias2)))) {
-							holder.setCacheStatus(logDate);
-							holder.setFound(true);
-							holder.getFreshDetails().OwnLogId = logId;
-							holder.getFreshDetails().OwnLog = new Log(logIcon,logDate,logFinder,logData);
-				}
-				return;
-			}
-		}
-		
-		if (name.equals(&quot;wpt&quot;)){
-			// Add cache Data only, if waypoint not already in database
-			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
-			int index=cacheDB.getIndex(holder.getWayPoint());
-			//Vm.debug(&quot;here ?!?!?&quot;);
-			//Vm.debug(&quot;chould be new!!!!&quot;);
-			if (index == -1){
-				holder.setNoFindLogs(holder.getFreshDetails().CacheLogs.countNotFoundLogs());
-				holder.setNew(true);
-				cacheDB.add(holder);
-				// don't spider additional waypoints, so check
-				// if waypoint starts with &quot;GC&quot;
-				if(doSpider == true) {
-					if(spiderOK == true &amp;&amp; holder.is_archived() == false){
-							if(holder.LatLon.length() &gt; 1){
-							if(getMaps){
-								ParseLatLon pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
-								pll.parse();
-								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
-								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map.gif&quot;, &quot;3&quot;);
-								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map_2.gif&quot;, &quot;10&quot;);
-							}
-						}
-					if(holder.getWayPoint().startsWith(&quot;GC&quot;)|| fromTC) {
-						//spiderImages();
-						spiderImagesUsingSpider();
-						//Rename image sources
-						String text;
-						String orig;
-						String imgName;
-						orig = holder.getFreshDetails().LongDescription;
-						Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
-						text = ex.findNext();
-						int num = 0;
-						while(ex.endOfSearch() == false &amp;&amp; spiderOK == true){
-							//Vm.debug(&quot;Replacing: &quot; + text);
-							if (num &gt;= holder.getFreshDetails().ImagesText.getCount())break;
-							imgName = (String)holder.getFreshDetails().ImagesText.get(num);
-							holder.getFreshDetails().LongDescription = replace(holder.getFreshDetails().LongDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
-							num++;
-							text = ex.findNext();
-						}
-					}
-						
-					}
-				}
-				holder.save();
-				//crw.saveIndex(cacheDB,saveDir);
-			}
-			//Update cache data
-			else {
-				CacheHolder oldCh= cacheDB.get(index);
-				oldCh.update(holder);
-				oldCh.save();
-			}
-			
-			inWpt = false;
-			return;
-		}
-		if (name.equals(&quot;sym&quot;)&amp;&amp; strData.endsWith(&quot;Found&quot;)) {
-			holder.setFound(true);
-			holder.setCacheStatus(MyLocale.getMsg(318,&quot;Found&quot;));
-			return;
-		}
-		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
-			inBug = false;
-			return;
-		}
-
-		if (name.equals(&quot;groundspeak:name&quot;)&amp;&amp; inBug) {
-			Travelbug tb=new Travelbug(strData);
-			holder.getFreshDetails().Travelbugs.add(tb);
-			//holder.Bugs += &quot;&lt;b&gt;Name:&lt;/b&gt; &quot; + strData + &quot;&lt;br&gt;&lt;hr&gt;&quot;;
-			holder.setHas_bugs(true);
-			return;
-		}
-		
-		if (name.equals(&quot;time&quot;) &amp;&amp; !inWpt) {		    
-			try {
-			    gpxDate.parse(strData.substring(0,19),&quot;yyyy-MM-dd'T'HH:mm:ss&quot;);
-			} catch (IllegalArgumentException e) {
-			    gpxDate.setTime(0);
-			    Global.getPref().log(&quot;Error parsing date: '&quot;+strData+&quot;'. Ignoring.&quot;);
-			}
-			return;
-		}
-
-		if (name.equals(&quot;time&quot;) &amp;&amp; inWpt) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
-			return;
-		}
-		// cache information
-		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;)|| name.equals(&quot;terra:terracache&quot;)) {
-			inCache = false;
-		}
-		
-		if (name.equals(&quot;name&quot;) &amp;&amp; inWpt &amp;&amp; !inCache) {
-			holder.setWayPoint(strData);
-			if (gpxDate.getTime()!=0) {
-			    holder.setLastSync(gpxDate.format(&quot;yyyyMMddHHmmss&quot;));
-			} else {
-			    holder.setLastSync(&quot;&quot;);
-			}    
-			//msgA.setText(&quot;import &quot; + strData);
-			return;
-		}
-		//Vm.debug(&quot;Check: &quot; + inWpt + &quot; / &quot; + fromOC);
-		//if (name.equals(&quot;desc&quot;) &amp;&amp; inWpt &amp;&amp; fromOC) {
-		// fill name with contents of &lt;desc&gt;, in case of gc.com the name is
-		// later replaced by the contents of &lt;groundspeak:name&gt; which is shorter
-		if (name.equals(&quot;desc&quot;)&amp;&amp; inWpt ) {
-			holder.setCacheName(strData);
-			//Vm.debug(&quot;CacheName: &quot; + strData);
-			//msgA.setText(&quot;import &quot; + strData);
-			return;
-		}
-		if (name.equals(&quot;url&quot;)&amp;&amp; inWpt){
-			holder.getFreshDetails().URL = strData;
-			return;
-		}
-		
-		// Text for additional waypoints, no HTML
-		if (name.equals(&quot;cmt&quot;)&amp;&amp; inWpt){
-			holder.getFreshDetails().LongDescription = strData;
-			holder.setHTML(false);
-			return;
-		}
-		
-		// aditional wapypoint
-		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
-			holder.setType(CacheType.gpxType2CwType(strData));
-			holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-			holder.setHard(CacheTerrDiff.CW_DT_UNSET);
-			holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-			holder.setLastSync(&quot;&quot;);
-		}
-		
-		if ((name.equals(&quot;groundspeak:name&quot;)|| name.equals(&quot;terra:name&quot;)) &amp;&amp; inCache) {
-			holder.setCacheName(strData);
-			return;
-		}
-		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;)||name.equals(&quot;terra:owner&quot;)) {
-			holder.setCacheOwner(strData);
-			if(pref.myAlias.equals(strData)) holder.setOwned(true);
-			return;
-		}
-		if (name.equals(&quot;groundspeak:difficulty&quot;) || name.equals(&quot;difficulty&quot;) || name.equals(&quot;terra:mental_challenge&quot;)) {
-			holder.setHard(CacheTerrDiff.v1Converter(strData));
-			return;
-		}
-		if (name.equals(&quot;groundspeak:terrain&quot;)|| name.equals(&quot;terrain&quot;)|| name.equals(&quot;terra:physical_challenge&quot;)) {
-			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
-			return;
-		}
-		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){
-			holder.setType(CacheType.gpxType2CwType(strData));
-			if (holder.getType() == CacheType.CW_TYPE_CUSTOM) {
-				holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-				holder.setHard(CacheTerrDiff.CW_DT_UNSET);
-				holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-			}
-			return;
-		}
-		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){
-			holder.setCacheSize(CacheSize.gcGpxString2Cw(strData));
-			return;
-		}
-		if (name.equals(&quot;groundspeak:country&quot;)|| name.equals(&quot;country&quot;)){
-			holder.getFreshDetails().Country = strData;
-			return;
-		}
-		if (name.equals(&quot;groundspeak:state&quot;)|| name.equals(&quot;state&quot;)){
-			holder.getFreshDetails().State = strData;
-			return;
-		}
-		if (name.equals(&quot;terra:size&quot;)){
-			holder.setCacheSize(CacheSize.tcGpxString2Cw(strData));
-		}
-
-		if (name.equals(&quot;groundspeak:short_description&quot;)|| name.equals(&quot;summary&quot;)) {
-			if (holder.is_HTML())	holder.getFreshDetails().LongDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
-			else holder.getFreshDetails().LongDescription =strData+&quot;\n&quot;;
-			return;
-		}
-
-		if (name.equals(&quot;groundspeak:long_description&quot;)|| name.equals(&quot;description&quot;)|| name.equals(&quot;terra:description&quot;)) {
-			if (holder.is_HTML())	holder.getFreshDetails().LongDescription +=SafeXML.cleanback(strData);
-			else holder.getFreshDetails().LongDescription +=strData;
-			return;
-		}
-		if (name.equals(&quot;groundspeak:encoded_hints&quot;) || name.equals(&quot;hints&quot;)) {
-			holder.getFreshDetails().Hints = Common.rot13(strData);
-			return;
-		}
-		
-		if (name.equals(&quot;terra:hint&quot;)) {
-			// remove &quot;&lt;br&gt;&lt;br&gt;&quot; from the end
-			int indexTrash = strData.indexOf(&quot;&lt;br&gt;&lt;br&gt;&quot;);
-			if (indexTrash &gt; 0)	holder.getFreshDetails().Hints = Common.rot13(strData.substring(0,indexTrash));
-			return;
-		}
-
-
-	}
-	public void characters(char[] ch,int start,int length){
-		strBuf.append(ch,start,length);
-		if (debugGPX) Vm.debug(&quot;Char: &quot; + strBuf.toString());
-	}
-	
-
-	public static String typeText2Image(String typeText){
-		if (typeText.equals(&quot;Found it&quot;)||typeText.equals(&quot;Found&quot;)||typeText.equals(&quot;find&quot;)) return &quot;icon_smile.gif&quot;;
-		if (typeText.equals(&quot;Didn't find it&quot;)||typeText.equals(&quot;Not Found&quot;)||typeText.equals(&quot;no_find&quot;)) return &quot;icon_sad.gif&quot;;
-		if (typeText.equals(&quot;Write note&quot;)||typeText.equals(&quot;Note&quot;)||typeText.equals(&quot;note&quot;)
-			||typeText.equals(&quot;Not Attempted&quot;)||typeText.equals(&quot;Other&quot;)) return &quot;icon_note.gif&quot;;
-		if (typeText.equals(&quot;Enable Listing&quot;)) return &quot;icon_enabled.gif&quot;;
-		if (typeText.equals(&quot;Temporarily Disable Listing&quot;)) return &quot;icon_disabled.gif&quot;;
-		if (typeText.equals(&quot;Webcam Photo Taken&quot;)) return &quot;11.png&quot;;
-		if (typeText.equals(&quot;Attended&quot;)) return &quot;icon_attended.gif&quot;;
-		if (typeText.equals(&quot;Publish Listing&quot;)) return &quot;green.png&quot;;
-		if (typeText.equals(&quot;Will Attend&quot;)) return &quot;icon_rsvp.gif&quot;;
-		if (typeText.equals(&quot;Post Reviewer Note&quot;)) return &quot;big_smile.gif&quot;;
-		if (typeText.equals(&quot;Unarchive&quot;)) return &quot;traffic_cone.gif&quot;;
-		if (typeText.equals(&quot;Archive (show)&quot;)) return &quot;traffic_cone.gif&quot;;
-		if (typeText.equals(&quot;Owner Maintenance&quot;)) return &quot;icon_maint.gif&quot;;
-		if (typeText.equals(&quot;Needs Maintenance&quot;)) return &quot;icon_needsmaint.gif&quot;;
-		if (typeText.equals(&quot;Update Coordinates&quot;)) return &quot;coord_update.gif&quot;;
-		//Vm.debug(&quot;Unknown Log Type:&quot; + typeText);
-		return typeText;
-	}
-	
-	public static String TCSizetoText(String size){
-		if (size.equals(&quot;1&quot;)) return &quot;Micro&quot;;
-		if (size.equals(&quot;2&quot;)) return &quot;Medium&quot;;
-		if (size.equals(&quot;3&quot;)) return &quot;Regular&quot;;
-		if (size.equals(&quot;4&quot;)) return &quot;Large&quot;;
-		if (size.equals(&quot;5&quot;)) return &quot;Very Large&quot;;
-
-		return &quot;None&quot;;
-	}
-
-	/**
-	* Method to iterate through cache database and look for waypoint.
-	* Returns value &gt;= 0 if waypoint is found, else -1
-	*/
-	/*
-	private int searchWpt(Vector db, String wpt){
-		if(wpt.length()&gt;0){
-			wpt = wpt.toUpperCase();
-			CacheHolder ch = new CacheHolder();
-			//Search through complete database
-			for(int i = 0;i &lt; db.size();i++){
-				ch = (CacheHolder)db.get(i);
-				if(ch.wayPoint.indexOf(wpt) &gt;=0 ){
-					return i;
-				}
-			} // for
-		} // if
-		return -1;
-	}
-	*/
-	
-	private void spiderImagesUsingSpider(){
-		String addr;
-		String cacheText;
-		
-		// just to be sure to have a spider object
-		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
-		
-		if (fromTC) {
-				imgSpider.getImages(holder.getFreshDetails().LongDescription, holder.getFreshDetails());
-		}
-		else {
-			addr = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + holder.getWayPoint() ;
-			//Vm.debug(addr + &quot;|&quot;);
-			cacheText = SpiderGC.fetch(addr);
-			imgSpider.getImages(cacheText, holder.getFreshDetails());
-			try {
-				imgSpider.getAttributes(cacheText, holder.getFreshDetails());
-			} catch (Exception e) {
-				if (Global.getPref().debug) Global.getPref().log(&quot;unable to fetch attrivbutes for&quot;+holder.getWayPoint(), e);
-			}
-		}
-	}
-	
-	public static String replace(String source, String pattern, String replace){
-		if (source!=null)
-		{
-			final int len = pattern.length();
-			StringBuffer sb = new StringBuffer();
-			int found = -1;
-			int start = 0;
-		
-			while( (found = source.indexOf(pattern, start) ) != -1) {
-			    sb.append(source.substring(start, found));
-			    sb.append(replace);
-			    start = found + len;
-			}
-		
-			sb.append(source.substring(start));
-		
-			return sb.toString();
-		}
-		else return &quot;&quot;;
-	}
-}

Modified: trunk/src/CacheWolf/GuiImageBroker.java
===================================================================
--- trunk/src/CacheWolf/GuiImageBroker.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/GuiImageBroker.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -49,7 +49,12 @@
 
 	// TODO: move size images here
 	private static final Image[] sizeImages = {
-
+//		new Image(CacheSize.CW_GUIIMG_NONPHYSICAL),
+//		new Image(CacheSize.CW_GUIIMG_MICRO),
+//		new Image(CacheSize.CW_GUIIMG_SMALL),
+//		new Image(CacheSize.CW_GUIIMG_NORMAL),
+//		new Image(CacheSize.CW_GUIIMG_LARGE),
+//		new Image(CacheSize.CW_GUIIMG_VERYLARGE)
 	};
 
 	/** constructor does nothing */
@@ -90,10 +95,10 @@
 	}
 
 	/**
-	 * Replaces the buildt-in symbols by images stored in /symbols:
-	 * If the subdirectory symbols exists in CW-directory *.png-files
+	 * Replaces the build-in symbols by images stored in /symbols:
+	 * If the sub directory symbols exists in CW-directory *.png-files
 	 * are read in and roughly checked for validity (names must be
-	 * convertable to integers between 0 and 21).
+	 * convertible to integers between 0 and 21).
 	 * For every valid file x.png the corresponding typeImages[x] is
 	 * replaced by the image in x.png.
 	 * Images are NOT checked for size etc.

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/InfoBox.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -8,7 +8,7 @@
 	public boolean mCB_state = false;
 	mButton mB = new mButton(&quot;OK&quot;);
 	mButton mC = new mButton(&quot;Cancel&quot;);
-	mInput feedback = new mInput();
+	public mInput feedback = new mInput();
 	public final static int CHECKBOX = 1;
 	public final static int INPUT = 2;
 	public final static int DISPLAY_ONLY = 3;

Modified: trunk/src/CacheWolf/Log.java
===================================================================
--- trunk/src/CacheWolf/Log.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/Log.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,5 +1,7 @@
 package CacheWolf;
 
+import CacheWolf.imp.GPXImporter;
+
 public class Log {
 	private static String MAXLOGICON=&quot;MAXLOG&quot;;
 	private static String INVALIDLOGICON=null;
@@ -19,7 +21,7 @@
 	 * or &lt;img src='ICON'&gt;&nbsp;DATE by LOGGER&lt;br&gt;MESSAGE&lt;/pre&gt;
 	 * @param logLine
 	 */
-	Log(String logLine) {
+	public Log(String logLine) {
 //		RECOMMENDED=&quot;1&quot;&lt;img src='icon_smile.gif'&gt;&nbsp;2007-01-14 xyz&lt;br&gt;a wonderful log
 		try {
 			int ic1=logLine.indexOf(&quot;RECOMMENDED=\&quot;1\&quot;&quot;);
@@ -47,11 +49,11 @@
 		}
 	}
 	
-	Log(String icon, String date, String logger, String message) {
+	public Log(String icon, String date, String logger, String message) {
 		this(icon, date, logger, message, false);
 	}
 	
-	Log(String icon, String date, String logger, String message, boolean recommended_) {
+	public Log(String icon, String date, String logger, String message, boolean recommended_) {
 		this.icon=icon;
 		this.date=date;
 		this.logger=logger;

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/MainMenu.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,18 +1,45 @@
 package CacheWolf;
 
+import CacheWolf.imp.GPXImporter;
+import CacheWolf.imp.OCXMLImporter;
+import CacheWolf.imp.OCXMLImporterScreen;
+import CacheWolf.imp.Rating;
+import CacheWolf.imp.SpiderGC;
 import CacheWolf.navi.MapImporter;
 import CacheWolf.navi.MapLoaderGui;
 import CacheWolf.navi.SelectMap;
-import CacheWolf.imp.Rating;
-import ewe.ui.*;
+import ewe.filechooser.FileChooser;
+import ewe.filechooser.FileChooserBase;
+import ewe.fx.Font;
+import ewe.io.FileBase;
+import ewe.io.IOException;
+import ewe.sys.Vm;
+import ewe.ui.ControlEvent;
+import ewe.ui.Event;
+import ewe.ui.Form;
+import ewe.ui.FormBase;
+import ewe.ui.Gui;
+import ewe.ui.Menu;
+import ewe.ui.MenuBar;
+import ewe.ui.MenuEvent;
+import ewe.ui.MenuItem;
+import ewe.ui.MessageBox;
+import ewe.ui.ProgressBarForm;
+import ewe.ui.PullDownMenu;
+import ewe.ui.mApp;
 import ewe.util.Vector;
-//import ewe.util.mString;
-import ewe.fx.*;
-import ewe.sys.*;
-//import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import exp.*;
+import exp.ASCExporter;
+import exp.ExploristExporter;
+import exp.GPXExporter;
+import exp.GpxExportNg;
+import exp.HTMLExporter;
+import exp.KMLExporter;
+import exp.LocExporter;
+import exp.MSARCSVExporter;
+import exp.OVLExporter;
+import exp.OziExporter;
+import exp.TPLExporter;
+import exp.TomTomExporter;
 
 /**
  *	This class creates the menu for cachewolf. It is also responsible

Deleted: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,716 +0,0 @@
-package CacheWolf;
-
-import utils.FileBugfix;
-
-import com.stevesoft.ewe_pat.Regex;
-
-import ewesoft.xml.*;
-import ewesoft.xml.sax.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
-import ewe.util.zip.*;
-import ewe.net.*;
-import ewe.sys.Double;
-
-/**
- *	Class to import Data from opencaching.de. 
- *	It uses the lastmodified parameter to identify new or changed caches.
- *	See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
- *   See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
- *	for more information.
- */
-public class OCXMLImporter extends MinML {
-	static protected final int STAT_INIT = 0;
-	static protected final int STAT_CACHE = 1;
-	static protected final int STAT_CACHE_DESC = 2;
-	static protected final int STAT_CACHE_LOG = 3;
-	static protected final int STAT_PICTURE = 4;
-
-	final static String OPENCACHING_HOST = &quot;www.opencaching.de&quot;;
-	int state = STAT_INIT;
-	int numCacheImported, numDescImported, numLogImported= 0;
-
-	boolean debugGPX = false;
-	CacheDB cacheDB;
-	InfoBox inf;
-	CacheHolder ch;
-	CacheHolder holder;
-	Preferences pref;
-	Profile profile;
-	Time dateOfthisSync;
-	String strData = new String();
-	int picCnt;
-	boolean incUpdate = true; // complete or incremental Update
-	boolean ignoreDesc = false;
-	boolean askForOptions = true;
-	Hashtable DBindexID = new Hashtable();
-
-	String picUrl = new String();
-	String picTitle =  new String();
-	String picID = new String();
-	String ocSeekUrl = new String(&quot;<A HREF="http://">http://</A>&quot;+OPENCACHING_HOST+&quot;/viewcache.php?cacheid=&quot;);
-	String cacheID = new String();
-
-	String logData, logIcon, logDate, logFinder, logId;
-	boolean loggerRecommended;
-	int logtype;
-	String user;
-	double longitude;
-
-
-	public OCXMLImporter(Preferences p,Profile prof)
-	{
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-		if(profile.getLast_sync_opencaching() == null ||
-				profile.getLast_sync_opencaching().length() &lt; 12){
-			profile.setLast_sync_opencaching(&quot;20050801000000&quot;);
-			incUpdate = false;
-		}
-		user = p.myAlias.toLowerCase();
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = cacheDB.get(i);
-			if (!ch.getOcCacheID().equals(&quot;&quot;))
-				DBindexID.put(ch.getOcCacheID(), new Integer(i));
-		}//for
-
-	}
-
-	/** true, if not the last syncdate shall be used, but the caches shall be reloaded
-	 * only used in syncSingle */
-	boolean reload;
-	/**
-	 * 
-	 * @param number
-	 * @param infB
-	 * @return true, if some change was made to the cacheDB
-	 */
-	public boolean syncSingle(int number, InfoBox infB) {
-		ch = cacheDB.get(number);
-		holder= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
-
-		if (infB.isClosed) {
-			if (askForOptions) return false; 
-			else return true;
-		}
-		if (askForOptions) {
-			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL);
-			if (importOpt.execute() == FormBase.IDCANCEL) {	return false; }
-			askForOptions = false;
-			reload = importOpt.missingCheckBox.getState();
-		}
-
-		// this is only a dummy-InfoBox for capturing the output
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
-//		inf.setPreferredSize(220, 300);
-//		inf.relayout(false);
-//		inf.exec();
-
-		String lastS; 
-		if (reload)  lastS = &quot;20050801000000&quot;;
-		else {
-			if (ch.getLastSync().length() &lt; 14) lastS = &quot;20050801000000&quot;;
-			else lastS = ch.getLastSync();
-		}
-		dateOfthisSync = new Time();
-		dateOfthisSync.parse(lastS, &quot;yyyyMMddHHmmss&quot;);
-	
-
-		String url = new String();
-		picCnt = 0;
-		//Build url
-		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
-		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;wp=&quot; + ch.getWayPoint()
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
-		syncOC(url);
-		inf.close(0);
-		return true;
-	}
-
-	public void doIt(){
-		boolean success=true;
-		String finalMessage;
-
-		
-		String url = new String();
-
-		String lastS =  profile.getLast_sync_opencaching();
-		CWPoint centre = pref.curCentrePt; // No need to clone curCentrePt as centre is only read
-		if (!centre.isValid()) {
-			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, FormBase.OKB)).execute();
-			return;
-		}
-		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),
-																 OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
-		Vm.showWait(true);
-		String dist = importOpt.distanceInput.getText();
-		if (dist.length()== 0) return;
-		
-		Double distDouble = new Double();
-		distDouble.value = Common.parseDouble(dist);
-		dist = distDouble.toString(0, 1, 0).replace(',', '.');
-		//check, if distance is greater than before
-		if (Convert.toInt(dist) &gt; Convert.toInt(profile.getDistOC()) ||
-				pref.downloadmissingOC  ){
-			// resysnc
-			lastS = &quot;20050801000000&quot;;
-			incUpdate = false;
-		}
-		profile.setDistOC(dist);
-		// Clear status of caches in db
-		for(int i = cacheDB.size()-1; i&gt;=0 ;i--){
-			ch = cacheDB.get(i);
-			ch.setUpdated(false);
-			ch.setNew(false);
-			ch.setLog_updated(false);
-		}	
-		picCnt = 0;
-		//Build url
-		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
-		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;lat=&quot; + centre.getLatDeg(CWPoint.DD)
-			+ &quot;&amp;lon=&quot; + centre.getLonDeg(CWPoint.DD)
-			+ &quot;&amp;distance=&quot; + dist
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
-		inf.setPreferredSize(220, 300);
-		inf.relayout(false);
-		inf.exec();
-
-		success = syncOC(url);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-		Vm.showWait(false);
-		if (success) {
-			profile.setLast_sync_opencaching(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
-			//pref.savePreferences();
-			finalMessage = MyLocale.getMsg(1607,&quot;Update from opencaching successful&quot;); 
-			inf.addWarning(&quot;\nNumber of&quot;+
-			&quot;\n...caches new/updated: &quot; + numCacheImported +
-			&quot;\n...cache descriptions new/updated: &quot; + numDescImported +
-			&quot;\n...logs new/updated: &quot; + numLogImported);
-			inf.setInfo(finalMessage);
-		}
-		inf.addOkButton();
-	}
-	
-	private boolean syncOC(String url) {
-		String finalMessage = new String();
-		boolean success=true;
-		File tmpFile = null;
-		BufferedReader r;
-		String file = new String();
-
-		//inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
-		
-		picCnt = 0;
-		try{
-			holder = null;
-			file = fetch(url, &quot;dummy&quot;);
-
-			//parse
-			tmpFile = new FileBugfix(profile.dataDir + file);
-			if (tmpFile.getLength() == 0 ) {
-				throw new IOException(&quot;no updates available&quot;);
-			}
-
-			ZipFile zif = new ZipFile (profile.dataDir + file);
-			ZipEntry zipEnt;
-			Enumeration zipEnum = zif.entries();
-			inf.setInfo(&quot;...unzipping update file&quot;); 
-			while (zipEnum.hasMoreElements())
-			{
-				zipEnt = (ZipEntry) zipEnum.nextElement();
-				// skip over PRC-files and empty files
-				if (zipEnt.getSize()&gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)){
-					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
-					parse(r);
-					r.close();
-				}
-			}
-			zif.close();
-		}catch (ZipException e){
-			finalMessage = MyLocale.getMsg(1614,&quot;Error while unzipping udpate file&quot;);
-			success = false;
-		}catch (IOException e){
-			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) { finalMessage = &quot;No updates available&quot;; success = false; }
-			else {
-				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
-					finalMessage = MyLocale.getMsg(1616,&quot;Error: could not download udpate file from opencaching.de&quot;);
-				} else { finalMessage = &quot;IOException: &quot;+e.getMessage(); }
-				success = false;
-			}
-		}catch (IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,&quot;Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
-			success = false;
-			Vm.debug(&quot;Parse error: &quot; + state + &quot; &quot; + holder.getWayPoint());
-			e.printStackTrace();
-		}catch (Exception e){ // here should be used the correct exception
-			if (holder != null)	finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
-			else finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &lt;unkown&gt;&quot;;
-			success = false;
-			Vm.debug(&quot;Parse error: &quot; + state + &quot; Exception:&quot; + e.toString()+&quot;   &quot;+holder.getOcCacheID());
-			e.printStackTrace();
-		} finally {
-			if (tmpFile != null) tmpFile.delete();
-		}
-		/*
-		for (int i=cacheDB.size()-1; i &gt;=0; i--) {
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
-				ch.calcRecommendationScore();
-			}
-		} */
-		inf.setInfo(finalMessage);
-
-		return success;
-	}
-
-	public void startElement(String name, AttributeList atts){
-		if (debugGPX){
-			for (int i = 0; i &lt; atts.getLength(); i++) {
-				Vm.debug(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
-			}
-		}
-		strData =&quot;&quot;;
-
-		if (name.equals(&quot;oc11xml&quot;)){
-			Time lastSync = new Time();
-			try {
-				lastSync.parse(atts.getValue(&quot;date&quot;),&quot;yyyy-MM-dd HH:mm:ss&quot;);
-			}catch (IllegalArgumentException e){ // TODO Fehler werfen
-				Vm.debug(e.toString());
-			}
-			// reduce time at 1 second to avoid sync problems
-			lastSync.setTime(lastSync.getTime() - 1000);
-			dateOfthisSync = lastSync;
-			state = STAT_INIT;
-		}
-
-		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		{ state = STAT_CACHE; numCacheImported++;}
-		if (name.equals(&quot;cachedesc&quot;)) 	{ state = STAT_CACHE_DESC; numDescImported++;}
-		if (name.equals(&quot;cachelog&quot;)) 	{ state = STAT_CACHE_LOG; numLogImported++; logtype = 0;}
-		if (name.equals(&quot;picture&quot;)) 	{ state = STAT_PICTURE; }
-
-		//examine data
-		switch (state) {
-		case STAT_CACHE: startCache(name, atts); break;
-		case STAT_CACHE_DESC: startCacheDesc(name, atts); break; 
-		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
-		case STAT_PICTURE: startPicture(name,atts); break;
-		}
-
-	}
-
-	public void endElement(String name){
-		//examine data
-		switch (state) {
-		case STAT_CACHE: endCache(name); break;
-		case STAT_CACHE_DESC: endCacheDesc(name);break;
-		case STAT_CACHE_LOG: endCacheLog(name); break;
-		case STAT_PICTURE: endPicture(name); break;
-		}
-
-		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		state = STAT_INIT;
-		if (name.equals(&quot;cachedesc&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;cachelog&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;picture&quot;)) 	state = STAT_INIT;
-
-	}
-
-	public void characters(char[] ch2,int start,int length){
-		String chars = new String(ch2,start,length);
-		strData += chars;
-		if (debugGPX) Vm.debug(strData);
-	}
-
-	private void startCache(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1609,&quot;Importing Cache:&quot;)+&quot; &quot; + numCacheImported + &quot;\n&quot;);
-		if(name.equals(&quot;id&quot;)){
-			cacheID = atts.getValue(&quot;id&quot;);
-		}
-		if(name.equals(&quot;type&quot;)){
-			holder.setType(CacheType.ocType2CwType(atts.getValue(&quot;id&quot;)));
-			return;
-		}
-		if(name.equals(&quot;status&quot;)){
-			if(atts.getValue(&quot;id&quot;).equals(&quot;1&quot;)) holder.setAvailable(true);
-			if(atts.getValue(&quot;id&quot;).equals(&quot;2&quot;)) holder.setAvailable(false);
-			if(atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) {
-				holder.setArchived(true);
-				holder.setAvailable(false);
-			}
-			if(atts.getValue(&quot;id&quot;).equals(&quot;4&quot;)) holder.setAvailable(false);
-			return;
-		}
-		if(name.equals(&quot;size&quot;)){
-			holder.setCacheSize(CacheSize.ocXmlString2Cw(atts.getValue(&quot;id&quot;)));
-			return;
-		}
-
-		if(name.equals(&quot;waypoints&quot;)){
-			holder.setWayPoint(atts.getValue(&quot;oc&quot;));
-			if (holder.getWayPoint().length()==0) throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
-			return;
-		}
-
-	}
-	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported);
-		if (name.equals(&quot;cachedesc&quot;)){
-			ignoreDesc = false;
-		}
-
-		if (name.equals(&quot;desc&quot;)){
-			holder.setHTML(atts.getValue(&quot;html&quot;).equals(&quot;1&quot;)?true:false);
-		}
-
-		if (name.equals(&quot;language&quot;) &amp;&amp; !atts.getValue(&quot;id&quot;).equals(&quot;DE&quot;)){
-			if (holder.getFreshDetails().LongDescription.length()&gt; 0) ignoreDesc = true; // TODO &quot;DE&quot; in preferences adjustable
-			else ignoreDesc = false;
-		}
-	}
-
-	private void startPicture(String name, AttributeList atts){
-		if(name.equals(&quot;picture&quot;)){
-			inf.setInfo(MyLocale.getMsg(1613,&quot;Pictures:&quot;)+&quot; &quot; + ++picCnt);
-		}
-	}
-
-	private void startCacheLog(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1612,&quot;Importing Cachlog:&quot;)+&quot; &quot; + numLogImported);
-		if (name.equals(&quot;logtype&quot;)){
-			logtype = Convert.toInt(atts.getValue(&quot;id&quot;));
-			switch (logtype) {
-			case 1: 
-				logIcon = GPXImporter.typeText2Image(&quot;Found&quot;);
-				break;
-			case 2:	logIcon = GPXImporter.typeText2Image(&quot;Not Found&quot;); 
-			holder.setNoFindLogs((byte)(holder.getNoFindLogs()+1));
-			break;
-			case 3: logIcon = GPXImporter.typeText2Image(&quot;Note&quot;);
-			}
-			loggerRecommended = atts.getValue(&quot;recommended&quot;).equals(&quot;1&quot;);
-			return;
-		}
-		
-		if (name.equals(&quot;id&quot;)){
-			logId = atts.getValue(&quot;id&quot;);
-		}
-	}
-
-	// TODO Do we have to release the &quot;holder&quot; cache details ?
-	private void endCache(String name){
-		if (name.equals(&quot;cache&quot;)){
-			holder.setLastSync(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
-			int index;
-			index = cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){
-				holder.setNew(true);
-				cacheDB.add(holder);
-				Integer indexInt = new Integer(cacheDB.size()-1);
-				DBindexID.put(holder.getOcCacheID(), indexInt);
-			}
-			// update (overwrite) data
-			else {
-				holder.setNew(false);
-				holder.setIncomplete(false);
-				cacheDB.get(index).update(holder);
-				// save ocCacheID, in case, the previous data is from GPX
-				DBindexID.put(holder.getOcCacheID(), new Integer(index));
-			}
-			// clear data (picture, logs) if we do a complete Update
-			if (incUpdate == false){
-				holder.getFreshDetails().CacheLogs.clear();
-				holder.getFreshDetails().Images.clear();
-				holder.getFreshDetails().ImagesText.clear();
-				holder.getFreshDetails().ImagesInfo.clear();
-			}
-
-			// save all
-			holder.getFreshDetails().hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
-			// chD.saveCacheDetails(profile.dataDir); 
-			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
-			return;
-		}
-		if(name.equals(&quot;id&quot;)){ // &lt;/id&gt;
-			holder = getHolder(strData); // Allocate a new CacheHolder object
-			holder.setOcCacheID(strData);
-			holder.getFreshDetails().URL = ocSeekUrl + cacheID;
-			return;
-		}
-
-		if(name.equals(&quot;name&quot;)){
-			holder.setCacheName(strData);
-			return;
-		}
-		if(name.equals(&quot;userid&quot;)) {
-			holder.setCacheOwner(strData);
-			if(holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) holder.setOwned(true);
-			return;
-		}
-
-		if(name.equals(&quot;longitude&quot;)){
-			longitude = Common.parseDouble(strData);
-			return;
-		}
-		if(name.equals(&quot;latitude&quot;)) {
-			holder.pos.set(Common.parseDouble(strData),longitude);
-			holder.LatLon = holder.pos.toString();
-			return;
-		}
-		if(name.equals(&quot;difficulty&quot;)) {
-			holder.setHard(CacheTerrDiff.v1Converter(strData));
-			return;
-		}
-		if(name.equals(&quot;terrain&quot;)) {
-			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
-			return;
-		}
-		if(name.equals(&quot;datehidden&quot;)) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
-			return;
-		}
-		if (name.equals(&quot;country&quot;)){
-			holder.getFreshDetails().Country = strData;
-			return;
-		}
-	}
-
-	private void endCacheDesc(String name){
-
-		if (!ignoreDesc){
-			if (name.equals(&quot;cachedesc&quot;)){
-				if (pref.downloadPics &amp;&amp; holder.is_HTML()) {
-					String fetchUrl, imgTag, imgAltText;
-					Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); //  Ergebnis enth&#228;lt keine Anf&#252;hrungszeichen
-					Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;); // get alternative text for Pic
-					imgRegexAlt.setIgnoreCase(true);
-					imgRegexUrl.setIgnoreCase(true);
-					int descIndex=0;
-					int numDownloaded=1;
-					while (imgRegexUrl.searchFrom(holder.getFreshDetails().LongDescription, descIndex)) { // &quot;img&quot; found
-						imgTag=imgRegexUrl.stringMatched(1); // (1) enth&#228;lt das gesamte &lt;img ...&gt;-tag
-						fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anf&#252;hrungszeichen 
-						if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
-						if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-							inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot;+holder.getWayPoint()));
-							continue;
-						}
-						inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported + &quot;\n&quot;+MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
-						if (imgRegexAlt.search(imgTag)) {
-							imgAltText=imgRegexAlt.stringMatched(1);
-							if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
-							// kein alternativer Text als Bild&#252;berschrift -&gt; Dateiname
-						} else { 
-							if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.de&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend 
-								imgAltText = new String(&quot;No image title&quot;);
-							else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf(&quot;/&quot;)+1);
-						}
-						descIndex = imgRegexUrl.matchedTo();
-						getPic(fetchUrl, imgAltText);
-					}
-				}
-				holder.getFreshDetails().hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
-				return;
-			}
-
-
-			if (name.equals(&quot;cacheid&quot;)){
-				// load cachedata
-				holder = getHolder(strData);
-				holder.setUpdated(true);
-				return;
-			}
-
-			if (name.equals(&quot;shortdesc&quot;)){
-				holder.getFreshDetails().LongDescription = strData;
-				return;
-			}
-
-			if (name.equals(&quot;desc&quot;)){ // &lt;/desc&gt;
-				if (holder.is_HTML())	holder.getFreshDetails().LongDescription +=SafeXML.cleanback(strData);
-				else holder.getFreshDetails().LongDescription +=strData;
-				return;
-			}
-			if (name.equals(&quot;hint&quot;)){
-				holder.getFreshDetails().Hints = Common.rot13(strData);
-				return;
-			}
-		}
-	}
-
-	private String createPicFilename(String fetchURL) {
-		String fileName = holder.getWayPoint() + &quot;_&quot; + fetchURL.substring(fetchURL.lastIndexOf(&quot;/&quot;)+1);
-		return Common.ClearForFileName(fileName);
-	}
-	
-	private void getPic(String fetchURL, String picDesc) { // TODO handling of relativ URLs
-		try {
-			if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST+&quot;/&quot;), fetchURL).toString(); // TODO this is not quite correct: actually the &quot;base&quot; URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
-			String fileName = createPicFilename(fetchURL);
-			// add title
-			holder.getFreshDetails().ImagesText.add(picDesc);
-			holder.getFreshDetails().ImagesInfo.add(null); // need to stay in sync with ImagesText
-			try {
-				File ftest = new File(profile.dataDir + fileName);
-				if (ftest.exists()){
-					holder.getFreshDetails().Images.add(fileName);
-				}
-				else {
-					if (pref.downloadPics) {
-						holder.getFreshDetails().Images.add(fetch(fetchURL, fileName));
-					}
-				}
-			} catch (IOException e) {
-				String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+fetchURL); 
-				if (e.getMessage().toLowerCase().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+holder.getCacheName() + &quot; (&quot;+holder.getWayPoint()+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+fetchURL;
-				} 
-				inf.addWarning(&quot;\n&quot;+ErrMessage);
-				//(new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), ErrMessage, MessageBox.OKB)).exec();
-				pref.log(ErrMessage);
-				e.printStackTrace();
-			}
-		} catch (MalformedURLException e) {
-			String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchURL); 
-			inf.addWarning(&quot;\n&quot;+ErrMessage);
-			pref.log(ErrMessage);
-		}
-
-	}
-
-
-	private void endPicture(String name){
-
-		if(name.equals(&quot;id&quot;)){
-			picID = strData;
-			return;
-		}
-
-		if (name.equals(&quot;url&quot;)){
-			picUrl = strData;
-			return;
-		}
-		if (name.equals(&quot;title&quot;)){
-			picTitle = strData;
-			return;
-		}
-		if(name.equals(&quot;object&quot;)){
-			// get cachedata
-			holder = getHolder(strData);
-			return;
-		}
-		if(name.equals(&quot;picture&quot;)){ 
-			//String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
-			getPic(picUrl,picTitle);
-			holder.getFreshDetails().hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
-			return;
-		}
-	}
-
-	private void endCacheLog(String name){
-		if (name.equals(&quot;cachelog&quot;)){ // &lt;/cachelog&gt;
-			holder.getFreshDetails().CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
-			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1) {
-						holder.setCacheStatus(logDate);
-						holder.setFound(true);
-						holder.getFreshDetails().OwnLogId = logId;
-						holder.getFreshDetails().OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
-			}
-			holder.getFreshDetails().hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
-			return;
-		}
-
-		if (name.equals(&quot;cacheid&quot;)){ // &lt;/cacheid&gt;
-			// load cachedata
-			holder = getHolder(strData);
-			return;
-		}
-
-		if (name.equals(&quot;date&quot;))  {
-			logDate = new String(strData);
-			return;
-		}
-		if (name.equals(&quot;userid&quot;)){
-			logFinder = new String(strData);
-			return;
-		}
-		if (name.equals(&quot;text&quot;)){ 
-			logData = new String(strData);
-			return;
-		}
-
-	}
-
-	private String fetch(String addr, String fileName ) throws IOException
-	{
-		//Vm.debug(&quot;Redirect: &quot; + redirect);
-		CharArray realurl = new CharArray();
-		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
-		String address = realurl.toString();
-		if (holder != null) fileName = holder.getWayPoint() + &quot;_&quot; + Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
-		// else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
-
-		//save file
-		//Vm.debug(&quot;Save: &quot; + myPref.mydatadir + fileName);
-		//Vm.debug(&quot;Daten: &quot; + daten.length);
-		FileOutputStream outp =  new FileOutputStream(profile.dataDir + fileName);
-		outp.write(daten.toBytes());
-		outp.close();
-		return fileName;
-	}
-
-
-	/**
-	 * Method to iterate through cache database and look for cacheID.
-	 * Returns value &gt;= 0 if cacheID is found, else -1
-	 */
-	private int searchID(String cacxheID){
-		Integer INTR = (Integer)DBindexID.get(cacxheID);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-
-
-	private CacheHolder getHolder(String wpt){// See also LOCXMLImporter
-		CacheHolder chx;
-		int index;
-		
-		index = cacheDB.getIndex(wpt);
-		if (index == -1) index = searchID(wpt);
-		if (index == -1) {
-			chx = new CacheHolder();
-		} else {
-			chx = cacheDB.get(index);
-		}
-		return chx;
-	}
-
-}

Deleted: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,207 +0,0 @@
-/**
- * 
- */
-package CacheWolf;
-
-import CacheWolf.SpiderGC.SpiderProperties;
-import ewe.sys.Convert;
-import ewe.ui.*;
-
-/**
- * @author pfeffer
- * This Class is the Dialog for Download from Opencaching.de 
- * is called from OCXMLImporter
- * 20061209 Bugfix: Checking for uninitialised missingCheckBox
- */
-public class OCXMLImporterScreen extends Form {
-	mButton cancelB, okB;
-	Preferences pref;
-	mChoice chcType;
-	mInput distanceInput;
-	mInput maxNumberInput;
-	mInput maxLogsInput;
-	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox, travelbugsCheckBox;
-	mLabel distLbl;
-	mLabel maxNumberLbl;
-	mLabel distUnit;
-	boolean isGC = true;
-	static int DIST = 1;
-	static int IMAGES = 2;
-	static int ALL = 4;
-	static int INCLUDEFOUND = 8;
-	static int ISGC = 16;
-	static int MAXNUMBER = 32;
-	static int TRAVELBUGS = 64;
-	static int MAXLOGS = 128;
-	static int TYPE = 256;
-
-	
-	public OCXMLImporterScreen(String title, int options) {
-		super();
-		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
-		
-		isGC = ((options &amp; ISGC) &gt; 0);
-		
-		this.title = title;
-				
-		if ((options &amp; TYPE) &gt; 0) {
-			this.addLast( chcType = new mChoice(new String[] {
-					MyLocale.getMsg(1627,&quot;All caches&quot;),	
-					CacheType.CW_GUISTR_TRADI,
-					CacheType.CW_GUISTR_MULTI,
-					CacheType.CW_GUISTR_VIRTUAL,
-					CacheType.CW_GUISTR_LETTERBOX,
-					CacheType.CW_GUISTR_EVENT,
-					CacheType.CW_GUISTR_MEGAEVENT,
-					CacheType.CW_GUISTR_WEBCAM,
-					CacheType.CW_GUISTR_UNKNOWN,
-					CacheType.CW_GUISTR_CITO,
-					CacheType.CW_GUISTR_EARTH,
-					CacheType.CW_GUISTR_WHEREIGO
-				},0), CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
-		}
-
-		if ((options &amp; DIST) &gt; 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,&quot;Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			distanceInput = new mInput();
-			String dist1;
-			String dist2;
-			if (isGC) {
-				dist1 = Global.getProfile().getDistGC();
-				dist2 = Global.getProfile().getDistOC();
-			} else {
-				dist1 = Global.getProfile().getDistOC();
-				dist2 = Global.getProfile().getDistGC();
-			}
-			if ( dist1.equals(&quot;&quot;) || dist1.equals(&quot;0&quot;) || dist1.equals(&quot;0.0&quot;) ) {
-				dist1 = dist2;
-			}
-			distanceInput.setText(dist1);
-			this.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(distUnit = new mLabel(&quot; km/mi.&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		}
-		
-		if ((options &amp; MAXNUMBER) &gt; 0) {
-			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623,&quot;Max. number:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			maxNumberInput = new mInput();
-			if ( pref.maxSpiderNumber &lt; 0 ) {
-				maxNumberInput.setText(&quot;&quot;);
-			} else {
-				maxNumberInput.setText(Integer.toString(pref.maxSpiderNumber));
-			}
-			this.addNext(maxNumberInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast( new mLabel(MyLocale.getMsg(1624,&quot; caches&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		}
-		
-		if ((options &amp; MAXLOGS) &gt; 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1626,&quot;Max. logs:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			maxLogsInput = new mInput();
-			maxLogsInput.setText(Convert.toString(pref.maxLogsToSpider));
-			this.addLast(maxLogsInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		}
-
-		if ((options &amp; IMAGES) &gt; 0) {
-			imagesCheckBox = new mCheckBox();
-			imagesCheckBox.setText(MyLocale.getMsg(1602,&quot;Download Images&quot;));
-			imagesCheckBox.setState(pref.downloadPics);
-			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		}
-		
-		if ((options &amp; TRAVELBUGS) &gt; 0) {
-			travelbugsCheckBox = new mCheckBox();
-			travelbugsCheckBox.setText(MyLocale.getMsg(1625,&quot;Download TBs&quot;));
-			travelbugsCheckBox.setState(pref.downloadTBs);
-			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		}
-		
-		if((options &amp; INCLUDEFOUND) &gt; 0){
-			foundCheckBox = new mCheckBox();
-			foundCheckBox.setText(MyLocale.getMsg(1622,&quot;Exclude found caches&quot;));
-			foundCheckBox.setState(true);
-			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		}
-
-		if((options &amp; ALL) &gt; 0){
-			missingCheckBox = new mCheckBox();
-			missingCheckBox.setText(MyLocale.getMsg(1606,&quot;Alle erneut downloaden&quot;));
-			missingCheckBox.setState(pref.downloadmissingOC);
-			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		}
-
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
-		cancelB.setHotKey(0, IKeys.ESCAPE);
-		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okB = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
-		okB.setHotKey(0, IKeys.ACTION);
-		okB.setHotKey(0, IKeys.ENTER);
-		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
-				this.close(FormBase.IDCANCEL);
-			}
-			if (ev.target == okB){
-				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr&#252;ft werden kann, ob es gr&#246;&#223;er oder kleiner ist als vorher
-					if (imagesCheckBox!=null) pref.downloadPics = imagesCheckBox.state;
-					if (missingCheckBox!=null) pref.downloadmissingOC = missingCheckBox.state;
-					if (travelbugsCheckBox!=null) pref.downloadTBs = travelbugsCheckBox.state;
-					if (maxLogsInput!=null) pref.maxLogsToSpider=Common.parseInt(maxLogsInput.getText());
-					pref.savePreferences();
-				this.close(FormBase.IDOK);
-				}
-		}
-		super.onEvent(ev);
-	}
-	
-	public String getCacheTypeRestriction(SpiderProperties p){
-		String cacheTypeRestriction = &quot;&quot;;
-
-		if (chcType!=null){
-			try {
-				switch (chcType.getInt()) {
-				case  0:
-					cacheTypeRestriction = &quot;&quot;;
-					break;
-				case  1: 
-					cacheTypeRestriction = p.getProp(&quot;onlyTraditional&quot;);
-					break;
-				case  2:
-					cacheTypeRestriction = p.getProp(&quot;onlyMulti&quot;);
-					break;
-				case  3:
-					cacheTypeRestriction = p.getProp(&quot;onlyVirtual&quot;) ;
-					break;
-				case  4:
-					cacheTypeRestriction = p.getProp(&quot;onlyLetterboxHybrid&quot;);
-					break;
-				case  5:
-					cacheTypeRestriction = p.getProp(&quot;onlyEvent&quot;);
-					break;
-				case  6:
-					cacheTypeRestriction = p.getProp(&quot;onlyMegaEvent&quot;);
-					break;
-				case  7:
-					cacheTypeRestriction = p.getProp(&quot;onlyWebcam&quot;);
-					break;
-				case  8:
-					cacheTypeRestriction = p.getProp(&quot;onlyUnknown&quot;);
-					break;
-				case 9:
-					cacheTypeRestriction = p.getProp(&quot;onlyCito&quot;);
-					break;
-				case 10:
-					cacheTypeRestriction = p.getProp(&quot;onlyEarth&quot;);
-					break;
-				case 11:
-					cacheTypeRestriction = p.getProp(&quot;onlyWherigo&quot;);
-					break;
-				default:
-					cacheTypeRestriction = &quot;&quot;;
-				}
-			}catch (Exception ex) { // Some tag missing from spider.def
-			}
-		}
-		return cacheTypeRestriction;
-	}
-}

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/Preferences.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import CacheWolf.imp.SpiderGC;
 import CacheWolf.navi.Metrics;
 import utils.FileBugfix;
 import ewe.io.*;

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import CacheWolf.imp.SpiderGC;
 import CacheWolf.navi.Metrics;
 import utils.FileBugfix;
 import ewe.ui.*;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/Profile.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -364,7 +364,7 @@
 	 *  Called from Main Form and MainMenu 
 	 *  The values of Filter.isActive and Filter.isInactive are set by the filter 
 	 **/
-	void restoreFilter() {
+	public void restoreFilter() {
 		restoreFilter( true );		
 	}
 	

Deleted: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -1,1676 +0,0 @@
-/*
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
-
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-		<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
-
-package CacheWolf;
-import ewe.net.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.sys.Double;
-import ewe.util.*;
-import CacheWolf.navi.Metrics;
-
-import com.stevesoft.ewe_pat.*;
-import ewe.ui.*;
-import ewe.data.Property;
-import ewe.data.PropertyList;
-
-/**
-*	Class to spider caches from gc.com
-*/
-public class SpiderGC{
-
-	/**
-	 * The maximum number of logs that will be stored
-	 */
-	public static int MAXLOGS=250; // Can be pre-set from preferences
-	public static String passwort = &quot;&quot;; // Can be pre-set from preferences
-	public static boolean loggedIn = false;
-
-	private static int ERR_LOGIN = -10;
-	private static Preferences pref;
-	private Profile profile;
-	private static String viewstate = &quot;&quot;;
-	private static String viewstate1 = &quot;&quot;;
-	private static String eventvalidation = &quot;&quot;;
-	private static String cookieID = &quot;&quot;;
-	private static String cookieSession = &quot;&quot;;
-	private static double distance = 0;
-	private Regex inRex = new Regex();
-	private CacheDB cacheDB;
-	private Vector cachesToLoad = new Vector();
-	private InfoBox infB;
-	private static SpiderProperties p=null;
-
-	public SpiderGC(Preferences prf, Profile profile, boolean bypass){
-		this.profile=profile;
-		this.cacheDB = profile.cacheDB;
-		pref = prf;
-		if (p==null) {
-			pref.logInit();
-			p=new SpiderProperties();
-		}
-		MAXLOGS=pref.maxLogsToSpider;
-	}
-
-	/**
-	 * Method to login the user to gc.com
-	 * It will request a password and use the alias defined in preferences
-	 * If the login page cannot be fetched, the password is cleared.
-	 * If the login fails, an appropriate message is displayed.
-	 */
-	public int login(){
-		loggedIn = false;
-		String start,loginPage,loginSuccess,nextPage;
-		try {
-			loginPage=p.getProp(&quot;loginPage&quot;);
-			loginSuccess=p.getProp(&quot;loginSuccess&quot;);
-			nextPage=p.getProp(&quot;nextPage&quot;);
-		} catch (Exception ex) { // Tag not found in spider.def
-			return ERR_LOGIN;
-		}
-		//Get password
-		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506,&quot;Password&quot;), MyLocale.getMsg(5505,&quot;Enter Password&quot;), InfoBox.INPUT);
-		localInfB.feedback.setText(passwort); // Remember the PWD for next time
-		localInfB.feedback.isPassword=true;
-		int code=FormBase.IDOK;
-		if (passwort.equals(&quot;&quot;)) {
-			code = localInfB.execute();
-			passwort = localInfB.getInput();
-		}
-		localInfB.close(0);
-		if(code != FormBase.IDOK) return code;
-		// Now start the login proper
-		localInfB = new InfoBox(MyLocale.getMsg(5507,&quot;Status&quot;), MyLocale.getMsg(5508,&quot;Logging in...&quot;));
-		localInfB.exec();
-		try{
-			pref.log(&quot;[login]:Fetching login page&quot;);
-			//Access the page once to get a viewstate
-			start = fetch(loginPage);   //<A HREF="http://www.geocaching.com/login/Default.aspx">http://www.geocaching.com/login/Default.aspx</A>
-			if (start.equals(&quot;&quot;)) {
-				localInfB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
-				pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;);
-				return ERR_LOGIN;
-			}
-		} catch(Exception ex){
-			localInfB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
-			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;,ex);
-			return ERR_LOGIN;
-		}
-		if (!localInfB.isClosed) { // If user has not aborted, we continue
-			Regex rexCookieID = new Regex(&quot;(?i)Set-Cookie: userid=(.*?);.*&quot;);
-			Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			Regex rexCookieSession = new Regex(&quot;(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*&quot;);
-			rexViewstate.search(start);
-			if(rexViewstate.didMatch()){
-				viewstate = rexViewstate.stringMatched(1);
-				//Vm.debug(&quot;ViewState: &quot; + viewstate);
-			} else
-				pref.log(&quot;[login]:Viewstate not found before login&quot;);
-
-			if(start.indexOf(loginSuccess) &gt; 0)
-				pref.log(&quot;[login]:Already logged in&quot;);
-			else {
-				rexEventvalidation.search(start);
-				if(rexEventvalidation.didMatch()){
-					eventvalidation = rexEventvalidation.stringMatched(1);
-					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
-				} else
-					pref.log(&quot;[login]:Eventvalidation not found before login&quot;);
-				//Ok now login!
-				try{
-					pref.log(&quot;[login]:Logging in as &quot;+pref.myAlias);
-					StringBuffer sb=new StringBuffer(1000);
-					sb.append(URL.encodeURL(&quot;__VIEWSTATE&quot;,false));	sb.append(&quot;=&quot;); sb.append(URL.encodeURL(viewstate,false));
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;myUsername&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;myPassword&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;cookie&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;on&quot;,false));
-					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;Button1&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;Login&quot;,false));
-//					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false));
-//					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(eventvalidation,false));
-					start = fetch_post(loginPage, sb.toString(), nextPage);  // /login/default.aspx
-					if(start.indexOf(loginSuccess) &gt; 0)
-						pref.log(&quot;[login]:Login successful&quot;);
-					else {
-						pref.log(&quot;[login]:Login failed. Wrong Account or Password?&quot;);
-						if (pref.debug) {
-							pref.log(&quot;[login.LoginUrl]:&quot;+sb.toString());
-							pref.log(&quot;[login.Answer]:&quot;+start);
-						}
-						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
-						return ERR_LOGIN;
-					}
-				}catch(Exception ex){
-					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
-					localInfB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
-					return ERR_LOGIN;
-				}
-			}
-
-			rexViewstate.search(start);
-			if (!rexViewstate.didMatch()) {
-				pref.log(&quot;[login]:Viewstate not found&quot;);
-			}
-			viewstate = rexViewstate.stringMatched(1);
-
-			rexViewstate1.search(start);
-			if (!rexViewstate1.didMatch()) {
-				pref.log(&quot;[login]:Viewstate1 not found&quot;);
-			}
-			viewstate1 = rexViewstate1.stringMatched(1);
-
-			rexCookieID.search(start);
-			if (!rexCookieID.didMatch()) {
-				pref.log(&quot;[login]:CookieID not found. Using old one.&quot;);
-			} else
-				cookieID = rexCookieID.stringMatched(1);
-			//Vm.debug(cookieID);
-			rexCookieSession.search(start);
-			if (!rexCookieSession.didMatch()) {
-				pref.log(&quot;[login]:CookieSession not found. Using old one.&quot;);
-				//cookieSession=&quot;&quot;;
-			} else
-				cookieSession = rexCookieSession.stringMatched(1);
-			//Vm.debug(&quot;cookieSession = &quot; + cookieSession);
-		}
-		boolean loginAborted=localInfB.isClosed;
-		localInfB.close(0);
-		if (loginAborted)
-			return FormBase.IDCANCEL;
-		else {
-			loggedIn = true;
-			return FormBase.IDOK;
-		}
-	}
-
-	/**
-	 * Method to spider a single cache.
-	 * It assumes a login has already been performed!
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
-	 */
-	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin){
-		int ret=-1;
-		this.infB = pInfB;
-		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
-		ch.setWayPoint(cacheDB.get(number).getWayPoint());
-		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
-
-		// check if we need to login
-		if (!loggedIn || forceLogin){
-			if (this.login()!=FormBase.IDOK) return -1;
-			// loggedIn is already set by this.login()
-		}
-		try{
-			// Read the cache data from GC.COM and compare to old data
-			boolean loadAllLogs = (MAXLOGS &gt; 5);
-			ret=getCacheByWaypointName(ch,true,pref.downloadPics,pref.downloadTBs,false,loadAllLogs);
-			// Save the spidered data
-			if (ret == 1) {
-				CacheHolder cacheInDB = cacheDB.get(number);
-				cacheInDB.initStates(false);
-				if (cacheInDB.is_found() &amp;&amp; !ch.is_found() &amp;&amp; ! loadAllLogs) {
-					// If the number of logs to spider is 5 or less, then the &quot;not found&quot; information
-					// of the spidered cache is not credible. In this case it should not overwrite
-					// the &quot;found&quot; state of an existing cache.
-					ch.setFound(true);
-				}
-				cacheInDB.update(ch);
-				cacheInDB.save();
-			}
-		}catch(Exception ex){
-			pref.log(&quot;Error spidering &quot; + ch.getWayPoint() + &quot; in spiderSingle&quot;);
-		}
-		return ret;
-	} // spiderSingle
-
-	/**
-	 * Fetch the coordinates of a waypoint from GC
-	 * @param wayPoint the name of the waypoint
-	 * @return the cache coordinates
-	 */
-	public String getCacheCoordinates(String wayPoint) {
-		String completeWebPage;
-		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
-		// Try to login. If login fails, issue appropriate message and terminate
-		if (!loggedIn || Global.getPref().forceLogin) {
-			if (login()!=FormBase.IDOK) {
-				return &quot;&quot;;
-			}
-		}
-		InfoBox localInfB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
-		localInfB.exec();
-		try{
-			String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
-			pref.log(&quot;Fetching: &quot; + wayPoint);
-			completeWebPage = fetch(doc);
-		}catch(Exception ex){
-			localInfB.close(0);
-			pref.log(&quot;Could not fetch &quot; + wayPoint,ex);
-			return &quot;&quot;;
-		}
-		localInfB.close(0);
-		try {
-			return getLatLon(completeWebPage);
-		} catch (Exception ex) {
-			return &quot;????&quot;;
-		}
-	}
-
-	/**
-	*	Method to start the spider for a search around the centre coordinates
-	*/
-	public void doIt(){
-		doIt(false);
-	}
-	public void doIt(boolean spiderAllFinds){
-		String postStr, dummy, ln, wpt;
-		Regex lineRex;
-		CacheHolder holder;
-		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
-		if ( !spiderAllFinds &amp;&amp; !origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
-			return;
-		}
-		if (System.getProperty(&quot;os.name&quot;)!=null)pref.log(&quot;Operating system: &quot;+System.getProperty(&quot;os.name&quot;)+&quot;/&quot;+System.getProperty(&quot;os.arch&quot;));
-		if (System.getProperty(&quot;java.vendor&quot;)!=null)pref.log(&quot;Java: &quot;+System.getProperty(&quot;java.vendor&quot;)+&quot;/&quot;+System.getProperty(&quot;java.version&quot;));
-		CacheHolder ch;
-		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = cacheDB.get(i);
-			if (ch.mainCache==null) ch.initStates(false);
-		}
-		String start = &quot;&quot;;
-		Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
-		Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
-		Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
-		String doc = &quot;&quot;;
-
-		if (!loggedIn || Global.getPref().forceLogin) {
-			if(login() != FormBase.IDOK) return;
-		}
-
-		boolean doNotgetFound = false;
-
-		OCXMLImporterScreen options;
-		if (spiderAllFinds) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;), OCXMLImporterScreen.MAXNUMBER|OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC| OCXMLImporterScreen.TRAVELBUGS| OCXMLImporterScreen.MAXLOGS| OCXMLImporterScreen.TYPE);
-			if (options.execute() == FormBase.IDCANCEL) {return; }
-
-			distance = 1;
-		} else {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;),	OCXMLImporterScreen.MAXNUMBER|OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.DIST| OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC| OCXMLImporterScreen.TRAVELBUGS| OCXMLImporterScreen.MAXLOGS| OCXMLImporterScreen.TYPE);
-			if (options.execute() == FormBase.IDCANCEL) {return; }
-			String dist = options.distanceInput.getText();
-			if (dist.length()== 0) return;
-			distance = Common.parseDouble(dist);
-
-			//save last radius to profile
-			Double distDouble = new Double();
-			distDouble.value = distance;
-			dist = distDouble.toString(0, 1, 0).replace(',', '.');
-			profile.setDistGC(dist);
-
-			doNotgetFound = options.foundCheckBox.getState();
-		}
-
-		int maxNumber = -1;
-		String maxNumberString = options.maxNumberInput.getText();
-		if (maxNumberString.length()!= 0) {
-			maxNumber = Common.parseInt(maxNumberString);
-		}
-		if (maxNumber != pref.maxSpiderNumber) {
-			pref.maxSpiderNumber = maxNumber;
-			pref.savePreferences();
-		}
-		if (maxNumber == 0) return;
-		boolean maxNumberAbort = false;
-
-		boolean getImages = options.imagesCheckBox.getState();
-		boolean getTBs = options.travelbugsCheckBox.getState();
-
-		String cacheTypeRestriction = options.getCacheTypeRestriction(p);
-
-		options.close(0);
-
-		//max distance in miles for URL, so we can get more than 80km
-		double saveDistanceInMiles = distance;
-		if ( Global.getPref().metricSystem != Metrics.IMPERIAL ) {
-			saveDistanceInMiles = Metrics.convertUnit(distance, Metrics.KILOMETER, Metrics.MILES);
-		}
-		// add a mile to be save from different distance calculations in CW and at GC
-		saveDistanceInMiles = java.lang.Math.ceil(saveDistanceInMiles) + 1;
-
-		Hashtable cachesToUpdate = new Hashtable(cacheDB.size());
-		double distanceInKm = distance;
-		if ( Global.getPref().metricSystem == Metrics.IMPERIAL ) {
-			distanceInKm = Metrics.convertUnit(distance, Metrics.MILES, Metrics.KILOMETER);
-		}
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = cacheDB.get(i);
-			if (spiderAllFinds) {
-				if ( (ch.getWayPoint().substring(0,2).equalsIgnoreCase(&quot;GC&quot;)) ) {
-					cachesToUpdate.put(ch.getWayPoint(), ch);
-				}
-			} else {
-				if ( (!ch.is_archived()) &amp;&amp; (ch.kilom &lt;= distanceInKm) &amp;&amp; !(doNotgetFound &amp;&amp; ch.is_found()) &amp;&amp; (ch.getWayPoint().substring(0,2).equalsIgnoreCase(&quot;GC&quot;)) ) {
-					cachesToUpdate.put(ch.getWayPoint(), ch);
-				}
-			}
-		}
-
-		//=======
-		// Prepare list of all caches that are to be spidered
-		//=======
-		Vm.showWait(true);
-		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502,&quot;Fetching first page...&quot;));
-		infB.exec();
-		//Get first page
-		try{
-			if (spiderAllFinds) {
-				ln = p.getProp(&quot;firstPageFinds&quot;) + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias));
-			} else {
-				ln = p.getProp(&quot;firstPage&quot;) + origin.getLatDeg(CWPoint.DD) + p.getProp(&quot;firstPage2&quot;) + origin.getLonDeg(CWPoint.DD)
-			                              + p.getProp(&quot;maxDistance&quot;) + Integer.toString( (int)saveDistanceInMiles );
-				if(doNotgetFound) ln = ln + p.getProp(&quot;showOnlyFound&quot;);
-			}
-			ln = ln + cacheTypeRestriction;
-			pref.log(&quot;Getting first page: &quot;+ln);
-			start = fetch(ln);
-			pref.log(&quot;Got first page&quot;);
-		}catch(Exception ex){
-			pref.log(&quot;Error fetching first list page&quot;,ex,true);
-			Vm.showWait(false);
-			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5503,&quot;Error fetching first list page.&quot;), FormBase.OKB)).execute();
-			return;
-		}
-		dummy = &quot;&quot;;
-		//String lineBlck = &quot;&quot;;
-		int page_number = 4;
-		try  {
-			lineRex = new Regex(p.getProp(&quot;lineRex&quot;)); //&quot;&lt;tr bgcolor=((?s).*?)&lt;/tr&gt;&quot;
-		} catch (Exception ex) {
-			infB.close(0);
-			Vm.showWait(false);
-			return;
-		}
-		int page = 0;
-		int found_on_page = 0;
-		try {
-			//Loop till maximum distance has been found or no more caches are in the list
-			while(distance &gt; 0){
-				if (infB.isClosed) break;
-
-				rexViewstate.search(start);
-				if(rexViewstate.didMatch()){
-					viewstate = rexViewstate.stringMatched(1);
-					//Vm.debug(&quot;ViewState: &quot; + viewstate);
-				} else {
-					viewstate = &quot;&quot;;
-					pref.log(&quot;Viewstate not found&quot;);
-				}
-
-				rexViewstate1.search(start);
-				if(rexViewstate1.didMatch()){
-					viewstate1 = rexViewstate1.stringMatched(1);
-					//Vm.debug(&quot;ViewState: &quot; + viewstate);
-				} else {
-					viewstate1 = &quot;&quot;;
-					pref.log(&quot;Viewstate1 not found&quot;);
-				}
-
-				rexEventvalidation.search(start);
-				if(rexEventvalidation.didMatch()){
-					eventvalidation = rexEventvalidation.stringMatched(1);
-					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
-				} else {
-					eventvalidation = &quot;&quot;;
-					pref.log(&quot;Eventvalidation not found&quot;);
-				}
-
-				//Vm.debug(&quot;In loop&quot;);
-				Regex listBlockRex = new Regex(p.getProp(&quot;listBlockRex&quot;)); // &quot;&lt;table id=\&quot;dlResults\&quot;((?s).*?)&lt;/table&gt;&quot;
-				listBlockRex.search(start);
-				dummy = listBlockRex.stringMatched(1);
-				try{
-					lineRex.search(dummy);
-				}catch(NullPointerException nex){
-					Global.getPref().log(&quot;Ignored Exception&quot;, nex, true);
-				}
-				while(lineRex.didMatch()){
-					//Vm.debug(getDist(lineRex.stringMatched(1)) + &quot; / &quot; +getWP(lineRex.stringMatched(1)));
-					found_on_page++;
-					if(getDist(lineRex.stringMatched(1)) &lt;= distance){
-						String waypoint=getWP(lineRex.stringMatched(1));
-						CacheHolder existingCache;
-						if((existingCache=cacheDB.get(waypoint)) == null){
-							if ( (maxNumber &gt; 0) &amp;&amp; (cachesToLoad.size() &gt;= maxNumber) ) {
-								maxNumberAbort = true;
-
-								//add no more caches
-								distance = 0;
-
-								//don't update existing caches, because list is not correct when aborting
-								cachesToUpdate.clear();
-							} else {
-								cachesToLoad.add(waypoint);
-							}
-						} else {
-							pref.log(waypoint+&quot; already in DB&quot;);
-							ch=existingCache;
-							// If the &lt;strike&gt; tag is used, the cache is marked as unavailable or archived
-							boolean is_archived_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&lt;font color=\&quot;red\&quot;&gt;&quot;)!=-1;
-							boolean is_available_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&quot;)==-1;
-							if (ch.is_archived()!=is_archived_GC) { // Update the database with the cache status
-								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_archived_GC?&quot;archived&quot;:&quot;not archived&quot;));
-								if ( ch.is_archived() ) {
-									cachesToUpdate.put(ch.getWayPoint(), ch);
-								}
-								ch.setArchived(is_archived_GC);
-							} else if (ch.is_available()!=is_available_GC) { // Update the database with the cache status
-								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_available_GC?&quot;available&quot;:&quot;not available&quot;));
-								ch.setAvailable(is_available_GC);
-							} else if (spiderAllFinds &amp;&amp; !ch.is_found()) { // Update the database with the cache status
-								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to found&quot;);
-								ch.setFound(true);
-							} else {
-								cachesToUpdate.remove( ch.getWayPoint() );
-							}
-						}
-					} else distance = 0;
-					lineRex.searchFrom(dummy, lineRex.matchedTo());
-				}
-
-				page++;
-				infB.setInfo(MyLocale.getMsg(5521,&quot;Page &quot;) + page + &quot;\n&quot; + MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
-
-				if(found_on_page &lt; 20) distance = 0;
-				if (spiderAllFinds) {
-					postStr = p.getProp(&quot;firstLine&quot;);
-				} else {
-					postStr = p.getProp(&quot;firstLine&quot;) + origin.getLatDeg(CWPoint.DD) + &quot;&amp;&quot; + origin.getLonDeg(CWPoint.DD)
-							                             + p.getProp(&quot;maxDistance&quot;) + Integer.toString( (int)saveDistanceInMiles );
-					if(doNotgetFound) postStr = postStr + p.getProp(&quot;showOnlyFound&quot;);
-				}
-				postStr = postStr + cacheTypeRestriction;
-				if(distance &gt; 0){
-					page_number++;
-					if(page_number &gt;= 15) page_number = 5;
-					String strNextPage;
-					if (page_number &lt; 10) {
-						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl0&quot; + page_number;
-					} else {
-						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl&quot; + page_number;
-					}
-					doc = URL.encodeURL(&quot;__EVENTTARGET&quot;,false) +&quot;=&quot;+ URL.encodeURL(strNextPage,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTARGUMENT&quot;,false) +&quot;=&quot;+ URL.encodeURL(&quot;&quot;,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATEFIELDCOUNT&quot;,false) +&quot;=2&quot;
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE1&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate1,false);
-//					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false) +&quot;=&quot;+ URL.encodeURL(eventvalidation,false);
-					try{
-						start = &quot;&quot;;
-						pref.log(&quot;Fetching next list page:&quot; + doc);
-						start = fetch_post(postStr, doc, p.getProp(&quot;nextListPage&quot;));
-					}catch(Exception ex){
-						//Vm.debug(&quot;Couldn't get the next page&quot;);
-						pref.log(&quot;Error getting next page&quot;);
-					}
-				}
-				//Vm.debug(&quot;Distance is now: &quot; + distance);
-				found_on_page = 0;
-			}
-		} catch (Exception ex) { // Some tag missing from spider.def
-			infB.close(0);
-			Vm.showWait(false);
-			return;
-		}
-		pref.log(&quot;Found &quot; + cachesToLoad.size() + &quot; new caches&quot;);
-		pref.log(&quot;Found &quot; + cachesToUpdate.size() + &quot; caches for update&quot;);
-		if (!infB.isClosed) infB.setInfo(MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
-
-		//=======
-		// Now ready to spider each cache in the list
-		//=======
-		boolean loadAllLogs = (MAXLOGS &gt; 5);
-
-		int spiderErrors = 0;
-
-		if ( cachesToUpdate.size() &gt; 0 ) {
-			switch (pref.spiderUpdates) {
-			case Preferences.NO:
-				cachesToUpdate.clear();
-				break;
-			case Preferences.ASK:
-				MessageBox mBox = new MessageBox(MyLocale.getMsg(5517,&quot;Spider Updates?&quot;), cachesToUpdate.size() + MyLocale.getMsg(5518,&quot; caches in database need an update. Update now?&quot;) , FormBase.IDYES |FormBase.IDNO);
-				if (mBox.execute() != FormBase.IDOK){
-					cachesToUpdate.clear();
-				}
-				break;
-			}
-		}
-
-		int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
-
-		for(int i = 0; i&lt;cachesToLoad.size(); i++){
-			if (infB.isClosed) break;
-
-			wpt = (String)cachesToLoad.get(i);
-			// Get only caches not already available in the DB
-			if(cacheDB.getIndex(wpt) == -1){
-				infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + wpt +&quot; (&quot; + (i+1) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
-				holder = new CacheHolder();
-				holder.setWayPoint(wpt);
-				int test = getCacheByWaypointName(holder,false,getImages,getTBs,doNotgetFound,loadAllLogs);
-				if (test == -1) {
-					infB.close(0);
-					break;
-				} else if (test == 0) {
-					spiderErrors++;
-				} else {
-					if (!holder.is_found() || !doNotgetFound ) {
-						cacheDB.add(holder);
-						holder.save();
-					}
-				}
-			}
-		}
-
-		if (!infB.isClosed) {
-			int j = 1;
-			for (Enumeration e = cachesToUpdate.elements() ; e.hasMoreElements() ; j++) {
-				ch = (CacheHolder)e.nextElement();
-				infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + ch.getWayPoint() +&quot; (&quot; + (cachesToLoad.size()+j) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
-				infB.redisplay();
-
-				int test = spiderSingle(cacheDB.getIndex(ch), infB,false);
-				if (test == -1) {
-					break;
-				} else if (test == 0) {
-					spiderErrors++;
-				} else {
-					//profile.hasUnsavedChanges=true;
-				}
-			}
-		}
-
-		infB.close(0);
-		Vm.showWait(false);
-		if ( spiderErrors &gt; 0) {
-			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
-		}
-		if ( maxNumberAbort ) {
-			new MessageBox(MyLocale.getMsg(5519,&quot;Information&quot;),MyLocale.getMsg(5520,&quot;Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated.&quot;),FormBase.DEFOKB).execute();
-		}
-		Global.getProfile().restoreFilter();
-		Global.getProfile().saveIndex(Global.getPref(),true);
-	}
-
-	/**
-	 * Read a complete cachepage from geocaching.com including all logs. This is used both when
-	 * updating already existing caches (via spiderSingle) and when spidering around a centre. It
-	 * is also used when reading a GPX file and fetching the images.
-	 *
-	 * This is the workhorse function of the spider.
-	 *
-	 * @param CacheHolderDetail chD The element wayPoint must be set to the name of a waypoint
-	 * @param boolean isUpdate True if an existing cache is being updated, false if it is a new cache
-	 * @param boolean fetchImages True if the pictures are to be fetched
-	 * @param boolean fetchTBs True if the TBs are to be fetched
-	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
-	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line).
-	 *     This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
-	 */
-	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean fetchTBs, boolean doNotGetFound, boolean fetchAllLogs) {
-		int ret = 1;
-		while (true) {
-			String completeWebPage;
-			int spiderTrys=0;
-			int MAX_SPIDER_TRYS=3;
-			while (spiderTrys++&lt;MAX_SPIDER_TRYS) {
-				ret = 1;
-				try{
-					String doc = p.getProp(&quot;getPageByName&quot;) + ch.getWayPoint() +(fetchAllLogs?p.getProp(&quot;fetchAllLogs&quot;):&quot;&quot;);
-					pref.log(&quot;Fetching: &quot; + ch.getWayPoint());
-					completeWebPage = fetch(doc);
-					if	( completeWebPage.equals(&quot;&quot;)) {
-						pref.log(&quot;Could not fetch &quot; + ch.getWayPoint());
-						if (!infB.isClosed) {
-							continue;
-						} else {
-							ch.setIncomplete(true);
-							return -1;
-						}
-					}
-				}catch(Exception ex){
-					pref.log(&quot;Could not fetch &quot; + ch.getWayPoint(),ex);
-					if (!infB.isClosed) {
-						continue;
-					} else {
-						ch.setIncomplete(true);
-						return -1;
-					}
-				}
-				// Only analyse the cache data and fetch pictures if user has not closed the progress window
-				if (!infB.isClosed) {
-					try{
-						ch.initStates(!isUpdate);
-
-						//first check if coordinates are available to prevent deleting existing coorinates
-						String latLon = getLatLon(completeWebPage);
-						if (latLon.equals(&quot;???&quot;)) {
-							pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot;);
-							ret = 0;
-							continue; // Restart the spider
-						}
-
-						ch.setHTML(true);
-						ch.setAvailable(true);
-						ch.setArchived(false);
-						ch.setIncomplete(true);
-						// Save size of logs to be able to check whether any new logs were added
-						//int logsz = chD.CacheLogs.size();
-						//chD.CacheLogs.clear();
-						ch.addiWpts.clear();
-						ch.getFreshDetails().Images.clear();
-						ch.getFreshDetails().ImagesText.clear();
-						ch.getFreshDetails().ImagesInfo.clear();
-
-						if(completeWebPage.indexOf(p.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0) ch.setAvailable(false);
-						if(completeWebPage.indexOf(p.getProp(&quot;cacheArchived&quot;)) &gt;= 0) ch.setArchived(true);
-						//==========
-						// General Cache Data
-						//==========
-						ch.setLatLon(latLon);
-						pref.log(&quot;LatLon: &quot; + ch.LatLon);
-						if (pref.debug) pref.log(&quot;chD.pos: &quot; + ch.pos.toString());
-
-						pref.log(&quot;Trying description&quot;);
-						ch.getFreshDetails().setLongDescription(getLongDesc(completeWebPage));
-						pref.log(&quot;Got description&quot;);
-
-						pref.log(&quot;Getting cache name&quot;);
-						ch.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
-						if (pref.debug) pref.log(&quot;Name: &quot; + ch.getCacheName()); else pref.log(&quot;Got name&quot;);
-
-						pref.log(&quot;Trying location (country/state)&quot;);
-						String location = getLocation(completeWebPage);
-						if (location.length() != 0) {
-							int countryStart = location.indexOf(&quot;,&quot;);
-							if (countryStart &gt; -1) {
-								ch.getFreshDetails().Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
-								ch.getFreshDetails().State = SafeXML.cleanback(location.substring(0, countryStart).trim());
-							} else {
-								ch.getFreshDetails().Country = location.trim();
-								ch.getFreshDetails().State = &quot;&quot;;
-							}
-							pref.log(&quot;Got location (country/state)&quot;);
-						} else {
-							ch.getFreshDetails().Country = &quot;&quot;;
-							ch.getFreshDetails().State = &quot;&quot;;
-							pref.log(&quot;No location (country/state) found&quot;);
-						}
-
-						pref.log(&quot;Trying owner&quot;);
-						ch.setCacheOwner(SafeXML.cleanback(getOwner(completeWebPage)).trim());
-						if(ch.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; ch.getCacheOwner().equals(pref.myAlias2))) ch.setOwned(true);
-						if (pref.debug) pref.log(&quot;Owner: &quot; + ch.getCacheOwner() +&quot;; is_owned = &quot;+ch.is_owned()+&quot;;  alias1,2 = [&quot;+pref.myAlias+&quot;|&quot;+pref.myAlias2+&quot;]&quot;);
-						else pref.log(&quot;Got owner&quot;);
-
-
-						pref.log(&quot;Trying date hidden&quot;);
-						ch.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
-						if (pref.debug) pref.log(&quot;Hidden: &quot; + ch.getDateHidden());
-						else pref.log(&quot;Got date hidden&quot;);
-
-						pref.log(&quot;Trying hints&quot;);
-						ch.getFreshDetails().setHints(getHints(completeWebPage));
-						if (pref.debug) pref.log(&quot;Hints: &quot; + ch.getFreshDetails().Hints);
-						else pref.log(&quot;Got hints&quot;);
-
-						pref.log(&quot;Trying size&quot;);
-						ch.setCacheSize(CacheSize.gcSpiderString2Cw(getSize(completeWebPage)));
-						if (pref.debug) pref.log(&quot;Size: &quot; + ch.getCacheSize());
-						else pref.log(&quot;Got size&quot;);
-
-						pref.log(&quot;Trying difficulty&quot;);
-						ch.setHard(CacheTerrDiff.v1Converter(getDiff(completeWebPage)));
-						if (pref.debug) pref.log(&quot;Hard: &quot; + ch.getHard());
-						else pref.log(&quot;Got difficulty&quot;);
-
-						pref.log(&quot;Trying terrain&quot;);
-						ch.setTerrain(CacheTerrDiff.v1Converter(getTerr(completeWebPage)));
-						if (pref.debug) pref.log(&quot;Terr: &quot; + ch.getTerrain());
-						else pref.log(&quot;Got terrain&quot;);
-
-						pref.log(&quot;Trying cache type&quot;);
-						ch.setType(getType(completeWebPage));
-						if (pref.debug) pref.log(&quot;Type: &quot; + ch.getType());
-						else pref.log(&quot;Got cache type&quot;);
-
-						//==========
-						// Logs
-						//==========
-						pref.log(&quot;Trying logs&quot;);
-						ch.getFreshDetails().setCacheLogs(getLogs(completeWebPage, ch.getFreshDetails()));
-						pref.log(&quot;Found logs&quot;);
-
-						// If the switch is set to not store found caches and we found the cache =&gt; return
-						if (ch.is_found() &amp;&amp; doNotGetFound) {
-							if (infB.isClosed) {
-								return -1;
-							} else {
-								return 1;
-							}
-						}
-
-						//==========
-						// Bugs
-						//==========
-						// As there may be several bugs, we check whether the user has aborted
-						if (!infB.isClosed &amp;&amp; fetchTBs) getBugs(ch.getFreshDetails(),completeWebPage);
-						ch.setHas_bugs(ch.getFreshDetails().Travelbugs.size()&gt;0);
-
-						//==========
-						// Images
-						//==========
-						if(fetchImages){
-							pref.log(&quot;Trying images&quot;);
-							getImages(completeWebPage, ch.getFreshDetails());
-							pref.log(&quot;Got images&quot;);
-						}
-						//==========
-						// Addi waypoints
-						//==========
-
-						pref.log(&quot;Getting additional waypoints&quot;);
-						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch.is_found());
-						pref.log(&quot;Got additional waypoints&quot;);
-
-						//==========
-						// Attributes
-						//==========
-						pref.log(&quot;Getting attributes&quot;);
-						getAttributes(completeWebPage, ch.getFreshDetails());
-						pref.log(&quot;Got attributes&quot;);
-						//if (ch.is_new()) ch.setUpdated(false);
-						//==========
-						// Last sync date
-						//==========
-						ch.setLastSync((new Time()).format(&quot;yyyyMMddHHmmss&quot;));
-
-						ch.setIncomplete(false);
-						break;
-					}catch(Exception ex){
-						pref.log(&quot;Error reading cache: &quot;+ch.getWayPoint());
-						pref.log(&quot;Exception in getCacheByWaypointName: &quot;,ex);
-					}
-				} else {
-					break;
-				}
-			} // spiderTrys
-			if ( ( spiderTrys &gt;= MAX_SPIDER_TRYS ) &amp;&amp; ( ret == 1 ) ) {
-				pref.log(&quot;&gt;&gt;&gt; Failed to spider cache. Number of retrys exhausted.&quot;);
-				int decision = (new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(5515,&quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;),FormBase.DEFOKB|FormBase.NOB|FormBase.CANCELB)).execute();
-				if ( decision == FormBase.IDOK ) {
-					continue;
-				} else if ( decision == FormBase.IDNO ){
-					ret = 0;
-				} else {
-					ret = -1;
-				}
-			}
-			break;
-		}//while(true)
-		if (infB.isClosed) {// If the infoBox was closed before getting here, we return -1
-			return -1;
-		}
-		return ret;
-	} // getCacheByWaypointName
-
-
-	/**
-	 * Get the Distance to the centre
-	 * @param doc A previously fetched cachepage
-	 * @return Distance
-	 */
-	private double getDist(String doc) throws Exception {
-		inRex = new Regex(p.getProp(&quot;distRex&quot;));
-		inRex.search(doc);
-		if(doc.indexOf(&quot;Here&quot;) &gt;= 0) return(0);
-		if (!inRex.didMatch()) return 0;
-		if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) return Convert.toDouble(inRex.stringMatched(1).replace('.',','));
-		return Convert.toDouble(inRex.stringMatched(1));
-	}
-
-	/**
-	 * Get the waypoint name
-	 * @param doc A previously fetched cachepage
-	 * @return Name of waypoint to add to list
-	 */
-	private String getWP(String doc) throws Exception {
-		inRex = new Regex(p.getProp(&quot;waypointRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return &quot;GC&quot;+inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the coordinates of the cache
-	 * @param doc A previously fetched cachepage
-	 * @return Cache coordinates
-	 */
-	private String getLatLon(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the long description
-	 * @param doc A previously fetched cachepage
-	 * @return the long description
-	 */
-	private String getLongDesc(String doc) throws Exception{
-		String res = &quot;&quot;;
-		inRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
-		Regex rex2 = new Regex(p.getProp(&quot;longDescRex&quot;));
-		inRex.search(doc);
-		rex2.search(doc);
-		res = ((inRex.stringMatched(1)==null)?&quot;&quot;:inRex.stringMatched(1)) + &quot;&lt;br&gt;&quot;;
-		res += rex2.stringMatched(1);
-		return res; // SafeXML.cleanback(res);
-	}
-
-	/**
-	 * Get the cache location (country and state)
-	 * @param doc A previously fetched cachepage
-	 * @return the location (country and state) of the cache
-	 */
-	private String getLocation(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;cacheLocationRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;&quot;;
-
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the cache name
-	 * @param doc A previously fetched cachepage
-	 * @return the name of the cache
-	 */
-	private String getName(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the cache owner
-	 * @param doc A previously fetched cachepage
-	 * @return the cache owner
-	 */
-	private String getOwner(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the date when the cache was hidden
-	 * @param doc A previously fetched cachepage
-	 * @return Hidden date
-	 */
-	private String getDateHidden(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the hints
-	 * @param doc A previously fetched cachepage
-	 * @return Cachehints
-	 */
-	private String getHints(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the cache size
-	 * @param doc A previously fetched cachepage
-	 * @return Cache size
-	 */
-	private String getSize(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;None&quot;;
-	}
-
-	/**
-	 * Get the Difficulty
-	 * @param doc A previously fetched cachepage
-	 * @return The cache difficulty
-	 */
-	private String getDiff(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
-	}
-
-	/**
-	 * Get the terrain rating
-	 * @param doc A previously fetched cachepage
-	 * @return Terrain rating
-	 */
-	private String getTerr(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
-	}
-
-	/**
-	 * Get the waypoint type
-	 * @param doc A previously fetched cachepage
-	 * @return the waypoint type (Tradi, Multi, etc.)
-	 */
-	private byte getType(String doc) throws Exception {
-		inRex = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return CacheType.gcSpider2CwType(inRex.stringMatched(1));
-		else return 0;
-	}
-
-	/**
-	 * Get the logs
-	 * @param doc A previously fetched cachepage
-	 * @param chD Cache Details
-	 * @return A HTML string containing the logs
-	 */
-	private LogList getLogs(String doc, CacheHolderDetail chD) throws Exception {
-		String icon = &quot;&quot;;
-		String name = &quot;&quot;;
-		String logText = &quot;&quot;;
-		String logId = &quot;&quot;;
-		LogList reslts = new LogList();
-		Regex blockRex = new Regex(p.getProp(&quot;blockRex&quot;));
-		blockRex.search(doc);
-		doc = blockRex.stringMatched(1);
-		String singleLog = &quot;&quot;;
-		Extractor exSingleLog = new Extractor(doc,p.getProp(&quot;singleLogExStart&quot;), p.getProp(&quot;singleLogExEnd&quot;), 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back???
-		singleLog = exSingleLog.findNext();
-		Extractor exIcon = new Extractor(singleLog,p.getProp(&quot;iconExStart&quot;), p.getProp(&quot;iconExEnd&quot;), 0, true);
-		Extractor exNameTemp = new Extractor(singleLog,p.getProp(&quot;nameTempExStart&quot;), p.getProp(&quot;nameTempExEnd&quot;), 0 , true);
-		String nameTemp = &quot;&quot;;
-		nameTemp = exNameTemp.findNext();
-		Extractor exName = new Extractor(nameTemp, p.getProp(&quot;nameExStart&quot;), p.getProp(&quot;nameExEnd&quot;), 0 , true);
-		Extractor exDate = new Extractor(singleLog,p.getProp(&quot;dateExStart&quot;), p.getProp(&quot;dateExEnd&quot;), 0 , true);
-		Extractor exLog = new Extractor(singleLog, p.getProp(&quot;logExStart&quot;), p.getProp(&quot;logExEnd&quot;), 0, true);
-		Extractor exLogId = new Extractor(singleLog, p.getProp(&quot;logIdExStart&quot;), p.getProp(&quot;logIdExEnd&quot;), 0, true);
-		//Vm.debug(&quot;Log Block: &quot; + singleLog);
-		int nLogs=0;
-		while(exSingleLog.endOfSearch() == false){
-			nLogs++;
-			//Vm.debug(&quot;--------------------------------------------&quot;);
-			//Vm.debug(&quot;Log Block: &quot; + singleLog);
-			//Vm.debug(&quot;Icon: &quot;+exIcon.findNext());
-			//Vm.debug(exName.findNext());
-			//Vm.debug(exDate.findNext());
-			//Vm.debug(exLog.findNext());
-			//Vm.debug(&quot;--------------------------------------------&quot;);
-			icon = exIcon.findNext();
-			name = exName.findNext();
-			logText = exLog.findNext();
-			logId = exLogId.findNext();
-			String d=DateFormat.logdate2YMD(exDate.findNext());
-			if((icon.equals(p.getProp(&quot;icon_smile&quot;)) || icon.equals(p.getProp(&quot;icon_camera&quot;)) || icon.equals(p.getProp(&quot;icon_attended&quot;))) &amp;&amp;
-				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; name.equalsIgnoreCase(pref.myAlias2))) )  {
-				chD.getParent().setFound(true);
-				chD.getParent().setCacheStatus(d);
-				chD.OwnLogId = logId;
-				chD.OwnLog = new Log(icon,d,name,logText);
-			}
-			if (nLogs&lt;=MAXLOGS) reslts.add(new Log(icon,d,name,logText));
-
-			singleLog = exSingleLog.findNext();
-			exIcon.setSource(singleLog);
-			exNameTemp.setSource(singleLog);
-			nameTemp = exNameTemp.findNext();
-			exName.setSource(nameTemp);
-			exDate.setSource(singleLog);
-			exLog.setSource(singleLog);
-			exLogId.setSource(singleLog);
-			// We cannot simply stop if we have reached MAXLOGS just in case we are waiting for
-			// a log by our alias that happened earlier.
-			if (nLogs&gt;=MAXLOGS &amp;&amp; chD.getParent().is_found() &amp;&amp; (chD.OwnLogId.length() != 0) &amp;&amp; (chD.OwnLog != null) &amp;&amp; !(chD.OwnLog.getDate().equals(&quot;1900-01-01&quot;))) break;
-		}
-		if (nLogs&gt;MAXLOGS) {
-			reslts.add(Log.maxLog());
-			pref.log(&quot;Too many logs. MAXLOGS reached (&quot;+MAXLOGS+&quot;)&quot;);
-		} else
-			pref.log(nLogs+&quot; logs found&quot;);
-		return reslts;
-	}
-
-	/**
-	 * Read the travelbug names from a previously fetched Cache page and then
-	 * read the travelbug purpose for each travelbug
-	 * @param doc The previously fetched cachepage
-	 * @return A HTML formatted string with bug names and there purpose
-	 */
-	public void getBugs(CacheHolderDetail chD, String doc) throws Exception{
-		Extractor exBlock = new Extractor(doc,p.getProp(&quot;blockExStart&quot;),p.getProp(&quot;blockExEnd&quot;) ,0,Extractor.EXCLUDESTARTEND);
-		String bugBlock = exBlock.findNext();
-		//Vm.debug(&quot;Bugblock: &quot;+bugBlock);
-		Extractor exBug = new Extractor(bugBlock,p.getProp(&quot;bugExStart&quot;),p.getProp(&quot;bugExEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-		String link,bug,linkPlusBug,bugDetails;
-		String oldInfoBox=infB.getInfo();
-		chD.Travelbugs.clear();
-		while(exBug.endOfSearch() == false){
-			if (infB.isClosed) break; // Allow user to cancel by closing progress form
-			linkPlusBug= exBug.findNext();
-			int idx=linkPlusBug.indexOf(&quot;'&gt;&quot;);
-			if (idx&lt;0) break; // No link/bug pair found
-			link=linkPlusBug.substring(0,idx);
-			bug=linkPlusBug.substring(idx+2);
-			if(bug.length()&gt;0) { // Found a bug, get its details
-				Travelbug tb=new Travelbug(bug);
-				try{
-					infB.setInfo(oldInfoBox+MyLocale.getMsg(5514,&quot;\nGetting bug: &quot;)+SafeXML.cleanback(bug));
-					pref.log(&quot;Fetching bug details: &quot;+bug);
-					bugDetails = fetch(link);
-					Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-					tb.setMission(exDetails.findNext());
-					Extractor exGuid = new Extractor(bugDetails,&quot;details.aspx?guid=&quot;,&quot;\&quot; id=\&quot;aspnetForm&quot;,0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def see also further down
-					tb.setGuid(exGuid.findNext());
-					chD.Travelbugs.add(tb);
-				}catch(Exception ex){
-					pref.log(&quot;Could not fetch bug details&quot;);
-				}
-			}
-			//Vm.debug(&quot;B: &quot; + bug);
-			//Vm.debug(&quot;End? &quot; + exBug.endOfSearch());
-		}
-		infB.setInfo(oldInfoBox);
-	}
-
-	/**
-	 * Get the images for a previously fetched cache page. Images are extracted
-	 * from two areas: The long description and the pictures section (including
-	 * the spoiler)
-	 * @param doc The previously fetched cachepage
-	 * @param chD The Cachedetails
-	 */
-	public void getImages(String doc, CacheHolderDetail chD){
-		int imgCounter = 0;
-		String imgName, oldImgName, imgType, imgUrl, imgComment;
-		Vector spideredUrls=new Vector(15);
-		Extractor exImgBlock,exImgComment;
-		int idxUrl; // Index of already spidered Url in list of spideredUrls
-		//========
-		//In the long description
-		//========
-		String longDesc = &quot;&quot;;
-		try {
-			if (chD.getParent().getWayPoint().startsWith(&quot;TC&quot;)) longDesc = doc;
-			else
-				longDesc = getLongDesc(doc);
-			longDesc = STRreplace.replace(longDesc, &quot;&lt;img&quot;, &quot;&lt;IMG&quot;);
-			longDesc = STRreplace.replace(longDesc, &quot;src=&quot;, &quot;SRC=&quot;);
-			longDesc = STRreplace.replace(longDesc, &quot;'&quot;, &quot;\&quot;&quot;);
-			exImgBlock = new Extractor(longDesc,p.getProp(&quot;imgBlockExStart&quot;),p.getProp(&quot;imgBlockExEnd&quot;), 0, false);
-		} catch (Exception ex) {//Missing property in spider.def
-			return;
-		}
-		//Vm.debug(&quot;In getImages: Have longDesc&quot; + longDesc);
-		String tst;
-		tst = exImgBlock.findNext();
-		//Vm.debug(&quot;Test: \n&quot; + tst);
-		Extractor exImgSrc = new Extractor(tst, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while(exImgBlock.endOfSearch() == false){
-			imgUrl = exImgSrc.findNext();
-			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
-			if(imgUrl.length()&gt;0){
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try{
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
-					// imgType is now max 4 chars, starting with .
-					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
-						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
-						if (idxUrl&lt;0) { // New image
-							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
-							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
-							spideredUrls.add(imgUrl);
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							pref.log(&quot;Already loaded image: &quot; + imgUrl);
-							oldImgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(idxUrl);
-							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
-						}
-						chD.ImagesText.add(imgName); // Keep the image name
-						chD.ImagesInfo.add(null); // Need to stay in synch with ImagesText
-						imgCounter++;
-					}
-				} catch (IndexOutOfBoundsException e) {
-					//Vm.debug(&quot;IndexOutOfBoundsException not in image span&quot;+e.toString()+&quot;imgURL:&quot;+imgUrl);
-					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
-				}
-				}
-			exImgSrc.setSource(exImgBlock.findNext());
-		}
-		//========
-		//In the image span
-		//========
-		Extractor spanBlock,exImgName;
-		try {
-			spanBlock = new Extractor(doc,p.getProp(&quot;imgSpanExStart&quot;),p.getProp(&quot;imgSpanExEnd&quot;), 0 , true);
-			tst = spanBlock.findNext();
-			exImgName = new Extractor(tst,p.getProp(&quot;imgNameExStart&quot;),p.getProp(&quot;imgNameExEnd&quot;), 0 , true);
-			exImgSrc = new Extractor(tst,p.getProp(&quot;imgSrcExStart&quot;),p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
-			exImgComment = new Extractor(tst,p.getProp(&quot;imgCommentExStart&quot;),p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
-		} catch (Exception ex) { // Missing property in spider .def
-			return;
-		}
-		while(exImgSrc.endOfSearch() == false){
-			imgUrl = exImgSrc.findNext();
-			imgComment = exImgComment.findNext();
-			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
-			if(imgUrl.length()&gt;0){
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try{
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
-					// imgType is now max 4 chars, starting with .
-					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
-						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
-						if (idxUrl&lt;0) { // New image
-							pref.log(&quot;Loading image: &quot; + imgUrl);
-							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
-						} else { // Image already spidered as wayPoint_ 'idxUrl'
-							pref.log(&quot;Already loaded image: &quot; + imgUrl);
-							oldImgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(idxUrl);
-							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
-						}
-						chD.ImagesText.add(exImgName.findNext()); // Keep the image description
-						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(6);
-						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(0,imgComment.length()-6);
-						if (imgComment.length()==0)
-							chD.ImagesInfo.add(null);
-						else
-							chD.ImagesInfo.add(imgComment);
-						imgCounter++;
-					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log(&quot;IndexOutOfBoundsException in image span. imgURL:&quot;+imgUrl,e);
-				}
-			}
-		}
-		//========
-		//Final sweep to check for images in hrefs
-		//========
-		Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while(exFinal.endOfSearch() == false){
-			imgUrl = exFinal.findNext();
-			if(imgUrl.length()&gt;0){
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try{
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
-					// imgType is now max 4 chars, starting with . Delete characters in URL after the image extension
-					imgUrl=imgUrl.substring(0,imgUrl.lastIndexOf(&quot;.&quot;)+imgType.length());
-					if( imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)){
-						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
-						if (idxUrl&lt;0) { // New image
-							imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
-							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
-							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
-							spideredUrls.add(imgUrl);
-							chD.ImagesText.add(imgName); // Keep the image name
-							chD.ImagesInfo.add(null);
-							imgCounter++;
-						}
-					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
-				}
-			}
-		}
-	}
-
-
-	/**
-	 * Read an image from the server
-	 * @param imgUrl The Url of the image
-	 * @param target The bytes of the image
-	 */
-	private void spiderImage(String imgUrl, String target){ // TODO implement a fetch(URL, filename) in HttpConnection and use that one
-		HttpConnection connImg;
-		Socket sockImg;
-		//InputStream is;
-		FileOutputStream fos;
-		//int bytes_read;
-		//byte[] buffer = new byte[9000];
-		ByteArray daten;
-		String datei = &quot;&quot;;
-		datei = profile.dataDir + target;
-		connImg = new HttpConnection(imgUrl);
-		if (imgUrl.indexOf('%')&gt;=0) connImg.documentIsEncoded=true;
-		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-		//connImg.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12&quot;);
-		//connImg.setRequestorProperty(&quot;Accept&quot;,&quot;text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5&quot;);
-		try{
-			pref.log(&quot;Trying to fetch image from: &quot; + imgUrl);
-			String redirect=null;
-			do {
-				sockImg = connImg.connect();
-				redirect=connImg.getRedirectTo();
-				if (redirect!=null) {
-					connImg=connImg.getRedirectedConnection(redirect);
-					pref.log(&quot;Redirect to &quot;+redirect);
-				}
-			} while(redirect!=null); // TODO this can end up in an endless loop if trying to load from a malicous site
-			daten = connImg.readData(sockImg);
-			fos = new FileOutputStream(new File(datei));
-			fos.write(daten.toBytes());
-			fos.close();
-			sockImg.close();
-		} catch (UnknownHostException e) {
-			pref.log(&quot;Host not there...&quot;);
-		}catch(IOException ioex){
-			pref.log(&quot;File not found!&quot;);
-		} catch (Exception ex){
-			pref.log(&quot;Some other problem while fetching image&quot;,ex);
-		} finally {
-			//Continue with the spider
-		}
-	}
-
-	/**
-	 * Read all additional waypoints from a previously fetched cachepage.
-	 * @param doc The previously fetched cachepage
-	 * @param wayPoint The name of the cache
-	 * @param is_found Found status of the cached (is inherited by the additional waypoints)
-	 */
-	public void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception{
-		Extractor exWayBlock = new Extractor(doc,p.getProp(&quot;wayBlockExStart&quot;),p.getProp(&quot;wayBlockExEnd&quot;), 0, false);
-		String wayBlock = &quot;&quot;;
-		String rowBlock = &quot;&quot;;
-		wayBlock = exWayBlock.findNext();
-		Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
-		Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
-		Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
-		Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
-		int counter = 0;
-		if(exWayBlock.endOfSearch() == false &amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;)&lt;0){
-			Extractor exRowBlock = new Extractor(wayBlock,p.getProp(&quot;rowBlockExStart&quot;),p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
-			rowBlock = exRowBlock.findNext();
-			rowBlock = exRowBlock.findNext();
-			while(exRowBlock.endOfSearch()==false){
-				CacheHolder hd = null;
-				Extractor exPrefix=new Extractor(rowBlock,p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
-				String prefix=exPrefix.findNext();
-				String adWayPoint;
-				if (prefix.length()==2)
-					adWayPoint=prefix+wayPoint.substring(2);
-				else
-				    adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
-				counter++;
-				int idx=profile.getCacheIndex(adWayPoint);
-				if (idx&gt;=0) {
-					// Creating new CacheHolder, but accessing old cache.xml file
-					hd=new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-					hd.getExistingDetails(); // Accessing Details reads file if not yet done
-				} else {
-					hd=new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-				}
-				hd.initStates(idx&lt;0);
-				nameRex.search(rowBlock);
-				koordRex.search(rowBlock);
-				typeRex.search(rowBlock);
-				hd.setCacheName(nameRex.stringMatched(1));
-				if(koordRex.didMatch()) hd.setLatLon(koordRex.stringMatched(1));
-				if(typeRex.didMatch()) hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot;+typeRex.stringMatched(1)));
-				rowBlock = exRowBlock.findNext();
-				descRex.search(rowBlock);
-				hd.getFreshDetails().setLongDescription(descRex.stringMatched(1));
-				hd.setFound(is_found);
-				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-				hd.setHard(CacheTerrDiff.CW_DT_UNSET);
-				hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (idx&lt;0){
-					cacheDB.add(hd);
-					hd.save();
-				}else {
-					CacheHolder cx=cacheDB.get(idx);
-					if (cx.is_Checked &amp;&amp; // Only re-spider existing addi waypoints that are ticked
-				 	   cx.isVisible()) { // and are visible (i.e.  not filtered)
-					   cx.initStates(false);
-					   cx.update(hd);
-					   cx.is_Checked=true;
-					   cx.save();
-					}
-				}
-				rowBlock = exRowBlock.findNext();
-
-			}
-		}
-	}
-
-	public void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
-		Extractor attBlock = new Extractor(doc,p.getProp(&quot;attBlockExStart&quot;),p.getProp(&quot;attBlockExEnd&quot;), 0 , true);
-		String atts = attBlock.findNext();
-		Extractor attEx = new Extractor(atts,p.getProp(&quot;attExStart&quot;),p.getProp(&quot;attExEnd&quot;), 0 , true);
-		String attribute=attEx.findNext();
-		chD.attributes.clear();
-		while (attEx.endOfSearch()==false) {
-			chD.attributes.add(attribute);
-			attribute=attEx.findNext();
-		}
-		chD.getParent().setAttributesYes(chD.attributes.attributesYes);
-		chD.getParent().setAttributesNo(chD.attributes.attributesNo);
-	}
-
-
-	/**
-	*	Performs an initial fetch to a given address. In this case
-	*	it will be a gc.com address. This method is used to obtain
-	*	the result of a search for caches screen.
-	*/
-	public static String fetch(String address) {
-		CharArray c_data;
-		try{
-			HttpConnection conn;
-			if(pref.myproxy.length() &gt; 0 &amp;&amp; pref.proxyActive){
-				pref.log(&quot;[fetch]:Using proxy: &quot; + pref.myproxy + &quot; / &quot; +pref.myproxyport);
-			}
-			conn = new HttpConnection(address);
-			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-			if(cookieSession.length()&gt;0){
-				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
-				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
-			} else
-				pref.log(&quot;[fetch]:No Cookie found&quot;);
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			conn.documentIsEncoded = true;
-			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
-			Socket sock = conn.connect();
-			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
-			ByteArray daten = conn.readData(sock);
-			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			sock.close();
-			return getResponseHeaders(conn)+ c_data.toString();
-		}catch(IOException ioex){
-			pref.log(&quot;IOException in fetch&quot;, ioex);
-		}finally{
-			//continue
-		}
-		return &quot;&quot;;
-	}
-
-	/**
-	*	After a fetch to gc.com the next fetches have to use the post method.
-	*	This method does exactly that. Actually this method is generic in the sense
-	*	that it can be used to post to a URL using http post.
-	*/
-	private static String fetch_post(String address, String document, String path) {
-		HttpConnection conn;
-		try {
-			conn = new HttpConnection(address);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			conn.documentIsEncoded = true;
-			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-			conn.setPostData(codec.encodeText(document.toCharArray(),0,document.length(),true,null));
-			conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
-			if(cookieSession.length()&gt;0){
-				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession+&quot;; userid=&quot;+cookieID);
-				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
-			} else {
-				pref.log(&quot;[fetch]:No Cookie found&quot;);
-			}
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
-			Socket sock = conn.connect();
-			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
-			ByteArray daten = conn.readData(sock);
-			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
-			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			sock.close();
-			return getResponseHeaders(conn)+c_data.toString();
-		} catch (Exception e) {
-			Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-		}
-		return &quot;&quot;;
-	}
-
-	private static String getResponseHeaders(HttpConnection conn) {
-		PropertyList pl = conn.documentProperties;
-		if (pl != null) {
-			StringBuffer sb = new StringBuffer(1000);
-			boolean gotany = false;
-
-			for (int i = 0; i &lt; pl.size(); i++) {
-				Property currProp = (Property)pl.get(i);
-				if (currProp.value != null) {
-					sb.append(currProp.name).append(&quot;: &quot;).append(currProp.value).append(&quot;\r\n&quot;);
-					gotany = true;
-				}
-			}
-			if (gotany)
-				return sb.toString() + &quot;\r\n&quot;;
-		}
-		return &quot;&quot;;
-	}
-
-
-	final static String hex = ewe.util.TextEncoder.hex;
-
-	public String encodeUTF8URL(byte[] what) {
-		int max = what.length;
-		char [] dest = new char[6*max]; // Assume each char is a UTF char and encoded into 6 chars
-		char d = 0;
-		for (int i = 0; i&lt;max; i++){
-			char c = (char) what[i];
-			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '=' ||
-				   c == '|' || c == '{' || c == '}' || c&gt;0x7f ){
-					dest[d++] = '%';
-					dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
-					dest[d++] = hex.charAt(c &amp; 0xf);
-			} else dest[d++] = c;
-		}
-		return new String(dest,0,d);
-	}
-
-	/**
-	 * Load the bug id for a given name. This method is not ideal, as there are
-	 * sometimes several bugs with identical names but different IDs. Normally
-	 * the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
-	 * Note that each bug has both an ID and a GUID.
-	 * @param name The name (or partial name) of a travelbug
-	 * @return the id of the bug
-	 */
-	public String getBugId (String name) {
-		String bugList;
-		try{
-			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
-			pref.log(&quot;Fetching bugId: &quot;+name);
-			bugList = fetch(p.getProp(&quot;getBugByName&quot;)+STRreplace.replace(SafeXML.clean(name),&quot; &quot;,&quot;+&quot;));
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug list&quot;);
-			bugList=&quot;&quot;;
-		}
-		try {
-			if (bugList.equals(&quot;&quot;) || bugList.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
-				return &quot;&quot;;
-			}
-			if (bugList.indexOf(p.getProp(&quot;bugTotalRecords&quot;))&lt;0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6021,&quot;More than one travelbug found. Specify name more precisely.&quot;), FormBase.OKB)).execute();
-				return &quot;&quot;;
-			}
-			Extractor exGuid = new Extractor(bugList,p.getProp(&quot;bugGuidExStart&quot;),p.getProp(&quot;bugGuidExEnd&quot;),0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def
-			return exGuid.findNext();
-		} catch (Exception ex) {
-			return &quot;&quot;;
-		}
-	}
-
-	/**
-	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer
-	 * than 10 characters it is assumed to be a GUID, otherwise it is an ID.
-	 * @param guid the guid or id of the travelbug
-	 * @return The mission
-	 */
-	public String getBugMissionByGuid(String guid) {
-		String bugDetails;
-		try{
-			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
-			pref.log(&quot;Fetching bug detailsById: &quot;+guid);
-			if (guid.length()&gt;10)
-				bugDetails = fetch(p.getProp(&quot;getBugByGuid&quot;)+guid);
-			else
-				bugDetails = fetch(p.getProp(&quot;getBugById&quot;)+guid);
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug details&quot;);
-			bugDetails=&quot;&quot;;
-		}
-		try {
-			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
-				return &quot;&quot;;
-			}
-			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			return exDetails.findNext();
-		} catch (Exception ex) {
-			return &quot;&quot;;
-		}
-	}
-
-	/**
-	 * Fetch a bug's mission for a given tracking number
-	 * @param trackNr the tracking number of the travelbug
-	 * @return The mission
-	 */
-	public String getBugMissionByTrackNr(String trackNr) {
-		String bugDetails;
-		try{
-			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
-			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug details&quot;);
-			bugDetails=&quot;&quot;;
-		}
-		try {
-			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
-				return &quot;&quot;;
-			}
-			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			return exDetails.findNext();
-		} catch (Exception ex) {
-			return &quot;&quot;;
-		}
-	}
-
-	/**
-	 * Fetch a bug's mission and namefor a given tracking number
-	 * @param TB the travelbug
-	 * @return true if suceeded
-	 */
-	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
-		String bugDetails;
-		String trackNr = TB.getTrackingNo();
-		try{
-			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
-			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug details&quot;);
-			bugDetails=&quot;&quot;;
-		}
-		try {
-			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
-				return false;
-			}
-			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			TB.setMission( exDetails.findNext() );
-			Extractor exName = new Extractor(bugDetails,p.getProp(&quot;bugNameStart&quot;),p.getProp(&quot;bugNameEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			TB.setName( exName.findNext() );
-			return true;
-		} catch (Exception ex) {
-			return false;
-		}
-	}
-
-	public class SpiderProperties extends Properties {
-		SpiderProperties() {
-			super();
-			try {
-				load(new FileInputStream(FileBase.getProgramDirectory()+&quot;/spider.def&quot;));
-			} catch (Exception ex) {
-				pref.log(&quot;Failed to load spider.def&quot;,ex);
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5504,&quot;Could not load 'spider.def'&quot;), FormBase.OKB)).execute();
-			}
-		}
-		public String getProp(String key) throws Exception {
-			String s=super.getProperty(key);
-			if (s==null) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5497,&quot;Error missing tag in spider.def&quot;) + &quot;: &quot;+key, FormBase.OKB)).execute();
-				throw new Exception(&quot;Missing tag in spider.def: &quot;+key);
-			}
-			return s;
-		}
-
-	}
-}

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -11,6 +11,7 @@
  * @author salzkammergut
  */
 
+import CacheWolf.imp.SpiderGC;
 import utils.CWWrapper;
 import ewe.sys.Convert;
 import ewe.sys.Time;

Copied: trunk/src/CacheWolf/imp/GPXImporter.java (from rev 1941, trunk/src/CacheWolf/GPXImporter.java)
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-06-24 17:27:40 UTC (rev 1941)
+++ trunk/src/CacheWolf/imp/GPXImporter.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -0,0 +1,597 @@
+package CacheWolf.imp;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheSize;
+import CacheWolf.CacheTerrDiff;
+import CacheWolf.CacheType;
+import CacheWolf.Common;
+import CacheWolf.Extractor;
+import CacheWolf.Filter;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.Log;
+import CacheWolf.MyLocale;
+import CacheWolf.ParseLatLon;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import CacheWolf.SafeXML;
+import CacheWolf.Travelbug;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.FormBase;
+import ewe.ui.MessageBox;
+import ewe.util.Enumeration;
+import ewe.util.Vector;
+import ewe.util.zip.ZipEntry;
+import ewe.util.zip.ZipFile;
+import ewesoft.xml.MinML;
+import ewesoft.xml.XMLElement;
+import ewesoft.xml.sax.AttributeList;
+
+/**
+*	Class to import Data from an GPX File. If cache data exists, the data from 
+*	the GPX-File is ignored.
+*	Class ID = 4000
+*/
+public class GPXImporter extends MinML {
+	
+	static Preferences pref;
+	Profile profile;
+	CacheDB cacheDB;
+	CacheHolder holder;
+	String strData, saveDir, logData, logIcon, logDate, logFinder, logId;
+	boolean inWpt, inCache, inLogs, inBug;
+	public XMLElement document;
+	private Vector files = new Vector();
+	private boolean debugGPX = false; 
+	InfoBox infB;
+	boolean spiderOK = true;
+	boolean doSpider = false;
+	boolean fromOC = false;
+	boolean fromTC = false;
+	boolean nameFound = false;
+	static final Time gpxDate = new Time();
+	int zaehlerGel = 0;
+	public static final int DOIT_ASK = 0;
+	public static final int DOIT_NOSPOILER = 1;
+	public static final int DOIT_WITHSPOILER = 2;
+	boolean getMaps = false;
+	SpiderGC imgSpider;
+	StringBuffer strBuf;
+	
+	public GPXImporter(Preferences p, Profile prof, String f )
+	{
+		profile=prof;
+		pref = p;
+		cacheDB = profile.cacheDB;
+		//file = f;
+		files.add(f);
+		saveDir = profile.dataDir;
+		//msgA = msgArea;
+		inWpt = false;
+		inCache = false;
+		inLogs = false;
+		inBug =false;
+	}
+/*	skg: This Constructor is not referenced, therefore commented out 
+	public GPXImporter(Vector DB, String[] f,String d, Preferences p)
+	{
+		pref = p;
+		cacheDB = DB;
+		saveDir = pref.mydatadir;
+		for (int i=0;i&lt;f.length;i++){
+			files.add(d + &quot;/&quot; + f[i]);
+		}
+		
+		//msgA = msgArea;
+		inWpt = false;
+		inCache = false;
+		inLogs = false;
+		inBug =false;
+		strData = new String();
+		//index db for faster search
+		CacheHolder ch;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			DBindex.put((String)ch.wayPoint, new Integer(i));
+		}//for
+	}
+*/	
+	public void doIt(int how){
+		Filter flt = new Filter();
+		boolean wasFiltered = (profile.getFilterActive()==Filter.FILTER_ACTIVE);
+		flt.clearFilter();
+		try{
+			ewe.io.Reader r;
+			String file;
+			
+			OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
+			if (options.execute() == FormBase.IDCANCEL) {	return; }
+			//String dist = options.distanceInput.getText();
+			//if (dist.length()== 0) return;
+			//getMaps = options.mapsCheckBox.getState();
+			boolean getImages = options.imagesCheckBox.getState();
+			doSpider = false;
+			if(getImages){
+				doSpider = true;
+				imgSpider = new SpiderGC(pref, profile, false);
+			}
+			options.close(0);
+			
+			//Vm.debug(&quot;State of: &quot; + doSpider);
+			Vm.showWait(true);
+			for (int i=0; i&lt;files.size();i++){
+				//Test for zip.file
+				file = (String)files.get(i);
+				if (file.indexOf(&quot;.zip&quot;) &gt; 0){
+					ZipFile zif = new ZipFile (file);
+					ZipEntry zipEnt;
+					Enumeration zipEnum = zif.entries();
+					// there could be more than one file in the archive
+					while (zipEnum.hasMoreElements())
+					{
+						zipEnt = (ZipEntry) zipEnum.nextElement();
+						// skip over PRC-files
+						if (zipEnt.getName().endsWith(&quot;gpx&quot;)){
+							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
+							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+							infB.exec();
+							if (r.read() != 65279)
+								r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
+							parse(r);
+							r.close();
+							infB.close(0);
+						}
+					}
+				}
+				else {
+					r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
+					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+					infB.show();
+					if (r.read() != 65279)
+						r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
+					parse(r);
+					r.close();
+					infB.close(0);
+				}
+				// save Index 
+				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				infB.close(0);
+			}
+				Vm.showWait(false);
+			}catch(Exception e){
+				e.printStackTrace();
+				Vm.showWait(false);
+			}
+		if(wasFiltered){
+			flt.setFilter();
+			flt.doFilter();
+		}
+	}
+	public void startElement(String name, AttributeList atts){
+		strBuf=new StringBuffer(300);
+		if (name.equals(&quot;gpx&quot;)){
+			// check for opencaching
+			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;)&gt; 0) fromOC = true;
+			else fromOC = false;
+			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;)) fromTC = true;
+			else fromTC = false;
+
+			if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
+			zaehlerGel = 0;
+		}
+		if (name.equals(&quot;wpt&quot;)) {
+			holder = new CacheHolder();
+			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
+			holder.LatLon=holder.pos.toString();
+			inWpt = true;
+			inLogs = false;
+			inBug = false;
+			nameFound = false;
+			zaehlerGel++;
+			infB.setInfo(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel);
+			return;
+		}
+		
+		if (name.equals(&quot;link&quot;)&amp;&amp; inWpt){
+			holder.getFreshDetails().URL = atts.getValue(&quot;href&quot;);
+			return;
+		}
+
+		if (name.equals(&quot;groundspeak:cache&quot;)) {
+			inCache = true;
+			holder.setAvailable(atts.getValue(&quot;available&quot;).equals(&quot;True&quot;));
+			holder.setArchived(atts.getValue(&quot;archived&quot;).equals(&quot;True&quot;));
+			return;
+		}
+
+		if (name.equals(&quot;geocache&quot;)) {
+			boolean available = false;
+			boolean archived  = false;
+			inCache=true;
+			// get status
+			String status = new String(atts.getValue(&quot;status&quot;));
+			if (status.equals(&quot;Available&quot;)) available = true;
+			else if (status.equals(&quot;Unavailable&quot;)) available = false;
+			else if (status.equals(&quot;Draft&quot;)) available = false;
+			else if (status.equals(&quot;Archived&quot;)) archived = true;
+			holder.setArchived(archived);
+			holder.setAvailable(available);
+			return;
+		}
+		
+		if (name.equals(&quot;terra:terracache&quot;)) {
+			inCache=true;
+		}
+
+		
+		if (name.equals(&quot;groundspeak:long_description&quot;)) {
+			holder.setHTML(atts.getValue(&quot;html&quot;).toLowerCase().equals(&quot;true&quot;));
+		}
+		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;) ) {
+			//set HTML always to true if from oc.de or TC
+			holder.setHTML(true);
+		}
+
+		if (name.equals(&quot;groundspeak:logs&quot;) || name.equals(&quot;logs&quot;) || name.equals(&quot;terra:logs&quot;)) {
+			inLogs = true;
+			return;
+		}
+		if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;)) {
+			inLogs = true;
+			logId = atts.getValue(&quot;id&quot;);
+			return;
+		}
+		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
+			inBug = true;
+			return;
+		}
+		if (debugGPX){
+			for (int i = 0; i &lt; atts.getLength(); i++) {
+				Vm.debug(&quot;Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
+			}
+		}
+	}
+	
+	public void endElement(String name){
+		strData=strBuf.toString();
+		//Vm.debug(&quot;Ende: &quot; + name);
+		
+		// logs
+		if (inLogs){
+			if (name.equals(&quot;groundspeak:date&quot;)|| name.equals(&quot;time&quot;)|| name.equals(&quot;terra:date&quot;))  {
+				logDate = new String(strData.substring(0,10));
+				return;
+			}
+			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)){
+				logIcon = new String(typeText2Image(strData));
+				return;
+			}
+			if (name.equals(&quot;groundspeak:finder&quot;)|| name.equals(&quot;geocacher&quot;)|| name.equals(&quot;terra:user&quot;)){
+				logFinder = new String(strData);
+				return;
+			}
+			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){ 
+				logData = new String(strData);
+				return;
+			}
+			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;) ) {
+				holder.getFreshDetails().CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
+				if((logIcon.equals(&quot;icon_smile.gif&quot;) || logIcon.equals(&quot;11.png&quot;) || logIcon.equals(&quot;icon_attended.gif&quot;)) &amp;&amp; 
+						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; logFinder.equalsIgnoreCase(pref.myAlias2)))) {
+							holder.setCacheStatus(logDate);
+							holder.setFound(true);
+							holder.getFreshDetails().OwnLogId = logId;
+							holder.getFreshDetails().OwnLog = new Log(logIcon,logDate,logFinder,logData);
+				}
+				return;
+			}
+		}
+		
+		if (name.equals(&quot;wpt&quot;)){
+			// Add cache Data only, if waypoint not already in database
+			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
+			int index=cacheDB.getIndex(holder.getWayPoint());
+			//Vm.debug(&quot;here ?!?!?&quot;);
+			//Vm.debug(&quot;chould be new!!!!&quot;);
+			if (index == -1){
+				holder.setNoFindLogs(holder.getFreshDetails().CacheLogs.countNotFoundLogs());
+				holder.setNew(true);
+				cacheDB.add(holder);
+				// don't spider additional waypoints, so check
+				// if waypoint starts with &quot;GC&quot;
+				if(doSpider == true) {
+					if(spiderOK == true &amp;&amp; holder.is_archived() == false){
+							if(holder.LatLon.length() &gt; 1){
+							if(getMaps){
+								ParseLatLon pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
+								pll.parse();
+								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
+								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map.gif&quot;, &quot;3&quot;);
+								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map_2.gif&quot;, &quot;10&quot;);
+							}
+						}
+					if(holder.getWayPoint().startsWith(&quot;GC&quot;)|| fromTC) {
+						//spiderImages();
+						spiderImagesUsingSpider();
+						//Rename image sources
+						String text;
+						String orig;
+						String imgName;
+						orig = holder.getFreshDetails().LongDescription;
+						Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
+						text = ex.findNext();
+						int num = 0;
+						while(ex.endOfSearch() == false &amp;&amp; spiderOK == true){
+							//Vm.debug(&quot;Replacing: &quot; + text);
+							if (num &gt;= holder.getFreshDetails().ImagesText.getCount())break;
+							imgName = (String)holder.getFreshDetails().ImagesText.get(num);
+							holder.getFreshDetails().LongDescription = replace(holder.getFreshDetails().LongDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
+							num++;
+							text = ex.findNext();
+						}
+					}
+						
+					}
+				}
+				holder.save();
+				//crw.saveIndex(cacheDB,saveDir);
+			}
+			//Update cache data
+			else {
+				CacheHolder oldCh= cacheDB.get(index);
+				oldCh.update(holder);
+				oldCh.save();
+			}
+			
+			inWpt = false;
+			return;
+		}
+		if (name.equals(&quot;sym&quot;)&amp;&amp; strData.endsWith(&quot;Found&quot;)) {
+			holder.setFound(true);
+			holder.setCacheStatus(MyLocale.getMsg(318,&quot;Found&quot;));
+			return;
+		}
+		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
+			inBug = false;
+			return;
+		}
+
+		if (name.equals(&quot;groundspeak:name&quot;)&amp;&amp; inBug) {
+			Travelbug tb=new Travelbug(strData);
+			holder.getFreshDetails().Travelbugs.add(tb);
+			//holder.Bugs += &quot;&lt;b&gt;Name:&lt;/b&gt; &quot; + strData + &quot;&lt;br&gt;&lt;hr&gt;&quot;;
+			holder.setHas_bugs(true);
+			return;
+		}
+		
+		if (name.equals(&quot;time&quot;) &amp;&amp; !inWpt) {		    
+			try {
+			    gpxDate.parse(strData.substring(0,19),&quot;yyyy-MM-dd'T'HH:mm:ss&quot;);
+			} catch (IllegalArgumentException e) {
+			    gpxDate.setTime(0);
+			    Global.getPref().log(&quot;Error parsing date: '&quot;+strData+&quot;'. Ignoring.&quot;);
+			}
+			return;
+		}
+
+		if (name.equals(&quot;time&quot;) &amp;&amp; inWpt) {
+			holder.setDateHidden(strData.substring(0,10)); //Date;
+			return;
+		}
+		// cache information
+		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;)|| name.equals(&quot;terra:terracache&quot;)) {
+			inCache = false;
+		}
+		
+		if (name.equals(&quot;name&quot;) &amp;&amp; inWpt &amp;&amp; !inCache) {
+			holder.setWayPoint(strData);
+			if (gpxDate.getTime()!=0) {
+			    holder.setLastSync(gpxDate.format(&quot;yyyyMMddHHmmss&quot;));
+			} else {
+			    holder.setLastSync(&quot;&quot;);
+			}    
+			//msgA.setText(&quot;import &quot; + strData);
+			return;
+		}
+		//Vm.debug(&quot;Check: &quot; + inWpt + &quot; / &quot; + fromOC);
+		//if (name.equals(&quot;desc&quot;) &amp;&amp; inWpt &amp;&amp; fromOC) {
+		// fill name with contents of &lt;desc&gt;, in case of gc.com the name is
+		// later replaced by the contents of &lt;groundspeak:name&gt; which is shorter
+		if (name.equals(&quot;desc&quot;)&amp;&amp; inWpt ) {
+			holder.setCacheName(strData);
+			//Vm.debug(&quot;CacheName: &quot; + strData);
+			//msgA.setText(&quot;import &quot; + strData);
+			return;
+		}
+		if (name.equals(&quot;url&quot;)&amp;&amp; inWpt){
+			holder.getFreshDetails().URL = strData;
+			return;
+		}
+		
+		// Text for additional waypoints, no HTML
+		if (name.equals(&quot;cmt&quot;)&amp;&amp; inWpt){
+			holder.getFreshDetails().LongDescription = strData;
+			holder.setHTML(false);
+			return;
+		}
+		
+		// aditional wapypoint
+		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
+			holder.setType(CacheType.gpxType2CwType(strData));
+			holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+			holder.setHard(CacheTerrDiff.CW_DT_UNSET);
+			holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+			holder.setLastSync(&quot;&quot;);
+		}
+		
+		if ((name.equals(&quot;groundspeak:name&quot;)|| name.equals(&quot;terra:name&quot;)) &amp;&amp; inCache) {
+			holder.setCacheName(strData);
+			return;
+		}
+		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;)||name.equals(&quot;terra:owner&quot;)) {
+			holder.setCacheOwner(strData);
+			if(pref.myAlias.equals(strData)) holder.setOwned(true);
+			return;
+		}
+		if (name.equals(&quot;groundspeak:difficulty&quot;) || name.equals(&quot;difficulty&quot;) || name.equals(&quot;terra:mental_challenge&quot;)) {
+			holder.setHard(CacheTerrDiff.v1Converter(strData));
+			return;
+		}
+		if (name.equals(&quot;groundspeak:terrain&quot;)|| name.equals(&quot;terrain&quot;)|| name.equals(&quot;terra:physical_challenge&quot;)) {
+			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
+			return;
+		}
+		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){
+			holder.setType(CacheType.gpxType2CwType(strData));
+			if (holder.getType() == CacheType.CW_TYPE_CUSTOM) {
+				holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				holder.setHard(CacheTerrDiff.CW_DT_UNSET);
+				holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+			}
+			return;
+		}
+		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){
+			holder.setCacheSize(CacheSize.gcGpxString2Cw(strData));
+			return;
+		}
+		if (name.equals(&quot;groundspeak:country&quot;)|| name.equals(&quot;country&quot;)){
+			holder.getFreshDetails().Country = strData;
+			return;
+		}
+		if (name.equals(&quot;groundspeak:state&quot;)|| name.equals(&quot;state&quot;)){
+			holder.getFreshDetails().State = strData;
+			return;
+		}
+		if (name.equals(&quot;terra:size&quot;)){
+			holder.setCacheSize(CacheSize.tcGpxString2Cw(strData));
+		}
+
+		if (name.equals(&quot;groundspeak:short_description&quot;)|| name.equals(&quot;summary&quot;)) {
+			if (holder.is_HTML())	holder.getFreshDetails().LongDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
+			else holder.getFreshDetails().LongDescription =strData+&quot;\n&quot;;
+			return;
+		}
+
+		if (name.equals(&quot;groundspeak:long_description&quot;)|| name.equals(&quot;description&quot;)|| name.equals(&quot;terra:description&quot;)) {
+			if (holder.is_HTML())	holder.getFreshDetails().LongDescription +=SafeXML.cleanback(strData);
+			else holder.getFreshDetails().LongDescription +=strData;
+			return;
+		}
+		if (name.equals(&quot;groundspeak:encoded_hints&quot;) || name.equals(&quot;hints&quot;)) {
+			holder.getFreshDetails().Hints = Common.rot13(strData);
+			return;
+		}
+		
+		if (name.equals(&quot;terra:hint&quot;)) {
+			// remove &quot;&lt;br&gt;&lt;br&gt;&quot; from the end
+			int indexTrash = strData.indexOf(&quot;&lt;br&gt;&lt;br&gt;&quot;);
+			if (indexTrash &gt; 0)	holder.getFreshDetails().Hints = Common.rot13(strData.substring(0,indexTrash));
+			return;
+		}
+
+
+	}
+	public void characters(char[] ch,int start,int length){
+		strBuf.append(ch,start,length);
+		if (debugGPX) Vm.debug(&quot;Char: &quot; + strBuf.toString());
+	}
+	
+
+	public static String typeText2Image(String typeText){
+		if (typeText.equals(&quot;Found it&quot;)||typeText.equals(&quot;Found&quot;)||typeText.equals(&quot;find&quot;)) return &quot;icon_smile.gif&quot;;
+		if (typeText.equals(&quot;Didn't find it&quot;)||typeText.equals(&quot;Not Found&quot;)||typeText.equals(&quot;no_find&quot;)) return &quot;icon_sad.gif&quot;;
+		if (typeText.equals(&quot;Write note&quot;)||typeText.equals(&quot;Note&quot;)||typeText.equals(&quot;note&quot;)
+			||typeText.equals(&quot;Not Attempted&quot;)||typeText.equals(&quot;Other&quot;)) return &quot;icon_note.gif&quot;;
+		if (typeText.equals(&quot;Enable Listing&quot;)) return &quot;icon_enabled.gif&quot;;
+		if (typeText.equals(&quot;Temporarily Disable Listing&quot;)) return &quot;icon_disabled.gif&quot;;
+		if (typeText.equals(&quot;Webcam Photo Taken&quot;)) return &quot;11.png&quot;;
+		if (typeText.equals(&quot;Attended&quot;)) return &quot;icon_attended.gif&quot;;
+		if (typeText.equals(&quot;Publish Listing&quot;)) return &quot;green.png&quot;;
+		if (typeText.equals(&quot;Will Attend&quot;)) return &quot;icon_rsvp.gif&quot;;
+		if (typeText.equals(&quot;Post Reviewer Note&quot;)) return &quot;big_smile.gif&quot;;
+		if (typeText.equals(&quot;Unarchive&quot;)) return &quot;traffic_cone.gif&quot;;
+		if (typeText.equals(&quot;Archive (show)&quot;)) return &quot;traffic_cone.gif&quot;;
+		if (typeText.equals(&quot;Owner Maintenance&quot;)) return &quot;icon_maint.gif&quot;;
+		if (typeText.equals(&quot;Needs Maintenance&quot;)) return &quot;icon_needsmaint.gif&quot;;
+		if (typeText.equals(&quot;Update Coordinates&quot;)) return &quot;coord_update.gif&quot;;
+		//Vm.debug(&quot;Unknown Log Type:&quot; + typeText);
+		return typeText;
+	}
+	
+	public static String TCSizetoText(String size){
+		if (size.equals(&quot;1&quot;)) return &quot;Micro&quot;;
+		if (size.equals(&quot;2&quot;)) return &quot;Medium&quot;;
+		if (size.equals(&quot;3&quot;)) return &quot;Regular&quot;;
+		if (size.equals(&quot;4&quot;)) return &quot;Large&quot;;
+		if (size.equals(&quot;5&quot;)) return &quot;Very Large&quot;;
+
+		return &quot;None&quot;;
+	}
+
+	/**
+	* Method to iterate through cache database and look for waypoint.
+	* Returns value &gt;= 0 if waypoint is found, else -1
+	*/
+	/*
+	private int searchWpt(Vector db, String wpt){
+		if(wpt.length()&gt;0){
+			wpt = wpt.toUpperCase();
+			CacheHolder ch = new CacheHolder();
+			//Search through complete database
+			for(int i = 0;i &lt; db.size();i++){
+				ch = (CacheHolder)db.get(i);
+				if(ch.wayPoint.indexOf(wpt) &gt;=0 ){
+					return i;
+				}
+			} // for
+		} // if
+		return -1;
+	}
+	*/
+	
+	private void spiderImagesUsingSpider(){
+		String addr;
+		String cacheText;
+		
+		// just to be sure to have a spider object
+		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
+		
+		if (fromTC) {
+				imgSpider.getImages(holder.getFreshDetails().LongDescription, holder.getFreshDetails());
+		}
+		else {
+			addr = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + holder.getWayPoint() ;
+			//Vm.debug(addr + &quot;|&quot;);
+			cacheText = SpiderGC.fetch(addr);
+			imgSpider.getImages(cacheText, holder.getFreshDetails());
+			try {
+				imgSpider.getAttributes(cacheText, holder.getFreshDetails());
+			} catch (Exception e) {
+				if (Global.getPref().debug) Global.getPref().log(&quot;unable to fetch attrivbutes for&quot;+holder.getWayPoint(), e);
+			}
+		}
+	}
+	
+	public static String replace(String source, String pattern, String replace){
+		if (source!=null)
+		{
+			final int len = pattern.length();
+			StringBuffer sb = new StringBuffer();
+			int found = -1;
+			int start = 0;
+		
+			while( (found = source.indexOf(pattern, start) ) != -1) {
+			    sb.append(source.substring(start, found));
+			    sb.append(replace);
+			    start = found + len;
+			}
+		
+			sb.append(source.substring(start));
+		
+			return sb.toString();
+		}
+		else return &quot;&quot;;
+	}
+}


Property changes on: trunk/src/CacheWolf/imp/GPXImporter.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/src/CacheWolf/imp/OCXMLImporter.java (from rev 1941, trunk/src/CacheWolf/OCXMLImporter.java)
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-06-24 17:27:40 UTC (rev 1941)
+++ trunk/src/CacheWolf/imp/OCXMLImporter.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -0,0 +1,731 @@
+package CacheWolf.imp;
+
+import utils.FileBugfix;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheSize;
+import CacheWolf.CacheTerrDiff;
+import CacheWolf.CacheType;
+import CacheWolf.Common;
+import CacheWolf.InfoBox;
+import CacheWolf.Log;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import CacheWolf.SafeXML;
+import CacheWolf.UrlFetcher;
+
+import com.stevesoft.ewe_pat.Regex;
+
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+import ewe.io.*;
+import ewe.sys.*;
+import ewe.ui.FormBase;
+import ewe.ui.MessageBox;
+import ewe.util.*;
+import ewe.util.zip.*;
+import ewe.net.*;
+import ewe.sys.Double;
+
+/**
+ *	Class to import Data from opencaching.de. 
+ *	It uses the lastmodified parameter to identify new or changed caches.
+ *	See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
+ *   See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
+ *	for more information.
+ */
+public class OCXMLImporter extends MinML {
+	static protected final int STAT_INIT = 0;
+	static protected final int STAT_CACHE = 1;
+	static protected final int STAT_CACHE_DESC = 2;
+	static protected final int STAT_CACHE_LOG = 3;
+	static protected final int STAT_PICTURE = 4;
+
+	final static String OPENCACHING_HOST = &quot;www.opencaching.de&quot;;
+	int state = STAT_INIT;
+	int numCacheImported, numDescImported, numLogImported= 0;
+
+	boolean debugGPX = false;
+	CacheDB cacheDB;
+	InfoBox inf;
+	CacheHolder ch;
+	CacheHolder holder;
+	Preferences pref;
+	Profile profile;
+	Time dateOfthisSync;
+	String strData = new String();
+	int picCnt;
+	boolean incUpdate = true; // complete or incremental Update
+	boolean ignoreDesc = false;
+	boolean askForOptions = true;
+	Hashtable DBindexID = new Hashtable();
+
+	String picUrl = new String();
+	String picTitle =  new String();
+	String picID = new String();
+	String ocSeekUrl = new String(&quot;<A HREF="http://">http://</A>&quot;+OPENCACHING_HOST+&quot;/viewcache.php?cacheid=&quot;);
+	String cacheID = new String();
+
+	String logData, logIcon, logDate, logFinder, logId;
+	boolean loggerRecommended;
+	int logtype;
+	String user;
+	double longitude;
+
+
+	public OCXMLImporter(Preferences p,Profile prof)
+	{
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+		if(profile.getLast_sync_opencaching() == null ||
+				profile.getLast_sync_opencaching().length() &lt; 12){
+			profile.setLast_sync_opencaching(&quot;20050801000000&quot;);
+			incUpdate = false;
+		}
+		user = p.myAlias.toLowerCase();
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = cacheDB.get(i);
+			if (!ch.getOcCacheID().equals(&quot;&quot;))
+				DBindexID.put(ch.getOcCacheID(), new Integer(i));
+		}//for
+
+	}
+
+	/** true, if not the last syncdate shall be used, but the caches shall be reloaded
+	 * only used in syncSingle */
+	boolean reload;
+	/**
+	 * 
+	 * @param number
+	 * @param infB
+	 * @return true, if some change was made to the cacheDB
+	 */
+	public boolean syncSingle(int number, InfoBox infB) {
+		ch = cacheDB.get(number);
+		holder= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
+
+		if (infB.isClosed) {
+			if (askForOptions) return false; 
+			else return true;
+		}
+		if (askForOptions) {
+			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL);
+			if (importOpt.execute() == FormBase.IDCANCEL) {	return false; }
+			askForOptions = false;
+			reload = importOpt.missingCheckBox.getState();
+		}
+
+		// this is only a dummy-InfoBox for capturing the output
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+//		inf.setPreferredSize(220, 300);
+//		inf.relayout(false);
+//		inf.exec();
+
+		String lastS; 
+		if (reload)  lastS = &quot;20050801000000&quot;;
+		else {
+			if (ch.getLastSync().length() &lt; 14) lastS = &quot;20050801000000&quot;;
+			else lastS = ch.getLastSync();
+		}
+		dateOfthisSync = new Time();
+		dateOfthisSync.parse(lastS, &quot;yyyyMMddHHmmss&quot;);
+	
+
+		String url = new String();
+		picCnt = 0;
+		//Build url
+		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
+			+ &quot;modifiedsince=&quot; + lastS
+			+ &quot;&amp;cache=1&quot;
+			+ &quot;&amp;cachedesc=1&quot;;
+		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
+		else url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot;
+			+ &quot;&amp;removedobject=0&quot;
+			+ &quot;&amp;wp=&quot; + ch.getWayPoint()
+			+ &quot;&amp;charset=utf-8&quot;
+			+ &quot;&amp;cdata=0&quot;
+			+ &quot;&amp;session=0&quot;;
+		syncOC(url);
+		inf.close(0);
+		return true;
+	}
+
+	public void doIt(){
+		boolean success=true;
+		String finalMessage;
+
+		
+		String url = new String();
+
+		String lastS =  profile.getLast_sync_opencaching();
+		CWPoint centre = pref.curCentrePt; // No need to clone curCentrePt as centre is only read
+		if (!centre.isValid()) {
+			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, FormBase.OKB)).execute();
+			return;
+		}
+		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),
+																 OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES);
+		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
+		Vm.showWait(true);
+		String dist = importOpt.distanceInput.getText();
+		if (dist.length()== 0) return;
+		
+		Double distDouble = new Double();
+		distDouble.value = Common.parseDouble(dist);
+		dist = distDouble.toString(0, 1, 0).replace(',', '.');
+		//check, if distance is greater than before
+		if (Convert.toInt(dist) &gt; Convert.toInt(profile.getDistOC()) ||
+				pref.downloadmissingOC  ){
+			// resysnc
+			lastS = &quot;20050801000000&quot;;
+			incUpdate = false;
+		}
+		profile.setDistOC(dist);
+		// Clear status of caches in db
+		for(int i = cacheDB.size()-1; i&gt;=0 ;i--){
+			ch = cacheDB.get(i);
+			ch.setUpdated(false);
+			ch.setNew(false);
+			ch.setLog_updated(false);
+		}	
+		picCnt = 0;
+		//Build url
+		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
+			+ &quot;modifiedsince=&quot; + lastS
+			+ &quot;&amp;cache=1&quot;
+			+ &quot;&amp;cachedesc=1&quot;;
+		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
+		else url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot;
+			+ &quot;&amp;removedobject=0&quot;
+			+ &quot;&amp;lat=&quot; + centre.getLatDeg(CWPoint.DD)
+			+ &quot;&amp;lon=&quot; + centre.getLonDeg(CWPoint.DD)
+			+ &quot;&amp;distance=&quot; + dist
+			+ &quot;&amp;charset=utf-8&quot;
+			+ &quot;&amp;cdata=0&quot;
+			+ &quot;&amp;session=0&quot;;
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		inf.setPreferredSize(220, 300);
+		inf.relayout(false);
+		inf.exec();
+
+		success = syncOC(url);
+		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		Vm.showWait(false);
+		if (success) {
+			profile.setLast_sync_opencaching(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
+			//pref.savePreferences();
+			finalMessage = MyLocale.getMsg(1607,&quot;Update from opencaching successful&quot;); 
+			inf.addWarning(&quot;\nNumber of&quot;+
+			&quot;\n...caches new/updated: &quot; + numCacheImported +
+			&quot;\n...cache descriptions new/updated: &quot; + numDescImported +
+			&quot;\n...logs new/updated: &quot; + numLogImported);
+			inf.setInfo(finalMessage);
+		}
+		inf.addOkButton();
+	}
+	
+	private boolean syncOC(String url) {
+		String finalMessage = new String();
+		boolean success=true;
+		File tmpFile = null;
+		BufferedReader r;
+		String file = new String();
+
+		//inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		
+		picCnt = 0;
+		try{
+			holder = null;
+			file = fetch(url, &quot;dummy&quot;);
+
+			//parse
+			tmpFile = new FileBugfix(profile.dataDir + file);
+			if (tmpFile.getLength() == 0 ) {
+				throw new IOException(&quot;no updates available&quot;);
+			}
+
+			ZipFile zif = new ZipFile (profile.dataDir + file);
+			ZipEntry zipEnt;
+			Enumeration zipEnum = zif.entries();
+			inf.setInfo(&quot;...unzipping update file&quot;); 
+			while (zipEnum.hasMoreElements())
+			{
+				zipEnt = (ZipEntry) zipEnum.nextElement();
+				// skip over PRC-files and empty files
+				if (zipEnt.getSize()&gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)){
+					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
+					parse(r);
+					r.close();
+				}
+			}
+			zif.close();
+		}catch (ZipException e){
+			finalMessage = MyLocale.getMsg(1614,&quot;Error while unzipping udpate file&quot;);
+			success = false;
+		}catch (IOException e){
+			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) { finalMessage = &quot;No updates available&quot;; success = false; }
+			else {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
+						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
+					finalMessage = MyLocale.getMsg(1616,&quot;Error: could not download udpate file from opencaching.de&quot;);
+				} else { finalMessage = &quot;IOException: &quot;+e.getMessage(); }
+				success = false;
+			}
+		}catch (IllegalArgumentException e) {
+			finalMessage = MyLocale.getMsg(1621,&quot;Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
+			success = false;
+			Vm.debug(&quot;Parse error: &quot; + state + &quot; &quot; + holder.getWayPoint());
+			e.printStackTrace();
+		}catch (Exception e){ // here should be used the correct exception
+			if (holder != null)	finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
+			else finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &lt;unkown&gt;&quot;;
+			success = false;
+			Vm.debug(&quot;Parse error: &quot; + state + &quot; Exception:&quot; + e.toString()+&quot;   &quot;+holder.getOcCacheID());
+			e.printStackTrace();
+		} finally {
+			if (tmpFile != null) tmpFile.delete();
+		}
+		/*
+		for (int i=cacheDB.size()-1; i &gt;=0; i--) {
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
+				ch.calcRecommendationScore();
+			}
+		} */
+		inf.setInfo(finalMessage);
+
+		return success;
+	}
+
+	public void startElement(String name, AttributeList atts){
+		if (debugGPX){
+			for (int i = 0; i &lt; atts.getLength(); i++) {
+				Vm.debug(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
+			}
+		}
+		strData =&quot;&quot;;
+
+		if (name.equals(&quot;oc11xml&quot;)){
+			Time lastSync = new Time();
+			try {
+				lastSync.parse(atts.getValue(&quot;date&quot;),&quot;yyyy-MM-dd HH:mm:ss&quot;);
+			}catch (IllegalArgumentException e){ // TODO Fehler werfen
+				Vm.debug(e.toString());
+			}
+			// reduce time at 1 second to avoid sync problems
+			lastSync.setTime(lastSync.getTime() - 1000);
+			dateOfthisSync = lastSync;
+			state = STAT_INIT;
+		}
+
+		// look for changes in the state
+		if (name.equals(&quot;cache&quot;)) 		{ state = STAT_CACHE; numCacheImported++;}
+		if (name.equals(&quot;cachedesc&quot;)) 	{ state = STAT_CACHE_DESC; numDescImported++;}
+		if (name.equals(&quot;cachelog&quot;)) 	{ state = STAT_CACHE_LOG; numLogImported++; logtype = 0;}
+		if (name.equals(&quot;picture&quot;)) 	{ state = STAT_PICTURE; }
+
+		//examine data
+		switch (state) {
+		case STAT_CACHE: startCache(name, atts); break;
+		case STAT_CACHE_DESC: startCacheDesc(name, atts); break; 
+		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
+		case STAT_PICTURE: startPicture(name,atts); break;
+		}
+
+	}
+
+	public void endElement(String name){
+		//examine data
+		switch (state) {
+		case STAT_CACHE: endCache(name); break;
+		case STAT_CACHE_DESC: endCacheDesc(name);break;
+		case STAT_CACHE_LOG: endCacheLog(name); break;
+		case STAT_PICTURE: endPicture(name); break;
+		}
+
+		// look for changes in the state
+		if (name.equals(&quot;cache&quot;)) 		state = STAT_INIT;
+		if (name.equals(&quot;cachedesc&quot;)) 	state = STAT_INIT;
+		if (name.equals(&quot;cachelog&quot;)) 	state = STAT_INIT;
+		if (name.equals(&quot;picture&quot;)) 	state = STAT_INIT;
+
+	}
+
+	public void characters(char[] ch2,int start,int length){
+		String chars = new String(ch2,start,length);
+		strData += chars;
+		if (debugGPX) Vm.debug(strData);
+	}
+
+	private void startCache(String name, AttributeList atts){
+		inf.setInfo(MyLocale.getMsg(1609,&quot;Importing Cache:&quot;)+&quot; &quot; + numCacheImported + &quot;\n&quot;);
+		if(name.equals(&quot;id&quot;)){
+			cacheID = atts.getValue(&quot;id&quot;);
+		}
+		if(name.equals(&quot;type&quot;)){
+			holder.setType(CacheType.ocType2CwType(atts.getValue(&quot;id&quot;)));
+			return;
+		}
+		if(name.equals(&quot;status&quot;)){
+			if(atts.getValue(&quot;id&quot;).equals(&quot;1&quot;)) holder.setAvailable(true);
+			if(atts.getValue(&quot;id&quot;).equals(&quot;2&quot;)) holder.setAvailable(false);
+			if(atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) {
+				holder.setArchived(true);
+				holder.setAvailable(false);
+			}
+			if(atts.getValue(&quot;id&quot;).equals(&quot;4&quot;)) holder.setAvailable(false);
+			return;
+		}
+		if(name.equals(&quot;size&quot;)){
+			holder.setCacheSize(CacheSize.ocXmlString2Cw(atts.getValue(&quot;id&quot;)));
+			return;
+		}
+
+		if(name.equals(&quot;waypoints&quot;)){
+			holder.setWayPoint(atts.getValue(&quot;oc&quot;));
+			if (holder.getWayPoint().length()==0) throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
+			return;
+		}
+
+	}
+	private void startCacheDesc(String name, AttributeList atts){
+		inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported);
+		if (name.equals(&quot;cachedesc&quot;)){
+			ignoreDesc = false;
+		}
+
+		if (name.equals(&quot;desc&quot;)){
+			holder.setHTML(atts.getValue(&quot;html&quot;).equals(&quot;1&quot;)?true:false);
+		}
+
+		if (name.equals(&quot;language&quot;) &amp;&amp; !atts.getValue(&quot;id&quot;).equals(&quot;DE&quot;)){
+			if (holder.getFreshDetails().LongDescription.length()&gt; 0) ignoreDesc = true; // TODO &quot;DE&quot; in preferences adjustable
+			else ignoreDesc = false;
+		}
+	}
+
+	private void startPicture(String name, AttributeList atts){
+		if(name.equals(&quot;picture&quot;)){
+			inf.setInfo(MyLocale.getMsg(1613,&quot;Pictures:&quot;)+&quot; &quot; + ++picCnt);
+		}
+	}
+
+	private void startCacheLog(String name, AttributeList atts){
+		inf.setInfo(MyLocale.getMsg(1612,&quot;Importing Cachlog:&quot;)+&quot; &quot; + numLogImported);
+		if (name.equals(&quot;logtype&quot;)){
+			logtype = Convert.toInt(atts.getValue(&quot;id&quot;));
+			switch (logtype) {
+			case 1: 
+				logIcon = GPXImporter.typeText2Image(&quot;Found&quot;);
+				break;
+			case 2:	logIcon = GPXImporter.typeText2Image(&quot;Not Found&quot;); 
+			holder.setNoFindLogs((byte)(holder.getNoFindLogs()+1));
+			break;
+			case 3: logIcon = GPXImporter.typeText2Image(&quot;Note&quot;);
+			}
+			loggerRecommended = atts.getValue(&quot;recommended&quot;).equals(&quot;1&quot;);
+			return;
+		}
+		
+		if (name.equals(&quot;id&quot;)){
+			logId = atts.getValue(&quot;id&quot;);
+		}
+	}
+
+	// TODO Do we have to release the &quot;holder&quot; cache details ?
+	private void endCache(String name){
+		if (name.equals(&quot;cache&quot;)){
+			holder.setLastSync(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
+			int index;
+			index = cacheDB.getIndex(holder.getWayPoint());
+			if (index == -1){
+				holder.setNew(true);
+				cacheDB.add(holder);
+				Integer indexInt = new Integer(cacheDB.size()-1);
+				DBindexID.put(holder.getOcCacheID(), indexInt);
+			}
+			// update (overwrite) data
+			else {
+				holder.setNew(false);
+				holder.setIncomplete(false);
+				cacheDB.get(index).update(holder);
+				// save ocCacheID, in case, the previous data is from GPX
+				DBindexID.put(holder.getOcCacheID(), new Integer(index));
+			}
+			// clear data (picture, logs) if we do a complete Update
+			if (incUpdate == false){
+				holder.getFreshDetails().CacheLogs.clear();
+				holder.getFreshDetails().Images.clear();
+				holder.getFreshDetails().ImagesText.clear();
+				holder.getFreshDetails().ImagesInfo.clear();
+			}
+
+			// save all
+			holder.getFreshDetails().hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
+			// chD.saveCacheDetails(profile.dataDir); 
+			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
+			return;
+		}
+		if(name.equals(&quot;id&quot;)){ // &lt;/id&gt;
+			holder = getHolder(strData); // Allocate a new CacheHolder object
+			holder.setOcCacheID(strData);
+			holder.getFreshDetails().URL = ocSeekUrl + cacheID;
+			return;
+		}
+
+		if(name.equals(&quot;name&quot;)){
+			holder.setCacheName(strData);
+			return;
+		}
+		if(name.equals(&quot;userid&quot;)) {
+			holder.setCacheOwner(strData);
+			if(holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) holder.setOwned(true);
+			return;
+		}
+
+		if(name.equals(&quot;longitude&quot;)){
+			longitude = Common.parseDouble(strData);
+			return;
+		}
+		if(name.equals(&quot;latitude&quot;)) {
+			holder.pos.set(Common.parseDouble(strData),longitude);
+			holder.LatLon = holder.pos.toString();
+			return;
+		}
+		if(name.equals(&quot;difficulty&quot;)) {
+			holder.setHard(CacheTerrDiff.v1Converter(strData));
+			return;
+		}
+		if(name.equals(&quot;terrain&quot;)) {
+			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
+			return;
+		}
+		if(name.equals(&quot;datehidden&quot;)) {
+			holder.setDateHidden(strData.substring(0,10)); //Date;
+			return;
+		}
+		if (name.equals(&quot;country&quot;)){
+			holder.getFreshDetails().Country = strData;
+			return;
+		}
+	}
+
+	private void endCacheDesc(String name){
+
+		if (!ignoreDesc){
+			if (name.equals(&quot;cachedesc&quot;)){
+				if (pref.downloadPics &amp;&amp; holder.is_HTML()) {
+					String fetchUrl, imgTag, imgAltText;
+					Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); //  Ergebnis enth&#228;lt keine Anf&#252;hrungszeichen
+					Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;); // get alternative text for Pic
+					imgRegexAlt.setIgnoreCase(true);
+					imgRegexUrl.setIgnoreCase(true);
+					int descIndex=0;
+					int numDownloaded=1;
+					while (imgRegexUrl.searchFrom(holder.getFreshDetails().LongDescription, descIndex)) { // &quot;img&quot; found
+						imgTag=imgRegexUrl.stringMatched(1); // (1) enth&#228;lt das gesamte &lt;img ...&gt;-tag
+						fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anf&#252;hrungszeichen 
+						if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
+						if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
+							inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot;+holder.getWayPoint()));
+							continue;
+						}
+						inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported + &quot;\n&quot;+MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
+						if (imgRegexAlt.search(imgTag)) {
+							imgAltText=imgRegexAlt.stringMatched(1);
+							if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
+							// kein alternativer Text als Bild&#252;berschrift -&gt; Dateiname
+						} else { 
+							if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.de&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend 
+								imgAltText = new String(&quot;No image title&quot;);
+							else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf(&quot;/&quot;)+1);
+						}
+						descIndex = imgRegexUrl.matchedTo();
+						getPic(fetchUrl, imgAltText);
+					}
+				}
+				holder.getFreshDetails().hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+				return;
+			}
+
+
+			if (name.equals(&quot;cacheid&quot;)){
+				// load cachedata
+				holder = getHolder(strData);
+				holder.setUpdated(true);
+				return;
+			}
+
+			if (name.equals(&quot;shortdesc&quot;)){
+				holder.getFreshDetails().LongDescription = strData;
+				return;
+			}
+
+			if (name.equals(&quot;desc&quot;)){ // &lt;/desc&gt;
+				if (holder.is_HTML())	holder.getFreshDetails().LongDescription +=SafeXML.cleanback(strData);
+				else holder.getFreshDetails().LongDescription +=strData;
+				return;
+			}
+			if (name.equals(&quot;hint&quot;)){
+				holder.getFreshDetails().Hints = Common.rot13(strData);
+				return;
+			}
+		}
+	}
+
+	private String createPicFilename(String fetchURL) {
+		String fileName = holder.getWayPoint() + &quot;_&quot; + fetchURL.substring(fetchURL.lastIndexOf(&quot;/&quot;)+1);
+		return Common.ClearForFileName(fileName);
+	}
+	
+	private void getPic(String fetchURL, String picDesc) { // TODO handling of relativ URLs
+		try {
+			if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST+&quot;/&quot;), fetchURL).toString(); // TODO this is not quite correct: actually the &quot;base&quot; URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
+			String fileName = createPicFilename(fetchURL);
+			// add title
+			holder.getFreshDetails().ImagesText.add(picDesc);
+			holder.getFreshDetails().ImagesInfo.add(null); // need to stay in sync with ImagesText
+			try {
+				File ftest = new File(profile.dataDir + fileName);
+				if (ftest.exists()){
+					holder.getFreshDetails().Images.add(fileName);
+				}
+				else {
+					if (pref.downloadPics) {
+						holder.getFreshDetails().Images.add(fetch(fetchURL, fileName));
+					}
+				}
+			} catch (IOException e) {
+				String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+fetchURL); 
+				if (e.getMessage().toLowerCase().equalsIgnoreCase(&quot;could not connect&quot;) ||
+						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
+					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+holder.getCacheName() + &quot; (&quot;+holder.getWayPoint()+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+fetchURL;
+				} 
+				inf.addWarning(&quot;\n&quot;+ErrMessage);
+				//(new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), ErrMessage, MessageBox.OKB)).exec();
+				pref.log(ErrMessage);
+				e.printStackTrace();
+			}
+		} catch (MalformedURLException e) {
+			String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchURL); 
+			inf.addWarning(&quot;\n&quot;+ErrMessage);
+			pref.log(ErrMessage);
+		}
+
+	}
+
+
+	private void endPicture(String name){
+
+		if(name.equals(&quot;id&quot;)){
+			picID = strData;
+			return;
+		}
+
+		if (name.equals(&quot;url&quot;)){
+			picUrl = strData;
+			return;
+		}
+		if (name.equals(&quot;title&quot;)){
+			picTitle = strData;
+			return;
+		}
+		if(name.equals(&quot;object&quot;)){
+			// get cachedata
+			holder = getHolder(strData);
+			return;
+		}
+		if(name.equals(&quot;picture&quot;)){ 
+			//String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
+			getPic(picUrl,picTitle);
+			holder.getFreshDetails().hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+			return;
+		}
+	}
+
+	private void endCacheLog(String name){
+		if (name.equals(&quot;cachelog&quot;)){ // &lt;/cachelog&gt;
+			holder.getFreshDetails().CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
+			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1) {
+						holder.setCacheStatus(logDate);
+						holder.setFound(true);
+						holder.getFreshDetails().OwnLogId = logId;
+						holder.getFreshDetails().OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
+			}
+			holder.getFreshDetails().hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
+			return;
+		}
+
+		if (name.equals(&quot;cacheid&quot;)){ // &lt;/cacheid&gt;
+			// load cachedata
+			holder = getHolder(strData);
+			return;
+		}
+
+		if (name.equals(&quot;date&quot;))  {
+			logDate = new String(strData);
+			return;
+		}
+		if (name.equals(&quot;userid&quot;)){
+			logFinder = new String(strData);
+			return;
+		}
+		if (name.equals(&quot;text&quot;)){ 
+			logData = new String(strData);
+			return;
+		}
+
+	}
+
+	private String fetch(String addr, String fileName ) throws IOException
+	{
+		//Vm.debug(&quot;Redirect: &quot; + redirect);
+		CharArray realurl = new CharArray();
+		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
+		String address = realurl.toString();
+		if (holder != null) fileName = holder.getWayPoint() + &quot;_&quot; + Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
+		// else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
+
+		//save file
+		//Vm.debug(&quot;Save: &quot; + myPref.mydatadir + fileName);
+		//Vm.debug(&quot;Daten: &quot; + daten.length);
+		FileOutputStream outp =  new FileOutputStream(profile.dataDir + fileName);
+		outp.write(daten.toBytes());
+		outp.close();
+		return fileName;
+	}
+
+
+	/**
+	 * Method to iterate through cache database and look for cacheID.
+	 * Returns value &gt;= 0 if cacheID is found, else -1
+	 */
+	private int searchID(String cacxheID){
+		Integer INTR = (Integer)DBindexID.get(cacxheID);
+		if(INTR != null){
+			return INTR.intValue();
+		} else return -1;
+	}
+
+
+	private CacheHolder getHolder(String wpt){// See also LOCXMLImporter
+		CacheHolder chx;
+		int index;
+		
+		index = cacheDB.getIndex(wpt);
+		if (index == -1) index = searchID(wpt);
+		if (index == -1) {
+			chx = new CacheHolder();
+		} else {
+			chx = cacheDB.get(index);
+		}
+		return chx;
+	}
+
+}


Property changes on: trunk/src/CacheWolf/imp/OCXMLImporter.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/src/CacheWolf/imp/OCXMLImporterScreen.java (from rev 1941, trunk/src/CacheWolf/OCXMLImporterScreen.java)
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2009-06-24 17:27:40 UTC (rev 1941)
+++ trunk/src/CacheWolf/imp/OCXMLImporterScreen.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -0,0 +1,212 @@
+/**
+ * 
+ */
+package CacheWolf.imp;
+
+import CacheWolf.CacheType;
+import CacheWolf.Common;
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.imp.SpiderGC.SpiderProperties;
+import ewe.sys.Convert;
+import ewe.ui.*;
+
+/**
+ * @author pfeffer
+ * This Class is the Dialog for Download from Opencaching.de 
+ * is called from OCXMLImporter
+ * 20061209 Bugfix: Checking for uninitialised missingCheckBox
+ */
+public class OCXMLImporterScreen extends Form {
+	mButton cancelB, okB;
+	Preferences pref;
+	mChoice chcType;
+	mInput distanceInput;
+	mInput maxNumberInput;
+	mInput maxLogsInput;
+	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox, travelbugsCheckBox;
+	mLabel distLbl;
+	mLabel maxNumberLbl;
+	mLabel distUnit;
+	boolean isGC = true;
+	static int DIST = 1;
+	public static int IMAGES = 2;
+	static int ALL = 4;
+	static int INCLUDEFOUND = 8;
+	static int ISGC = 16;
+	static int MAXNUMBER = 32;
+	public static int TRAVELBUGS = 64;
+	public static int MAXLOGS = 128;
+	static int TYPE = 256;
+
+	
+	public OCXMLImporterScreen(String title, int options) {
+		super();
+		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
+		
+		isGC = ((options &amp; ISGC) &gt; 0);
+		
+		this.title = title;
+				
+		if ((options &amp; TYPE) &gt; 0) {
+			this.addLast( chcType = new mChoice(new String[] {
+					MyLocale.getMsg(1627,&quot;All caches&quot;),	
+					CacheType.CW_GUISTR_TRADI,
+					CacheType.CW_GUISTR_MULTI,
+					CacheType.CW_GUISTR_VIRTUAL,
+					CacheType.CW_GUISTR_LETTERBOX,
+					CacheType.CW_GUISTR_EVENT,
+					CacheType.CW_GUISTR_MEGAEVENT,
+					CacheType.CW_GUISTR_WEBCAM,
+					CacheType.CW_GUISTR_UNKNOWN,
+					CacheType.CW_GUISTR_CITO,
+					CacheType.CW_GUISTR_EARTH,
+					CacheType.CW_GUISTR_WHEREIGO
+				},0), CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		}
+
+		if ((options &amp; DIST) &gt; 0) {
+			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,&quot;Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			distanceInput = new mInput();
+			String dist1;
+			String dist2;
+			if (isGC) {
+				dist1 = Global.getProfile().getDistGC();
+				dist2 = Global.getProfile().getDistOC();
+			} else {
+				dist1 = Global.getProfile().getDistOC();
+				dist2 = Global.getProfile().getDistGC();
+			}
+			if ( dist1.equals(&quot;&quot;) || dist1.equals(&quot;0&quot;) || dist1.equals(&quot;0.0&quot;) ) {
+				dist1 = dist2;
+			}
+			distanceInput.setText(dist1);
+			this.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addLast(distUnit = new mLabel(&quot; km/mi.&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		}
+		
+		if ((options &amp; MAXNUMBER) &gt; 0) {
+			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623,&quot;Max. number:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			maxNumberInput = new mInput();
+			if ( pref.maxSpiderNumber &lt; 0 ) {
+				maxNumberInput.setText(&quot;&quot;);
+			} else {
+				maxNumberInput.setText(Integer.toString(pref.maxSpiderNumber));
+			}
+			this.addNext(maxNumberInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addLast( new mLabel(MyLocale.getMsg(1624,&quot; caches&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		}
+		
+		if ((options &amp; MAXLOGS) &gt; 0) {
+			this.addNext(new mLabel(MyLocale.getMsg(1626,&quot;Max. logs:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			maxLogsInput = new mInput();
+			maxLogsInput.setText(Convert.toString(pref.maxLogsToSpider));
+			this.addLast(maxLogsInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		}
+
+		if ((options &amp; IMAGES) &gt; 0) {
+			imagesCheckBox = new mCheckBox();
+			imagesCheckBox.setText(MyLocale.getMsg(1602,&quot;Download Images&quot;));
+			imagesCheckBox.setState(pref.downloadPics);
+			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		}
+		
+		if ((options &amp; TRAVELBUGS) &gt; 0) {
+			travelbugsCheckBox = new mCheckBox();
+			travelbugsCheckBox.setText(MyLocale.getMsg(1625,&quot;Download TBs&quot;));
+			travelbugsCheckBox.setState(pref.downloadTBs);
+			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		}
+		
+		if((options &amp; INCLUDEFOUND) &gt; 0){
+			foundCheckBox = new mCheckBox();
+			foundCheckBox.setText(MyLocale.getMsg(1622,&quot;Exclude found caches&quot;));
+			foundCheckBox.setState(true);
+			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		}
+
+		if((options &amp; ALL) &gt; 0){
+			missingCheckBox = new mCheckBox();
+			missingCheckBox.setText(MyLocale.getMsg(1606,&quot;Alle erneut downloaden&quot;));
+			missingCheckBox.setState(pref.downloadmissingOC);
+			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		}
+
+		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okB = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okB.setHotKey(0, IKeys.ACTION);
+		okB.setHotKey(0, IKeys.ENTER);
+		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+	}
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB){
+				this.close(FormBase.IDCANCEL);
+			}
+			if (ev.target == okB){
+				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr&#252;ft werden kann, ob es gr&#246;&#223;er oder kleiner ist als vorher
+					if (imagesCheckBox!=null) pref.downloadPics = imagesCheckBox.state;
+					if (missingCheckBox!=null) pref.downloadmissingOC = missingCheckBox.state;
+					if (travelbugsCheckBox!=null) pref.downloadTBs = travelbugsCheckBox.state;
+					if (maxLogsInput!=null) pref.maxLogsToSpider=Common.parseInt(maxLogsInput.getText());
+					pref.savePreferences();
+				this.close(FormBase.IDOK);
+				}
+		}
+		super.onEvent(ev);
+	}
+	
+	public String getCacheTypeRestriction(SpiderProperties p){
+		String cacheTypeRestriction = &quot;&quot;;
+
+		if (chcType!=null){
+			try {
+				switch (chcType.getInt()) {
+				case  0:
+					cacheTypeRestriction = &quot;&quot;;
+					break;
+				case  1: 
+					cacheTypeRestriction = p.getProp(&quot;onlyTraditional&quot;);
+					break;
+				case  2:
+					cacheTypeRestriction = p.getProp(&quot;onlyMulti&quot;);
+					break;
+				case  3:
+					cacheTypeRestriction = p.getProp(&quot;onlyVirtual&quot;) ;
+					break;
+				case  4:
+					cacheTypeRestriction = p.getProp(&quot;onlyLetterboxHybrid&quot;);
+					break;
+				case  5:
+					cacheTypeRestriction = p.getProp(&quot;onlyEvent&quot;);
+					break;
+				case  6:
+					cacheTypeRestriction = p.getProp(&quot;onlyMegaEvent&quot;);
+					break;
+				case  7:
+					cacheTypeRestriction = p.getProp(&quot;onlyWebcam&quot;);
+					break;
+				case  8:
+					cacheTypeRestriction = p.getProp(&quot;onlyUnknown&quot;);
+					break;
+				case 9:
+					cacheTypeRestriction = p.getProp(&quot;onlyCito&quot;);
+					break;
+				case 10:
+					cacheTypeRestriction = p.getProp(&quot;onlyEarth&quot;);
+					break;
+				case 11:
+					cacheTypeRestriction = p.getProp(&quot;onlyWherigo&quot;);
+					break;
+				default:
+					cacheTypeRestriction = &quot;&quot;;
+				}
+			}catch (Exception ex) { // Some tag missing from spider.def
+			}
+		}
+		return cacheTypeRestriction;
+	}
+}


Property changes on: trunk/src/CacheWolf/imp/OCXMLImporterScreen.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/src/CacheWolf/imp/SpiderGC.java (from rev 1949, trunk/src/CacheWolf/SpiderGC.java)
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-06-26 17:05:17 UTC (rev 1949)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2009-06-26 18:53:49 UTC (rev 1950)
@@ -0,0 +1,1697 @@
+/*
+    CacheWolf is a software for PocketPC, Win and Linux that
+    enables paperless caching.
+    It supports the sites geocaching.com and opencaching.de
+
+    Copyright (C) 2006  CacheWolf development team
+    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+    for more information.
+    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+		<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+
+package CacheWolf.imp;
+import ewe.net.*;
+import ewe.io.*;
+import ewe.sys.*;
+import ewe.sys.Double;
+import ewe.util.*;
+import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.CacheSize;
+import CacheWolf.CacheTerrDiff;
+import CacheWolf.CacheType;
+import CacheWolf.Common;
+import CacheWolf.DateFormat;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import CacheWolf.HttpConnection;
+import CacheWolf.InfoBox;
+import CacheWolf.Log;
+import CacheWolf.LogList;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import CacheWolf.STRreplace;
+import CacheWolf.SafeXML;
+import CacheWolf.Travelbug;
+import CacheWolf.navi.Metrics;
+
+import com.stevesoft.ewe_pat.*;
+import ewe.ui.*;
+import ewe.data.Property;
+import ewe.data.PropertyList;
+
+/**
+*	Class to spider caches from gc.com
+*/
+public class SpiderGC{
+
+	/**
+	 * The maximum number of logs that will be stored
+	 */
+	public static int MAXLOGS=250; // Can be pre-set from preferences
+	public static String passwort = &quot;&quot;; // Can be pre-set from preferences
+	public static boolean loggedIn = false;
+
+	private static int ERR_LOGIN = -10;
+	private static Preferences pref;
+	private Profile profile;
+	private static String viewstate = &quot;&quot;;
+	private static String viewstate1 = &quot;&quot;;
+	private static String eventvalidation = &quot;&quot;;
+	private static String cookieID = &quot;&quot;;
+	private static String cookieSession = &quot;&quot;;
+	private static double distance = 0;
+	private Regex inRex = new Regex();
+	private CacheDB cacheDB;
+	private Vector cachesToLoad = new Vector();
+	private InfoBox infB;
+	private static SpiderProperties p=null;
+
+	public SpiderGC(Preferences prf, Profile profile, boolean bypass){
+		this.profile=profile;
+		this.cacheDB = profile.cacheDB;
+		pref = prf;
+		if (p==null) {
+			pref.logInit();
+			p=new SpiderProperties();
+		}
+		MAXLOGS=pref.maxLogsToSpider;
+	}
+
+	/**
+	 * Method to login the user to gc.com
+	 * It will request a password and use the alias defined in preferences
+	 * If the login page cannot be fetched, the password is cleared.
+	 * If the login fails, an appropriate message is displayed.
+	 */
+	public int login(){
+		loggedIn = false;
+		String start,loginPage,loginSuccess,nextPage;
+		try {
+			loginPage=p.getProp(&quot;loginPage&quot;);
+			loginSuccess=p.getProp(&quot;loginSuccess&quot;);
+			nextPage=p.getProp(&quot;nextPage&quot;);
+		} catch (Exception ex) { // Tag not found in spider.def
+			return ERR_LOGIN;
+		}
+		//Get password
+		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506,&quot;Password&quot;), MyLocale.getMsg(5505,&quot;Enter Password&quot;), InfoBox.INPUT);
+		localInfB.feedback.setText(passwort); // Remember the PWD for next time
+		localInfB.feedback.isPassword=true;
+		int code=FormBase.IDOK;
+		if (passwort.equals(&quot;&quot;)) {
+			code = localInfB.execute();
+			passwort = localInfB.getInput();
+		}
+		localInfB.close(0);
+		if(code != FormBase.IDOK) return code;
+		// Now start the login proper
+		localInfB = new InfoBox(MyLocale.getMsg(5507,&quot;Status&quot;), MyLocale.getMsg(5508,&quot;Logging in...&quot;));
+		localInfB.exec();
+		try{
+			pref.log(&quot;[login]:Fetching login page&quot;);
+			//Access the page once to get a viewstate
+			start = fetch(loginPage);   //<A HREF="http://www.geocaching.com/login/Default.aspx">http://www.geocaching.com/login/Default.aspx</A>
+			if (start.equals(&quot;&quot;)) {
+				localInfB.close(0);
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
+				pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;);
+				return ERR_LOGIN;
+			}
+		} catch(Exception ex){
+			localInfB.close(0);
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
+			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;,ex);
+			return ERR_LOGIN;
+		}
+		if (!localInfB.isClosed) { // If user has not aborted, we continue
+			Regex rexCookieID = new Regex(&quot;(?i)Set-Cookie: userid=(.*?);.*&quot;);
+			Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+			Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+			Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+			Regex rexCookieSession = new Regex(&quot;(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*&quot;);
+			rexViewstate.search(start);
+			if(rexViewstate.didMatch()){
+				viewstate = rexViewstate.stringMatched(1);
+				//Vm.debug(&quot;ViewState: &quot; + viewstate);
+			} else
+				pref.log(&quot;[login]:Viewstate not found before login&quot;);
+
+			if(start.indexOf(loginSuccess) &gt; 0)
+				pref.log(&quot;[login]:Already logged in&quot;);
+			else {
+				rexEventvalidation.search(start);
+				if(rexEventvalidation.didMatch()){
+					eventvalidation = rexEventvalidation.stringMatched(1);
+					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
+				} else
+					pref.log(&quot;[login]:Eventvalidation not found before login&quot;);
+				//Ok now login!
+				try{
+					pref.log(&quot;[login]:Logging in as &quot;+pref.myAlias);
+					StringBuffer sb=new StringBuffer(1000);
+					sb.append(URL.encodeURL(&quot;__VIEWSTATE&quot;,false));	sb.append(&quot;=&quot;); sb.append(URL.encodeURL(viewstate,false));
+					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;myUsername&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
+					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;myPassword&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
+					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;cookie&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;on&quot;,false));
+					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;); sb.append(URL.encodeURL(&quot;Button1&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;Login&quot;,false));
+//					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false));
+//					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(eventvalidation,false));
+					start = fetch_post(loginPage, sb.toString(), nextPage);  // /login/default.aspx
+					if(start.indexOf(loginSuccess) &gt; 0)
+						pref.log(&quot;[login]:Login successful&quot;);
+					else {
+						pref.log(&quot;[login]:Login failed. Wrong Account or Password?&quot;);
+						if (pref.debug) {
+							pref.log(&quot;[login.LoginUrl]:&quot;+sb.toString());
+							pref.log(&quot;[login.Answer]:&quot;+start);
+						}
+						localInfB.close(0);
+						(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
+						return ERR_LOGIN;
+					}
+				}catch(Exception ex){
+					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
+					localInfB.close(0);
+					(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
+					return ERR_LOGIN;
+				}
+			}
+
+			rexViewstate.search(start);
+			if (!rexViewstate.didMatch()) {
+				pref.log(&quot;[login]:Viewstate not found&quot;);
+			}
+			viewstate = rexViewstate.stringMatched(1);
+
+			rexViewstate1.search(start);
+			if (!rexViewstate1.didMatch()) {
+				pref.log(&quot;[login]:Viewstate1 not found&quot;);
+			}
+			viewstate1 = rexViewstate1.stringMatched(1);
+
+			rexCookieID.search(start);
+			if (!rexCookieID.didMatch()) {
+				pref.log(&quot;[login]:CookieID not found. Using old one.&quot;);
+			} else
+				cookieID = rexCookieID.stringMatched(1);
+			//Vm.debug(cookieID);
+			rexCookieSession.search(start);
+			if (!rexCookieSession.didMatch()) {
+				pref.log(&quot;[login]:CookieSession not found. Using old one.&quot;);
+				//cookieSession=&quot;&quot;;
+			} else
+				cookieSession = rexCookieSession.stringMatched(1);
+			//Vm.debug(&quot;cookieSession = &quot; + cookieSession);
+		}
+		boolean loginAborted=localInfB.isClosed;
+		localInfB.close(0);
+		if (loginAborted)
+			return FormBase.IDCANCEL;
+		else {
+			loggedIn = true;
+			return FormBase.IDOK;
+		}
+	}
+
+	/**
+	 * Method to spider a single cache.
+	 * It assumes a login has already been performed!
+	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
+	 */
+	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin){
+		int ret=-1;
+		this.infB = pInfB;
+		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
+		ch.setWayPoint(cacheDB.get(number).getWayPoint());
+		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
+
+		// check if we need to login
+		if (!loggedIn || forceLogin){
+			if (this.login()!=FormBase.IDOK) return -1;
+			// loggedIn is already set by this.login()
+		}
+		try{
+			// Read the cache data from GC.COM and compare to old data
+			boolean loadAllLogs = (MAXLOGS &gt; 5);
+			ret=getCacheByWaypointName(ch,true,pref.downloadPics,pref.downloadTBs,false,loadAllLogs);
+			// Save the spidered data
+			if (ret == 1) {
+				CacheHolder cacheInDB = cacheDB.get(number);
+				cacheInDB.initStates(false);
+				if (cacheInDB.is_found() &amp;&amp; !ch.is_found() &amp;&amp; ! loadAllLogs) {
+					// If the number of logs to spider is 5 or less, then the &quot;not found&quot; information
+					// of the spidered cache is not credible. In this case it should not overwrite
+					// the &quot;found&quot; state of an existing cache.
+					ch.setFound(true);
+				}
+				cacheInDB.update(ch);
+				cacheInDB.save();
+			}
+		}catch(Exception ex){
+			pref.log(&quot;Error spidering &quot; + ch.getWayPoint() + &quot; in spiderSingle&quot;);
+		}
+		return ret;
+	} // spiderSingle
+
+	/**
+	 * Fetch the coordinates of a waypoint from GC
+	 * @param wayPoint the name of the waypoint
+	 * @return the cache coordinates
+	 */
+	public String getCacheCoordinates(String wayPoint) {
+		String completeWebPage;
+		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
+		// Try to login. If login fails, issue appropriate message and terminate
+		if (!loggedIn || Global.getPref().forceLogin) {
+			if (login()!=FormBase.IDOK) {
+				return &quot;&quot;;
+			}
+		}
+		InfoBox localInfB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
+		localInfB.exec();
+		try{
+			String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
+			pref.log(&quot;Fetching: &quot; + wayPoint);
+			completeWebPage = fetch(doc);
+		}catch(Exception ex){
+			localInfB.close(0);
+			pref.log(&quot;Could not fetch &quot; + wayPoint,ex);
+			return &quot;&quot;;
+		}
+		localInfB.close(0);
+		try {
+			return getLatLon(completeWebPage);
+		} catch (Exception ex) {
+			return &quot;????&quot;;
+		}
+	}
+
+	/**
+	*	Method to start the spider for a search around the centre coordinates
+	*/
+	public void doIt(){
+		doIt(false);
+	}
+	public void doIt(boolean spiderAllFinds){
+		String postStr, dummy, ln, wpt;
+		Regex lineRex;
+		CacheHolder holder;
+		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
+		if ( !spiderAllFinds &amp;&amp; !origin.isValid()) {
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
+			return;
+		}
+		if (System.getProperty(&quot;os.name&quot;)!=null)pref.log(&quot;Operating system: &quot;+System.getProperty(&quot;os.name&quot;)+&quot;/&quot;+System.getProperty(&quot;os.arch&quot;));
+		if (System.getProperty(&quot;java.vendor&quot;)!=null)pref.log(&quot;Java: &quot;+System.getProperty(&quot;java.vendor&quot;)+&quot;/&quot;+System.getProperty(&quot;java.version&quot;));
+		CacheHolder ch;
+		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = cacheDB.get(i);
+			if (ch.mainCache==null) ch.initStates(false);
+		}
+		String start = &quot;&quot;;
+		Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
+		Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
+		Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
+		String doc = &quot;&quot;;
+
+		if (!loggedIn || Global.getPref().forceLogin) {
+			if(login() != FormBase.IDOK) return;
+		}
+
+		boolean doNotgetFound = false;
+
+		OCXMLImporterScreen options;
+		if (spiderAllFinds) {
+			options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;), OCXMLImporterScreen.MAXNUMBER|OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC| OCXMLImporterScreen.TRAVELBUGS| OCXMLImporterScreen.MAXLOGS| OCXMLImporterScreen.TYPE);
+			if (options.execute() == FormBase.IDCANCEL) {return; }
+
+			distance = 1;
+		} else {
+			options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;),	OCXMLImporterScreen.MAXNUMBER|OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.DIST| OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC| OCXMLImporterScreen.TRAVELBUGS| OCXMLImporterScreen.MAXLOGS| OCXMLImporterScreen.TYPE);
+			if (options.execute() == FormBase.IDCANCEL) {return; }
+			String dist = options.distanceInput.getText();
+			if (dist.length()== 0) return;
+			distance = Common.parseDouble(dist);
+
+			//save last radius to profile
+			Double distDouble = new Double();
+			distDouble.value = distance;
+			dist = distDouble.toString(0, 1, 0).replace(',', '.');
+			profile.setDistGC(dist);
+
+			doNotgetFound = options.foundCheckBox.getState();
+		}
+
+		int maxNumber = -1;
+		String maxNumberString = options.maxNumberInput.getText();
+		if (maxNumberString.length()!= 0) {
+			maxNumber = Common.parseInt(maxNumberString);
+		}
+		if (maxNumber != pref.maxSpiderNumber) {
+			pref.maxSpiderNumber = maxNumber;
+			pref.savePreferences();
+		}
+		if (maxNumber == 0) return;
+		boolean maxNumberAbort = false;
+
+		boolean getImages = options.imagesCheckBox.getState();
+		boolean getTBs = options.travelbugsCheckBox.getState();
+
+		String cacheTypeRestriction = options.getCacheTypeRestriction(p);
+
+		options.close(0);
+
+		//max distance in miles for URL, so we can get more than 80km
+		double saveDistanceInMiles = distance;
+		if ( Global.getPref().metricSystem != Metrics.IMPERIAL ) {
+			saveDistanceInMiles = Metrics.convertUnit(distance, Metrics.KILOMETER, Metrics.MILES);
+		}
+		// add a mile to be save from different distance calculations in CW and at GC
+		saveDistanceInMiles = java.lang.Math.ceil(saveDistanceInMiles) + 1;
+
+		Hashtable cachesToUpdate = new Hashtable(cacheDB.size());
+		double distanceInKm = distance;
+		if ( Global.getPref().metricSystem == Metrics.IMPERIAL ) {
+			distanceInKm = Metrics.convertUnit(distance, Metrics.MILES, Metrics.KILOMETER);
+		}
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = cacheDB.get(i);
+			if (spiderAllFinds) {
+				if ( (ch.getWayPoint().substring(0,2).equalsIgnoreCase(&quot;GC&quot;)) ) {
+					cachesToUpdate.put(ch.getWayPoint(), ch);
+				}
+			} else {
+				if ( (!ch.is_archived()) &amp;&amp; (ch.kilom &lt;= distanceInKm) &amp;&amp; !(doNotgetFound &amp;&amp; ch.is_found()) &amp;&amp; (ch.getWayPoint().substring(0,2).equalsIgnoreCase(&quot;GC&quot;)) ) {
+					cachesToUpdate.put(ch.getWayPoint(), ch);
+				}
+			}
+		}
+
+		//=======
+		// Prepare list of all caches that are to be spidered
+		//=======
+		Vm.showWait(true);
+		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502,&quot;Fetching first page...&quot;));
+		infB.exec();
+		//Get first page
+		try{
+			if (spiderAllFinds) {
+				ln = p.getProp(&quot;firstPageFinds&quot;) + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias));
+			} else {
+				ln = p.getProp(&quot;firstPage&quot;) + origin.getLatDeg(CWPoint.DD) + p.getProp(&quot;firstPage2&quot;) + origin.getLonDeg(CWPoint.DD)
+			                              + p.getProp(&quot;maxDistance&quot;) + Integer.toString( (int)saveDistanceInMiles );
+				if(doNotgetFound) ln = ln + p.getProp(&quot;showOnlyFound&quot;);
+			}
+			ln = ln + cacheTypeRestriction;
+			pref.log(&quot;Getting first page: &quot;+ln);
+			start = fetch(ln);
+			pref.log(&quot;Got first page&quot;);
+		}catch(Exception ex){
+			pref.log(&quot;Error fetching first list page&quot;,ex,true);
+			Vm.showWait(false);
+			infB.close(0);
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5503,&quot;Error fetching first list page.&quot;), FormBase.OKB)).execute();
+			return;
+		}
+		dummy = &quot;&quot;;
+		//String lineBlck = &quot;&quot;;
+		int page_number = 4;
+		try  {
+			lineRex = new Regex(p.getProp(&quot;lineRex&quot;)); //&quot;&lt;tr bgcolor=((?s).*?)&lt;/tr&gt;&quot;
+		} catch (Exception ex) {
+			infB.close(0);
+			Vm.showWait(false);
+			return;
+		}
+		int page = 0;
+		int found_on_page = 0;
+		try {
+			//Loop till maximum distance has been found or no more caches are in the list
+			while(distance &gt; 0){
+				if (infB.isClosed) break;
+
+				rexViewstate.search(start);
+				if(rexViewstate.didMatch()){
+					viewstate = rexViewstate.stringMatched(1);
+					//Vm.debug(&quot;ViewState: &quot; + viewstate);
+				} else {
+					viewstate = &quot;&quot;;
+					pref.log(&quot;Viewstate not found&quot;);
+				}
+
+				rexViewstate1.search(start);
+				if(rexViewstate1.didMatch()){
+					viewstate1 = rexViewstate1.stringMatched(1);
+					//Vm.debug(&quot;ViewState: &quot; + viewstate);
+				} else {
+					viewstate1 = &quot;&quot;;
+					pref.log(&quot;Viewstate1 not found&quot;);
+				}
+
+				rexEventvalidation.search(start);
+				if(rexEventvalidation.didMatch()){
+					eventvalidation = rexEventvalidation.stringMatched(1);
+					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
+				} else {
+					eventvalidation = &quot;&quot;;
+					pref.log(&quot;Eventvalidation not found&quot;);
+				}
+
+				//Vm.debug(&quot;In loop&quot;);
+				Regex listBlockRex = new Regex(p.getProp(&quot;listBlockRex&quot;)); // &quot;&lt;table id=\&quot;dlResults\&quot;((?s).*?)&lt;/table&gt;&quot;
+				listBlockRex.search(start);
+				dummy = listBlockRex.stringMatched(1);
+				try{
+					lineRex.search(dummy);
+				}catch(NullPointerException nex){
+					Global.getPref().log(&quot;Ignored Exception&quot;, nex, true);
+				}
+				while(lineRex.didMatch()){
+					//Vm.debug(getDist(lineRex.stringMatched(1)) + &quot; / &quot; +getWP(lineRex.stringMatched(1)));
+					found_on_page++;
+					if(getDist(lineRex.stringMatched(1)) &lt;= distance){
+						String waypoint=getWP(lineRex.stringMatched(1));
+						CacheHolder existingCache;
+						if((existingCache=cacheDB.get(waypoint)) == null){
+							if ( (maxNumber &gt; 0) &amp;&amp; (cachesToLoad.size() &gt;= maxNumber) ) {
+								maxNumberAbort = true;
+
+								//add no more caches
+								distance = 0;
+
+								//don't update existing caches, because list is not correct when aborting
+								cachesToUpdate.clear();
+							} else {
+								cachesToLoad.add(waypoint);
+							}
+						} else {
+							pref.log(waypoint+&quot; already in DB&quot;);
+							ch=existingCache;
+							// If the &lt;strike&gt; tag is used, the cache is marked as unavailable or archived
+							boolean is_archived_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&lt;font color=\&quot;red\&quot;&gt;&quot;)!=-1;
+							boolean is_available_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&quot;)==-1;
+							if (ch.is_archived()!=is_archived_GC) { // Update the database with the cache status
+								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_archived_GC?&quot;archived&quot;:&quot;not archived&quot;));
+								if ( ch.is_archived() ) {
+									cachesToUpdate.put(ch.getWayPoint(), ch);
+								}
+								ch.setArchived(is_archived_GC);
+							} else if (ch.is_available()!=is_available_GC) { // Update the database with the cache status
+								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_available_GC?&quot;available&quot;:&quot;not available&quot;));
+								ch.setAvailable(is_available_GC);
+							} else if (spiderAllFinds &amp;&amp; !ch.is_found()) { // Update the database with the cache status
+								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to found&quot;);
+								ch.setFound(true);
+							} else {
+								cachesToUpdate.remove( ch.getWayPoint() );
+							}
+						}
+					} else distance = 0;
+					lineRex.searchFrom(dummy, lineRex.matchedTo());
+				}
+
+				page++;
+				infB.setInfo(MyLocale.getMsg(5521,&quot;Page &quot;) + page + &quot;\n&quot; + MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
+
+				if(found_on_page &lt; 20) distance = 0;
+				if (spiderAllFinds) {
+					postStr = p.getProp(&quot;firstLine&quot;);
+				} else {
+					postStr = p.getProp(&quot;firstLine&quot;) + origin.getLatDeg(CWPoint.DD) + &quot;&amp;&quot; + origin.getLonDeg(CWPoint.DD)
+							                             + p.getProp(&quot;maxDistance&quot;) + Integer.toString( (int)saveDistanceInMiles );
+					if(doNotgetFound) postStr = postStr + p.getProp(&quot;showOnlyFound&quot;);
+				}
+				postStr = postStr + cacheTypeRestriction;
+				if(distance &gt; 0){
+					page_number++;
+					if(page_number &gt;= 15) page_number = 5;
+					String strNextPage;
+					if (page_number &lt; 10) {
+						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl0&quot; + page_number;
+					} else {
+						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl&quot; + page_number;
+					}
+					doc = URL.encodeURL(&quot;__EVENTTARGET&quot;,false) +&quot;=&quot;+ URL.encodeURL(strNextPage,false)
+					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTARGUMENT&quot;,false) +&quot;=&quot;+ URL.encodeURL(&quot;&quot;,false)
+					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATEFIELDCOUNT&quot;,false) +&quot;=2&quot;
+					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate,false)
+					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE1&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate1,false);
+//					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false) +&quot;=&quot;+ URL.encodeURL(eventvalidation,false);
+					try{
+						start = &quot;&quot;;
+						pref.log(&quot;Fetching next list page:&quot; + doc);
+						start = fetch_post(postStr, doc, p.getProp(&quot;nextListPage&quot;));
+					}catch(Exception ex){
+						//Vm.debug(&quot;Couldn't get the next page&quot;);
+						pref.log(&quot;Error getting next page&quot;);
+					}
+				}
+				//Vm.debug(&quot;Distance is now: &quot; + distance);
+				found_on_page = 0;
+			}
+		} catch (Exception ex) { // Some tag missing from spider.def
+			infB.close(0);
+			Vm.showWait(false);
+			return;
+		}
+		pref.log(&quot;Found &quot; + cachesToLoad.size() + &quot; new caches&quot;);
+		pref.log(&quot;Found &quot; + cachesToUpdate.size() + &quot; caches for update&quot;);
+		if (!infB.isClosed) infB.setInfo(MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
+
+		//=======
+		// Now ready to spider each cache in the list
+		//=======
+		boolean loadAllLogs = (MAXLOGS &gt; 5);
+
+		int spiderErrors = 0;
+
+		if ( cachesToUpdate.size() &gt; 0 ) {
+			switch (pref.spiderUpdates) {
+			case Preferences.NO:
+				cachesToUpdate.clear();
+				break;
+			case Preferences.ASK:
+				MessageBox mBox = new MessageBox(MyLocale.getMsg(5517,&quot;Spider Updates?&quot;), cachesToUpdate.size() + MyLocale.getMsg(5518,&quot; caches in database need an update. Update now?&quot;) , FormBase.IDYES |FormBase.IDNO);
+				if (mBox.execute() != FormBase.IDOK){
+					cachesToUpdate.clear();
+				}
+				break;
+			}
+		}
+
+		int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
+
+		for(int i = 0; i&lt;cachesToLoad.size(); i++){
+			if (infB.isClosed) break;
+
+			wpt = (String)cachesToLoad.get(i);
+			// Get only caches not already available in the DB
+			if(cacheDB.getIndex(wpt) == -1){
+				infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + wpt +&quot; (&quot; + (i+1) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
+				holder = new CacheHolder();
+				holder.setWayPoint(wpt);
+				int test = getCacheByWaypointName(holder,false,getImages,getTBs,doNotgetFound,loadAllLogs);
+				if (test == -1) {
+					infB.close(0);
+					break;
+				} else if (test == 0) {
+					spiderErrors++;
+				} else {
+					if (!holder.is_found() || !doNotgetFound ) {
+						cacheDB.add(holder);
+						holder.save();
+					}
+				}
+			}
+		}
+
+		if (!infB.isClosed) {
+			int j = 1;
+			for (Enumeration e = cachesToUpdate.elements() ; e.hasMoreElements() ; j++) {
+				ch = (CacheHolder)e.nextElement();
+				infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + ch.getWayPoint() +&quot; (&quot; + (cachesToLoad.size()+j) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
+				infB.redisplay();
+
+				int test = spiderSingle(cacheDB.getIndex(ch), infB,false);
+				if (test == -1) {
+					break;
+				} else if (test == 0) {
+					spiderErrors++;
+				} else {
+					//profile.hasUnsavedChanges=true;
+				}
+			}
+		}
+
+		infB.close(0);
+		Vm.showWait(false);
+		if ( spiderErrors &gt; 0) {
+			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
+		}
+		if ( maxNumberAbort ) {
+			new MessageBox(MyLocale.getMsg(5519,&quot;Information&quot;),MyLocale.getMsg(5520,&quot;Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated.&quot;),FormBase.DEFOKB).execute();
+		}
+		Global.getProfile().restoreFilter();
+		Global.getProfile().saveIndex(Global.getPref(),true);
+	}
+
+	/**
+	 * Read a complete cachepage from geocaching.com including all logs. This is used both when
+	 * updating already existing caches (via spiderSingle) and when spidering around a centre. It
+	 * is also used when reading a GPX file and fetching the images.
+	 *
+	 * This is the workhorse function of the spider.
+	 *
+	 * @param CacheHolderDetail chD The element wayPoint must be set to the name of a waypoint
+	 * @param boolean isUpdate True if an existing cache is being updated, false if it is a new cache
+	 * @param boolean fetchImages True if the pictures are to be fetched
+	 * @param boolean fetchTBs True if the TBs are to be fetched
+	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
+	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line).
+	 *     This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
+	 */
+	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean fetchTBs, boolean doNotGetFound, boolean fetchAllLogs) {
+		int ret = 1;
+		while (true) {
+			String completeWebPage;
+			int spiderTrys=0;
+			int MAX_SPIDER_TRYS=3;
+			while (spiderTrys++&lt;MAX_SPIDER_TRYS) {
+				ret = 1;
+				try{
+					String doc = p.getProp(&quot;getPageByName&quot;) + ch.getWayPoint() +(fetchAllLogs?p.getProp(&quot;fetchAllLogs&quot;):&quot;&quot;);
+					pref.log(&quot;Fetching: &quot; + ch.getWayPoint());
+					completeWebPage = fetch(doc);
+					if	( completeWebPage.equals(&quot;&quot;)) {
+						pref.log(&quot;Could not fetch &quot; + ch.getWayPoint());
+						if (!infB.isClosed) {
+							continue;
+						} else {
+							ch.setIncomplete(true);
+							return -1;
+						}
+					}
+				}catch(Exception ex){
+					pref.log(&quot;Could not fetch &quot; + ch.getWayPoint(),ex);
+					if (!infB.isClosed) {
+						continue;
+					} else {
+						ch.setIncomplete(true);
+						return -1;
+					}
+				}
+				// Only analyse the cache data and fetch pictures if user has not closed the progress window
+				if (!infB.isClosed) {
+					try{
+						ch.initStates(!isUpdate);
+
+						//first check if coordinates are available to prevent deleting existing coorinates
+						String latLon = getLatLon(completeWebPage);
+						if (latLon.equals(&quot;???&quot;)) {
+							pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot;);
+							ret = 0;
+							continue; // Restart the spider
+						}
+
+						ch.setHTML(true);
+						ch.setAvailable(true);
+						ch.setArchived(false);
+						ch.setIncomplete(true);
+						// Save size of logs to be able to check whether any new logs were added
+						//int logsz = chD.CacheLogs.size();
+						//chD.CacheLogs.clear();
+						ch.addiWpts.clear();
+						ch.getFreshDetails().Images.clear();
+						ch.getFreshDetails().ImagesText.clear();
+						ch.getFreshDetails().ImagesInfo.clear();
+
+						if(completeWebPage.indexOf(p.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0) ch.setAvailable(false);
+						if(completeWebPage.indexOf(p.getProp(&quot;cacheArchived&quot;)) &gt;= 0) ch.setArchived(true);
+						//==========
+						// General Cache Data
+						//==========
+						ch.setLatLon(latLon);
+						pref.log(&quot;LatLon: &quot; + ch.LatLon);
+						if (pref.debug) pref.log(&quot;chD.pos: &quot; + ch.pos.toString());
+
+						pref.log(&quot;Trying description&quot;);
+						ch.getFreshDetails().setLongDescription(getLongDesc(completeWebPage));
+						pref.log(&quot;Got description&quot;);
+
+						pref.log(&quot;Getting cache name&quot;);
+						ch.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
+						if (pref.debug) pref.log(&quot;Name: &quot; + ch.getCacheName()); else pref.log(&quot;Got name&quot;);
+
+						pref.log(&quot;Trying location (country/state)&quot;);
+						String location = getLocation(completeWebPage);
+						if (location.length() != 0) {
+							int countryStart = location.indexOf(&quot;,&quot;);
+							if (countryStart &gt; -1) {
+								ch.getFreshDetails().Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
+								ch.getFreshDetails().State = SafeXML.cleanback(location.substring(0, countryStart).trim());
+							} else {
+								ch.getFreshDetails().Country = location.trim();
+								ch.getFreshDetails().State = &quot;&quot;;
+							}
+							pref.log(&quot;Got location (country/state)&quot;);
+						} else {
+							ch.getFreshDetails().Country = &quot;&quot;;
+							ch.getFreshDetails().State = &quot;&quot;;
+							pref.log(&quot;No location (country/state) found&quot;);
+						}
+
+						pref.log(&quot;Trying owner&quot;);
+						ch.setCacheOwner(SafeXML.cleanback(getOwner(completeWebPage)).trim());
+						if(ch.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; ch.getCacheOwner().equals(pref.myAlias2))) ch.setOwned(true);
+						if (pref.debug) pref.log(&quot;Owner: &quot; + ch.getCacheOwner() +&quot;; is_owned = &quot;+ch.is_owned()+&quot;;  alias1,2 = [&quot;+pref.myAlias+&quot;|&quot;+pref.myAlias2+&quot;]&quot;);
+						else pref.log(&quot;Got owner&quot;);
+
+
+						pref.log(&quot;Trying date hidden&quot;);
+						ch.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
+						if (pref.debug) pref.log(&quot;Hidden: &quot; + ch.getDateHidden());
+						else pref.log(&quot;Got date hidden&quot;);
+
+						pref.log(&quot;Trying hints&quot;);
+						ch.getFreshDetails().setHints(getHints(completeWebPage));
+						if (pref.debug) pref.log(&quot;Hints: &quot; + ch.getFreshDetails().Hints);
+						else pref.log(&quot;Got hints&quot;);
+
+						pref.log(&quot;Trying size&quot;);
+						ch.setCacheSize(CacheSize.gcSpiderString2Cw(getSize(completeWebPage)));
+						if (pref.debug) pref.log(&quot;Size: &quot; + ch.getCacheSize());
+						else pref.log(&quot;Got size&quot;);
+
+						pref.log(&quot;Trying difficulty&quot;);
+						ch.setHard(CacheTerrDiff.v1Converter(getDiff(completeWebPage)));
+						if (pref.debug) pref.log(&quot;Hard: &quot; + ch.getHard());
+						else pref.log(&quot;Got difficulty&quot;);
+
+						pref.log(&quot;Trying terrain&quot;);
+						ch.setTerrain(CacheTerrDiff.v1Converter(getTerr(completeWebPage)));
+						if (pref.debug) pref.log(&quot;Terr: &quot; + ch.getTerrain());
+						else pref.log(&quot;Got terrain&quot;);
+
+						pref.log(&quot;Trying cache type&quot;);
+						ch.setType(getType(completeWebPage));
+						if (pref.debug) pref.log(&quot;Type: &quot; + ch.getType());
+						else pref.log(&quot;Got cache type&quot;);
+
+						//==========
+						// Logs
+						//==========
+						pref.log(&quot;Trying logs&quot;);
+						ch.getFreshDetails().setCacheLogs(getLogs(completeWebPage, ch.getFreshDetails()));
+						pref.log(&quot;Found logs&quot;);
+
+						// If the switch is set to not store found caches and we found the cache =&gt; return
+						if (ch.is_found() &amp;&amp; doNotGetFound) {
+							if (infB.isClosed) {
+								return -1;
+							} else {
+								return 1;
+							}
+						}
+
+						//==========
+						// Bugs
+						//==========
+						// As there may be several bugs, we check whether the user has aborted
+						if (!infB.isClosed &amp;&amp; fetchTBs) getBugs(ch.getFreshDetails(),completeWebPage);
+						ch.setHas_bugs(ch.getFreshDetails().Travelbugs.size()&gt;0);
+
+						//==========
+						// Images
+						//==========
+						if(fetchImages){
+							pref.log(&quot;Trying images&quot;);
+							getImages(completeWebPage, ch.getFreshDetails());
+							pref.log(&quot;Got images&quot;);
+						}
+						//==========
+						// Addi waypoints
+						//==========
+
+						pref.log(&quot;Getting additional waypoints&quot;);
+						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch.is_found());
+						pref.log(&quot;Got additional waypoints&quot;);
+
+						//==========
+						// Attributes
+						//==========
+						pref.log(&quot;Getting attributes&quot;);
+						getAttributes(completeWebPage, ch.getFreshDetails());
+						pref.log(&quot;Got attributes&quot;);
+						//if (ch.is_new()) ch.setUpdated(false);
+						//==========
+						// Last sync date
+						//==========
+						ch.setLastSync((new Time()).format(&quot;yyyyMMddHHmmss&quot;));
+
+						ch.setIncomplete(false);
+						break;
+					}catch(Exception ex){
+						pref.log(&quot;Error reading cache: &quot;+ch.getWayPoint());
+						pref.log(&quot;Exception in getCacheByWaypointName: &quot;,ex);
+					}
+				} else {
+					break;
+				}
+			} // spiderTrys
+			if ( ( spiderTrys &gt;= MAX_SPIDER_TRYS ) &amp;&amp; ( ret == 1 ) ) {
+				pref.log(&quot;&gt;&gt;&gt; Failed to spider cache. Number of retrys exhausted.&quot;);
+				int decision = (new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(5515,&quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;),FormBase.DEFOKB|FormBase.NOB|FormBase.CANCELB)).execute();
+				if ( decision == FormBase.IDOK ) {
+					continue;
+				} else if ( decision == FormBase.IDNO ){
+					ret = 0;
+				} else {
+					ret = -1;
+				}
+			}
+			break;
+		}//while(true)
+		if (infB.isClosed) {// If the infoBox was closed before getting here, we return -1
+			return -1;
+		}
+		return ret;
+	} // getCacheByWaypointName
+
+
+	/**
+	 * Get the Distance to the centre
+	 * @param doc A previously fetched cachepage
+	 * @return Distance
+	 */
+	private double getDist(String doc) throws Exception {
+		inRex = new Regex(p.getProp(&quot;distRex&quot;));
+		inRex.search(doc);
+		if(doc.indexOf(&quot;Here&quot;) &gt;= 0) return(0);
+		if (!inRex.didMatch()) return 0;
+		if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) return Convert.toDouble(inRex.stringMatched(1).replace('.',','));
+		return Convert.toDouble(inRex.stringMatched(1));
+	}
+
+	/**
+	 * Get the waypoint name
+	 * @param doc A previously fetched cachepage
+	 * @return Name of waypoint to add to list
+	 */
+	private String getWP(String doc) throws Exception {
+		inRex = new Regex(p.getProp(&quot;waypointRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return &quot;GC&quot;+inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the coordinates of the cache
+	 * @param doc A previously fetched cachepage
+	 * @return Cache coordinates
+	 */
+	private String getLatLon(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the long description
+	 * @param doc A previously fetched cachepage
+	 * @return the long description
+	 */
+	private String getLongDesc(String doc) throws Exception{
+		String res = &quot;&quot;;
+		inRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
+		Regex rex2 = new Regex(p.getProp(&quot;longDescRex&quot;));
+		inRex.search(doc);
+		rex2.search(doc);
+		res = ((inRex.stringMatched(1)==null)?&quot;&quot;:inRex.stringMatched(1)) + &quot;&lt;br&gt;&quot;;
+		res += rex2.stringMatched(1);
+		return res; // SafeXML.cleanback(res);
+	}
+
+	/**
+	 * Get the cache location (country and state)
+	 * @param doc A previously fetched cachepage
+	 * @return the location (country and state) of the cache
+	 */
+	private String getLocation(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;cacheLocationRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;&quot;;
+
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the cache name
+	 * @param doc A previously fetched cachepage
+	 * @return the name of the cache
+	 */
+	private String getName(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the cache owner
+	 * @param doc A previously fetched cachepage
+	 * @return the cache owner
+	 */
+	private String getOwner(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the date when the cache was hidden
+	 * @param doc A previously fetched cachepage
+	 * @return Hidden date
+	 */
+	private String getDateHidden(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the hints
+	 * @param doc A previously fetched cachepage
+	 * @return Cachehints
+	 */
+	private String getHints(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the cache size
+	 * @param doc A previously fetched cachepage
+	 * @return Cache size
+	 */
+	private String getSize(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch()) return inRex.stringMatched(1);
+		else return &quot;None&quot;;
+	}
+
+	/**
+	 * Get the Difficulty
+	 * @param doc A previously fetched cachepage
+	 * @return The cache difficulty
+	 */
+	private String getDiff(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch()) return inRex.stringMatched(1);
+		else return &quot;&quot;;
+	}
+
+	/**
+	 * Get the terrain rating
+	 * @param doc A previously fetched cachepage
+	 * @return Terrain rating
+	 */
+	private String getTerr(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch()) return inRex.stringMatched(1);
+		else return &quot;&quot;;
+	}
+
+	/**
+	 * Get the waypoint type
+	 * @param doc A previously fetched cachepage
+	 * @return the waypoint type (Tradi, Multi, etc.)
+	 */
+	private byte getType(String doc) throws Exception {
+		inRex = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch()) return CacheType.gcSpider2CwType(inRex.stringMatched(1));
+		else return 0;
+	}
+
+	/**
+	 * Get the logs
+	 * @param doc A previously fetched cachepage
+	 * @param chD Cache Details
+	 * @return A HTML string containing the logs
+	 */
+	private LogList getLogs(String doc, CacheHolderDetail chD) throws Exception {
+		String icon = &quot;&quot;;
+		String name = &quot;&quot;;
+		String logText = &quot;&quot;;
+		String logId = &quot;&quot;;
+		LogList reslts = new LogList();
+		Regex blockRex = new Regex(p.getProp(&quot;blockRex&quot;));
+		blockRex.search(doc);
+		doc = blockRex.stringMatched(1);
+		String singleLog = &quot;&quot;;
+		Extractor exSingleLog = new Extractor(doc,p.getProp(&quot;singleLogExStart&quot;), p.getProp(&quot;singleLogExEnd&quot;), 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back???
+		singleLog = exSingleLog.findNext();
+		Extractor exIcon = new Extractor(singleLog,p.getProp(&quot;iconExStart&quot;), p.getProp(&quot;iconExEnd&quot;), 0, true);
+		Extractor exNameTemp = new Extractor(singleLog,p.getProp(&quot;nameTempExStart&quot;), p.getProp(&quot;nameTempExEnd&quot;), 0 , true);
+		String nameTemp = &quot;&quot;;
+		nameTemp = exNameTemp.findNext();
+		Extractor exName = new Extractor(nameTemp, p.getProp(&quot;nameExStart&quot;), p.getProp(&quot;nameExEnd&quot;), 0 , true);
+		Extractor exDate = new Extractor(singleLog,p.getProp(&quot;dateExStart&quot;), p.getProp(&quot;dateExEnd&quot;), 0 , true);
+		Extractor exLog = new Extractor(singleLog, p.getProp(&quot;logExStart&quot;), p.getProp(&quot;logExEnd&quot;), 0, true);
+		Extractor exLogId = new Extractor(singleLog, p.getProp(&quot;logIdExStart&quot;), p.getProp(&quot;logIdExEnd&quot;), 0, true);
+		//Vm.debug(&quot;Log Block: &quot; + singleLog);
+		int nLogs=0;
+		while(exSingleLog.endOfSearch() == false){
+			nLogs++;
+			//Vm.debug(&quot;--------------------------------------------&quot;);
+			//Vm.debug(&quot;Log Block: &quot; + singleLog);
+			//Vm.debug(&quot;Icon: &quot;+exIcon.findNext());
+			//Vm.debug(exName.findNext());
+			//Vm.debug(exDate.findNext());
+			//Vm.debug(exLog.findNext());
+			//Vm.debug(&quot;--------------------------------------------&quot;);
+			icon = exIcon.findNext();
+			name = exName.findNext();
+			logText = exLog.findNext();
+			logId = exLogId.findNext();
+			String d=DateFormat.logdate2YMD(exDate.findNext());
+			if((icon.equals(p.getProp(&quot;icon_smile&quot;)) || icon.equals(p.getProp(&quot;icon_camera&quot;)) || icon.equals(p.getProp(&quot;icon_attended&quot;))) &amp;&amp;
+				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; name.equalsIgnoreCase(pref.myAlias2))) )  {
+				chD.getParent().setFound(true);
+				chD.getParent().setCacheStatus(d);
+				chD.OwnLogId = logId;
+				chD.OwnLog = new Log(icon,d,name,logText);
+			}
+			if (nLogs&lt;=MAXLOGS) reslts.add(new Log(icon,d,name,logText));
+
+			singleLog = exSingleLog.findNext();
+			exIcon.setSource(singleLog);
+			exNameTemp.setSource(singleLog);
+			nameTemp = exNameTemp.findNext();
+			exName.setSource(nameTemp);
+			exDate.setSource(singleLog);
+			exLog.setSource(singleLog);
+			exLogId.setSource(singleLog);
+			// We cannot simply stop if we have reached MAXLOGS just in case we are waiting for
+			// a log by our alias that happened earlier.
+			if (nLogs&gt;=MAXLOGS &amp;&amp; chD.getParent().is_found() &amp;&amp; (chD.OwnLogId.length() != 0) &amp;&amp; (chD.OwnLog != null) &amp;&amp; !(chD.OwnLog.getDate().equals(&quot;1900-01-01&quot;))) break;
+		}
+		if (nLogs&gt;MAXLOGS) {
+			reslts.add(Log.maxLog());
+			pref.log(&quot;Too many logs. MAXLOGS reached (&quot;+MAXLOGS+&quot;)&quot;);
+		} else
+			pref.log(nLogs+&quot; logs found&quot;);
+		return reslts;
+	}
+
+	/**
+	 * Read the travelbug names from a previously fetched Cache page and then
+	 * read the travelbug purpose for each travelbug
+	 * @param doc The previously fetched cachepage
+	 * @return A HTML formatted string with bug names and there purpose
+	 */
+	public void getBugs(CacheHolderDetail chD, String doc) throws Exception{
+		Extractor exBlock = new Extractor(doc,p.getProp(&quot;blockExStart&quot;),p.getProp(&quot;blockExEnd&quot;) ,0,Extractor.EXCLUDESTARTEND);
+		String bugBlock = exBlock.findNext();
+		//Vm.debug(&quot;Bugblock: &quot;+bugBlock);
+		Extractor exBug = new Extractor(bugBlock,p.getProp(&quot;bugExStart&quot;),p.getProp(&quot;bugExEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+		String link,bug,linkPlusBug,bugDetails;
+		String oldInfoBox=infB.getInfo();
+		chD.Travelbugs.clear();
+		while(exBug.endOfSearch() == false){
+			if (infB.isClosed) break; // Allow user to cancel by closing progress form
+			linkPlusBug= exBug.findNext();
+			int idx=linkPlusBug.indexOf(&quot;'&gt;&quot;);
+			if (idx&lt;0) break; // No link/bug pair found
+			link=linkPlusBug.substring(0,idx);
+			bug=linkPlusBug.substring(idx+2);
+			if(bug.length()&gt;0) { // Found a bug, get its details
+				Travelbug tb=new Travelbug(bug);
+				try{
+					infB.setInfo(oldInfoBox+MyLocale.getMsg(5514,&quot;\nGetting bug: &quot;)+SafeXML.cleanback(bug));
+					pref.log(&quot;Fetching bug details: &quot;+bug);
+					bugDetails = fetch(link);
+					Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+					tb.setMission(exDetails.findNext());
+					Extractor exGuid = new Extractor(bugDetails,&quot;details.aspx?guid=&quot;,&quot;\&quot; id=\&quot;aspnetForm&quot;,0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def see also further down
+					tb.setGuid(exGuid.findNext());
+					chD.Travelbugs.add(tb);
+				}catch(Exception ex){
+					pref.log(&quot;Could not fetch bug details&quot;);
+				}
+			}
+			//Vm.debug(&quot;B: &quot; + bug);
+			//Vm.debug(&quot;End? &quot; + exBug.endOfSearch());
+		}
+		infB.setInfo(oldInfoBox);
+	}
+
+	/**
+	 * Get the images for a previously fetched cache page. Images are extracted
+	 * from two areas: The long description and the pictures section (including
+	 * the spoiler)
+	 * @param doc The previously fetched cachepage
+	 * @param chD The Cachedetails
+	 */
+	public void getImages(String doc, CacheHolderDetail chD){
+		int imgCounter = 0;
+		String imgName, oldImgName, imgType, imgUrl, imgComment;
+		Vector spideredUrls=new Vector(15);
+		Extractor exImgBlock,exImgComment;
+		int idxUrl; // Index of already spidered Url in list of spideredUrls
+		//========
+		//In the long description
+		//========
+		String longDesc = &quot;&quot;;
+		try {
+			if (chD.getParent().getWayPoint().startsWith(&quot;TC&quot;)) longDesc = doc;
+			else
+				longDesc = getLongDesc(doc);
+			longDesc = STRreplace.replace(longDesc, &quot;&lt;img&quot;, &quot;&lt;IMG&quot;);
+			longDesc = STRreplace.replace(longDesc, &quot;src=&quot;, &quot;SRC=&quot;);
+			longDesc = STRreplace.replace(longDesc, &quot;'&quot;, &quot;\&quot;&quot;);
+			exImgBlock = new Extractor(longDesc,p.getProp(&quot;imgBlockExStart&quot;),p.getProp(&quot;imgBlockExEnd&quot;), 0, false);
+		} catch (Exception ex) {//Missing property in spider.def
+			return;
+		}
+		//Vm.debug(&quot;In getImages: Have longDesc&quot; + longDesc);
+		String tst;
+		tst = exImgBlock.findNext();
+		//Vm.debug(&quot;Test: \n&quot; + tst);
+		Extractor exImgSrc = new Extractor(tst, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while(exImgBlock.endOfSearch() == false){
+			imgUrl = exImgSrc.findNext();
+			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
+			if(imgUrl.length()&gt;0){
+				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+				try{
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+					// imgType is now max 4 chars, starting with .
+					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+						// Check whether image was already spidered for this cache
+						idxUrl=spideredUrls.find(imgUrl);
+						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+						if (idxUrl&lt;0) { // New image
+							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
+							spiderImage(imgUrl, imgName+imgType);
+							chD.Images.add(imgName+imgType);
+							spideredUrls.add(imgUrl);
+						} else { // Image already spidered as wayPoint_'idxUrl'
+							pref.log(&quot;Already loaded image: &quot; + imgUrl);
+							oldImgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(idxUrl);
+							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
+						}
+						chD.ImagesText.add(imgName); // Keep the image name
+						chD.ImagesInfo.add(null); // Need to stay in synch with ImagesText
+						imgCounter++;
+					}
+				} catch (IndexOutOfBoundsException e) {
+					//Vm.debug(&quot;IndexOutOfBoundsException not in image span&quot;+e.toString()+&quot;imgURL:&quot;+imgUrl);
+					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
+				}
+				}
+			exImgSrc.setSource(exImgBlock.findNext());
+		}
+		//========
+		//In the image span
+		//========
+		Extractor spanBlock,exImgName;
+		try {
+			spanBlock = new Extractor(doc,p.getProp(&quot;imgSpanExStart&quot;),p.getProp(&quot;imgSpanExEnd&quot;), 0 , true);
+			tst = spanBlock.findNext();
+			exImgName = new Extractor(tst,p.getProp(&quot;imgNameExStart&quot;),p.getProp(&quot;imgNameExEnd&quot;), 0 , true);
+			exImgSrc = new Extractor(tst,p.getProp(&quot;imgSrcExStart&quot;),p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
+			exImgComment = new Extractor(tst,p.getProp(&quot;imgCommentExStart&quot;),p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
+		} catch (Exception ex) { // Missing property in spider .def
+			return;
+		}
+		while(exImgSrc.endOfSearch() == false){
+			imgUrl = exImgSrc.findNext();
+			imgComment = exImgComment.findNext();
+			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
+			if(imgUrl.length()&gt;0){
+				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+				try{
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+					// imgType is now max 4 chars, starting with .
+					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+						// Check whether image was already spidered for this cache
+						idxUrl=spideredUrls.find(imgUrl);
+						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+						if (idxUrl&lt;0) { // New image
+							pref.log(&quot;Loading image: &quot; + imgUrl);
+							spiderImage(imgUrl, imgName+imgType);
+							chD.Images.add(imgName+imgType);
+						} else { // Image already spidered as wayPoint_ 'idxUrl'
+							pref.log(&quot;Already loaded image: &quot; + imgUrl);
+							oldImgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(idxUrl);
+							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
+						}
+						chD.ImagesText.add(exImgName.findNext()); // Keep the image description
+						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(6);
+						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(0,imgComment.length()-6);
+						if (imgComment.length()==0)
+							chD.ImagesInfo.add(null);
+						else
+							chD.ImagesInfo.add(imgComment);
+						imgCounter++;
+					}
+				} catch (IndexOutOfBoundsException e) {
+					pref.log(&quot;IndexOutOfBoundsException in image span. imgURL:&quot;+imgUrl,e);
+				}
+			}
+		}
+		//========
+		//Final sweep to check for images in hrefs
+		//========
+		Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while(exFinal.endOfSearch() == false){
+			imgUrl = exFinal.findNext();
+			if(imgUrl.length()&gt;0){
+				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+				try{
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+					// imgType is now max 4 chars, starting with . Delete characters in URL after the image extension
+					imgUrl=imgUrl.substring(0,imgUrl.lastIndexOf(&quot;.&quot;)+imgType.length());
+					if( imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+						// Check whether image was already spidered for this cache
+						idxUrl=spideredUrls.find(imgUrl);
+						if (idxUrl&lt;0) { // New image
+							imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
+							spiderImage(imgUrl, imgName+imgType);
+							chD.Images.add(imgName+imgType);
+							spideredUrls.add(imgUrl);
+							chD.ImagesText.add(imgName); // Keep the image name
+							chD.ImagesInfo.add(null);
+							imgCounter++;
+						}
+					}
+				} catch (IndexOutOfBoundsException e) {
+					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
+				}
+			}
+		}
+	}
+
+
+	/**
+	 * Read an image from the server
+	 * @param imgUrl The Url of the image
+	 * @param target The bytes of the image
+	 */
+	private void spiderImage(String imgUrl, String target){ // TODO implement a fetch(URL, filename) in HttpConnection and use that one
+		HttpConnection connImg;
+		Socket sockImg;
+		//InputStream is;
+		FileOutputStream fos;
+		//int bytes_read;
+		//byte[] buffer = new byte[9000];
+		ByteArray daten;
+		String datei = &quot;&quot;;
+		datei = profile.dataDir + target;
+		connImg = new HttpConnection(imgUrl);
+		if (imgUrl.indexOf('%')&gt;=0) connImg.documentIsEncoded=true;
+		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+		//connImg.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12&quot;);
+		//connImg.setRequestorProperty(&quot;Accept&quot;,&quot;text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5&quot;);
+		try{
+			pref.log(&quot;Trying to fetch image from: &quot; + imgUrl);
+			String redirect=null;
+			do {
+				sockImg = connImg.connect();
+				redirect=connImg.getRedirectTo();
+				if (redirect!=null) {
+					connImg=connImg.getRedirectedConnection(redirect);
+					pref.log(&quot;Redirect to &quot;+redirect);
+				}
+			} while(redirect!=null); // TODO this can end up in an endless loop if trying to load from a malicous site
+			daten = connImg.readData(sockImg);
+			fos = new FileOutputStream(new File(datei));
+			fos.write(daten.toBytes());
+			fos.close();
+			sockImg.close();
+		} catch (UnknownHostException e) {
+			pref.log(&quot;Host not there...&quot;);
+		}catch(IOException ioex){
+			pref.log(&quot;File not found!&quot;);
+		} catch (Exception ex){
+			pref.log(&quot;Some other problem while fetching image&quot;,ex);
+		} finally {
+			//Continue with the spider
+		}
+	}
+
+	/**
+	 * Read all additional waypoints from a previously fetched cachepage.
+	 * @param doc The previously fetched cachepage
+	 * @param wayPoint The name of the cache
+	 * @param is_found Found status of the cached (is inherited by the additional waypoints)
+	 */
+	public void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception{
+		Extractor exWayBlock = new Extractor(doc,p.getProp(&quot;wayBlockExStart&quot;),p.getProp(&quot;wayBlockExEnd&quot;), 0, false);
+		String wayBlock = &quot;&quot;;
+		String rowBlock = &quot;&quot;;
+		wayBlock = exWayBlock.findNext();
+		Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
+		Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
+		Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
+		Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
+		int counter = 0;
+		if(exWayBlock.endOfSearch() == false &amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;)&lt;0){
+			Extractor exRowBlock = new Extractor(wayBlock,p.getProp(&quot;rowBlockExStart&quot;),p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
+			rowBlock = exRowBlock.findNext();
+			rowBlock = exRowBlock.findNext();
+			while(exRowBlock.endOfSearch()==false){
+				CacheHolder hd = null;
+				Extractor exPrefix=new Extractor(rowBlock,p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
+				String prefix=exPrefix.findNext();
+				String adWayPoint;
+				if (prefix.length()==2)
+					adWayPoint=prefix+wayPoint.substring(2);
+				else
+				    adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
+				counter++;
+				int idx=profile.getCacheIndex(adWayPoint);
+				if (idx&gt;=0) {
+					// Creating new CacheHolder, but accessing old cache.xml file
+					hd=new CacheHolder();
+					hd.setWayPoint(adWayPoint);
+					hd.getExistingDetails(); // Accessing Details reads file if not yet done
+				} else {
+					hd=new CacheHolder();
+					hd.setWayPoint(adWayPoint);
+				}
+				hd.initStates(idx&lt;0);
+				nameRex.search(rowBlock);
+				koordRex.search(rowBlock);
+				typeRex.search(rowBlock);
+				hd.setCacheName(nameRex.stringMatched(1));
+				if(koordRex.didMatch()) hd.setLatLon(koordRex.stringMatched(1));
+				if(typeRex.didMatch()) hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot;+typeRex.stringMatched(1)));
+				rowBlock = exRowBlock.findNext();
+				descRex.search(rowBlock);
+				hd.getFreshDetails().setLongDescription(descRex.stringMatched(1));
+				hd.setFound(is_found);
+				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				hd.setHard(CacheTerrDiff.CW_DT_UNSET);
+				hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				if (idx&lt;0){
+					cacheDB.add(hd);
+					hd.save();
+				}else {
+					CacheHolder cx=cacheDB.get(idx);
+					if (cx.is_Checked &amp;&amp; // Only re-spider existing addi waypoints that are ticked
+				 	   cx.isVisible()) { // and are visible (i.e.  not filtered)
+					   cx.initStates(false);
+					   cx.update(hd);
+					   cx.is_Checked=true;
+					   cx.save();
+					}
+				}
+				rowBlock = exRowBlock.findNext();
+
+			}
+		}
+	}
+
+	public void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
+		Extractor attBlock = new Extractor(doc,p.getProp(&quot;attBlockExStart&quot;),p.getProp(&quot;attBlockExEnd&quot;), 0 , true);
+		String atts = attBlock.findNext();
+		Extractor attEx = new Extractor(atts,p.getProp(&quot;attExStart&quot;),p.getProp(&quot;attExEnd&quot;), 0 , true);
+		String attribute=attEx.findNext();
+		chD.attributes.clear();
+		while (attEx.endOfSearch()==false) {
+			chD.attributes.add(attribute);
+			attribute=attEx.findNext();
+		}
+		chD.getParent().setAttributesYes(chD.attributes.attributesYes);
+		chD.getParent().setAttributesNo(chD.attributes.attributesNo);
+	}
+
+
+	/**
+	*	Performs an initial fetch to a given address. In this case
+	*	it will be a gc.com address. This method is used to obtain
+	*	the result of a search for caches screen.
+	*/
+	public static String fetch(String address) {
+		CharArray c_data;
+		try{
+			HttpConnection conn;
+			if(pref.myproxy.length() &gt; 0 &amp;&amp; pref.proxyActive){
+				pref.log(&quot;[fetch]:Using proxy: &quot; + pref.myproxy + &quot; / &quot; +pref.myproxyport);
+			}
+			conn = new HttpConnection(address);
+			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+			if(cookieSession.length()&gt;0){
+				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
+				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
+			} else
+				pref.log(&quot;[fetch]:No Cookie found&quot;);
+			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+			conn.documentIsEncoded = true;
+			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
+			Socket sock = conn.connect();
+			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
+			ByteArray daten = conn.readData(sock);
+			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
+			JavaUtf8Codec codec = new JavaUtf8Codec();
+			c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
+			sock.close();
+			return getResponseHeaders(conn)+ c_data.toString();
+		}catch(IOException ioex){
+			pref.log(&quot;IOException in fetch&quot;, ioex);
+		}finally{
+			//continue
+		}
+		return &quot;&quot;;
+	}
+
+	/**
+	*	After a fetch to gc.com the next fetches have to use the post method.
+	*	This method does exactly that. Actually this method is generic in the sense
+	*	that it can be used to post to a URL using http post.
+	*/
+	private static String fetch_post(String address, String document, String path) {
+		HttpConnection conn;
+		try {
+			conn = new HttpConnection(address);
+			JavaUtf8Codec codec = new JavaUtf8Codec();
+			conn.documentIsEncoded = true;
+			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+			conn.setPostData(codec.encodeText(document.toCharArray(),0,document.length(),true,null));
+			conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
+			if(cookieSession.length()&gt;0){
+				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession+&quot;; userid=&quot;+cookieID);
+				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
+			} else {
+				pref.log(&quot;[fetch]:No Cookie found&quot;);
+			}
+			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
+			Socket sock = conn.connect();
+			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
+			ByteArray daten = conn.readData(sock);
+			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
+			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
+			sock.close();
+			return getResponseHeaders(conn)+c_data.toString();
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+		}
+		return &quot;&quot;;
+	}
+
+	private static String getResponseHeaders(HttpConnection conn) {
+		PropertyList pl = conn.documentProperties;
+		if (pl != null) {
+			StringBuffer sb = new StringBuffer(1000);
+			boolean gotany = false;
+
+			for (int i = 0; i &lt; pl.size(); i++) {
+				Property currProp = (Property)pl.get(i);
+				if (currProp.value != null) {
+					sb.append(currProp.name).append(&quot;: &quot;).append(currProp.value).append(&quot;\r\n&quot;);
+					gotany = true;
+				}
+			}
+			if (gotany)
+				return sb.toString() + &quot;\r\n&quot;;
+		}
+		return &quot;&quot;;
+	}
+
+
+	final static String hex = ewe.util.TextEncoder.hex;
+
+	public String encodeUTF8URL(byte[] what) {
+		int max = what.length;
+		char [] dest = new char[6*max]; // Assume each char is a UTF char and encoded into 6 chars
+		char d = 0;
+		for (int i = 0; i&lt;max; i++){
+			char c = (char) what[i];
+			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '=' ||
+				   c == '|' || c == '{' || c == '}' || c&gt;0x7f ){
+					dest[d++] = '%';
+					dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
+					dest[d++] = hex.charAt(c &amp; 0xf);
+			} else dest[d++] = c;
+		}
+		return new String(dest,0,d);
+	}
+
+	/**
+	 * Load the bug id for a given name. This method is not ideal, as there are
+	 * sometimes several bugs with identical names but different IDs. Normally
+	 * the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
+	 * Note that each bug has both an ID and a GUID.
+	 * @param name The name (or partial name) of a travelbug
+	 * @return the id of the bug
+	 */
+	public String getBugId (String name) {
+		String bugList;
+		try{
+			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
+			pref.log(&quot;Fetching bugId: &quot;+name);
+			bugList = fetch(p.getProp(&quot;getBugByName&quot;)+STRreplace.replace(SafeXML.clean(name),&quot; &quot;,&quot;+&quot;));
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug list&quot;);
+			bugList=&quot;&quot;;
+		}
+		try {
+			if (bugList.equals(&quot;&quot;) || bugList.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
+				return &quot;&quot;;
+			}
+			if (bugList.indexOf(p.getProp(&quot;bugTotalRecords&quot;))&lt;0) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6021,&quot;More than one travelbug found. Specify name more precisely.&quot;), FormBase.OKB)).execute();
+				return &quot;&quot;;
+			}
+			Extractor exGuid = new Extractor(bugList,p.getProp(&quot;bugGuidExStart&quot;),p.getProp(&quot;bugGuidExEnd&quot;),0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def
+			return exGuid.findNext();
+		} catch (Exception ex) {
+			return &quot;&quot;;
+		}
+	}
+
+	/**
+	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer
+	 * than 10 characters it is assumed to be a GUID, otherwise it is an ID.
+	 * @param guid the guid or id of the travelbug
+	 * @return The mission
+	 */
+	public String getBugMissionByGuid(String guid) {
+		String bugDetails;
+		try{
+			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
+			pref.log(&quot;Fetching bug detailsById: &quot;+guid);
+			if (guid.length()&gt;10)
+				bugDetails = fetch(p.getProp(&quot;getBugByGuid&quot;)+guid);
+			else
+				bugDetails = fetch(p.getProp(&quot;getBugById&quot;)+guid);
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug details&quot;);
+			bugDetails=&quot;&quot;;
+		}
+		try {
+			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
+				return &quot;&quot;;
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			return exDetails.findNext();
+		} catch (Exception ex) {
+			return &quot;&quot;;
+		}
+	}
+
+	/**
+	 * Fetch a bug's mission for a given tracking number
+	 * @param trackNr the tracking number of the travelbug
+	 * @return The mission
+	 */
+	public String getBugMissionByTrackNr(String trackNr) {
+		String bugDetails;
+		try{
+			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
+			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug details&quot;);
+			bugDetails=&quot;&quot;;
+		}
+		try {
+			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
+				return &quot;&quot;;
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			return exDetails.findNext();
+		} catch (Exception ex) {
+			return &quot;&quot;;
+		}
+	}
+
+	/**
+	 * Fetch a bug's mission and namefor a given tracking number
+	 * @param TB the travelbug
+	 * @return true if suceeded
+	 */
+	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
+		String bugDetails;
+		String trackNr = TB.getTrackingNo();
+		try{
+			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
+			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug details&quot;);
+			bugDetails=&quot;&quot;;
+		}
+		try {
+			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
+				return false;
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			TB.setMission( exDetails.findNext() );
+			Extractor exName = new Extractor(bugDetails,p.getProp(&quot;bugNameStart&quot;),p.getProp(&quot;bugNameEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			TB.setName( exName.findNext() );
+			return true;
+		} catch (Exception ex) {
+			return false;
+		}
+	}
+
+	public class SpiderProperties extends Properties {
+		SpiderProperties() {
+			super();
+			try {
+				load(new FileInputStream(FileBase.getProgramDirectory()+&quot;/spider.def&quot;));
+			} catch (Exception ex) {
+				pref.log(&quot;Failed to load spider.def&quot;,ex);
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5504,&quot;Could not load 'spider.def'&quot;), FormBase.OKB)).execute();
+			}
+		}
+		public String getProp(String key) throws Exception {
+			String s=super.getProperty(key);
+			if (s==null) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5497,&quot;Error missing tag in spider.def&quot;) + &quot;: &quot;+key, FormBase.OKB)).execute();
+				throw new Exception(&quot;Missing tag in spider.def: &quot;+key);
+			}
+			return s;
+		}
+
+	}
+}


Property changes on: trunk/src/CacheWolf/imp/SpiderGC.java
___________________________________________________________________
Name: svn:mergeinfo
   + 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001868.html">[Cachewolf-svn] r1949 - trunk/src/exp
</A></li>
	<LI>Next message: <A HREF="001870.html">[Cachewolf-svn] r1951 - trunk/src/exp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1869">[ date ]</a>
              <a href="thread.html#1869">[ thread ]</a>
              <a href="subject.html#1869">[ subject ]</a>
              <a href="author.html#1869">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
