<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r2979 - in trunk: res_noewe/symbols resources	src/CacheWolf src/CacheWolf/navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-April/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2979%20-%20in%20trunk%3A%20res_noewe/symbols%20resources%0A%09src/CacheWolf%20src/CacheWolf/navi&In-Reply-To=%3C20110416145328.1D6A3481455%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002969.html">
   <LINK REL="Next"  HREF="002971.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r2979 - in trunk: res_noewe/symbols resources	src/CacheWolf src/CacheWolf/navi</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2979%20-%20in%20trunk%3A%20res_noewe/symbols%20resources%0A%09src/CacheWolf%20src/CacheWolf/navi&In-Reply-To=%3C20110416145328.1D6A3481455%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r2979 - in trunk: res_noewe/symbols resources	src/CacheWolf src/CacheWolf/navi">araber95 at mail.berlios.de
       </A><BR>
    <I>Sat Apr 16 04:53:27 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002969.html">[Cachewolf-svn] r2978 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="002971.html">[Cachewolf-svn] r2980 - trunk/res_noewe/webmapservices
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2970">[ date ]</a>
              <a href="thread.html#2970">[ thread ]</a>
              <a href="subject.html#2970">[ subject ]</a>
              <a href="author.html#2970">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-04-16 16:53:27 +0200 (Sat, 16 Apr 2011)
New Revision: 2979

Added:
   trunk/res_noewe/symbols/2foundsize.png
   trunk/resources/found.png
Modified:
   trunk/res_noewe/symbols/readme.htm
   trunk/src/CacheWolf/CacheType.java
   trunk/src/CacheWolf/GuiImageBroker.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
symbol for finds on map

Added: trunk/res_noewe/symbols/2foundsize.png
===================================================================
(Binary files differ)


Property changes on: trunk/res_noewe/symbols/2foundsize.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/res_noewe/symbols/readme.htm
===================================================================
--- trunk/res_noewe/symbols/readme.htm	2011-04-16 12:35:45 UTC (rev 2978)
+++ trunk/res_noewe/symbols/readme.htm	2011-04-16 14:53:27 UTC (rev 2979)
@@ -13,18 +13,18 @@
 &lt;!--[if gte mso 9]&gt;&lt;xml&gt;
  &lt;o:DocumentProperties&gt;
   &lt;o:Author&gt;.&lt;/o:Author&gt;
-  &lt;o:LastAuthor&gt;.&lt;/o:LastAuthor&gt;
-  &lt;o:Revision&gt;5&lt;/o:Revision&gt;
+  &lt;o:LastAuthor&gt;Franz&lt;/o:LastAuthor&gt;
+  &lt;o:Revision&gt;7&lt;/o:Revision&gt;
   &lt;o:Created&gt;2009-10-23T21:05:00Z&lt;/o:Created&gt;
-  &lt;o:LastSaved&gt;2010-06-08T16:27:00Z&lt;/o:LastSaved&gt;
+  &lt;o:LastSaved&gt;2011-04-16T14:48:00Z&lt;/o:LastSaved&gt;
   &lt;o:Pages&gt;1&lt;/o:Pages&gt;
-  &lt;o:Words&gt;238&lt;/o:Words&gt;
-  &lt;o:Characters&gt;1506&lt;/o:Characters&gt;
+  &lt;o:Words&gt;256&lt;/o:Words&gt;
+  &lt;o:Characters&gt;1615&lt;/o:Characters&gt;
   &lt;o:Company&gt;CF Computer&lt;/o:Company&gt;
-  &lt;o:Lines&gt;12&lt;/o:Lines&gt;
+  &lt;o:Lines&gt;13&lt;/o:Lines&gt;
   &lt;o:Paragraphs&gt;3&lt;/o:Paragraphs&gt;
-  &lt;o:CharactersWithSpaces&gt;1741&lt;/o:CharactersWithSpaces&gt;
-  &lt;o:Version&gt;10.6858&lt;/o:Version&gt;
+  &lt;o:CharactersWithSpaces&gt;1868&lt;/o:CharactersWithSpaces&gt;
+  &lt;o:Version&gt;10.6870&lt;/o:Version&gt;
  &lt;/o:DocumentProperties&gt;
 &lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
  &lt;w:WordDocument&gt;
@@ -84,7 +84,7 @@
 	font-family:&quot;Times New Roman&quot;;}
 &lt;/style&gt;
 &lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
- &lt;o:shapedefaults v:ext=&quot;edit&quot; spidmax=&quot;5122&quot;/&gt;
+ &lt;o:shapedefaults v:ext=&quot;edit&quot; spidmax=&quot;6146&quot;/&gt;
 &lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
  &lt;o:shapelayout v:ext=&quot;edit&quot;&gt;
   &lt;o:idmap v:ext=&quot;edit&quot; data=&quot;1&quot;/&gt;
@@ -106,6 +106,10 @@
 Symbole angezeigt, falls sie existieren und der Dateiname auf &lt;span
 class=SpellE&gt;size&lt;/span&gt; endet.&lt;/p&gt;
 
+&lt;p class=MsoNormal&gt;F&#252;r &lt;span class=GramE&gt;gefundene&lt;/span&gt; Cache k&#246;nnen auf der
+Karte entsprechende Symbole angezeigt werden. Der Dateiname muss daf&#252;r auf &lt;span
+class=SpellE&gt;foundsize&lt;/span&gt; enden.&lt;/p&gt;
+
 &lt;p class=MsoNormal&gt;Es m&#252;ssen nur die Dateien erstellt werden, die ersetzt
 werden sollen.&lt;/p&gt;
 
@@ -125,8 +129,8 @@
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;They're
 supposed to be 16x16 &lt;span class=SpellE&gt;PNGs&lt;/span&gt; or less.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;On the map larger
-symbols are shown, if they exist and the filename ends on size.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;On the map
+larger symbols are shown, if they exist and the filename ends on size.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;Incorrectly
 named files will be ignored.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
@@ -154,12 +158,11 @@
 &lt;p class=MsoNormal&gt;&lt;span class=GramE&gt;&lt;span lang=EN-GB style='mso-ansi-language:
 EN-GB'&gt;old&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt; Nr&lt;span
 style='mso-tab-count:1'&gt;&#160; &lt;/span&gt;&lt;span class=SpellE&gt;newNr&lt;/span&gt;&lt;span
-style='mso-tab-count:1'&gt; &lt;/span&gt;&lt;span style='mso-tab-count:1'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;meaning&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;meaning&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span class=GramE&gt;&lt;span lang=EN-GB style='mso-ansi-language:
 EN-GB'&gt;0.png&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;span
-style='mso-tab-count:1'&gt;&#160;&#160; &lt;/span&gt;0.png&lt;span style='mso-tab-count:1'&gt;&#160;&#160; &lt;/span&gt;&lt;span
-style='mso-tab-count:1'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Custom&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+style='mso-tab-count:1'&gt;&#160;&#160; &lt;/span&gt;0.png&lt;span style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Custom&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span class=GramE&gt;&lt;span lang=EN-GB style='mso-ansi-language:
 EN-GB'&gt;1.png&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;span

Added: trunk/resources/found.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/found.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/CacheType.java
===================================================================
--- trunk/src/CacheWolf/CacheType.java	2011-04-16 12:35:45 UTC (rev 2978)
+++ trunk/src/CacheWolf/CacheType.java	2011-04-16 14:53:27 UTC (rev 2979)
@@ -31,26 +31,27 @@
 	public byte _cwMappedCType; // CW Cache Typ intern
 	public byte _cwCType; // CW Cache Typ intern
 	public char _cwCGroup; // Cache Typ Group intern
-	public String _cwCTypeV1; // V1 Cache Typ 
-	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com 
-	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com 
-	public byte _cwCTypeV2; // V2 Cache Typ 
+	public String _cwCTypeV1; // V1 Cache Typ
+	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com
+	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com
+	public byte _cwCTypeV2; // V2 Cache Typ
 	public char _gpxShortCType; // Short Typ (one char abbreviation)
 	public String _imageName; // name of imageName for Icon, &quot;showCacheInBrowser&quot; and &quot;KML Export&quot;
 	public String _gpxWptTypeTag; // gpx wpt &lt;type&gt; tag
 	public String _gpxWptSymTag; // gpx wpt &lt;sym&gt; tag
 	public String _gpxWptGCextensionTypTag; // gpx cache extension &lt;groundspeak:type&gt; tag
-	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources 		
+	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources
 	public int _msgNrCTypeName; // message number for gui cache Typ name
 	public int _GUIOrder; // sort Order in GUI selection //TODO more intelligent implementation (now manually change each line on new one)
-	public int _FilterStringPos; // BitNr in Filter String (profile) 
+	public int _FilterStringPos; // BitNr in Filter String (profile)
 	public int _FilterPattern; // 2**BitNr in Filter int (does not correspond with BitNr in String)
-	public Image _iconImage; 
+	public Image _iconImage;
 	public Image _mapImage;
-	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, 
-			String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, 
+	public Image _foundImage;
+	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider,
+			String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName,
 			String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos, int filterPattern) {
-		
+
 		_cwMappedCType = cwMappedCType;
 		_cwCType = cwCType;
 		_cwCGroup = cwCGroup;
@@ -71,13 +72,14 @@
 		if (!_imageName.equals(&quot;&quot;)) {
 			_iconImage=new Image(_imageName);
 			_mapImage=_iconImage;
+			_foundImage=new Image(&quot;found.png&quot;);
 		}
 	}
 }
 
 
 /**
- * Handles all aspects of converting cache type information 
+ * Handles all aspects of converting cache type information
  * from and to the various im- and exporters ...
  * converting legacy profiles to current standard
  *
@@ -158,12 +160,12 @@
 		new CTyp(CW_TYPE_REFERENCE,CW_TYPE_REFERENCE,'A',&quot;55&quot;,&quot;&quot;,&quot;&quot;,(byte) -73,'R',&quot;typeReference.png&quot;,new String[] {&quot;Waypoint|Reference Point&quot;,&quot;Reference Point&quot;,&quot;Reference Point&quot;,&quot;&quot;},55,18,16,0x010000),
 		// error on waypoint
 		new CTyp(CW_TYPE_ERROR,CW_TYPE_ERROR,'E',&quot;&quot;,&quot;&quot;,&quot;&quot;,(byte) -1,'-',&quot;guiError.png&quot;,new String[] {&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},49,-1,-1,0),
-        // mapped types (recognized on input from gpx or download-spider / or cw - version)                 
+        // mapped types (recognized on input from gpx or download-spider / or cw - version)
 		new CTyp(CW_TYPE_UNKNOWN,(byte) 1,'C',&quot;&quot;,&quot;&quot;,&quot;1&quot;,(byte) -1,'U',&quot;&quot;,new String[] {&quot;Geocache|Other&quot;,&quot;Geocache&quot;,&quot;Other&quot;,&quot;Other&quot;},21,-1,-1,0),
 		new CTyp(CW_TYPE_UNKNOWN,(byte) 7,'C',&quot;7&quot;,&quot;&quot;,&quot;7&quot;,(byte) -121,'U',&quot;&quot;,new String[] {&quot;Geocache|Quiz&quot;,&quot;Geocache&quot;,&quot;Quiz&quot;,&quot;Quiz&quot;},7,-1,-1,0),
 		new CTyp(CW_TYPE_UNKNOWN,(byte) 9,'C',&quot;9&quot;,&quot;&quot;,&quot;9&quot;,(byte) -119,'U',&quot;&quot;,new String[] {&quot;Geocache|Moving&quot;,&quot;Geocache&quot;,&quot;Moving&quot;,&quot;Moving&quot;},9,-1,-1,0),
 		new CTyp(CW_TYPE_TRADITIONAL,(byte) 10,'C',&quot;10&quot;,&quot;&quot;,&quot;10&quot;,(byte) -118,'U',&quot;&quot;,new String[] {&quot;Geocache|DriveIn&quot;,&quot;Geocache&quot;,&quot;DriveIn&quot;,&quot;DriveIn&quot;},10,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 14,'C',&quot;&quot;,&quot;3653&quot;,&quot;&quot;,(byte) -1,'X',&quot;&quot;,new String[] {&quot;Geocache|Lost and Found Event Cache&quot;,&quot;Geocache&quot;,&quot;Lost and Found Event Cache&quot;,&quot;&quot;},6,-1,-1,0),		         
+		new CTyp(CW_TYPE_EVENT,(byte) 14,'C',&quot;&quot;,&quot;3653&quot;,&quot;&quot;,(byte) -1,'X',&quot;&quot;,new String[] {&quot;Geocache|Lost and Found Event Cache&quot;,&quot;Geocache&quot;,&quot;Lost and Found Event Cache&quot;,&quot;&quot;},6,-1,-1,0),
 		new CTyp(CW_TYPE_TRADITIONAL,(byte) 102,'C',&quot;&quot;,&quot;9&quot;,&quot;&quot;,(byte) -1,'T',&quot;&quot;,new String[] {&quot;Geocache|Project APE Cache&quot;,&quot;Geocache&quot;,&quot;Project APE Cache&quot;,&quot;APE&quot;},16,-1,-1,0),
 		new CTyp(CW_TYPE_EVENT,(byte) 103,'C',&quot;&quot;,&quot;1304&quot;,&quot;&quot;,(byte) -1,'X',&quot;&quot;,new String[] {&quot;Geocache|GPS Adventures Exhibit&quot;,&quot;Geocache&quot;,&quot;GPS Adventures Exhibit&quot;,&quot;MAZE&quot;},17,-1,-1,0),
 		new CTyp(CW_TYPE_UNKNOWN,(byte) 108,'C',&quot;&quot;,&quot;&quot;,&quot;8&quot;,(byte) -1,'U',&quot;&quot;,new String[] {&quot;only on OC download&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},19,-1,-1,0),
@@ -179,12 +181,12 @@
 	   }
 	}
 	public static byte Ref_Index(final byte type) {
-		byte ret=Ref_Index[cTypRef[Ref_Index[type+1]]._cwMappedCType + 1];
+		final byte ret=Ref_Index[cTypRef[Ref_Index[type+1]]._cwMappedCType + 1];
 		return ret;
 	}
-	
-	
-	
+
+
+
 	/**
 	 * check if a given waypoint type is an additional waypoint
 	 * @param type waypoint type to check
@@ -209,8 +211,8 @@
 	public static boolean isCustomWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'P';
 	}
-	
-	
+
+
 	// done for DetailsPanel.java and KML- and TomTom-Exporter
 	/**
 	 * create list of cache types to be shown in GUI drop down lists
@@ -225,7 +227,7 @@
 				j=cTypRef[i]._GUIOrder;
 			}
 		}
-		String[] ret = new String[j+1];
+		final String[] ret = new String[j+1];
 		for (int i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder &gt; -1) {
 				ret[cTypRef[i]._GUIOrder]=MyLocale.getMsg(cTypRef[i]._msgNrCTypeName,&quot;&quot;);
@@ -259,8 +261,8 @@
 		return cTypRef[Ref_Index(typeId)]._GUIOrder;
 	}
 
-	
-	
+
+
 	/**
 	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
 	 * @param gpxType type information found in GPX
@@ -273,14 +275,14 @@
 		for (byte i=0; i&lt;cTypRef.length; i++) {
 			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {return cTypRef[i]._cwMappedCType;};
 		}
-		String lowerCaseGPXType = gpxType.toLowerCase();
+		final String lowerCaseGPXType = gpxType.toLowerCase();
 		for (byte i=0; i&lt;cTypRef.length; i++) {
 			if (cTypRef[i]._gpxAlternativeWptTypTags.toLowerCase().indexOf(lowerCaseGPXType) != -1) {
 				return cTypRef[i]._cwMappedCType;
 			};
 		}
 		// TODO extend definition of _gpxAlternativeWptTypTags for all cases of Mystery
-		// old code was : if (!(gpxType.indexOf(&quot;Mystery&quot;)==-1)) return CW_TYPE_UNKNOWN; 
+		// old code was : if (!(gpxType.indexOf(&quot;Mystery&quot;)==-1)) return CW_TYPE_UNKNOWN;
 		return -1;
 	}
 
@@ -341,8 +343,8 @@
 		return -1;
 	}
 
-	
-	
+
+
 	/**
 	 * translate cache type to a short version for compact exporters or &quot;smart&quot; cache names.
 	 * @param typeId CacheWolf internal type information
@@ -407,13 +409,17 @@
 	public static Image getMapImage(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._mapImage;
 	}
+
+	public static Image getFoundImage(final byte typeId) {
+		return cTypRef[Ref_Index(typeId)]._foundImage;
+	}
 	/**
 	 * select image to be displayed for a given cache type
 	 * @param typeId internal cache type id
 	 * @param Image object to be displayed
 	 */
 	public static void setTypeImage(final byte id, final Image iconImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage) 
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._iconImage.free();
 		cTypRef[Ref_Index(id)]._iconImage=iconImage;
 	}
@@ -423,12 +429,15 @@
 	 * @param Image object to be displayed
 	 */
 	public static void setMapImage(final byte id, final Image mapImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage) 
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._mapImage.free();
 		cTypRef[Ref_Index(id)]._mapImage=mapImage;
 	}
-	
-	
+	public static void setFoundImage(final byte id, final Image foundImage) {
+		cTypRef[Ref_Index(id)]._foundImage=foundImage;
+	}
+
+
 	// TODO do it better in Version 4
 	public static int getCacheTypePattern(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._FilterPattern;
@@ -456,6 +465,6 @@
 		}
 		return (typeMatchPattern &amp; TYPE_MAIN) != 0;
 	}
-	
+
 	// TODO it for OCXMLImporterScreen and FilterScreen ?
 }

Modified: trunk/src/CacheWolf/GuiImageBroker.java
===================================================================
--- trunk/src/CacheWolf/GuiImageBroker.java	2011-04-16 12:35:45 UTC (rev 2978)
+++ trunk/src/CacheWolf/GuiImageBroker.java	2011-04-16 14:53:27 UTC (rev 2979)
@@ -53,12 +53,17 @@
 		// Noting to do
 	}
 
-	public static Image getTypeImage(byte typeId,boolean map) {
+	public static Image getTypeImage(byte typeId,boolean map, boolean found) {
 		if (!map) {
 			return CacheType.getTypeImage(typeId);
 		}
 		else {
-			return CacheType.getMapImage(typeId);
+			if (found) {
+				return CacheType.getFoundImage(typeId);
+			}
+			else {
+				return CacheType.getMapImage(typeId);
+			}
 		}
 	}
 
@@ -78,6 +83,7 @@
 		if (dir.isDirectory()){
 			int id;
 			boolean size=false;
+			boolean found=false;
 			String name = &quot;&quot;;
 			String [] pngFiles;
 			pngFiles=dir.list(&quot;*.png&quot;,0);
@@ -88,18 +94,29 @@
 					size=true;
 					name=name.substring(0,name.length()-4);
 				}
+				if (name.toLowerCase().endsWith(&quot;found&quot;)){
+					found=true;
+					name=name.substring(0,name.length()-5);
+				}
 				try {
 					id = Integer.parseInt(name);
 				}
-				catch (Exception E){
+				catch (final Exception E){
 					id = -1; //filename invalid for symbols
 				}
 				if (0&lt;=id &amp;&amp; id&lt;=CacheType.maxCWCType){
-					String s=FileBase.getProgramDirectory()+sdir+pngFiles[i];
+					final String s=FileBase.getProgramDirectory()+sdir+pngFiles[i];
 					Global.getPref().log(&quot;own symbol: &quot;+(i+1)+&quot; = &quot;+pngFiles[i]);
 					if (size){
-						CacheType.setMapImage((byte) id, new Image(s));
+						if (found) {
+							CacheType.setFoundImage((byte) id, new Image(s));
+						}
+						else {
+							CacheType.setMapImage((byte) id, new Image(s));
+						}
 						size=false;
+						found=false;
+
 					}
 					else{
 						CacheType.setTypeImage((byte) id, new Image(s));

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2011-04-16 12:35:45 UTC (rev 2978)
+++ trunk/src/CacheWolf/RadarPanel.java	2011-04-16 14:53:27 UTC (rev 2979)
@@ -69,43 +69,43 @@
 	*/
 	public RadarPanel(){
 		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		CellPanel cp = new CellPanel();
+		final CellPanel cp = new CellPanel();
 		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
 		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
 		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
 		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
 	}
-	
+
 	public void setMainTab(MainTab tb){
 		mt = tb;
 		iActP.setMainTab(tb);
 	}
-	
+
 	/**
 	* Informs the radar panel on preferences and currently loaded cache
-	* database. It also calculates the maximum size available for drawing 
+	* database. It also calculates the maximum size available for drawing
 	* the radar.
 	*/
 	public void setParam(Preferences p, CacheDB db, CacheHolder sWp){
 		selectedWaypoint = sWp;
 		pref = p;
 		cacheDB = db;
-		height = (pref.myAppHeight)*6/5; // add 10% each at top/bottom 
+		height = (pref.myAppHeight)*6/5; // add 10% each at top/bottom
 		width = (pref.myAppWidth)*6/5;
 	}
-	
+
 	// Call this after the centre has changed to re-center the radar panel
 	public void recenterRadar() {
 		reCenterImage=true;
 	}
-	
+
 	/**
 	* Public method to draw the different caches and the
 	* radar background
 	*/
 	public void drawThePanel(){
 		// If there are any images remove them!
-		int anz = iActP.images.size();
+		final int anz = iActP.images.size();
 		for(int i = 0; i&lt;anz;i++){
 			iActP.removeImage((AniImage)iActP.images.get(0));
 		}
@@ -116,25 +116,25 @@
 		if (reCenterImage) {
 			// Hack to scroll to left origin for a defined position for subsequent
 			// scroll which centers the image
-			iActP.scroll(-1000,-1000); 
-			Dimension dispSize=getDisplayedSize(null);
+			iActP.scroll(-1000,-1000);
+			final Dimension dispSize=getDisplayedSize(null);
 			iActP.scroll((width-dispSize.width)/2,(height-dispSize.height+btMinus.getSize(null).height)/2);
 			reCenterImage=false;
 		}
 	}
-	
+
 	/**
 	* Private method to draw the caches.
 	*/
 	private void drawCaches(){
-		Font radarFont = new Font(&quot;Gui&quot;, Font.BOLD,Global.getPref().fontSize);
-		FontMetrics fm = getFontMetrics(radarFont);
+		final Font radarFont = new Font(&quot;Gui&quot;, Font.BOLD,Global.getPref().fontSize);
+		final FontMetrics fm = getFontMetrics(radarFont);
 		AniImage aImg;
 		RadarPanelImage rpi;
 		int drX,drY = 0;
 		CacheHolder holder;
 		double degrees;
-		double pi180=java.lang.Math.PI / 180.0;
+		final double pi180=java.lang.Math.PI / 180.0;
 		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
 			holder = cacheDB.get(i);
 			if(holder.isVisible() &amp;&amp; holder.pos.isValid()) {
@@ -148,10 +148,10 @@
 							s=holder.getWayPoint();
 						else
 							s=holder.getCacheName();
-						if (s.length()&gt;0) { 
+						if (s.length()&gt;0) {
 							int tw;
-							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
-							Graphics g = new Graphics(img);
+							final Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
+							final Graphics g = new Graphics(img);
 							g.setFont(radarFont);
 							g.setColor(Color.Black);
 							g.fillRect(0,0,tw, fm.getHeight());
@@ -164,20 +164,20 @@
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=GuiImageBroker.getTypeImage(holder.getType(),true);
+					Image imgCache=GuiImageBroker.getTypeImage(holder.getType(),true, holder.is_found());
 					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=GuiImageBroker.getTypeImage(CacheType.CW_TYPE_UNKNOWN,true); 
+					if (imgCache==null) imgCache=GuiImageBroker.getTypeImage(CacheType.CW_TYPE_UNKNOWN,true,false);
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;
-					int dx = imgCache.getWidth();
-					int dy = imgCache.getHeight();
+					final int dx = imgCache.getWidth();
+					final int dy = imgCache.getHeight();
 					rpi.setLocation(centerX+drX-dx/2,centerY+drY-dy/2);
 					iActP.addImage(rpi);
 					if(holder == selectedWaypoint){ // Draw red circle around selected wpt
-						int diag = (int) (java.lang.Math.sqrt(dx*dx+dy*dy)+0.5);
-						Image imgCircle = new Image(diag, diag);
-						Graphics gCircle = new Graphics(imgCircle);
+						final int diag = (int) (java.lang.Math.sqrt(dx*dx+dy*dy)+0.5);
+						final Image imgCircle = new Image(diag, diag);
+						final Graphics gCircle = new Graphics(imgCircle);
 						gCircle.setColor(Color.Black);
 						gCircle.fillRect(0,0,diag,diag);
 						gCircle.setColor(new Color(255,0,0));
@@ -192,22 +192,22 @@
 			}// if is_black...
 		}
 	}
-	
+
 	/**
 	* Private method to draw the black background and green radar.
 	* Also calculates some other parameters.
 	* Always call this before calling drawCaches().
 	*/
 	private void drawBackground(){
-		Rect r = new Rect(new Dimension(width, height));
+		final Rect r = new Rect(new Dimension(width, height));
 		iActP.virtualSize = r;
 		iActP.refresh();
-		Image img = new Image(width, height);
-		Graphics g = new Graphics(img);
+		final Image img = new Image(width, height);
+		final Graphics g = new Graphics(img);
 		g.setColor(Color.Black);
 		g.fillRect(0,0,width, height);
-		
-		
+
+
 		if(width &lt; height) {
 			scale = (double)scaleKm / (double)height;
 		} else {
@@ -218,7 +218,7 @@
 		//centerY = (int)(centerY-centerY*0.15);
 		g.setColor(new Color(0,255,0));
 		int radstep= 0, steps=0, radius = 0;
-		
+
 		if(width &gt; height){
 			radstep = (int)(10 / scale);
 			steps = (width / radstep);
@@ -239,15 +239,15 @@
 			radius = radstep/5;
 			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
 			g.free();
-		}	
-		AniImage aImg = new AniImage(img);
+		}
+		final AniImage aImg = new AniImage(img);
 		//iActP.addImage(aImg);
 		iActP.backgroundImage = img;
-		int xPos = (pref.myAppWidth/2 - width/2);
+		final int xPos = (pref.myAppWidth/2 - width/2);
 		aImg.setLocation(xPos,0);
 		aImg.refresh();
 	}
-	
+
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == btPlus){

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-04-16 12:35:45 UTC (rev 2978)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-04-16 14:53:27 UTC (rev 2979)
@@ -136,8 +136,8 @@
 	double lastDistance = -1;
 
 	// the layer for the buttons
-	private MovingMapControls controlsLayer;
-	
+	private final MovingMapControls controlsLayer;
+
 	float lastHighestResolutionGPSDestScale = -1;
 
 	public static final int tileWidth = 100;
@@ -158,7 +158,7 @@
 		pref.fillWhiteArea = fillWhiteArea;
 		if (!fillWhiteArea) { // remove tiles from panel
 			for (int i = mmp.images.size() -1; i &gt;= 0; i--) {
-				AniImage im = (AniImage) mmp.images.get(i);
+				final AniImage im = (AniImage) mmp.images.get(i);
 				if ((im instanceof MapImage)
 						&amp;&amp; (!((im instanceof MapSymbol)
 								|| (im instanceof TrackOverlay) || mmp.mapImage == im))) {
@@ -177,16 +177,16 @@
 		}
 
 	}
-	
-	
+
+
 	public boolean isMobileVga() {
 		return mobileVGA;
 	}
-	
+
 	public InteractivePanel getMmp() {
 		return mmp;
 	}
-	
+
 	public MovingMapControls getControlsLayer() {
 		return controlsLayer;
 	}
@@ -209,12 +209,12 @@
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 
-		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) 
+		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400)
 			mobileVGA = true;
 		String imagesize=&quot;&quot;;
 		if(mobileVGA) imagesize=&quot;_vga&quot;;
 
-		
+
 		statusImageHaveSignal = new AniImage(&quot;position_green&quot;+imagesize+&quot;.png&quot;);
 		statusImageNoSignal = new AniImage(&quot;position_yellow&quot;+imagesize+&quot;.png&quot;);
 		statusImageNoGps = new AniImage(&quot;position_red&quot;+imagesize+&quot;.png&quot;);
@@ -224,8 +224,8 @@
 		directionArrows.properties = mImage.AlwaysOnTop;
 		mmp.addImage(directionArrows);
 		//target distance
-		int fontSize = ( 3 * pref.fontSize ) / 2;
-		Font imageFont = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize );
+		final int fontSize = ( 3 * pref.fontSize ) / 2;
+		final Font imageFont = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize );
 		fm = getFontMetrics(imageFont);
 		setGpsStatus(noGPS);
 		posCircle.properties = mImage.AlwaysOnTop;
@@ -238,10 +238,10 @@
 		lastHighestResolutionGPSDestScale = -1;
 
 		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
-		
+
 		controlsLayer = new MovingMapControls(this);
-		
-		
+
+
 	}
 
 	public void resizeTo(int w,int h) {
@@ -274,12 +274,12 @@
 	public void loadMaps(String mapsPath, double lat){
 		if (loadingMapList) return;
 		loadingMapList = true;
-		InfoBox inf = new InfoBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(4203, &quot;Loading list of maps...&quot;));
+		final InfoBox inf = new InfoBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(4203, &quot;Loading list of maps...&quot;));
 		Vm.showWait(this, true);
 		inf.exec();
 		inf.waitUntilPainted(100);
 		resetCenterOfMap();
-		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		final boolean saveGpsIgnoreStatus = dontUpdatePos;
 		dontUpdatePos = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
@@ -301,7 +301,7 @@
 		{
 			double lineLengthMeters = 40 * currentMap.scale;
 
-			int metricSystem = pref.metricSystem;
+			final int metricSystem = pref.metricSystem;
 			double localizedLineLength = 0;
 			int bigUnit = -1;
 			int smallUnit = -1;
@@ -338,10 +338,10 @@
 			String lineLengthString = Convert.toString((int) localizedLineLength) + Metrics.getUnit(currentUnit);
 
 			if	(digits &lt; 0){
-				Double tmp = new Double();
+				final Double tmp = new Double();
 				tmp.set(localizedLineLength);
 
-				int decimals = (int)(-1 * digits);
+				final int decimals = (int)(-1 * digits);
 
 				lineLengthString = tmp.toString(decimals+2,decimals,0) + Metrics.getUnit(currentUnit);
 //				lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) + Metrics.getUnit(currentUnit);
@@ -349,7 +349,7 @@
 
 			lineLengthMeters = Metrics.convertUnit( localizedLineLength, currentUnit, Metrics.METER);
 
-			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+			final int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
 
 			controlsLayer.updateContent(&quot;scale&quot;, lineLengthString, lineLengthPixels);
 		}
@@ -362,14 +362,14 @@
 	public void updateDistance(boolean repaint) {
 		if (gotoPos != null &amp;&amp; posCircle.where.isValid())
 		{
-			double currentDistance = gotoPos.where.getDistance(posCircle.where);
+			final double currentDistance = gotoPos.where.getDistance(posCircle.where);
 			if (currentDistance != lastDistance)
 			{
 				lastDistance = currentDistance;
-				ewe.sys.Double dd = new ewe.sys.Double();
+				final ewe.sys.Double dd = new ewe.sys.Double();
 				String d;
 
-				int metricSystem = pref.metricSystem;
+				final int metricSystem = pref.metricSystem;
 				double localizedDistance = 0;
 				int bigUnit = -1;
 				int smallUnit = -1;
@@ -411,18 +411,18 @@
 	}
 
 	public final FormFrame myExec(CWPoint centerTo, boolean forceCenter) {
-		FormFrame ret = exec();
+		final FormFrame ret = exec();
 		running = true;
 		// disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
 		if (forceCenter) setGpsStatus(noGPS);
 		// to load maplist + place a map on screen otherwise no symbol can be placed
 		ignoreGps=true; // else overlay symbols are removed on started gps
-		
+
 		rebuildOverlaySet(); // show tracks , even if reentering map
-		
+
 		updatePosition(centerTo);
 		setCenterOfScreen(centerTo, false);
-		
+
 		if (getControlsLayer()!=null) {
 			getControlsLayer().changeRoleState(MovingMapControls.ROLE_MENU, false);
 		}
@@ -435,7 +435,7 @@
 		}
 		setMarkedCache(Global.mainTab.ch); // this is the selected one (not necessary marked)
 		showCachesOnMap();
-		
+
 		if (myNavigation.destinationIsCache) {
 			destChanged(myNavigation.destinationCache);
 		}
@@ -445,7 +445,7 @@
 
 		repaint();
 		ignoreGps=false;
-		
+
 		return ret;
 	}
 
@@ -458,7 +458,7 @@
 		if (ch != null) {
 			if ( ch.pos.isValid()) {
 				addSymbol(&quot;selectedCache&quot;, MARK_CACHE_IMAGE, ch.pos);
-				addSymbolIfNecessary(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
+				addSymbolIfNecessary(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
 				markedCache = ch;
 			}
 		}
@@ -491,10 +491,10 @@
 		try {
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 			addMissingOverlays();
-		} catch (NullPointerException e) {
+		} catch (final NullPointerException e) {
 			// hapens if currentmap == null or PosCircle not valid
 		}
-		catch (IllegalArgumentException e) {
+		catch (final IllegalArgumentException e) {
 			// happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
 		}
 	}
@@ -518,9 +518,9 @@
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 		}
-		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		final boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
 		dontUpdatePos = true;
-		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
+		final Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
 		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
 		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
 		int i;
@@ -549,7 +549,7 @@
 		TrackOverlays[ov]=null;
 	}
 	public void rearangeOverlays() {
-		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
+		final Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
 			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
 			destroyOverlay(6);
@@ -714,9 +714,9 @@
 		//	Point upperleft = getMapXYPosition();
 		Point posOnScreen;
 		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft);
-		Dimension ws = mmp.getSize(null);
-		int ww = ws.width;
-		int wh = ws.height;
+		final Dimension ws = mmp.getSize(null);
+		final int ww = ws.width;
+		final int wh = ws.height;
 		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
 		int num, pX, pY;
 		for (int yi=0; yi&lt;3; yi++) {
@@ -768,8 +768,8 @@
 	}
 
 	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
-		Point mappos = getMapPositionOnScreen();
-		Point onscreenpos = getXYonScreen(c);
+		final Point mappos = getMapPositionOnScreen();
+		final Point onscreenpos = getXYonScreen(c);
 		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
 		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
 		if (repaint) mmp.repaintNow();
@@ -781,10 +781,10 @@
 	 * @param diffY
 	 */
 	public void mapMoved(int diffX, int diffY) {
-		int w = posCircle.getWidth();
-		int h = posCircle.getHeight();
-		int npx = posCircleX-w/2+diffX;
-		int npy = posCircleY-h/2+diffY;
+		final int w = posCircle.getWidth();
+		final int h = posCircle.getHeight();
+		final int npx = posCircleX-w/2+diffX;
+		final int npy = posCircleY-h/2+diffY;
 		posCircle.move(npx, npy);
 		posCircleX = posCircleX+diffX;
 		posCircleY = posCircleY+diffY;
@@ -808,10 +808,10 @@
 		if (currentMap == null || !posCircle.where.isValid())
 			return new Point(pref.myAppWidth +1, pref.myAppHeight +1);
 		// in case no calculation is possible return somthing outside of the screen
-		Point mapPos = new Point();
+		final Point mapPos = new Point();
 		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
 		//else {
-		Point mapposint = currentMap.calcMapXY(posCircle.where);
+		final Point mapposint = currentMap.calcMapXY(posCircle.where);
 		mapPos.x = posCircleX - mapposint.x;
 		mapPos.y = posCircleY - mapposint.y;
 		//}
@@ -826,13 +826,13 @@
 	 */
 	public Point getXYonScreen(TrackPoint ll){
 		if (currentMap == null) return null;
-		Point coords = currentMap.calcMapXY(ll);
-		Point mapPos = getMapPositionOnScreen();
+		final Point coords = currentMap.calcMapXY(ll);
+		final Point mapPos = getMapPositionOnScreen();
 		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 	}
 
 	public CWPoint ScreenXY2LatLon (int px, int py){
-		Point mapPos = getMapPositionOnScreen();
+		final Point mapPos = getMapPositionOnScreen();
 		return currentMap.calcLatLon(px - mapPos.x, py - mapPos.y);
 	}
 
@@ -854,10 +854,10 @@
 
 	public MapSymbol addSymbol(String pName, String filename, CWPoint where) {
 		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, filename, where);
+		final MapSymbol ms = new MapSymbol(pName, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(where);
+		final Point pOnScreen = getXYonScreen(where);
 		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
 		mmp.addImage(ms);
@@ -866,10 +866,10 @@
 
 	public MapSymbol addSymbol(String pName, Object mapObject, String filename, CWPoint where) {
 		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
+		final MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(where);
+		final Point pOnScreen = getXYonScreen(where);
 		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
 		mmp.addImage(ms);
@@ -888,9 +888,9 @@
 
 	public void addSymbol(String pName, Object mapObject, Image imSymb, CWPoint ll) {
 		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
+		final MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
 		ms.properties = mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(ll);
+		final Point pOnScreen = getXYonScreen(ll);
 		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
 		mmp.addImage(ms);
@@ -902,20 +902,22 @@
 		removeMapSymbol(&quot;goto&quot;);
 		if (d == null || !d.isValid() ) return;
 		gotoPos = addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, d);
-		//updateDistance(); - this is called from updatePosition
 		forceMapLoad = true;
-		if (this.width != 0) updatePosition(posCircle.where); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+		// dirty hack: if this.width == 0, then the symbols are not on the screen
+		// and get hidden by updateSymbolPositions
+		if (this.width != 0) updatePosition(posCircle.where);
 	}
 
 	public void destChanged(CacheHolder ch) {
-		CWPoint d = new CWPoint (ch.pos);
+		final CWPoint d = new CWPoint (ch.pos);
 		if(!running || (gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
 		removeMapSymbol(&quot;goto&quot;);
 		if (!d.isValid() ) return;
 		gotoPos = addSymbol(&quot;goto&quot;, ch, &quot;goto_map.png&quot;, d);
-		//updateDistance(); - this is called from updatePosition
 		forceMapLoad = true;
-		if (this.width != 0) updatePosition(posCircle.where); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+		// dirty hack: if this.width == 0, then the symbols are not on the screen
+		// and get hidden by updateSymbolPositions
+		if (this.width != 0) updatePosition(posCircle.where);
 	}
 
 	public CWPoint getGotoPos(){
@@ -932,12 +934,12 @@
 	}
 
 	public void removeMapSymbol(String pName) {
-		int symbNr = findMapSymbol(pName);
+		final int symbNr = findMapSymbol(pName);
 		if (symbNr != -1) removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(Object obj) {
-		int symbNr = findMapSymbol(obj);
+		final int symbNr = findMapSymbol(obj);
 		if (symbNr != -1) removeMapSymbol(symbNr);
 	}
 
@@ -973,7 +975,7 @@
 	 */
 	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
 		posCircle.where.set(where);
-		Point mapPos = getMapPositionOnScreen();
+		final Point mapPos = getMapPositionOnScreen();
 		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1))
 		{
 			lastRepaintMapPos = mapPos;
@@ -1006,8 +1008,8 @@
 		loadBestMap(where);
 		if (width==0 || height==0) { pref.log(&quot;[MovingMap:updatePosition]no window shown&quot;); return; } // why is this called with these values
 		updateOnlyPosition(where, true);
-		Point mapPos = getMapPositionOnScreen();
-		boolean screenNotCompletlyCovered = (mmp.mapImage == null)
+		final Point mapPos = getMapPositionOnScreen();
+		final boolean screenNotCompletlyCovered = (mmp.mapImage == null)
 				|| (mmp.mapImage != null &amp;&amp; (
 				   mapPos.y &gt; 0                                      || mapPos.x                           &gt; 0
 				|| mapPos.y + mmp.mapImage.getHeight() &lt; this.height || mapPos.x + mmp.mapImage.getWidth() &lt; this.width));
@@ -1027,17 +1029,17 @@
 				lastCompareY = mapPos.y;
 			}
 			else{
-				int deltaX = mapPos.x - lastXPos;
-				int deltaY = mapPos.y - lastYPos;
+				final int deltaX = mapPos.x - lastXPos;
+				final int deltaY = mapPos.y - lastYPos;
 				for(int i = mmp.images.size() -1; i &gt;= 0; i--){
-					AniImage im = (AniImage) mmp.images.get(i);
+					final AniImage im = (AniImage) mmp.images.get(i);
 					if ((im instanceof MapImage)
 						&amp;&amp; (!((im instanceof MapSymbol)
 							|| (im instanceof TrackOverlay)
 							|| mmp.mapImage == im))) {
 						//locAlways contains the real coordinates while
 						//location is only correct if the image is on the screen.
-						Point p = ((MapImage)im).locAlways;
+						final Point p = ((MapImage)im).locAlways;
 						p.x += deltaX;
 						p.y += deltaY;
 						im.setLocation(p.x, p.y);
@@ -1055,18 +1057,18 @@
 	private void showCachesOnMap() {
 		// if (width == 0 || height == 0) return;
 		CacheHolder ch;
-		Area screenArea = new Area(ScreenXY2LatLon(0,0), ScreenXY2LatLon(width,height));
+		final Area screenArea = new Area(ScreenXY2LatLon(0,0), ScreenXY2LatLon(width,height));
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
 			if (screenArea.isInBound(ch.pos)) {
 				// because visible and valid don't change while showing map --&gt;need no remove
 				if (ch.isVisible() &amp;&amp; ch.pos.isValid()) {
 					if (pref.showCachesOnMap) {
-						addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
+						addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
 					}
 					else {
 						if (ch.is_Checked) {
-							addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
+							addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
 						}
 						else {
 							removeMapSymbol(ch);
@@ -1096,7 +1098,7 @@
 			if (gotoPosCH != null) {
 				if (screenArea.isInBound(gotoPosCH.pos)) {
 					if (!pref.showCachesOnMap) {
-						addSymbolIfNecessary(gotoPosCH.cacheName, gotoPosCH, GuiImageBroker.getTypeImage(gotoPosCH.getType(),true), gotoPosCH.pos);
+						addSymbolIfNecessary(gotoPosCH.cacheName, gotoPosCH, GuiImageBroker.getTypeImage(gotoPosCH.getType(),true,gotoPosCH.is_found()), gotoPosCH.pos);
 					}
 					addSymbolOnTop(&quot;goto&quot;, gotoPosCH, &quot;goto_map.png&quot;, gotoPos.where);
 				}
@@ -1105,7 +1107,7 @@
 		// show Selected
 		if (markedCache != null) {
 			if (screenArea.isInBound(markedCache.pos)) {
-				addSymbolIfNecessary(markedCache.cacheName, markedCache, GuiImageBroker.getTypeImage(markedCache.getType(),true), markedCache.pos);
+				addSymbolIfNecessary(markedCache.cacheName, markedCache, GuiImageBroker.getTypeImage(markedCache.getType(),true, false), markedCache.pos);
 				addSymbolOnTop(&quot;selectedCache&quot;, markedCache, MARK_CACHE_IMAGE, markedCache.pos);
 			}
 		}
@@ -1115,14 +1117,14 @@
 		if (mmp.mapImage == null) return; // if error at map load
 		// Clean up any additional images, tiles will removed and any
 		// other item be added again later
-		Vector icons = new Vector(mmp.images.size());
-		try {			
+		final Vector icons = new Vector(mmp.images.size());
+		try {
 		Vm.showWait(true);
 		dontUpdatePos=true; // no new Position while filling
-		
-		int s = mmp.images.size(); // avoid calling size() in each iteration
+
+		final int s = mmp.images.size(); // avoid calling size() in each iteration
 		for (int i = 0; i &lt; s ;  i++) {
-			AniImage im = (AniImage) mmp.images.get(i);
+			final AniImage im = (AniImage) mmp.images.get(i);
 			if (!(im instanceof MapImage) ||
 				(im instanceof MapSymbol) ||
 				(im instanceof TrackOverlay) ||
@@ -1135,16 +1137,16 @@
 		MovingMapCache.getCache().clearUsedFlags();
 
 		// Holds areas not filled by currentmap and/or used tiles
-		Vector rectangles = new Vector();
+		final Vector rectangles = new Vector();
 		// calculate areas which will not drawn
-		Point mapPosx = getMapPositionOnScreen();
+		final Point mapPosx = getMapPositionOnScreen();
 		if ( screenNotCompletlyCovered &amp;&amp; ( // screen not completely covered is only used, because it is already calculated
 				mapPosx.x &gt; this.width || mapPosx.y &gt; this.height // map doesn't overlap with the screen
 				|| mapPosx.x + mmp.mapImage.getWidth() &lt; 0 || mapPosx.y + mmp.mapImage.getHeight() &lt; 0) ) {
 			rectangles.add(new Rect(0,0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
 		} else {
-			Rect whiteArea = new Rect((int)(-width/10), (int)(-height/10), (int)(width*1.1), (int)(height*1.1));
-			Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
+			final Rect whiteArea = new Rect((-width/10), (-height/10), (int)(width*1.1), (int)(height*1.1));
+			final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
 			calculateRectangles(blackArea, whiteArea, rectangles);
 		}
 		// I've sometimes experienced an endless loop which might be
@@ -1157,7 +1159,7 @@
 			try {
 				updateTileForWhiteArea(rectangles);
 			}
-			catch (ewe.sys.SystemResourceException sre) {
+			catch (final ewe.sys.SystemResourceException sre) {
 				// next time there may be no problem, and ask only once
 				if (reflectResourceException) {
 					if (new MessageBox(
@@ -1168,34 +1170,34 @@
 						reflectResourceException=true;
 					}
 					else {
-						reflectResourceException=false;						
+						reflectResourceException=false;
 					}
 				}
 			}
 		}
-		} 
+		}
 		finally {
 			// Remove all tiles not needed from the cache to reduce memory
 			MovingMapCache.getCache().cleanCache();
 			// At Last redraw all icons on the map
 			mmp.images.addAll(icons);
-			Vm.showWait(false);		
-			dontUpdatePos=false; // do next Position 
+			Vm.showWait(false);
+			dontUpdatePos=false; // do next Position
 			repaint();
-		} 
+		}
 	}
 	private void updateTileForWhiteArea(Vector rectangles) {
 		Rect blackArea;
-		Rect r = (Rect) rectangles.get(0);
+		final Rect r = (Rect) rectangles.get(0);
 		rectangles.removeElementAt(0);
 		//calculate the center of the rectangle and try to get an map for it
-		int middlewidth = r.x + (r.width)/2;
-		int middleheight = r.y + (r.height)/2;
-		CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
-		Rect screen = new Rect ();
+		final int middlewidth = r.x + (r.width)/2;
+		final int middleheight = r.y + (r.height)/2;
+		final CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
+		final Rect screen = new Rect ();
 		screen.height = r.height ;//- r.y;
 		screen.width = r.width ;//- r.x;
-		MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true,false);
+		final MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true,false);
 		if (bestMap == null){
 			//No map found, area must be left white
 			return;
@@ -1209,21 +1211,21 @@
 		}
 		//Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
 		//For me, showing a message seems better than throwing the NPE
-		String imagefilename = bestMap.getImageFilename();
+		final String imagefilename = bestMap.getImageFilename();
 		if (imagefilename == null){
 			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, FormBase.OKB)).execute();
 			return;
 		}
 
 		if (!imagefilename.equals(currentMap.getImageFilename())) {
-			String filename = bestMap.getImageFilename();
+			final String filename = bestMap.getImageFilename();
 			if (filename.length() &gt; 0) {
 				//calculate position of the new map on the screen
-				Point mapPos = new Point();
-				Point mapposint = bestMap.calcMapXY(posCircle.where);
+				final Point mapPos = new Point();
+				final Point mapposint = bestMap.calcMapXY(posCircle.where);
 				mapPos.x = posCircleX - mapposint.x;
 				mapPos.y = posCircleY - mapposint.y;
-				Point mapDimension = bestMap.calcMapXY(bestMap.bottomright);
+				final Point mapDimension = bestMap.calcMapXY(bestMap.bottomright);
 				blackArea = new Rect (mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
 				//Are there any white areas left?
 				calculateRectangles(blackArea, r, rectangles);
@@ -1243,8 +1245,8 @@
 	private void generateTiles(Rect blackArea, String filename, Point mapPos,
 			Dimension rect2, MapImage fullImage) {
 		//Generate tiles from the map
-		int numRows = ((rect2.height-1)/tileHeight)+1;
-		int numCols = ((rect2.width-1)/tileWidth)+1;
+		final int numRows = ((rect2.height-1)/tileHeight)+1;
+		final int numCols = ((rect2.width-1)/tileWidth)+1;
 		for (int row = 0; row &lt; numRows; row++) {
 			for (int column = 0; column &lt; numCols; column++) {
 				//Tile is not needed, don't process
@@ -1265,7 +1267,7 @@
 					//Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
 					boolean added=false;
 					for(int i=mmp.images.size()-1; i &gt;= 0; i--) {
-						MapImage m=(MapImage) mmp.images.get(i);
+						final MapImage m=(MapImage) mmp.images.get(i);
 						if (m == im){
 							added=true;
 							break;
@@ -1282,17 +1284,17 @@
 
 	private void putImageIntoCache(String filename, MapImage fullImage, Point mapPos, Rect blackArea) {
 		MapImage im;
-		int numRows = (fullImage.getHeight()-1)/tileHeight + 1;
-		int numCols = (fullImage.getWidth()-1)/tileWidth + 1;
+		final int numRows = (fullImage.getHeight()-1)/tileHeight + 1;
+		final int numCols = (fullImage.getWidth()-1)/tileWidth + 1;
 		for (int row2 = 0; row2 &lt; numRows; row2++) {
 			for (int column2 = 0; column2 &lt; numCols; column2++) {
-				int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth*column2));
-				int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight*row2));
+				final int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth*column2));
+				final int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight*row2));
 				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))){
 					continue;
 				}
-				Image image2 = new Image(realWidth, realHeight);
-				int[] pixels = new int[realWidth * realHeight];
+				final Image image2 = new Image(realWidth, realHeight);
+				final int[] pixels = new int[realWidth * realHeight];
 				fullImage.getPixels(pixels, 0, tileWidth * column2, tileHeight * row2, realWidth, realHeight, 0);
 				image2.setPixels(pixels, 0, 0, 0, realWidth, realHeight, 0);
 				im = new MapImage();
@@ -1304,12 +1306,12 @@
 	}
 
 	private boolean isCoveredByBlackArea (Point mapPos, int row,int column,Rect blackArea, Dimension mapDimension){
-		int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth*column));
-		int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight*row));
-		int left = mapPos.x + column * tileWidth;
-		int right = left + realWidth;
-		int top = mapPos.y + row * tileHeight;
-		int bottom = top +realHeight;
+		final int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth*column));
+		final int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight*row));
+		final int left = mapPos.x + column * tileWidth;
+		final int right = left + realWidth;
+		final int top = mapPos.y + row * tileHeight;
+		final int bottom = top +realHeight;
 		if (right &lt; blackArea.x || bottom &lt; blackArea.y){
 			return false;
 		}
@@ -1328,10 +1330,10 @@
 	*/
 	private void calculateRectangles(Rect blackArea, Rect whiteArea, Vector rectangles) {
 		if (width == 0 || height == 0) return;
-		int offsetX = width/10;
-		int offsetY = height/10;
-		int width=this.width+offsetX;
-		int height=this.height+offsetY;
+		final int offsetX = width/10;
+		final int offsetY = height/10;
+		final int width=this.width+offsetX;
+		final int height=this.height+offsetY;
 		if (whiteArea.x &gt;= width || whiteArea.y &gt;= height) return;
 
 		if (blackArea.x &lt; -offsetX){
@@ -1350,7 +1352,7 @@
 		}
 
 		if (blackArea.x &gt; whiteArea.x) {
-			Rect r= new Rect ();
+			final Rect r= new Rect ();
 			r.x = -offsetX;
 			r.y = whiteArea.y;
 			r.width = blackArea.x + offsetX;
@@ -1358,7 +1360,7 @@
 			rectangles.add(r);
 		}
 		if (blackArea.y &gt; whiteArea.y) {
-			Rect r= new Rect ();
+			final Rect r= new Rect ();
 			r.x = whiteArea.x;
 			r.y = -offsetY;
 			r.width = whiteArea.width;
@@ -1366,7 +1368,7 @@
 			rectangles.add(r);
 		}
 		if ((blackArea.y + blackArea.height) &lt;  whiteArea.y + whiteArea.height) {
-			Rect r= new Rect ();
+			final Rect r= new Rect ();
 			r.x = whiteArea.x;
 			r.y = blackArea.y + blackArea.height;
 			r.width = whiteArea.width;
@@ -1374,7 +1376,7 @@
 			rectangles.add(r);
 		}
 		if ((blackArea.x + blackArea.width)&lt;  whiteArea.x + whiteArea.width) {
-			Rect r= new Rect ();
+			final Rect r= new Rect ();
 			r.x = blackArea.x + blackArea.width;
 			r.y = whiteArea.y;
 			r.width = (whiteArea.x + whiteArea.width) - r.x;
@@ -1385,7 +1387,7 @@
 
 	public void updateGps(int fix) {
 		if (!running || ignoreGps) return;
-		// runMovingMap neccessary in case of multi-threaded Java-VM: 
+		// runMovingMap neccessary in case of multi-threaded Java-VM:
 		// ticked could be called during load of mmp
 		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
 			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
@@ -1435,10 +1437,10 @@
 	public void setBestMap(CWPoint where, boolean loadIfSameScale) {
 		if (inBestMap) return;
 		inBestMap = true;
-		Object [] s = getRectForMapChange(where);
-		CWPoint cll = (CWPoint) s[0];
-		Rect screen = (Rect) s[1];
-		boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
+		final Object [] s = getRectForMapChange(where);
+		final CWPoint cll = (CWPoint) s[0];
+		final Rect screen = (Rect) s[1];
+		final boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
 		MapInfoObject newmap = null;
 		wantMapTest = true;
 		switch (mapChangeModus) {
@@ -1491,7 +1493,7 @@
 			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
 			try {
 				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
-			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec(); }
+			} catch (final IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec(); }
 			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
 				mmp.chooseMap(); // force the user to select a scale
 				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
@@ -1520,8 +1522,8 @@
 	 * @return
 	 */
 	public Object[] getRectForMapChange(CWPoint ll) {
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
+		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
 		int pX, pY;
 		CWPoint cll;
 		Boolean posCircleOnScreen = java.lang.Boolean.FALSE;
@@ -1535,7 +1537,7 @@
 			pX = w/2;
 			pY = h/2;
 		}
-		Object[] ret = new Object[3];
+		final Object[] ret = new Object[3];
 		ret[0] = cll;
 		ret[1] = new Rect(pX, pY, w, h);
 		ret[2] = posCircleOnScreen;
@@ -1548,9 +1550,9 @@
 	 * @return
 	 */
 	public void loadMoreDetailedMap(boolean betterOverview){
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
-		Rect screen = new Rect(w/2, h/2, w, h);
+		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
+		final Rect screen = new Rect(w/2, h/2, w, h);
 
 		CWPoint cll;
 		if (currentMap != null) {
@@ -1559,9 +1561,9 @@
 			cll = new CWPoint(posCircle.where);
 		}
 
-		MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale * currentMap.zoomFactor, !betterOverview);
+		final MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale * currentMap.zoomFactor, !betterOverview);
 		if (m != null) {
-			boolean saveGpsIgnStatus = dontUpdatePos;
+			final boolean saveGpsIgnStatus = dontUpdatePos;
 			dontUpdatePos = true;
 			setMap(m, cll);
 			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
@@ -1577,31 +1579,31 @@
 	}
 
 	public void loadMapForAllCaches(){
-		Area sur = Global.getProfile().getSourroundingArea(true);
+		final Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
 			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#239;&#191;&#189;ckchen ausgew&#239;&#191;&#189;hlt&quot;), FormBase.OKB)).execute();
 			return;
 		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.bottomright);
 		if (newmap == null ) { // no map that includs all caches is available -&gt; load map with lowest resolution
-			Object [] s = getRectForMapChange(posCircle.where);
-			CWPoint cll = (CWPoint) s[0];
-			Rect screen = (Rect) s[1];
+			final Object [] s = getRectForMapChange(posCircle.where);
+			final CWPoint cll = (CWPoint) s[0];
+			final Rect screen = (Rect) s[1];
 			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false,true);
 		}
 		if (newmap == null) { // no map is covering any area of the caches -&gt; zoom an empty map to cover all caches on screen
 			try {
-				Object [] s = getRectForMapChange(posCircle.where);
+				final Object [] s = getRectForMapChange(posCircle.where);
 			//	CWPoint cll = (CWPoint) s[0];
-				Rect screen = (Rect) s[1];
-				float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
-				float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
+				final Rect screen = (Rect) s[1];
+				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
+				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
 				newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
 				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex &gt; neededscaley ? neededscalex : neededscaley), 0, 0);
 				forceMapLoad = true;
-			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec(); }
+			} catch (final IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec(); }
 		}
-		boolean saveGpsIgnStatus = dontUpdatePos;
+		final boolean saveGpsIgnStatus = dontUpdatePos;
 		dontUpdatePos = true;
 		setMap(newmap, posCircle.where);
 		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
@@ -1647,7 +1649,7 @@
 			updateOnlyPosition(where, true);
 			return;
 		}
-		try {			
+		try {
 			Vm.showWait(true);
 			boolean saveIgnoreStatus;
 			saveIgnoreStatus = dontUpdatePos;
@@ -1657,18 +1659,18 @@
 				this.currentMap = newmap;
 				this.title = currentMap.mapName;
 				// neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-				lastCompareX = Integer.MAX_VALUE; 
+				lastCompareX = Integer.MAX_VALUE;
 				lastCompareY = Integer.MAX_VALUE;
 				if (mmp.mapImage != null ) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free(); 
-					mmp.mapImage = null; 
+					mmp.removeImage(mmp.mapImage);
+					mmp.mapImage.free();
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 					// calls the garbage collection
-					Vm.getUsedMemory(true); 
-				} 
+					Vm.getUsedMemory(true);
+				}
 				// give memory free before loading the new map to avoid out of memory error
-				String ImageFilename = currentMap.getImageFilename();
+				final String ImageFilename = currentMap.getImageFilename();
 				if (ImageFilename == null ) {
 					mmp.mapImage = new MapImage();
 					maps.remove(currentMap);
@@ -1678,7 +1680,7 @@
 					if (ImageFilename.length() &gt; 0) {
 						// attention: when running in native java-vm,
 						// no exception will be thrown, not even OutOfMemeoryError
-						mmp.mapImage = new MapImage(ImageFilename); 
+						mmp.mapImage = new MapImage(ImageFilename);
 					}
 					else mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
 				}
@@ -1694,28 +1696,28 @@
 				forceMapLoad = false;
 				directionArrows.setMap(currentMap);
 				updateScale();
-				// this doesn't work in a ticked-thread in the ewe-vm. 
+				// this doesn't work in a ticked-thread in the ewe-vm.
 				// That's why i made a new mThread in gotoPanel for ticked
 				dontUpdatePos = saveIgnoreStatus;
-			} catch (IllegalArgumentException e) { 
+			} catch (final IllegalArgumentException e) {
 				// thrown by new AniImage() in ewe-vm if file not found;
 				pref.log(&quot;[MovingMap:setMap]IllegalArgumentException&quot;,e,true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
 				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;)+ newmap.getImageFilename(), FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
-			} catch (OutOfMemoryError e) {
+			} catch (final OutOfMemoryError e) {
 				pref.log(&quot;[MovingMap:setMap]OutOfMemoryError&quot;,e,true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
@@ -1725,12 +1727,12 @@
 						+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
 						FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
-			}catch (SystemResourceException e) {
+			}catch (final SystemResourceException e) {
 				pref.log(&quot;[MovingMap:setMap]SystemResourceException&quot;,e,true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
@@ -1751,21 +1753,21 @@
 		if (!posCircle.where.isValid()) {
 			posCircle.where.set(newCenter);
 		}
-		Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
-		Point centerOnMap = currentMap.calcMapXY(newCenter);
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
-		int mapPosX = w/2 - centerOnMap.x;
-		int mapPosY = h/2 - centerOnMap.y;
-		int newPosCircleX = mapPosX + circlePosOnMap.x;
-		int newPosCircleY = mapPosY + circlePosOnMap.y;
+		final Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
+		final Point centerOnMap = currentMap.calcMapXY(newCenter);
+		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
+		final int mapPosX = w/2 - centerOnMap.x;
+		final int mapPosY = h/2 - centerOnMap.y;
+		final int newPosCircleX = mapPosX + circlePosOnMap.x;
+		final int newPosCircleY = mapPosY + circlePosOnMap.y;
 
 		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
 
-		int wCircle = posCircle.getWidth();
-		int hCircle = posCircle.getHeight();
-		int npx = newPosCircleX-wCircle/2;
-		int npy = newPosCircleY-hCircle/2;
+		final int wCircle = posCircle.getWidth();
+		final int hCircle = posCircle.getHeight();
+		final int npx = newPosCircleX-wCircle/2;
+		final int npy = newPosCircleY-hCircle/2;
 		posCircle.move(npx, npy);
 		posCircleX = newPosCircleX;
 		posCircleY = newPosCircleY;
@@ -1776,8 +1778,8 @@
 	public void hideMap() {
 		if (mmp != null &amp;&amp; mmp.mapImage != null)
 			mmp.mapImage.hide();
-		for(Iterator i=mmp.images.iterator(); i.hasNext ();){
-			AniImage image = (AniImage) i.next();
+		for(final Iterator i=mmp.images.iterator(); i.hasNext ();){
+			final AniImage image = (AniImage) i.next();
 			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)){
 				((MapImage) image).hide();
 			}
@@ -1789,8 +1791,8 @@
 	public void showMap() {
 		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.unhide();
 		mapHidden = false;
-		for(Iterator i=mmp.images.iterator(); i.hasNext ();){
-			AniImage image = (AniImage) i.next();
+		for(final Iterator i=mmp.images.iterator(); i.hasNext ();){
+			final AniImage image = (AniImage) i.next();
 			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)){
 				((MapImage) image).unhide();
 			}
@@ -1812,7 +1814,7 @@
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
 		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
 		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
-		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
 		float zoomFactor;
 		if (h &lt; 0) {
 			h = java.lang.Math.abs(h);
@@ -1829,10 +1831,10 @@
 		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
 		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
-		Point mappos = getMapPositionOnScreen();
-		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+		final Point mappos = getMapPositionOnScreen();
+		final int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+		final int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
+		final Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
 		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
 		{
 			// try to avoid overlapping by shifting
@@ -1863,7 +1865,7 @@
 	}
 
 	public void zoomout() {
-		CWPoint center = currentMap.center;
+		final CWPoint center = currentMap.center;
 		float zoomfactor = currentMap.zoomFactor / 2;
 		if (zoomfactor &lt; 1) {
 			zoomfactor = 1;
@@ -1880,7 +1882,7 @@
 	}
 
 	public void zoom1to1() {
-		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+		final CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
 		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
 		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
 	}
@@ -1893,7 +1895,7 @@
 	 */
 	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
 		Vm.showWait(this, true);
-		boolean savegpsstatus = dontUpdatePos;
+		final boolean savegpsstatus = dontUpdatePos;
 		if (mapImage1to1 != null) {
 			dontUpdatePos = true; // avoid multi-thread problems
 			int saveprop = mImage.IsMoveable;
@@ -1912,7 +1914,7 @@
 				if (zoomFactor == 1) tmp = mapImage1to1;
 				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-			} catch (OutOfMemoryError e) {
+			} catch (final OutOfMemoryError e) {
 				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;),
 						MyLocale.getMsg(4222, &quot;Out of memory error&quot;), FormBase.OKB)).execute();
 				//tmp = mapImage1to1;
@@ -1925,7 +1927,7 @@
 			mmp.images.moveToBack(mmp.mapImage);
 			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
 			{
-				Point mappos = getMapPositionOnScreen();
+				final Point mappos = getMapPositionOnScreen();
 				mmp.mapImage.move(mappos.x,mappos.y);
 			}
 		} else // no map image loaded
@@ -1957,18 +1959,18 @@
 	}
 
 	public boolean handleCommand(int actionCommand) {
-		if (CLOSE == actionCommand) {			
-			WindowEvent tmp = new WindowEvent();
+		if (CLOSE == actionCommand) {
+			final WindowEvent tmp = new WindowEvent();
 			tmp.type = WindowEvent.CLOSE;
 			postEvent(tmp);
 			return true;
-		} 
+		}
 		if (SELECT_MAP == actionCommand) {
 			mmp.chooseMap();
 			return true;
 		}
 		if (CHANGE_MAP_DIR == actionCommand) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
+			final FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 			fc.addMask(&quot;*.wfl&quot;);
 			fc.setTitle(MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
 			if(fc.execute() != FormBase.IDCANCEL){
@@ -2074,12 +2076,12 @@
 		return mapHidden;
 	}
 
-	
+
 	public void setPaintPosDestLine(boolean paintPosDestLine) {
 		this.paintPosDestLine = paintPosDestLine;
 	}
-	
-	
+
+
 }
 
 /**
@@ -2099,13 +2101,13 @@
 	Point saveMapLoc = null;
 	boolean saveGpsIgnoreStatus;
 	boolean paintingZoomArea;
-	
+
 	ImageList saveImageList = null;
 	int lastZoomWidth , lastZoomHeight;
-	
+
 	boolean ignoreNextDrag=false;
 	boolean onlyIfCache=false;
-	
+
 	public MovingMapPanel(MovingMap f){
 		this.mm = f;
 		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
@@ -2124,7 +2126,7 @@
 		}
 		if (mm.getControlsLayer().imageBeginDragged(which, pos)) {
 			return false;
-		}			
+		}
 		// move (drag) map
 		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.dontUpdatePos;
@@ -2136,7 +2138,7 @@
 	}
 
 	public boolean imageNotDragged(ImageDragContext dc,Point pos){
-		boolean ret = super.imageNotDragged(dc, pos);
+		final boolean ret = super.imageNotDragged(dc, pos);
 		bringMaptoBack();
 		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
@@ -2186,10 +2188,10 @@
 					}
 					mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 				}
-				if (paintingZoomArea &amp;&amp; 
+				if (paintingZoomArea &amp;&amp;
 					(ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
 					int left, top;
-					Graphics dr = this.getGraphics();
+					final Graphics dr = this.getGraphics();
 					if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
 					else left = saveMapLoc.x;
 					if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
@@ -2247,7 +2249,7 @@
 	public void doPaint(Graphics g,Rect area) {
 		super.doPaint(g, area);
 		if (mm.gotoPos != null &amp;&amp; mm.paintPosDestLine) {
-			Point dest = mm.getXYonScreen(mm.gotoPos.where);
+			final Point dest = mm.getXYonScreen(mm.gotoPos.where);
 			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
 		}
@@ -2257,7 +2259,7 @@
 		CWPoint gpspos;
 		if (mm.myNavigation.gpsPos.Fix &gt; 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
 		else gpspos = null;
-		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
+		final ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
 		if(l.execute() == FormBase.IDOK){
 			mm.autoSelectMap = false;
 			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length()==0) {
@@ -2296,7 +2298,7 @@
 				kontextMenu.addItem(newWayPointMenuItem);
 				kontextMenu.addItem(new MenuItem(&quot;-&quot;));
 			}
-			AniImage clickedOnImage = images.findHotImage(p);
+			final AniImage clickedOnImage = images.findHotImage(p);
 			if (clickedOnImage != null &amp;&amp; clickedOnImage instanceof MapSymbol) {
 				if ( ((MapSymbol)clickedOnImage).mapObject instanceof CacheHolder) {
 					clickedCache = (CacheHolder)( ((MapSymbol)clickedOnImage).mapObject);
@@ -2306,7 +2308,7 @@
 						kontextMenu.addItem(openCacheDescMenuItem);
 						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, &quot;Open Details&quot;)+&quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$e&quot;);
 						kontextMenu.addItem(openCacheDetailMenuItem);
-						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, &quot;Goto&quot;)+ &quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$g&quot;); 
+						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, &quot;Goto&quot;)+ &quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$g&quot;);
 						kontextMenu.addItem(gotoCacheMenuItem);
 						if (Global.mainForm.cacheListVisible) {
 							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,&quot;Add to cachetour&quot;));
@@ -2320,7 +2322,7 @@
 						if (clickedCache.getType() == CacheType.CW_TYPE_QUESTION) {
 							stmp=clickedCache.getCacheDetails(false).LongDescription;
 							if (!stmp.equals(&quot;&quot;)) {
-								kontextMenu.addItem(missionMenuItem=new MenuItem(&quot;?: &quot;));								
+								kontextMenu.addItem(missionMenuItem=new MenuItem(&quot;?: &quot;));
 							}
 						}
 						kontextMenu.addItem(new MenuItem(&quot;-&quot;));
@@ -2333,7 +2335,7 @@
 			}
 			/*
 			 *  this kontext will be replaced by the settings of the rose in the goto panel
-			 *    
+			 *
 			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
 			}
 			else {
@@ -2351,11 +2353,11 @@
 			else kontextMenu=null;
 		}
 	}
-	
+
 	public boolean imageMovedOn(AniImage which) {
 		if (which instanceof MapSymbol) {
 			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
-				CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
+				final CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
 				this.toolTip=ch.getWayPoint()+&quot;\n&quot;
 							+ ch.cacheName+&quot;\n&quot;
 							+ &quot;Difficulty: &quot;+CacheTerrDiff.longDT(ch.getHard())+&quot;\n&quot;
@@ -2379,27 +2381,27 @@
 
 	public void onEvent(Event ev){
 		// nothing selected in kontext
-		if (kontextMenu != null 
-				&amp;&amp; ev instanceof PenEvent 
-				&amp;&amp; ev.type == PenEvent.PEN_DOWN 
+		if (kontextMenu != null
+				&amp;&amp; ev instanceof PenEvent
+				&amp;&amp; ev.type == PenEvent.PEN_DOWN
 				&amp;&amp; ev.target == this) {
-			kontextMenu.close(); 
-			kontextMenu = null; 
+			kontextMenu.close();
+			kontextMenu = null;
 			return;
 		}
 		// something selected
 		if (ev instanceof MenuEvent) {
 			if (ev.target == kontextMenu) {
 				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
-					MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
+					final MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
 					if (action == gotoMenuItem) {
 						closeKontextMenu();
 						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 					}
 					if (action == openCacheDescMenuItem || action == openCacheDetailMenuItem) {
 						leaveMovingMap();
-						MainTab mainT = Global.mainTab;
-						if (action == openCacheDescMenuItem) 
+						final MainTab mainT = Global.mainTab;
+						if (action == openCacheDescMenuItem)
 							mainT.openPanel(clickedCache,2);
 						else
 							mainT.openPanel(clickedCache,1);
@@ -2410,7 +2412,7 @@
 					}
 					if (action == newWayPointMenuItem) {
 						leaveMovingMap();
-						CacheHolder newWP = new CacheHolder();
+						final CacheHolder newWP = new CacheHolder();
 						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
 						newWP.setLatLon(newWP.pos.toString());
 						Global.mainTab.newWaypoint(newWP);
@@ -2444,7 +2446,7 @@
 	private void closeKontextMenu() {
 		kontextMenu.close();
 		// for not to do an additional klick (before reacting on klicks)
-		PenEvent pev = new PenEvent();
+		final PenEvent pev = new PenEvent();
 		pev.target=this;
 		pev.type=PenEvent.PEN_DOWN;
 		this.postEvent(pev);
@@ -2453,10 +2455,10 @@
 	}
 	private void leaveMovingMap() {
 		closeKontextMenu();
-		WindowEvent close = new WindowEvent();
+		final WindowEvent close = new WindowEvent();
 		close.target = this;
 		close.type = WindowEvent.CLOSE;
-		this.postEvent(close);		
+		this.postEvent(close);
 	}
 }
 
@@ -2481,7 +2483,7 @@
 		String cmp;
 		int oldmap = -1;
 		boolean curMapFound = false;
-		boolean[] inList = new boolean[maps.size()];
+		final boolean[] inList = new boolean[maps.size()];
 		int row = -1;
 		if (curMap == null) curMapFound = true;
 		if (gotopos != null &amp;&amp; Gps != null) {
@@ -2493,7 +2495,7 @@
 				try {
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
 					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
+				} catch (final IOException ex) {continue; } // could not read .wfl-file
 				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) )
 				{
 					list.addItem(i + &quot;: &quot; + map.mapName);
@@ -2515,7 +2517,7 @@
 				try {
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
 					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
+				} catch (final IOException ex) {continue; } // could not read .wfl-file
 				if( map.isInBound(Gps.latDec, Gps.lonDec) )
 				{
 					list.addItem(i + &quot;: &quot; + map.mapName);
@@ -2537,7 +2539,7 @@
 				try {
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
 					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
+				} catch (final IOException ex) {continue; } // could not read .wfl-file
 				if(map.isInBound(gotopos)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
@@ -2585,7 +2587,7 @@
 				selectedMap = ((MapListEntry)maps.get(mapNum)).getMap();
 				selected = true;
 				this.close(FormBase.IDOK);
-				} catch (IOException e) {
+				} catch (final IOException e) {
 					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;)
 							+ ((MapListEntry)maps.get(mapNum)).filename, FormBase.OKB)).execute();
 				}
@@ -2594,7 +2596,7 @@
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-		}catch (NegativeArraySizeException e) {
+		}catch (final NegativeArraySizeException e) {
 			// happens in substring when a dividing line selected
 		}
 	}
@@ -2757,7 +2759,7 @@
 		if (map == null) return;
 
 		float angleRad;
-		int centerX = location.width/2, centerY = location.height/2;
+		final int centerX = location.width/2, centerY = location.height/2;
 		if (arrow[0] == null) arrow[0] = new Point();
 		if (arrow[1] == null) arrow[1] = new Point();
 		arrow[0].x = centerX;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002969.html">[Cachewolf-svn] r2978 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="002971.html">[Cachewolf-svn] r2980 - trunk/res_noewe/webmapservices
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2970">[ date ]</a>
              <a href="thread.html#2970">[ thread ]</a>
              <a href="subject.html#2970">[ subject ]</a>
              <a href="author.html#2970">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
