From araber95 at mail.berlios.de  Wed Apr  1 19:03:15 2009
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 1 Apr 2009 19:03:15 +0200
Subject: [Cachewolf-svn] r1733 - trunk/res_noewe/webmapservices
Message-ID: <200904011703.n31H3FUW029452@sheep.berlios.de>

Author: araber95
Date: 2009-04-01 19:03:06 +0200 (Wed, 01 Apr 2009)
New Revision: 1733

Added:
   trunk/res_noewe/webmapservices/de-sn_t10.wms
   trunk/res_noewe/webmapservices/de-sn_t25.wms
   trunk/res_noewe/webmapservices/de-sn_t50.wms
Removed:
   trunk/res_noewe/webmapservices/de-sn_photo.wms
   trunk/res_noewe/webmapservices/de-sn_topo_10.wms
   trunk/res_noewe/webmapservices/de-sn_topo_25.wms
   trunk/res_noewe/webmapservices/de-sn_topo_50.wms
Modified:
   trunk/res_noewe/webmapservices/de-sn_p.wms
Log:
using the new address of the Sachsen wms-server. Adjunsting skaling.

Modified: trunk/res_noewe/webmapservices/de-sn_p.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_p.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_p.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -1,19 +1,33 @@
-TakenFromUrl:	http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten
-GetCapabilitiesUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVDOPFREE/WMSFREE_TK/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities&VERSION=1.1.0&SERVICE=WMS
-Name:	de.Sachsen photo
+TakenFromUrl:   http://www.landesvermessung.sachsen.de/inhalt/geo/basis/basis_dienste.html
+GetCapabilitiesUrl: http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4DOPFREE/WMSFREE_TK/wmsservice?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:	de.Sachsen photo SF 0,1..247
 MapType:	photo
-MainUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVDOPFREE/WMSFREE_TK/WMSFREE_TK/wmsservice?
-ServiceTypeUrlPart:	SERVICE=WMS 
-VersionUrlPart:	VERSION=1.1.1 
+MainUrl:            http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4DOPFREE/WMSFREE_TK/wmsservice?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf: 31468 
 CoordinateReferenceSystemUrlPart:	SRS=EPSG:31468
-RequestUrlPart:	REQUEST=GetMap
-LayersUrlPart:	LAYERS=c
-StylesUrlPart:	STYLES=
-ImageFormatUrlPart:	FORMAT=image/png
-BoundingBoxTopLeftWGS84:	N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84:	N 50.0294 E 15.1358
-MinScale:	0.65
-MaxScale:	4.98853
-RecommendedScale:	1
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=MS|Luftbilder||
+#LayersUrlPart:     LAYERS=bw|Graustufen||
+#LayersUrlPart:     LAYERS=ortho|Sachsen 1999-2004|0.000498903|0.0498903
+#LayersUrlPart:     LAYERS=ortho_pan06|Sachsen 2006-2008|0.000498903|4.98853
+#LayersUrlPart:     LAYERS=ortho_flut|Flut 2002|0.000498903|0.0498903
+#LayersUrlPart:     LAYERS=ir|Farbe (infrarot)||
+#LayersUrlPart:     LAYERS=ortho_cir06|Sachsen 2006-2008|0.000498903|4.98853
+#LayersUrlPart:     LAYERS=c|Farbe (RGB)||
+#LayersUrlPart:     LAYERS=ortho_color|Mittelsachsen 2002|0.000498903|0.0498903
+#LayersUrlPart:     LAYERS=ortho_rgb06_lowres|Sachsen 2006-2008 LowRes|4.98853|4989.03
+#LayersUrlPart:     LAYERS=ortho_rgb06|Sachsen 2006-2008|0.000498903|4.98853
+#LayersUrlPart:	LAYERS=c
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/png
+BoundingBoxTopLeftWGS84:	N 51.85920 E 011.76510
+BoundingBoxButtomRightWGS84:	N 50.02940 E 015.13580
+MinScale:   0.13
+MaxScale:   350
+RecommendedScale:   1
 ImageFileExtension: .png
+#Karten teils ausserhalb Sachsens werden weiss oder nicht bedient (Verweis auf BBox)
+#Skalierung 0,1 bis 247  : 240(340/1,414) erfasst ganz Sachsen
+#LayersUrlPart:     LAYERS=MS geht auch (wie c), andere nicht getestet

Deleted: trunk/res_noewe/webmapservices/de-sn_photo.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_photo.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_photo.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -1,20 +0,0 @@
-# please refere to readme_wms.txt for an explantion of this file format
-TakenFromUrl:	http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten
-GetCapabilitiesUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVDOPFREE/WMSFREE_TK/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities&VERSION=1.1.0&SERVICE=WMS
-Name:	de.sn Luftbild
-MapType:	photo
-MainUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVDOPFREE/WMSFREE_TK/WMSFREE_TK/wmsservice?
-ServiceTypeUrlPart:	SERVICE=WMS 
-VersionUrlPart:	VERSION=1.1.1 
-CoordinateReferenceSystemCacheWolf: 31468 
-CoordinateReferenceSystemUrlPart:	SRS=EPSG:31468
-RequestUrlPart:	REQUEST=GetMap
-LayersUrlPart:	LAYERS=c
-StylesUrlPart:	STYLES=
-ImageFormatUrlPart:	FORMAT=image/png
-BoundingBoxTopLeftWGS84:	N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84:	N 50.0294 E 15.1358
-MinScale:	0.65
-MaxScale:	4.98853
-RecommendedScale:	0.5
-ImageFileExtension: .png

Added: trunk/res_noewe/webmapservices/de-sn_t10.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_t10.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_t10.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -0,0 +1,44 @@
+TakenFromUrl:   http://www.landesvermessung.sachsen.de/inhalt/geo/basis/basis_dienste.html
+GetCapabilitiesUrl:   http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4TKFREE/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities
+Name:	de.Sachsen topo 10 SF 0,038..1,76
+MapType:   topo
+MainUrl:   http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4TKFREE/WMSFREE_TK/wmsservice?
+ServiceTypeUrlPart:   SERVICE=WMS 
+VersionUrlPart:   VERSION=1.1.1 
+CoordinateReferenceSystemCacheWolf: 31468 
+CoordinateReferenceSystemUrlPart:   SRS=EPSG:31468
+RequestUrlPart:   REQUEST=GetMap
+#LayersUrlPart:     LAYERS=MS|Topogr. Karten||
+#LayersUrlPart:     LAYERS=UEB|Uebersicht|62.3629|1247.26
+#LayersUrlPart:     LAYERS=TK100|TK 100||
+#LayersUrlPart:     LAYERS=tk100v|TK 100 - Vegetation|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100i|TK 100 - Hoehenlinien|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100w|TK 100 - Gewaesser|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100g|TK 100 - Grundriss|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100s|TK 100 - Schriften|12.4726|62.3629
+#LayersUrlPart:     LAYERS=TK50|TK 50||
+#LayersUrlPart:     LAYERS=tk50v|TK 50 - Vegetation|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50i|TK 50 - Hoehenlinien|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50w|TK 50 - Gewaesser|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50g|TK 50 - Grundriss|4.98903|12.4726
+#LayersUrlPart:     LAYERS=TK25|TK 25||
+#LayersUrlPart:     LAYERS=tk25v|TK 25 - Vegetation|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25i|TK 25 - Hoehenlinien|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25w|TK 25 - Gewaesser|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25g|TK 25 - Grundriss|2.49451|4.98903
+#LayersUrlPart:     LAYERS=TK10|TK 10||
+#LayersUrlPart:     LAYERS=tk10v|TK 10 - Vegetation|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10i|TK 10 - Hoehenlinien|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10w|TK 10 - Gewaesser|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10g|TK 10 - Grundriss|0.0503892|2.49451
+LayersUrlPart:	LAYERS=TK10
+#LayersUrlPart:   LAYERS=tk10v,tk10i,tk10g,tk10w
+StylesUrlPart:   STYLES=
+ImageFormatUrlPart:   FORMAT=image/png
+BoundingBoxTopLeftWGS84:   N 51.8592 E 11.7651
+BoundingBoxButtomRightWGS84:   N 50.0294 E 15.1358
+MinScale:   0.0503892
+MaxScale:   2.49451
+RecommendedScale:   1.0
+ImageFileExtension: .png
+#MinScale 0,0503892 = 0,035630545018565180516539026730974 Praktisch aber 0,038 da CW noch mal was runter korrigiert
\ No newline at end of file

Added: trunk/res_noewe/webmapservices/de-sn_t25.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_t25.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_t25.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -0,0 +1,44 @@
+TakenFromUrl:   http://www.landesvermessung.sachsen.de/inhalt/geo/basis/basis_dienste.html
+GetCapabilitiesUrl:   http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4TKFREE/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities
+Name:	de.Sachsen topo 25 SF 1,77..3,52
+MapType:   topo
+MainUrl:   http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4TKFREE/WMSFREE_TK/wmsservice?
+ServiceTypeUrlPart:   SERVICE=WMS 
+VersionUrlPart:   VERSION=1.1.1 
+CoordinateReferenceSystemCacheWolf: 31468 
+CoordinateReferenceSystemUrlPart:   SRS=EPSG:31468
+RequestUrlPart:   REQUEST=GetMap
+#LayersUrlPart:     LAYERS=MS|Topogr. Karten||
+#LayersUrlPart:     LAYERS=UEB|Uebersicht|62.3629|1247.26
+#LayersUrlPart:     LAYERS=TK100|TK 100||
+#LayersUrlPart:     LAYERS=tk100v|TK 100 - Vegetation|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100i|TK 100 - Hoehenlinien|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100w|TK 100 - Gewaesser|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100g|TK 100 - Grundriss|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100s|TK 100 - Schriften|12.4726|62.3629
+#LayersUrlPart:     LAYERS=TK50|TK 50||
+#LayersUrlPart:     LAYERS=tk50v|TK 50 - Vegetation|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50i|TK 50 - Hoehenlinien|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50w|TK 50 - Gewaesser|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50g|TK 50 - Grundriss|4.98903|12.4726
+#LayersUrlPart:     LAYERS=TK25|TK 25||
+#LayersUrlPart:     LAYERS=tk25v|TK 25 - Vegetation|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25i|TK 25 - Hoehenlinien|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25w|TK 25 - Gewaesser|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25g|TK 25 - Grundriss|2.49451|4.98903
+#LayersUrlPart:     LAYERS=TK10|TK 10||
+#LayersUrlPart:     LAYERS=tk10v|TK 10 - Vegetation|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10i|TK 10 - Hoehenlinien|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10w|TK 10 - Gewaesser|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10g|TK 10 - Grundriss|0.0503892|2.49451
+LayersUrlPart:	LAYERS=TK25
+#LayersUrlPart:   LAYERS=tk25,tk25i,tk25g,tk25w
+StylesUrlPart:   STYLES=
+ImageFormatUrlPart:   FORMAT=image/png
+BoundingBoxTopLeftWGS84:   N 51.8592 E 11.7651
+BoundingBoxButtomRightWGS84:   N 50.0294 E 15.1358
+MinScale:   2.49452
+MaxScale:   4.98903
+RecommendedScale:   2.5
+ImageFileExtension: .png
+#MinScale 2,49451 = 1,7638849367376546650931502697142 Praktisch aber 1,77
\ No newline at end of file

Added: trunk/res_noewe/webmapservices/de-sn_t50.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_t50.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_t50.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -0,0 +1,45 @@
+TakenFromUrl:   http://www.landesvermessung.sachsen.de/inhalt/geo/basis/basis_dienste.html
+GetCapabilitiesUrl:   http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4TKFREE/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities
+Name:	de.Sachsen topo 50 SF 3,54..8,82
+MapType:   topo
+MainUrl:   http://www.landesvermessung.sachsen.de/ias/basiskarte4/service/SRV4TKFREE/WMSFREE_TK/wmsservice?
+ServiceTypeUrlPart:   SERVICE=WMS 
+VersionUrlPart:   VERSION=1.1.1 
+CoordinateReferenceSystemCacheWolf: 31468 
+CoordinateReferenceSystemUrlPart:   SRS=EPSG:31468
+RequestUrlPart:   REQUEST=GetMap
+#LayersUrlPart:     LAYERS=MS|Topogr. Karten||
+#LayersUrlPart:     LAYERS=UEB|Uebersicht|62.3629|1247.26
+#LayersUrlPart:     LAYERS=TK100|TK 100||
+#LayersUrlPart:     LAYERS=tk100v|TK 100 - Vegetation|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100i|TK 100 - Hoehenlinien|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100w|TK 100 - Gewaesser|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100g|TK 100 - Grundriss|12.4726|62.3629
+#LayersUrlPart:     LAYERS=tk100s|TK 100 - Schriften|12.4726|62.3629
+#LayersUrlPart:     LAYERS=TK50|TK 50||
+#LayersUrlPart:     LAYERS=tk50v|TK 50 - Vegetation|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50i|TK 50 - Hoehenlinien|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50w|TK 50 - Gewaesser|4.98903|12.4726
+#LayersUrlPart:     LAYERS=tk50g|TK 50 - Grundriss|4.98903|12.4726
+#LayersUrlPart:     LAYERS=TK25|TK 25||
+#LayersUrlPart:     LAYERS=tk25v|TK 25 - Vegetation|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25i|TK 25 - Hoehenlinien|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25w|TK 25 - Gewaesser|2.49451|4.98903
+#LayersUrlPart:     LAYERS=tk25g|TK 25 - Grundriss|2.49451|4.98903
+#LayersUrlPart:     LAYERS=TK10|TK 10||
+#LayersUrlPart:     LAYERS=tk10v|TK 10 - Vegetation|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10i|TK 10 - Hoehenlinien|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10w|TK 10 - Gewaesser|0.0503892|2.49451
+#LayersUrlPart:     LAYERS=tk10g|TK 10 - Grundriss|0.0503892|2.49451
+LayersUrlPart:	LAYERS=TK50
+#LayersUrlPart:   LAYERS=tk50,tk50i,tk50g,tk50w
+StylesUrlPart:   STYLES=
+ImageFormatUrlPart:   FORMAT=image/png
+BoundingBoxTopLeftWGS84:   N 51.8592 E 11.7651
+BoundingBoxButtomRightWGS84:   N 50.0294 E 15.1358
+MinScale:   4.9
+MaxScale:   13
+RecommendedScale:   5
+ImageFileExtension: .png
+#MinScale 4.98903 = 3.527776944543121195661544547872 Praktisch aber 3.53
+#MaxScale 12,4726 = 8,8194600390273326528419713907889
\ No newline at end of file

Deleted: trunk/res_noewe/webmapservices/de-sn_topo_10.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_topo_10.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_topo_10.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -1,19 +0,0 @@
-TakenFromUrl:	http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten
-GetCapabilitiesUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVTKFREE/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities&VERSION=1.1.0&SERVICE=WMS
-Name:	de.Sachsen topo 10
-MapType:	topo
-MainUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVTKFREE/WMSFREE_TK/wmsservice?
-ServiceTypeUrlPart:	SERVICE=WMS 
-VersionUrlPart:	VERSION=1.1.1 
-CoordinateReferenceSystemCacheWolf: 31468 
-CoordinateReferenceSystemUrlPart:	SRS=EPSG:31468
-RequestUrlPart:	REQUEST=GetMap
-LayersUrlPart:	LAYERS=TK10
-StylesUrlPart:	STYLES=
-ImageFormatUrlPart:	FORMAT=image/png
-BoundingBoxTopLeftWGS84:	N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84:	N 50.0294 E 15.1358
-MinScale:	0.0503892
-MaxScale:	2.49451
-RecommendedScale:	1.0
-ImageFileExtension: .png

Deleted: trunk/res_noewe/webmapservices/de-sn_topo_25.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_topo_25.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_topo_25.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -1,19 +0,0 @@
-TakenFromUrl:	http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten
-GetCapabilitiesUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVTKFREE/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities&VERSION=1.1.0&SERVICE=WMS
-Name:	de.Sachsen topo 25
-MapType:	topo
-MainUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVTKFREE/WMSFREE_TK/wmsservice?
-ServiceTypeUrlPart:	SERVICE=WMS 
-VersionUrlPart:	VERSION=1.1.1 
-CoordinateReferenceSystemCacheWolf: 31468 
-CoordinateReferenceSystemUrlPart:	SRS=EPSG:31468
-RequestUrlPart:	REQUEST=GetMap
-LayersUrlPart:	LAYERS=TK25
-StylesUrlPart:	STYLES=
-ImageFormatUrlPart:	FORMAT=image/png
-BoundingBoxTopLeftWGS84:	N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84:	N 50.0294 E 15.1358
-MinScale:	2.49451
-MaxScale:	4.98903
-RecommendedScale:	2.5
-ImageFileExtension: .png

Deleted: trunk/res_noewe/webmapservices/de-sn_topo_50.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_topo_50.wms	2009-03-30 11:40:42 UTC (rev 1732)
+++ trunk/res_noewe/webmapservices/de-sn_topo_50.wms	2009-04-01 17:03:06 UTC (rev 1733)
@@ -1,19 +0,0 @@
-TakenFromUrl:	http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten
-GetCapabilitiesUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVTKFREE/WMSFREE_TK/wmsservice?REQUEST=GetCapabilities&VERSION=1.1.0&SERVICE=WMS
-Name:	de.Sachsen topo 50
-MapType:	topo
-MainUrl:	http://www.landesvermessung.sachsen.de/ias/basiskarte/service/SRVTKFREE/WMSFREE_TK/wmsservice?
-ServiceTypeUrlPart:	SERVICE=WMS 
-VersionUrlPart:	VERSION=1.1.1 
-CoordinateReferenceSystemCacheWolf: 31468 
-CoordinateReferenceSystemUrlPart:	SRS=EPSG:31468
-RequestUrlPart:	REQUEST=GetMap
-LayersUrlPart:	LAYERS=TK50
-StylesUrlPart:	STYLES=
-ImageFormatUrlPart:	FORMAT=image/png
-BoundingBoxTopLeftWGS84:	N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84:	N 50.0294 E 15.1358
-MinScale:	4.98903
-MaxScale:	12.4726
-RecommendedScale:	5.0
-ImageFileExtension: .png



From araber95 at mail.berlios.de  Wed Apr  1 19:06:58 2009
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 1 Apr 2009 19:06:58 +0200
Subject: [Cachewolf-svn] r1734 - trunk/src/CacheWolf/navi
Message-ID: <200904011706.n31H6won001420@sheep.berlios.de>

Author: araber95
Date: 2009-04-01 19:06:56 +0200 (Wed, 01 Apr 2009)
New Revision: 1734

Modified:
   trunk/src/CacheWolf/navi/MapLoaderGui.java
Log:
calculation of scale did not reflect comma on input (so scale was 0)

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-01 17:03:06 UTC (rev 1733)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-01 17:06:56 UTC (rev 1734)
@@ -328,7 +328,7 @@
 					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all"))) onlySelected = false;
 					else onlySelected = true;
 					overviewmap = overviewChkBoxPerCache.getState();
-					scale = Convert.toFloat(scaleInputPerCache.getText());
+					scale = (float)CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
 				}
 				if (scale < mapLoader.currentOnlineMapService.minscale || scale > mapLoader.currentOnlineMapService.maxscale) {
 					if (scale < mapLoader.currentOnlineMapService.minscale) {



From admin at berlios.de  Thu Apr  2 20:08:51 2009
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 2 Apr 2009 10:08:51 -0800 (AKDT)
Subject: [Cachewolf-svn] [Bug #15475] exportierte GPX Dateien in MapSource
	nicht lesbar
Message-ID: <200904021808.n32I8pUJ015590@unicorn.berlios.de>

Bug #15475, was updated on 2009-Apr-02 10:08
Here is a current snapshot of the bug.

Project: CacheWolf
Category: Import/Export
Status: Open
Resolution: None
Bug Group: Bug reproduceable
Priority: 5
Submitted by: tester1111
Assigned to : none
Summary: exportierte GPX Dateien in MapSource nicht lesbar

Details: Hallo Entwickler von Cachewolf,

ich habe einige Caches als test.gpx Datei exportiert.
Wenn ich diese test.gpx Datei in MapSource ?ffnen m?chte kommt der Fehler: "test.gpx ist keine zul?ssige MapSourceDatei und konnte nicht ge?ffnet werden."

Ich habe so lange Caches aus der Datei entfernt bis MapSource die Datei wieder akzeptiert hat. Dabei ist mir aufgefallen, das in einem Cache ein ung?ltiges Zeichen (EOT / 04hex) drin stand.

Daraufhin habe ich mir die Seite auf Geocaching.com angesehen und entdeckt, dass in der Cachebeschreibung seltsame Zeichen benutzt wurden.

Der Cache, bei dem dies aufgetreten ist hei?t "New Year's Cache 2008" (GC188DE).

Vielleicht kann man solche Zeichen (wie z.B. EOT) beim Export entfernen.


Gru? Franz

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=15475&group_id=2211


From mik77 at mail.berlios.de  Sat Apr  4 01:36:57 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 4 Apr 2009 01:36:57 +0200
Subject: [Cachewolf-svn] r1735 - trunk/src/CacheWolf
Message-ID: <200904032336.n33NavhQ016861@sheep.berlios.de>

Author: mik77
Date: 2009-04-04 01:36:54 +0200 (Sat, 04 Apr 2009)
New Revision: 1735

Modified:
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
 - save own log in same format as other logs

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2009-04-01 17:06:56 UTC (rev 1734)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2009-04-03 23:36:54 UTC (rev 1735)
@@ -34,7 +34,7 @@
 	  public String URL = EMPTY;
 	  public String Solver = EMPTY;
 	  public String OwnLogId = EMPTY;
-	  public String OwnLogText = EMPTY;
+	  public Log OwnLog = null;
 	  public String Country = EMPTY;
 	  public String State = EMPTY;
 	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
@@ -110,7 +110,7 @@
 		  setCacheLogs(newCh.CacheLogs);
 		  
 		  if (newCh.OwnLogId.length()>0) this.OwnLogId=newCh.OwnLogId;
-		  if (newCh.OwnLogText.length()>0) this.OwnLogText=newCh.OwnLogText;
+		  if (newCh.OwnLog != null) this.OwnLog = newCh.OwnLog;
 		  
 		  if (newCh.Country.length()>0) this.Country=newCh.Country;
 		  if (newCh.State.length()>0) this.State=newCh.State;
@@ -179,7 +179,16 @@
 			ex = new Extractor(dummy, "<OWNLOGID>","</OWNLOGID>", 0, true);
 			OwnLogId = ex.findNext();
 			ex = new Extractor(dummy, "<OWNLOG><![CDATA[", "]]></OWNLOG>", 0, true);
-			OwnLogText = ex.findNext();
+			String ownLogText = ex.findNext();
+			if ( ownLogText.length() > 0 ) {
+				if (ownLogText.indexOf("<img src='") >= 0) {
+					OwnLog = new Log( ownLogText + "]]>" );
+				} else {
+					OwnLog = new Log( "icon_smile.gif", "1900-01-01", Global.getPref().myAlias, ownLogText );
+				}
+			} else {
+				OwnLog = null;
+			}
 			CacheLogs.clear();
 			ex = new Extractor(dummy, "<LOG>","</LOG>", 0, true);
 			
@@ -302,7 +311,11 @@
 				  detfile.print("<HINTS><![CDATA["+Hints+"]]></HINTS>\r\n");
 				  detfile.print("<LOGS>\r\n");
 				  detfile.print("<OWNLOGID>"+OwnLogId+"</OWNLOGID>\r\n");
-				  detfile.print("<OWNLOG><![CDATA["+OwnLogText+"]]></OWNLOG>\r\n");
+				  if ( OwnLog != null ) {
+					  detfile.print("<OWNLOG><![CDATA["+OwnLog.toHtml()+"]]></OWNLOG>\r\n");
+				  } else {
+					  detfile.print("<OWNLOG><![CDATA[]]></OWNLOG>\r\n");
+				  }
 				  for(int i = 0; i < CacheLogs.size(); i++){
 					  detfile.print(CacheLogs.getLog(i).toXML());
 				  }

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-04-01 17:06:56 UTC (rev 1734)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-04-03 23:36:54 UTC (rev 1735)
@@ -272,7 +272,7 @@
 							chD.CacheStatus=logDate;
 							chD.is_found=true;
 							chD.OwnLogId = logId;
-							chD.OwnLogText = logData;
+							chD.OwnLog = new Log(logIcon,logDate,logFinder,logData);
 				}
 				return;
 			}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-04-01 17:06:56 UTC (rev 1734)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-04-03 23:36:54 UTC (rev 1735)
@@ -645,7 +645,7 @@
 						chD.CacheStatus=logDate;
 						chD.is_found=true;
 						chD.OwnLogId = logId;
-						chD.OwnLogText = logData;
+						chD.OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
 			}
 			chD.hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
 			return;

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-01 17:06:56 UTC (rev 1734)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-03 23:36:54 UTC (rev 1735)
@@ -1049,7 +1049,7 @@
 				chD.is_found = true;
 				chD.CacheStatus = d;
 				chD.OwnLogId = logId;
-				chD.OwnLogText = logText;
+				chD.OwnLog = new Log(icon,d,name,logText);
 			}
 			if (nLogs<=MAXLOGS) reslts.add(new Log(icon,d,name,logText));
 
@@ -1063,7 +1063,7 @@
 			exLogId.setSource(singleLog);
 			// We cannot simply stop if we have reached MAXLOGS just in case we are waiting for
 			// a log by our alias that happened earlier.
-			if (nLogs>=MAXLOGS && chD.is_found && (chD.OwnLogId.length() != 0)) break;
+			if (nLogs>=MAXLOGS && chD.is_found && (chD.OwnLogId.length() != 0) && (chD.OwnLog != null) && !(chD.OwnLog.getDate().equals("1900-01-01"))) break;
 		}
 		if (nLogs>MAXLOGS) {
 			reslts.add(Log.maxLog());



From mik77 at mail.berlios.de  Sat Apr  4 02:06:08 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 4 Apr 2009 02:06:08 +0200
Subject: [Cachewolf-svn] r1736 - in trunk/src: CacheWolf exp
Message-ID: <200904040006.n340682R004251@sheep.berlios.de>

Author: mik77
Date: 2009-04-04 02:06:06 +0200 (Sat, 04 Apr 2009)
New Revision: 1736

Modified:
   trunk/src/CacheWolf/Preferences.java
   trunk/src/exp/GPXExporter.java
Log:
- Some (hidden) prefs for export:
<export numberOfLogsToExport="5" exportTravelbugs="true" exportGpxAsMyFinds="true"/>
- country, state, travelbugs, logs added to GPX Exporter
- generate MyFinds GPX when exporting to GPX an Cache is found

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2009-04-03 23:36:54 UTC (rev 1735)
+++ trunk/src/CacheWolf/Preferences.java	2009-04-04 00:06:06 UTC (rev 1736)
@@ -209,6 +209,12 @@
 	public boolean addDetailsToName = false;
 	/** The own GC member ID */
 	public String gcMemberId = "";
+	/** The maximum number of logs to export */
+	public int numberOfLogsToExport = 5;
+	/** Add Travelbugs when exporting */
+	public boolean exportTravelbugs = true;
+	/** Try to make a MyFinds GPX when exporting to GPX */
+	public boolean exportGpxAsMyFinds = true;
 
 	//////////////////////////////////////////////
 	/** The debug switch (Can be used to activate dormant code) by adding
@@ -397,6 +403,14 @@
 				metricSystem = Metrics.METRIC;
 			}
 		}
+		else if (name.equals("export")) {
+			tmp = atts.getValue("numberOfLogsToExport");
+			if (tmp != null) numberOfLogsToExport=Convert.parseInt(tmp);
+			tmp = atts.getValue("exportTravelbugs");
+			if (tmp != null) exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
+			tmp = atts.getValue("exportGpxAsMyFinds");
+			if (tmp != null) exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
+		}
 		else if (name.equals("locale")) {
 			language = atts.getValue("language");
 		}
@@ -460,6 +474,7 @@
 			outp.print("    <gotopanel northcentered=\"" + SafeXML.strxmlencode(northCenteredGoto) + "\" />\n");
 			outp.print("    <details cacheSize=\"" + SafeXML.strxmlencode(maxDetails) + "\" delete=\"" + SafeXML.strxmlencode(deleteDetails) + "\"/>\n");
 			outp.print("    <metric type=\"" + SafeXML.strxmlencode(metricSystem) + "\"/>\n");
+			outp.print("    <export numberOfLogsToExport=\"" + SafeXML.strxmlencode(numberOfLogsToExport) + "\" exportTravelbugs=\"" + SafeXML.strxmlencode(exportTravelbugs) + "\" exportGpxAsMyFinds=\"" + SafeXML.strxmlencode(exportGpxAsMyFinds) + "\"/>\n");
 			if (customMapsPath!=null) outp.print("	<mapspath dir = \"" + SafeXML.strxmlencode(customMapsPath.replace('\\','/')) + "\"/>\n");
 			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set
 			// save last path of different exporters

Modified: trunk/src/exp/GPXExporter.java
===================================================================
--- trunk/src/exp/GPXExporter.java	2009-04-03 23:36:54 UTC (rev 1735)
+++ trunk/src/exp/GPXExporter.java	2009-04-04 00:06:06 UTC (rev 1736)
@@ -19,7 +19,7 @@
 		super();
 		this.setMask("*.gpx");
 		this.setNeedCacheDetails(true);
-		this.setHowManyParams(LAT_LON);
+		this.setHowManyParams(LAT_LON|COUNT);
 		this.setTmpFileName(FileBase.getProgramDirectory() + "/temp.gpx");
 	}
 	
@@ -27,7 +27,7 @@
 		super();
 		this.setMask("*.gpx");
 		this.setNeedCacheDetails(true);
-		this.setHowManyParams(LAT_LON);
+		this.setHowManyParams(LAT_LON|COUNT);
 		this.setTmpFileName(FileBase.getProgramDirectory() + "/temp.gpx");
 	}
 	
@@ -37,6 +37,9 @@
 		
 		strBuf.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n");
 		strBuf.append("<gpx xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"1.0\" creator=\"Groundspeak Pocket Query\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0 http://www.groundspeak.com/cache/1/0/cache.xsd\" xmlns=\"http://www.topografix.com/GPX/1/0\">\r\n");
+		if ( Global.getPref().exportGpxAsMyFinds ) {
+			strBuf.append("  <name>My Finds Pocket Query</name>\r\n");
+		}
 		strBuf.append("  <desc>Geocache file generated by CacheWolf</desc>\r\n");
 		strBuf.append("  <author>CacheWolf</author>\r\n");
 		strBuf.append("  <email>test at test.com</email>\r\n");
@@ -47,7 +50,7 @@
 		return strBuf.toString();
 	}
 	
-	public String record(CacheHolderDetail ch, String lat, String lon) {
+	public String record(CacheHolderDetail ch, String lat, String lon, int counter) {
 		StringBuffer strBuf = new StringBuffer(1000);
 
 		try{
@@ -74,7 +77,8 @@
 				strBuf.append("    <groundspeak:cache id=\"").append( ch.GetCacheID() ).append( "\" available=\"" ).append( dummyAvailable ).append( "\" archived=\"" ).append( dummyArchived).append( "\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">\r\n");
 				strBuf.append("      <groundspeak:name>").append(SafeXML.cleanGPX(ch.CacheName)).append("</groundspeak:name>\r\n");
 				strBuf.append("      <groundspeak:placed_by>").append(SafeXML.cleanGPX(ch.CacheOwner)).append("</groundspeak:placed_by>\r\n");
-				strBuf.append("      <groundspeak:owner>").append(SafeXML.cleanGPX(ch.CacheOwner)+"</groundspeak:owner>\r\n");
+				//todo low prio: correct owner-id
+				strBuf.append("      <groundspeak:owner id=\"23\">").append(SafeXML.cleanGPX(ch.CacheOwner)+"</groundspeak:owner>\r\n");
 				strBuf.append("      <groundspeak:type>").append(CacheType.transType(ch.type)).append("</groundspeak:type>\r\n");
 				strBuf.append("      <groundspeak:container>").append(ch.CacheSize).append("</groundspeak:container>\r\n");
 				//for Colorado/Oregon: 2.0 -> 2
@@ -88,14 +92,60 @@
 					diffTerr = diffTerr.substring(0, 1);
 				}
 				strBuf.append("      <groundspeak:terrain>").append(diffTerr).append("</groundspeak:terrain>\r\n");
+				
+				strBuf.append("      <groundspeak:country>").append(SafeXML.cleanGPX(ch.Country)+"</groundspeak:country>\r\n");
+				strBuf.append("      <groundspeak:state>").append(SafeXML.cleanGPX(ch.State)+"</groundspeak:state>\r\n");
+												
 				String dummyHTML = ch.is_HTML ? STRING_TRUE:STRING_FALSE;
 				strBuf.append("      <groundspeak:long_description html=\"" ).append( dummyHTML ).append( "\">\r\n");
 				strBuf.append("      ").append(SafeXML.cleanGPX(ch.LongDescription));
 				strBuf.append("      \n</groundspeak:long_description>\r\n");
 				strBuf.append("	  <groundspeak:encoded_hints>").append(SafeXML.cleanGPX(Common.rot13(ch.Hints))).append("</groundspeak:encoded_hints>\r\n");
 				strBuf.append("      <groundspeak:logs>\r\n");
+				if ( Global.getPref().exportGpxAsMyFinds && ch.is_found ) {
+					if ( ch.OwnLogId.length() != 0 ) {
+						strBuf.append("        <groundspeak:log id=\"" ).append( ch.OwnLogId ).append( "\">\r\n");						
+					} else {
+						strBuf.append("        <groundspeak:log id=\"" ).append( Integer.toString(counter) ).append( "\">\r\n");
+					}
+					strBuf.append("          <groundspeak:date>").append(SafeXML.cleanGPX(ch.GetStatusDate())).append("T").append(SafeXML.cleanGPX(ch.GetStatusTime())).append(":00</groundspeak:date>\r\n");
+					if ( ch.OwnLog != null ) {
+						strBuf.append("          <groundspeak:type>").append(image2TypeText(ch.OwnLog.getIcon())).append("</groundspeak:type>\r\n");
+					} else {
+						strBuf.append("          <groundspeak:type>Found it</groundspeak:type>\r\n");
+					}
+					strBuf.append("          <groundspeak:finder id=\"").append(SafeXML.cleanGPX(Global.getPref().gcMemberId)).append("\">").append(SafeXML.cleanGPX(Global.getPref().myAlias)).append("</groundspeak:finder>\r\n");
+					if ( ch.OwnLog != null ) {
+						strBuf.append("          <groundspeak:text encoded=\"False\">").append(SafeXML.cleanGPX(ch.OwnLog.getMessage())).append("</groundspeak:text>\r\n");
+					} else {
+						strBuf.append("          <groundspeak:text encoded=\"False\"></groundspeak:text>\r\n");		
+					}
+					strBuf.append("        </groundspeak:log>\r\n");
+				} else {
+					int numberOfLogs = java.lang.Math.min(Global.getPref().numberOfLogsToExport, ch.CacheLogs.size());
+					if (numberOfLogs < 0) numberOfLogs = ch.CacheLogs.size();
+					for (int i = 0; i < numberOfLogs; i++) {
+						strBuf.append("        <groundspeak:log id=\"" ).append( Integer.toString(i) ).append( "\">\r\n");
+						strBuf.append("          <groundspeak:date>").append(SafeXML.cleanGPX(ch.CacheLogs.getLog(i).getDate())).append("T00:00:00</groundspeak:date>\r\n");
+						strBuf.append("          <groundspeak:type>").append(image2TypeText(ch.CacheLogs.getLog(i).getIcon())).append("</groundspeak:type>\r\n");
+						strBuf.append("          <groundspeak:finder id=\"\">").append(SafeXML.cleanGPX(ch.CacheLogs.getLog(i).getLogger())).append("</groundspeak:finder>\r\n");
+						strBuf.append("          <groundspeak:text encoded=\"False\">").append(SafeXML.cleanGPX(ch.CacheLogs.getLog(i).getMessage())).append("</groundspeak:text>\r\n");
+						strBuf.append("        </groundspeak:log>\r\n");
+					}
+				}
 				strBuf.append("      </groundspeak:logs>\r\n");
-				strBuf.append("      <groundspeak:travelbugs />\r\n");
+				if ( Global.getPref().exportTravelbugs && (ch.Travelbugs.size() > 0) ) {
+					ch.Travelbugs.size();
+					strBuf.append("      <groundspeak:travelbugs>\r\n");
+					for (int i = 0; i < ch.Travelbugs.size(); i++) {
+						strBuf.append("        <groundspeak:travelbug id=\"").append(Integer.toString(i)).append("\" ref=\"\">\r\n");
+						strBuf.append("          <groundspeak:name>").append(SafeXML.cleanGPX(ch.Travelbugs.getTB(i).getName())).append("</groundspeak:name>\r\n");
+						strBuf.append("        </groundspeak:travelbug>\r\n");						
+					}
+					strBuf.append("      </groundspeak:travelbugs>\r\n");					
+				} else {
+					strBuf.append("      <groundspeak:travelbugs />\r\n");				
+				}
 				strBuf.append("    </groundspeak:cache>\r\n");
 			}else {
 				// there is no HTML in the description of addi wpts
@@ -111,8 +161,28 @@
 		return strBuf.toString();
 	}
 	
-	public String trailer() {
+	public String trailer(int total) {
 		return "</gpx>\r\n";
 	}
 	
+	public static String image2TypeText(String image){
+		if (image.equals("icon_smile.gif")) return "Found it";
+		if (image.equals("icon_sad.gif")) return "Didn't find it";
+		if (image.equals("icon_note.gif")) return "Write note";
+		if (image.equals("icon_enabled.gif")) return "Enable Listing";
+		if (image.equals("icon_disabled.gif")) return "Temporarily Disable Listing";
+		if (image.equals("icon_camera.gif")) return "Webcam Photo Taken";
+		if (image.equals("11.png")) return "Webcam Photo Taken";
+		if (image.equals("icon_attended.gif")) return "Attended";
+		if (image.equals("green.gif")) return "Publish Listing";
+		if (image.equals("icon_rsvp.gif")) return "Will Attend";
+		if (image.equals("big_smile.gif")) return "Post Reviewer Note";
+		if (image.equals("traffic_cone.gif")) return "Archive (show)";
+		if (image.equals("icon_maint.gif")) return "Owner Maintenance";
+		if (image.equals("icon_needsmaint.gif")) return "Needs Maintenance";
+		if (image.equals("coord_update.gif")) return "Update Coordinates";
+
+		return image;
+	}
+	
 }



From mik77 at mail.berlios.de  Sat Apr  4 10:29:50 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 4 Apr 2009 10:29:50 +0200
Subject: [Cachewolf-svn] r1737 - trunk/src/CacheWolf
Message-ID: <200904040829.n348To3S029261@sheep.berlios.de>

Author: mik77
Date: 2009-04-04 10:29:49 +0200 (Sat, 04 Apr 2009)
New Revision: 1737

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
Default fot TB export set to false.

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2009-04-04 00:06:06 UTC (rev 1736)
+++ trunk/src/CacheWolf/Preferences.java	2009-04-04 08:29:49 UTC (rev 1737)
@@ -212,7 +212,7 @@
 	/** The maximum number of logs to export */
 	public int numberOfLogsToExport = 5;
 	/** Add Travelbugs when exporting */
-	public boolean exportTravelbugs = true;
+	public boolean exportTravelbugs = false;
 	/** Try to make a MyFinds GPX when exporting to GPX */
 	public boolean exportGpxAsMyFinds = true;
 



From engywuck at mail.berlios.de  Sun Apr  5 17:00:02 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sun, 5 Apr 2009 17:00:02 +0200
Subject: [Cachewolf-svn] r1738 - in trunk/src: CacheWolf CacheWolf/navi exp
Message-ID: <200904051500.n35F02vp005620@sheep.berlios.de>

Author: engywuck
Date: 2009-04-05 16:59:37 +0200 (Sun, 05 Apr 2009)
New Revision: 1738

Modified:
   trunk/src/CacheWolf/Attributes.java
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DBStats.java
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/DescriptionPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/NewProfileForm.java
   trunk/src/CacheWolf/NewProfileWizard.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/ProfileDataForm.java
   trunk/src/CacheWolf/ProfilesForm.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/ShowCacheInBrowser.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/StatusBar.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/myInteractivePanel.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/exp/ASCExporter.java
   trunk/src/exp/ExploristExporter.java
   trunk/src/exp/Exporter.java
   trunk/src/exp/GPXExporter.java
   trunk/src/exp/HTMLExporter.java
   trunk/src/exp/KMLExporter.java
   trunk/src/exp/LocExporter.java
   trunk/src/exp/MSARCSVExporter.java
   trunk/src/exp/OVLExporter.java
   trunk/src/exp/OziExporter.java
   trunk/src/exp/PCX5Exporter.java
   trunk/src/exp/TPLExporter.java
   trunk/src/exp/TomTomExporter.java
Log:
Introduced getter/setter methods for the most important public fields, in order to be able to toggle the "we have to save index.xml"-flag in a central and more intelligent way. 
Also had to tweak some of the filter routines, so that they don't alter filter flags unnecessarily.

Modified: trunk/src/CacheWolf/Attributes.java
===================================================================
--- trunk/src/CacheWolf/Attributes.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/Attributes.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -16,9 +16,9 @@
 	public long attributesYes;
 	public long attributesNo;
 
-	public Attributes() { 
+	public Attributes(){ 
 	}
-
+	
 	/**
 	 * Get the number of attributes in the list
 	 * @return number of attributes

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -26,21 +26,21 @@
 	protected static final String EMPTY = "";
 
 	/** Cachestatus is Found, Not found or a date in format yyyy-mm-dd hh:mm for found date */
-	public String CacheStatus = EMPTY;
+	private String cacheStatus = EMPTY;
 	/** The name of the waypoint typicall GC.... or OC.... or CW...... (can be any characters) */
-	public String wayPoint = EMPTY;
+	private String wayPoint = EMPTY;
 	/** The name of the cache (short description) */
-	public String CacheName = EMPTY;
+	private String cacheName = EMPTY;
 	/** The alias of the owner */
-	public String CacheOwner = EMPTY;
+	private String cacheOwner = EMPTY;
 	/** The coordinates of the cache */
 	public CWPoint pos = new CWPoint();
 	/** The coordinates of the cache */
 	public String LatLon = pos.toString();
 	/** The date when the cache was hidden in format yyyy-mm-dd */
-	public String DateHidden = EMPTY;
+	private String dateHidden = EMPTY;
 	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
-	public String CacheSize = "None";
+	private String cacheSize = "None";
 	/** The distance from the centre in km */
 	public double kilom = -1; int bla = 0;
 	public double lastKilom = -2; // Cache last value
@@ -51,31 +51,31 @@
 	/** The angle (0=North, 180=South) from the current centre to this point */
 	public double degrees = 0;
 	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
-	public String hard = EMPTY;
+	private String hard = EMPTY;
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
-	public String terrain = EMPTY;
+	private String terrain = EMPTY;
 	/** The cache type (@see CacheType for translation table)  */
-	public int type = 0; 
+	private int type = 0; 
 	/** True if the cache has been archived */
-	public boolean is_archived = false;
+	private boolean archived = false;
 	/** True if the cache is available for searching */
-	public boolean is_available = true;
+	private boolean available = true;
 	/** True if we own this cache */
-	public boolean is_owned = false;
+	private boolean owned = false;
 	/** True if we have found this cache */
-	public boolean is_found = false;
+	private boolean found = false;
 	/** If this is true, the cache has been filtered (is currently invisible) */
-	public boolean is_filtered = false;
+	private boolean filtered = false;
 	/** True if the number of logs for this cache has changed */
-	public boolean is_log_update = false;
+	private boolean log_updated = false;
 	/** True if cache details have changed: longDescription, Hints,  */
-	public boolean is_update = false;
+	private boolean cache_updated = false;
 	/** True if the cache data is incomplete (e.g. an error occurred during spidering */
-	public boolean is_incomplete = false;
+	private boolean incomplete = false;
 	/** True if the cache is blacklisted */
-	public boolean is_black = false;
+	private boolean black = false;
 	/** True if the cache is new */
-	public boolean is_new = false;
+	private boolean newCache = false;
 	/** True if the cache is part of the results of a search */
 	public boolean is_flaged = false;
 	/** True if the cache has been selected using the tick box in the list view */
@@ -83,19 +83,19 @@
 	/** Not used: This attribute is saved with the cache and read back but never set */
 //	public String dirty = EMPTY;
 	/** The unique OC cache ID */
-	public String ocCacheID = EMPTY;
+	private String ocCacheID = EMPTY;
 	/** The number of times this cache has not been found (max. 5) */
-	public int noFindLogs = 0;
+	private int noFindLogs = 0;
 	/** Number of recommendations (from the opencaching logs) */
-	public int numRecommended = 0;
+	private int numRecommended = 0;
 	/** Number of Founds since start of recommendations system */
-	public int numFoundsSinceRecommendation = 0;
+	private int numFoundsSinceRecommendation = 0;
 	/** Recommendation score: calculated as rations  numRecommended / numLogsSinceRecommendation * 100 */
 	public int recommendationScore = 0;
 	/** True if this cache has travelbugs */
-	public boolean has_bug = false;
+	private boolean bugs = false;
 	/** True if the cache description is stored in HTML format */
-	public boolean is_HTML = true;
+	private boolean html = true;
 	/** List of additional waypoints associated with this waypoint */
 	public Vector addiWpts = new Vector();
 	/** in range is used by the route filter to identify caches in range of a segment*/
@@ -103,7 +103,7 @@
 	/** If this is an additional waypoint, this links back to the main waypoint */
 	public CacheHolder mainCache;
 	/** The date this cache was last synced with OC in format yyyyMMddHHmmss */
-	public String lastSyncOC = EMPTY;
+	private String lastSyncOC = EMPTY;
 	public CacheHolderDetail details = null;
 	/** When sorting the cacheDB this field is used. The relevant field is copied here and
 	 *  the sort is always done on this field to speed up the sorting process 
@@ -111,9 +111,10 @@
 	public String sort;
 	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
 
-	public long attributesYes = 0;
-	public long attributesNo  = 0;
+	private long attributesYes = 0;
+	private long attributesNo  = 0;
 
+	
 //	static int nObjects=0;
 	public CacheHolder() {//nObjects++;Vm.debug("CacheHolder() nO="+nObjects);
 	}
@@ -132,10 +133,10 @@
 		int start,end;
 		try {
 			start=xmlString.indexOf('"'); end=xmlString.indexOf('"',start+1);
-			CacheName = SafeXML.cleanback(xmlString.substring(start+1,end));
+			setCacheName(SafeXML.cleanback(xmlString.substring(start+1,end)));
 			
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-            CacheOwner = SafeXML.cleanback(xmlString.substring(start+1,end));
+            setCacheOwner(SafeXML.cleanback(xmlString.substring(start+1,end)));
 			// Assume coordinates are in decimal format
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
 			double lat=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
@@ -146,90 +147,90 @@
 			LatLon=pos.toString();
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			DateHidden = xmlString.substring(start+1,end); 
+			setDateHidden(xmlString.substring(start+1,end)); 
 			// Convert the US format to YYYY-MM-DD if necessary
-			if (DateHidden.indexOf('/')>-1) DateHidden=DateFormat.MDY2YMD(DateHidden);
+			if (getDateHidden().indexOf('/')>-1) setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			wayPoint = SafeXML.cleanback(xmlString.substring(start+1,end));
+			setWayPoint(SafeXML.cleanback(xmlString.substring(start+1,end)));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			CacheStatus = xmlString.substring(start+1,end);
+			setCacheStatus(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			type = new Integer(xmlString.substring(start+1,end)).intValue();
+			setType(new Integer(xmlString.substring(start+1,end)).intValue());
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			hard = xmlString.substring(start+1,end);
+			setHard(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			terrain = xmlString.substring(start+1,end);
+			setTerrain(xmlString.substring(start+1,end));
 
 			// The next item was 'dirty' but this is no longer used.
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_filtered = xmlString.substring(start+1,end).equals("true"); 
+			setFiltered(xmlString.substring(start+1,end).equals("true")); 
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			CacheSize = xmlString.substring(start+1,end);
+			setCacheSize(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_available = xmlString.substring(start+1,end).equals("true");
+			setAvailable(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_archived = xmlString.substring(start+1,end).equals("true");
+			setArchived(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			has_bug = xmlString.substring(start+1,end).equals("true");
+			setHas_bugs(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_black = xmlString.substring(start+1,end).equals("true");
-			if(is_black!=Global.getProfile().showBlacklisted) is_filtered = true;
+			setBlack(xmlString.substring(start+1,end).equals("true"));
+			if(is_black()!=Global.getProfile().showBlacklisted()) setFiltered(true);
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_owned = xmlString.substring(start+1,end).equals("true");
+			setOwned(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_found = xmlString.substring(start+1,end).equals("true");
+			setFound(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_new = xmlString.substring(start+1,end).equals("true");
+			setNew(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_log_update = xmlString.substring(start+1,end).equals("true");
+			setLog_updated(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_update = xmlString.substring(start+1,end).equals("true");
+			setUpdated(xmlString.substring(start+1,end).equals("true"));
 
 			// for backwards compatibility set value to true, if it is not in the file
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_HTML = !xmlString.substring(start+1,end).equals("false");
+			setHTML(!xmlString.substring(start+1,end).equals("false"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			noFindLogs = Convert.toInt(xmlString.substring(start+1,end));
+			setNoFindLogs(Convert.toInt(xmlString.substring(start+1,end)));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			ocCacheID = xmlString.substring(start+1,end);
+			setOcCacheID(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			is_incomplete = xmlString.substring(start+1,end).equals("true");
+			setIncomplete(xmlString.substring(start+1,end).equals("true"));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			lastSyncOC = xmlString.substring(start+1,end);
+			setLastSyncOC(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			numRecommended = Convert.toInt(xmlString.substring(start+1,end));
+			setNumRecommended(Convert.toInt(xmlString.substring(start+1,end)));
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			numFoundsSinceRecommendation = Convert.toInt(xmlString.substring(start+1,end));
-			recommendationScore = LogList.getScore(numRecommended, numFoundsSinceRecommendation);
+			setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start+1,end)));
+			recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
 
 			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
 			if (start > -1 && end > -1) {
-				attributesYes = Convert.parseLong(xmlString.substring(start+1,end));
+				setAttributesYes(Convert.parseLong(xmlString.substring(start+1,end)));
 
 				start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
 				if (start > -1 && end > -1)
-					attributesNo = Convert.parseLong(xmlString.substring(start+1,end));
+					setAttributesNo(Convert.parseLong(xmlString.substring(start+1,end)));
 			}
 		} catch (Exception ex) {
 
@@ -280,11 +281,11 @@
 	}
 	public void update(CacheHolder ch, boolean overwrite) {
 		this.recommendationScore = ch.recommendationScore;
-		this.numFoundsSinceRecommendation = ch.numFoundsSinceRecommendation;
-		this.numRecommended = ch.numRecommended;
+		this.setNumFoundsSinceRecommendation(ch.getNumFoundsSinceRecommendation());
+		this.setNumRecommended(ch.getNumRecommended());
 		if (overwrite) {
-			this.CacheStatus=ch.CacheStatus;
-			this.is_found = ch.is_found;
+			this.setCacheStatus(ch.getCacheStatus());
+			this.setFound(ch.is_found());
 			this.pos = ch.pos;
 			this.LatLon = ch.LatLon;
 		} else {
@@ -296,9 +297,9 @@
 	   true                yyyy-mm-dd          yyyy-mm-dd       no (or yes)
 	   true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
 			 */
-			if (!this.is_found || this.CacheStatus.indexOf(":")<0) {
-				this.CacheStatus=ch.CacheStatus;
-				this.is_found = ch.is_found;
+			if (!this.is_found() || this.getCacheStatus().indexOf(":")<0) {
+				this.setCacheStatus(ch.getCacheStatus());
+				this.setFound(ch.is_found());
 			}
 			// Don't overwrite valid coordinates with invalid ones
 			if (ch.pos.isValid() || !this.pos.isValid()) {
@@ -306,70 +307,70 @@
 				this.LatLon = ch.LatLon;
 			}
 		}
-		this.wayPoint = ch.wayPoint;
-		this.CacheName = ch.CacheName;
-		this.CacheOwner = ch.CacheOwner;
+		this.setWayPoint(ch.getWayPoint());
+		this.setCacheName(ch.getCacheName());
+		this.setCacheOwner(ch.getCacheOwner());
 
-		this.DateHidden = ch.DateHidden;
-		this.CacheSize = ch.CacheSize;
+		this.setDateHidden(ch.getDateHidden());
+		this.setCacheSize(ch.getCacheSize());
 		this.kilom = ch.kilom;
 		this.bearing = ch.bearing;
 		this.degrees = ch.degrees;
-		this.hard = ch.hard;
-		this.terrain = ch.terrain;
-		this.type = ch.type;
-		this.is_archived = ch.is_archived;
-		this.is_available = ch.is_available;
-		this.is_owned = ch.is_owned;
-		this.is_filtered = ch.is_filtered;
-		this.is_log_update = ch.is_log_update;
-		this.is_update = ch.is_update;
-		this.is_incomplete = ch.is_incomplete;
-		this.is_black=ch.is_black;
+		this.setHard(ch.getHard());
+		this.setTerrain(ch.getTerrain());
+		this.setType(ch.getType());
+		this.setArchived(ch.is_archived());
+		this.setAvailable(ch.is_available());
+		this.setOwned(ch.is_owned());
+		this.setFiltered(ch.is_filtered());
+		this.setLog_updated(ch.is_log_updated());
+		this.setUpdated(ch.is_updated());
+		this.setIncomplete(ch.is_incomplete());
+		this.setBlack(ch.is_black());
 		this.addiWpts = ch.addiWpts;
 		this.mainCache=ch.mainCache;
-		this.is_new=ch.is_new;
+		this.setNew(ch.is_new());
 		this.is_flaged = ch.is_flaged;
 		this.is_Checked = ch.is_Checked;
 		//this.dirty = ch.dirty;
-		this.ocCacheID = ch.ocCacheID;
-		this.noFindLogs = ch.noFindLogs;
-		this.has_bug = ch.has_bug;
-		this.is_HTML = ch.is_HTML;
+		this.setOcCacheID(ch.getOcCacheID());
+		this.setNoFindLogs(ch.getNoFindLogs());
+		this.setHas_bugs(ch.has_bugs());
+		this.setHTML(ch.is_HTML());
 		this.sort=ch.sort;
-		this.lastSyncOC = ch.lastSyncOC;
+		this.setLastSyncOC(ch.getLastSyncOC());
 
-		this.attributesYes = ch.attributesYes;
-		this.attributesNo = ch.attributesNo;
+		this.setAttributesYes(ch.getAttributesYes());
+		this.setAttributesNo(ch.getAttributesNo());
 	}
 	/**
 	 * Call it only when necessary, it takes time, because all logs must be parsed
 	 *
 	 */
 	public void calcRecommendationScore() {
-		if (wayPoint.toLowerCase().startsWith("oc") ) {
+		if (getWayPoint().toLowerCase().startsWith("oc") ) {
 			CacheHolderDetail chD;
 			if (this instanceof CacheHolderDetail)	chD = (CacheHolderDetail)this;
 			else chD = getCacheDetails(true, false);
 			if (chD != null) {
 				chD.CacheLogs.calcRecommendations();
 				recommendationScore = chD.CacheLogs.recommendationRating;
-				numFoundsSinceRecommendation = chD.CacheLogs.foundsSinceRecommendation;
-				numRecommended = chD.CacheLogs.numRecommended;
+				setNumFoundsSinceRecommendation(chD.CacheLogs.foundsSinceRecommendation);
+				setNumRecommended(chD.CacheLogs.numRecommended);
 			} else { // cache doesn't have details
 				recommendationScore = -1;
-				numFoundsSinceRecommendation = -1;
-				numRecommended = -1;
+				setNumFoundsSinceRecommendation(-1);
+				setNumRecommended(-1);
 			}
 		} else {
 			recommendationScore = -1;
-			numFoundsSinceRecommendation = -1;
-			numRecommended = -1;
+			setNumFoundsSinceRecommendation(-1);
+			setNumRecommended(-1);
 		}
 		if (details != null) {
 		details.recommendationScore = recommendationScore;
-		details.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
-		details.numRecommended = numRecommended;
+		details.setNumFoundsSinceRecommendation(getNumFoundsSinceRecommendation());
+		details.setNumRecommended(getNumRecommended());
 		}
 	}
 	
@@ -377,50 +378,50 @@
 	public String toXML() {
 		if (this instanceof CacheHolderDetail || (details != null && details.hasUnsavedChanges)) calcRecommendationScore(); 
 		sb.delete(0,sb.length());
-		sb.append("    <CACHE name = \"");
-		sb.append(SafeXML.clean(CacheName));
-		sb.append("\" owner = \"");		sb.append(SafeXML.clean(CacheOwner));
+		sb.append("    <CACHE ");
+		sb.append(" name = \"");        sb.append(SafeXML.clean(getCacheName()));
+		sb.append("\" owner = \"");		sb.append(SafeXML.clean(getCacheOwner()));
 		sb.append("\" lat = \""); 		sb.append(pos.latDec ); 
 		sb.append("\" lon = \"");		sb.append(pos.lonDec);
-		sb.append("\" hidden = \"");	sb.append(DateHidden);
-		sb.append("\" wayp = \"");		sb.append(SafeXML.clean(wayPoint));
-		sb.append("\" status = \"");	sb.append(CacheStatus);
-		sb.append("\" type = \"");		sb.append(type);
-		sb.append("\" dif = \"");		sb.append(hard);
-		sb.append("\" terrain = \"" );	sb.append(terrain ); 
-		sb.append("\" filtered = \"" ); sb.append(is_filtered); // This was 'dirty', but dirty is not used
-		sb.append("\" size = \"");		sb.append(CacheSize);
-		sb.append("\" online = \"" );	sb.append(is_available); 
-		sb.append("\" archived = \"" );	sb.append(is_archived); 
-		sb.append("\" has_bug = \"" ); 	sb.append(has_bug); 
-		sb.append("\" black = \"" ); 	sb.append(is_black); 
-		sb.append("\" owned = \"" ); 	sb.append(is_owned); 
-		sb.append("\" found = \"" ); 	sb.append(is_found); 
-		sb.append("\" is_new = \"" );	sb.append(is_new);
-		sb.append("\" is_log_update = \"" );sb.append(is_log_update); 
-		sb.append("\" is_update = \"" );sb.append(is_update); 
-		sb.append("\" is_HTML = \"" ); 	sb.append(is_HTML); 
-		sb.append("\" DNFLOGS = \"" ); 	sb.append(noFindLogs ); 
-		sb.append("\" ocCacheID = \"" );sb.append(ocCacheID ); 
-		sb.append("\" is_INCOMPLETE = \"");sb.append(is_incomplete); 
-		sb.append("\" lastSyncOC = \"" );sb.append(lastSyncOC ); 
-		sb.append("\" num_recommended = \"");sb.append(Convert.formatInt(numRecommended)); 
-		sb.append("\" num_found = \"" );sb.append(Convert.formatInt(numFoundsSinceRecommendation));
-		sb.append("\" attributesYes = \"" ); sb.append(Convert.formatLong(attributesYes));
-		sb.append("\" attributesNo = \"" ); sb.append(Convert.formatLong(attributesNo));
+		sb.append("\" hidden = \"");	sb.append(getDateHidden());
+		sb.append("\" wayp = \"");		sb.append(SafeXML.clean(getWayPoint()));
+		sb.append("\" status = \"");	sb.append(getCacheStatus());
+		sb.append("\" type = \"");		sb.append(getType());
+		sb.append("\" dif = \"");		sb.append(getHard());
+		sb.append("\" terrain = \"" );	sb.append(getTerrain() ); 
+		sb.append("\" filtered = \"" ); sb.append(is_filtered()); // This was 'dirty', but dirty is not used
+		sb.append("\" size = \"");		sb.append(getCacheSize());
+		sb.append("\" online = \"" );	sb.append(is_available()); 
+		sb.append("\" archived = \"" );	sb.append(is_archived()); 
+		sb.append("\" has_bug = \"" ); 	sb.append(has_bugs()); 
+		sb.append("\" black = \"" ); 	sb.append(is_black()); 
+		sb.append("\" owned = \"" ); 	sb.append(is_owned()); 
+		sb.append("\" found = \"" ); 	sb.append(is_found()); 
+		sb.append("\" is_new = \"" );	sb.append(is_new());
+		sb.append("\" is_log_update = \"" );sb.append(is_log_updated()); 
+		sb.append("\" is_update = \"" );sb.append(is_updated()); 
+		sb.append("\" is_HTML = \"" ); 	sb.append(is_HTML()); 
+		sb.append("\" DNFLOGS = \"" ); 	sb.append(getNoFindLogs()); 
+		sb.append("\" ocCacheID = \"" );sb.append(getOcCacheID()); 
+		sb.append("\" is_INCOMPLETE = \"");sb.append(is_incomplete()); 
+		sb.append("\" lastSyncOC = \"" );sb.append(getLastSyncOC()); 
+		sb.append("\" num_recommended = \"");sb.append(Convert.formatInt(getNumRecommended())); 
+		sb.append("\" num_found = \"" );sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
+		sb.append("\" attributesYes = \"" ); sb.append(Convert.formatLong(getAttributesYes()));
+		sb.append("\" attributesNo = \"" ); sb.append(Convert.formatLong(getAttributesNo()));
 		sb.append("\" />\n");
 		return sb.toString();
 	}
 
 	public void setLatLon(String latLon) {
 		latLon=latLon.trim();
-		if (!latLon.equals(LatLon.trim())) is_update=true;
+		if (!latLon.equals(LatLon.trim())) setUpdated(true);
 		LatLon = latLon;
 		pos.set(latLon);
 	}
 
 	public boolean isAddiWpt() {
-		return CacheType.isAddiWpt(this.type);
+		return CacheType.isAddiWpt(this.getType());
 	}
 
 	public boolean hasAddiWpt() {
@@ -440,14 +441,14 @@
 		}
 	}
 	public void setAttributesFromMainCache(CacheHolder mainCh){
-		this.CacheOwner = mainCh.CacheOwner;
-		this.CacheStatus = mainCh.CacheStatus;
-		this.is_archived = mainCh.is_archived;
-		this.is_available = mainCh.is_available;
-		this.is_black = mainCh.is_black;
-		this.is_owned = mainCh.is_owned;
-		this.is_new = mainCh.is_new;
-		this.is_found = mainCh.is_found;
+		this.setCacheOwner(mainCh.getCacheOwner());
+		this.setCacheStatus(mainCh.getCacheStatus());
+		this.setArchived(mainCh.is_archived());
+		this.setAvailable(mainCh.is_available());
+		this.setBlack(mainCh.is_black());
+		this.setOwned(mainCh.is_owned());
+		this.setNew(mainCh.is_new());
+		this.setFound(mainCh.is_found());
 	}
 
 	public void setAttributesToAddiWpts(){
@@ -475,7 +476,7 @@
 			if (ch.isAddiWpt()) 
 				main2=ch.mainCache;
 			else 
-				return main1.wayPoint.equals(ch.wayPoint);
+				return main1.getWayPoint().equals(ch.getWayPoint());
 		} else { // ch instanceof CacheHolder 
 			if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
 		}
@@ -512,16 +513,21 @@
 			else details.update(this);
 			return details;
 		}
+		// FIXME Problem: Hier wird ein neues Detail-Objekt erzeugt, welches nat?rlich noch
+		//       Default-Werte in den Feldern stehen hat. 
+		//       Das Zur?cksetzen von UnsavedChanges ist erstmal ein Hack.
+		boolean hasUnsavedChanges = Global.getProfile().hasUnsavedChanges();
 		details = new CacheHolderDetail(this);
 		try {
 			details.readCache(Global.getProfile().dataDir);
 		} catch (IOException e) {
 			if (maybenew) details.update(this);
 			else {
-				if (alarmuser) (new MessageBox("Error", "Could not read cache details for cache: "+this.wayPoint, FormBase.OKB)).execute();
+				if (alarmuser) (new MessageBox("Error", "Could not read cache details for cache: "+this.getWayPoint(), FormBase.OKB)).execute();
 				return null;
 			} 
 		}
+		if (! hasUnsavedChanges) Global.getProfile().resetUnsavedChanges();
 		detailsAdded();
 		return details;
 	}
@@ -589,9 +595,9 @@
 	public String GetStatusDate() {
 		String statusDate = "";
 		
-		if (is_found) {
+		if (is_found()) {
 			Regex rexDate=new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
-			rexDate.search(CacheStatus);
+			rexDate.search(getCacheStatus());
 			if (rexDate.stringMatched(1)!= null) {
 				statusDate = rexDate.stringMatched(1);
 			}
@@ -603,15 +609,15 @@
 	public String GetStatusTime() {
 		String statusTime = "";
 
-		if (is_found) {
+		if (is_found()) {
 			Regex rexTime=new Regex("([0-9]{1,2}:[0-9]{2})");
-			rexTime.search(CacheStatus);
+			rexTime.search(getCacheStatus());
 			if (rexTime.stringMatched(1)!= null) {
 				statusTime = rexTime.stringMatched(1);
 			}
 			else {
 				Regex rexDate=new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
-				rexDate.search(CacheStatus);
+				rexDate.search(getCacheStatus());
 				if (rexDate.stringMatched(1)!= null) {
 					statusTime = "00:00";
 				}
@@ -624,12 +630,12 @@
 	public String GetCacheID() {
 		String result = "";
 		
-		if ( wayPoint.toUpperCase().startsWith( "GC" ) ) {
+		if ( getWayPoint().toUpperCase().startsWith( "GC" ) ) {
 			int gcId = 0;
 
 			String sequence = "0123456789ABCDEFGHJKMNPQRTVWXYZ";
 			
-			String rightPart = wayPoint.substring( 2 ).toUpperCase();
+			String rightPart = getWayPoint().substring( 2 ).toUpperCase();
 			
 			int base = 31;
 			if ((rightPart.length() < 4) || (rightPart.length() == 4 && sequence.indexOf(rightPart.charAt(0)) < 16)) {
@@ -646,11 +652,266 @@
 	        }
 	        
 	        result = Integer.toString(gcId);	        
-		} else if ( wayPoint.toUpperCase().startsWith( "OC" ) ) {
-        	result = ocCacheID;
+		} else if ( getWayPoint().toUpperCase().startsWith( "OC" ) ) {
+        	result = getOcCacheID();
         }
 
 		return result;
 	}
+
+	// Getter and Setter for private properties
+
+	public String getCacheStatus() {
+    	return cacheStatus;
+    }
+
+	public void setCacheStatus(String cacheStatus) {
+		Global.getProfile().notifyUnsavedChanges(!cacheStatus.equals(this.cacheStatus));		
+    	this.cacheStatus = cacheStatus;
+    }
+
+	public String getWayPoint() {
+    	return wayPoint;
+    }
+
+	public void setWayPoint(String wayPoint) {
+		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));		
+    	this.wayPoint = wayPoint;
+    }
+
+	public String getCacheName() {
+    	return cacheName;
+    }
+
+	public void setCacheName(String cacheName) {
+		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));		
+    	this.cacheName = cacheName;
+    }
+
+	public String getCacheOwner() {
+    	return cacheOwner;
+    }
+
+	public void setCacheOwner(String cacheOwner) {
+		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));		
+    	this.cacheOwner = cacheOwner;
+    }
+
+	public String getDateHidden() {
+    	return dateHidden;
+    }
+
+	public void setDateHidden(String dateHidden) {
+		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));		
+    	this.dateHidden = dateHidden;
+    }
+
+	public String getCacheSize() {
+    	return cacheSize;
+    }
+
+	public void setCacheSize(String cacheSize) {
+		Global.getProfile().notifyUnsavedChanges(!cacheSize.equals(this.cacheSize));		
+    	this.cacheSize = cacheSize;
+    }
+
+	public String getHard() {
+    	return hard;
+    }
+
+	public void setHard(String hard) {
+		Global.getProfile().notifyUnsavedChanges(!hard.equals(this.hard));		
+    	this.hard = hard;
+    }
+
+	public String getTerrain() {
+    	return terrain;
+    }
+
+	public void setTerrain(String terrain) {
+		Global.getProfile().notifyUnsavedChanges(!terrain.equals(this.terrain));		
+    	this.terrain = terrain;
+    }
+
+	public int getType() {
+    	return type;
+    }
+
+	public void setType(int type) {
+		Global.getProfile().notifyUnsavedChanges(type != this.type);		
+    	this.type = type;
+    }
+
+	public boolean is_archived() {
+    	return archived;
+    }
+
+	public void setArchived(boolean is_archived) {
+		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);		
+    	this.archived = is_archived;
+    }
+
+	public boolean is_available() {
+    	return available;
+    }
+
+	public void setAvailable(boolean is_available) {
+		Global.getProfile().notifyUnsavedChanges(is_available != this.available);		
+    	this.available = is_available;
+    }
+
+	public boolean is_owned() {
+    	return owned;
+    }
+
+	public void setOwned(boolean is_owned) {
+		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);		
+    	this.owned = is_owned;
+    }
+
+	public boolean is_found() {
+    	return found;
+    }
+
+	public void setFound(boolean is_found) {
+		Global.getProfile().notifyUnsavedChanges(is_found != this.found);		
+    	this.found = is_found;
+    }
+
+	public boolean is_filtered() {
+    	return filtered;
+    }
+
+	public void setFiltered(boolean is_filtered) {
+		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);		
+    	this.filtered = is_filtered;
+    }
+
+	public boolean is_log_updated() {
+    	return log_updated;
+    }
+
+	public void setLog_updated(boolean is_log_updated) {
+		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);		
+    	this.log_updated = is_log_updated;
+    }
+
+	public boolean is_updated() {
+    	return cache_updated;
+    }
+
+	public void setUpdated(boolean is_updated) {
+		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);		
+    	this.cache_updated = is_updated;
+    }
+
+	public boolean is_incomplete() {
+    	return incomplete;
+    }
+
+	public void setIncomplete(boolean is_incomplete) {
+		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);		
+    	this.incomplete = is_incomplete;
+    }
+
+	public boolean is_black() {
+    	return black;
+    }
+
+	public void setBlack(boolean is_black) {
+		Global.getProfile().notifyUnsavedChanges(is_black != this.black);		
+    	this.black = is_black;
+    }
+
+	public boolean is_new() {
+    	return newCache;
+    }
+
+	public void setNew(boolean is_new) {
+		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);		
+    	this.newCache = is_new;
+    }
+
+	public String getOcCacheID() {
+    	return ocCacheID;
+    }
+
+	public void setOcCacheID(String ocCacheID) {
+		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));		
+    	this.ocCacheID = ocCacheID;
+    }
+
+	public int getNoFindLogs() {
+    	return noFindLogs;
+    }
+
+	public void setNoFindLogs(int noFindLogs) {
+		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);		
+    	this.noFindLogs = noFindLogs;
+    }
+
+	public int getNumRecommended() {
+    	return numRecommended;
+    }
+
+	public void setNumRecommended(int numRecommended) {
+		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);		
+    	this.numRecommended = numRecommended;
+    }
+
+	public int getNumFoundsSinceRecommendation() {
+    	return numFoundsSinceRecommendation;
+    }
+
+	public void setNumFoundsSinceRecommendation(int numFoundsSinceRecommendation) {
+		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);		
+    	this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
+    }
+
+	public boolean has_bugs() {
+    	return bugs;
+    }
+
+	public void setHas_bugs(boolean has_bug) {
+		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);		
+    	this.bugs = has_bug;
+    }
+
+	public boolean is_HTML() {
+    	return html;
+    }
+
+	public void setHTML(boolean is_HTML) {
+		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);		
+    	this.html = is_HTML;
+    }
+
+	public String getLastSyncOC() {
+    	return lastSyncOC;
+    }
+
+	public void setLastSyncOC(String lastSyncOC) {
+		Global.getProfile().notifyUnsavedChanges(!lastSyncOC.equals(this.lastSyncOC));		
+    	this.lastSyncOC = lastSyncOC;
+    }
+
+	public long getAttributesYes() {
+    	return attributesYes;
+    }
+
+	public void setAttributesYes(long attributesYes) {
+		Global.getProfile().notifyUnsavedChanges(attributesYes != this.attributesYes);		
+    	this.attributesYes = attributesYes;
+    }
+
+	public long getAttributesNo() {
+    	return attributesNo;
+    }
+
+	public void setAttributesNo(long attributesNo) {
+		Global.getProfile().notifyUnsavedChanges(attributesNo != this.attributesNo);		
+    	this.attributesNo = attributesNo;
+    }
+
 }
 

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -49,8 +49,8 @@
 	 }
 
 	 public void setLongDescription(String longDescription) {
-	 	if (LongDescription.equals("")) is_new=true;
-	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) is_update=true;
+	 	if (LongDescription.equals("")) setNew(true);
+	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) setUpdated(true);
 	 	LongDescription = longDescription;
 	 }
 	 
@@ -64,17 +64,17 @@
 	 }
 	 
 	 public void setHints(String hints) {
-	 	if (!Hints.equals(hints)) is_update=true;
+	 	if (!Hints.equals(hints)) setUpdated(true);
 	 	Hints = hints;
 	 }
 	 
 	 public void setCacheLogs(LogList newLogs) {
 		 int size=newLogs.size();
 		 for (int i=size-1; i>=0; i--) { // Loop over all new logs, must start with oldest log
-			 if (CacheLogs.merge(newLogs.getLog(i))>=0) this.is_log_update=true;
+			 if (CacheLogs.merge(newLogs.getLog(i))>=0) this.setLog_updated(true);
 		 }
 		 //CacheLogs=logs;
-		 noFindLogs=CacheLogs.countNotFoundLogs();
+		 setNoFindLogs(CacheLogs.countNotFoundLogs());
 	 }
 
 	 
@@ -87,11 +87,11 @@
 	public CacheHolderDetail update(CacheHolderDetail newCh){
 		  super.update(newCh);
 		  // flags
-		  if (this.is_found == true && this.CacheStatus.equals("")) this.CacheStatus = MyLocale.getMsg(318,"Found");
+		  if (this.is_found() && this.getCacheStatus().equals("")) this.setCacheStatus(MyLocale.getMsg(318,"Found"));
 
 		  //travelbugs:GPX-File contains all actual travelbugs but not the missions
 		  //  we need to check whether the travelbug is already in the existing list
-		  this.has_bug = newCh.Travelbugs.size()>0;
+		  this.setHas_bugs(newCh.Travelbugs.size()>0);
 		  for (int i=newCh.Travelbugs.size()-1; i>=0; i--) {
 			 Travelbug tb=newCh.Travelbugs.getTB(i);  
 		     Travelbug oldTB=this.Travelbugs.find(tb.getName());
@@ -135,7 +135,7 @@
 				imgDesc = new InputBox("Description").input("",10);
 				//Create Destination Filename
 				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf("."));
-				imgDestName = this.wayPoint + "_U_" + (this.UserImages.size()+1) + ext;
+				imgDestName = this.getWayPoint() + "_U_" + (this.UserImages.size()+1) + ext;
 				
 				this.UserImages.add(imgDestName);
 				this.UserImagesText.add(imgDesc);
@@ -155,11 +155,11 @@
 		public void readCache(String dir) throws IOException{
 			String dummy;
 			FileReader in = null;
-			if (new FileBugfix(dir + wayPoint.toLowerCase() + ".xml").exists()) in = new FileReader(dir+wayPoint.toLowerCase() + ".xml");
+			if (new FileBugfix(dir + getWayPoint().toLowerCase() + ".xml").exists()) in = new FileReader(dir+getWayPoint().toLowerCase() + ".xml");
 			if (in == null) {
-				if (new FileBugfix(dir + wayPoint + ".xml").exists()) in = new FileReader(dir+wayPoint + ".xml");
+				if (new FileBugfix(dir + getWayPoint() + ".xml").exists()) in = new FileReader(dir+getWayPoint() + ".xml");
 			}
-			if (in == null) throw new FileNotFoundException(dir+wayPoint.toLowerCase()+".xml");
+			if (in == null) throw new FileNotFoundException(dir+getWayPoint().toLowerCase()+".xml");
 			String text= in.readAll();
 			in.close();
 			Extractor ex = new Extractor(text, "<DETAILS><![CDATA[", "]]></DETAILS>", 0, true);		
@@ -267,8 +267,8 @@
 				URL = dummy;
 			}
 			else {
-				if (wayPoint.startsWith("GC")) {
-					URL = "http://www.geocaching.com/seek/cache_details.aspx?wp="+ wayPoint + "&Submit6=Find&log=y";
+				if (getWayPoint().startsWith("GC")) {
+					URL = "http://www.geocaching.com/seek/cache_details.aspx?wp="+ getWayPoint() + "&Submit6=Find&log=y";
 				}
 			}
 			ex = new Extractor(text, "<SOLVER><![CDATA[", "]]></SOLVER>", 0, true);
@@ -281,27 +281,27 @@
 		public void saveCacheDetails(String dir){
 			PrintWriter detfile;
 			//File exists?
-			boolean exists = (new File(dir + wayPoint + ".xml")).exists();
+			boolean exists = (new File(dir + getWayPoint() + ".xml")).exists();
 			//yes: then delete
 			if (exists) {
-				boolean ok = (new File(dir + wayPoint + ".xml")).delete();
+				boolean ok = (new File(dir + getWayPoint() + ".xml")).delete();
 				if(ok) ok = true;
 			}
-			boolean exists2 = (new File(dir + wayPoint.toLowerCase() + ".xml")).exists();
+			boolean exists2 = (new File(dir + getWayPoint().toLowerCase() + ".xml")).exists();
 			//yes: delete
 			if (exists2) {
-				boolean ok2 = (new File(dir + wayPoint.toLowerCase() + ".xml")).delete();
+				boolean ok2 = (new File(dir + getWayPoint().toLowerCase() + ".xml")).delete();
 				if(ok2) ok2=true;
 			}
 			//Vm.debug("Writing to: " +dir + "for: " + wayPoint);
 			try{
-			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dir + wayPoint.toLowerCase() + ".xml")));
+			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dir + getWayPoint().toLowerCase() + ".xml")));
 			} catch (Exception e) {
 				Global.getPref().log("Problem creating details file",e,true);
 				return;
 			}
 			try{
-				if(wayPoint.length()>0){
+				if(getWayPoint().length()>0){
 				  detfile.print("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n");
 				  detfile.print("<CACHEDETAILS>\r\n");
 				  detfile.print("<DETAILS><![CDATA["+LongDescription+"]]></DETAILS>\r\n");
@@ -366,12 +366,12 @@
 				  detfile.print("</CACHEDETAILS>\n");
 				} // if length
 			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + wayPoint + " writing to a details file: " + e.getMessage());
+				Global.getPref().log("Problem waypoint " + getWayPoint() + " writing to a details file: " + e.getMessage());
 			}
 			try{
 			  detfile.close();
 			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + wayPoint + " writing to a details file: " + e.getMessage());
+				Global.getPref().log("Problem waypoint " + getWayPoint() + " writing to a details file: " + e.getMessage());
 			}
 			hasUnsavedChanges = false;
 		}
@@ -387,9 +387,9 @@
 		public boolean belongsTo (CacheHolder ch) {
 			
 			// avoid self referencing
-			if (this.wayPoint.equals(ch.wayPoint)) return false;
+			if (this.getWayPoint().equals(ch.getWayPoint())) return false;
 
-			return this.wayPoint.endsWith(ch.wayPoint.substring(2));
+			return this.getWayPoint().endsWith(ch.getWayPoint().substring(2));
 		}
 		
 		/**

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/CacheList.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -90,10 +90,10 @@
 			 idx=getSelectedIndex(0);
 			 if (idx>=0) {
 				 CacheHolder ch=(CacheHolder)cacheList.get(idx);
-				 wayPoint=ch.wayPoint;
+				 wayPoint=ch.getWayPoint();
 				 IconAndText imgDrag=new IconAndText();
-				 imgDrag.addColumn(CacheType.cache2Img(ch.type));
-				 imgDrag.addColumn(ch.wayPoint);
+				 imgDrag.addColumn(CacheType.cache2Img(ch.getType()));
+				 imgDrag.addColumn(ch.getWayPoint());
 				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
 			 } 
 		}
@@ -266,7 +266,7 @@
 		// Start by setting all caches to filtered
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=true ; // ignore blacklist attribute
+			ch.setFiltered(true) ; // ignore blacklist attribute
 			ch.sort=apply;
 		}
 		// Now "unfilter" the caches in our list
@@ -279,23 +279,22 @@
 			   cacheDB for each entry in cacheList, we simply compare the sort field of ch to apply.
 			*/
 			if (!ch.sort.equals(apply)) {
-				int idx=Global.getProfile().getCacheIndex(ch.wayPoint);
+				int idx=Global.getProfile().getCacheIndex(ch.getWayPoint());
 				if (idx==-1) continue;
 				ch=null;
 				ch=(CacheHolder) cacheDB.get(idx);
 			}
-			if (ch.is_black!=Global.getProfile().showBlacklisted) 
+			if (ch.is_black()!=Global.getProfile().showBlacklisted()) 
 				wrongBlackStatus++;
 			else {
-				ch.is_filtered=false;
+				ch.setFiltered(false);
 				ch.sort=MyLocale.formatLong(i,"00000");
 			}
 		}
 		// The sort command places all filtered caches at the end
 		cacheDB.sort(new mySort(),false);
-		Global.getProfile().filterActive=Filter.FILTER_CACHELIST;
-		Global.getProfile().filterInverted=false;
-		Global.getProfile().hasUnsavedChanges=true;
+		Global.getProfile().setFilterActive(Filter.FILTER_CACHELIST);
+		Global.getProfile().setFilterInverted(false);
 		updateScreen(cacheList.size()-wrongBlackStatus);
 		if (wrongBlackStatus>0)
 			(new MessageBox(MyLocale.getMsg(5500,"Error"),MyLocale.getMsg(4600,"Some cache(s) cannot be shown because of wrong blacklist status"), FormBase.OKB)).execute();
@@ -318,7 +317,7 @@
 			CacheHolder addiWpt;
 			for (int j=0; j<ch.addiWpts.getCount();j++){
 				addiWpt = (CacheHolder)ch.addiWpts.get(j);
-				if (!addiWpt.is_filtered) cachesAdded|=addCache(addiWpt);
+				if (!addiWpt.is_filtered()) cachesAdded|=addCache(addiWpt);
 			}
 		}
 		// Update screen if any cache was added
@@ -335,7 +334,7 @@
 			// Add cache reference to hidden list
 			cacheList.add(ch);
 			// Add Cache and cache icon to visible list
-			lstCaches.addItem((new MenuItem()).iconize(ch.wayPoint+"   "+ch.CacheName,CacheType.cache2Img(ch.type),true));
+			lstCaches.addItem((new MenuItem()).iconize(ch.getWayPoint()+"   "+ch.getCacheName(),CacheType.cache2Img(ch.getType()),true));
 		    dirty=true;
 			return true;
 		} else
@@ -430,7 +429,7 @@
 			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
 			for (int i=0; i<cacheList.size(); i++) {
 				// Put a > in front of the selected cache
-				outp.print((i==selectedIndex?">":"")+((CacheHolder)cacheList.get(i)).wayPoint+"\n");
+				outp.print((i==selectedIndex?">":"")+((CacheHolder)cacheList.get(i)).getWayPoint()+"\n");
 			}
 			outp.close();
 		} catch(Exception e) {

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/CalcPanel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -155,8 +155,8 @@
 	
 	// ch must be not null
 	public void setFields(CacheHolder ch){
-		if ( !ch.wayPoint.equalsIgnoreCase(lastWaypoint) ) {
-			lastWaypoint = ch.wayPoint;
+		if ( !ch.getWayPoint().equalsIgnoreCase(lastWaypoint) ) {
+			lastWaypoint = ch.getWayPoint();
 			if (ch.pos.isValid()) {
 				inpBearing.setText("0");
 				inpDistance.setText("0");
@@ -201,7 +201,7 @@
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				ch.LatLon = coordOut.toString();
 				ch.pos.set(coordOut);
-				ch.type = 51; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				ch.setType(51); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			

Modified: trunk/src/CacheWolf/DBStats.java
===================================================================
--- trunk/src/CacheWolf/DBStats.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/DBStats.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -24,8 +24,8 @@
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false && holder.is_filtered == false){
-				if(holder.wayPoint.startsWith("GC") || holder.wayPoint.startsWith("OC")) counter++;
+			if(holder.is_black() == false && holder.is_filtered() == false){
+				if(holder.getWayPoint().startsWith("GC") || holder.getWayPoint().startsWith("OC")) counter++;
 			}
 		}
 		return counter;
@@ -40,8 +40,8 @@
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false){
-				if(holder.wayPoint.startsWith("GC") || holder.wayPoint.startsWith("OC")) counter++;
+			if(holder.is_black() == false){
+				if(holder.getWayPoint().startsWith("GC") || holder.getWayPoint().startsWith("OC")) counter++;
 			}
 		}
 		return counter;
@@ -52,8 +52,8 @@
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_found == true) {
-				if(holder.wayPoint.startsWith("GC") || holder.wayPoint.startsWith("OC")) counter++;
+			if(holder.is_found() == true) {
+				if(holder.getWayPoint().startsWith("GC") || holder.getWayPoint().startsWith("OC")) counter++;
 			}
 		}
 		return counter;

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/DataMover.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -91,7 +91,7 @@
 		int count=0;
 		// Count the number of caches to move/delete/copy
 		for(int i = 0; i<size; i++) {
-			if(((CacheHolder)srcDB.get(i)).is_filtered==false) count++;
+			if(((CacheHolder)srcDB.get(i)).is_filtered()==false) count++;
 		}
 		myProgressBarForm pbf = new myProgressBarForm();
 		Handle h = new Handle();
@@ -102,7 +102,7 @@
 		// Now do the actual work
 		for(int i = size-1; i>=0; i--){
 			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.is_filtered==false){
+			if(srcHolder.is_filtered()==false){
 				h.progress = ((float)nProcessed++)/(float)count;
 				h.changed();
 				//Now do the copy/delete/move of the cache
@@ -195,7 +195,7 @@
 		 }
 		 public void doIt(int i,CacheHolder srcHolder) {
 			srcHolder.releaseCacheDetails();
-			deleteCacheFiles(srcHolder.wayPoint,profile.dataDir);
+			deleteCacheFiles(srcHolder.getWayPoint(),profile.dataDir);
 			srcDB.removeElementAt(i);
 		 }
 	}
@@ -206,49 +206,49 @@
 			 this.dstProfile=dstProfile;
 		 }
 		 public void doIt(int i,CacheHolder srcHolder) {
-			srcHolder.releaseCacheDetails();
-			// does cache exists in destDB ?
-			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
-			if (dstPos >= 0){
-				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-				copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-				// Update database
-				dstProfile.cacheDB.set(dstPos,srcHolder);
-			}
-			else {
-				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-				copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-				// Update database
-				dstProfile.cacheDB.add(srcHolder);
-			}
-		 }		 
-	}
+				srcHolder.releaseCacheDetails();
+				// does cache exists in destDB ?
+				int dstPos = dstProfile.getCacheIndex(srcHolder.getWayPoint());
+				if (dstPos >= 0){
+					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
+					copyCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
+					// Update database
+					dstProfile.cacheDB.set(dstPos,srcHolder);
+				}
+				else {
+					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
+					copyCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
+					// Update database
+					dstProfile.cacheDB.add(srcHolder);
+				}
+			 }		 
+		}
 
-	private class Mover extends Executor {
-		 Mover(String title, Profile dstProfile) {
-			 this.title=title;
-			 this.dstProfile=dstProfile;
-		 }
-		 public void doIt(int i,CacheHolder srcHolder) {
-			// does cache exists in destDB ?
-			srcHolder.releaseCacheDetails();
-			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
-			if (dstPos >= 0){
-				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-				moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-				// Update database
-				dstProfile.cacheDB.set(dstPos,srcHolder);
-				srcDB.removeElementAt(i);
-				i--;
-			}
-			else {
-				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-				moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-				// Update database
-				dstProfile.cacheDB.add(srcHolder);
-				srcDB.removeElementAt(i);
-				i--;
-			}
-		 }		 
+		private class Mover extends Executor {
+			 Mover(String title, Profile dstProfile) {
+				 this.title=title;
+				 this.dstProfile=dstProfile;
+			 }
+			 public void doIt(int i,CacheHolder srcHolder) {
+				// does cache exists in destDB ?
+				srcHolder.releaseCacheDetails();
+				int dstPos = dstProfile.getCacheIndex(srcHolder.getWayPoint());
+				if (dstPos >= 0){
+					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
+					moveCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
+					// Update database
+					dstProfile.cacheDB.set(dstPos,srcHolder);
+					srcDB.removeElementAt(i);
+					i--;
+				}
+				else {
+					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
+					moveCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
+					// Update database
+					dstProfile.cacheDB.add(srcHolder);
+					srcDB.removeElementAt(i);
+					i--;
+				}
+			 }		 
+		}
 	}
-}

Modified: trunk/src/CacheWolf/DescriptionPanel.java
===================================================================
--- trunk/src/CacheWolf/DescriptionPanel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/DescriptionPanel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -47,10 +47,10 @@
         } else {
             if (cache.hasSameMainCache(currCache))
                 scrollto = disp.getTopLine();
-            isHtml = cache.is_HTML;
+            isHtml = cache.is_HTML();
             if (cache.isAddiWpt()) {
                 CacheHolderDetail mainCache = cache.mainCache.getCacheDetails(true);
-                isHtml = mainCache.is_HTML;
+                isHtml = mainCache.is_HTML();
                 if (cache.LongDescription != null && cache.LongDescription.length() > 0)
                     desc = cache.LongDescription + (isHtml ? "<hr>\n" : "\n")
                             + mainCache.LongDescription;
@@ -162,7 +162,7 @@
 
 		Vm.showWait(true);
 		currLine = disp.getTopLine();
-		if (currCache.is_HTML)	disp.setHtml(desc);
+		if (currCache.is_HTML())	disp.setHtml(desc);
 		else				disp.setPlainText(currCache.LongDescription);
 		disp.scrollTo(currLine,false);
 		Vm.showWait(false);

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/DetailsPanel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -178,30 +178,30 @@
 		thisCache = ch;
 		dirty_notes = false;
 		dirty_details = false;
-		inpWaypoint.setText(ch.wayPoint);
-		inpName.setText(ch.CacheName);
+		inpWaypoint.setText(ch.getWayPoint());
+		inpName.setText(ch.getCacheName());
 	    btnWayLoc.setText(ch.pos.toString());
-		inpHidden.setText(ch.DateHidden);
-		inpOwner.setText(ch.CacheOwner);
-		if (ch.CacheStatus.length()>=10 && ch.CacheStatus.charAt(4)=='-')
-			chcStatus.setText(MyLocale.getMsg(318,"Found")+" "+ch.CacheStatus);
+		inpHidden.setText(ch.getDateHidden());
+		inpOwner.setText(ch.getCacheOwner());
+		if (ch.getCacheStatus().length()>=10 && ch.getCacheStatus().charAt(4)=='-')
+			chcStatus.setText(MyLocale.getMsg(318,"Found")+" "+ch.getCacheStatus());
 		else {
-			chcStatus.setText(ch.CacheStatus);
+			chcStatus.setText(ch.getCacheStatus());
 			// If the cache status contains a date, do not overwrite it with 'found' message
-			if(ch.is_found == true) chcStatus.setText(MyLocale.getMsg(318,"Found"));
+			if(ch.is_found() == true) chcStatus.setText(MyLocale.getMsg(318,"Found"));
 		}
-		chcType.setInt(transType(ch.type));
-		if(ch.is_black){
+		chcType.setInt(transType(ch.getType()));
+		if(ch.is_black()){
 			btnBlack.image = imgBlack;
 		} else {
 			btnBlack.image = imgBlackNo;
 		}
-		blackStatus=ch.is_black; 
+		blackStatus=ch.is_black(); 
 		blackStatusChanged=false;
 		btnBlack.repaintNow();
 		if (inpWaypoint.getText().length() == 0)
 			createWptName();
-		if(ch.has_bug == true) {
+		if(ch.has_bugs() == true) {
 			//btnShowBug.modify(Control.Disabled,1);
 			btnShowBug.image = imgShowBug;
 		} else {
@@ -209,17 +209,17 @@
 			btnShowBug.image = imgShowBugNo;
 		}
 		btnShowBug.repaintNow();
-		if(ch.CacheSize.equals("Micro")) chcSize.setInt(1);
-		if(ch.CacheSize.equals("Small")) chcSize.setInt(2);
-		if(ch.CacheSize.equals("Regular")) chcSize.setInt(3);
-		if(ch.CacheSize.equals("Large")) chcSize.setInt(4);
-		if(ch.CacheSize.equals("Other")) chcSize.setInt(5);
-		if(ch.CacheSize.equals("Very Large")) chcSize.setInt(6);
-		if(ch.CacheSize.equals("None")) chcSize.setInt(7);
-		if(ch.CacheSize.equals("Not chosen")) chcSize.setInt(7);
+		if(ch.getCacheSize().equals("Micro")) chcSize.setInt(1);
+		if(ch.getCacheSize().equals("Small")) chcSize.setInt(2);
+		if(ch.getCacheSize().equals("Regular")) chcSize.setInt(3);
+		if(ch.getCacheSize().equals("Large")) chcSize.setInt(4);
+		if(ch.getCacheSize().equals("Other")) chcSize.setInt(5);
+		if(ch.getCacheSize().equals("Very Large")) chcSize.setInt(6);
+		if(ch.getCacheSize().equals("None")) chcSize.setInt(7);
+		if(ch.getCacheSize().equals("Not chosen")) chcSize.setInt(7);
 		attV.showImages(ch.getCacheDetails(true).attributes);
-		lblTerr.setText((ch.terrain.length()>0) ? (MyLocale.getMsg(1001,"T")+": "+ch.terrain) : "");
-		lblDiff.setText((ch.hard.length()>0)    ? (MyLocale.getMsg(1000,"D")+": "+ch.hard) : ""); 
+		lblTerr.setText((ch.getTerrain().length()>0) ? (MyLocale.getMsg(1001,"T")+": "+ch.getTerrain()) : "");
+		lblDiff.setText((ch.getHard().length()>0)    ? (MyLocale.getMsg(1000,"D")+": "+ch.getHard()) : ""); 
 
 		if(isBigScreen)	mNotes.setText(ch.details.CacheNotes);
 	}
@@ -329,7 +329,7 @@
 			}
 			dirty_details = true;
 			needsTableUpdate  = true;
-			profile.hasUnsavedChanges=true;
+			// profile.hasUnsavedChanges=true;
 			if (ev.target==chcType) {
 				createWptName();
 			}
@@ -383,15 +383,15 @@
 				thisCache.getCacheDetails(true).addUserImage(profile);
 			}
 			else if(ev.target == btnBlack){
-				if(thisCache.is_black) {
-					thisCache.is_black = false;
+				if(thisCache.is_black()) {
+					thisCache.setBlack(false);
 					btnBlack.image = imgBlackNo;
 				}
 				else {
-					thisCache.is_black = true;
+					thisCache.setBlack(true);
 					btnBlack.image = imgBlack;
 				}
-				blackStatus = thisCache.is_black;
+				blackStatus = thisCache.is_black();
 				thisCache.setAttributesToAddiWpts();
 				btnBlack.repaintNow();
 				dirty_details=true;
@@ -401,7 +401,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = thisCache.LatLon;
 				ch.pos = new CWPoint( thisCache.pos );
-				ch.type = 51;
+				ch.setType(51);
 				Global.mainTab.newWaypoint(ch);
 			}
 			else if (ev.target == btnGoto){
@@ -442,7 +442,7 @@
 				if (dc.execute()==ewe.ui.FormBase.IDOK) {
 				  chcStatus.setText(MyLocale.getMsg(318,"Found")+" "+Convert.toString(dc.year)+"-"+MyLocale.formatLong(dc.month,"00")+"-"+MyLocale.formatLong(dc.day,"00")+" "+dc.time);
 				  dirty_details=true;
-				  profile.hasUnsavedChanges=true;
+				  //profile.hasUnsavedChanges=true;
 				}
 			}
 			else if (ev.target==btnHiddenDate) {
@@ -462,7 +462,7 @@
 				if (dc.execute()==ewe.ui.FormBase.IDOK) {
 				  inpHidden.setText(Convert.toString(dc.year)+"-"+MyLocale.formatLong(dc.month,"00")+"-"+MyLocale.formatLong(dc.day,"00"));
 				  dirty_details=true;
-				  profile.hasUnsavedChanges=true;
+				  //profile.hasUnsavedChanges=true;
 				}
 			}
 			ev.consumed=true;
@@ -476,33 +476,33 @@
 		  // Strip the found message if the status contains a date
 		if (chcStatus.getText().startsWith(MyLocale.getMsg(318,"Found")) && 
 				  chcStatus.getText().length()>=MyLocale.getMsg(318,"Found").length()+11)
-			  thisCache.CacheStatus = chcStatus.getText().substring(MyLocale.getMsg(318,"Found").length()+1);
+			  thisCache.setCacheStatus(chcStatus.getText().substring(MyLocale.getMsg(318,"Found").length()+1));
 		  else	  
-			  thisCache.CacheStatus = chcStatus.getText();
-		  thisCache.is_found = chcStatus.getText().startsWith(MyLocale.getMsg(318,"Found"));
-		  thisCache.CacheOwner = inpOwner.getText().trim();
-		  thisCache.is_owned = thisCache.CacheStatus.equals(MyLocale.getMsg(320,"Owner"));
+			  thisCache.setCacheStatus(chcStatus.getText());
+		  thisCache.setFound(chcStatus.getText().startsWith(MyLocale.getMsg(318,"Found")));
+		  thisCache.setCacheOwner(inpOwner.getText().trim());
+		  thisCache.setOwned(thisCache.getCacheStatus().equals(MyLocale.getMsg(320,"Owner")));
 		  // Avoid setting is_owned if alias is empty and username is empty
-		  if(thisCache.is_owned == false){
-			  thisCache.is_owned = (!pref.myAlias.equals("") && pref.myAlias.equals(thisCache.CacheOwner)) || 
-					        (!pref.myAlias2.equals("") && pref.myAlias2.equals(thisCache.CacheOwner));
+		  if(thisCache.is_owned() == false){
+			  thisCache.setOwned((!pref.myAlias.equals("") && pref.myAlias.equals(thisCache.getCacheOwner())) || 
+					        (!pref.myAlias2.equals("") && pref.myAlias2.equals(thisCache.getCacheOwner())));
 		  }
-		  thisCache.is_black = blackStatus;
-		  String oldWaypoint=thisCache.wayPoint;
-		  thisCache.wayPoint = inpWaypoint.getText().toUpperCase().trim();
-		  thisCache.CacheSize = chcSize.getText();
+		  thisCache.setBlack(blackStatus);
+		  String oldWaypoint=thisCache.getWayPoint();
+		  thisCache.setWayPoint(inpWaypoint.getText().toUpperCase().trim());
+		  thisCache.setCacheSize(chcSize.getText());
 		  // If the waypoint does not have a name, give it one
-		  if (thisCache.wayPoint.equals("")) { 
-			  thisCache.wayPoint=profile.getNewWayPointName();
+		  if (thisCache.getWayPoint().equals("")) { 
+			  thisCache.setWayPoint(profile.getNewWayPointName());
 		  }
 		  //Don't allow single letter names=> Problems in updateBearingDistance
 		  // This is a hack but faster than slowing down the loop in updateBearingDistance
-		  if (thisCache.wayPoint.length()<2) thisCache.wayPoint+=" ";
-		  thisCache.CacheName = inpName.getText().trim();
+		  if (thisCache.getWayPoint().length()<2) thisCache.setWayPoint(thisCache.getWayPoint()+" ");
+		  thisCache.setCacheName(inpName.getText().trim());
 		  thisCache.LatLon = thisCache.pos.toString();
-		  thisCache.DateHidden = inpHidden.getText().trim();
-		  int oldType=thisCache.type;
-		  thisCache.type = transSelect(chcType.getInt());
+		  thisCache.setDateHidden(inpHidden.getText().trim());
+		  int oldType=thisCache.getType();
+		  thisCache.setType(transSelect(chcType.getInt()));
 		 // thisCache.saveCacheDetails(profile.dataDir); // this is redundant, because all changes affecting the details are immediately saved
 		  // Now update the table
 		  CacheHolder ch = thisCache; // TODO variable ch is redundant
@@ -512,20 +512,20 @@
 	   *   - the old cachetype or the new cachetype were 'addi' and 
 	   *     the waypointname has changed 
 	   */
-	  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType) ||
-		 ((CacheType.isAddiWpt(ch.type) || CacheType.isAddiWpt(oldType)) &&
-		 !thisCache.wayPoint.equals(oldWaypoint))) {
+	  if (CacheType.isAddiWpt(ch.getType())!=CacheType.isAddiWpt(oldType) ||
+		 ((CacheType.isAddiWpt(ch.getType()) || CacheType.isAddiWpt(oldType)) &&
+		 !thisCache.getWayPoint().equals(oldWaypoint))) {
 			  // If we changed the type to addi, check that a parent exists
-			  if (CacheType.isAddiWpt(ch.type)) {
+			  if (CacheType.isAddiWpt(ch.getType())) {
 				  int idx;
-				  if (ch.wayPoint.length()<5)
+				  if (ch.getWayPoint().length()<5)
 					  idx=-1;
 				  else {
-					  idx=profile.getCacheIndex("GC"+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
-					  if (idx<0) idx=profile.getCacheIndex("OC"+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
-					  if (idx<0) idx=profile.getCacheIndex("CW"+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
+					  idx=profile.getCacheIndex("GC"+ ch.getWayPoint().substring(ch.getWayPoint().length() == 5?1:2));
+					  if (idx<0) idx=profile.getCacheIndex("OC"+ ch.getWayPoint().substring(ch.getWayPoint().length() == 5?1:2));
+					  if (idx<0) idx=profile.getCacheIndex("CW"+ ch.getWayPoint().substring(ch.getWayPoint().length() == 5?1:2));
 					  if (idx<0) (new MessageBox(MyLocale.getMsg(144,"Warning"),
-							  MyLocale.getMsg(734,"No main cache found for addi waypoint ")+" "+ch.wayPoint+
+							  MyLocale.getMsg(734,"No main cache found for addi waypoint ")+" "+ch.getWayPoint()+
 							  "\n"+MyLocale.getMsg(735,"Addi Waypoints must have the format xxYYYY, where xx are any 2 chars and YYYY are the main cache's chars after the GC"),FormBase.OKB)).execute();
 				  }
 				  profile.buildReferences(); // TODO this takes quite long -> use profile.setAddiRef instead
@@ -536,7 +536,7 @@
 		  // set status also on addi wpts
 		  ch.setAttributesToAddiWpts();
 		  dirty_notes=false;
-		  if (dirty_details) { Global.getProfile().hasUnsavedChanges=true;}
+		  // if (dirty_details) { Global.getProfile().hasUnsavedChanges=true;}
 		  dirty_details=false;
 		  setNeedsTableUpdate(false);
 		  if (thisCache.details != null) thisCache.details.hasUnsavedChanges = false;
@@ -596,12 +596,12 @@
 						tbjList=new TravelbugJourneyList();
 						tbjList.readTravelbugsFile();
 						// Add the tb to this list
-						tbjList.addTbPickup(tb,Global.getProfile().name,thisCache.wayPoint);
+						tbjList.addTbPickup(tb,Global.getProfile().name,thisCache.getWayPoint());
 						tbjList.saveTravelbugsFile();
 						tbjList=null;
 						setHtml(thisCache.getCacheDetails(true).Travelbugs.toHtml());
 						repaint();
-						thisCache.has_bug=thisCache.getCacheDetails(true).Travelbugs.size()>0;						
+						thisCache.setHas_bugs(thisCache.getCacheDetails(true).Travelbugs.size()>0);						
 					}
 				} else if (selectedItem==mnuDropTB) {
 					tbjList=new TravelbugJourneyList();
@@ -612,11 +612,11 @@
 					if (tbs.selectedItem>=0) {
 						Travelbug tb=tbl.getTB(tbs.selectedItem);
 						thisCache.getCacheDetails(true).Travelbugs.add(tb);
-						tbjList.addTbDrop(tb,Global.getProfile().name,thisCache.wayPoint);
+						tbjList.addTbDrop(tb,Global.getProfile().name,thisCache.getWayPoint());
 					}
 					tbjList.saveTravelbugsFile();
 					tbjList=null;
-					thisCache.has_bug=thisCache.getCacheDetails(true).Travelbugs.size()>0;
+					thisCache.setHas_bugs(thisCache.getCacheDetails(true).Travelbugs.size()>0);
 					setHtml(thisCache.getCacheDetails(true).Travelbugs.toHtml());
 					repaint();
 					dirty_details=true;

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/Filter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -191,7 +191,7 @@
 			} // for segments
 			for(int i = cacheDB.size()-1; i >=0 ; i--){
 				ch = (CacheHolder)cacheDB.get(i);
-				if(ch.is_filtered == false && ch.in_range == false) ch.is_filtered = true;
+				if(ch.is_filtered() == false && ch.in_range == false) ch.setFiltered(true);
 			}
 		}catch(FileNotFoundException fnex){
 			(new MessageBox("Error", "File not found", FormBase.OKB)).execute();
@@ -251,16 +251,16 @@
 	 */
 	public void setFilter() {
 		Profile profile=Global.getProfile();
-		archived     = profile.filterVar.charAt(0) == '1';
-		available    = profile.filterVar.charAt(1) == '1';
-		foundByMe    = profile.filterVar.charAt(2) == '1';
-		ownedByMe    = profile.filterVar.charAt(3) == '1';
-		notArchived  = profile.filterVar.charAt(4) == '1';
-		notAvailable = profile.filterVar.charAt(5) == '1';
-		notFoundByMe = profile.filterVar.charAt(6) == '1';
-		notOwnedByMe = profile.filterVar.charAt(7) == '1';
+		archived     = profile.getFilterVar().charAt(0) == '1';
+		available    = profile.getFilterVar().charAt(1) == '1';
+		foundByMe    = profile.getFilterVar().charAt(2) == '1';
+		ownedByMe    = profile.getFilterVar().charAt(3) == '1';
+		notArchived  = profile.getFilterVar().charAt(4) == '1';
+		notAvailable = profile.getFilterVar().charAt(5) == '1';
+		notFoundByMe = profile.getFilterVar().charAt(6) == '1';
+		notOwnedByMe = profile.getFilterVar().charAt(7) == '1';
 		typeMatchPattern=0;
-		String filterType=profile.filterType;
+		String filterType=profile.getFilterType();
 		if (filterType.charAt(0) == '1') typeMatchPattern|=TRADITIONAL;
 		if (filterType.charAt(1) == '1') typeMatchPattern|=MULTI;
 		if (filterType.charAt(2) == '1') typeMatchPattern|=VIRTUAL;
@@ -282,7 +282,7 @@
 		if (filterType.charAt(18) == '1') typeMatchPattern|=WHERIGO;
 		hasTypeMatchPattern= typeMatchPattern!=TYPE_ALL;
 		roseMatchPattern=0;
-		String filterRose=profile.filterRose;
+		String filterRose=profile.getFilterRose();
 		if (filterRose.charAt(0) == '1') roseMatchPattern|=NW;
 		if (filterRose.charAt(1) == '1') roseMatchPattern|=NNW;
 		if (filterRose.charAt(2) == '1') roseMatchPattern|=N;
@@ -301,7 +301,7 @@
 		if (filterRose.charAt(15) == '1') roseMatchPattern|=WNW;
 		hasRoseMatchPattern=roseMatchPattern!=ROSE_ALL;
 		sizeMatchPattern=0;
-		String filterSize=profile.filterSize;
+		String filterSize=profile.getFilterSize();
 		if (filterSize.charAt(0) == '1') sizeMatchPattern|=MICRO;
 		if (filterSize.charAt(1) == '1') sizeMatchPattern|=SMALL;
 		if (filterSize.charAt(2) == '1') sizeMatchPattern|=REGULAR;
@@ -309,17 +309,17 @@
 		if (filterSize.charAt(4) == '1') sizeMatchPattern|=VERYLARGE;
 		if (filterSize.charAt(5) == '1') sizeMatchPattern|=OTHER;
 		hasSizeMatchPattern=sizeMatchPattern!=SIZE_ALL;
-		distdirec = profile.filterDist.charAt(0) == 'L' ? SMALLER : GREATER; 
-		fscDist = Common.parseDouble(profile.filterDist.substring(1));  // Distance
-		diffdirec = profile.filterDiff.charAt(0) == 'L' ? SMALLER : 
-					(profile.filterDiff.charAt(0) == '=' ? EQUAL : GREATER );
-		fscDiff = Common.parseDouble(profile.filterDiff.substring(1));  // Difficulty
-		terrdirec = profile.filterTerr.charAt(0) == 'L' ? SMALLER : 
-				(profile.filterTerr.charAt(0) == '=' ? EQUAL : GREATER );
-		fscTerr = Common.parseDouble(profile.filterTerr.substring(1));  // Terrain
-		attributesYesPattern = profile.filterAttrYes;
-		attributesNoPattern = profile.filterAttrNo;
-		attributesChoice = profile.filterAttrChoice;
+		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER; 
+		fscDist = Common.parseDouble(profile.getFilterDist().substring(1));  // Distance
+		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : 
+					(profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER );
+		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1));  // Difficulty
+		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : 
+				(profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER );
+		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1));  // Terrain
+		attributesYesPattern = profile.getFilterAttrYes();
+		attributesNoPattern = profile.getFilterAttrNo();
+		attributesChoice = profile.getFilterAttrChoice();
 	}
 	
 	/**
@@ -329,6 +329,7 @@
 	*/
 	public void doFilter(){
 		Vector cacheDB=Global.getProfile().cacheDB;
+		Hashtable examinedCaches;
 		if (cacheDB.size()==0) return;
 		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
 			clearFilter();
@@ -336,194 +337,267 @@
 		}
 		Global.getProfile().selectionChanged = true;
 		CacheHolder ch;
-		int cacheTypePattern;
-		int cacheRosePattern;
-		int cacheSizePattern;
-		// Values from filterscreen are parsed outside the main filter loop (fsc=FilterSCreen)
-		double dummyd1;
-		//Loop db and match once against type pattern and once against rose pattern
-		//Default is_filtered = false, means will be displayed!
-		//If cache does not match type or rose pattern then is_filtered is set to true
-		// and we proceed to next cache (no further tests needed)
-		//Then we check the other filter criteria one by one: As soon as one is found that
-		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
-		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
+		examinedCaches = new Hashtable(cacheDB.size());
+		
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered = ch.is_black^Global.getProfile().showBlacklisted;
-			///////////////////////////////
-			// Filter criterium 1: Cache type
-			///////////////////////////////
-			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
-				cacheTypePattern = 0;
-				// As each cache can only have one type, we can use else if and set the type
-				if (ch.type == 0) cacheTypePattern = CUSTOM;
-				else if(ch.type == 2) cacheTypePattern = TRADITIONAL;
-				else if(ch.type == 3) cacheTypePattern = MULTI;
-				else if(ch.type == 4) cacheTypePattern = VIRTUAL;
-				else if(ch.type == 5) cacheTypePattern = LETTER;
-				else if(ch.type == 6) cacheTypePattern = EVENT;
-				else if(ch.type == 8) cacheTypePattern = MYSTERY;
-				else if(ch.type == 11) cacheTypePattern = WEBCAM;
-				else if(ch.type == 12) cacheTypePattern = LOCLESS;
-				else if(ch.type == 137)cacheTypePattern = EARTH;
-				else if(ch.type == 453)cacheTypePattern = MEGA;
-				else if(ch.type == 50)cacheTypePattern = PARKING;
-				else if(ch.type == 51)cacheTypePattern = STAGE;
-				else if(ch.type == 52)cacheTypePattern = QUESTION;
-				else if(ch.type == 53)cacheTypePattern = FINAL;
-				else if(ch.type == 54)cacheTypePattern = TRAILHEAD;
-				else if(ch.type == 55)cacheTypePattern = REFERENCE;
-				else if(ch.type == 13)cacheTypePattern = CITO;
-				else if(ch.type == 1858)cacheTypePattern = WHERIGO;
-				if ((cacheTypePattern & typeMatchPattern) == 0) { ch.is_filtered=true; continue; }
-			}			
-			///////////////////////////////
-			// Filter criterium 2: Bearing from centre
-			///////////////////////////////
-			// The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
-			// By using else if we can reduce the number of comparisons from 16 to just over 8
-			// By first checking the first letter, we can reduce the average number further to
-			// just under 5
-			if (hasRoseMatchPattern) {
-				if (ch.bearing.startsWith("N")) {
-					if(ch.bearing.equals("NW")) cacheRosePattern = NW;
-					else if(ch.bearing.equals("NNW")) cacheRosePattern = NNW;
-					else if(ch.bearing.equals("N")) cacheRosePattern = N;
-					else if(ch.bearing.equals("NNE")) cacheRosePattern = NNE;
-					else cacheRosePattern = NE;
-				} else if (ch.bearing.startsWith("E")) {
-					if(ch.bearing.equals("ENE")) cacheRosePattern = ENE;
-					else if(ch.bearing.equals("E")) cacheRosePattern = E;
-					else cacheRosePattern = ESE;
-				} else if (ch.bearing.startsWith("S")) {
-					if(ch.bearing.equals("SW")) cacheRosePattern = SW;
-					else if(ch.bearing.equals("SSW")) cacheRosePattern = SSW;
-					else if(ch.bearing.equals("S")) cacheRosePattern = S;
-					else if(ch.bearing.equals("SSE")) cacheRosePattern = SSE;
-					else cacheRosePattern = SE;
-				} else {
-					if(ch.bearing.equals("WNW")) cacheRosePattern = WNW;
-					else if(ch.bearing.equals("W")) cacheRosePattern = W;
-					else cacheRosePattern = WSW;
-				}
-				if ((cacheRosePattern & roseMatchPattern) == 0) { ch.is_filtered=true; continue; }
-			}			
-			///////////////////////////////
-			// Filter criterium 3: Distance
-			///////////////////////////////
-			if(fscDist>0.0){
-				dummyd1 = ch.kilom; 
-				if(distdirec == SMALLER && dummyd1 > fscDist)  { ch.is_filtered=true; continue; }
-				if(distdirec == GREATER && dummyd1 < fscDist)  { ch.is_filtered=true; continue; }
-			}
-			///////////////////////////////
-			// Filter criterium 4: Difficulty
-			///////////////////////////////
-			if(fscDiff>0.0){
-				dummyd1 = Common.parseDouble(ch.hard);
-				if(diffdirec == SMALLER && dummyd1 > fscDiff) { ch.is_filtered=true; continue; }
-				if(diffdirec == EQUAL && dummyd1 != fscDiff) { ch.is_filtered=true; continue; }
-				if(diffdirec == GREATER && dummyd1 < fscDiff) { ch.is_filtered=true; continue; }
-			}
-			///////////////////////////////
-			// Filter criterium 5: Terrain
-			///////////////////////////////
-			if(fscTerr>0.0){
-				dummyd1 = Common.parseDouble(ch.terrain);
-				if(terrdirec == SMALLER &&  dummyd1 > fscTerr) { ch.is_filtered=true; continue; }
-				if(terrdirec == EQUAL && dummyd1 != fscTerr) { ch.is_filtered=true; continue; }
-				if(terrdirec == GREATER &&  dummyd1 < fscTerr) { ch.is_filtered=true; continue; }
-			}
-//Vm.debug(ch.wayPoint+" Found"+ch.is_found+"  FoundyMe="+foundByMe+"   notFoundByMe="+notFoundByMe);
-//Vm.debug(ch.wayPoint+" Owned"+ch.is_owned+"  OwnedByMe="+ownedByMe+"   notOwnedByMe="+notOwnedByMe);
-//Vm.debug(ch.wayPoint+" Archived"+ch.is_archived+"  Archived="+archived+"   notArchived="+notArchived);
-//Vm.debug(ch.wayPoint+" Available"+ch.is_available+"  Available="+available+"   notAvailable="+notAvailable);
-//Vm.debug("Blacklisted: "+ch.is_black);
-			///////////////////////////////
-			// Filter criterium 6: Found by me
-			///////////////////////////////
-			if((ch.is_found && !foundByMe) ||
-			   (!ch.is_found && !notFoundByMe)){ ch.is_filtered=true; continue; }
-			///////////////////////////////
-			// Filter criterium 7: Owned by me
-			///////////////////////////////
-			if((ch.is_owned && !ownedByMe) ||
-			   (!ch.is_owned && !notOwnedByMe)) { ch.is_filtered=true; continue; }
+			if (examinedCaches.containsKey(ch)) continue;
 			
-			///////////////////////////////
-			// Filter criterium 8: Archived
-			///////////////////////////////
-			if((ch.is_archived && !archived) ||
-			   (!ch.is_archived && !notArchived)){ ch.is_filtered=true; continue; }
-
-			///////////////////////////////
-			// Filter criterium 9: Unavailable
-			///////////////////////////////
-			if((ch.is_available && !available) ||
-			   (!ch.is_available && !notAvailable)) { ch.is_filtered=true; continue; }
-			///////////////////////////////
-			// Filter criterium 10: Size
-			///////////////////////////////
-			if (hasSizeMatchPattern) {
-				cacheSizePattern=0;
-				if (ch.CacheSize.startsWith("M")) cacheSizePattern = MICRO;
-				else if (ch.CacheSize.startsWith("S")) cacheSizePattern = SMALL;
-				else if (ch.CacheSize.startsWith("R")) cacheSizePattern = REGULAR;
-				else if (ch.CacheSize.startsWith("L")) cacheSizePattern = LARGE;
-				else if (ch.CacheSize.startsWith("V")) cacheSizePattern = VERYLARGE;
-				else cacheSizePattern = OTHER;
-				if ((cacheSizePattern & sizeMatchPattern) == 0) { ch.is_filtered=true; continue; }
-			}
-			///////////////////////////////
-			// Filter criterium 11: Attributes
-			///////////////////////////////
-			if ( (attributesYesPattern != 0 || attributesNoPattern != 0) && ch.mainCache == null) {
-				if (attributesChoice == 0) {
-					// AND-condition:
-					if (
-						(ch.attributesYes & attributesYesPattern) != attributesYesPattern
-						|| (ch.attributesNo & attributesNoPattern) != attributesNoPattern )
-					{
-						ch.is_filtered=true;
-						continue;
-					}
-				} else if (attributesChoice == 1) {
-					// OR-condition:
-					if (
-						(ch.attributesYes & attributesYesPattern) == 0
-						&& (ch.attributesNo & attributesNoPattern) == 0 )
-					{
-						ch.is_filtered=true;
-						continue;
-					}
+			boolean filterCache = excludedByFilter(ch);
+			if (!filterCache && ch.mainCache!=null && ((typeMatchPattern & TYPE_MAIN) != 0)) {
+				if (examinedCaches.containsKey(ch.mainCache)) {
+					filterCache = ch.mainCache.is_filtered();
 				} else {
-					// NOT-condition:
-					if (
-						(ch.attributesYes & attributesYesPattern) != 0
-						|| (ch.attributesNo & attributesNoPattern) != 0 )
-					{
-						ch.is_filtered=true;
-						continue;
-					}
+					ch.mainCache.setFiltered(excludedByFilter(ch.mainCache));
+					filterCache = ch.mainCache.is_filtered();
+					examinedCaches.put(ch.mainCache, null);
 				}
 			}
-		} // for
-		// Ensure that for all main caches that are filtered, the addis are also filtered independently of 
-		// the filter status of the addi
-		if ((typeMatchPattern & TYPE_MAIN) != 0){ //exception: don't filter out correxpnding Addis, if only Addis are enabled
-			for(int i = cacheDB.size()-1; i >=0 ; i--){
-				ch = (CacheHolder)cacheDB.get(i);
-				if (ch.mainCache!=null) {
-					// We have found an addi, filte it if its parent is filtered
-					ch.is_filtered|=ch.mainCache.is_filtered;
-				}
-			}			
+			ch.setFiltered(filterCache);			
 		}
-		Global.getProfile().filterActive=FILTER_ACTIVE;
-		Global.getProfile().filterInverted=false;
-		Global.getProfile().hasUnsavedChanges=true;
+		Global.getProfile().setFilterActive(FILTER_ACTIVE);
+		Global.getProfile().setFilterInverted(false);
+		examinedCaches = null;
+		//Global.getProfile().hasUnsavedChanges=true;
 	}
+
+	public boolean excludedByFilter(CacheHolder ch) {
+		//Match once against type pattern and once against rose pattern
+		//Default is_filtered = false, means will be displayed!
+		//If cache does not match type or rose pattern then is_filtered is set to true
+		// and we proceed to next cache (no further tests needed)
+		//Then we check the other filter criteria one by one: As soon as one is found that
+		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
+		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
+	    int cacheTypePattern;
+	    int cacheRosePattern;
+	    int cacheSizePattern;
+	    double dummyd1;
+	    boolean cacheFiltered;
+	    do {
+	    	cacheFiltered = ch.is_black()^Global.getProfile().showBlacklisted();
+	    	if (cacheFiltered) break;
+	    	
+	        ///////////////////////////////
+	        // Filter criterium 1: Cache type
+	        ///////////////////////////////
+	        if (hasTypeMatchPattern) { // Only do the checks if we have a filter
+		        cacheTypePattern = 0;
+		        // As each cache can only have one type, we can use else if and set the type
+		        if (ch.getType() == 0)
+			        cacheTypePattern = CUSTOM;
+		        else if (ch.getType() == 2)
+			        cacheTypePattern = TRADITIONAL;
+		        else if (ch.getType() == 3)
+			        cacheTypePattern = MULTI;
+		        else if (ch.getType() == 4)
+			        cacheTypePattern = VIRTUAL;
+		        else if (ch.getType() == 5)
+			        cacheTypePattern = LETTER;
+		        else if (ch.getType() == 6)
+			        cacheTypePattern = EVENT;
+		        else if (ch.getType() == 8)
+			        cacheTypePattern = MYSTERY;
+		        else if (ch.getType() == 11)
+			        cacheTypePattern = WEBCAM;
+		        else if (ch.getType() == 12)
+			        cacheTypePattern = LOCLESS;
+		        else if (ch.getType() == 137)
+			        cacheTypePattern = EARTH;
+		        else if (ch.getType() == 453)
+			        cacheTypePattern = MEGA;
+		        else if (ch.getType() == 50)
+			        cacheTypePattern = PARKING;
+		        else if (ch.getType() == 51)
+			        cacheTypePattern = STAGE;
+		        else if (ch.getType() == 52)
+			        cacheTypePattern = QUESTION;
+		        else if (ch.getType() == 53)
+			        cacheTypePattern = FINAL;
+		        else if (ch.getType() == 54)
+			        cacheTypePattern = TRAILHEAD;
+		        else if (ch.getType() == 55)
+			        cacheTypePattern = REFERENCE;
+		        else if (ch.getType() == 13)
+			        cacheTypePattern = CITO;
+		        else if (ch.getType() == 1858)
+			        cacheTypePattern = WHERIGO;
+		        if ((cacheTypePattern & typeMatchPattern) == 0) {
+			        cacheFiltered = true; break;
+		        }
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 2: Bearing from centre
+	        ///////////////////////////////
+	        // The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
+	        // By using else if we can reduce the number of comparisons from 16 to just over 8
+	        // By first checking the first letter, we can reduce the average number further to
+	        // just under 5
+	        if (hasRoseMatchPattern) {
+		        if (ch.bearing.startsWith("N")) {
+			        if (ch.bearing.equals("NW"))
+				        cacheRosePattern = NW;
+			        else if (ch.bearing.equals("NNW"))
+				        cacheRosePattern = NNW;
+			        else if (ch.bearing.equals("N"))
+				        cacheRosePattern = N;
+			        else if (ch.bearing.equals("NNE"))
+				        cacheRosePattern = NNE;
+			        else
+				        cacheRosePattern = NE;
+		        } else if (ch.bearing.startsWith("E")) {
+			        if (ch.bearing.equals("ENE"))
+				        cacheRosePattern = ENE;
+			        else if (ch.bearing.equals("E"))
+				        cacheRosePattern = E;
+			        else
+				        cacheRosePattern = ESE;
+		        } else if (ch.bearing.startsWith("S")) {
+			        if (ch.bearing.equals("SW"))
+				        cacheRosePattern = SW;
+			        else if (ch.bearing.equals("SSW"))
+				        cacheRosePattern = SSW;
+			        else if (ch.bearing.equals("S"))
+				        cacheRosePattern = S;
+			        else if (ch.bearing.equals("SSE"))
+				        cacheRosePattern = SSE;
+			        else
+				        cacheRosePattern = SE;
+		        } else {
+			        if (ch.bearing.equals("WNW"))
+				        cacheRosePattern = WNW;
+			        else if (ch.bearing.equals("W"))
+				        cacheRosePattern = W;
+			        else
+				        cacheRosePattern = WSW;
+		        }
+		        if ((cacheRosePattern & roseMatchPattern) == 0) {
+			        cacheFiltered = true; break;
+		        }
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 3: Distance
+	        ///////////////////////////////
+	        if (fscDist > 0.0) {
+		        dummyd1 = ch.kilom;
+		        if (distdirec == SMALLER && dummyd1 > fscDist) {
+			        cacheFiltered = true; break;
+		        }
+		        if (distdirec == GREATER && dummyd1 < fscDist) {
+			        cacheFiltered = true; break;
+		        }
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 4: Difficulty
+	        ///////////////////////////////
+	        if (fscDiff > 0.0) {
+		        dummyd1 = Common.parseDouble(ch.getHard());
+		        if (diffdirec == SMALLER && dummyd1 > fscDiff) {
+			        cacheFiltered = true; break;
+		        }
+		        if (diffdirec == EQUAL && dummyd1 != fscDiff) {
+			        cacheFiltered = true; break;
+		        }
+		        if (diffdirec == GREATER && dummyd1 < fscDiff) {
+			        cacheFiltered = true; break;
+		        }
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 5: Terrain
+	        ///////////////////////////////
+	        if (fscTerr > 0.0) {
+		        dummyd1 = Common.parseDouble(ch.getTerrain());
+		        if (terrdirec == SMALLER && dummyd1 > fscTerr) {
+			        cacheFiltered = true; break;
+		        }
+		        if (terrdirec == EQUAL && dummyd1 != fscTerr) {
+			        cacheFiltered = true; break;
+		        }
+		        if (terrdirec == GREATER && dummyd1 < fscTerr) {
+			        cacheFiltered = true; break;
+		        }
+	        }
+	        //Vm.debug(ch.wayPoint+" Found"+ch.is_found+"  FoundyMe="+foundByMe+"   notFoundByMe="+notFoundByMe);
+	        //Vm.debug(ch.wayPoint+" Owned"+ch.is_owned+"  OwnedByMe="+ownedByMe+"   notOwnedByMe="+notOwnedByMe);
+	        //Vm.debug(ch.wayPoint+" Archived"+ch.is_archived+"  Archived="+archived+"   notArchived="+notArchived);
+	        //Vm.debug(ch.wayPoint+" Available"+ch.is_available+"  Available="+available+"   notAvailable="+notAvailable);
+	        //Vm.debug("Blacklisted: "+ch.is_black);
+	        ///////////////////////////////
+	        // Filter criterium 6: Found by me
+	        ///////////////////////////////
+	        if ((ch.is_found() && !foundByMe) || (!ch.is_found() && !notFoundByMe)) {
+		        cacheFiltered = true; break;
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 7: Owned by me
+	        ///////////////////////////////
+	        if ((ch.is_owned() && !ownedByMe) || (!ch.is_owned() && !notOwnedByMe)) {
+		        cacheFiltered = true; break;
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 8: Archived
+	        ///////////////////////////////
+	        if ((ch.is_archived() && !archived) || (!ch.is_archived() && !notArchived)) {
+		        cacheFiltered = true; break;
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 9: Unavailable
+	        ///////////////////////////////
+	        if ((ch.is_available() && !available) || (!ch.is_available() && !notAvailable)) {
+		        cacheFiltered = true; break;
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 10: Size
+	        ///////////////////////////////
+	        if (hasSizeMatchPattern) {
+		        cacheSizePattern = 0;
+		        if (ch.getCacheSize().startsWith("M"))
+			        cacheSizePattern = MICRO;
+		        else if (ch.getCacheSize().startsWith("S"))
+			        cacheSizePattern = SMALL;
+		        else if (ch.getCacheSize().startsWith("R"))
+			        cacheSizePattern = REGULAR;
+		        else if (ch.getCacheSize().startsWith("L"))
+			        cacheSizePattern = LARGE;
+		        else if (ch.getCacheSize().startsWith("V"))
+			        cacheSizePattern = VERYLARGE;
+		        else
+			        cacheSizePattern = OTHER;
+		        if ((cacheSizePattern & sizeMatchPattern) == 0) {
+			        cacheFiltered = true; break;
+		        }
+	        }
+	        ///////////////////////////////
+	        // Filter criterium 11: Attributes
+	        ///////////////////////////////
+	        if ((attributesYesPattern != 0 || attributesNoPattern != 0) && ch.mainCache == null) {
+		        if (attributesChoice == 0) {
+			        // AND-condition:
+			        if ((ch.getAttributesYes() & attributesYesPattern) != attributesYesPattern
+			                || (ch.getAttributesNo() & attributesNoPattern) != attributesNoPattern) {
+				        cacheFiltered = true;
+				        break;
+			        }
+		        } else if (attributesChoice == 1) {
+			        // OR-condition:
+			        if ((ch.getAttributesYes() & attributesYesPattern) == 0
+			                && (ch.getAttributesNo() & attributesNoPattern) == 0) {
+				        cacheFiltered = true;
+				        break;
+			        }
+		        } else {
+			        // NOT-condition:
+			        if ((ch.getAttributesYes() & attributesYesPattern) != 0
+			                || (ch.getAttributesNo() & attributesNoPattern) != 0) {
+				        cacheFiltered = true;
+				        break;
+			        }
+		        }
+	        }
+	        break;
+        } while (true);
+		return cacheFiltered;
+    }
 	
 	/**
 	*	Invert is_filtered flag on all caches
@@ -533,16 +607,16 @@
 		CacheHolder ch;
 		if (cacheDB.size()==0) return;
 		Global.getProfile().selectionChanged = true;
-		boolean showBlackListed=Global.getProfile().showBlacklisted;
+		boolean showBlackListed=Global.getProfile().showBlacklisted();
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.is_black==showBlackListed)
-				ch.is_filtered=!ch.is_filtered; // Only invert those that would be shown under blacklist filter
+			if (ch.is_black()==showBlackListed)
+				ch.setFiltered(!ch.is_filtered()); // Only invert those that would be shown under blacklist filter
 			else
-				ch.is_filtered=true; // Hide all those that have the wrong is_black status
+				ch.setFiltered(true); // Hide all those that have the wrong is_black status
 		}
-		Global.getProfile().filterInverted=!Global.getProfile().filterInverted;
-		Global.getProfile().hasUnsavedChanges=true;
+		Global.getProfile().setFilterInverted(!Global.getProfile().isFilterInverted());
+		//Global.getProfile().hasUnsavedChanges=true;
 	}
 	
 	/**
@@ -554,24 +628,24 @@
 		CacheHolder ch;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=(ch.is_black^Global.getProfile().showBlacklisted) ; // Always filter blacklisted caches
+			ch.setFiltered((ch.is_black()^Global.getProfile().showBlacklisted())) ; // Always filter blacklisted caches
 		}
-		Global.getProfile().filterActive=FILTER_INACTIVE;
-		Global.getProfile().filterInverted=false;
-		Global.getProfile().hasUnsavedChanges=true;
+		Global.getProfile().setFilterActive(FILTER_INACTIVE);
+		Global.getProfile().setFilterInverted(false);
+		//Global.getProfile().hasUnsavedChanges=true;
 	}
 
 	public boolean hasFilter() {
 		Profile prof=Global.getProfile();
-		return !(prof.filterType.equals(Profile.FILTERTYPE) &&
-		    prof.filterRose.equals(Profile.FILTERROSE) &&
-		    prof.filterVar.equals(Profile.FILTERVAR) &&
-		    prof.filterSize.equals(Profile.FILTERSIZE) &&
-		    prof.filterDist.equals("L") &&
-		    prof.filterDiff.equals("L") &&
-		    prof.filterTerr.equals("L") &&
-		    prof.filterAttrYes == 0l &&
-		    prof.filterAttrNo == 0l);
+		return !(prof.getFilterType().equals(Profile.FILTERTYPE) &&
+		    prof.getFilterRose().equals(Profile.FILTERROSE) &&
+		    prof.getFilterVar().equals(Profile.FILTERVAR) &&
+		    prof.getFilterSize().equals(Profile.FILTERSIZE) &&
+		    prof.getFilterDist().equals("L") &&
+		    prof.getFilterDiff().equals("L") &&
+		    prof.getFilterTerr().equals("L") &&
+		    prof.getFilterAttrYes() == 0l &&
+		    prof.getFilterAttrNo() == 0l);
 	}
 
 }

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/FilterScreen.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -318,12 +318,12 @@
 		//////////////////////////
 		// Panel 1 - Bearing & Distance
 		//////////////////////////
-		if (prof.filterDist.length()>1) {
-			if (prof.filterDist.charAt(0)=='L')
+		if (prof.getFilterDist().length()>1) {
+			if (prof.getFilterDist().charAt(0)=='L')
 				chcDist.select(0);
 			else
 				chcDist.select(1);
-			String dist = prof.filterDist.substring(1);
+			String dist = prof.getFilterDist().substring(1);
 			if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
 				double distValue = java.lang.Double.valueOf(dist).doubleValue();
 				double newDistValue = Metrics.convertUnit(distValue, Metrics.KILOMETER, Metrics.MILES);
@@ -334,7 +334,7 @@
 			chcDist.select(0);
 			inpDist.setText("");
 		}
-		String fltRose=prof.filterRose;
+		String fltRose=prof.getFilterRose();
 		chkNW.state   = fltRose.charAt(0) == '1';
 		chkNNW.state  = fltRose.charAt(1) == '1';
 		chkN.state    = fltRose.charAt(2) == '1';
@@ -358,7 +358,7 @@
 		//////////////////////////
 		// Panel 2 - Cache attributes
 		//////////////////////////
-		String fltVar=prof.filterVar;
+		String fltVar=prof.getFilterVar();
 		chkArchived.state      = fltVar.charAt(0) == '1';
 		chkAvailable.state     = fltVar.charAt(1) == '1';
 		chkFound.state         = fltVar.charAt(2) == '1';
@@ -371,27 +371,27 @@
 		//////////////////////////
 		// Panel 3 - Cache ratings
 		//////////////////////////
-		if (prof.filterDiff.length()>1) {
-			if (prof.filterDiff.charAt(0)=='L')
+		if (prof.getFilterDiff().length()>1) {
+			if (prof.getFilterDiff().charAt(0)=='L')
 				chcDiff.select(0);
-			else if (prof.filterDiff.charAt(0)=='=')
+			else if (prof.getFilterDiff().charAt(0)=='=')
 				chcDiff.select(1);
 			else
 				chcDiff.select(2);
-			inpDiff.setText(prof.filterDiff.substring(1));
+			inpDiff.setText(prof.getFilterDiff().substring(1));
 		} else {
 			chcDiff.select(0);
 			inpDiff.setText("");
 		}
 
-		if (prof.filterTerr.length()>1) {
-			if (prof.filterTerr.charAt(0)=='L')
+		if (prof.getFilterTerr().length()>1) {
+			if (prof.getFilterTerr().charAt(0)=='L')
 				chcTerr.select(0);
-			else if (prof.filterTerr.charAt(0)=='=')
+			else if (prof.getFilterTerr().charAt(0)=='=')
 				chcTerr.select(1);
 			else
 				chcTerr.select(2);
-			inpTerr.setText(prof.filterTerr.substring(1));
+			inpTerr.setText(prof.getFilterTerr().substring(1));
 		} else {
 			chcTerr.select(0);
 			inpTerr.setText("");
@@ -402,7 +402,7 @@
 		// Panel 4 - Cache types
 		//////////////////////////
 		
-		String fltType=prof.filterType;
+		String fltType=prof.getFilterType();
 		chkTrad.state       = fltType.charAt(0) == '1';
 		chkMulti.state      = fltType.charAt(1) == '1';
 		chkVirtual.state    = fltType.charAt(2) == '1';
@@ -433,7 +433,7 @@
 		//////////////////////////
 		// Panel 6 - Cache container
 		//////////////////////////
-		String fltSize=prof.filterSize;
+		String fltSize=prof.getFilterSize();
 		chkMicro.state      = fltSize.charAt(0) == '1';
 		chkSmall.state      = fltSize.charAt(1) == '1';
 		chkRegular.state    = fltSize.charAt(2) == '1';
@@ -448,8 +448,8 @@
 		//////////////////////////
 		// Panel 8 - Cache attributes
 		//////////////////////////
-		attV.setSelectionMasks( prof.filterAttrYes, prof.filterAttrNo );
-		chcAttrib.select(prof.filterAttrChoice);
+		attV.setSelectionMasks( prof.getFilterAttrYes(), prof.getFilterAttrNo() );
+		chcAttrib.select(prof.getFilterAttrChoice());
 		
 		// Adjust colors of buttons depending on which filters are active
 		setColors();
@@ -583,15 +583,15 @@
 				Vm.showWait(true);
 				//Save filter required
 				Profile pfl = Global.getProfile();
-				pfl.filterVar = (chkArchived.state    ? "1" : "0") +
+				pfl.setFilterVar((chkArchived.state    ? "1" : "0") +
 							(chkAvailable.state   ? "1" : "0") +
 							(chkFound.state       ? "1" : "0") +
 							(chkOwned.state       ? "1" : "0") +
 							(chkNotArchived.state ? "1" : "0") +
 							(chkNotAvailable.state? "1" : "0") +
 							(chkNotFound.state    ? "1" : "0") +
-							(chkNotOwned.state    ? "1" : "0");							
-				pfl.filterType =(chkTrad.state    ? "1" : "0") +
+							(chkNotOwned.state    ? "1" : "0"));							
+				pfl.setFilterType((chkTrad.state    ? "1" : "0") +
 								(chkMulti.state   ? "1" : "0") +
 								(chkVirtual.state ? "1" : "0") +
 								(chkLetter.state  ? "1" : "0") +
@@ -609,8 +609,8 @@
 								(chkTrailhead.state ? "1" : "0") +
 								(chkReference.state ? "1" : "0")+
 								(chkCito.state ? "1" : "0")+
-								(chkWherigo.state ? "1" : "0");
-				pfl.filterRose = (chkNW.state  ? "1":"0")+
+								(chkWherigo.state ? "1" : "0"));
+				pfl.setFilterRose((chkNW.state  ? "1":"0")+
 							 (chkNNW.state ? "1":"0")+
 							 (chkN.state   ? "1":"0")+
 							 (chkNNE.state ? "1":"0")+
@@ -625,13 +625,13 @@
 							 (chkSW.state  ? "1":"0")+
 							 (chkWSW.state ? "1":"0")+
 							 (chkW.state   ? "1":"0")+
-							 (chkWNW.state ? "1":"0");
-				pfl.filterSize =(chkMicro.state ? "1" : "0")+
+							 (chkWNW.state ? "1":"0"));
+				pfl.setFilterSize((chkMicro.state ? "1" : "0")+
 							(chkSmall.state ? "1" : "0")+
 							(chkRegular.state ? "1" : "0")+
 							(chkLarge.state ? "1" : "0")+
 							(chkVeryLarge.state ? "1" : "0")+
-							(chkOther.state ? "1" : "0");
+							(chkOther.state ? "1" : "0"));
 				
 				// Distance: If Metric system is set to imperial units,
 				//           then the entered value is meant to be miles,
@@ -646,29 +646,29 @@
 					}
 				}
 				if(chcDist.selectedIndex == 0) { 
-					pfl.filterDist="L"+newDistance;
+					pfl.setFilterDist("L"+newDistance);
 				} else { 
-					pfl.filterDist="G"+newDistance;
+					pfl.setFilterDist("G"+newDistance);
 				}
 					
 				if(chcDiff.selectedIndex == 0) { 
-					pfl.filterDiff="L"+inpDiff.getText();
+					pfl.setFilterDiff("L"+inpDiff.getText());
 				} else if(chcDiff.selectedIndex == 1) { 
-					pfl.filterDiff="="+inpDiff.getText();
+					pfl.setFilterDiff("="+inpDiff.getText());
 				} else {	
-					pfl.filterDiff="G"+inpDiff.getText();
+					pfl.setFilterDiff("G"+inpDiff.getText());
 				}	
 					
 				if(chcTerr.selectedIndex == 0) { 
-					pfl.filterTerr="L"+inpTerr.getText();
+					pfl.setFilterTerr("L"+inpTerr.getText());
 				} else if(chcTerr.selectedIndex == 1){ 
-					pfl.filterTerr="="+inpTerr.getText();
+					pfl.setFilterTerr("="+inpTerr.getText());
 				} else { 
-					pfl.filterTerr="G"+inpTerr.getText();
+					pfl.setFilterTerr("G"+inpTerr.getText());
 				}
-				pfl.filterAttrYes = attV.selectionMaskYes;
-				pfl.filterAttrNo = attV.selectionMaskNo;
-				pfl.filterAttrChoice = chcAttrib.selectedIndex;
+				pfl.setFilterAttrYes(attV.selectionMaskYes);
+				pfl.setFilterAttrNo(attV.selectionMaskNo);
+				pfl.setFilterAttrChoice(chcAttrib.selectedIndex);
 				Filter flt = new Filter();
 				flt.setFilter();
 				flt.doFilter();

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -56,7 +56,7 @@
 		CacheHolder ch;
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			DBindex.put(ch.wayPoint, new Integer(i));
+			DBindex.put(ch.getWayPoint(), new Integer(i));
 		}//for
 	}
 /*	skg: This Constructor is not referenced, therefore commented out 
@@ -85,7 +85,7 @@
 */	
 	public void doIt(int how){
 		Filter flt = new Filter();
-		boolean wasFiltered = (profile.filterActive==Filter.FILTER_ACTIVE);
+		boolean wasFiltered = (profile.getFilterActive()==Filter.FILTER_ACTIVE);
 		flt.clearFilter();
 		try{
 			ewe.io.Reader r;
@@ -182,27 +182,23 @@
 
 		if (name.equals("groundspeak:cache")) {
 			inCache = true;
-			if (atts.getValue("available").equals("True"))
-				chD.is_available = true;
-			else 
-				chD.is_available = false;
-			if (atts.getValue("archived").equals("True"))
-				chD.is_archived = true;
-			else
-				chD.is_archived = false;
+			chD.setAvailable(atts.getValue("available").equals("True"));
+			chD.setArchived(atts.getValue("archived").equals("True"));
 			return;
 		}
 
 		if (name.equals("geocache")) {
+			boolean available = false;
+			boolean archived  = false;
 			inCache=true;
 			// get status
 			String status = new String(atts.getValue("status"));
-			chD.is_available = false;
-			chD.is_archived = false;
-			if (status.equals("Available")) chD.is_available = true;
-			if (status.equals("Unavailable")) chD.is_available = false;
-			if (status.equals("Draft")) chD.is_available = false;
-			if (status.equals("Archived")) chD.is_archived = true;
+			if (status.equals("Available")) available = true;
+			else if (status.equals("Unavailable")) available = false;
+			else if (status.equals("Draft")) available = false;
+			else if (status.equals("Archived")) archived = true;
+			chD.setArchived(archived);
+			chD.setAvailable(available);
 			return;
 		}
 		
@@ -212,15 +208,11 @@
 
 		
 		if (name.equals("groundspeak:long_description")) {
-			if (atts.getValue("html").toLowerCase().equals("true"))
-				chD.is_HTML= true;
-			else 
-				chD.is_HTML = false;
-			
+			chD.setHTML(atts.getValue("html").toLowerCase().equals("true"));
 		}
 		if (name.equals("description") || name.equals("terra:description") ) {
 			//set HTML always to true if from oc.de or TC
-			chD.is_HTML= true;
+			chD.setHTML(true);
 		}
 
 		if (name.equals("groundspeak:logs") || name.equals("logs") || name.equals("terra:logs")) {
@@ -269,8 +261,8 @@
 				chD.CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
 				if((logIcon.equals("icon_smile.gif") || logIcon.equals("11.png") || logIcon.equals("icon_attended.gif")) && 
 						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && logFinder.equalsIgnoreCase(pref.myAlias2)))) {
-							chD.CacheStatus=logDate;
-							chD.is_found=true;
+							chD.setCacheStatus(logDate);
+							chD.setFound(true);
 							chD.OwnLogId = logId;
 							chD.OwnLog = new Log(logIcon,logDate,logFinder,logData);
 				}
@@ -281,17 +273,17 @@
 		if (name.equals("wpt")){
 			// Add cache Data only, if waypoint not already in database
 			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
-			int index=searchWpt(chD.wayPoint);
+			int index=searchWpt(chD.getWayPoint());
 			//Vm.debug("here ?!?!?");
 			//Vm.debug("chould be new!!!!");
 			if (index == -1){
-				chD.noFindLogs=chD.CacheLogs.countNotFoundLogs();
-				chD.is_new = true;
+				chD.setNoFindLogs(chD.CacheLogs.countNotFoundLogs());
+				chD.setNew(true);
 				cacheDB.add(new CacheHolder(chD));
 				// don't spider additional waypoints, so check
 				// if waypoint starts with "GC"
 				if(doSpider == true) {
-					if(spiderOK == true && chD.is_archived == false){
+					if(spiderOK == true && chD.is_archived() == false){
 							if(chD.LatLon.length() > 1){
 							if(getMaps){
 								ParseLatLon pll = new ParseLatLon(chD.LatLon,".");
@@ -301,7 +293,7 @@
 								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 							}
 						}
-					if(chD.wayPoint.startsWith("GC")|| fromTC) {
+					if(chD.getWayPoint().startsWith("GC")|| fromTC) {
 						//spiderImages();
 						spiderImagesUsingSpider();
 						//Rename image sources
@@ -346,8 +338,8 @@
 			return;
 		}
 		if (name.equals("sym")&& strData.endsWith("Found")) {
-			chD.is_found = true;
-			chD.CacheStatus = MyLocale.getMsg(318,"Found");
+			chD.setFound(true);
+			chD.setCacheStatus(MyLocale.getMsg(318,"Found"));
 			return;
 		}
 		if (name.equals("groundspeak:travelbugs")) {
@@ -359,7 +351,7 @@
 			Travelbug tb=new Travelbug(strData);
 			chD.Travelbugs.add(tb);
 			//holder.Bugs += "<b>Name:</b> " + strData + "<br><hr>";
-			chD.has_bug = true;
+			chD.setHas_bugs(true);
 			return;
 		}
 		
@@ -368,7 +360,7 @@
 			//Date = strData.substring(5,7); // month
 			//Date += "/" + strData.substring(8,10); // day
 			//Date += "/" + strData.substring(0,4); // year
-			chD.DateHidden = strData.substring(0,10); //Date;
+			chD.setDateHidden(strData.substring(0,10)); //Date;
 			return;
 		}
 		// cache information
@@ -377,7 +369,7 @@
 		}
 		
 		if (name.equals("name") && inWpt && !inCache) {
-			chD.wayPoint = strData;
+			chD.setWayPoint(strData);
 			//msgA.setText("import " + strData);
 			return;
 		}
@@ -386,7 +378,7 @@
 		// fill name with contents of <desc>, in case of gc.com the name is
 		// later replaced by the contents of <groundspeak:name> which is shorter
 		if (name.equals("desc")&& inWpt ) {
-			chD.CacheName = strData;
+			chD.setCacheName(strData);
 			//Vm.debug("CacheName: " + strData);
 			//msgA.setText("import " + strData);
 			return;
@@ -399,40 +391,40 @@
 		// Text for additional waypoints, no HTML
 		if (name.equals("cmt")&& inWpt){
 			chD.LongDescription = strData;
-			chD.is_HTML = false;
+			chD.setHTML(false);
 			return;
 		}
 		
 		// aditional wapypoint
 		if (name.equals("type")&& inWpt && !inCache && strData.startsWith("Waypoint")){
-			chD.type= CacheType.typeText2Number(strData);
-			chD.CacheSize = "None";
+			chD.setType(CacheType.typeText2Number(strData));
+			chD.setCacheSize("None");
 		}
 
 		
 		if ((name.equals("groundspeak:name")|| name.equals("terra:name")) && inCache) {
-			chD.CacheName = strData;
+			chD.setCacheName(strData);
 			return;
 		}
 		if (name.equals("groundspeak:owner") || name.equals("owner")||name.equals("terra:owner")) {
-			chD.CacheOwner = strData;
-			if(pref.myAlias.equals(strData)) chD.is_owned = true;
+			chD.setCacheOwner(strData);
+			if(pref.myAlias.equals(strData)) chD.setOwned(true);
 			return;
 		}
 		if (name.equals("groundspeak:difficulty") || name.equals("difficulty") || name.equals("terra:mental_challenge")) {
-			chD.hard = strData.replace('.',',');
+			chD.setHard(strData.replace('.',','));
 			return;
 		}
 		if (name.equals("groundspeak:terrain")|| name.equals("terrain")|| name.equals("terra:physical_challenge")) {
-			chD.terrain = strData.replace('.',',');
+			chD.setTerrain(strData.replace('.',','));
 			return;
 		}
 		if ((name.equals("groundspeak:type") || name.equals("type")|| name.equals("terra:style"))&& inCache){
-			chD.type= CacheType.typeText2Number(strData);
+			chD.setType(CacheType.typeText2Number(strData));
 			return;
 		}
 		if (name.equals("groundspeak:container")|| name.equals("container")){
-			chD.CacheSize = strData;
+			chD.setCacheSize(strData);
 			return;
 		}
 		if (name.equals("groundspeak:country")|| name.equals("country")){
@@ -444,17 +436,17 @@
 			return;
 		}
 		if (name.equals("terra:size")){
-			chD.CacheSize = TCSizetoText(strData);
+			chD.setCacheSize(TCSizetoText(strData));
 		}
 
 		if (name.equals("groundspeak:short_description")|| name.equals("summary")) {
-			if (chD.is_HTML)	chD.LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
+			if (chD.is_HTML())	chD.LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
 			else chD.LongDescription =strData+"\n";
 			return;
 		}
 
 		if (name.equals("groundspeak:long_description")|| name.equals("description")|| name.equals("terra:description")) {
-			if (chD.is_HTML)	chD.LongDescription +=SafeXML.cleanback(strData);
+			if (chD.is_HTML())	chD.LongDescription +=SafeXML.cleanback(strData);
 			else chD.LongDescription +=strData;
 			return;
 		}
@@ -547,7 +539,7 @@
 				imgSpider.getImages(chD.LongDescription, chD);
 		}
 		else {
-			addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + chD.wayPoint ;
+			addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + chD.getWayPoint() ;
 			//Vm.debug(addr + "|");
 			cacheText = SpiderGC.fetch(addr);
 			imgSpider.getImages(cacheText, chD);

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -56,7 +56,7 @@
 		CacheHolder ch;
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			DBindexWpt.put(ch.wayPoint, new Integer(i));
+			DBindexWpt.put(ch.getWayPoint(), new Integer(i));
 		}//for
 	}
 	
@@ -100,20 +100,20 @@
 	
 	public void endElement(String name){
 		if (name.equals("name")){
-			holder.CacheName = strData;
+			holder.setCacheName(strData);
 		}
 
 		if (name.equals("waypoint")){
 			int index;
-			index = searchWpt(holder.wayPoint);
+			index = searchWpt(holder.getWayPoint());
 			if (index == -1){
-				holder.is_new = true;
+				holder.setNew(true);
 				cacheDB.add(new CacheHolder(holder));
-				DBindexWpt.put(holder.wayPoint, new Integer(cacheDB.size()-1));
+				DBindexWpt.put(holder.getWayPoint(), new Integer(cacheDB.size()-1));
 			}
 			// update (overwrite) data
 			else {
-				holder.is_new = false;
+				holder.setNew(false);
 				cacheDB.set(index, new CacheHolder(holder));
 			}
 			// save all  (after each cache???)
@@ -157,7 +157,7 @@
 		index = searchWpt(wpt);
 		if (index == -1){
 			ch = new CacheHolderDetail();
-			ch.wayPoint = wpt;
+			ch.setWayPoint(wpt);
 			return ch;
 		}
 		ch = new CacheHolderDetail((CacheHolder) cacheDB.get(index));

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/MainForm.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -86,9 +86,6 @@
 			profile.readIndex();
 			pref.curCentrePt.set(profile.centre);
 			profile.updateBearingDistance();
-			boolean saveHasUnsavedChanges = profile.hasUnsavedChanges;
-			profile.restoreFilter(); // this method sets hasUnsavedChanges to true
-			profile.hasUnsavedChanges = saveHasUnsavedChanges ; // in case that the profile is new, it hasUnsavedChanges, so set it back
 			setTitle("Cachewolf "+Version.getRelease()+" - "+profile.name);
 		} catch (Exception e){
 			if(pref.debug == true) Vm.debug("MainForm:: Exception:: " + e.toString());

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/MainMenu.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -160,7 +160,7 @@
 		filterMenuItems[6] = filtNonSelected = new MenuItem(MyLocale.getMsg(1011,"Filter out non selected"));
 		filterMenuItems[7] = mnuSeparator;
 		filterMenuItems[8] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
-        filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+        filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
 		//filterMenuItems[9] = mnuSeparator;
 		//filterMenuItems[10] = cacheTour;
 
@@ -264,7 +264,7 @@
 			if(mev.selectedItem == mnuNewProfile){
 				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {
 					pref.curCentrePt = new CWPoint(profile.centre);
-		            filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+		            filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
 					tbp.refreshTable();
 				}
 			}
@@ -281,7 +281,7 @@
 					profile.readIndex();
 					Vm.showWait(infB, false);
 					pref.curCentrePt.set(profile.centre);
-                    filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+                    filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
 					Global.mainForm.setTitle("Cachewolf "+Version.getRelease()+" - "+profile.name);
 					infB.close(0);
 					tbp.resetModel();
@@ -341,15 +341,15 @@
 						}
 					}
 				}
-                Global.getProfile().showBlacklisted = false;
-                filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+                Global.getProfile().setShowBlacklisted(false);
+                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == loadOC){
 				OCXMLImporter oc = new OCXMLImporter(pref,profile);
 				oc.doIt();
-                Global.getProfile().showBlacklisted = false;
-                filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+                Global.getProfile().setShowBlacklisted(false);
+                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
 				tbp.resetModel();
 			}
 			if (mev.selectedItem == update) 
@@ -543,13 +543,13 @@
 					ch = (CacheHolder)cacheDB.get(i);
 					// This is an incremental filter, i.e. it keeps the existing filter
 					// status and only adds the marked caches to the filtered set
-					if (ch.is_Checked && !ch.is_filtered) {
-						ch.is_filtered = true;
+					if (ch.is_Checked && !ch.is_filtered()) {
+						ch.setFiltered(true);
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged && Global.getProfile().filterActive == Filter.FILTER_INACTIVE) {
-					Global.getProfile().filterActive = Filter.FILTER_MARKED_ONLY;
+				if ( filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
@@ -561,31 +561,32 @@
 					ch = (CacheHolder)cacheDB.get(i);
 					// incremental filter. Keeps status of all marked caches and
 					// adds unmarked caches to filtered list
-					if (!ch.is_Checked && !ch.is_filtered) {
-						ch.is_filtered = true;
+					if (!ch.is_Checked && !ch.is_filtered()) {
+						ch.setFiltered(true);
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged && Global.getProfile().filterActive == Filter.FILTER_INACTIVE) {
-					Global.getProfile().filterActive = Filter.FILTER_MARKED_ONLY;
+				if ( filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == filtBlack){
 				//filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
-				Global.getProfile().showBlacklisted = !Global.getProfile().showBlacklisted;
-				filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(!Global.getProfile().showBlacklisted());
+				filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();// Clear search & restore filter status
-				Filter flt=new Filter();
-				flt.clearFilter();
+				//Filter flt=new Filter();
+				//flt.clearFilter();
+				Global.getProfile().restoreFilter();
 				tbp.refreshTable();
 			}
 			///////////////////////////////////////////////////////////////////////
 			// "Organise" pulldown menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == orgNewWP){
-				if (Global.mainTab.tbP.getSelectedCache() >= 0) Global.mainTab.lastselected = ((CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache())).wayPoint;
+				if (Global.mainTab.tbP.getSelectedCache() >= 0) Global.mainTab.lastselected = ((CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache())).getWayPoint();
 				Global.mainTab.newWaypoint(new CacheHolder());
 			}
 
@@ -691,9 +692,9 @@
 		Vector cachesToUpdate = new Vector();
 		for(int i = 0; i <	cacheDB.size(); i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.is_Checked == true && !ch.is_filtered) {
-				if ( ch.wayPoint.length()>1 && (ch.wayPoint.substring(0,2).equalsIgnoreCase("GC") 
-						|| ch.wayPoint.substring(0,2).equalsIgnoreCase("OC")))
+			if(ch.is_Checked == true && !ch.is_filtered()) {
+				if ( ch.getWayPoint().length()>1 && (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC") 
+						|| ch.getWayPoint().substring(0,2).equalsIgnoreCase("OC")))
 //					if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
 //					Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
 //					Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
@@ -708,7 +709,7 @@
 					if (!ch.isAddiWpt() && !alreadySaid) {
 						alreadySaid = true;
 						(new MessageBox(MyLocale.getMsg(327,"Information"),
-								        ch.wayPoint+ 
+								        ch.getWayPoint()+ 
 								        MyLocale.getMsg(5002,": At the moment this function is only applicable for geocaching.com and opencaching.de."), FormBase.OKB)).execute();
 					}
 				}
@@ -722,9 +723,9 @@
 			int i = ((Integer)cachesToUpdate.get(j)).intValue();
 			ch = (CacheHolder)cacheDB.get(i);
 //			infB.setInfo("Loading: " + ch.wayPoint);
-			infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.wayPoint +" (" + (j+1) + " / " + cachesToUpdate.size() + ")");
+			infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.getWayPoint() +" (" + (j+1) + " / " + cachesToUpdate.size() + ")");
 			infB.redisplay();
-			if (ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")) {
+			if (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) {
 				int test = spider.spiderSingle(i, infB,forceLogin);
 				if (test == -1) {
 					infB.close(0);
@@ -732,7 +733,7 @@
 				} else if (test == 0) {
 					spiderErrors++;
 				} else {
-					profile.hasUnsavedChanges=true;	
+					//profile.hasUnsavedChanges=true;	
 				}
 				forceLogin=false;
 			}
@@ -740,15 +741,15 @@
 				if (!ocSync.syncSingle(i, infB)) {
 					infB.close(0);
 					break;
-				} else 
-					profile.hasUnsavedChanges=true;	
+				} else { 
+					//profile.hasUnsavedChanges=true;
+				}	
 			}
 
 //			cacheDB.clear();
 //			profile.readIndex();
 		}
 		infB.close(0);
-//		profile.hasUnsavedChanges=true;	
 		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
 		profile.restoreFilter();
 		profile.updateBearingDistance();

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/MainTab.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -141,7 +141,7 @@
 				lastselected="";
 			} else {
 				ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
-				lastselected=ch.wayPoint;  // Used in Parser.Skeleton
+				lastselected=ch.getWayPoint();  // Used in Parser.Skeleton
 				try {
 					chD = ch.getCacheDetails(true);
 					//chD=new CacheHolderDetail(ch);
@@ -159,7 +159,7 @@
 				detP.saveDirtyWaypoint();
 				if (needTableUpdate) {
 					tbP.myMod.updateRows();// This sorts the waypoint (if it is new) into the right position
-					tbP.selectRow(profile.getCacheIndex(detP.thisCache.wayPoint));
+					tbP.selectRow(profile.getCacheIndex(detP.thisCache.getWayPoint()));
 				}
 				//was tbP.refreshTable();
 				tbP.tc.update(true); // Update and repaint
@@ -255,7 +255,7 @@
 			break;
 		case 8:  // Cache Radar Panel
 			MyLocale.setSIPOff();
-			radarP.setParam(pref, cacheDB, chD==null?"":chD.wayPoint);
+			radarP.setParam(pref, cacheDB, chD==null?"":chD.getWayPoint());
 			radarP.drawThePanel();
 			break;
 		}
@@ -282,7 +282,7 @@
 		// To change cache we need to be in panel 0
 		onLeavingPanel(oldCard);
 		onEnteringPanel(0); oldCard=0;
-		int row = profile.getCacheIndex(chi.wayPoint);
+		int row = profile.getCacheIndex(chi.getWayPoint());
 		tbP.selectRow(row);
 		//tbP.tc.scrollToVisible(row, 0);
 		//tbP.selectRow(row);
@@ -313,23 +313,23 @@
 		if (selectedIndex >= 0) {
 			CacheHolder selectedCache = (CacheHolder) profile.cacheDB.get( selectedIndex );
 			if ( selectedCache.isAddiWpt() ) {
-				mainCache = selectedCache.mainCache.wayPoint;
+				mainCache = selectedCache.mainCache.getWayPoint();
 			}			
 		}
-		Global.getProfile().hasUnsavedChanges=true;
 		detP.setNeedsTableUpdate(true);
-		if (CacheType.isAddiWpt(ch.type) && mainCache!=null && mainCache.length()>2) {
-			ch.wayPoint = profile.getNewAddiWayPointName(mainCache);
+		if (CacheType.isAddiWpt(ch.getType()) && mainCache!=null && mainCache.length()>2) {
+			ch.setWayPoint(profile.getNewAddiWayPointName(mainCache));
 			profile.setAddiRef(ch);
 		} else { 
-			ch.wayPoint = profile.getNewWayPointName();
-			ch.type=0;
-			lastselected=ch.wayPoint;
+			ch.setWayPoint(profile.getNewWayPointName());
+			ch.setType(0);
+			lastselected=ch.getWayPoint();
 		}
-		ch.CacheSize = "None";
+		ch.setCacheSize("None");
 		chD = ch.getCacheDetails(true);
 		this.ch = ch;
 		cacheDB.add(ch);
+		Global.getProfile().notifyUnsavedChanges(true); // Just to be sure 
 		tbP.myMod.numRows++;
 		detP.setDetails(ch);
 		oldCard=1;
@@ -401,7 +401,7 @@
 			oldCard=0;
 		}
 		updatePendingChanges();
-		if (profile.hasUnsavedChanges) profile.saveIndex(Global.getPref(),true);
+		if (profile.hasUnsavedChanges()) profile.saveIndex(Global.getPref(),true);
 	    this.tbP.saveColWidth(pref);
 		Global.getPref().savePreferences();
 	}

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/MyComparer.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -20,27 +20,27 @@
 		if (colToCompare==1) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=String.valueOf(ch.type);
+				ch.sort=String.valueOf(ch.getType());
 			}
 		} else if (colToCompare==2) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.hard;
+				ch.sort=ch.getHard();
 			}
 		} else if (colToCompare==3) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.terrain;
+				ch.sort=ch.getTerrain();
 			}
 		} else if (colToCompare==4) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.wayPoint.toUpperCase();
+				ch.sort=ch.getWayPoint().toUpperCase();
 			}
 		} else if (colToCompare==5) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheName.toLowerCase();
+				ch.sort=ch.getCacheName().toLowerCase();
 			}
 		} else if (colToCompare==6) {
 			for (int i=0; i<visibleSize; i++) {
@@ -50,17 +50,17 @@
 		} else if (colToCompare==7) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheOwner.toLowerCase();
+				ch.sort=ch.getCacheOwner().toLowerCase();
 			}
 		} else if (colToCompare==8) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.DateHidden;
+				ch.sort=ch.getDateHidden();
 			}
 		} else if (colToCompare==9) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheStatus;
+				ch.sort=ch.getCacheStatus();
 			}
 		} else if (colToCompare==10) {
 			for (int i=0; i<visibleSize; i++) {
@@ -77,8 +77,8 @@
 		} else if (colToCompare==12) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				if (ch.CacheSize.length()==0) ch.sort="?";
-				else switch (ch.CacheSize.charAt(0)) {
+				if (ch.getCacheSize().length()==0) ch.sort="?";
+				else switch (ch.getCacheSize().charAt(0)) {
 					case 'M': ch.sort="1"; break;
 					case 'S': ch.sort="2"; break;
 					case 'R': ch.sort="3"; break;
@@ -90,15 +90,15 @@
 		} else if (colToCompare==13) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				if (ch.wayPoint.startsWith("OC"))
-					ch.sort=MyLocale.formatLong(ch.numRecommended,"00000");
+				if (ch.getWayPoint().startsWith("OC"))
+					ch.sort=MyLocale.formatLong(ch.getNumRecommended(),"00000");
 				else
 					ch.sort="\uFFFF";
 			}			
 		} else if (colToCompare==14) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				if (ch.wayPoint.startsWith("OC"))
+				if (ch.getWayPoint().startsWith("OC"))
 					ch.sort=MyLocale.formatLong(ch.recommendationScore,"00000");
 				else
 					ch.sort="\uFFFF";

Modified: trunk/src/CacheWolf/NewProfileForm.java
===================================================================
--- trunk/src/CacheWolf/NewProfileForm.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/NewProfileForm.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -54,8 +54,8 @@
 							profileDir="";
 							this.close(-1);
 						}
-						Global.getProfile().filterActive=Filter.FILTER_INACTIVE;
-						Global.getProfile().filterInverted=false;
+						Global.getProfile().setFilterActive(Filter.FILTER_INACTIVE);
+						Global.getProfile().setFilterInverted(false);
 						this.close(0);
 					}
 				}

Modified: trunk/src/CacheWolf/NewProfileWizard.java
===================================================================
--- trunk/src/CacheWolf/NewProfileWizard.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/NewProfileWizard.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -20,8 +20,7 @@
 			CoordsScreen cs = new CoordsScreen();
 			cs.setFields(new CWPoint(), CWPoint.CW);
 			if (cs.execute() == FormBase.IDOK) {
-				profile.centre.set(cs.getCoords());
-				profile.hasUnsavedChanges=true;
+				profile.setCenterCoords(cs.getCoords());
 			}
 			Global.mainForm.setTitle("Cachewolf "+Version.getRelease()+" - "+profile.name);
 		}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -67,17 +67,17 @@
 		pref = p;
 		profile=prof;
 		cacheDB = profile.cacheDB;
-		if(profile.last_sync_opencaching == null ||
-				profile.last_sync_opencaching.length() < 12){
-			profile.last_sync_opencaching = "20050801000000";
+		if(profile.getLast_sync_opencaching() == null ||
+				profile.getLast_sync_opencaching().length() < 12){
+			profile.setLast_sync_opencaching("20050801000000");
 			incUpdate = false;
 		}
 		user = p.myAlias.toLowerCase();
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			DBindexWpt.put(ch.wayPoint, new Integer(i));
-			if (!ch.ocCacheID.equals(""))
-				DBindexID.put(ch.ocCacheID, new Integer(i));
+			DBindexWpt.put(ch.getWayPoint(), new Integer(i));
+			if (!ch.getOcCacheID().equals(""))
+				DBindexID.put(ch.getOcCacheID(), new Integer(i));
 		}//for
 
 	}
@@ -115,8 +115,8 @@
 		String lastS; 
 		if (reload)  lastS = "20050801000000";
 		else {
-			if (ch.lastSyncOC.length() < 14) lastS = "20050801000000";
-			else lastS = ch.lastSyncOC;
+			if (ch.getLastSyncOC().length() < 14) lastS = "20050801000000";
+			else lastS = ch.getLastSyncOC();
 		}
 		dateOfthisSync = new Time();
 		dateOfthisSync.parse(lastS, "yyyyMMddHHmmss");
@@ -133,7 +133,7 @@
 		else url += "&picture=0";
 		url += "&cachelog=1"
 			+ "&removedobject=0"
-			+ "&wp=" + ch.wayPoint
+			+ "&wp=" + ch.getWayPoint()
 			+ "&charset=utf-8"
 			+ "&cdata=0"
 			+ "&session=0";
@@ -149,7 +149,7 @@
 		
 		String url = new String();
 
-		String lastS =  profile.last_sync_opencaching;
+		String lastS =  profile.getLast_sync_opencaching();
 		CWPoint centre = pref.curCentrePt; // No need to clone curCentrePt as centre is only read
 		if (!centre.isValid()) {
 			(new MessageBox("Error", "Coordinates for centre must be set", FormBase.OKB)).execute();
@@ -166,19 +166,19 @@
 		distDouble.value = Common.parseDouble(dist);
 		dist = distDouble.toString(0, 1, 0).replace(',', '.');
 		//check, if distance is greater than before
-		if (Convert.toInt(dist) > Convert.toInt(profile.distOC) ||
+		if (Convert.toInt(dist) > Convert.toInt(profile.getDistOC()) ||
 				pref.downloadmissingOC  ){
 			// resysnc
 			lastS = "20050801000000";
 			incUpdate = false;
 		}
-		profile.distOC = dist;
+		profile.setDistOC(dist);
 		// Clear status of caches in db
 		for(int i = cacheDB.size()-1; i>=0 ;i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_update = false;
-			ch.is_new = false;
-			ch.is_log_update = false;
+			ch.setUpdated(false);
+			ch.setNew(false);
+			ch.setLog_updated(false);
 		}	
 		picCnt = 0;
 		//Build url
@@ -205,7 +205,7 @@
 		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
 		Vm.showWait(false);
 		if (success) {
-			profile.last_sync_opencaching = dateOfthisSync.format("yyyyMMddHHmmss");
+			profile.setLast_sync_opencaching(dateOfthisSync.format("yyyyMMddHHmmss"));
 			//pref.savePreferences();
 			finalMessage = MyLocale.getMsg(1607,"Update from opencaching successful"); 
 			inf.addWarning("\nNumber of"+
@@ -265,15 +265,15 @@
 				success = false;
 			}
 		}catch (IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ chD.wayPoint;
+			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ chD.getWayPoint();
 			success = false;
-			Vm.debug("Parse error: " + state + " " + chD.wayPoint);
+			Vm.debug("Parse error: " + state + " " + chD.getWayPoint());
 			e.printStackTrace();
-		}catch (Exception e){ // here schould be used the correct exepion
-			if (chD != null)	finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ chD.wayPoint;
+		}catch (Exception e){ // here should be used the correct exception
+			if (chD != null)	finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ chD.getWayPoint();
 			else finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: <unkown>";
 			success = false;
-			Vm.debug("Parse error: " + state + " Exception:" + e.toString()+"   "+chD.ocCacheID);
+			Vm.debug("Parse error: " + state + " Exception:" + e.toString()+"   "+chD.getOcCacheID());
 			e.printStackTrace();
 		} finally {
 			if (tmpFile != null) tmpFile.delete();
@@ -356,27 +356,27 @@
 			cacheID = atts.getValue("id");
 		}
 		if(name.equals("type")){
-			chD.type = CacheType.transOCType(new Integer(atts.getValue("id")).intValue()); 
+			chD.setType(CacheType.transOCType(new Integer(atts.getValue("id")).intValue())); 
 			return;
 		}
 		if(name.equals("status")){
-			if(atts.getValue("id").equals("1")) chD.is_available = true;
-			if(atts.getValue("id").equals("2")) chD.is_available = false;
+			if(atts.getValue("id").equals("1")) chD.setAvailable(true);
+			if(atts.getValue("id").equals("2")) chD.setAvailable(false);
 			if(atts.getValue("id").equals("3")) {
-				chD.is_archived = true;
-				chD.is_available = false;
+				chD.setArchived(true);
+				chD.setAvailable(false);
 			}
-			if(atts.getValue("id").equals("4")) chD.is_available = false;
+			if(atts.getValue("id").equals("4")) chD.setAvailable(false);
 			return;
 		}
 		if(name.equals("size")){
-			chD.CacheSize = transSize(atts.getValue("id"));
+			chD.setCacheSize(transSize(atts.getValue("id")));
 			return;
 		}
 
 		if(name.equals("waypoints")){
-			chD.wayPoint = atts.getValue("oc");
-			if (chD.wayPoint.length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
+			chD.setWayPoint(atts.getValue("oc"));
+			if (chD.getWayPoint().length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
 			return;
 		}
 
@@ -388,7 +388,7 @@
 		}
 
 		if (name.equals("desc")){
-			chD.is_HTML = atts.getValue("html").equals("1")?true:false;
+			chD.setHTML(atts.getValue("html").equals("1")?true:false);
 		}
 
 		if (name.equals("language") && !atts.getValue("id").equals("DE")){
@@ -412,7 +412,7 @@
 				logIcon = GPXImporter.typeText2Image("Found");
 				break;
 			case 2:	logIcon = GPXImporter.typeText2Image("Not Found"); 
-			chD.noFindLogs += 1;
+			chD.setNoFindLogs(chD.getNoFindLogs()+1);
 			break;
 			case 3: logIcon = GPXImporter.typeText2Image("Note");
 			}
@@ -427,25 +427,25 @@
 
 	private void endCache(String name){
 		if (name.equals("cache")){
-			chD.lastSyncOC = dateOfthisSync.format("yyyyMMddHHmmss");
+			chD.setLastSyncOC(dateOfthisSync.format("yyyyMMddHHmmss"));
 			int index;
-			index = searchWpt(chD.wayPoint);
+			index = searchWpt(chD.getWayPoint());
 			if (index == -1){
-				chD.is_new = true;
+				chD.setNew(true);
 				CacheHolder ch = new CacheHolder(chD);
 				ch.details = chD;
 				cacheDB.add(ch);
 				ch.detailsAdded();
 				Integer indexInt = new Integer(cacheDB.size()-1);
-				DBindexWpt.put(chD.wayPoint, indexInt);
-				DBindexID.put(chD.ocCacheID, indexInt);
+				DBindexWpt.put(chD.getWayPoint(), indexInt);
+				DBindexID.put(chD.getOcCacheID(), indexInt);
 			}
 			// update (overwrite) data
 			else {
-				chD.is_new = false;
+				chD.setNew(false);
 				cacheDB.set(index, new CacheHolder(chD));
 				// save ocCacheID, in case, the previous data is from GPX
-				DBindexID.put(chD.ocCacheID, new Integer(index));
+				DBindexID.put(chD.getOcCacheID(), new Integer(index));
 			}
 			// clear data (picture, logs) if we do a complete Update
 			if (incUpdate == false){
@@ -463,18 +463,18 @@
 		}
 		if(name.equals("id")){ // </id>
 			chD = getHolder(strData); // Allocate a new CacheHolder object
-			chD.ocCacheID=strData;
+			chD.setOcCacheID(strData);
 			chD.URL = ocSeekUrl + cacheID;
 			return;
 		}
 
 		if(name.equals("name")){
-			chD.CacheName = strData;
+			chD.setCacheName(strData);
 			return;
 		}
 		if(name.equals("userid")) {
-			chD.CacheOwner = strData;
-			if(chD.CacheOwner.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && chD.CacheOwner.equalsIgnoreCase(pref.myAlias2))) chD.is_owned = true;
+			chD.setCacheOwner(strData);
+			if(chD.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && chD.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) chD.setOwned(true);
 			return;
 		}
 
@@ -488,15 +488,15 @@
 			return;
 		}
 		if(name.equals("difficulty")) {
-			chD.hard = strData;
+			chD.setHard(strData);
 			return;
 		}
 		if(name.equals("terrain")) {
-			chD.terrain = strData;
+			chD.setTerrain(strData);
 			return;
 		}
 		if(name.equals("datehidden")) {
-			chD.DateHidden = strData.substring(0,10); //Date;
+			chD.setDateHidden(strData.substring(0,10)); //Date;
 			return;
 		}
 		if (name.equals("country")){
@@ -509,7 +509,7 @@
 
 		if (!ignoreDesc){
 			if (name.equals("cachedesc")){
-				if (pref.downloadPicsOC && chD.is_HTML) {
+				if (pref.downloadPicsOC && chD.is_HTML()) {
 					String fetchUrl, imgTag, imgAltText;
 					Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)"); //  Ergebnis enth?lt keine Anf?hrungszeichen
 					Regex imgRegexAlt = new Regex("(?:alt=[\"\']([^>^\"^\']*)|alt=([^>^\"^\'^ ]*))"); // get alternative text for Pic
@@ -522,7 +522,7 @@
 						fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf?hrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anf?hrungszeichen 
 						if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
 						if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-							inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+chD.wayPoint));
+							inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+chD.getWayPoint()));
 							continue;
 						}
 						inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
@@ -547,7 +547,7 @@
 			if (name.equals("cacheid")){
 				// load cachedata
 				chD = getHolder(strData);
-				chD.is_update = true;
+				chD.setUpdated(true);
 				return;
 			}
 
@@ -557,7 +557,7 @@
 			}
 
 			if (name.equals("desc")){ // </desc>
-				if (chD.is_HTML)	chD.LongDescription +=SafeXML.cleanback(strData);
+				if (chD.is_HTML())	chD.LongDescription +=SafeXML.cleanback(strData);
 				else chD.LongDescription +=strData;
 				return;
 			}
@@ -569,7 +569,7 @@
 	}
 
 	private String createPicFilename(String fetchURL) {
-		String fileName = chD.wayPoint + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
+		String fileName = chD.getWayPoint() + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
 		return Common.ClearForFileName(fileName);
 	}
 	
@@ -591,10 +591,10 @@
 					}
 				}
 			} catch (IOException e) {
-				String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + chD.wayPoint + ": ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+fetchURL); 
+				String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + chD.getWayPoint() + ": ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+fetchURL); 
 				if (e.getMessage().toLowerCase().equalsIgnoreCase("could not connect") ||
 						e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+chD.CacheName + " ("+chD.wayPoint+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
+					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+chD.getCacheName() + " ("+chD.getWayPoint()+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
 				} 
 				inf.addWarning("\n"+ErrMessage);
 				//(new MessageBox(MyLocale.getMsg(144, "Warning"), ErrMessage, MessageBox.OKB)).exec();
@@ -602,7 +602,7 @@
 				e.printStackTrace();
 			}
 		} catch (MalformedURLException e) {
-			String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + chD.wayPoint + ": ignoring MalformedUrlException: " + e.getMessage()+ " while downloading from URL:" + fetchURL); 
+			String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + chD.getWayPoint() + ": ignoring MalformedUrlException: " + e.getMessage()+ " while downloading from URL:" + fetchURL); 
 			inf.addWarning("\n"+ErrMessage);
 			pref.log(ErrMessage);
 		}
@@ -642,8 +642,8 @@
 		if (name.equals("cachelog")){ // </cachelog>
 			chD.CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
 			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) && logtype == 1) {
-						chD.CacheStatus=logDate;
-						chD.is_found=true;
+						chD.setCacheStatus(logDate);
+						chD.setFound(true);
 						chD.OwnLogId = logId;
 						chD.OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
 			}
@@ -678,7 +678,7 @@
 		CharArray realurl = new CharArray();
 		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
 		String address = realurl.toString();
-		if (chD != null) fileName = chD.wayPoint + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
+		if (chD != null) fileName = chD.getWayPoint() + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
 		// else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
 
 		//save file

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -39,11 +39,11 @@
 			String dist1;
 			String dist2;
 			if ((options & ISGC) > 0) {
-				dist1 = Global.getProfile().distGC;
-				dist2 = Global.getProfile().distOC;
+				dist1 = Global.getProfile().getDistGC();
+				dist2 = Global.getProfile().getDistOC();
 			} else {
-				dist1 = Global.getProfile().distOC;
-				dist2 = Global.getProfile().distGC;
+				dist1 = Global.getProfile().getDistOC();
+				dist2 = Global.getProfile().getDistGC();
 			}
 			if ( dist1.equals("") || dist1.equals("0") || dist1.equals("0.0") ) {
 				dist1 = dist2;

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/Parser.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -667,7 +667,7 @@
     	if (ci<0) return;
     	// If it is an addi, find its main cache
     	if (((CacheHolder) Global.getProfile().cacheDB.get(ci)).isAddiWpt()) {
-    		waypointName=((CacheHolder) Global.getProfile().cacheDB.get(ci)).mainCache.wayPoint;
+    		waypointName=((CacheHolder) Global.getProfile().cacheDB.get(ci)).mainCache.getWayPoint();
     	}
    		int nStages=-1;
     	if (nargs==1) {
@@ -716,17 +716,17 @@
 				for (int j=0; j<ch.addiWpts.getCount();j++){
 					addiWpt = (CacheHolder)ch.addiWpts.get(j);
 					op.append("IF $");
-					op.append(addiWpt.wayPoint);
+					op.append(addiWpt.getWayPoint());
 					op.append("=\"\" THEN\n   $");
-					op.append(addiWpt.wayPoint);
+					op.append(addiWpt.getWayPoint());
 					op.append("=\"\"");
 					//op.append(addiWpt.pos.toString());
 					op.append("\n   \"Punkt ");
-					op.append(addiWpt.wayPoint.substring(0,2));
+					op.append(addiWpt.getWayPoint().substring(0,2));
 					op.append(" [");
-					op.append(addiWpt.CacheName);
+					op.append(addiWpt.getCacheName());
 					op.append("] = \" $");
-					op.append(addiWpt.wayPoint);
+					op.append(addiWpt.getWayPoint());
 					CacheHolderDetail chD=new CacheHolderDetail(addiWpt);
 					try {
 						chD.readCache(Global.getProfile().dataDir);
@@ -734,7 +734,7 @@
 					if (chD.LongDescription.trim().length()>0)
 						op.append("\n   \""+STRreplace.replace(chD.LongDescription,"\"","\"\"")+"\"");
 					op.append("\n   goto($");
-					op.append(addiWpt.wayPoint);
+					op.append(addiWpt.getWayPoint());
 					op.append("); STOP\nENDIF\n\n");
 				}
 				Global.mainTab.solverP.mText.appendText(op.toString(),true);
@@ -1101,12 +1101,11 @@
     	if (ci >= 0) return false;
 
 		CacheHolder ch = new CacheHolder();
-		ch.wayPoint = wayPoint;
-		ch.type = type;
-		ch.CacheSize = "None";
-		ch.CacheName= name;
+		ch.setWayPoint(wayPoint);
+		ch.setType(type);
+		ch.setCacheSize("None");
+		ch.setCacheName(name);
 
-		Global.getProfile().hasUnsavedChanges=true;
 		Global.getProfile().setAddiRef(ch);
 
 		Global.mainTab.cacheDB.add(ch);

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/Preferences.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -651,8 +651,8 @@
 				if (code==-1) return false; // Cancel pressed
 				CWPoint savecenter = new CWPoint(prof.centre);
 				prof.clearProfile();
-				prof.centre = savecenter;
-				prof.hasUnsavedChanges = true;
+				prof.setCenterCoords(savecenter);
+				//prof.hasUnsavedChanges = true;
 				//curCentrePt.set(0,0); // No centre yet
 				lastProfile=f.newSelectedProfile;
 			}

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/Profile.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -32,45 +32,51 @@
 	 *  the index.xml and cache files live. (Excuse the English spelling of centre)     */
 	public String name=new String();
 	/** This is the directory for the profile. It contains a closing /.   	 */
-	public String dataDir=new String();  
+	public String dataDir = new String();
+
 	/** Last sync date for opencaching caches */
-	public String last_sync_opencaching = new String();
+	private String last_sync_opencaching = new String();
+
 	/** Distance for opencaching caches */
-	public String distOC = new String();
+	private String distOC = new String();
+
 	/** Distance for geocaching caches */
-	public String distGC = new String();
+	private String distGC = new String();
 
 	public final static boolean SHOW_PROGRESS_BAR = true;
 	public final static boolean NO_SHOW_PROGRESS_BAR = false;
 
 	// When extending the filter check "normaliseFilters"
 	// which ensures backward compatibility. Normally no change should be needed
-	public final static String FILTERTYPE="1111111111111111111";
-	public final static String FILTERROSE="1111111111111111";
-	public final static String FILTERVAR="11111111";
-	public final static String FILTERSIZE="111111";
-	public String filterType = new String(FILTERTYPE);
-	public String filterRose = new String(FILTERROSE);
-	public String filterSize = new String(FILTERSIZE);
-	//filter settings for archived ... owner (section) in filterscreen
-	public String filterVar = new String(FILTERVAR);
-	public String filterDist=new String("L");
-	public String filterDiff=new String("L");
-	public String filterTerr=new String("L");
+	public final static String FILTERTYPE = "1111111111111111111";
+	public final static String FILTERROSE = "1111111111111111";
+	public final static String FILTERVAR = "11111111";
+	public final static String FILTERSIZE = "111111";
+
+	private String filterType = new String(FILTERTYPE);
+	private String filterRose = new String(FILTERROSE);
+	private String filterSize = new String(FILTERSIZE);
+
+	// filter settings for archived ... owner (section) in filterscreen
+	private String filterVar = new String(FILTERVAR);
+	private String filterDist = new String("L");
+	private String filterDiff = new String("L");
+	private String filterTerr = new String("L");
+
 	// Saved filterstatus - is only refreshed from class Filter when Profile is saved
-	public int filterActive=Filter.FILTER_INACTIVE;
-	public boolean filterInverted=false;
-	public boolean showBlacklisted = false;
+	private int filterActive = Filter.FILTER_INACTIVE;
+	private boolean filterInverted = false;
+	private boolean showBlacklisted = false;
 
-	public long filterAttrYes = 0l;
-	public long filterAttrNo = 0l;
-	public int filterAttrChoice = 0;
+	private long filterAttrYes = 0l;
+	private long filterAttrNo = 0l;
+	private int filterAttrChoice = 0;
 
 	public boolean selectionChanged = true; // ("H?ckchen") used by movingMap to get to knao if it should update the caches in the map 
 	/** True if the profile has been modified and not saved
 	 * The following modifications set this flag: New profile centre, Change of waypoint data 
 	 */
-	public boolean hasUnsavedChanges = false;
+	private boolean hasUnsavedChanges = false;
 	public boolean byPassIndexActive = false;
 
 	//TODO Add other settings, such as max. number of logs to spider
@@ -83,18 +89,50 @@
 	public Profile(){
 	}
 
+
+	/**
+	 * Returns <code>true</code> if profile needs to be changed when profile is left. Returns
+	 * <code>false</code> if no relevant changes have been made.
+	 * 
+	 * @return hasUnsavedChanges
+	 */
+	public boolean hasUnsavedChanges() {
+		return hasUnsavedChanges;
+	}
+
+	/**
+	 * Remember that profile needs to be saved. Flag is set <code>true</code> when parameter is
+	 * true, but it's not set to <code>false</code> when parameter is <code>false</code>.<br>
+	 * This is only done internally on saving the cache.
+	 * 
+	 * @param hasUnsavedChanges
+	 *            the hasUnsavedChanges to set
+	 */
+	public void notifyUnsavedChanges(boolean changes) {
+		hasUnsavedChanges = hasUnsavedChanges || changes;
+	}
+	
+	public void resetUnsavedChanges() {
+		hasUnsavedChanges = false;
+	}
+
 	public void clearProfile() {
 		CacheHolder.removeAllDetails();
 		cacheDB.clear();
-		centre.set(-361,-361);
-		name="";
-		dataDir="";  
-		last_sync_opencaching = "";
-		distOC = "";
-		distGC = "";
-		hasUnsavedChanges=false;
+		centre.set(-361, -361);
+		name = "";
+		dataDir = "";
+		setLast_sync_opencaching("");
+		setDistOC("");
+		setDistGC("");
+		resetUnsavedChanges();
 	}
 
+	public void setCenterCoords(CWPoint coords) {
+		this.notifyUnsavedChanges(coords.equals(this.centre));
+		this.centre.set(coords);
+	}
+	
 	/**
 	 *	Method to save the index.xml file that holds the total information
 	 *	on available caches in the database. The database is nothing else
@@ -145,32 +183,32 @@
 //				detfile.print("    <CENTRE lat=\""+savedCentre.getNSLetter() + " " + savedCentre.getLatDeg(CWPoint.CW) + "&deg; " + savedCentre.getLatMin(CWPoint.CW)+ "\" "+
 //				"long=\""+savedCentre.getEWLetter() + " " + savedCentre.getLonDeg(CWPoint.CW) + "&deg; " + savedCentre.getLonMin(CWPoint.CW)+"\"/>\n");
 				detfile.print("    <CENTRE lat=\""+savedCentre.latDec+"\" lon=\""+savedCentre.lonDec+"\"/>\n");
-			if(last_sync_opencaching == null || last_sync_opencaching.endsWith("null") || last_sync_opencaching.equals("")){
-				last_sync_opencaching = "20050801000000";
+			if(getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith("null") || getLast_sync_opencaching().equals("")){
+				setLast_sync_opencaching("20050801000000");
 			}
-			if(distOC == null || distOC.endsWith("null") || distOC.equals("")){
-				distOC = "0.0";
+			if (getDistOC() == null || getDistOC().endsWith("null") || getDistOC().equals("")) {
+				setDistOC("0.0");
 			}
-			if(distGC == null || distGC.endsWith("null") || distGC.equals("")){
-				distGC = "0.0";
+			if (getDistGC() == null || getDistGC().endsWith("null") || getDistGC().equals("")) {
+				setDistGC("0.0");
 			}
 
-			detfile.print("    <FILTER status = \""+filterActive+(filterInverted?"T":"F")+ 
-					"\" rose = \""+filterRose+"\" type = \""+filterType+
-					"\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
-					filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" attributesYes = \""+filterAttrYes+
-					"\" attributesNo = \""+filterAttrNo+"\" attributesChoice = \""+filterAttrChoice+"\" showBlacklist = \""+showBlacklisted+"\" />\n");
-			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
-			detfile.print("    <SPIDERGC dist = \""+distGC+"\"/>\n");
-			int size=cacheDB.size();
-			for(int i = 0; i<size;i++){
-				if(showprogress){
-					h.progress = (float)i/(float)size;
+			detfile.print("    <FILTER status = \""+getFilterActive()+(isFilterInverted()?"T":"F")+ 
+					"\" rose = \""+getFilterRose()+"\" type = \""+getFilterType()+
+					"\" var = \""+getFilterVar()+"\" dist = \""+getFilterDist().replace('"',' ')+"\" diff = \""+
+					getFilterDiff()+"\" terr = \""+getFilterTerr()+"\" size = \""+getFilterSize()+"\" attributesYes = \""+getFilterAttrYes()+
+					"\" attributesNo = \""+getFilterAttrNo()+"\" attributesChoice = \""+getFilterAttrChoice()+"\" showBlacklist = \""+showBlacklisted()+"\" />\n");
+			detfile.print("    <SYNCOC date = \""+getLast_sync_opencaching()+"\" dist = \""+getDistOC()+"\"/>\n");
+			detfile.print("    <SPIDERGC dist = \"" + getDistGC() + "\"/>\n");
+			int size = cacheDB.size();
+			for (int i = 0; i < size; i++) {
+				if (showprogress) {
+					h.progress = (float) i / (float) size;
 					h.changed();
 				}
-				ch = (CacheHolder)cacheDB.get(i);
-				////Vm.debug("Saving: " + ch.CacheName);
-				if(ch.wayPoint.length()>0) { //TODO && ch.LongDescription.equals("An Error Has Occured") == false){
+				ch = (CacheHolder) cacheDB.get(i);
+				// //Vm.debug("Saving: " + ch.CacheName);
+				if (ch.getWayPoint().length() > 0) { // TODO && ch.LongDescription.equals("An
 /*					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
 							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
 							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
@@ -188,7 +226,7 @@
 			detfile.close();
 			if(showprogress) pbf.exit(0);
 		}
-		hasUnsavedChanges=false;
+		resetUnsavedChanges();
 	}
 
 	/**
@@ -196,16 +234,16 @@
 	 *	on available caches in the database. The database in nothing else
 	 *	than the collection of caches in a directory.
 	 */
-	public void readIndex(){
-		
+	public void readIndex() {
+
 		try {
 			selectionChanged = true;
-			boolean fmtDec=false;
-			char decSep=MyLocale.getDigSeparator().charAt(0);
-			char notDecSep=decSep=='.'?',':'.';
+			boolean fmtDec = false;
+			char decSep = MyLocale.getDigSeparator().charAt(0);
+			char notDecSep = decSep == '.' ? ',' : '.';
 			FileReader in = new FileReader(dataDir + "index.xml");
 			in.readLine(); // <?xml version= ...
-			String text=in.readLine(); // <CACHELIST>
+			String text = in.readLine(); // <CACHELIST>
 			if (text!=null && text.indexOf("decimal")>0) fmtDec=true;
 			Extractor ex = new Extractor(null, " = \"", "\" ", 0, true);
 			
@@ -231,45 +269,45 @@
 					}	
 				} else if (text.indexOf("<SYNCOC")>=0) {
 					int start=text.indexOf("date = \"")+8;
-					last_sync_opencaching=text.substring(start,text.indexOf("\"",start));
+					setLast_sync_opencaching(text.substring(start,text.indexOf("\"",start)));
 					start=text.indexOf("dist = \"")+8;
-					distOC=text.substring(start,text.indexOf("\"",start));
+					setDistOC(text.substring(start,text.indexOf("\"",start)));
 				} else if (text.indexOf("<SPIDERGC")>=0) {
 					int start=text.indexOf("dist = \"")+8;
-					distGC=text.substring(start,text.indexOf("\"",start));
+					setDistGC(text.substring(start,text.indexOf("\"",start)));
 				} else if (text.indexOf("<FILTER")>=0){
 					ex.setSource(text);
 					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
 					if (temp.length()==2) {
 						// Compatibility with previous versions
 						if (temp.charAt(0)=='T') 
-							filterActive=Filter.FILTER_ACTIVE;
+							setFilterActive(Filter.FILTER_ACTIVE);
 						else
-							filterActive=Common.parseInt(temp.substring(0,1));
-						filterInverted=temp.charAt(1)=='T';
-						filterRose = ex.findNext();
+							setFilterActive(Common.parseInt(temp.substring(0,1)));
+						setFilterInverted(temp.charAt(1)=='T');
+						setFilterRose(ex.findNext());
 					} else 
-						filterRose = temp;
-					filterType = ex.findNext();
+						setFilterRose(temp);
+					setFilterType(ex.findNext());
 					//Need this to stay "downward" compatible. New type introduced
 					//if(filterType.length()<=17) filterType = filterType + "1";
 					//Vm.debug("fil len: " +filterType.length());
 					//This is handled by "normaliseFilters" which is called at the end.
-					filterVar = ex.findNext();
-					filterDist = ex.findNext();
-					filterDiff = ex.findNext();
-					filterTerr = ex.findNext();
-					filterSize = ex.findNext();
+					setFilterVar(ex.findNext());
+					setFilterDist(ex.findNext());
+					setFilterDiff(ex.findNext());
+					setFilterTerr(ex.findNext());
+					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
 					if (attr != null && !attr.equals(""))
-						filterAttrYes = Convert.parseLong(attr);
+						setFilterAttrYes(Convert.parseLong(attr));
 					attr = ex.findNext();
 					if (attr != null && !attr.equals(""))
-						filterAttrNo = Convert.parseLong(attr);
+						setFilterAttrNo(Convert.parseLong(attr));
 					attr = ex.findNext();
 					if (attr != null && !attr.equals(""))
-						filterAttrChoice = Convert.parseInt(attr);
-					showBlacklisted = new Boolean(ex.findNext()).booleanValue();
+						setFilterAttrChoice(Convert.parseInt(attr));
+					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
 				}
 			}
 			in.close();
@@ -279,7 +317,6 @@
 			//Vm.debug("End  :"+endT.format("H:mm:ss.SSS"));	
 			// Build references between caches and addi wpts
 			buildReferences();
-			hasUnsavedChanges = false;
 		} catch (FileNotFoundException e) {
 			Global.getPref().log("index.xml not found in directory "+dataDir); // Normal when profile is opened for first time
 			//e.printStackTrace();
@@ -287,6 +324,7 @@
 			Global.getPref().log("Problem reading index.xml in dir: "+dataDir,e,true); 
 		}
 		normaliseFilters();
+		resetUnsavedChanges();
 	}
 
 	/** Restore the filter to the values stored in this profile 
@@ -298,19 +336,19 @@
 	}
 	
 	void restoreFilter(boolean clearIfInactive) {
-		boolean inverted=filterInverted; // Save it as doFilter will clear filterInverted
+		boolean inverted=isFilterInverted(); // Save it as doFilter will clear filterInverted
 		Filter flt=new Filter();
-		if (filterActive==Filter.FILTER_ACTIVE) {
+		if (getFilterActive()==Filter.FILTER_ACTIVE) {
 			flt.setFilter();
 			flt.doFilter();
 			if (inverted) {
 				flt.invertFilter();
-				filterInverted=true; // Needed because previous line inverts filterInverted
+				setFilterInverted(true); // Needed because previous line inverts filterInverted
 			}
-		} else if (filterActive==Filter.FILTER_CACHELIST) {
+		} else if (getFilterActive()==Filter.FILTER_CACHELIST) {
 			Global.mainForm.cacheList.applyCacheList();
 			//flt.filterActive=filterActive;
-		} else if (filterActive==Filter.FILTER_INACTIVE) {
+		} else if (getFilterActive()==Filter.FILTER_INACTIVE) {
 			if (clearIfInactive) {
 				flt.clearFilter();
 			}
@@ -320,26 +358,21 @@
 	void checkBlacklistStatus() {
 		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
-		boolean filterChanged = false;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.is_black^showBlacklisted) {
-				ch.is_filtered = true;
-				filterChanged = true;
+			if (ch.is_black() ^ showBlacklisted()) {
+				ch.setFiltered(true);
+				selectionChanged = true;
 			}
 		}
-		if ( filterChanged ) {
-			selectionChanged = true;
-			hasUnsavedChanges=true;			
-		}
 	}
 
-	public int getCacheIndex(String wp){
+	public int getCacheIndex(String wp) {
 		int retval = -1;
 		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.wayPoint.equals(wp)){
+		for (int i = 0; i < cacheDB.size(); i++) {
+			ch = (CacheHolder) cacheDB.get(i);
+			if (ch.getWayPoint().equals(wp)) {
 				return i;
 			}
 		}
@@ -347,71 +380,75 @@
 	}
 
 	/** Get a unique name for a new waypoint */
-	//TODO Make more efficient
-	public String getNewWayPointName(){
-		String strWp=null;
-		long  lgWp=1;
-		int s = cacheDB.size(); 
-		if (s ==0 )
+	// TODO Make more efficient
+	public String getNewWayPointName() {
+		String strWp = null;
+		long lgWp = 1;
+		int s = cacheDB.size();
+		if (s == 0)
 			return "CW0000";
-		//Create new waypoint,look if not in db
-		for(int i = 0;i < s;i++){
+		// Create new waypoint,look if not in db
+		for (int i = 0; i < s; i++) {
 			strWp = "CW" + MyLocale.formatLong(lgWp, "0000");
-			if(((CacheHolder)cacheDB.get(i)).wayPoint.indexOf(strWp) >=0 ){
-				//waypoint exists in database
+			if (((CacheHolder) cacheDB.get(i)).getWayPoint().indexOf(strWp) >= 0) {
+				// waypoint exists in database
 				lgWp++;
 				i = -1; // Because i++ will be executed next, so we start the loop with 0
 			}
 		}
 		return strWp;
 	}
-	
+
 	/**
 	 * 
 	 * @param forcache maincache
 	 * @return
 	 */
 	public String getNewAddiWayPointName(String forcache) {
-		int wptNo=-1;
+		int wptNo = -1;
 		String waypoint;
 		do {
-			waypoint=MyLocale.formatLong(++wptNo,"00")+forcache.substring(2);
-		} while (Global.getProfile().getCacheIndex(waypoint)>=0);
+			waypoint = MyLocale.formatLong(++wptNo, "00") + forcache.substring(2);
+		} while (Global.getProfile().getCacheIndex(waypoint) >= 0);
 		return waypoint;
 	}
 
 	/**
 	 * Call this after getNewAddiWayPointName to set the references between main and addi correctly
+	 * 
 	 * @param ch
 	 */
 	public void setAddiRef(CacheHolder ch) {
-		String mainwpt = ch.wayPoint.substring(2);
-		int mainindex = getCacheIndex("GC"+mainwpt);
-		if (mainindex < 0) mainindex = getCacheIndex("OC"+mainwpt);
-		if (mainindex < 0) mainindex = getCacheIndex("CW"+mainwpt);
-		if (mainindex < 0) throw new IllegalArgumentException("no main cache found for: " + ch.wayPoint);
-		CacheHolder mainch = (CacheHolder)cacheDB.get(mainindex);
+		String mainwpt = ch.getWayPoint().substring(2);
+		int mainindex = getCacheIndex("GC" + mainwpt);
+		if (mainindex < 0)
+			mainindex = getCacheIndex("OC" + mainwpt);
+		if (mainindex < 0)
+			mainindex = getCacheIndex("CW" + mainwpt);
+		if (mainindex < 0)
+			throw new IllegalArgumentException("no main cache found for: " + ch.getWayPoint());
+		CacheHolder mainch = (CacheHolder) cacheDB.get(mainindex);
 		mainch.addiWpts.add(ch);
 		ch.mainCache = mainch;
 	}
 
-
 	public String toString() {
 		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
-		last_sync_opencaching+"\ndistOC="+distOC+"\ndistGC="+distGC;
+		getLast_sync_opencaching()+"\ndistOC="+getDistOC()+"\ndistGC="+getDistGC();
 	}
 
 	public void setSelectForAll(boolean selectStatus) {
 		selectionChanged = true;
 		CacheHolder ch;
-		for(int i = cacheDB.size()-1; i >=	0; i--){
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.is_filtered == false) ch.is_Checked = selectStatus;
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
+			ch = (CacheHolder) cacheDB.get(i);
+			if (ch.is_filtered() == false)
+				ch.is_Checked = selectStatus;
 		}
-	} 
+	}
 
+	public int numCachesInArea; // only valid after calling getSourroundingArea
 
-	public int numCachesInArea; // only valid after calling getSourroundingArea
 	public Area getSourroundingArea(boolean onlyOfSelected) {
 		if (cacheDB == null || cacheDB.size() == 0) return null;
 		CacheHolder ch;
@@ -420,7 +457,7 @@
 		CWPoint tmpca = new CWPoint();
 		numCachesInArea = 0;
 		boolean isAddi = false;
-		for (int i=cacheDB.size()-1; i >= 0; i--) {
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = (CacheHolder) cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
 				if (ch.pos == null) { // this can not happen
@@ -441,7 +478,7 @@
 				}
 			}
 		}
-		if (topleft != null && bottomright != null) 
+		if (topleft != null && bottomright != null)
 			return new Area(topleft, bottomright);
 		else return null;
 	}
@@ -477,25 +514,25 @@
 
 		Integer index;
 		// Build index for faster search and clear all references
-		for(int i = cacheDB.size() -1; i >= 0;i--){
-			ch = (CacheHolder)cacheDB.get(i);
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
+			ch = (CacheHolder) cacheDB.get(i);
 			ch.addiWpts.clear();
 			ch.mainCache = null;
 			// if (ch.wayPoint.startsWith("GC")) // Only put potential master caches into the index
-				dbIndex.put(ch.wayPoint, new Integer(i));
+			dbIndex.put(ch.getWayPoint(), new Integer(i));
 		}
 		// Build references
 		int max = cacheDB.size();
-		for(int i =  0; i < max ;i++){
-			ch = (CacheHolder)cacheDB.get(i);
+		for (int i = 0; i < max; i++) {
+			ch = (CacheHolder) cacheDB.get(i);
 			if (ch.isAddiWpt()) {
-				//search main cache
-				index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
+				// search main cache
+				index = (Integer) dbIndex.get("GC" + ch.getWayPoint().substring(2));
 				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
-					index = (Integer) dbIndex.get("OC"+ ch.wayPoint.substring(2));
+					index = (Integer) dbIndex.get("OC"+ ch.getWayPoint().substring(2));
 				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
-					index = (Integer) dbIndex.get("CW"+ ch.wayPoint.substring(2));
-				
+					index = (Integer) dbIndex.get("CW"+ ch.getWayPoint().substring(2));
+
 				if (index != null) {
 					mainCh = (CacheHolder) cacheDB.get(index.intValue());
 					mainCh.addiWpts.add(ch);
@@ -505,42 +542,193 @@
 			}// if
 		}// for
 		// sort addi wpts
-		for(int i =  0; i < max ;i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.hasAddiWpt() && (ch.addiWpts.size()> 1)){
-				//ch.addiWpts.sort(new MyComparer(ch.addiWpts,MyLocale.getMsg(1002,"Waypoint"),ch.addiWpts.size()), false);
-				ch.addiWpts.sort(
-						new ewe.util.Comparer() {	
-							public int compare(Object o1, Object o2){
-								return ((CacheHolder) o1).wayPoint.compareTo(((CacheHolder)o2).wayPoint);
-							}
-						},false );
+		for (int i = 0; i < max; i++) {
+			ch = (CacheHolder) cacheDB.get(i);
+			if (ch.hasAddiWpt() && (ch.addiWpts.size() > 1)) {
+				// ch.addiWpts.sort(new
+				// MyComparer(ch.addiWpts,MyLocale.getMsg(1002,"Waypoint"),ch.addiWpts.size()),
+				// false);
+				ch.addiWpts.sort(new ewe.util.Comparer() {
+					public int compare(Object o1, Object o2) {
+						return ((CacheHolder) o1).getWayPoint().compareTo(
+						        ((CacheHolder) o2).getWayPoint());
+					}
+				}, false);
 			}
 		}
 
 	}
-	
-	
-	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter
-	 * do not cause nullPointer Exceptions
+
+	/**
+	 * Ensure that all filters have the proper length so that the 'charAt' access in the filter do
+	 * not cause nullPointer Exceptions
 	 */
 	private void normaliseFilters() {
-		String manyOnes="11111111111111111111111111111";
-		if (filterRose.length()<FILTERROSE.length()) { 
-			filterRose=(filterRose+manyOnes).substring(0,FILTERROSE.length()); 
-		}  
-		if (filterVar.length()<FILTERVAR.length()) { 
-			filterVar=(filterVar+manyOnes).substring(0,FILTERVAR.length()); 
-		}  
-		if (filterType.length()<FILTERTYPE.length()) { 
-			filterType=(filterType+manyOnes).substring(0,FILTERTYPE.length());
-		} 
-		if (filterSize.length()<FILTERSIZE.length()) {
-			filterSize=(filterSize+manyOnes).substring(0,FILTERSIZE.length());
+		String manyOnes = "11111111111111111111111111111";
+		if (getFilterRose().length() < FILTERROSE.length()) {
+			setFilterRose((getFilterRose() + manyOnes).substring(0, FILTERROSE.length()));
 		}
-		if (filterDist.length()==0) filterDist="L";
-		if (filterDiff.length()==0) filterDiff="L";
-		if (filterTerr.length()==0) filterTerr="L";
+		if (getFilterVar().length() < FILTERVAR.length()) {
+			setFilterVar((getFilterVar() + manyOnes).substring(0, FILTERVAR.length()));
+		}
+		if (getFilterType().length() < FILTERTYPE.length()) {
+			setFilterType((getFilterType() + manyOnes).substring(0, FILTERTYPE.length()));
+		}
+		if (getFilterSize().length() < FILTERSIZE.length()) {
+			setFilterSize((getFilterSize() + manyOnes).substring(0, FILTERSIZE.length()));
+		}
+		if (getFilterDist().length() == 0)
+			setFilterDist("L");
+		if (getFilterDiff().length() == 0)
+			setFilterDiff("L");
+		if (getFilterTerr().length() == 0)
+			setFilterTerr("L");
 	}
 
+	// Getter and Setter for private properties
+
+	public String getFilterType() {
+		return filterType;
+	}
+
+	public void setFilterType(String filterType) {
+		this.notifyUnsavedChanges(!filterType.equals(this.filterType));
+		this.filterType = filterType;
+	}
+
+	public String getFilterRose() {
+		return filterRose;
+	}
+
+	public void setFilterRose(String filterRose) {
+		this.notifyUnsavedChanges(!filterRose.equals(this.filterRose));
+		this.filterRose = filterRose;
+	}
+
+	public String getFilterSize() {
+		return filterSize;
+	}
+
+	public void setFilterSize(String filterSize) {
+		this.notifyUnsavedChanges(!filterSize.equals(this.filterSize));
+		this.filterSize = filterSize;
+	}
+
+	public String getFilterVar() {
+		return filterVar;
+	}
+
+	public void setFilterVar(String filterVar) {
+		this.notifyUnsavedChanges(!filterVar.equals(this.filterVar));
+		this.filterVar = filterVar;
+	}
+
+	public String getFilterDist() {
+		return filterDist;
+	}
+
+	public void setFilterDist(String filterDist) {
+		this.notifyUnsavedChanges(!filterDist.equals(this.filterDist));
+		this.filterDist = filterDist;
+	}
+
+	public String getFilterDiff() {
+		return filterDiff;
+	}
+
+	public void setFilterDiff(String filterDiff) {
+		this.notifyUnsavedChanges(!filterDiff.equals(this.filterDiff));
+		this.filterDiff = filterDiff;
+	}
+
+	public String getFilterTerr() {
+		return filterTerr;
+	}
+
+	public void setFilterTerr(String filterTerr) {
+		this.notifyUnsavedChanges(!filterTerr.equals(this.filterTerr));
+		this.filterTerr = filterTerr;
+	}
+
+	public int getFilterActive() {
+		return filterActive;
+	}
+
+	public void setFilterActive(int filterActive) {
+		this.notifyUnsavedChanges(filterActive != this.filterActive);
+		this.filterActive = filterActive;
+	}
+
+	public boolean isFilterInverted() {
+		return filterInverted;
+	}
+
+	public void setFilterInverted(boolean filterInverted) {
+		this.notifyUnsavedChanges(filterInverted != this.filterInverted);
+		this.filterInverted = filterInverted;
+	}
+
+	public boolean showBlacklisted() {
+		return showBlacklisted;
+	}
+
+	public void setShowBlacklisted(boolean showBlacklisted) {
+		this.notifyUnsavedChanges(showBlacklisted != this.showBlacklisted);
+		this.showBlacklisted = showBlacklisted;
+	}
+
+	public long getFilterAttrYes() {
+		return filterAttrYes;
+	}
+
+	public void setFilterAttrYes(long filterAttrYes) {
+		this.notifyUnsavedChanges(filterAttrYes != this.filterAttrYes);
+		this.filterAttrYes = filterAttrYes;
+	}
+
+	public long getFilterAttrNo() {
+		return filterAttrNo;
+	}
+
+	public void setFilterAttrNo(long filterAttrNo) {
+		this.notifyUnsavedChanges(filterAttrNo != this.filterAttrNo);
+		this.filterAttrNo = filterAttrNo;
+	}
+
+	public int getFilterAttrChoice() {
+		return filterAttrChoice;
+	}
+
+	public void setFilterAttrChoice(int filterAttrChoice) {
+		this.notifyUnsavedChanges(filterAttrChoice != this.filterAttrChoice);
+		this.filterAttrChoice = filterAttrChoice;
+	}
+
+	public String getLast_sync_opencaching() {
+		return last_sync_opencaching;
+	}
+
+	public void setLast_sync_opencaching(String last_sync_opencaching) {
+		this.notifyUnsavedChanges(!last_sync_opencaching.equals(this.last_sync_opencaching));
+		this.last_sync_opencaching = last_sync_opencaching;
+	}
+
+	public String getDistOC() {
+		return distOC;
+	}
+
+	public void setDistOC(String distOC) {
+		this.notifyUnsavedChanges(!distOC.equals(this.distOC));
+		this.distOC = distOC;
+	}
+
+	public String getDistGC() {
+		return distGC;
+	}
+
+	public void setDistGC(String distGC) {
+		this.notifyUnsavedChanges(!distGC.equals(this.distGC));
+		this.distGC = distGC;
+	}
+
 }

Modified: trunk/src/CacheWolf/ProfileDataForm.java
===================================================================
--- trunk/src/CacheWolf/ProfileDataForm.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/ProfileDataForm.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -66,15 +66,15 @@
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(profile.centre, CWPoint.CW);
 				if (cs.execute()== FormBase.IDOK){
+					profile.notifyUnsavedChanges(cs.getCoords().equals(profile.centre));
 					profile.centre.set(cs.getCoords());
 					btnProfileCentre.setText(profile.centre.toString());
-					profile.hasUnsavedChanges=true;
 				}
 			}
 			if (ev.target == btnCur2Prof){
+				profile.notifyUnsavedChanges(pref.curCentrePt.equals(profile.centre));
 				profile.centre.set(pref.curCentrePt);
 				btnProfileCentre.setText(profile.centre.toString());
-				profile.hasUnsavedChanges=true;
 			}
 			if (ev.target == btnProf2Cur){
 				pref.curCentrePt.set(profile.centre);

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/ProfilesForm.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -126,8 +126,8 @@
 				close(-1);
 			}
 			if (ev.target == btnOK || ev.target == choice){
-				Global.getProfile().filterActive=Filter.FILTER_INACTIVE;
-				Global.getProfile().filterInverted=false;
+				Global.getProfile().setFilterActive(Filter.FILTER_INACTIVE);
+				Global.getProfile().setFilterInverted(false);
 				if (choice.getSelectedItem()!=null) {
 					newSelectedProfile=choice.getSelectedItem().toString();
 					close(1);

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/RadarPanel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -106,7 +106,7 @@
 		double pi180=java.lang.Math.PI / 180.0;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(!holder.is_filtered && holder.pos.isValid()) {
+			if(!holder.is_filtered() && holder.pos.isValid()) {
 				degrees = holder.degrees * pi180;
 				x =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
 				y = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
@@ -114,9 +114,9 @@
 					if (toggleMod>0) {
 						String s;
 						if (toggleMod==1)
-							s=holder.wayPoint;
+							s=holder.getWayPoint();
 						else
-							s=holder.CacheName;
+							s=holder.getCacheName();
 						if (s.length()>0) { 
 							int tw;
 							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
@@ -133,15 +133,15 @@
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=CacheType.cache2Img(holder.type);
+					Image imgCache=CacheType.cache2Img(holder.getType());
 					// If we have no image for the cache type use a question mark
 					if (imgCache==null) imgCache=CacheType.cacheImages[8]; 
 					rpi = new RadarPanelImage(imgCache);
-					rpi.wayPoint = holder.wayPoint;
+					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;
 					rpi.setLocation(centerX+x-7,centerY+y-7);
 					iActP.addImage(rpi);
-					if(holder.wayPoint.equals(selectedWaypoint)){ // Draw red circle around selected wpt
+					if(holder.getWayPoint().equals(selectedWaypoint)){ // Draw red circle around selected wpt
 						Image imgCircle = new Image(20, 20);
 						Graphics gCircle = new Graphics(imgCircle);
 						gCircle.setColor(Color.Black);

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -32,12 +32,12 @@
 			//marked caches.
 			for(int i = 0;i < cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
-				if (ch.is_filtered) break; // Reached end of visible records
-				if(ch.wayPoint.toUpperCase().indexOf(searchStr) <0 && 
-				   ch.CacheName.toUpperCase().indexOf(searchStr) <0 && 
-				   ch.CacheStatus.toUpperCase().indexOf(searchStr)<0){
+				if (ch.is_filtered()) break; // Reached end of visible records
+				if(ch.getWayPoint().toUpperCase().indexOf(searchStr) <0 && 
+				   ch.getCacheName().toUpperCase().indexOf(searchStr) <0 && 
+				   ch.getCacheStatus().toUpperCase().indexOf(searchStr)<0){
 					ch.is_flaged = false;
-					ch.is_filtered = true;
+					ch.setFiltered(true);
 				} else
 					ch.is_flaged=true;
 			} // for
@@ -54,7 +54,7 @@
 		for(int i = cacheDB.size()-1;i >=0;i--){
 			CacheHolder ch=((CacheHolder)cacheDB.get(i));
 			ch.is_flaged=false;
-			ch.is_filtered=(ch.is_black^Global.getProfile().showBlacklisted) ;
+			//ch.setFiltered((ch.is_black()^Global.getProfile().showBlacklisted())) ;
 		}
 		//Global.getProfile().filterActive=Filter.filterActive; //TODO This is a hack. Need to tidy this up
 		//Global.getProfile().filterInverted=Filter.filterInverted;

Modified: trunk/src/CacheWolf/ShowCacheInBrowser.java
===================================================================
--- trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -63,21 +63,21 @@
 		if (chD == null) return;
 		try {
 			Template tpl = new Template(args);
-			if(!chD.is_filtered){
+			if(!chD.is_filtered()){
 				Vm.showWait(true);
 				try {
-					if (chD.wayPoint.startsWith("OC"))
-						tpl.setParam("TYPE", "\"file://"+FileBase.getProgramDirectory()+"/"+CacheType.transOCType(chD.type)+".gif\"");
+					if (chD.getWayPoint().startsWith("OC"))
+						tpl.setParam("TYPE", "\"file://"+FileBase.getProgramDirectory()+"/"+CacheType.transOCType(chD.getType())+".gif\"");
 					else	
-						tpl.setParam("TYPE", "\"file://"+FileBase.getProgramDirectory()+"/"+chD.type+".gif\"");
-					tpl.setParam("SIZE", chD.CacheSize);
-					tpl.setParam("WAYPOINT", chD.wayPoint);
-					tpl.setParam("CACHE_NAME", chD.CacheName);
-					tpl.setParam("OWNER", chD.CacheOwner);
-					if (chD.hard.endsWith(".0")) chD.hard=chD.hard.substring(0,chD.hard.length()-2);
-					tpl.setParam("DIFFICULTY", (String) diff.get(chD.hard.replace(',','.')));
-					if (chD.terrain.endsWith(".0")) chD.terrain=chD.terrain.substring(0,chD.terrain.length()-2);
-					tpl.setParam("TERRAIN", (String) terr.get(chD.terrain.replace(',','.')));
+						tpl.setParam("TYPE", "\"file://"+FileBase.getProgramDirectory()+"/"+chD.getType()+".gif\"");
+					tpl.setParam("SIZE", chD.getCacheSize());
+					tpl.setParam("WAYPOINT", chD.getWayPoint());
+					tpl.setParam("CACHE_NAME", chD.getCacheName());
+					tpl.setParam("OWNER", chD.getCacheOwner());
+					if (chD.getHard().endsWith(".0")) chD.setHard(chD.getHard().substring(0,chD.getHard().length()-2));
+					tpl.setParam("DIFFICULTY", (String) diff.get(chD.getHard().replace(',','.')));
+					if (chD.getTerrain().endsWith(".0")) chD.setTerrain(chD.getTerrain().substring(0,chD.getTerrain().length()-2));
+					tpl.setParam("TERRAIN", (String) terr.get(chD.getTerrain().replace(',','.')));
 					tpl.setParam("DISTANCE", chD.getDistance().replace(',','.'));
 					tpl.setParam("BEARING", chD.bearing);
 					if (chD.pos!=null && chD.pos.isValid()) {
@@ -86,10 +86,10 @@
 						tpl.setParam("LATLON", "unknown");
 					}
 					// If status is of format yyyy-mm-dd prefix it with a "Found" message in local language
-					if (chD.CacheStatus.length()>=10 && chD.CacheStatus.charAt(4)=='-')
-						tpl.setParam("STATUS",MyLocale.getMsg(318,"Found")+" "+chD.CacheStatus);
+					if (chD.getCacheStatus().length()>=10 && chD.getCacheStatus().charAt(4)=='-')
+						tpl.setParam("STATUS",MyLocale.getMsg(318,"Found")+" "+chD.getCacheStatus());
 					else
-						tpl.setParam("STATUS", chD.CacheStatus);
+						tpl.setParam("STATUS", chD.getCacheStatus());
 					
 					// Cache attributes
 					if (chD.attributes.getCount()>0) {
@@ -109,7 +109,7 @@
 						tpl.setParam("ATTRIBUTES",attVect);
 					}
 					
-					tpl.setParam("DATE", chD.DateHidden);
+					tpl.setParam("DATE", chD.getDateHidden());
 					tpl.setParam("URL", chD.URL);
 					if (chD.Travelbugs.size()>0) tpl.setParam("BUGS",chD.Travelbugs.toHtml());
 					if (chD.CacheNotes!=null && chD.CacheNotes.trim().length()>0) tpl.setParam("NOTES", STRreplace.replace(chD.CacheNotes,"\n","<br/>\n"));
@@ -183,7 +183,7 @@
 						logVect.add(logs);
 					}
 					tpl.setParam("LOGS",logVect);
-					if (!chD.is_available) tpl.setParam("UNAVAILABLE","1");
+					if (!chD.is_available()) tpl.setParam("UNAVAILABLE","1");
 					if (!chD.Hints.equals("null"))tpl.setParam("HINT",Common.rot13(chD.Hints));
 					
 					if (chD.hasAddiWpt()) {
@@ -191,10 +191,10 @@
 						for (int i=0; i<chD.addiWpts.size(); i++) {
 							Hashtable addis=new Hashtable();
 							CacheHolder ch=(CacheHolder) chD.addiWpts.get(i);
-							addis.put("WAYPOINT",ch.wayPoint);
-							addis.put("NAME",ch.CacheName);
+							addis.put("WAYPOINT",ch.getWayPoint());
+							addis.put("NAME",ch.getCacheName());
 							addis.put("LATLON",ch.LatLon);
-							addis.put("IMG","<img src=\""+CacheType.type2pic(ch.type)+"\">");
+							addis.put("IMG","<img src=\""+CacheType.type2pic(ch.getType())+"\">");
 							CacheHolderDetail chDA=new CacheHolderDetail(ch);
 							chDA.readCache(Global.getProfile().dataDir);
 							addis.put("LONGDESC",chDA.LongDescription); // Do we need to treat longDesc as above ?
@@ -203,8 +203,8 @@
 						tpl.setParam("ADDIS",addiVect);
 					}
 				}catch(Exception e){
-					Vm.debug("Problem getting Parameter, Cache: " + chD.wayPoint);
-					Global.getPref().log("Problem getting parameter "+e.toString()+", Cache: " + chD.wayPoint);
+					Vm.debug("Problem getting Parameter, Cache: " + chD.getWayPoint());
+					Global.getPref().log("Problem getting parameter "+e.toString()+", Cache: " + chD.getWayPoint());
 					e.printStackTrace();
 				}
 			}

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -238,7 +238,7 @@
 				((CacheHolder) cacheDB.get(number)).update(chD);
 			}
 		}catch(Exception ex){
-			pref.log("Error spidering " + chD.wayPoint + " in spiderSingle");
+			pref.log("Error spidering " + chD.getWayPoint() + " in spiderSingle");
 		}
 		return ret;
 	} // spiderSingle
@@ -299,8 +299,8 @@
 		//index the database for faster searching!
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			indexDB.put(ch.wayPoint, new Integer(i));
-			ch.is_new = false;
+			indexDB.put(ch.getWayPoint(), new Integer(i));
+			ch.setNew(false);
 		}
 		String start = "";
 		Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*)\" />");
@@ -330,7 +330,7 @@
 			Double distDouble = new Double();
 			distDouble.value = distance;
 			dist = distDouble.toString(0, 1, 0).replace(',', '.');
-			profile.distGC = dist;
+			profile.setDistGC(dist);
 
 			doNotgetFound = options.foundCheckBox.getState();
 		}
@@ -366,12 +366,12 @@
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (spiderAllFinds) {
-				if ( (ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")) ) {
-					cachesToUpdate.put(ch.wayPoint, new Integer(i));
+				if ( (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) ) {
+					cachesToUpdate.put(ch.getWayPoint(), new Integer(i));
 				}
 			} else {
-				if ( (!ch.is_archived) && (ch.kilom <= distanceInKm) && !(doNotgetFound && ch.is_found) && (ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")) ) {
-					cachesToUpdate.put(ch.wayPoint, new Integer(i));
+				if ( (!ch.is_archived()) && (ch.kilom <= distanceInKm) && !(doNotgetFound && ch.is_found()) && (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) ) {
+					cachesToUpdate.put(ch.getWayPoint(), new Integer(i));
 				}
 			}
 		}
@@ -466,21 +466,21 @@
 							// If the <strike> tag is used, the cache is marked as unavailable or archived
 							boolean is_archived_GC=lineRex.stringMatched(1).indexOf("<strike><font color=\"red\">")!=-1;
 							boolean is_available_GC=lineRex.stringMatched(1).indexOf("<strike>")==-1;
-							if (ch.is_archived!=is_archived_GC) { // Update the database with the cache status
+							if (ch.is_archived()!=is_archived_GC) { // Update the database with the cache status
 								pref.log("Updating status of "+waypoint+" to "+(is_archived_GC?"archived":"not archived"));
-								if ( ch.is_archived ) {
-									cachesToUpdate.put(ch.wayPoint, nr);
+								if ( ch.is_archived() ) {
+									cachesToUpdate.put(ch.getWayPoint(), nr);
 								}
-								ch.is_archived=is_archived_GC;
+								ch.setArchived(is_archived_GC);
 								chD=ch.getCacheDetails(true,false);
 								ch.detailsAdded();
-							} else if (ch.is_available!=is_available_GC) { // Update the database with the cache status
+							} else if (ch.is_available()!=is_available_GC) { // Update the database with the cache status
 								pref.log("Updating status of "+waypoint+" to "+(is_available_GC?"available":"not available"));
-								ch.is_available=is_available_GC;
+								ch.setAvailable(is_available_GC);
 								chD=ch.getCacheDetails(true,false);
 								ch.detailsAdded();
 							} else {
-								cachesToUpdate.remove( ch.wayPoint );
+								cachesToUpdate.remove( ch.getWayPoint() );
 							}
 						}
 					} else distance = 0;
@@ -561,7 +561,7 @@
 			if(searchWpt(wpt) == -1){
 				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + wpt +" (" + (i+1) + " / " + totalCachesToLoad + ")");
 				chD = new CacheHolderDetail();
-				chD.wayPoint=wpt;
+				chD.setWayPoint(wpt);
 				int test = getCacheByWaypointName(chD,false,getImages,doNotgetFound,loadAllLogs);
 				if (test == -1) {
 					infB.close(0);
@@ -569,7 +569,7 @@
 				} else if (test == 0) {
 					spiderErrors++;
 				} else {
-					if (!chD.is_found || !doNotgetFound ) {
+					if (!chD.is_found() || !doNotgetFound ) {
 						chD.saveCacheDetails(profile.dataDir);
 						cacheDB.add(new CacheHolder(chD)); 
 					}
@@ -582,7 +582,7 @@
 			for (Enumeration e = cachesToUpdate.elements() ; e.hasMoreElements() ; j++) {
 				int i = ((Integer)e.nextElement()).intValue();
 				ch = (CacheHolder)cacheDB.get(i);
-				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.wayPoint +" (" + (cachesToLoad.size()+j) + " / " + totalCachesToLoad + ")");
+				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.getWayPoint() +" (" + (cachesToLoad.size()+j) + " / " + totalCachesToLoad + ")");
 				infB.redisplay();
 
 				int test = spiderSingle(i, infB,false);
@@ -591,7 +591,7 @@
 				} else if (test == 0) {
 					spiderErrors++;
 				} else {
-					profile.hasUnsavedChanges=true;	
+					//profile.hasUnsavedChanges=true;	
 				}
 			}
 		}
@@ -604,6 +604,7 @@
 		if ( maxNumberAbort ) {
 			new MessageBox(MyLocale.getMsg(5519,"Information"),MyLocale.getMsg(5520,"Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated."),FormBase.DEFOKB).execute();			
 		}
+		Global.getProfile().restoreFilter();
 		Global.getProfile().saveIndex(Global.getPref(),true);
 	}
 
@@ -631,33 +632,33 @@
 			while (spiderTrys++<MAX_SPIDER_TRYS) {
 				ret = 1;
 				try{
-					String doc = p.getProp("getPageByName") + chD.wayPoint +(fetchAllLogs?p.getProp("fetchAllLogs"):"");
-					pref.log("Fetching: " + chD.wayPoint);
+					String doc = p.getProp("getPageByName") + chD.getWayPoint() +(fetchAllLogs?p.getProp("fetchAllLogs"):"");
+					pref.log("Fetching: " + chD.getWayPoint());
 					completeWebPage = fetch(doc);
 					if	( completeWebPage.equals("")) {
-						pref.log("Could not fetch " + chD.wayPoint);
+						pref.log("Could not fetch " + chD.getWayPoint());
 						if (!infB.isClosed) {
 							continue;
 						} else {
-							chD.is_incomplete = true;
+							chD.setIncomplete(true);
 							return -1;
 						}
 					}
 				}catch(Exception ex){
-					pref.log("Could not fetch " + chD.wayPoint,ex);
+					pref.log("Could not fetch " + chD.getWayPoint(),ex);
 					if (!infB.isClosed) {
 						continue;
 					} else {
-						chD.is_incomplete = true;
+						chD.setIncomplete(true);
 						return -1;
 					}
 				}
 				// Only analyse the cache data and fetch pictures if user has not closed the progress window
 				if (!infB.isClosed) {
 					try{
-						chD.is_new = !isUpdate;
-						chD.is_update = false;
-						chD.is_log_update=false;
+						chD.setNew(!isUpdate);
+						chD.setUpdated(false);
+						chD.setLog_updated(false);
 
 						//first check if coordinates are available to prevent deleting existing coorinates
 						String latLon = getLatLon(completeWebPage);
@@ -667,10 +668,10 @@
 							continue; // Restart the spider
 						}
 
-						chD.is_HTML = true;
-						chD.is_available = true;
-						chD.is_archived = false;
-						chD.is_incomplete = true;
+						chD.setHTML(true);
+						chD.setAvailable(true);
+						chD.setArchived(false);
+						chD.setIncomplete(true);
 						// Save size of logs to be able to check whether any new logs were added
 						//int logsz = chD.CacheLogs.size();
 						//chD.CacheLogs.clear();
@@ -679,8 +680,8 @@
 						chD.ImagesText.clear();
 						chD.ImagesInfo.clear();
 
-						if(completeWebPage.indexOf(p.getProp("cacheUnavailable")) >= 0) chD.is_available = false;
-						if(completeWebPage.indexOf(p.getProp("cacheArchived")) >= 0) chD.is_archived = true;
+						if(completeWebPage.indexOf(p.getProp("cacheUnavailable")) >= 0) chD.setAvailable(false);
+						if(completeWebPage.indexOf(p.getProp("cacheArchived")) >= 0) chD.setArchived(true);
 						//==========
 						// General Cache Data
 						//==========
@@ -693,8 +694,8 @@
 						pref.log("Got description");
 
 						pref.log("Getting cache name");
-						chD.CacheName = SafeXML.cleanback(getName(completeWebPage));
-						if (pref.debug) pref.log("Name: " + chD.CacheName); else pref.log("Got name");
+						chD.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
+						if (pref.debug) pref.log("Name: " + chD.getCacheName()); else pref.log("Got name");
 						
 						pref.log("Trying location (country/state)");
 						String location = getLocation(completeWebPage);
@@ -715,15 +716,15 @@
 						}
 
 						pref.log("Trying owner");
-						chD.CacheOwner = SafeXML.cleanback(getOwner(completeWebPage)).trim();
-						if(chD.CacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()>0 && chD.CacheOwner.equals(pref.myAlias2))) chD.is_owned = true;
-						if (pref.debug) pref.log("Owner: " + chD.CacheOwner +"; is_owned = "+chD.is_owned+";  alias1,2 = ["+pref.myAlias+"|"+pref.myAlias2+"]");
+						chD.setCacheOwner(SafeXML.cleanback(getOwner(completeWebPage)).trim());
+						if(chD.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length()>0 && chD.getCacheOwner().equals(pref.myAlias2))) chD.setOwned(true);
+						if (pref.debug) pref.log("Owner: " + chD.getCacheOwner() +"; is_owned = "+chD.is_owned()+";  alias1,2 = ["+pref.myAlias+"|"+pref.myAlias2+"]");
 						else pref.log("Got owner");
 
 
 						pref.log("Trying date hidden");
-						chD.DateHidden = DateFormat.MDY2YMD(getDateHidden(completeWebPage));
-						if (pref.debug) pref.log("Hidden: " + chD.DateHidden);
+						chD.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
+						if (pref.debug) pref.log("Hidden: " + chD.getDateHidden());
 						else pref.log("Got date hidden");
 
 						pref.log("Trying hints");
@@ -732,23 +733,23 @@
 						else pref.log("Got hints");
 
 						pref.log("Trying size");
-						chD.CacheSize = getSize(completeWebPage);
-						if (pref.debug) pref.log("Size: " + chD.CacheSize);
+						chD.setCacheSize(getSize(completeWebPage));
+						if (pref.debug) pref.log("Size: " + chD.getCacheSize());
 						else pref.log("Got size");
 
 						pref.log("Trying difficulty");
-						chD.hard = getDiff(completeWebPage);
-						if (pref.debug) pref.log("Hard: " + chD.hard);
+						chD.setHard(getDiff(completeWebPage));
+						if (pref.debug) pref.log("Hard: " + chD.getHard());
 						else pref.log("Got difficulty");
 
 						pref.log("Trying terrain");
-						chD.terrain = getTerr(completeWebPage);
-						if (pref.debug) pref.log("Terr: " + chD.terrain);
+						chD.setTerrain(getTerr(completeWebPage));
+						if (pref.debug) pref.log("Terr: " + chD.getTerrain());
 						else pref.log("Got terrain");
 
 						pref.log("Trying cache type");
-						chD.type = getType(completeWebPage);
-						if (pref.debug) pref.log("Type: " + chD.type);
+						chD.setType(getType(completeWebPage));
+						if (pref.debug) pref.log("Type: " + chD.getType());
 						else pref.log("Got cache type");
 
 						//==========
@@ -759,7 +760,7 @@
 						pref.log("Found logs");
 
 						// If the switch is set to not store found caches and we found the cache => return
-						if (chD.is_found && doNotGetFound) {
+						if (chD.is_found() && doNotGetFound) {
 							if (infB.isClosed) {
 								return -1;
 							} else {
@@ -772,7 +773,7 @@
 						//==========
 						// As there may be several bugs, we check whether the user has aborted
 						if (!infB.isClosed) getBugs(chD,completeWebPage);
-						chD.has_bug = chD.Travelbugs.size()>0;
+						chD.setHas_bugs(chD.Travelbugs.size()>0);
 
 						//==========
 						// Images
@@ -787,7 +788,7 @@
 						//==========
 
 						pref.log("Getting additional waypoints");
-						getAddWaypoints(completeWebPage, chD.wayPoint, chD.is_found);
+						getAddWaypoints(completeWebPage, chD.getWayPoint(), chD.is_found());
 						pref.log("Got additional waypoints");
 
 						//==========
@@ -796,11 +797,11 @@
 						pref.log("Getting attributes");
 						getAttributes(completeWebPage, chD);
 						pref.log("Got attributes");
-						if (chD.is_new) chD.is_update=false;
-						chD.is_incomplete = false;
+						if (chD.is_new()) chD.setUpdated(false);
+						chD.setIncomplete(false);
 						break;
 					}catch(Exception ex){
-						pref.log("Error reading cache: "+chD.wayPoint);
+						pref.log("Error reading cache: "+chD.getWayPoint());
 						pref.log("Exception in getCacheByWaypointName: ",ex);
 					}
 					finally{}
@@ -1046,8 +1047,8 @@
 			String d=DateFormat.logdate2YMD(exDate.findNext());
 			if((icon.equals(p.getProp("icon_smile")) || icon.equals(p.getProp("icon_camera")) || icon.equals(p.getProp("icon_attended"))) &&
 				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && name.equalsIgnoreCase(pref.myAlias2))) )  {
-				chD.is_found = true;
-				chD.CacheStatus = d;
+				chD.setFound(true);
+				chD.setCacheStatus(d);
 				chD.OwnLogId = logId;
 				chD.OwnLog = new Log(icon,d,name,logText);
 			}
@@ -1063,7 +1064,7 @@
 			exLogId.setSource(singleLog);
 			// We cannot simply stop if we have reached MAXLOGS just in case we are waiting for
 			// a log by our alias that happened earlier.
-			if (nLogs>=MAXLOGS && chD.is_found && (chD.OwnLogId.length() != 0) && (chD.OwnLog != null) && !(chD.OwnLog.getDate().equals("1900-01-01"))) break;
+			if (nLogs>=MAXLOGS && chD.is_found() && (chD.OwnLogId.length() != 0) && (chD.OwnLog != null) && !(chD.OwnLog.getDate().equals("1900-01-01"))) break;
 		}
 		if (nLogs>MAXLOGS) {
 			reslts.add(Log.maxLog());
@@ -1133,7 +1134,7 @@
 		//========
 		String longDesc = "";
 		try {
-			if (chD.wayPoint.startsWith("TC")) longDesc = doc;
+			if (chD.getWayPoint().startsWith("TC")) longDesc = doc;
 			else
 				longDesc = getLongDesc(doc);
 			longDesc = STRreplace.replace(longDesc, "<img", "<IMG");
@@ -1159,7 +1160,7 @@
 					if(imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")){
 						// Check whether image was already spidered for this cache
 						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.wayPoint + "_" + Convert.toString(imgCounter);
+						imgName = chD.getWayPoint() + "_" + Convert.toString(imgCounter);
 						if (idxUrl<0) { // New image
 							pref.log("Loading image: " + imgUrl+" as "+imgName);
 							spiderImage(imgUrl, imgName+imgType);
@@ -1167,7 +1168,7 @@
 							spideredUrls.add(imgUrl);
 						} else { // Image already spidered as wayPoint_'idxUrl'
 							pref.log("Already loaded image: " + imgUrl);
-							oldImgName = chD.wayPoint + "_" + Convert.toString(idxUrl);
+							oldImgName = chD.getWayPoint() + "_" + Convert.toString(idxUrl);
 							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
 						}
 						chD.ImagesText.add(imgName); // Keep the image name
@@ -1206,14 +1207,14 @@
 					if(imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")){
 						// Check whether image was already spidered for this cache
 						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.wayPoint + "_" + Convert.toString(imgCounter);
+						imgName = chD.getWayPoint() + "_" + Convert.toString(imgCounter);
 						if (idxUrl<0) { // New image
 							pref.log("Loading image: " + imgUrl);
 							spiderImage(imgUrl, imgName+imgType);
 							chD.Images.add(imgName+imgType);
 						} else { // Image already spidered as wayPoint_ 'idxUrl'
 							pref.log("Already loaded image: " + imgUrl);
-							oldImgName = chD.wayPoint + "_" + Convert.toString(idxUrl);
+							oldImgName = chD.getWayPoint() + "_" + Convert.toString(idxUrl);
 							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
 						}
 						chD.ImagesText.add(exImgName.findNext()); // Keep the image description
@@ -1246,7 +1247,7 @@
 						// Check whether image was already spidered for this cache
 						idxUrl=spideredUrls.find(imgUrl);
 						if (idxUrl<0) { // New image
-							imgName = chD.wayPoint + "_" + Convert.toString(imgCounter);
+							imgName = chD.getWayPoint() + "_" + Convert.toString(imgCounter);
 							pref.log("Loading image: " + imgUrl+" as "+imgName);
 							spiderImage(imgUrl, imgName+imgType);
 							chD.Images.add(imgName+imgType);
@@ -1348,27 +1349,29 @@
 						cxD.readCache(profile.dataDir);
 					} catch (Exception ex) {};
 				} else {
-					cxD=new CacheHolderDetail(); cxD.wayPoint=adWayPoint;
+					cxD=new CacheHolderDetail(); cxD.setWayPoint(adWayPoint);
 				}
-				cxD.is_update=false; cxD.is_new=false;
+				cxD.setUpdated(false); 
+				cxD.setNew(false);
 				nameRex.search(rowBlock);
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
-				cxD.CacheName = nameRex.stringMatched(1);
+				cxD.setCacheName(nameRex.stringMatched(1));
 				if(koordRex.didMatch()) cxD.setLatLon(koordRex.stringMatched(1));
-				if(typeRex.didMatch()) cxD.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
+				if(typeRex.didMatch()) cxD.setType(CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1)));
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
 				cxD.setLongDescription(descRex.stringMatched(1));
-				cxD.is_found = is_found;
+				cxD.setFound(is_found);
 				cxD.saveCacheDetails(profile.dataDir);
 				if (idx<0){
-					cxD.is_new=true; cxD.is_update=false;
+					cxD.setNew(true); 
+					cxD.setUpdated(false);
 					cacheDB.add(new CacheHolder(cxD));
 				}else {
 					CacheHolder cx=(CacheHolder) cacheDB.get(idx);
 					if (cx.is_Checked && // Only re-spider existing addi waypoints that are ticked
-				 	   !cx.is_filtered) { // and are visible (i.e.  not filtered)
+				 	   !cx.is_filtered()) { // and are visible (i.e.  not filtered)
 					   cx.update(cxD);
 					   cx.is_Checked=true;
 					}
@@ -1388,8 +1391,8 @@
 			chD.attributes.add(attribute);
 			attribute=attEx.findNext();
 		}
-		chD.attributesYes = chD.attributes.attributesYes;
-		chD.attributesNo = chD.attributes.attributesNo;
+		chD.setAttributesYes(chD.attributes.attributesYes);
+		chD.setAttributesNo(chD.attributes.attributesNo);
 	}
 
 

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/StatusBar.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -58,11 +58,11 @@
 					MyLocale.getMsg(4502,"Fnd:") + " " + stats.totalFound() + "  ";
 		disp.setText(strStatus);
 		// Indicate that a filter is active in the status line
-		if (Global.getProfile().filterActive==Filter.FILTER_ACTIVE)
+		if (Global.getProfile().getFilterActive()==Filter.FILTER_ACTIVE)
 			btnFlt.backGround=new Color(0,255,0);
-		else if (Global.getProfile().filterActive==Filter.FILTER_CACHELIST)
+		else if (Global.getProfile().getFilterActive()==Filter.FILTER_CACHELIST)
 			btnFlt.backGround=new Color(0,0,255);
-		else if (Global.getProfile().filterActive==Filter.FILTER_MARKED_ONLY)
+		else if (Global.getProfile().getFilterActive()==Filter.FILTER_MARKED_ONLY)
 			btnFlt.backGround=new Color(0,255,255);
 		else
 			btnFlt.backGround=null;
@@ -80,7 +80,7 @@
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnFlt){
 				Filter flt = new Filter();
-				if (Global.getProfile().filterActive==Filter.FILTER_INACTIVE) {
+				if (Global.getProfile().getFilterActive()==Filter.FILTER_INACTIVE) {
 					flt.setFilter();
 					flt.doFilter();
 				} else {

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/TablePanel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -81,7 +81,6 @@
 	public void resetModel() {
 		myMod.numRows = cacheDB.size();
 		Global.getProfile().updateBearingDistance();
-		Global.getProfile().restoreFilter(); // Restore the isActive & isInverted status of the filter
 		tc.scrollToVisible(0,0);
 		refreshTable();
 	}
@@ -103,7 +102,7 @@
 		Vector oldVisibleCaches = null;
 		int sel = getSelectedCache();
 		if ((sel >= 0) && (sel < cacheDB.size()) ) // sel > cacheDB.size() can happen if you load a new profile, which is smaller than the old profile and you selected one cache that exceeds the number of caches in the new profile  
-			wayPoint = ((CacheHolder)cacheDB.get(sel)).wayPoint;
+			wayPoint = ((CacheHolder)cacheDB.get(sel)).getWayPoint();
 		else wayPoint = null;
 		// Then: remember all caches that are visible before the refresh
 		if (wayPoint != null) {
@@ -125,7 +124,7 @@
 				int i;
 				for (i=sel-1; i>=0; i--) {
 					CacheHolder checkCache = (CacheHolder) oldVisibleCaches.get(i);
-					rownum = Global.getProfile().getCacheIndex(checkCache.wayPoint);
+					rownum = Global.getProfile().getCacheIndex(checkCache.getWayPoint());
 					if ((rownum >= 0) && (rownum < myMod.numRows)) break;
 					rownum = 0;	
 				}

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -65,13 +65,13 @@
 		String cache="";
 		if (curCacheNo>=0 && curCacheNo<cacheDB.size()) {
 			ch=(CacheHolder)cacheDB.elementAt(curCacheNo);
-			cache=MyLocale.getMsg(6022,": Current cache: ")+ch.wayPoint+" - "+ch.CacheName;
-			waypoint=ch.wayPoint;
+			cache=MyLocale.getMsg(6022,": Current cache: ")+ch.getWayPoint()+" - "+ch.getCacheName();
+			waypoint=ch.getWayPoint();
 			chD=new CacheHolderDetail(ch);
 			try {
 				chD.readCache(Global.getProfile().dataDir);
 			}catch (Exception ex) {
-				Global.getPref().log("Failed to read cache "+ch.wayPoint);
+				Global.getPref().log("Failed to read cache "+ch.getWayPoint());
 			};
 			tblSrcCache=chD.Travelbugs;
 		}
@@ -254,7 +254,7 @@
 			// If the list of travelbugs in the cache was modified, we need to save the cache too
 			if (chDmodified) {
 				chD.saveCacheDetails(Global.getProfile().dataDir);
-				ch.has_bug=chD.Travelbugs.size()>0;
+				ch.setHas_bugs(chD.Travelbugs.size()>0);
 			}
 			Vm.showWait(false);
 			chD=null;
@@ -497,7 +497,7 @@
 				chD.Travelbugs.add(tb);
 				tblMyTravelbugJourneys.addTbDrop(tb,Global.getProfile().name,waypoint);
 				chDmodified=true;
-				ch.has_bug=true;
+				ch.setHas_bugs(true);
 			}
 			repaint();
 		}

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -57,8 +57,8 @@
 		RadarPanelImage imgRP=(RadarPanelImage) which;
 		ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
-		String s=ch.wayPoint+"  "+ch.CacheSize+" / "+strDifficulty+"="+ch.hard+"  "+strTerrain+"="+ch.terrain;
-		String s1=ch.CacheName;
+		String s=ch.getWayPoint()+"  "+ch.getCacheSize()+" / "+strDifficulty+"="+ch.getHard()+"  "+strTerrain+"="+ch.getTerrain();
+		String s1=ch.getCacheName();
 		if (s1.length()>40) s1=s1.substring(0,40);
 		int tw=fm.getTextWidth(s)+2;
 		int tw1=fm.getTextWidth(s1)+2;
@@ -110,8 +110,8 @@
 			 //wayPoint=ch.wayPoint;
 			 //Vm.debug("Waypoint : "+ch.wayPoint);
 			 IconAndText icnDrag=new IconAndText();
-			 icnDrag.addColumn(CacheType.cache2Img(ch.type));
-			 icnDrag.addColumn(ch.wayPoint);
+			 icnDrag.addColumn(CacheType.cache2Img(ch.getType()));
+			 icnDrag.addColumn(ch.getWayPoint());
 			 dc.dragData=dc.startImageDrag(icnDrag,new Point(8,8),this);
 			 //if (dc instanceof ImageDragContext) Vm.debug(">>>>Is Image drag");
 			 canScroll=false;
@@ -134,7 +134,7 @@
 			RadarPanelImage imgRP=(RadarPanelImage) which;
 			ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
 			CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
-			wayPoint=ch.wayPoint;
+			wayPoint=ch.getWayPoint();
 			
 			int tw,th;
 			Image img = new Image(tw=fm.getTextWidth(wayPoint+15),th=fm.getHeight()>15?fm.getHeight():15);

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/myTableControl.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -102,7 +102,7 @@
 				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
 				else if (ev.key == IKeys.DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1)); 
 				else if (ev.key == IKeys.UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
-				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y>=0 && cursor.y<tbp.myMod.numRows) Global.mainForm.cacheList.addCache(((CacheHolder)cacheDB.elementAt(cursor.y)).wayPoint); 
+				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y>=0 && cursor.y<tbp.myMod.numRows) Global.mainForm.cacheList.addCache(((CacheHolder)cacheDB.elementAt(cursor.y)).getWayPoint()); 
 				else if (ev.key == IKeys.RIGHT) {
 					CacheHolder ch;
 					ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
@@ -150,7 +150,7 @@
 				CacheHolder currCache = (CacheHolder)cacheDB.get(i);
 				if ( currCache.is_Checked) {
 					allCount++;
-					if (currCache.is_filtered) {
+					if (currCache.is_filtered()) {
 						if (currCache.isAddiWpt()) {
 							addiFilteredCount++;
 						} else {
@@ -185,11 +185,11 @@
 					int size=cacheDB.size();
 					for(int i = size-1; i >=0; i--){// Start Counting down, as the size decreases with each deleted cache
 						ch = (CacheHolder)cacheDB.get(i);
-						if(ch.is_Checked && (!ch.is_filtered || deleteFiltered)) {
+						if(ch.is_Checked && (!ch.is_filtered() || deleteFiltered)) {
 							nDeleted++;
 							h.progress = ((float)nDeleted)/(float)allCount;
 							h.changed();
-							dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
+							dm.deleteCacheFiles(ch.getWayPoint(),profile.dataDir);
 							cacheDB.remove(ch);
 							ch.releaseCacheDetails();
 							ch=null;
@@ -298,11 +298,11 @@
 			}
 			 row=p.y;
 			 CacheHolder ch=(CacheHolder)cacheDB.get(p.y);
-			 wayPoint=ch.wayPoint;
+			 wayPoint=ch.getWayPoint();
 			 //Vm.debug("Waypoint : "+ch.wayPoint);
 			 imgDrag=new IconAndText();
-			 imgDrag.addColumn(CacheType.cache2Img(ch.type));
-			 imgDrag.addColumn(ch.wayPoint);
+			 imgDrag.addColumn(CacheType.cache2Img(ch.getType()));
+			 imgDrag.addColumn(ch.getWayPoint());
 			 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
 		 } else super.startDragging(dc);
 	 }

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -129,13 +129,13 @@
 		int size=cacheDB.size();
 		for (int i=0; i<size; i++){
 			ch = (CacheHolder) cacheDB.get(i);
-			if (ch.is_filtered) {
+			if (ch.is_filtered()) {
 				filteredDB.add(ch);
 			} else { // point is not filtered
 				if (ch.isAddiWpt()){ // unfiltered Addi Wpt
 					// check if main wpt is filtered
 					if(ch.mainCache != null) { // parent exists
-						if (ch.mainCache.is_filtered) 
+						if (ch.mainCache.is_filtered()) 
 							sortDB.add(ch); // Unfiltered Addi Wpt with filtered Main Wpt, show it on its own
 						// else Main cache is not filtered, Addi will be added below main cache further down
 					} else { //Addi without main Cache
@@ -146,7 +146,7 @@
 					if (ch.hasAddiWpt()){
 						for (int j=0; j<ch.addiWpts.getCount();j++){
 							addiWpt = (CacheHolder)ch.addiWpts.get(j);
-							if (!addiWpt.is_filtered) sortDB.add(addiWpt);
+							if (!addiWpt.is_filtered()) sortDB.add(addiWpt);
 						}
 					}// if hasAddiWpt
 				} // if AddiWpt
@@ -171,17 +171,17 @@
 			try {
 			   CacheHolder ch = (CacheHolder)cacheDB.get(row);
 				if(isSelected == true) ta.fillColor = COLOR_SELECTED;
-				else if(ch.is_available == false && ch.is_found == true){
+				else if(ch.is_available() == false && ch.is_found() == true){
 					ta.fillColor = COLOR_ARCHFND_BG;   // Green BG
 					ta.foreground = COLOR_ARCHFND_FG;  // Red FG
 				}
-				else if(ch.is_archived == true) ta.fillColor = COLOR_ARCHIVED;
-				else if(ch.is_available == false) ta.fillColor = COLOR_AVAILABLE;
-				else if(ch.is_owned == true) ta.fillColor = COLOR_OWNED;
-				else if(ch.is_found == true) ta.fillColor = COLOR_FOUND;
-				else if(ch.is_flaged == true) ta.fillColor = COLOR_FLAGED;
+				else if( ch.is_archived())  ta.fillColor = COLOR_ARCHIVED;
+				else if(!ch.is_available()) ta.fillColor = COLOR_AVAILABLE;
+				else if( ch.is_owned())     ta.fillColor = COLOR_OWNED;
+				else if( ch.is_found())     ta.fillColor = COLOR_FOUND;
+				else if( ch.is_flaged)        ta.fillColor = COLOR_FLAGED;
 			} catch (Exception e) {};
-		} else if (row==-1 && colMap[col]==0 && Global.getProfile().showBlacklisted) ta.fillColor=Color.Black;
+		} else if (row==-1 && colMap[col]==0 && Global.getProfile().showBlacklisted()) ta.fillColor=Color.Black;
 		return ta;
 	}
 
@@ -211,7 +211,7 @@
 		if(row == -1) return colName[colMap[col]];
 		try { // Access to row can fail if many caches are deleted
 			CacheHolder ch = (CacheHolder)cacheDB.get(row);
-			if(ch.is_filtered == false){
+			if(ch.is_filtered() == false){
 				switch(colMap[col]) { // Faster than using column names
 					case 0: // Checkbox
 						if (ch.is_Checked) 
@@ -219,48 +219,48 @@
 						else 
 							return checkboxUnticked;
 					case 1: // Type
-						return CacheType.cache2Img(ch.type);
+						return CacheType.cache2Img(ch.getType());
 					case 2: // Difficulty;
-						return ch.hard;
+						return ch.getHard();
 					case 3: // Terrain
-						return ch.terrain;
+						return ch.getTerrain();
 					case 4: // Waypoint
 						if (showExtraWptInfo) {
-							if(ch.is_incomplete) return new IconAndText(skull, ch.wayPoint, fm);
-							if(ch.is_new       ) return new IconAndText(yellow, ch.wayPoint, fm);
-							if(ch.is_update    ) return new IconAndText(red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
-							if(ch.is_log_update) return new IconAndText(blue, ch.wayPoint, fm);
+							if(ch.is_incomplete()) return new IconAndText(skull, ch.getWayPoint(), fm);
+							if(ch.is_new()       ) return new IconAndText(yellow, ch.getWayPoint(), fm);
+							if(ch.is_updated()    ) return new IconAndText(red, ch.getWayPoint(), fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
+							if(ch.is_log_updated()) return new IconAndText(blue, ch.getWayPoint(), fm);
 						}
-						return ch.wayPoint;
+						return ch.getWayPoint();
 					case 5: // Cachename
 						// Fast return for majority of case
-						if (!showExtraWptInfo || (ch.has_bug == false && ch.noFindLogs==0)) return ch.CacheName; 
+						if (!showExtraWptInfo || (ch.has_bugs() == false && ch.getNoFindLogs()==0)) return ch.getCacheName(); 
 						// Now need more checks
 						IconAndText wpVal = new IconAndText();
-						if(ch.has_bug == true) wpVal.addColumn(bug);
-						if(ch.noFindLogs > 0){
-							if (ch.noFindLogs > noFindLogs.length) 
+						if(ch.has_bugs() == true) wpVal.addColumn(bug);
+						if(ch.getNoFindLogs() > 0){
+							if (ch.getNoFindLogs() > noFindLogs.length) 
 								wpVal.addColumn(noFindLogs[noFindLogs.length-1]);
 							else 
-								wpVal.addColumn(noFindLogs[ch.noFindLogs-1]);
+								wpVal.addColumn(noFindLogs[ch.getNoFindLogs()-1]);
 						}
-						wpVal.addColumn(ch.CacheName);
+						wpVal.addColumn(ch.getCacheName());
 						return wpVal;
 					case 6: // Location
 						return ch.LatLon;
 					case 7: // Owner
-						return ch.CacheOwner;
+						return ch.getCacheOwner();
 					case 8: // Date hidden
-						return ch.DateHidden;
+						return ch.getDateHidden();
 					case 9: // Status
-						return ch.CacheStatus;
+						return ch.getCacheStatus();
 					case 10: // Distance
 						return ch.getDistance();
 					case 11: // Bearing
 						return ch.bearing;
 					case 12: // Size
-						if (ch.CacheSize.length()==0) return "?";
-						switch (ch.CacheSize.charAt(0)) {
+						if (ch.getCacheSize().length()==0) return "?";
+						switch (ch.getCacheSize().charAt(0)) {
 							case 'M': return picSizeMicro;
 							case 'S': return picSizeSmall;
 							case 'R': return picSizeReg;
@@ -269,11 +269,11 @@
 							default: return "?";
 						}
 					case 13: // OC number of recommendations
-						if (ch.wayPoint.startsWith("OC"))
-							return Convert.formatInt(ch.numRecommended);
+						if (ch.getWayPoint().startsWith("OC"))
+							return Convert.formatInt(ch.getNumRecommended());
 						return null;
 					case 14: // OC rating	
-						if (ch.wayPoint.startsWith("OC"))
+						if (ch.getWayPoint().startsWith("OC"))
 							return Convert.formatInt(ch.recommendationScore);
 						return null;
 				} // Switch
@@ -323,7 +323,7 @@
 				cacheDB.sort(new MyComparer(cacheDB, mappedCol,numRows), sortAsc);
 				updateRows();
 				if(a != null){
-					int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
+					int rownum = Global.getProfile().getCacheIndex(ch.getWayPoint());
 					if(rownum >= 0){
 						tcControl.cursorTo(rownum, 0, true);
 	/*					tcControl.scrollToVisible(rownum, 0);
@@ -365,7 +365,7 @@
 				for (int i=0;i<addiCount;i++){
 					addiWpt = (CacheHolder)ch.addiWpts.get(i);
 					addiWpt.is_Checked = ch.is_Checked;
-					if (!addiWpt.is_filtered){
+					if (!addiWpt.is_filtered()){
 						tcControl.repaintCell(cacheDB.find(addiWpt), x);
 					}
 				}

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -410,7 +410,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = myNavigation.gpsPos.toString();
 				ch.pos = new CWPoint(myNavigation.gpsPos);
-				ch.type = 51; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				ch.setType(51); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -85,8 +85,8 @@
 		pnlTiles.addLast(cachesLbl);
 		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		distanceInput = new mInput();
-		int tmp = Convert.toInt((Global.getProfile().distOC));
-		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().distGC)));
+		int tmp = Convert.toInt((Global.getProfile().getDistOC()));
+		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().getDistGC())));
 		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
 		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		pnlTiles.addLast(km);
@@ -248,11 +248,11 @@
 					}
 					if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
 						numdownloaded++;
-						progressBox.setInfo(MyLocale.getMsg(1820, "Downloading map '")+mapLoader.currentOnlineMapService.getName()+"'\n"+numdownloaded+" / "+numCaches+MyLocale.getMsg(1821, "\n for cache:\n")+ch.CacheName);
+						progressBox.setInfo(MyLocale.getMsg(1820, "Downloading map '")+mapLoader.currentOnlineMapService.getName()+"'\n"+numdownloaded+" / "+numCaches+MyLocale.getMsg(1821, "\n for cache:\n")+ch.getCacheName());
 						try {
 							mapLoader.downloadMap(ch.pos, scale, size, mapsDir);
 						} catch (Exception e) {
-							progressBox.addWarning(MyLocale.getMsg(1822, "Cache:")+" " + ch.CacheName + "(" + ch.wayPoint + ") "+MyLocale.getMsg(1823, "Ignoring error:")+" " + e.getMessage()+"\n");
+							progressBox.addWarning(MyLocale.getMsg(1822, "Cache:")+" " + ch.getCacheName() + "(" + ch.getWayPoint() + ") "+MyLocale.getMsg(1823, "Ignoring error:")+" " + e.getMessage()+"\n");
 						}
 					}
 				}

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -378,8 +378,8 @@
 			CacheHolder ch;
 			for (int i=cacheDB.size()-1; i>=0; i--) {
 				ch = (CacheHolder) cacheDB.get(i);
-				if (ch.is_Checked && !ch.is_filtered && ch != mainT.ch) {
-					if (ch.pos.isValid()) addSymbol(ch.CacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
+				if (ch.is_Checked && !ch.is_filtered() && ch != mainT.ch) {
+					if (ch.pos.isValid()) addSymbol(ch.getCacheName(), ch, CacheType.cache2Img(ch.getType()), ch.pos);
 				}
 			}
 		}
@@ -401,7 +401,7 @@
 		}
 		if (ch != null) {
 			addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos);
-			addSymbolIfNecessary(ch.CacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
+			addSymbolIfNecessary(ch.getCacheName(), ch, CacheType.cache2Img(ch.getType()), ch.pos);
 		}
 		markedCache = ch;
 	}
@@ -1753,9 +1753,9 @@
 				if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
 					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
 					if (clickedCache != null) {
-						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(4270, "Open")+" '"+(clickedCache.CacheName.length()>0 ? clickedCache.CacheName : clickedCache.wayPoint)+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
+						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(4270, "Open")+" '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
 						kontextMenu.addItem(openCacheDescMenuItem);
-						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, "Goto")+ " '"+(clickedCache.CacheName.length()>0 ? clickedCache.CacheName : clickedCache.wayPoint)+"'$g"); // clickedCache == null can happen if clicked on the goto-symbol
+						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, "Goto")+ " '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$g"); // clickedCache == null can happen if clicked on the goto-symbol
 						kontextMenu.addItem(gotoCacheMenuItem);
 						if (Global.mainForm.cacheListVisible) { 
 							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
@@ -1888,7 +1888,7 @@
 					}
 					if (action == addCachetoListMenuItem) {
 						kontextMenu.close();
-						Global.mainForm.cacheList.addCache(clickedCache.wayPoint);
+						Global.mainForm.cacheList.addCache(clickedCache.getWayPoint());
 					}
 					for (int i=0; i<miLuminary.length; i++) {
 						if (action == miLuminary[i]) {

Modified: trunk/src/exp/ASCExporter.java
===================================================================
--- trunk/src/exp/ASCExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/ASCExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -22,7 +22,7 @@
 	public String record (CacheHolderDetail holder, String lat, String lon){
 		StringBuffer strBuf = new StringBuffer(100);
 		String dummy;
-		dummy = holder.CacheName;
+		dummy = holder.getCacheName();
 		dummy = dummy.replace(',', ' ');
 		strBuf.append(dummy);
 		strBuf.append(",");

Modified: trunk/src/exp/ExploristExporter.java
===================================================================
--- trunk/src/exp/ExploristExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/ExploristExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -129,7 +129,7 @@
 		int expCount = 0;
 		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = (CacheHolder) cacheDB.get(i);
-			if (ch.is_black == false && ch.is_filtered == false)
+			if (ch.is_black() == false && ch.is_filtered() == false)
 				counter++;
 		}
 
@@ -137,7 +137,7 @@
 			PrintWriter outp = null;
 			for (int i = 0; i < cacheDB.size(); i++) {
 				ch = (CacheHolder) cacheDB.get(i);
-				if (ch.is_black == false && ch.is_filtered == false) {
+				if (ch.is_black() == false && ch.is_filtered() == false) {
 					// all 200 caches we need a new file
 					if (expCount % 200 == 0) {
 						if (outp != null) {
@@ -226,42 +226,42 @@
 		sb.append("E,");
 		sb.append("0000,"); // Height
 		sb.append("M,"); // in meter
-		sb.append(chD.wayPoint);
+		sb.append(chD.getWayPoint());
 		sb.append(",");
 		String add = "";
 		if (chD.isAddiWpt()) {
-			if (chD.type == 50) {
+			if (chD.getType() == 50) {
 				add = "Pa:";
-			} else if (chD.type == 51) {
+			} else if (chD.getType() == 51) {
 				add = "St:";
-			} else if (chD.type == 52) {
+			} else if (chD.getType() == 52) {
 				add = "Qu:"; 
-			} else if (chD.type == 53) {	
+			} else if (chD.getType() == 53) {	
 				add = "Fi:";
-			} else if (chD.type == 54) {
+			} else if (chD.getType() == 54) {
 				add = "Tr:";
-			} else if (chD.type == 55) {	
+			} else if (chD.getType() == 55) {	
 				add = "Re:";
 			}
-			sb.append(add).append(removeCommas(chD.CacheName));
+			sb.append(add).append(removeCommas(chD.getCacheName()));
 		} else {
-			sb.append(removeCommas(chD.CacheName));
+			sb.append(removeCommas(chD.getCacheName()));
 		}		
 		sb.append(",");
-		sb.append(removeCommas(chD.CacheOwner));
+		sb.append(removeCommas(chD.getCacheOwner()));
 		sb.append(",");
 		sb.append(removeCommas(Common.rot13(chD.Hints)));
 		sb.append(",");
 		
 		if (!add.equals("")) { // Set Picture in Explorist to Virtual
 			sb.append("Virtual Cache");
-		} else if (chD.type != 8) { // Rewrite Unknown Caches
-			sb.append(CacheType.transType(chD.type));
+		} else if (chD.getType() != 8) { // Rewrite Unknown Caches
+			sb.append(CacheType.transType(chD.getType()));
 		} else {
 			sb.append("Mystery Cache");
 		}
 		sb.append(",");
-		sb.append(toGsDateFormat(chD.DateHidden));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(toGsDateFormat(chD.getDateHidden()));  // created - DDMMYYY, YYY = year - 1900
 		sb.append(",");
 		String lastFound = "0000";
 		for (int i = 0; i < chD.CacheLogs.size(); i++) {
@@ -272,9 +272,9 @@
 		
 		sb.append(toGsDateFormat(lastFound)); // lastFound - DDMMYYY, YYY = year - 1900
 		sb.append(",");
-		sb.append(removeCommas(chD.hard));
+		sb.append(removeCommas(chD.getHard()));
 		sb.append(",");
-		sb.append(removeCommas(chD.terrain));
+		sb.append(removeCommas(chD.getTerrain()));
 		sb.append("*41");
 		return Exporter.simplifyString(sb.toString() + "\r\n");
 	}

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/Exporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -94,7 +94,7 @@
 		int expCount = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.is_black == false && ch.is_filtered == false) counter++;
+			if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 		}
 
 		try{
@@ -104,7 +104,7 @@
 			holder=new CacheHolderDetail();
 			for(int i = 0; i<cacheDB.size(); i++){
 				ch=(CacheHolder)cacheDB.get(i);
-				if(ch.is_black == false && ch.is_filtered == false){
+				if(ch.is_black() == false && ch.is_filtered() == false){
 					expCount++;
 					h.progress = (float)expCount/(float)counter;
 					h.changed();
@@ -417,20 +417,20 @@
 
     public static String getShortDetails( CacheHolder ch ) {
     	StringBuffer strBuf = new StringBuffer(7);
-    	strBuf.append(CacheType.shortType(ch.type).toLowerCase());			
+    	strBuf.append(CacheType.shortType(ch.getType()).toLowerCase());			
     	if (!ch.isAddiWpt()) {
-    		if ( (ch.hard.length() > 0) && (ch.terrain.length() > 0) ) {
-    			strBuf.append(ch.hard.charAt(0));
-    			if ( ch.hard.endsWith(".5") ) {
+    		if ( (ch.getHard().length() > 0) && (ch.getTerrain().length() > 0) ) {
+    			strBuf.append(ch.getHard().charAt(0));
+    			if ( ch.getHard().endsWith(".5") ) {
     				strBuf.append("5");
     			}
     			strBuf.append("/");
-    			strBuf.append(ch.terrain.charAt(0));
-    			if ( ch.terrain.endsWith(".5") ) {
+    			strBuf.append(ch.getTerrain().charAt(0));
+    			if ( ch.getTerrain().endsWith(".5") ) {
     				strBuf.append("5");
     			}
     		}
-    		strBuf.append(ch.CacheSize.substring(0, 1).toLowerCase());
+    		strBuf.append(ch.getCacheSize().substring(0, 1).toLowerCase());
     	}
 
     	return strBuf.toString();

Modified: trunk/src/exp/GPXExporter.java
===================================================================
--- trunk/src/exp/GPXExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/GPXExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -56,38 +56,38 @@
 		try{
 			strBuf.append("  <wpt lat=\""+lat+"\" lon=\""+lon+"\">\r\n");
 		
-			String tim = ch.DateHidden.length()>0 ? ch.DateHidden : DEFAULT_DATE;
+			String tim = ch.getDateHidden().length()>0 ? ch.getDateHidden() : DEFAULT_DATE;
 			strBuf.append("    <time>").append(tim.toString()).append("T00:00:00.0000000-07:00</time>\r\n");
-			strBuf.append("    <name>").append(ch.wayPoint).append("</name>\r\n");
+			strBuf.append("    <name>").append(ch.getWayPoint()).append("</name>\r\n");
 			if (ch.isAddiWpt()){
 				strBuf.append("    <cmt>").append(SafeXML.cleanGPX(ch.LongDescription)).append("</cmt>\r\n");
 			}
-			strBuf.append("    <desc>").append(SafeXML.cleanGPX(ch.CacheName)).append(" by ").append(SafeXML.cleanGPX(ch.CacheOwner)).append("</desc>\r\n");
-			strBuf.append("    <url>http://www.geocaching.com/seek/cache_details.aspx?wp=").append(ch.wayPoint).append("&amp;Submit6=Find</url>\r\n");
-			strBuf.append("    <urlname>").append(SafeXML.cleanGPX(ch.CacheName)).append(" by ").append(SafeXML.cleanGPX(ch.CacheOwner)).append("</urlname>\r\n");
+			strBuf.append("    <desc>").append(SafeXML.cleanGPX(ch.getCacheName())).append(" by ").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</desc>\r\n");
+			strBuf.append("    <url>http://www.geocaching.com/seek/cache_details.aspx?wp=").append(ch.getWayPoint()).append("&amp;Submit6=Find</url>\r\n");
+			strBuf.append("    <urlname>").append(SafeXML.cleanGPX(ch.getCacheName())).append(" by ").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</urlname>\r\n");
 			if (!ch.isAddiWpt()){
-				if ( ch.is_found ) {
+				if ( ch.is_found() ) {
 					strBuf.append("    <sym>Geocache Found</sym>\r\n");					
 				} else {
 					strBuf.append("    <sym>Geocache</sym>\r\n");
 				}
-				strBuf.append("    <type>Geocache|").append(CacheType.transType(ch.type)).append("</type>\r\n");
-				String dummyAvailable = ch.is_available ? STRING_TRUE:STRING_FALSE;
-				String dummyArchived = ch.is_archived ? STRING_TRUE:STRING_FALSE;
+				strBuf.append("    <type>Geocache|").append(CacheType.transType(ch.getType())).append("</type>\r\n");
+				String dummyAvailable = ch.is_available() ? STRING_TRUE:STRING_FALSE;
+				String dummyArchived = ch.is_archived() ? STRING_TRUE:STRING_FALSE;
 				strBuf.append("    <groundspeak:cache id=\"").append( ch.GetCacheID() ).append( "\" available=\"" ).append( dummyAvailable ).append( "\" archived=\"" ).append( dummyArchived).append( "\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">\r\n");
-				strBuf.append("      <groundspeak:name>").append(SafeXML.cleanGPX(ch.CacheName)).append("</groundspeak:name>\r\n");
-				strBuf.append("      <groundspeak:placed_by>").append(SafeXML.cleanGPX(ch.CacheOwner)).append("</groundspeak:placed_by>\r\n");
+				strBuf.append("      <groundspeak:name>").append(SafeXML.cleanGPX(ch.getCacheName())).append("</groundspeak:name>\r\n");
+				strBuf.append("      <groundspeak:placed_by>").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</groundspeak:placed_by>\r\n");
 				//todo low prio: correct owner-id
-				strBuf.append("      <groundspeak:owner id=\"23\">").append(SafeXML.cleanGPX(ch.CacheOwner)+"</groundspeak:owner>\r\n");
-				strBuf.append("      <groundspeak:type>").append(CacheType.transType(ch.type)).append("</groundspeak:type>\r\n");
-				strBuf.append("      <groundspeak:container>").append(ch.CacheSize).append("</groundspeak:container>\r\n");
+				strBuf.append("      <groundspeak:owner id=\"23\">").append(SafeXML.cleanGPX(ch.getCacheOwner())+"</groundspeak:owner>\r\n");
+				strBuf.append("      <groundspeak:type>").append(CacheType.transType(ch.getType())).append("</groundspeak:type>\r\n");
+				strBuf.append("      <groundspeak:container>").append(ch.getCacheSize()).append("</groundspeak:container>\r\n");
 				//for Colorado/Oregon: 2.0 -> 2
-				String diffTerr = ch.hard.replace(',','.');
+				String diffTerr = ch.getHard().replace(',','.');
 				if ( diffTerr.endsWith( ".0" ) ) {
 					diffTerr = diffTerr.substring(0, 1);
 				}
 				strBuf.append("      <groundspeak:difficulty>").append(diffTerr).append("</groundspeak:difficulty>\r\n");
-				diffTerr = ch.terrain.replace(',','.');
+				diffTerr = ch.getTerrain().replace(',','.');
 				if ( diffTerr.endsWith( ".0" ) ) {
 					diffTerr = diffTerr.substring(0, 1);
 				}
@@ -96,13 +96,13 @@
 				strBuf.append("      <groundspeak:country>").append(SafeXML.cleanGPX(ch.Country)+"</groundspeak:country>\r\n");
 				strBuf.append("      <groundspeak:state>").append(SafeXML.cleanGPX(ch.State)+"</groundspeak:state>\r\n");
 												
-				String dummyHTML = ch.is_HTML ? STRING_TRUE:STRING_FALSE;
+				String dummyHTML = ch.is_HTML() ? STRING_TRUE:STRING_FALSE;
 				strBuf.append("      <groundspeak:long_description html=\"" ).append( dummyHTML ).append( "\">\r\n");
 				strBuf.append("      ").append(SafeXML.cleanGPX(ch.LongDescription));
 				strBuf.append("      \n</groundspeak:long_description>\r\n");
 				strBuf.append("	  <groundspeak:encoded_hints>").append(SafeXML.cleanGPX(Common.rot13(ch.Hints))).append("</groundspeak:encoded_hints>\r\n");
 				strBuf.append("      <groundspeak:logs>\r\n");
-				if ( Global.getPref().exportGpxAsMyFinds && ch.is_found ) {
+				if ( Global.getPref().exportGpxAsMyFinds && ch.is_found() ) {
 					if ( ch.OwnLogId.length() != 0 ) {
 						strBuf.append("        <groundspeak:log id=\"" ).append( ch.OwnLogId ).append( "\">\r\n");						
 					} else {
@@ -149,8 +149,8 @@
 				strBuf.append("    </groundspeak:cache>\r\n");
 			}else {
 				// there is no HTML in the description of addi wpts
-				strBuf.append("    <sym>").append(CacheType.transType(ch.type)).append("</sym>\r\n");
-				strBuf.append("    <type>Waypoint|").append(CacheType.transType(ch.type)).append("</type>\r\n");
+				strBuf.append("    <sym>").append(CacheType.transType(ch.getType())).append("</sym>\r\n");
+				strBuf.append("    <type>Waypoint|").append(CacheType.transType(ch.getType())).append("</type>\r\n");
 			}
 			strBuf.append("  </wpt>\r\n");
 		}catch(Exception e){

Modified: trunk/src/exp/HTMLExporter.java
===================================================================
--- trunk/src/exp/HTMLExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/HTMLExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -70,7 +70,7 @@
 			int counter = 0;
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
-				if(ch.is_black == false && ch.is_filtered == false) counter++;
+				if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 			}
 			
 			pbf.showMainTask = false;
@@ -82,38 +82,38 @@
 				h.changed();
 
 				ch = (CacheHolder)cacheDB.get(i);
-				if(	ch.is_black == false && ch.is_filtered == false){
+				if(	ch.is_black() == false && ch.is_filtered() == false){
 					holder=ch.getCacheDetails(false,true);
 					varParams = new Hashtable();
-					varParams.put("TYPE", CacheType.transType(holder.type));
-					varParams.put("SIZE", holder.CacheSize);
-					varParams.put("WAYPOINT", holder.wayPoint);
-					varParams.put("NAME", holder.CacheName);
-					varParams.put("OWNER", holder.CacheOwner);
-					varParams.put("DIFFICULTY", holder.hard);
-					varParams.put("TERRAIN", holder.terrain);
+					varParams.put("TYPE", CacheType.transType(holder.getType()));
+					varParams.put("SIZE", holder.getCacheSize());
+					varParams.put("WAYPOINT", holder.getWayPoint());
+					varParams.put("NAME", holder.getCacheName());
+					varParams.put("OWNER", holder.getCacheOwner());
+					varParams.put("DIFFICULTY", holder.getHard());
+					varParams.put("TERRAIN", holder.getTerrain());
 					varParams.put("DISTANCE", holder.getDistance());
 					varParams.put("BEARING", holder.bearing);
 					varParams.put("LATLON", holder.LatLon);
-					varParams.put("STATUS", holder.CacheStatus);
-					varParams.put("DATE", holder.DateHidden);
+					varParams.put("STATUS", holder.getCacheStatus());
+					varParams.put("DATE", holder.getDateHidden());
 					cache_index.add(varParams);
 					//We can generate the individual page here!
 					try{
 						Template page_tpl = new Template(template_init_page);
-						page_tpl.setParam("TYPE", CacheType.transType(holder.type));
-						page_tpl.setParam("SIZE", holder.CacheSize);
-						page_tpl.setParam("WAYPOINT", holder.wayPoint);
-						page_tpl.setParam("NAME", holder.CacheName);
-						page_tpl.setParam("OWNER", holder.CacheOwner);
-						page_tpl.setParam("DIFFICULTY", holder.hard);
-						page_tpl.setParam("TERRAIN", holder.terrain);
+						page_tpl.setParam("TYPE", CacheType.transType(holder.getType()));
+						page_tpl.setParam("SIZE", holder.getCacheSize());
+						page_tpl.setParam("WAYPOINT", holder.getWayPoint());
+						page_tpl.setParam("NAME", holder.getCacheName());
+						page_tpl.setParam("OWNER", holder.getCacheOwner());
+						page_tpl.setParam("DIFFICULTY", holder.getHard());
+						page_tpl.setParam("TERRAIN", holder.getTerrain());
 						page_tpl.setParam("DISTANCE", holder.getDistance());
 						page_tpl.setParam("BEARING", holder.bearing);
 						page_tpl.setParam("LATLON", holder.LatLon);
-						page_tpl.setParam("STATUS", holder.CacheStatus);
-						page_tpl.setParam("DATE", holder.DateHidden);
-						if (holder.is_HTML)
+						page_tpl.setParam("STATUS", holder.getCacheStatus());
+						page_tpl.setParam("DATE", holder.getDateHidden());
+						if (holder.is_HTML())
 							page_tpl.setParam("DESCRIPTION", modifyLongDesc(holder,targetDir));
 						else {
 							String dummyText = new String();
@@ -178,7 +178,7 @@
 						// Map images
 						mapImg.clear();
 						mapImgParams = new Hashtable();
-						String mapImgFile = new String(holder.wayPoint + "_map.gif");
+						String mapImgFile = new String(holder.getWayPoint() + "_map.gif");
 						// check if map file exists
 						File test = new File(profile.dataDir + mapImgFile);
 						if (test.exists()) {
@@ -188,7 +188,7 @@
 							mapImg.add(mapImgParams);
 							
 							mapImgParams = new Hashtable();
-							mapImgFile = holder.wayPoint + "_map_2.gif";
+							mapImgFile = holder.getWayPoint() + "_map_2.gif";
 							mapImgParams.put("FILE", mapImgFile);
 							mapImgParams.put("TEXT",mapImgFile);
 							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
@@ -198,7 +198,7 @@
 						}
 
 						
-						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.wayPoint+".html")));
+						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.getWayPoint()+".html")));
 						pagefile.print(page_tpl.output());
 						pagefile.close();
 					}catch(Exception e){

Modified: trunk/src/exp/KMLExporter.java
===================================================================
--- trunk/src/exp/KMLExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/KMLExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -77,7 +77,7 @@
 		int expCount = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.is_black == false && ch.is_filtered == false) counter++;
+			if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 		}
 		copyIcons(outFile.getParent());
 		buildOutDB();
@@ -126,7 +126,7 @@
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
 								holder=new CacheHolderDetail(addiWpt);
 								expCount++;
-								if (holder.pos.isValid() &&  ! holder.is_filtered){
+								if (holder.pos.isValid() &&  ! holder.is_filtered()){
 									if (! createdAdditionalWaypointsFolder) {
 										outp.print(startFolder("Additional Waypoints", false));
 										createdAdditionalWaypointsFolder = true;
@@ -178,12 +178,12 @@
 		for(int i = 0; i<cacheDB.size(); i++){
 			ch=(CacheHolder)cacheDB.get(i);
 			// TODO Das Argument nach STring zu casten gef?llt mir nicht ganz...
-			if(ch.is_black == false && ch.is_filtered == false && !ch.isAddiWpt()){
-				if (ch.is_found) { tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.type));}
-				else if (ch.is_owned) { tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.type));}
-				else if (ch.is_archived || !ch.is_available){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.type));}
-				else if (ch.is_available){ tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.type));}
-				else { tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.type));}
+			if(ch.is_black() == false && ch.is_filtered() == false && !ch.isAddiWpt()){
+				if (ch.is_found()) { tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));}
+				else if (ch.is_owned()) { tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));}
+				else if (ch.is_archived() || !ch.is_available()){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.getType()));}
+				else if (ch.is_available()){ tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.getType()));}
+				else { tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.getType()));}
 				
 				tmp.add(ch);
 			}
@@ -279,7 +279,7 @@
 		if (ch.URL != null){
 			strBuf.append("      <description>"+SafeXML.clean(ch.URL)+"</description>\r\n");
 		}
-		strBuf.append("      <name>"+ ch.wayPoint + " - " + SafeXML.clean(ch.CacheName) +"</name>\r\n");
+		strBuf.append("      <name>"+ ch.getWayPoint() + " - " + SafeXML.clean(ch.getCacheName()) +"</name>\r\n");
 		strBuf.append("      <LookAt>\r\n");
 		strBuf.append("         <latitude>" + lat + "</latitude>\r\n");
 		strBuf.append("         <longitude>" + lon + "</longitude>\r\n");
@@ -292,7 +292,7 @@
 		strBuf.append("      <IconStyle>\r\n");
 		strBuf.append("         <Icon>\r\n");
 //		strBuf.append("            <href>"+ File.getProgramDirectory()+ "/" + CacheType.type2pic(Convert.parseInt(ch.type))+ "</href>\r\n");
-		strBuf.append("            <href>"+ CacheType.type2pic(ch.type)+ "</href>\r\n");
+		strBuf.append("            <href>"+ CacheType.type2pic(ch.getType())+ "</href>\r\n");
 		strBuf.append("         </Icon>\r\n");
 		strBuf.append("      </IconStyle>\r\n");
 		strBuf.append("      <LabelStyle>\r\n");
@@ -314,9 +314,9 @@
 	}
 	
 	private String getColor(CacheHolderDetail ch){
-		if (ch.is_found) return COLOR_FOUND;
-		if (ch.is_owned) return COLOR_OWNED;
-		if (ch.is_archived || !ch.is_available) return COLOR_NOT_AVAILABLE;
+		if (ch.is_found()) return COLOR_FOUND;
+		if (ch.is_owned()) return COLOR_OWNED;
+		if (ch.is_archived() || !ch.is_available()) return COLOR_NOT_AVAILABLE;
 		
 		return COLOR_AVAILABLE;
 	}

Modified: trunk/src/exp/LocExporter.java
===================================================================
--- trunk/src/exp/LocExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/LocExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -40,7 +40,7 @@
 		if (!chD.pos.isValid()) return null;
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append("<waypoint>\r\n   <name id=\"");
-		String wptName=simplifyString(chD.wayPoint);
+		String wptName=simplifyString(chD.getWayPoint());
 		if (Global.getPref().addDetailsToWaypoint) {
 			wptName += getShortDetails( chD );			
 		}
@@ -52,7 +52,7 @@
 			} catch (Exception ex){ pref.log("Invalid value for garmin.MaxWaypointLength"); }
 		}
 		strBuf.append("\"><![CDATA[");
-		strBuf.append(simplifyString(chD.CacheName));
+		strBuf.append(simplifyString(chD.getCacheName()));
 		if (Global.getPref().addDetailsToName) {
 			if ( !Global.getPref().addDetailsToWaypoint ) {
 				strBuf.append( getShortDetails( chD ) );
@@ -70,7 +70,7 @@
 		if (gm!=null) {
 			strBuf.append(gm.getIcon(chD));
 		} else {
-			if (chD.is_found)
+			if (chD.is_found())
 				strBuf.append("Geocache Found");
 			else
 				strBuf.append("Geocache");
@@ -117,17 +117,17 @@
 		
 		public String getIcon(CacheHolderDetail chD) {
 			// First check if there is a mapping for "cache found"
-			if (chD.is_found) {
+			if (chD.is_found()) {
 				for (int i=0; i<mapSize; i++)
 					// TODO Geht das noch sch?ner...? ................ <------------------------------>
-					if (symbols[i].onlyIfFound!=null && symbols[i].type.equals(String.valueOf(chD.type))) return symbols[i].name;
+					if (symbols[i].onlyIfFound!=null && symbols[i].type.equals(String.valueOf(chD.getType()))) return symbols[i].name;
 			}
 			// Now try mapping the cache irrespective of the "found" status
 			for (int i=0; i<mapSize; i++)
-				if (symbols[i].type.equals(String.valueOf(chD.type))) return symbols[i].name;
+				if (symbols[i].type.equals(String.valueOf(chD.getType()))) return symbols[i].name;
 		
 			// If it is not a mapped type, just use the standard mapping
-			if (chD.is_found)
+			if (chD.is_found())
 				return "Geocache Found";
 			else
 				return "Geocache";

Modified: trunk/src/exp/MSARCSVExporter.java
===================================================================
--- trunk/src/exp/MSARCSVExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/MSARCSVExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -24,12 +24,12 @@
 
 	public String record(CacheHolderDetail ch, String lat, String lon) {
 		StringBuffer str = new StringBuffer(200);
-		str.append("\"" + ch.wayPoint + " - " + ch.CacheName + "\";");
+		str.append("\"" + ch.getWayPoint() + " - " + ch.getCacheName() + "\";");
 		str.append(lat + ";" + lon +";");
-		str.append("\"" + CacheType.transType(ch.type)+ "\";");
-		str.append("\"" + ch.CacheSize + "\";");
-		str.append("\"" + ch.wayPoint + "\";");
-		str.append("\"" + ch.DateHidden + "\";");
+		str.append("\"" + CacheType.transType(ch.getType())+ "\";");
+		str.append("\"" + ch.getCacheSize() + "\";");
+		str.append("\"" + ch.getWayPoint() + "\";");
+		str.append("\"" + ch.getDateHidden() + "\";");
 		str.append("\"" + ch.URL + "\"\r\n");
 
 		return str.toString();

Modified: trunk/src/exp/OVLExporter.java
===================================================================
--- trunk/src/exp/OVLExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/OVLExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -42,7 +42,7 @@
 		tmp = Common.parseDouble(lat);
 		tmp += 0.002;
 		str.append("YKoord="+Convert.toString(tmp).replace(',', '.')+"\r\n");
-		str.append("Text="+ch.wayPoint+"\r\n");
+		str.append("Text="+ch.getWayPoint()+"\r\n");
 
 		return str.toString();
 	}

Modified: trunk/src/exp/OziExporter.java
===================================================================
--- trunk/src/exp/OziExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/OziExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -31,7 +31,7 @@
 		// usually start at 1 and increment. Can be set to -1 (minus 1) and the number will be auto generated.
 		strBuf.append("-1,");
 		// Field 2 : Name - the waypoint name, use the correct length name to suit the GPS type.
-		strBuf.append(ch.wayPoint + ",");
+		strBuf.append(ch.getWayPoint() + ",");
 		// Field 3 : Latitude - decimal degrees.
 		strBuf.append(lat+",");
 		// Field 4 : Longitude - decimal degrees.
@@ -49,7 +49,7 @@
 		// Field 10 : Background Color (RGB value)
 		strBuf.append("16777215,");
 		// Field 11 : Description (max 40), no commas
-		tmpName = simplifyString(ch.CacheName);
+		tmpName = simplifyString(ch.getCacheName());
 		if (tmpName.length() <= 40){
 			strBuf.append(tmpName + ",");
 		}

Modified: trunk/src/exp/PCX5Exporter.java
===================================================================
--- trunk/src/exp/PCX5Exporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/PCX5Exporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -38,7 +38,7 @@
 		StringBuffer strBuf = new StringBuffer(200);
 		String latlonstr, dummy;
 
-		  strBuf.append("W  " + ch.wayPoint + " ");
+		  strBuf.append("W  " + ch.getWayPoint() + " ");
 		  latlonstr = STRreplace.replace(ch.LatLon, "?", " ");
 		  latlonstr = STRreplace.replace(latlonstr, " ", "");
 		  latlonstr = STRreplace.replace(latlonstr, "E", " E");
@@ -46,7 +46,7 @@
 		  strBuf.append(latlonstr + "     ");
 		  strBuf.append("01-JAN-04 01:00:00 -0000 ");
 		  // has 42 characters
-		  dummy = ch.CacheName;
+		  dummy = ch.getCacheName();
 		  if (dummy.length() < 40){
 			  strBuf.append(dummy);
 			  int i = 40 - dummy.length();
@@ -57,7 +57,7 @@
 			  strBuf.append(dummy.substring(0,40));
 		  }
 		  strBuf.append(" 0.000000e+000 ");
-		  if(ch.is_found) strBuf.append("  8256\r\n");
+		  if(ch.is_found()) strBuf.append("  8256\r\n");
 		  else  		  strBuf.append("  8255\r\n");
 		return strBuf.toString();
 	}

Modified: trunk/src/exp/TPLExporter.java
===================================================================
--- trunk/src/exp/TPLExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/TPLExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -158,7 +158,7 @@
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.is_black == false && ch.is_filtered == false) counter++;
+			if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 		}
 		pbf.showMainTask = false;
 		pbf.setTask(h,"Exporting ...");
@@ -185,54 +185,54 @@
 				ch = (CacheHolder)cacheDB.get(i);
 				h.progress = (float)i/(float)counter;
 				h.changed();
-				if(ch.is_black == false && ch.is_filtered == false){
+				if(ch.is_black() == false && ch.is_filtered() == false){
 					if (ch.pos.isValid() == false) continue;
 					holder=new CacheHolderDetail(ch);
 					try{
 						holder.readCache(profile.dataDir);
 					}catch(Exception e){
 						Vm.debug("Problem reading cache page");
-						Global.getPref().log("Exception in TplExporter = Problem reading cache page, Cache: " + holder.wayPoint, e, true);
+						Global.getPref().log("Exception in TplExporter = Problem reading cache page, Cache: " + holder.getWayPoint(), e, true);
 					}
 					try {
 						Regex dec = new Regex("[,.]",myFilter.decSep);
 						if (myFilter.badChars != null) rex = new Regex("["+myFilter.badChars+"]","");
 						varParams = new Hashtable();
-						varParams.put("TYPE", CacheType.transType(holder.type));
-						varParams.put("SHORTTYPE", CacheType.transType(holder.type).substring(0,1));
-						varParams.put("SIZE", holder.CacheSize);
-						varParams.put("SHORTSIZE", holder.CacheSize.substring(0,1));
-						varParams.put("WAYPOINT", holder.wayPoint);
-						varParams.put("OWNER", holder.CacheOwner);
-						varParams.put("DIFFICULTY", dec.replaceAll(holder.hard));
-						varParams.put("TERRAIN", dec.replaceAll(holder.terrain));
+						varParams.put("TYPE", CacheType.transType(holder.getType()));
+						varParams.put("SHORTTYPE", CacheType.transType(holder.getType()).substring(0,1));
+						varParams.put("SIZE", holder.getCacheSize());
+						varParams.put("SHORTSIZE", holder.getCacheSize().substring(0,1));
+						varParams.put("WAYPOINT", holder.getWayPoint());
+						varParams.put("OWNER", holder.getCacheOwner());
+						varParams.put("DIFFICULTY", dec.replaceAll(holder.getHard()));
+						varParams.put("TERRAIN", dec.replaceAll(holder.getTerrain()));
 						varParams.put("DISTANCE", dec.replaceAll(holder.getDistance()));
 						varParams.put("BEARING", holder.bearing);
 						varParams.put("LATLON", holder.LatLon);
 						varParams.put("LAT", dec.replaceAll(holder.pos.getLatDeg(CWPoint.DD)));
 						varParams.put("LON", dec.replaceAll(holder.pos.getLonDeg(CWPoint.DD)));
-						varParams.put("STATUS", holder.CacheStatus);
+						varParams.put("STATUS", holder.getCacheStatus());
 						varParams.put("STATUS_DATE", holder.GetStatusDate());
 						varParams.put("STATUS_TIME", holder.GetStatusTime());
-						varParams.put("DATE", holder.DateHidden);
+						varParams.put("DATE", holder.getDateHidden());
 						varParams.put("URL", holder.URL);
 						varParams.put("DESCRIPTION", holder.LongDescription);
 						if (myFilter.badChars != null) {
-							varParams.put("NAME", rex.replaceAll(holder.CacheName));
+							varParams.put("NAME", rex.replaceAll(holder.getCacheName()));
 							varParams.put("NOTES", rex.replaceAll(holder.CacheNotes));
 							varParams.put("HINTS", rex.replaceAll(holder.Hints));
 							varParams.put("DECRYPTEDHINTS", rex.replaceAll(Common.rot13(holder.Hints)));
 						} else {
-							varParams.put("NAME", holder.CacheName);
+							varParams.put("NAME", holder.getCacheName());
 							varParams.put("NOTES", holder.CacheNotes);
 							varParams.put("HINTS", holder.Hints);
 							varParams.put("DECRYPTEDHINTS", Common.rot13(holder.Hints));
 						}
 						cache_index.add(varParams);
 					}catch(Exception e){
-						Vm.debug("Problem getting Parameter, Cache: " + holder.wayPoint);
+						Vm.debug("Problem getting Parameter, Cache: " + holder.getWayPoint());
 						e.printStackTrace();
-						Global.getPref().log("Exception in TplExporter = Problem getting Parameter, Cache: " + holder.wayPoint, e, true);
+						Global.getPref().log("Exception in TplExporter = Problem getting Parameter, Cache: " + holder.getWayPoint(), e, true);
 					}
 				}
 			}

Modified: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2009-04-04 08:29:49 UTC (rev 1737)
+++ trunk/src/exp/TomTomExporter.java	2009-04-05 14:59:37 UTC (rev 1738)
@@ -80,7 +80,7 @@
 		counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false && holder.is_filtered == false) counter++;
+			if(holder.is_black() == false && holder.is_filtered() == false) counter++;
 		}
 		
 		ext = format==TT_ASC?".asc":".ov2";
@@ -93,7 +93,7 @@
 				out =  new RandomAccessFile(fileName,"rw");
 				for(int i = 0; i<cacheDB.size(); i++){
 					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.type == new Integer(CacheType.wayType[j][TT_WPT_NUM]).intValue() && holder.is_black == false && holder.is_filtered == false){
+					if(holder.getType() == new Integer(CacheType.wayType[j][TT_WPT_NUM]).intValue() && holder.is_black() == false && holder.is_filtered() == false){
 						currExp++;
 						h.progress = (float)currExp/(float)counter;
 						h.changed();
@@ -138,7 +138,7 @@
 		int expCount = 0;
 		for(int i = 0; i<cacheDB.size();i++){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false && holder.is_filtered == false) counter++;
+			if(holder.is_black() == false && holder.is_filtered() == false) counter++;
 		}
 
 		try{
@@ -147,7 +147,7 @@
 			out =  new RandomAccessFile(fileName,"rw");
 			for(int i = 0; i<cacheDB.size(); i++){
 				holder=(CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false && holder.is_filtered == false){
+				if(holder.is_black() == false && holder.is_filtered() == false){
 					expCount++;
 					h.progress = (float)expCount/(float)counter;
 					h.changed();
@@ -177,17 +177,17 @@
 			outp.writeBytes(",");
 			//outp.writeBytes("\"" + ch.CacheName.replace(',',' ') + "\"\r\n");
 			outp.writeBytes("\"");
-			outp.writeBytes(ch.wayPoint);
+			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(" - ");
-			outp.writeBytes(ch.CacheName.replace(',',' '));
+			outp.writeBytes(ch.getCacheName().replace(',',' '));
 			outp.writeBytes(" by ");
-			outp.writeBytes(ch.CacheOwner);
+			outp.writeBytes(ch.getCacheOwner());
 			outp.writeBytes("- ");             
-			outp.writeBytes(ch.hard);
+			outp.writeBytes(ch.getHard());
 			outp.writeBytes("/");
-			outp.writeBytes(ch.terrain);
+			outp.writeBytes(ch.getTerrain());
 			outp.writeBytes(" - ");
-			outp.writeBytes(ch.CacheSize);
+			outp.writeBytes(ch.getCacheSize());
 			outp.writeBytes("\"\r\n");
 		} catch (IOException e) {
 			Vm.debug("Error writing to file");
@@ -204,7 +204,7 @@
 		try {
 			d = 2;
 			outp.writeByte((byte)d);
-			data = ch.wayPoint.length()+ch.CacheName.length()+ch.CacheOwner.length()+ch.hard.length()+ch.terrain.length()+ch.CacheSize.length()+27;
+			data = ch.getWayPoint().length()+ch.getCacheName().length()+ch.getCacheOwner().length()+ch.getHard().length()+ch.getTerrain().length()+ch.getCacheSize().length()+27;
 			writeIntBinary(outp, data);
 			latlon = Common.parseDouble(lon);
 			latlon *=100000;
@@ -212,21 +212,21 @@
 			latlon = Common.parseDouble(lat);;
 			latlon *=100000;
 			writeIntBinary(outp, (int) latlon);
-			outp.writeBytes(ch.wayPoint);
+			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(" - ");
-			outp.writeBytes(ch.CacheName);
+			outp.writeBytes(ch.getCacheName());
 			outp.writeBytes(" by ");
-			outp.writeBytes(ch.CacheOwner);
+			outp.writeBytes(ch.getCacheOwner());
 			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
 			//Hier wieder einf?gen
 			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
 			//wider um 1 erh?hen
 			outp.writeBytes("- ");             
-			outp.writeBytes(ch.hard);
+			outp.writeBytes(ch.getHard());
 			outp.writeBytes("/");
-			outp.writeBytes(ch.terrain);
+			outp.writeBytes(ch.getTerrain());
 			outp.writeBytes(" - ");
-			outp.writeBytes(ch.CacheSize);
+			outp.writeBytes(ch.getCacheSize());
 			d = 0;
 			outp.writeByte((byte)d);
 		} catch (IOException e) {



From salzkammergut at mail.berlios.de  Mon Apr  6 00:21:12 2009
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 6 Apr 2009 00:21:12 +0200
Subject: [Cachewolf-svn] r1739 - trunk/res_noewe
Message-ID: <200904052221.n35MLCo0010389@sheep.berlios.de>

Author: salzkammergut
Date: 2009-04-06 00:21:10 +0200 (Mon, 06 Apr 2009)
New Revision: 1739

Modified:
   trunk/res_noewe/spider.def
Log:
spider.def: Fix for country/state for US caches

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2009-04-05 14:59:37 UTC (rev 1738)
+++ trunk/res_noewe/spider.def	2009-04-05 22:21:10 UTC (rev 1739)
@@ -27,6 +27,7 @@
 # Version 4.3 - 20090314 maxDistance string added
 # Version 4.4 - 20090314 firstPageFinds string added
 # Version 4.5 - 20090315 strings for spidering country/state/logId
+# Version 4.6 - 20090406 Fix for country/state (did not work with US caches)
 #============================================================
 # A suffix of Rex indicates a regular expression
 # A suffix of ExStart indicates the start of an Extractor search pattern
@@ -46,7 +47,7 @@
 firstPage          = http://www.geocaching.com/seek/nearest.aspx?lat=
 firstPage2         = &lon=
 firstPageFinds     = http://www.geocaching.com/seek/nearest.aspx?ul=
-# Regex to search for cachenames 
+# Regex to search for cachenames
 listBlockRex       = <table id="ctl00_ContentBody_dlResults"((?s).*?)</table>
 lineRex            = <tr\ bgcolor='#.{6}'>(?:(?s).*?)<td\ valign="top"\ align="left">((?s).*?)</tr>
 distRex            = <br\ />(.*?)(?:km|mi)(?:\\s*)</td>
@@ -74,7 +75,7 @@
 difficultyRex      = <span\ id="Difficulty">.*?alt="(.*?)\ out\ of
 terrainRex         = <span\ id="Terrain">.*?alt="(.*?)\ out\ of
 cacheTypeRex       = \\./images/WptTypes/(.*?)\\.gif
-cacheLocationRex   = <span\ id="Location">In\ ((?s).*?)</span>
+cacheLocationRex   = <span\ id="Location">In\ ([^<]*?)<
 
 #--------------------------------------
 #Section2a: Logs



From engywuck at mail.berlios.de  Tue Apr  7 19:52:08 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Tue, 7 Apr 2009 19:52:08 +0200
Subject: [Cachewolf-svn] r1740 - in trunk/src: CacheWolf CacheWolf/navi exp
	utils
Message-ID: <200904071752.n37Hq8on012653@sheep.berlios.de>

Author: engywuck
Date: 2009-04-07 19:51:40 +0200 (Tue, 07 Apr 2009)
New Revision: 1740

Added:
   trunk/src/CacheWolf/CacheDB.java
   trunk/src/utils/MutableInteger.java
Modified:
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DBStats.java
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/StatusBar.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/myInteractivePanel.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/exp/ExploristExporter.java
   trunk/src/exp/Exporter.java
   trunk/src/exp/HTMLExporter.java
   trunk/src/exp/KMLExporter.java
   trunk/src/exp/TPLExporter.java
   trunk/src/exp/TomTomExporter.java
Log:
Introducing new class (CacheDB) to hold the list of caches. Main benefit in current implementation: Search by waypoint doesn't need to iterate over database to search for it, because internally a hashtable is invoked.
Code changes in other classes are numerous but insignificant.

Added: trunk/src/CacheWolf/CacheDB.java
===================================================================
--- trunk/src/CacheWolf/CacheDB.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/CacheDB.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -0,0 +1,179 @@
+package CacheWolf;
+
+import utils.MutableInteger;
+import ewe.util.Comparer;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+/**
+ * @author torsti
+ *
+ */
+/**
+ * @author torsti
+ *
+ */
+public class CacheDB {
+	
+	/**
+	 * Stores the CacheHolder objects
+	 */
+	private Vector vectorDB = new Vector();
+	/**
+	 * Stores the reference of waypoints to index positions (in vectorDB).
+	 */
+	private Hashtable hashDB = new Hashtable();
+	
+	/** Gets the existing MutableInteger object from a given waypoint, or,
+	 * if not existant, creates a new one, and fills it with the given integer. 
+	 * @param waypoint The waypoint whos MutableIntger object is to use
+	 * @param newValue The integer value you want to assign to the object
+	 * @return The newly created or reused and freshly assigned object
+	 */
+	private MutableInteger getIntObj(String waypoint, int newValue) {
+		MutableInteger obj = (MutableInteger) hashDB.get(waypoint);
+		if (obj == null) {
+			obj = new MutableInteger();			
+		}
+		obj.setInt(newValue);
+		return obj;
+	}
+	
+	/** Gets the stored CacheHolder object by its position in the Cache List.
+	 * @param index Index of cache 
+	 * @return CacheHolder object with corresponding index
+	 */
+	public CacheHolder get(int index) {
+		return (CacheHolder) vectorDB.get(index);
+	}
+
+	/** Gets the stored CacheHolder object by its waypoint. If no such Cache exists,
+	 * null is returned.
+	 * @param waypoint Waypoint of cache we want
+	 * @return CacheHolder object with corresponding waypoint
+	 */
+	public CacheHolder get(String waypoint){
+		int idx = this.getIndex(waypoint);
+		if (idx < 0) return null;
+		return this.get(idx);
+	}
+	
+	/** Gets the index of the cache with a given waypoint. 
+	 * @param waypoint Waypoint of cache we want
+	 * @return Index of CacheHolder object in cache list.
+	 */
+	public int getIndex(String waypoint) {
+		Object obj = hashDB.get(waypoint);
+		int result;
+		if (obj == null) {
+			result = -1;
+		} else {
+			result = ((MutableInteger)obj).getInt();
+		}
+		return result;
+	}
+
+	/** Gets the index of a certain CacheHolder object. 
+	 * @param ch CacheHolder object
+	 * @return Index of CacheHolder object in cache list.
+	 */
+	public int getIndex(CacheHolder ch) {
+		return getIndex(ch.getWayPoint());
+	}
+
+	/** Sets a CacheHolder object at a certain position in the cache list. If this position 
+	 * is already occupied by a cache object, this one discarded.
+	 * @param index Index where to set object
+	 * @param ch CacheHolder object to set
+	 */
+	public void set(int index, CacheHolder ch) {
+		CacheHolder oldObj = (CacheHolder) vectorDB.get(index);
+	    vectorDB.set(index, ch);
+	    hashDB.put(ch.getWayPoint(), this.getIntObj(ch.getWayPoint(), index));
+	    if (oldObj!=null) {
+	    	hashDB.remove(oldObj.getWayPoint());
+	    }
+    }
+
+	/** Append a CacheHolder object at the end of the cache list. If a cache with same waypoint
+	 * is already existant in the cache list, then the old object is overwritten and the new object
+	 * is positioned at the position of the old object (so in this case <code>add</code> acts like
+	 * <code>set</code>.
+	 * @param ch CacheHolder object to append
+	 */
+	public void add(CacheHolder ch) {
+		if (this.getIndex(ch)>0) {
+			this.set(this.getIndex(ch), ch);
+		} else {
+			vectorDB.add(ch);
+			hashDB.put(ch.getWayPoint(), this.getIntObj(ch.getWayPoint(), vectorDB.size()-1));
+		}
+    }
+
+	/** The number of caches in the cache list.
+	 * @return number
+	 */
+	public int size() {
+	    return vectorDB.size();
+    }
+
+	/**
+	 * Removes all cache objects from the list.
+	 */
+	public void clear() {
+	    hashDB.clear();
+	    vectorDB.clear();
+    }
+
+	/** Removes a CacheHolder object at the specified position in the cache list. The following
+	 * elements are renumbered.
+	 * @param index The index of element to remove
+	 */
+	public void removeElementAt(int index) {
+		CacheHolder ch = this.get(index);
+	    vectorDB.removeElementAt(index);
+	    hashDB.remove(ch.getWayPoint());
+	    // When one element has been removed, we have to update the index
+	    // references in the hashtable, as the indexes of waypoints changed.
+	    for (int i=index; i<vectorDB.size(); i++) {
+	    	CacheHolder ch2 = this.get(i);
+	    	hashDB.put(ch2.getWayPoint(), this.getIntObj(ch2.getWayPoint(), i));
+	    }
+    }
+
+	/**Sorts the caches in the list
+	 * @param comparer Comparer object
+	 * @param descending descending or not
+	 */
+	public void sort(Comparer comparer, boolean descending) {
+	    vectorDB.sort(comparer, descending);
+	    // When elements have been sorted we have to update the index
+	    // references in the hashtable, as the indexes of waypoints changed.
+	    for (int i=0; i<vectorDB.size(); i++) {
+	    	CacheHolder ch = this.get(i);
+	    	hashDB.put(ch.getWayPoint(), this.getIntObj(ch.getWayPoint(), i));
+	    }
+    }
+
+	/** Adds the caches of one CacheDB to current one. Caches are appended at the end.
+	 * @param caches CacheDB to append
+	 */
+	public void addAll(CacheDB caches) {
+		addAll(caches.vectorDB);
+	}
+
+	/** Adds a Vector of CacheHolder objects to current database. Caches are appended at the end.
+	 * @param caches Vector of caches to append
+	 */
+	public void addAll(Vector caches) {
+		int oldSize = vectorDB.size();
+		vectorDB.addAll(caches);
+		for (int i=0; i<caches.size(); i++) {
+			int pos;
+			CacheHolder currCache = (CacheHolder) vectorDB.get(i+oldSize);
+			pos = i+oldSize;
+			hashDB.put(currCache.getWayPoint(), this.getIntObj(currCache.getWayPoint(), pos));
+		}
+	}
+	
+}

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/CacheList.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -179,7 +179,7 @@
 			if (lstCaches.itemsSize()>0 && !needsInit) {
 				int lstCacheIdx=lstCaches.getSelectedIndex(0);
 				CacheHolder ch=(CacheHolder)cacheList.get(lstCacheIdx);
-				int idx=Global.getProfile().cacheDB.find(ch);
+				int idx=Global.getProfile().cacheDB.getIndex(ch);
 				// Ensure that the main view is updated with the selected cache, i.e.
 				// DetailsPanel, HintLog, Pictures etc.
 				int activeTab=Global.mainTab.cardPanel.selectedItem;
@@ -259,13 +259,13 @@
 	/** Apply the cache list */
 	public void applyCacheList() {
 		Global.getProfile().selectionChanged = true;
-		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
 		int wrongBlackStatus=0;
 		String apply="\uFFFF"+Convert.toString(applyCount++);
 		// Start by setting all caches to filtered
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			ch.setFiltered(true) ; // ignore blacklist attribute
 			ch.sort=apply;
 		}
@@ -282,7 +282,7 @@
 				int idx=Global.getProfile().getCacheIndex(ch.getWayPoint());
 				if (idx==-1) continue;
 				ch=null;
-				ch=(CacheHolder) cacheDB.get(idx);
+				ch=cacheDB.get(idx);
 			}
 			if (ch.is_black()!=Global.getProfile().showBlacklisted()) 
 				wrongBlackStatus++;
@@ -308,7 +308,7 @@
 		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; lstCaches.repaint(); }
 		int idx=Global.getProfile().getCacheIndex(wayPoint);
 		if (idx==-1) return false;
-		CacheHolder ch=(CacheHolder) Global.getProfile().cacheDB.get(idx);
+		CacheHolder ch=Global.getProfile().cacheDB.get(idx);
 		boolean cachesAdded=false;
 		// Add main cache
 		cachesAdded|=addCache(ch);
@@ -391,7 +391,7 @@
 			FileReader in = new FileReader(fileName);
 			String wayPoint;
 			int idx;
-			Vector cacheDB=Global.getProfile().cacheDB;
+			CacheDB cacheDB=Global.getProfile().cacheDB;
 			int lineNr=0;
 			while ((wayPoint = in.readLine()) != null){
 				wayPoint=wayPoint.trim();
@@ -403,7 +403,7 @@
 				// Only add the cache if it is in this profile
 				idx=Global.getProfile().getCacheIndex(wayPoint);
 				if (idx>=0) {
-					addCache((CacheHolder) cacheDB.get(idx));
+					addCache(cacheDB.get(idx));
 				}
 				lineNr++;
 			}

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/CalcPanel.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -43,7 +43,7 @@
 	CWPoint coordInp = new CWPoint();
 	CWPoint coordOut = new CWPoint();
 	// Needed for creation of new waypoint
-	Vector cacheDB;
+	CacheDB cacheDB;
 	MainTab mainT;
 	Preferences pref;
 	Profile profile;

Modified: trunk/src/CacheWolf/DBStats.java
===================================================================
--- trunk/src/CacheWolf/DBStats.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/DBStats.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -6,9 +6,9 @@
  * Use this class to obtain statistics or information on a cache database.
  */
 public class DBStats {
-	Vector cacheDB = new Vector();
+	CacheDB cacheDB = null;
 	
-	public DBStats(Vector db){
+	public DBStats(CacheDB db){
 		cacheDB = db;
 	}
 	
@@ -23,7 +23,7 @@
 		CacheHolder holder;
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
+			holder = cacheDB.get(i);
 			if(holder.is_black() == false && holder.is_filtered() == false){
 				if(holder.getWayPoint().startsWith("GC") || holder.getWayPoint().startsWith("OC")) counter++;
 			}
@@ -39,7 +39,7 @@
 		CacheHolder holder;
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
+			holder = cacheDB.get(i);
 			if(holder.is_black() == false){
 				if(holder.getWayPoint().startsWith("GC") || holder.getWayPoint().startsWith("OC")) counter++;
 			}
@@ -51,7 +51,7 @@
 		CacheHolder holder;
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
+			holder = cacheDB.get(i);
 			if(holder.is_found() == true) {
 				if(holder.getWayPoint().startsWith("GC") || holder.getWayPoint().startsWith("OC")) counter++;
 			}
@@ -69,4 +69,4 @@
 //TODO OziExporter.java
 //TODO PCX5Exporter.java
 //TODO TomTomASCExporter.ja
-//TODO TomTomOV2Exporter.ja
\ No newline at end of file
+//TODO TomTomOV2Exporter.ja

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/DataMover.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -15,7 +15,7 @@
 */
 public class DataMover {
 
-	Vector srcDB, dstDB;
+	CacheDB srcDB, dstDB;
 	Preferences pref;
 	Profile profile;
 	
@@ -91,7 +91,7 @@
 		int count=0;
 		// Count the number of caches to move/delete/copy
 		for(int i = 0; i<size; i++) {
-			if(((CacheHolder)srcDB.get(i)).is_filtered()==false) count++;
+			if(srcDB.get(i).is_filtered()==false) count++;
 		}
 		myProgressBarForm pbf = new myProgressBarForm();
 		Handle h = new Handle();
@@ -101,7 +101,7 @@
 		int nProcessed=0;
 		// Now do the actual work
 		for(int i = size-1; i>=0; i--){
-			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
+			CacheHolder srcHolder=srcDB.get(i);
 			if(srcHolder.is_filtered()==false){
 				h.progress = ((float)nProcessed++)/(float)count;
 				h.changed();

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/DetailsPanel.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -23,7 +23,7 @@
 	mComboBox chcStatus = new mComboBox(new String[]{"", MyLocale.getMsg(313,"Flag 1"), MyLocale.getMsg(314,"Flag 2"), MyLocale.getMsg(315,"Flag 3"), MyLocale.getMsg(316,"Flag 4"), MyLocale.getMsg(317,"Search"), MyLocale.getMsg(318,"Found"), MyLocale.getMsg(319,"Not Found"), MyLocale.getMsg(320,"Owner")},0);
 	mButton btnNewWpt, btnShowBug, btnShowMap, btnGoto, btnAddPicture, btnBlack, btnNotes, btnSave, btnCancel;
 	mButton btnFoundDate,btnHiddenDate;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	CacheHolder thisCache;
 	int dbIndex = -1;
 	CellPanel pnlTools = new CellPanel(); 

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/Filter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -118,7 +118,7 @@
 	*/
 	public void doFilterRoute(File routeFile, double distance){
 		Global.getProfile().selectionChanged = true;
-		Vector cacheDB=Global.getProfile().cacheDB;
+	    CacheDB cacheDB=Global.getProfile().cacheDB;
 		//load file into a vector:
 		Vector wayPoints = new Vector();
 		Regex rex = new Regex("(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})");
@@ -164,7 +164,7 @@
 			}
 			//initialise database
 			for(int i = cacheDB.size()-1; i >=0 ; i--){
-				ch = (CacheHolder)cacheDB.get(i);
+				ch = cacheDB.get(i);
 				ch.in_range = false;
 				//cacheDB.set(i, ch);
 			}
@@ -176,7 +176,7 @@
 				toPoint = (CWPoint)wayPoints.get(z+1);
 				//... go through the current cache database
 				for(int i = cacheDB.size()-1; i >=0 ; i--){
-					ch = (CacheHolder)cacheDB.get(i);
+					ch = cacheDB.get(i);
 					cwp = new CWPoint(ch.LatLon, CWPoint.CW);
 					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
 					calcDistance = (calcDistance*180*60)/java.lang.Math.PI;
@@ -190,7 +190,7 @@
 				} // for database
 			} // for segments
 			for(int i = cacheDB.size()-1; i >=0 ; i--){
-				ch = (CacheHolder)cacheDB.get(i);
+				ch = cacheDB.get(i);
 				if(ch.is_filtered() == false && ch.in_range == false) ch.setFiltered(true);
 			}
 		}catch(FileNotFoundException fnex){
@@ -328,7 +328,7 @@
 	*	not displaying a cache that is filtered.
 	*/
 	public void doFilter(){
-		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB=Global.getProfile().cacheDB;
 		Hashtable examinedCaches;
 		if (cacheDB.size()==0) return;
 		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
@@ -340,7 +340,7 @@
 		examinedCaches = new Hashtable(cacheDB.size());
 		
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (examinedCaches.containsKey(ch)) continue;
 			
 			boolean filterCache = excludedByFilter(ch);
@@ -603,13 +603,13 @@
 	*	Invert is_filtered flag on all caches
 	*/
 	public void invertFilter(){
-		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
 		if (cacheDB.size()==0) return;
 		Global.getProfile().selectionChanged = true;
 		boolean showBlackListed=Global.getProfile().showBlacklisted();
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (ch.is_black()==showBlackListed)
 				ch.setFiltered(!ch.is_filtered()); // Only invert those that would be shown under blacklist filter
 			else
@@ -624,10 +624,10 @@
 	*/
 	public void clearFilter(){
 		Global.getProfile().selectionChanged = true;
-		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			ch.setFiltered((ch.is_black()^Global.getProfile().showBlacklisted())) ; // Always filter blacklisted caches
 		}
 		Global.getProfile().setFilterActive(FILTER_INACTIVE);

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -17,7 +17,7 @@
 	
 	static Preferences pref;
 	Profile profile;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	CacheHolderDetail chD;
 	String strData, saveDir, logData, logIcon, logDate, logFinder, logId;
 	boolean inWpt, inCache, inLogs, inBug;
@@ -55,7 +55,7 @@
 		//index db for faster search
 		CacheHolder ch;
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			DBindex.put(ch.getWayPoint(), new Integer(i));
 		}//for
 	}
@@ -322,7 +322,7 @@
 			//Update cache data
 			else {
 				//Vm.debug("it is not new!");
-				CacheHolderDetail oldCh= new CacheHolderDetail((CacheHolder) cacheDB.get(index));
+				CacheHolderDetail oldCh= new CacheHolderDetail(cacheDB.get(index));
 				try {
 					//Vm.debug("Try to load");
 					oldCh.readCache(saveDir);

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -38,7 +38,7 @@
  */
 public class LOCXMLImporter extends MinML {
 	boolean debugXML = false;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 	String file;
@@ -55,7 +55,7 @@
 		file = f;
 		CacheHolder ch;
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			DBindexWpt.put(ch.getWayPoint(), new Integer(i));
 		}//for
 	}
@@ -160,7 +160,7 @@
 			ch.setWayPoint(wpt);
 			return ch;
 		}
-		ch = new CacheHolderDetail((CacheHolder) cacheDB.get(index));
+		ch = new CacheHolderDetail(cacheDB.get(index));
 		try {
 			ch.readCache(profile.dataDir);
 		} catch (Exception e) {Vm.debug("Could not open file: " + e.toString());};

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/MainMenu.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -254,7 +254,7 @@
 	public void onEvent(Event ev){
 		Preferences pref=Global.getPref();
 		Profile profile=Global.getProfile();
-		Vector cacheDB=profile.cacheDB;
+		CacheDB cacheDB=profile.cacheDB;
 		Global.mainTab.updatePendingChanges();
 		if (ev instanceof MenuEvent){ //&& ev.type == MenuEvent.PRESSED
 			MenuEvent mev = (MenuEvent)ev;
@@ -540,7 +540,7 @@
 				CacheHolder ch;
 				boolean filterChanged = false;
 				for(int i = cacheDB.size()-1; i>=0; i--){
-					ch = (CacheHolder)cacheDB.get(i);
+					ch = cacheDB.get(i);
 					// This is an incremental filter, i.e. it keeps the existing filter
 					// status and only adds the marked caches to the filtered set
 					if (ch.is_Checked && !ch.is_filtered()) {
@@ -558,7 +558,7 @@
 				CacheHolder ch;
 				boolean filterChanged = false;
 				for(int i = cacheDB.size()-1; i >=0; i--){
-					ch = (CacheHolder)cacheDB.get(i);
+					ch = cacheDB.get(i);
 					// incremental filter. Keeps status of all marked caches and
 					// adds unmarked caches to filtered list
 					if (!ch.is_Checked && !ch.is_filtered()) {
@@ -586,7 +586,7 @@
 			// "Organise" pulldown menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == orgNewWP){
-				if (Global.mainTab.tbP.getSelectedCache() >= 0) Global.mainTab.lastselected = ((CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache())).getWayPoint();
+				if (Global.mainTab.tbP.getSelectedCache() >= 0) Global.mainTab.lastselected = cacheDB.get(Global.mainTab.tbP.getSelectedCache()).getWayPoint();
 				Global.mainTab.newWaypoint(new CacheHolder());
 			}
 
@@ -677,7 +677,7 @@
 	public static void updateSelectedCaches(TablePanel tablePanel) {
 		Preferences pref=Global.getPref();
 		Profile profile=Global.getProfile();
-		Vector cacheDB=profile.cacheDB;
+		CacheDB cacheDB=profile.cacheDB;
 		CacheHolder ch;
 		
 		SpiderGC spider = new SpiderGC(pref, profile, false);
@@ -691,7 +691,7 @@
 		
 		Vector cachesToUpdate = new Vector();
 		for(int i = 0; i <	cacheDB.size(); i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if(ch.is_Checked == true && !ch.is_filtered()) {
 				if ( ch.getWayPoint().length()>1 && (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC") 
 						|| ch.getWayPoint().substring(0,2).equalsIgnoreCase("OC")))
@@ -721,7 +721,7 @@
 		boolean forceLogin=Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
 		for(int j = 0; j <	cachesToUpdate.size(); j++){
 			int i = ((Integer)cachesToUpdate.get(j)).intValue();
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 //			infB.setInfo("Loading: " + ch.wayPoint);
 			infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.getWayPoint() +" (" + (j+1) + " / " + cachesToUpdate.size() + ")");
 			infB.redisplay();

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/MainTab.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -20,7 +20,7 @@
 	DescriptionPanel descP= new DescriptionPanel();
 	HintLogPanel hintLP = new HintLogPanel();
 	TablePanel tbP;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	public DetailsPanel detP = new DetailsPanel();
 	CalcPanel calcP;
 	Preferences pref;
@@ -140,7 +140,7 @@
 				ch=null; chD=null; 
 				lastselected="";
 			} else {
-				ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+				ch = cacheDB.get(tbP.getSelectedCache());
 				lastselected=ch.getWayPoint();  // Used in Parser.Skeleton
 				try {
 					chD = ch.getCacheDetails(true);
@@ -311,7 +311,7 @@
 		mainCache=lastselected;
 		int selectedIndex = profile.getCacheIndex( lastselected );
 		if (selectedIndex >= 0) {
-			CacheHolder selectedCache = (CacheHolder) profile.cacheDB.get( selectedIndex );
+			CacheHolder selectedCache = profile.cacheDB.get( selectedIndex );
 			if ( selectedCache.isAddiWpt() ) {
 				mainCache = selectedCache.mainCache.getWayPoint();
 			}			

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/MyComparer.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -10,73 +10,73 @@
 public class MyComparer implements Comparer{
 	Vector cacheDB;
 	
-	public MyComparer(Vector cacheDB, int colToCompare, int visibleSize){
+	public MyComparer(CacheDB cacheDB, int colToCompare, int visibleSize){
 		//visibleSize=Global.mainTab.tbP.myMod.numRows;
 		if (visibleSize<2) return;
 		for (int i=visibleSize; i<cacheDB.size(); i++) {
-			CacheHolder ch=(CacheHolder) cacheDB.get(i);
+			CacheHolder ch=cacheDB.get(i);
 			ch.sort="\uFFFF";
 		}
 		if (colToCompare==1) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=String.valueOf(ch.getType());
 			}
 		} else if (colToCompare==2) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.getHard();
 			}
 		} else if (colToCompare==3) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.getTerrain();
 			}
 		} else if (colToCompare==4) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.getWayPoint().toUpperCase();
 			}
 		} else if (colToCompare==5) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.getCacheName().toLowerCase();
 			}
 		} else if (colToCompare==6) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.LatLon;
 			}
 		} else if (colToCompare==7) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.getCacheOwner().toLowerCase();
 			}
 		} else if (colToCompare==8) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.getDateHidden();
 			}
 		} else if (colToCompare==9) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.getCacheStatus();
 			}
 		} else if (colToCompare==10) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				// CHECK Is the formatting correctly done?
 				ch.sort = MyLocale.formatDouble(ch.kilom*1000, "000000000000");
 			}
 		} else if (colToCompare==11) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				ch.sort=ch.bearing;
 			}
 			
 		} else if (colToCompare==12) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				if (ch.getCacheSize().length()==0) ch.sort="?";
 				else switch (ch.getCacheSize().charAt(0)) {
 					case 'M': ch.sort="1"; break;
@@ -89,7 +89,7 @@
 			}
 		} else if (colToCompare==13) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				if (ch.getWayPoint().startsWith("OC"))
 					ch.sort=MyLocale.formatLong(ch.getNumRecommended(),"00000");
 				else
@@ -97,7 +97,7 @@
 			}			
 		} else if (colToCompare==14) {
 			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				CacheHolder ch=cacheDB.get(i);
 				if (ch.getWayPoint().startsWith("OC"))
 					ch.sort=MyLocale.formatLong(ch.recommendationScore,"00000");
 				else

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -34,7 +34,7 @@
 	int numCacheImported, numDescImported, numLogImported= 0;
 
 	boolean debugGPX = false;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	InfoBox inf;
 	CacheHolder ch;
 	CacheHolderDetail chD;
@@ -74,7 +74,7 @@
 		}
 		user = p.myAlias.toLowerCase();
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			DBindexWpt.put(ch.getWayPoint(), new Integer(i));
 			if (!ch.getOcCacheID().equals(""))
 				DBindexID.put(ch.getOcCacheID(), new Integer(i));
@@ -92,7 +92,7 @@
 	 * @return true, if some change was made to the cacheDB
 	 */
 	public boolean syncSingle(int number, InfoBox infB) {
-		ch = (CacheHolder)cacheDB.get(number);
+		ch = cacheDB.get(number);
 		chD= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
 
 		if (infB.isClosed) {
@@ -175,7 +175,7 @@
 		profile.setDistOC(dist);
 		// Clear status of caches in db
 		for(int i = cacheDB.size()-1; i>=0 ;i--){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			ch.setUpdated(false);
 			ch.setNew(false);
 			ch.setLog_updated(false);
@@ -746,7 +746,7 @@
 			chD = new CacheHolderDetail();
 			return chD;
 		}
-		chD = ((CacheHolder) cacheDB.get(index)).getCacheDetails(true);
+		chD = cacheDB.get(index).getCacheDetails(true);
 /*		try {
 			chD.readCache(profile.dataDir);
 		} catch (Exception e) {Vm.debug("Could not open file: " + e.toString());};
@@ -754,4 +754,4 @@
 	}
 
 
-}
\ No newline at end of file
+}

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/Parser.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -224,7 +224,7 @@
 		if (varName.startsWith("$")) { // Potential coordinate
 			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
 			if (idx!=-1) { // Found it!
-				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				CacheHolder ch=Global.getProfile().cacheDB.get(idx);
 				// Check whether coordinates are valid
 				cwPt.set(ch.pos);
 				if (cwPt.isValid() )
@@ -547,7 +547,7 @@
     		int i=Global.getProfile().getCacheIndex(waypointName);
     		if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
     		cwPt.set(coord);
-    		CacheHolder ch=((CacheHolder)Global.getProfile().cacheDB.get(i));
+    		CacheHolder ch=Global.getProfile().cacheDB.get(i);
     		ch.LatLon=cwPt.toString(CWPoint.CW);
     		ch.pos.set(cwPt);
     		ch.calcDistance(Global.getPref().curCentrePt); // Update distance/bearing
@@ -666,8 +666,8 @@
     	int ci=Global.getProfile().getCacheIndex(waypointName);
     	if (ci<0) return;
     	// If it is an addi, find its main cache
-    	if (((CacheHolder) Global.getProfile().cacheDB.get(ci)).isAddiWpt()) {
-    		waypointName=((CacheHolder) Global.getProfile().cacheDB.get(ci)).mainCache.getWayPoint();
+    	if (Global.getProfile().cacheDB.get(ci).isAddiWpt()) {
+    		waypointName=Global.getProfile().cacheDB.get(ci).mainCache.getWayPoint();
     	}
    		int nStages=-1;
     	if (nargs==1) {
@@ -709,7 +709,7 @@
     	} else {
 	    	int i=Global.getProfile().getCacheIndex(waypointName);
 			if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
-	   	    CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(i);
+	   	    CacheHolder ch=Global.getProfile().cacheDB.get(i);
 			CacheHolder addiWpt;
 	   	    if (ch.hasAddiWpt()){
 	   	    	op.append("cls()\n");
@@ -893,7 +893,7 @@
 		if (varName.startsWith("$")) { // Potential coordinate
 			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
 			if (idx!=-1) { // Yes, is a coordinate
-				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				CacheHolder ch=Global.getProfile().cacheDB.get(idx);
 				// Check whether new coordinates are valid
 				String coord=popCalcStackAsString();
 				cwPt.set(coord);

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/Profile.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -25,7 +25,7 @@
 	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
 	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector. 
 	 */
-	public Vector cacheDB=new Vector();
+	public CacheDB cacheDB=new CacheDB();
 	/** The centre point of this group of caches. Read from ans stored to index.xml file */
 	public CWPoint centre=new CWPoint();
 	/** The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
@@ -206,7 +206,7 @@
 					h.progress = (float) i / (float) size;
 					h.changed();
 				}
-				ch = (CacheHolder) cacheDB.get(i);
+				ch = cacheDB.get(i);
 				// //Vm.debug("Saving: " + ch.CacheName);
 				if (ch.getWayPoint().length() > 0) { // TODO && ch.LongDescription.equals("An
 /*					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
@@ -356,10 +356,9 @@
 	}
 	
 	void checkBlacklistStatus() {
-		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (ch.is_black() ^ showBlacklisted()) {
 				ch.setFiltered(true);
 				selectionChanged = true;
@@ -368,15 +367,7 @@
 	}
 
 	public int getCacheIndex(String wp) {
-		int retval = -1;
-		CacheHolder ch;
-		for (int i = 0; i < cacheDB.size(); i++) {
-			ch = (CacheHolder) cacheDB.get(i);
-			if (ch.getWayPoint().equals(wp)) {
-				return i;
-			}
-		}
-		return retval;
+		return cacheDB.getIndex(wp);
 	}
 
 	/** Get a unique name for a new waypoint */
@@ -390,7 +381,7 @@
 		// Create new waypoint,look if not in db
 		for (int i = 0; i < s; i++) {
 			strWp = "CW" + MyLocale.formatLong(lgWp, "0000");
-			if (((CacheHolder) cacheDB.get(i)).getWayPoint().indexOf(strWp) >= 0) {
+			if (cacheDB.get(i).getWayPoint().indexOf(strWp) >= 0) {
 				// waypoint exists in database
 				lgWp++;
 				i = -1; // Because i++ will be executed next, so we start the loop with 0
@@ -427,7 +418,7 @@
 			mainindex = getCacheIndex("CW" + mainwpt);
 		if (mainindex < 0)
 			throw new IllegalArgumentException("no main cache found for: " + ch.getWayPoint());
-		CacheHolder mainch = (CacheHolder) cacheDB.get(mainindex);
+		CacheHolder mainch = cacheDB.get(mainindex);
 		mainch.addiWpts.add(ch);
 		ch.mainCache = mainch;
 	}
@@ -441,7 +432,7 @@
 		selectionChanged = true;
 		CacheHolder ch;
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
-			ch = (CacheHolder) cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (ch.is_filtered() == false)
 				ch.is_Checked = selectStatus;
 		}
@@ -458,7 +449,7 @@
 		numCachesInArea = 0;
 		boolean isAddi = false;
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
-			ch = (CacheHolder) cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
 				if (ch.pos == null) { // this can not happen
 					tmpca.set(ch.LatLon);
@@ -491,11 +482,11 @@
 	 */
 	public void updateBearingDistance(){
 		CWPoint centerPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
-		int anz = cacheDB.getCount();
+		int anz = cacheDB.size();
 		CacheHolder ch;
 		// Jetzt durch die CacheDaten schleifen
 		while(--anz >= 0){
-			ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
+			ch = cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 			ch.calcDistance(centerPoint);
 		}
 		// The following call is not very clean as it mixes UI with base classes
@@ -515,7 +506,7 @@
 		Integer index;
 		// Build index for faster search and clear all references
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
-			ch = (CacheHolder) cacheDB.get(i);
+			ch = cacheDB.get(i);
 			ch.addiWpts.clear();
 			ch.mainCache = null;
 			// if (ch.wayPoint.startsWith("GC")) // Only put potential master caches into the index
@@ -524,7 +515,7 @@
 		// Build references
 		int max = cacheDB.size();
 		for (int i = 0; i < max; i++) {
-			ch = (CacheHolder) cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (ch.isAddiWpt()) {
 				// search main cache
 				index = (Integer) dbIndex.get("GC" + ch.getWayPoint().substring(2));
@@ -534,7 +525,7 @@
 					index = (Integer) dbIndex.get("CW"+ ch.getWayPoint().substring(2));
 
 				if (index != null) {
-					mainCh = (CacheHolder) cacheDB.get(index.intValue());
+					mainCh = cacheDB.get(index.intValue());
 					mainCh.addiWpts.add(ch);
 					ch.mainCache = mainCh;
 					ch.setAttributesFromMainCache(mainCh);
@@ -543,7 +534,7 @@
 		}// for
 		// sort addi wpts
 		for (int i = 0; i < max; i++) {
-			ch = (CacheHolder) cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (ch.hasAddiWpt() && (ch.addiWpts.size() > 1)) {
 				// ch.addiWpts.sort(new
 				// MyComparer(ch.addiWpts,MyLocale.getMsg(1002,"Waypoint"),ch.addiWpts.size()),

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/RadarPanel.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -16,7 +16,7 @@
 	mButton btPlus = new mButton("   +   ");
 	int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
 	Preferences pref;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	myInteractivePanel iActP;
 	double scale;
 	int scaleKm = 30;
@@ -51,7 +51,7 @@
 	* database. It also calculates the maximum size available for drawing 
 	* the radar.
 	*/
-	public void setParam(Preferences p, Vector db, String sWp){
+	public void setParam(Preferences p, CacheDB db, String sWp){
 		selectedWaypoint = sWp;
 		pref = p;
 		cacheDB = db;
@@ -105,7 +105,7 @@
 		double degrees;
 		double pi180=java.lang.Math.PI / 180.0;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
-			holder = (CacheHolder)cacheDB.get(i);
+			holder = cacheDB.get(i);
 			if(!holder.is_filtered() && holder.pos.isValid()) {
 				degrees = holder.degrees * pi180;
 				x =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -9,9 +9,9 @@
 */
 public class SearchCache {
 
-	Vector cacheDB;
+	CacheDB cacheDB;
 	
-	public SearchCache(Vector DB){
+	public SearchCache(CacheDB DB){
 		cacheDB = DB;
 	}
 	
@@ -31,7 +31,7 @@
 			//TableModel will be responsible for displaying
 			//marked caches.
 			for(int i = 0;i < cacheDB.size();i++){
-				ch = (CacheHolder)cacheDB.get(i);
+				ch = cacheDB.get(i);
 				if (ch.is_filtered()) break; // Reached end of visible records
 				if(ch.getWayPoint().toUpperCase().indexOf(searchStr) <0 && 
 				   ch.getCacheName().toUpperCase().indexOf(searchStr) <0 && 
@@ -52,7 +52,7 @@
 	public void clearSearch(){
 		Global.getProfile().selectionChanged = true;
 		for(int i = cacheDB.size()-1;i >=0;i--){
-			CacheHolder ch=((CacheHolder)cacheDB.get(i));
+			CacheHolder ch=cacheDB.get(i);
 			ch.is_flaged=false;
 			//ch.setFiltered((ch.is_black()^Global.getProfile().showBlacklisted())) ;
 		}

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -57,7 +57,7 @@
 	private static String cookieSession = "";
 	private static double distance = 0;
 	private Regex inRex = new Regex();
-	private Vector cacheDB;
+	private CacheDB cacheDB;
 	private Vector cachesToLoad = new Vector();
 	private Hashtable indexDB;
 	private InfoBox infB;
@@ -212,7 +212,7 @@
 	public int spiderSingle(int number, InfoBox infB, boolean forceLogin){
 		int ret=-1;
 		this.infB = infB;
-		CacheHolder ch = (CacheHolder)cacheDB.get(number);
+		CacheHolder ch = cacheDB.get(number);
 		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
 
 		// check if we need to login
@@ -235,7 +235,7 @@
 			if (ret == 1) {
 				pref.log("Saving to:" + profile.dataDir);
 				chD.saveCacheDetails(profile.dataDir);
-				((CacheHolder) cacheDB.get(number)).update(chD);
+				cacheDB.get(number).update(chD);
 			}
 		}catch(Exception ex){
 			pref.log("Error spidering " + chD.getWayPoint() + " in spiderSingle");
@@ -298,7 +298,7 @@
 		CacheHolder ch;
 		//index the database for faster searching!
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			indexDB.put(ch.getWayPoint(), new Integer(i));
 			ch.setNew(false);
 		}
@@ -364,7 +364,7 @@
 			distanceInKm = Metrics.convertUnit(distance, Metrics.MILES, Metrics.KILOMETER);
 		}
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (spiderAllFinds) {
 				if ( (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) ) {
 					cachesToUpdate.put(ch.getWayPoint(), new Integer(i));
@@ -462,7 +462,7 @@
 							}
 						} else {
 							pref.log(waypoint+" already in DB");
-							ch=(CacheHolder) cacheDB.get(nr.intValue());
+							ch=cacheDB.get(nr.intValue());
 							// If the <strike> tag is used, the cache is marked as unavailable or archived
 							boolean is_archived_GC=lineRex.stringMatched(1).indexOf("<strike><font color=\"red\">")!=-1;
 							boolean is_available_GC=lineRex.stringMatched(1).indexOf("<strike>")==-1;
@@ -581,7 +581,7 @@
 			int j = 1;
 			for (Enumeration e = cachesToUpdate.elements() ; e.hasMoreElements() ; j++) {
 				int i = ((Integer)e.nextElement()).intValue();
-				ch = (CacheHolder)cacheDB.get(i);
+				ch = cacheDB.get(i);
 				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.getWayPoint() +" (" + (cachesToLoad.size()+j) + " / " + totalCachesToLoad + ")");
 				infB.redisplay();
 
@@ -1344,7 +1344,7 @@
 				counter++;
 				int idx=profile.getCacheIndex(adWayPoint);
 				if (idx>=0) {
-					cxD=new CacheHolderDetail((CacheHolder) cacheDB.get(idx));
+					cxD=new CacheHolderDetail(cacheDB.get(idx));
 					try{ // If addi exists, try to read it to preserve the notes
 						cxD.readCache(profile.dataDir);
 					} catch (Exception ex) {};
@@ -1369,7 +1369,7 @@
 					cxD.setUpdated(false);
 					cacheDB.add(new CacheHolder(cxD));
 				}else {
-					CacheHolder cx=(CacheHolder) cacheDB.get(idx);
+					CacheHolder cx=cacheDB.get(idx);
 					if (cx.is_Checked && // Only re-spider existing addi waypoints that are ticked
 				 	   !cx.is_filtered()) { // and are visible (i.e.  not filtered)
 					   cx.update(cxD);

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/StatusBar.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -20,7 +20,7 @@
 	mImage imgCacheTour;
 	boolean MobileVGA;
 	
-	public StatusBar(Preferences p, Vector db){
+	public StatusBar(Preferences p, CacheDB db){
 		pref=p;
 		int sw = MyLocale.getScreenWidth();
 		MobileVGA = (Vm.isMobile() && sw >= 400);

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/TablePanel.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -13,7 +13,7 @@
 	myTableControl tc;
 	myTableModel myMod;
 	Preferences pref;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	MainTab myMaintab;
 	StatusBar statBar;
 	/** We keep track of the currently selected cache in two variables(for speed)
@@ -102,7 +102,7 @@
 		Vector oldVisibleCaches = null;
 		int sel = getSelectedCache();
 		if ((sel >= 0) && (sel < cacheDB.size()) ) // sel > cacheDB.size() can happen if you load a new profile, which is smaller than the old profile and you selected one cache that exceeds the number of caches in the new profile  
-			wayPoint = ((CacheHolder)cacheDB.get(sel)).getWayPoint();
+			wayPoint = cacheDB.get(sel).getWayPoint();
 		else wayPoint = null;
 		// Then: remember all caches that are visible before the refresh
 		if (wayPoint != null) {

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -58,13 +58,13 @@
 	private String waypoint="";
 	
 	public TravelbugJourneyScreen() {
-		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB=Global.getProfile().cacheDB;
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
 		CellPanel tablepane = split.getNextPanel();
 		int curCacheNo=Global.mainTab.tbP.getSelectedCache();
 		String cache="";
 		if (curCacheNo>=0 && curCacheNo<cacheDB.size()) {
-			ch=(CacheHolder)cacheDB.elementAt(curCacheNo);
+			ch=cacheDB.get(curCacheNo);
 			cache=MyLocale.getMsg(6022,": Current cache: ")+ch.getWayPoint()+" - "+ch.getCacheName();
 			waypoint=ch.getWayPoint();
 			chD=new CacheHolderDetail(ch);

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -55,8 +55,8 @@
 		timePenOn=Vm.getTimeStampLong();
 		setFont(font);
 		RadarPanelImage imgRP=(RadarPanelImage) which;
-		ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
-		CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+		CacheDB cacheDB=Global.getProfile().cacheDB;
+		CacheHolder ch=cacheDB.get(imgRP.rownum);
 		String s=ch.getWayPoint()+"  "+ch.getCacheSize()+" / "+strDifficulty+"="+ch.getHard()+"  "+strTerrain+"="+ch.getTerrain();
 		String s1=ch.getCacheName();
 		if (s1.length()>40) s1=s1.substring(0,40);
@@ -102,11 +102,11 @@
 	
 	public void startDragging(DragContext dc) {
 		if (!Global.mainForm.cacheListVisible) return;
-		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB=Global.getProfile().cacheDB;
 //Vm.debug("myIAP startDrag "+dc.start.x+"/"+dc.start.y);
 		int idx=Global.getProfile().getCacheIndex(wayPoint); 
 		if (idx>=0) {
-			 CacheHolder ch=(CacheHolder) cacheDB.get(idx);
+			 CacheHolder ch=cacheDB.get(idx);
 			 //wayPoint=ch.wayPoint;
 			 //Vm.debug("Waypoint : "+ch.wayPoint);
 			 IconAndText icnDrag=new IconAndText();
@@ -132,8 +132,8 @@
 		AniImage dragImage=null;
 		if (which instanceof RadarPanelImage) {
 			RadarPanelImage imgRP=(RadarPanelImage) which;
-			ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
-			CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+			CacheDB cacheDB=Global.getProfile().cacheDB;
+			CacheHolder ch=cacheDB.get(imgRP.rownum);
 			wayPoint=ch.getWayPoint();
 			
 			int tw,th;

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/myTableControl.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -15,7 +15,7 @@
 
 	public Preferences pref;
 	public Profile profile;
-	public Vector cacheDB;
+	public CacheDB cacheDB;
 	public TablePanel tbp;
 	
 	private MenuItem miOpen, miGoto, miCenter;
@@ -102,10 +102,10 @@
 				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
 				else if (ev.key == IKeys.DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1)); 
 				else if (ev.key == IKeys.UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
-				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y>=0 && cursor.y<tbp.myMod.numRows) Global.mainForm.cacheList.addCache(((CacheHolder)cacheDB.elementAt(cursor.y)).getWayPoint()); 
+				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y>=0 && cursor.y<tbp.myMod.numRows) Global.mainForm.cacheList.addCache(cacheDB.get(cursor.y).getWayPoint()); 
 				else if (ev.key == IKeys.RIGHT) {
 					CacheHolder ch;
-					ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
+					ch = cacheDB.get(tbp.getSelectedCache());
 					Global.mainTab.gotoPoint(ch.pos);
 				}
 				else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f 
@@ -147,7 +147,7 @@
 			int shouldDeleteCount=0;
 			boolean deleteFiltered=true;  // Bisheriges Verhalten
 			for(int i = cacheDB.size()-1; i >=0; i--){
-				CacheHolder currCache = (CacheHolder)cacheDB.get(i);
+				CacheHolder currCache = cacheDB.get(i);
 				if ( currCache.is_Checked) {
 					allCount++;
 					if (currCache.is_filtered()) {
@@ -184,13 +184,13 @@
 					int nDeleted=0;
 					int size=cacheDB.size();
 					for(int i = size-1; i >=0; i--){// Start Counting down, as the size decreases with each deleted cache
-						ch = (CacheHolder)cacheDB.get(i);
+						ch = cacheDB.get(i);
 						if(ch.is_Checked && (!ch.is_filtered() || deleteFiltered)) {
 							nDeleted++;
 							h.progress = ((float)nDeleted)/(float)allCount;
 							h.changed();
 							dm.deleteCacheFiles(ch.getWayPoint(),profile.dataDir);
-							cacheDB.remove(ch);
+							cacheDB.removeElementAt(i);
 							ch.releaseCacheDetails();
 							ch=null;
 							if (pbf.isClosed) break;
@@ -214,7 +214,7 @@
 				Global.getPref().log("popupMenuEvent: getSelectedCache() < 0");
 				return;
 			}
-			CacheHolder thisCache = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
+			CacheHolder thisCache = cacheDB.get(tbp.getSelectedCache());
 			CWPoint cp=new CWPoint(thisCache.LatLon);
 			if (!cp.isValid()){
 				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
@@ -227,12 +227,12 @@
 		}
 
 		if (selectedItem == miGoto){
-			ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
+			ch = cacheDB.get(tbp.getSelectedCache());
 			Global.mainTab.gotoPoint(ch.pos);
 		}
 		if (selectedItem == miOpenOnline){
 			if(browserPathIsValid()){
-				ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
+				ch = cacheDB.get(tbp.getSelectedCache());
 				CacheHolderDetail chD=ch.getCacheDetails(false, true);
 				try {
 					if (chD != null) {
@@ -250,7 +250,7 @@
 		if (selectedItem == miOpenOffline) {
 			if(browserPathIsValid()){
 				ShowCacheInBrowser sc=new ShowCacheInBrowser();
-				sc.showCache(((CacheHolder)cacheDB.get(tbp.getSelectedCache())).getCacheDetails(false, true));
+				sc.showCache(cacheDB.get(tbp.getSelectedCache()).getCacheDetails(false, true));
 			}
 		}
 		if (selectedItem == miOpen){
@@ -288,7 +288,7 @@
 	int row;
 	
 	public void startDragging(DragContext dc) {
-		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB=Global.getProfile().cacheDB;
 		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
 		 wayPoint=null;
 		 if (p.y>=0) { 
@@ -297,7 +297,7 @@
 				return;
 			}
 			 row=p.y;
-			 CacheHolder ch=(CacheHolder)cacheDB.get(p.y);
+			 CacheHolder ch=cacheDB.get(p.y);
 			 wayPoint=ch.getWayPoint();
 			 //Vm.debug("Waypoint : "+ch.wayPoint);
 			 imgDrag=new IconAndText();

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -24,7 +24,7 @@
 	private static final Color COLOR_SELECTED	= new Color(198,198,198);
 	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived && Found
 	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);	
-	private Vector cacheDB;
+	private CacheDB cacheDB;
 	/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
 	 * the element j (as per the list below) is visible in column i. 
 	 * [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates, 
@@ -128,7 +128,7 @@
 		// - filtered caches are moved to the end
 		int size=cacheDB.size();
 		for (int i=0; i<size; i++){
-			ch = (CacheHolder) cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (ch.is_filtered()) {
 				filteredDB.add(ch);
 			} else { // point is not filtered
@@ -169,7 +169,7 @@
 		ta.anchor = CellConstants.LEFT;
 		if(row >= 0){ 
 			try {
-			   CacheHolder ch = (CacheHolder)cacheDB.get(row);
+			   CacheHolder ch = cacheDB.get(row);
 				if(isSelected == true) ta.fillColor = COLOR_SELECTED;
 				else if(ch.is_available() == false && ch.is_found() == true){
 					ta.fillColor = COLOR_ARCHFND_BG;   // Green BG
@@ -210,7 +210,7 @@
 	public Object getCellData(int row, int col){
 		if(row == -1) return colName[colMap[col]];
 		try { // Access to row can fail if many caches are deleted
-			CacheHolder ch = (CacheHolder)cacheDB.get(row);
+			CacheHolder ch = cacheDB.get(row);
 			if(ch.is_filtered() == false){
 				switch(colMap[col]) { // Faster than using column names
 					case 0: // Checkbox
@@ -316,7 +316,7 @@
 				}
 				Vm.showWait(true);
 				Point a = tcControl.getSelectedCell(null);
-				if((a != null) && (a.y >= 0) && (a.y < cacheDB.size())) ch = (CacheHolder)cacheDB.get(a.y);
+				if((a != null) && (a.y >= 0) && (a.y < cacheDB.size())) ch = cacheDB.get(a.y);
 				if (mappedCol == sortedBy) sortAsc=!sortAsc;
 				else sortAsc = false;
 				sortedBy = mappedCol;
@@ -355,7 +355,7 @@
 		CacheHolder ch;
 		boolean singleRow= from == to;
 		for (int j=from; j<=to; j++) {
-			ch=(CacheHolder) cacheDB.get(j);
+			ch=cacheDB.get(j);
 			ch.is_Checked= !ch.is_Checked; 
 			tcControl.repaintCell(j, x);
 			// set the ceckbox also for addi wpts
@@ -366,7 +366,7 @@
 					addiWpt = (CacheHolder)ch.addiWpts.get(i);
 					addiWpt.is_Checked = ch.is_Checked;
 					if (!addiWpt.is_filtered()){
-						tcControl.repaintCell(cacheDB.find(addiWpt), x);
+						tcControl.repaintCell(cacheDB.getIndex(addiWpt), x);
 					}
 				}
 				

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -1,6 +1,7 @@
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CoordsScreen;
 import CacheWolf.DetailsPanel;
@@ -39,7 +40,7 @@
 	Color gpsStatus;
 
 	MainTab mainT;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	DetailsPanel detP;
 
 	Preferences pref;

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -1,6 +1,7 @@
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CoordsScreen;
 import CacheWolf.Global;
@@ -53,7 +54,7 @@
 	int[] sortingMapServices;
 	boolean[] inbound;
 	CWPoint center;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	boolean perCache;
 	boolean onlySelected;
 	float radius;
@@ -62,7 +63,7 @@
 	boolean overviewmap;
 	int numCaches;
 
-	public MapLoaderGui(Vector cacheDBi) {
+	public MapLoaderGui(CacheDB cacheDBi) {
 		super();
 		this.title = MyLocale.getMsg(1800, "Download georeferenced maps"); 
 		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
@@ -240,7 +241,7 @@
 			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
 			int numCaches = Global.getProfile().numCachesInArea;
 			for (int i=cacheDB.size()-1; i >= 0; i--) {
-				ch = (CacheHolder) cacheDB.get(i);
+				ch = cacheDB.get(i);
 				if (!this.onlySelected || ch.is_Checked) {
 					if (ch.pos == null) { // this can not happen
 						tmpca.set(ch.LatLon);

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -1,6 +1,7 @@
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheType;
 import CacheWolf.Global;
@@ -34,7 +35,7 @@
 	MovingMapPanel mmp;
 	MapsList maps;
 	Vector symbols;
-	Vector cacheDB;
+	CacheDB cacheDB;
 	TrackOverlay[] TrackOverlays;
 	CWPoint TrackOverlaySetCenterTopLeft;
 	Vector tracks;
@@ -80,7 +81,7 @@
 	
 	float lastHighestResolutionGPSDestScale = -1;
 
-	public MovingMap(Navigate nav, Vector cacheDB){
+	public MovingMap(Navigate nav, CacheDB cacheDB){
 		this.cacheDB = cacheDB;
 		this.myNavigation = nav;
 		this.pref = Global.getPref();
@@ -377,7 +378,7 @@
 			removeAllMapSymbolsButGoto();
 			CacheHolder ch;
 			for (int i=cacheDB.size()-1; i>=0; i--) {
-				ch = (CacheHolder) cacheDB.get(i);
+				ch = cacheDB.get(i);
 				if (ch.is_Checked && !ch.is_filtered() && ch != mainT.ch) {
 					if (ch.pos.isValid()) addSymbol(ch.getCacheName(), ch, CacheType.cache2Img(ch.getType()), ch.pos);
 				}

Modified: trunk/src/exp/ExploristExporter.java
===================================================================
--- trunk/src/exp/ExploristExporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/exp/ExploristExporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -34,7 +34,7 @@
 	final static int LAT_LON = 1;
 	final static int COUNT = 2;
 
-	Vector cacheDB;
+	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 	// mask in file chooser
@@ -128,7 +128,7 @@
 		int counter = 0;
 		int expCount = 0;
 		for (int i = 0; i < cacheDB.size(); i++) {
-			ch = (CacheHolder) cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if (ch.is_black() == false && ch.is_filtered() == false)
 				counter++;
 		}
@@ -136,7 +136,7 @@
 		try {
 			PrintWriter outp = null;
 			for (int i = 0; i < cacheDB.size(); i++) {
-				ch = (CacheHolder) cacheDB.get(i);
+				ch = cacheDB.get(i);
 				if (ch.is_black() == false && ch.is_filtered() == false) {
 					// all 200 caches we need a new file
 					if (expCount % 200 == 0) {
@@ -311,4 +311,4 @@
 		}
 	}
 	
-}
\ No newline at end of file
+}

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/exp/Exporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -33,7 +33,7 @@
 	final static int LAT_LON 	= 1;
 	final static int COUNT 		= 2;
 	
-	Vector cacheDB;
+	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 	// mask in file chooser
@@ -93,7 +93,7 @@
 		int counter = 0;
 		int expCount = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 		}
 
@@ -103,7 +103,7 @@
 			if (str != null) outp.print(str);
 			holder=new CacheHolderDetail();
 			for(int i = 0; i<cacheDB.size(); i++){
-				ch=(CacheHolder)cacheDB.get(i);
+				ch=cacheDB.get(i);
 				if(ch.is_black() == false && ch.is_filtered() == false){
 					expCount++;
 					h.progress = (float)expCount/(float)counter;

Modified: trunk/src/exp/HTMLExporter.java
===================================================================
--- trunk/src/exp/HTMLExporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/exp/HTMLExporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -17,7 +17,7 @@
 */
 public class HTMLExporter{
 //	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
+	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 	String [] template_init_index = {
@@ -69,7 +69,7 @@
 			//Generate index page
 			int counter = 0;
 			for(int i = 0; i<cacheDB.size();i++){
-				ch = (CacheHolder)cacheDB.get(i);
+				ch = cacheDB.get(i);
 				if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 			}
 			
@@ -81,7 +81,7 @@
 				h.progress = (float)(i+1)/(float)counter;
 				h.changed();
 
-				ch = (CacheHolder)cacheDB.get(i);
+				ch = cacheDB.get(i);
 				if(	ch.is_black() == false && ch.is_filtered() == false){
 					holder=ch.getCacheDetails(false,true);
 					varParams = new Hashtable();

Modified: trunk/src/exp/KMLExporter.java
===================================================================
--- trunk/src/exp/KMLExporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/exp/KMLExporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -76,7 +76,7 @@
 		int counter = 0;
 		int expCount = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 		}
 		copyIcons(outFile.getParent());
@@ -176,7 +176,7 @@
 
 		// fill structure with data from cacheDB
 		for(int i = 0; i<cacheDB.size(); i++){
-			ch=(CacheHolder)cacheDB.get(i);
+			ch=cacheDB.get(i);
 			// TODO Das Argument nach STring zu casten gef?llt mir nicht ganz...
 			if(ch.is_black() == false && ch.is_filtered() == false && !ch.isAddiWpt()){
 				if (ch.is_found()) { tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));}

Modified: trunk/src/exp/TPLExporter.java
===================================================================
--- trunk/src/exp/TPLExporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/exp/TPLExporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -26,6 +26,7 @@
 package exp;
 
 import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheHolderDetail;
 import CacheWolf.CacheType;
@@ -127,7 +128,7 @@
  
 
 public class TPLExporter {
-	Vector cacheDB;
+	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 	String tplFile;
@@ -157,7 +158,7 @@
 		pref.setExportPath(expName, saveTo.getPath());
 		int counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
+			ch = cacheDB.get(i);
 			if(ch.is_black() == false && ch.is_filtered() == false) counter++;
 		}
 		pbf.showMainTask = false;
@@ -182,7 +183,7 @@
 			Template tpl = new Template(args);
 
 			for(int i = 0; i<counter;i++){
-				ch = (CacheHolder)cacheDB.get(i);
+				ch = cacheDB.get(i);
 				h.progress = (float)i/(float)counter;
 				h.changed();
 				if(ch.is_black() == false && ch.is_filtered() == false){

Modified: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/exp/TomTomExporter.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -17,7 +17,7 @@
 	public final static int TT_WPT_NUM = 1;
 	public final static String expName = "TomTom";
 
-	Vector cacheDB;
+	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 
@@ -79,7 +79,7 @@
 		currExp = 0;
 		counter = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
+			holder = cacheDB.get(i);
 			if(holder.is_black() == false && holder.is_filtered() == false) counter++;
 		}
 		
@@ -92,7 +92,7 @@
 				dfile.delete();
 				out =  new RandomAccessFile(fileName,"rw");
 				for(int i = 0; i<cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
+					holder=cacheDB.get(i);
 					if(holder.getType() == new Integer(CacheType.wayType[j][TT_WPT_NUM]).intValue() && holder.is_black() == false && holder.is_filtered() == false){
 						currExp++;
 						h.progress = (float)currExp/(float)counter;
@@ -137,7 +137,7 @@
 		int counter = 0;
 		int expCount = 0;
 		for(int i = 0; i<cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
+			holder = cacheDB.get(i);
 			if(holder.is_black() == false && holder.is_filtered() == false) counter++;
 		}
 
@@ -146,7 +146,7 @@
 			dfile.delete();
 			out =  new RandomAccessFile(fileName,"rw");
 			for(int i = 0; i<cacheDB.size(); i++){
-				holder=(CacheHolder)cacheDB.get(i);
+				holder=cacheDB.get(i);
 				if(holder.is_black() == false && holder.is_filtered() == false){
 					expCount++;
 					h.progress = (float)expCount/(float)counter;

Added: trunk/src/utils/MutableInteger.java
===================================================================
--- trunk/src/utils/MutableInteger.java	2009-04-05 22:21:10 UTC (rev 1739)
+++ trunk/src/utils/MutableInteger.java	2009-04-07 17:51:40 UTC (rev 1740)
@@ -0,0 +1,31 @@
+/**
+ * 
+ */
+package utils;
+
+import ewe.util.Intable;
+
+/**
+ * Mutable Integer class, in case we need several integer Values
+ * which could be reused in order to decrease object creation. 
+ */
+public class MutableInteger implements Intable {
+
+	int value;
+	public MutableInteger() {
+		value = -1;
+	}
+	
+	public MutableInteger(int initialValue) {
+		value = initialValue;
+	}
+
+	public int getInt(){
+		return value;
+	}
+	
+	public void setInt(int value) {
+		this.value = value;
+	}
+
+}



From engywuck at mail.berlios.de  Wed Apr  8 18:41:55 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Wed, 8 Apr 2009 18:41:55 +0200
Subject: [Cachewolf-svn] r1741 - trunk/src/CacheWolf
Message-ID: <200904081641.n38GftfR022651@sheep.berlios.de>

Author: engywuck
Date: 2009-04-08 18:41:52 +0200 (Wed, 08 Apr 2009)
New Revision: 1741

Modified:
   trunk/src/CacheWolf/CacheDB.java
Log:
Little bugfix of a bug that currently couldn't have effect.

Modified: trunk/src/CacheWolf/CacheDB.java
===================================================================
--- trunk/src/CacheWolf/CacheDB.java	2009-04-07 17:51:40 UTC (rev 1740)
+++ trunk/src/CacheWolf/CacheDB.java	2009-04-08 16:41:52 UTC (rev 1741)
@@ -90,7 +90,7 @@
 		CacheHolder oldObj = (CacheHolder) vectorDB.get(index);
 	    vectorDB.set(index, ch);
 	    hashDB.put(ch.getWayPoint(), this.getIntObj(ch.getWayPoint(), index));
-	    if (oldObj!=null) {
+	    if (oldObj!=null && ! oldObj.getWayPoint().equals(oldObj.getWayPoint())) {
 	    	hashDB.remove(oldObj.getWayPoint());
 	    }
     }



From engywuck at mail.berlios.de  Wed Apr  8 18:44:45 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Wed, 8 Apr 2009 18:44:45 +0200
Subject: [Cachewolf-svn] r1742 - trunk/src/CacheWolf
Message-ID: <200904081644.n38Gijhu025268@sheep.berlios.de>

Author: engywuck
Date: 2009-04-08 18:44:32 +0200 (Wed, 08 Apr 2009)
New Revision: 1742

Modified:
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myInteractivePanel.java
Log:
Removed a bucket of hashtables that were occasionally used to speed up looking for waypoint names. Performed some other tweaking related to new CacheDB.

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/CacheList.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -279,10 +279,8 @@
 			   cacheDB for each entry in cacheList, we simply compare the sort field of ch to apply.
 			*/
 			if (!ch.sort.equals(apply)) {
-				int idx=Global.getProfile().getCacheIndex(ch.getWayPoint());
-				if (idx==-1) continue;
-				ch=null;
-				ch=cacheDB.get(idx);
+				ch=cacheDB.get(ch.getWayPoint());
+				if (ch == null) continue;
 			}
 			if (ch.is_black()!=Global.getProfile().showBlacklisted()) 
 				wrongBlackStatus++;
@@ -306,9 +304,8 @@
 	public boolean addCache(String wayPoint) {
 		// Check whether this is the first cache being added
 		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; lstCaches.repaint(); }
-		int idx=Global.getProfile().getCacheIndex(wayPoint);
-		if (idx==-1) return false;
-		CacheHolder ch=Global.getProfile().cacheDB.get(idx);
+		CacheHolder ch=Global.getProfile().cacheDB.get(wayPoint);
+		if (ch == null) return false;
 		boolean cachesAdded=false;
 		// Add main cache
 		cachesAdded|=addCache(ch);
@@ -390,8 +387,6 @@
 		try {
 			FileReader in = new FileReader(fileName);
 			String wayPoint;
-			int idx;
-			CacheDB cacheDB=Global.getProfile().cacheDB;
 			int lineNr=0;
 			while ((wayPoint = in.readLine()) != null){
 				wayPoint=wayPoint.trim();
@@ -401,9 +396,9 @@
 					select=lineNr;
 				}
 				// Only add the cache if it is in this profile
-				idx=Global.getProfile().getCacheIndex(wayPoint);
-				if (idx>=0) {
-					addCache(cacheDB.get(idx));
+				CacheHolder ch=Global.getProfile().cacheDB.get(wayPoint);
+				if (ch != null) {
+					addCache(ch);
 				}
 				lineNr++;
 			}

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -31,7 +31,6 @@
 	boolean fromTC = false;
 	boolean nameFound = false;
 	int zaehlerGel = 0;
-	Hashtable DBindex = new Hashtable();
 	public static final int DOIT_ASK = 0;
 	public static final int DOIT_NOSPOILER = 1;
 	public static final int DOIT_WITHSPOILER = 2;
@@ -52,12 +51,6 @@
 		inCache = false;
 		inLogs = false;
 		inBug =false;
-		//index db for faster search
-		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size();i++){
-			ch = cacheDB.get(i);
-			DBindex.put(ch.getWayPoint(), new Integer(i));
-		}//for
 	}
 /*	skg: This Constructor is not referenced, therefore commented out 
 	public GPXImporter(Vector DB, String[] f,String d, Preferences p)
@@ -273,7 +266,7 @@
 		if (name.equals("wpt")){
 			// Add cache Data only, if waypoint not already in database
 			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
-			int index=searchWpt(chD.getWayPoint());
+			int index=cacheDB.getIndex(chD.getWayPoint());
 			//Vm.debug("here ?!?!?");
 			//Vm.debug("chould be new!!!!");
 			if (index == -1){
@@ -522,12 +515,6 @@
 	}
 	*/
 	
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)DBindex.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
 	private void spiderImagesUsingSpider(){
 		String addr;
 		String cacheText;

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -44,7 +44,6 @@
 	String file;
 	CacheHolderDetail holder;
 
-	Hashtable DBindexWpt = new Hashtable();
 	String strData = new String();
 
 	
@@ -53,11 +52,6 @@
 		profile=prof;
 		cacheDB = profile.cacheDB;
 		file = f;
-		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size();i++){
-			ch = cacheDB.get(i);
-			DBindexWpt.put(ch.getWayPoint(), new Integer(i));
-		}//for
 	}
 	
 	public void doIt() {
@@ -105,11 +99,10 @@
 
 		if (name.equals("waypoint")){
 			int index;
-			index = searchWpt(holder.getWayPoint());
+			index = cacheDB.getIndex(holder.getWayPoint());
 			if (index == -1){
 				holder.setNew(true);
 				cacheDB.add(new CacheHolder(holder));
-				DBindexWpt.put(holder.getWayPoint(), new Integer(cacheDB.size()-1));
 			}
 			// update (overwrite) data
 			else {
@@ -138,23 +131,11 @@
 		if (debugXML) Vm.debug(strData);
 	}
 
-	
-	/**
-	* Method to iterate through cache database and look for waypoint.
-	* Returns value >= 0 if waypoint is found, else -1
-	*/
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)DBindexWpt.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-
 	private CacheHolderDetail getHolder(String wpt){// See also OCXMLImporter
 		int index;
 		CacheHolderDetail ch;
 		
-		index = searchWpt(wpt);
+		index = cacheDB.getIndex(wpt);
 		if (index == -1){
 			ch = new CacheHolderDetail();
 			ch.setWayPoint(wpt);

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -46,7 +46,6 @@
 	boolean incUpdate = true; // complete or incremental Update
 	boolean ignoreDesc = false;
 	boolean askForOptions = true;
-	Hashtable DBindexWpt = new Hashtable();
 	Hashtable DBindexID = new Hashtable();
 
 	String picUrl = new String();
@@ -75,7 +74,6 @@
 		user = p.myAlias.toLowerCase();
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = cacheDB.get(i);
-			DBindexWpt.put(ch.getWayPoint(), new Integer(i));
 			if (!ch.getOcCacheID().equals(""))
 				DBindexID.put(ch.getOcCacheID(), new Integer(i));
 		}//for
@@ -429,7 +427,7 @@
 		if (name.equals("cache")){
 			chD.setLastSyncOC(dateOfthisSync.format("yyyyMMddHHmmss"));
 			int index;
-			index = searchWpt(chD.getWayPoint());
+			index = cacheDB.getIndex(chD.getWayPoint());
 			if (index == -1){
 				chD.setNew(true);
 				CacheHolder ch = new CacheHolder(chD);
@@ -437,7 +435,6 @@
 				cacheDB.add(ch);
 				ch.detailsAdded();
 				Integer indexInt = new Integer(cacheDB.size()-1);
-				DBindexWpt.put(chD.getWayPoint(), indexInt);
 				DBindexID.put(chD.getOcCacheID(), indexInt);
 			}
 			// update (overwrite) data
@@ -715,22 +712,11 @@
 	}
 
 	/**
-	 * Method to iterate through cache database and look for waypoint.
-	 * Returns value >= 0 if waypoint is found, else -1
-	 */
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)DBindexWpt.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-
-	/**
 	 * Method to iterate through cache database and look for cacheID.
 	 * Returns value >= 0 if cacheID is found, else -1
 	 */
-	private int searchID(String cacheID){
-		Integer INTR = (Integer)DBindexID.get(cacheID);
+	private int searchID(String cacxheID){
+		Integer INTR = (Integer)DBindexID.get(cacxheID);
 		if(INTR != null){
 			return INTR.intValue();
 		} else return -1;
@@ -740,7 +726,7 @@
 	private CacheHolderDetail getHolder(String wpt){// See also LOCXMLImporter
 		int index;
 		
-		index = searchWpt(wpt);
+		index = cacheDB.getIndex(wpt);
 		if (index ==-1) index = searchID(wpt);
 		if (index == -1) {
 			chD = new CacheHolderDetail();

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/Parser.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -222,9 +222,8 @@
 
 	private Object getVariable(String varName) throws Exception {
 		if (varName.startsWith("$")) { // Potential coordinate
-			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
-			if (idx!=-1) { // Found it!
-				CacheHolder ch=Global.getProfile().cacheDB.get(idx);
+			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			if (ch != null) { // Found it!
 				// Check whether coordinates are valid
 				cwPt.set(ch.pos);
 				if (cwPt.isValid() )
@@ -544,10 +543,12 @@
 		// Don't want to switch to goto panel, just set the values
 		nav.setDestination(coord);
 		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
-    		int i=Global.getProfile().getCacheIndex(waypointName);
-    		if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
     		cwPt.set(coord);
-    		CacheHolder ch=Global.getProfile().cacheDB.get(i);
+    		CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
+    		if (ch == null) {
+    			err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
+    			return;
+    		}
     		ch.LatLon=cwPt.toString(CWPoint.CW);
     		ch.pos.set(cwPt);
     		ch.calcDistance(Global.getPref().curCentrePt); // Update distance/bearing
@@ -663,11 +664,11 @@
      */
     private void funcSkeleton(int nargs) throws Exception {
    		String waypointName=Global.mainTab.lastselected;
-    	int ci=Global.getProfile().getCacheIndex(waypointName);
-    	if (ci<0) return;
+    	CacheHolder c=Global.getProfile().cacheDB.get(waypointName);
+    	if (c == null) return;
     	// If it is an addi, find its main cache
-    	if (Global.getProfile().cacheDB.get(ci).isAddiWpt()) {
-    		waypointName=Global.getProfile().cacheDB.get(ci).mainCache.getWayPoint();
+    	if (c.isAddiWpt()) {
+    		waypointName=c.mainCache.getWayPoint();
     	}
    		int nStages=-1;
     	if (nargs==1) {
@@ -707,9 +708,11 @@
 				Global.mainTab.tbP.refreshTable();
 			}
     	} else {
-	    	int i=Global.getProfile().getCacheIndex(waypointName);
-			if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
-	   	    CacheHolder ch=Global.getProfile().cacheDB.get(i);
+	   	    CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
+	   	    if (ch == null) {
+	   	    	err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
+	   	    	return;
+	   	    }
 			CacheHolder addiWpt;
 	   	    if (ch.hasAddiWpt()){
 	   	    	op.append("cls()\n");
@@ -891,9 +894,8 @@
 		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(";")) return;
 		parseStringExp();
 		if (varName.startsWith("$")) { // Potential coordinate
-			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
-			if (idx!=-1) { // Yes, is a coordinate
-				CacheHolder ch=Global.getProfile().cacheDB.get(idx);
+			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			if (ch != null) { // Yes, is a coordinate
 				// Check whether new coordinates are valid
 				String coord=popCalcStackAsString();
 				cwPt.set(coord);

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/Profile.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -371,22 +371,17 @@
 	}
 
 	/** Get a unique name for a new waypoint */
-	// TODO Make more efficient
 	public String getNewWayPointName() {
 		String strWp = null;
-		long lgWp = 1;
+		long lgWp = 0;
 		int s = cacheDB.size();
 		if (s == 0)
 			return "CW0000";
 		// Create new waypoint,look if not in db
-		for (int i = 0; i < s; i++) {
+		do {
+			lgWp++;
 			strWp = "CW" + MyLocale.formatLong(lgWp, "0000");
-			if (cacheDB.get(i).getWayPoint().indexOf(strWp) >= 0) {
-				// waypoint exists in database
-				lgWp++;
-				i = -1; // Because i++ will be executed next, so we start the loop with 0
-			}
-		}
+		} while (cacheDB.getIndex(strWp) >= 0);
 		return strWp;
 	}
 
@@ -501,31 +496,27 @@
 	 */
 	public void buildReferences(){
 		CacheHolder ch, mainCh;
-		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialise so that von rehashing is neccessary
 
-		Integer index;
 		// Build index for faster search and clear all references
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
 			ch.addiWpts.clear();
 			ch.mainCache = null;
-			// if (ch.wayPoint.startsWith("GC")) // Only put potential master caches into the index
-			dbIndex.put(ch.getWayPoint(), new Integer(i));
 		}
+		
 		// Build references
 		int max = cacheDB.size();
 		for (int i = 0; i < max; i++) {
 			ch = cacheDB.get(i);
 			if (ch.isAddiWpt()) {
 				// search main cache
-				index = (Integer) dbIndex.get("GC" + ch.getWayPoint().substring(2));
-				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
-					index = (Integer) dbIndex.get("OC"+ ch.getWayPoint().substring(2));
-				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
-					index = (Integer) dbIndex.get("CW"+ ch.getWayPoint().substring(2));
+				mainCh = cacheDB.get("GC" + ch.getWayPoint().substring(2));
+				if (mainCh == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
+					mainCh = cacheDB.get("OC" + ch.getWayPoint().substring(2));
+				if (mainCh == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
+					mainCh = cacheDB.get("CW" + ch.getWayPoint().substring(2));
 
-				if (index != null) {
-					mainCh = cacheDB.get(index.intValue());
+				if (mainCh != null) {
 					mainCh.addiWpts.add(ch);
 					ch.mainCache = mainCh;
 					ch.setAttributesFromMainCache(mainCh);

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -59,7 +59,6 @@
 	private Regex inRex = new Regex();
 	private CacheDB cacheDB;
 	private Vector cachesToLoad = new Vector();
-	private Hashtable indexDB;
 	private InfoBox infB;
 	private static myProperties p=null;
 
@@ -293,13 +292,10 @@
 		}
 		if (System.getProperty("os.name")!=null)pref.log("Operating system: "+System.getProperty("os.name")+"/"+System.getProperty("os.arch"));
 		if (System.getProperty("java.vendor")!=null)pref.log("Java: "+System.getProperty("java.vendor")+"/"+System.getProperty("java.version"));
-		// Prepare an index of caches for faster searching
-		indexDB = new Hashtable(cacheDB.size());
 		CacheHolder ch;
-		//index the database for faster searching!
+		// Reset is_new()
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = cacheDB.get(i);
-			indexDB.put(ch.getWayPoint(), new Integer(i));
 			ch.setNew(false);
 		}
 		String start = "";
@@ -367,11 +363,11 @@
 			ch = cacheDB.get(i);
 			if (spiderAllFinds) {
 				if ( (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) ) {
-					cachesToUpdate.put(ch.getWayPoint(), new Integer(i));
+					cachesToUpdate.put(ch.getWayPoint(), ch);
 				}
 			} else {
 				if ( (!ch.is_archived()) && (ch.kilom <= distanceInKm) && !(doNotgetFound && ch.is_found()) && (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) ) {
-					cachesToUpdate.put(ch.getWayPoint(), new Integer(i));
+					cachesToUpdate.put(ch.getWayPoint(), ch);
 				}
 			}
 		}
@@ -447,8 +443,8 @@
 					found_on_page++;
 					if(getDist(lineRex.stringMatched(1)) <= distance){
 						String waypoint=getWP(lineRex.stringMatched(1));
-						Integer nr;
-						if((nr=(Integer)indexDB.get(waypoint)) == null){
+						CacheHolder existingCache;
+						if((existingCache=cacheDB.get(waypoint)) == null){
 							if ( (maxNumber > 0) && (cachesToLoad.size() >= maxNumber) ) {
 								maxNumberAbort = true;
 								
@@ -462,14 +458,14 @@
 							}
 						} else {
 							pref.log(waypoint+" already in DB");
-							ch=cacheDB.get(nr.intValue());
+							ch=existingCache;
 							// If the <strike> tag is used, the cache is marked as unavailable or archived
 							boolean is_archived_GC=lineRex.stringMatched(1).indexOf("<strike><font color=\"red\">")!=-1;
 							boolean is_available_GC=lineRex.stringMatched(1).indexOf("<strike>")==-1;
 							if (ch.is_archived()!=is_archived_GC) { // Update the database with the cache status
 								pref.log("Updating status of "+waypoint+" to "+(is_archived_GC?"archived":"not archived"));
 								if ( ch.is_archived() ) {
-									cachesToUpdate.put(ch.getWayPoint(), nr);
+									cachesToUpdate.put(ch.getWayPoint(), ch);
 								}
 								ch.setArchived(is_archived_GC);
 								chD=ch.getCacheDetails(true,false);
@@ -558,7 +554,7 @@
 
 			wpt = (String)cachesToLoad.get(i);
 			// Get only caches not already available in the DB
-			if(searchWpt(wpt) == -1){
+			if(cacheDB.getIndex(wpt) == -1){
 				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + wpt +" (" + (i+1) + " / " + totalCachesToLoad + ")");
 				chD = new CacheHolderDetail();
 				chD.setWayPoint(wpt);
@@ -580,12 +576,11 @@
 		if (!infB.isClosed) {
 			int j = 1;
 			for (Enumeration e = cachesToUpdate.elements() ; e.hasMoreElements() ; j++) {
-				int i = ((Integer)e.nextElement()).intValue();
-				ch = cacheDB.get(i);
+				ch = (CacheHolder)e.nextElement();
 				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.getWayPoint() +" (" + (cachesToLoad.size()+j) + " / " + totalCachesToLoad + ")");
 				infB.redisplay();
 
-				int test = spiderSingle(i, infB,false);
+				int test = spiderSingle(cacheDB.getIndex(ch), infB,false);
 				if (test == -1) {
 					break;
 				} else if (test == 0) {
@@ -828,17 +823,6 @@
 		return ret;
 	} // getCacheByWaypointName
 
-	/**
-	 * Check whether a waypoint is in the database
-	 * @param wpt Name of waypoint to check
-	 * @return index of waypoint in database, -1 if it does not exist
-	 */
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)indexDB.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
 
 	/**
 	 * Get the Distance to the centre

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/TablePanel.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -116,7 +116,7 @@
 		// Check whether the currently selected cache is still visible
 		int rownum = 0;
 		if (wayPoint != null) {
-			rownum = Global.getProfile().getCacheIndex(wayPoint);
+			rownum = Global.getProfile().cacheDB.getIndex(wayPoint);
 			if ( (rownum < 0) || (rownum>=myMod.numRows) ) {
 				// If it is not visible: Go backward in the list of the 
 				// previously visible caches and look if you find
@@ -124,7 +124,7 @@
 				int i;
 				for (i=sel-1; i>=0; i--) {
 					CacheHolder checkCache = (CacheHolder) oldVisibleCaches.get(i);
-					rownum = Global.getProfile().getCacheIndex(checkCache.getWayPoint());
+					rownum = Global.getProfile().cacheDB.getIndex(checkCache.getWayPoint());
 					if ((rownum >= 0) && (rownum < myMod.numRows)) break;
 					rownum = 0;	
 				}

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2009-04-08 16:41:52 UTC (rev 1741)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2009-04-08 16:44:32 UTC (rev 1742)
@@ -102,13 +102,8 @@
 	
 	public void startDragging(DragContext dc) {
 		if (!Global.mainForm.cacheListVisible) return;
-		CacheDB cacheDB=Global.getProfile().cacheDB;
-//Vm.debug("myIAP startDrag "+dc.start.x+"/"+dc.start.y);
-		int idx=Global.getProfile().getCacheIndex(wayPoint); 
-		if (idx>=0) {
-			 CacheHolder ch=cacheDB.get(idx);
-			 //wayPoint=ch.wayPoint;
-			 //Vm.debug("Waypoint : "+ch.wayPoint);
+		CacheHolder ch=Global.getProfile().cacheDB.get(wayPoint); 
+		if (ch != null) {
 			 IconAndText icnDrag=new IconAndText();
 			 icnDrag.addColumn(CacheType.cache2Img(ch.getType()));
 			 icnDrag.addColumn(ch.getWayPoint());



From engywuck at mail.berlios.de  Wed Apr  8 18:51:42 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Wed, 8 Apr 2009 18:51:42 +0200
Subject: [Cachewolf-svn] r1743 - trunk/src/CacheWolf
Message-ID: <200904081651.n38GpgjX029638@sheep.berlios.de>

Author: engywuck
Date: 2009-04-08 18:51:38 +0200 (Wed, 08 Apr 2009)
New Revision: 1743

Modified:
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/NewProfileForm.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/ProfilesForm.java
Log:
Setting property FilterActive not automatically sets FilterInverted = false.

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2009-04-08 16:44:32 UTC (rev 1742)
+++ trunk/src/CacheWolf/CacheList.java	2009-04-08 16:51:38 UTC (rev 1743)
@@ -292,7 +292,6 @@
 		// The sort command places all filtered caches at the end
 		cacheDB.sort(new mySort(),false);
 		Global.getProfile().setFilterActive(Filter.FILTER_CACHELIST);
-		Global.getProfile().setFilterInverted(false);
 		updateScreen(cacheList.size()-wrongBlackStatus);
 		if (wrongBlackStatus>0)
 			(new MessageBox(MyLocale.getMsg(5500,"Error"),MyLocale.getMsg(4600,"Some cache(s) cannot be shown because of wrong blacklist status"), FormBase.OKB)).execute();

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2009-04-08 16:44:32 UTC (rev 1742)
+++ trunk/src/CacheWolf/Filter.java	2009-04-08 16:51:38 UTC (rev 1743)
@@ -356,7 +356,6 @@
 			ch.setFiltered(filterCache);			
 		}
 		Global.getProfile().setFilterActive(FILTER_ACTIVE);
-		Global.getProfile().setFilterInverted(false);
 		examinedCaches = null;
 		//Global.getProfile().hasUnsavedChanges=true;
 	}
@@ -631,8 +630,6 @@
 			ch.setFiltered((ch.is_black()^Global.getProfile().showBlacklisted())) ; // Always filter blacklisted caches
 		}
 		Global.getProfile().setFilterActive(FILTER_INACTIVE);
-		Global.getProfile().setFilterInverted(false);
-		//Global.getProfile().hasUnsavedChanges=true;
 	}
 
 	public boolean hasFilter() {

Modified: trunk/src/CacheWolf/NewProfileForm.java
===================================================================
--- trunk/src/CacheWolf/NewProfileForm.java	2009-04-08 16:44:32 UTC (rev 1742)
+++ trunk/src/CacheWolf/NewProfileForm.java	2009-04-08 16:51:38 UTC (rev 1743)
@@ -55,7 +55,6 @@
 							this.close(-1);
 						}
 						Global.getProfile().setFilterActive(Filter.FILTER_INACTIVE);
-						Global.getProfile().setFilterInverted(false);
 						this.close(0);
 					}
 				}

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-08 16:44:32 UTC (rev 1742)
+++ trunk/src/CacheWolf/Profile.java	2009-04-08 16:51:38 UTC (rev 1743)
@@ -638,6 +638,7 @@
 
 	public void setFilterActive(int filterActive) {
 		this.notifyUnsavedChanges(filterActive != this.filterActive);
+		this.setFilterInverted(false);
 		this.filterActive = filterActive;
 	}
 

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2009-04-08 16:44:32 UTC (rev 1742)
+++ trunk/src/CacheWolf/ProfilesForm.java	2009-04-08 16:51:38 UTC (rev 1743)
@@ -127,7 +127,6 @@
 			}
 			if (ev.target == btnOK || ev.target == choice){
 				Global.getProfile().setFilterActive(Filter.FILTER_INACTIVE);
-				Global.getProfile().setFilterInverted(false);
 				if (choice.getSelectedItem()!=null) {
 					newSelectedProfile=choice.getSelectedItem().toString();
 					close(1);



From silas at mail.berlios.de  Sun Apr 12 14:53:09 2009
From: silas at mail.berlios.de (silas at mail.berlios.de)
Date: Sun, 12 Apr 2009 14:53:09 +0200
Subject: [Cachewolf-svn] r1744 - in trunk: . platform-dep
	platform-dep/PNA-WinCE42 platform-dep/PocketPC2003
Message-ID: <200904121253.n3CCr96q001701@sheep.berlios.de>

Author: silas
Date: 2009-04-12 14:47:23 +0200 (Sun, 12 Apr 2009)
New Revision: 1744

Added:
   trunk/platform-dep/
   trunk/platform-dep/PNA-WinCE42/
   trunk/platform-dep/PNA-WinCE42/ewe.dll
   trunk/platform-dep/PocketPC2003/
   trunk/platform-dep/PocketPC2003/ewe.dll
Log:
added platform-dep folder with ewe.dll for PocketPC2003 and later and WinCE 4.2 and later based PNAs

Added: trunk/platform-dep/PNA-WinCE42/ewe.dll
===================================================================
(Binary files differ)


Property changes on: trunk/platform-dep/PNA-WinCE42/ewe.dll
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/platform-dep/PocketPC2003/ewe.dll
===================================================================
(Binary files differ)


Property changes on: trunk/platform-dep/PocketPC2003/ewe.dll
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From greiol at mail.berlios.de  Mon Apr 13 22:25:20 2009
From: greiol at mail.berlios.de (greiol at mail.berlios.de)
Date: Mon, 13 Apr 2009 22:25:20 +0200
Subject: [Cachewolf-svn] r1745 - trunk
Message-ID: <200904132025.n3DKPKS3022765@sheep.berlios.de>

Author: greiol
Date: 2009-04-13 22:25:19 +0200 (Mon, 13 Apr 2009)
New Revision: 1745

Modified:
   trunk/build.xml
Log:
added new ewe.dll for ppc2003 build

Modified: trunk/build.xml
===================================================================
--- trunk/build.xml	2009-04-12 12:47:23 UTC (rev 1744)
+++ trunk/build.xml	2009-04-13 20:25:19 UTC (rev 1745)
@@ -140,6 +140,7 @@
 			<fileset dir="resources/attributes-big"/>
 		</copy>
 		<antcall target="copyres"/>
+		<antcall target="copyppcdll"/>
 
 		<zip destfile="${pkg.dir}/CacheWolf-PPC2003.zip" basedir="${assemble.dir}"/>
 
@@ -232,6 +233,10 @@
 
 	</target>
 
+	<target name="copyppcdll" description="copy modified dll for PPC2003">
+		<copy todir="${assemble.dir}" file="platform-dep/PNA-WinCE42/ewe.dll" />
+	</target>
+
 	<target name="copyres" description="copy images to the assembly directory">
 		<!-- copy templates -->
 		<copy todir="${assemble.dir}">



From engywuck at mail.berlios.de  Tue Apr 14 10:29:22 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Tue, 14 Apr 2009 10:29:22 +0200
Subject: [Cachewolf-svn] r1746 - trunk/src/CacheWolf
Message-ID: <200904140829.n3E8TMBt027202@sheep.berlios.de>

Author: engywuck
Date: 2009-04-14 10:29:16 +0200 (Tue, 14 Apr 2009)
New Revision: 1746

Modified:
   trunk/src/CacheWolf/SearchCache.java
Log:
Fixing Bug: Showing Blacklist now works again, even if Filter consists only of individual marked caches.

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-13 20:25:19 UTC (rev 1745)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-14 08:29:16 UTC (rev 1746)
@@ -50,11 +50,13 @@
 	* cache database. Restore to the state of the filter
 	*/
 	public void clearSearch(){
-		Global.getProfile().selectionChanged = true;
+	    Profile profile = Global.getProfile();
+		profile.selectionChanged = true;
+		boolean filter_marked_only = profile.getFilterActive() == Filter.FILTER_MARKED_ONLY;
 		for(int i = cacheDB.size()-1;i >=0;i--){
 			CacheHolder ch=cacheDB.get(i);
 			ch.is_flaged=false;
-			//ch.setFiltered((ch.is_black()^Global.getProfile().showBlacklisted())) ;
+			if (filter_marked_only) ch.setFiltered((ch.is_black()^Global.getProfile().showBlacklisted())) ;
 		}
 		//Global.getProfile().filterActive=Filter.filterActive; //TODO This is a hack. Need to tidy this up
 		//Global.getProfile().filterInverted=Filter.filterInverted;



From engywuck at mail.berlios.de  Tue Apr 14 10:37:19 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Tue, 14 Apr 2009 10:37:19 +0200
Subject: [Cachewolf-svn] r1747 - trunk/src/CacheWolf
Message-ID: <200904140837.n3E8bJXW028918@sheep.berlios.de>

Author: engywuck
Date: 2009-04-14 10:37:14 +0200 (Tue, 14 Apr 2009)
New Revision: 1747

Modified:
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SearchCache.java
Log:
Bugfix: Clearing search now works again, even if no filter is active.

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-14 08:29:16 UTC (rev 1746)
+++ trunk/src/CacheWolf/Profile.java	2009-04-14 08:37:14 UTC (rev 1747)
@@ -332,7 +332,7 @@
 	 *  The values of Filter.isActive and Filter.isInactive are set by the filter 
 	 **/
 	void restoreFilter() {
-		restoreFilter( false );		
+		restoreFilter( true );		
 	}
 	
 	void restoreFilter(boolean clearIfInactive) {

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-14 08:29:16 UTC (rev 1746)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-14 08:37:14 UTC (rev 1747)
@@ -60,6 +60,6 @@
 		}
 		//Global.getProfile().filterActive=Filter.filterActive; //TODO This is a hack. Need to tidy this up
 		//Global.getProfile().filterInverted=Filter.filterInverted;
-		Global.getProfile().restoreFilter();
+		profile.restoreFilter();
 	}
 }



From engywuck at mail.berlios.de  Fri Apr 17 18:41:41 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 18:41:41 +0200
Subject: [Cachewolf-svn] r1748 - in trunk/src: CacheWolf CacheWolf/navi exp
Message-ID: <200904171641.n3HGffQc014214@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 18:41:09 +0200 (Fri, 17 Apr 2009)
New Revision: 1748

Modified:
   trunk/src/CacheWolf/Attributes.java
   trunk/src/CacheWolf/CacheDB.java
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/DescriptionPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/NewProfileWizard.java
   trunk/src/CacheWolf/NotesScreen.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/ShowCacheInBrowser.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/CWGPSPoint.java
   trunk/src/exp/ASCExporter.java
   trunk/src/exp/ExploristExporter.java
   trunk/src/exp/Exporter.java
   trunk/src/exp/GPXExporter.java
   trunk/src/exp/HTMLExporter.java
   trunk/src/exp/KMLExporter.java
   trunk/src/exp/LocExporter.java
   trunk/src/exp/MSARCSVExporter.java
   trunk/src/exp/OVLExporter.java
   trunk/src/exp/OziExporter.java
   trunk/src/exp/PCX5Exporter.java
   trunk/src/exp/TPLExporter.java
Log:
Introducing new data model for CacheHolder/CacheHolderDetails. For most important changes see http://www.geoclub.de/viewtopic.php?f=40&t=33289.

Modified: trunk/src/CacheWolf/Attributes.java
===================================================================
--- trunk/src/CacheWolf/Attributes.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/Attributes.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -16,7 +16,7 @@
 	public long attributesYes;
 	public long attributesNo;
 
-	public Attributes(){ 
+	public Attributes(){ // Just a public constructor
 	}
 	
 	/**
@@ -40,7 +40,8 @@
     // Attribute set functions
     ////////////////////////////////////////////////
 	
-	public void XmlAttributesStart() {}
+	public void XmlAttributesStart() { // Any reason for this?		
+	}  
 	public void XmlAttributesEnd(String elem){
 		clear();
 		Extractor ex=new Extractor(elem,"<ATT>","</ATT>",0,true);
@@ -51,7 +52,8 @@
 		}
 	}
 
-	public void XmlAttributeStart(){}
+	public void XmlAttributeStart(){  // Any reason for this?
+	}
 	public void XmlAttributeEnd(String elem){
 		add(elem);
 	}

Modified: trunk/src/CacheWolf/CacheDB.java
===================================================================
--- trunk/src/CacheWolf/CacheDB.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/CacheDB.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -126,11 +126,13 @@
     }
 
 	/** Removes a CacheHolder object at the specified position in the cache list. The following
-	 * elements are renumbered.
+	 * elements are renumbered.<br>
+	 * Additionally the cache details are unloaded and saved to file, if necessary.
 	 * @param index The index of element to remove
 	 */
 	public void removeElementAt(int index) {
 		CacheHolder ch = this.get(index);
+		ch.releaseCacheDetails();
 	    vectorDB.removeElementAt(index);
 	    hashDB.remove(ch.getWayPoint());
 	    // When one element has been removed, we have to update the index

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -1,13 +1,23 @@
 package CacheWolf;
 
+import utils.FileBugfix;
 import CacheWolf.navi.Metrics;
 
 import com.stevesoft.ewe_pat.Regex;
 
+import ewe.filechooser.FileChooser;
+import ewe.filechooser.FileChooserBase;
+import ewe.io.BufferedWriter;
+import ewe.io.File;
+import ewe.io.FileNotFoundException;
+import ewe.io.FileReader;
+import ewe.io.FileWriter;
 import ewe.io.IOException;
+import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
+import ewe.ui.InputBox;
 import ewe.ui.MessageBox;
 import ewe.util.Vector;
 
@@ -114,129 +124,162 @@
 	private long attributesYes = 0;
 	private long attributesNo  = 0;
 
-	
-//	static int nObjects=0;
-	public CacheHolder() {//nObjects++;Vm.debug("CacheHolder() nO="+nObjects);
-	}
-
-	public CacheHolder(CacheHolder ch) {//nObjects++;Vm.debug("CacheHolder(ch) nO="+nObjects);
-		update(ch);
-	}
-
-	static char decSep,notDecSep;
+		static char decSep,notDecSep;
 	static {
 		decSep=MyLocale.getDigSeparator().charAt(0);
 		notDecSep=decSep=='.'?',':'.';
 	}
 
+	public CacheHolder() {  // Just a public constructor
+	}
+	
 	public CacheHolder(String xmlString) {
 		int start,end;
-		try {
-			start=xmlString.indexOf('"'); end=xmlString.indexOf('"',start+1);
-			setCacheName(SafeXML.cleanback(xmlString.substring(start+1,end)));
-			
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-            setCacheOwner(SafeXML.cleanback(xmlString.substring(start+1,end)));
-			// Assume coordinates are in decimal format
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			double lat=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
+		if (xmlString.length() <= 10) {
+			this.wayPoint = xmlString;
+		} else	
+	        try {
+		        start = xmlString.indexOf('"');
+		        end = xmlString.indexOf('"', start + 1);
+		        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			double lon=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
-			pos=new CWPoint(lat,lon);
-			LatLon=pos.toString();
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+		        // Assume coordinates are in decimal format
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
+		                notDecSep, decSep));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setDateHidden(xmlString.substring(start+1,end)); 
-			// Convert the US format to YYYY-MM-DD if necessary
-			if (getDateHidden().indexOf('/')>-1) setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
+		                notDecSep, decSep));
+		        pos = new CWPoint(lat, lon);
+		        LatLon = pos.toString();
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setWayPoint(SafeXML.cleanback(xmlString.substring(start+1,end)));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setDateHidden(xmlString.substring(start + 1, end));
+		        // Convert the US format to YYYY-MM-DD if necessary
+		        if (getDateHidden().indexOf('/') > -1)
+			        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setCacheStatus(xmlString.substring(start+1,end));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setType(new Integer(xmlString.substring(start+1,end)).intValue());
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setCacheStatus(xmlString.substring(start + 1, end));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setHard(xmlString.substring(start+1,end));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setType(new Integer(xmlString.substring(start + 1, end)).intValue());
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setTerrain(xmlString.substring(start+1,end));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setHard(xmlString.substring(start + 1, end));
 
-			// The next item was 'dirty' but this is no longer used.
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setFiltered(xmlString.substring(start+1,end).equals("true")); 
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setTerrain(xmlString.substring(start + 1, end));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setCacheSize(xmlString.substring(start+1,end));
+		        // The next item was 'dirty' but this is no longer used.
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setFiltered(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setAvailable(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setCacheSize(xmlString.substring(start + 1, end));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setArchived(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setAvailable(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setHas_bugs(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setArchived(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setBlack(xmlString.substring(start+1,end).equals("true"));
-			if(is_black()!=Global.getProfile().showBlacklisted()) setFiltered(true);
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setHas_bugs(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setOwned(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setBlack(xmlString.substring(start + 1, end).equals("true"));
+		        if (is_black() != Global.getProfile().showBlacklisted())
+			        setFiltered(true);
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setFound(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setOwned(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setNew(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setFound(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setLog_updated(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setNew(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setUpdated(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setLog_updated(xmlString.substring(start + 1, end).equals("true"));
 
-			// for backwards compatibility set value to true, if it is not in the file
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setHTML(!xmlString.substring(start+1,end).equals("false"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setUpdated(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setNoFindLogs(Convert.toInt(xmlString.substring(start+1,end)));
+		        // for backwards compatibility set value to true, if it is not in the file
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setHTML(!xmlString.substring(start + 1, end).equals("false"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setOcCacheID(xmlString.substring(start+1,end));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setNoFindLogs(Convert.toInt(xmlString.substring(start + 1, end)));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setIncomplete(xmlString.substring(start+1,end).equals("true"));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setOcCacheID(xmlString.substring(start + 1, end));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setLastSyncOC(xmlString.substring(start+1,end));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setIncomplete(xmlString.substring(start + 1, end).equals("true"));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setNumRecommended(Convert.toInt(xmlString.substring(start+1,end)));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setLastSyncOC(xmlString.substring(start + 1, end));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start+1,end)));
-			recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
 
-			start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-			if (start > -1 && end > -1) {
-				setAttributesYes(Convert.parseLong(xmlString.substring(start+1,end)));
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+		        recommendationScore = LogList.getScore(getNumRecommended(),
+		                getNumFoundsSinceRecommendation());
 
-				start=xmlString.indexOf('"',end+1); end=xmlString.indexOf('"',start+1);
-				if (start > -1 && end > -1)
-					setAttributesNo(Convert.parseLong(xmlString.substring(start+1,end)));
-			}
-		} catch (Exception ex) {
+		        start = xmlString.indexOf('"', end + 1);
+		        end = xmlString.indexOf('"', start + 1);
+		        if (start > -1 && end > -1) {
+			        setAttributesYes(Convert.parseLong(xmlString.substring(start + 1, end)));
 
-		}
-	}
+			        start = xmlString.indexOf('"', end + 1);
+			        end = xmlString.indexOf('"', start + 1);
+			        if (start > -1 && end > -1)
+				        setAttributesNo(Convert.parseLong(xmlString.substring(start + 1, end)));
+		        }
+	        } catch (Exception ex) {
 
+	        }
+        }
+	
+
 	/**
 	 * Returns the distance in formatted output. Using kilometers when metric system is active,
 	 * using miles when imperial system is active.
@@ -279,6 +322,15 @@
 	public void update(CacheHolder ch) {
 		update(ch, false);
 	}
+	/** 
+	 * Updates Cache information with information provided by cache given as argument. This is used
+	 * to update the cache with the information retrieved from files or web: The argument cache
+	 * is the one that is filled with the read information, <code>this</code> is the cache that
+	 * is already in the database and subject to update. 
+	 * @param ch The cache who's information is updating the current one
+	 * @param overwrite If <code>true</code>, then <i>status</i>, <i>is_found</i> and <i>position</i>
+	 * is updated, otherwise not.
+	 */
 	public void update(CacheHolder ch, boolean overwrite) {
 		this.recommendationScore = ch.recommendationScore;
 		this.setNumFoundsSinceRecommendation(ch.getNumFoundsSinceRecommendation());
@@ -342,41 +394,41 @@
 
 		this.setAttributesYes(ch.getAttributesYes());
 		this.setAttributesNo(ch.getAttributesNo());
+		if (ch.detailsLoaded()) {
+			this.getFreshDetails().update(ch.getFreshDetails());
+		}	
 	}
 	/**
 	 * Call it only when necessary, it takes time, because all logs must be parsed
-	 *
 	 */
 	public void calcRecommendationScore() {
-		if (getWayPoint().toLowerCase().startsWith("oc") ) {
-			CacheHolderDetail chD;
-			if (this instanceof CacheHolderDetail)	chD = (CacheHolderDetail)this;
-			else chD = getCacheDetails(true, false);
-			if (chD != null) {
-				chD.CacheLogs.calcRecommendations();
-				recommendationScore = chD.CacheLogs.recommendationRating;
-				setNumFoundsSinceRecommendation(chD.CacheLogs.foundsSinceRecommendation);
-				setNumRecommended(chD.CacheLogs.numRecommended);
-			} else { // cache doesn't have details
-				recommendationScore = -1;
-				setNumFoundsSinceRecommendation(-1);
-				setNumRecommended(-1);
+		if (getWayPoint().toLowerCase().startsWith("oc")) {
+			// Calculate recommendation score only when details
+			// are already loaded. When they aren't loaded, then we assume
+			// that there is no change, so nothing to do.
+			if (this.detailsLoaded()) {
+				CacheHolderDetail chD = getCacheDetails(true, false);
+				if (chD != null) {
+					chD.CacheLogs.calcRecommendations();
+					recommendationScore = chD.CacheLogs.recommendationRating;
+					setNumFoundsSinceRecommendation(chD.CacheLogs.foundsSinceRecommendation);
+					setNumRecommended(chD.CacheLogs.numRecommended);
+				} else { // cache doesn't have details
+					recommendationScore = -1;
+					setNumFoundsSinceRecommendation(-1);
+					setNumRecommended(-1);
+				}
 			}
 		} else {
 			recommendationScore = -1;
 			setNumFoundsSinceRecommendation(-1);
 			setNumRecommended(-1);
 		}
-		if (details != null) {
-		details.recommendationScore = recommendationScore;
-		details.setNumFoundsSinceRecommendation(getNumFoundsSinceRecommendation());
-		details.setNumRecommended(getNumRecommended());
-		}
 	}
 	
 	/** Return a XML string containing all the cache data for storing in index.xml */
 	public String toXML() {
-		if (this instanceof CacheHolderDetail || (details != null && details.hasUnsavedChanges)) calcRecommendationScore(); 
+		calcRecommendationScore(); 
 		sb.delete(0,sb.length());
 		sb.append("    <CACHE ");
 		sb.append(" name = \"");        sb.append(SafeXML.clean(getCacheName()));
@@ -440,7 +492,8 @@
 			bearing = NOBEARING;
 		}
 	}
-	public void setAttributesFromMainCache(CacheHolder mainCh){
+	public void setAttributesFromMainCache(){
+		CacheHolder mainCh = this.mainCache;
 		this.setCacheOwner(mainCh.getCacheOwner());
 		this.setCacheStatus(mainCh.getCacheStatus());
 		this.setArchived(mainCh.is_archived());
@@ -456,7 +509,7 @@
 			CacheHolder addiWpt;
 			for (int i= this.addiWpts.getCount() - 1;  i>=0; i--){
 				addiWpt = (CacheHolder) this.addiWpts.get(i);
-				addiWpt.setAttributesFromMainCache(this);
+				addiWpt.setAttributesFromMainCache();
 			}
 		}
 	}
@@ -472,17 +525,17 @@
 		if ((!this.isAddiWpt()) && (!ch.isAddiWpt())) return false;
 		CacheHolder main1, main2;
 		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
-		if (ch instanceof CacheHolderDetail) {
-			if (ch.isAddiWpt()) 
-				main2=ch.mainCache;
-			else 
-				return main1.getWayPoint().equals(ch.getWayPoint());
-		} else { // ch instanceof CacheHolder 
-			if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
-		}
+		if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
 		return main1 == main2;
 	}
 
+	/** Find out of detail object of Cache is loaded. Returns <code>true</code> if this is the case.
+	 * @return True when details object is present
+	 */
+	public boolean detailsLoaded() {
+		return details!=null;
+	}
+	
 	/** 
 	 * Call this method to get the long-description and so on.
 	 * If the according .xml-file is already read, it will return
@@ -495,93 +548,122 @@
 		return getCacheDetails(maybenew, true);
 	}
 	
-	/** 
-	 * Call this method to get the long-description and so on.
-	 * If the according .xml-file is already read, it will return
-	 * that one, otherwise it will be loaded.
-	 * To avoid memory problems this routine loads not for more caches than maxDetails
-	 * the details. If maxdetails is reached, it will remove from RAM the details 
-	 * of the 5 caches that were loaded most long ago.
+	/**
+	 * Gets the detail object of a cache. The detail object stores information which is not needed
+	 * for every cache instantaneously, but can be loaded if the user decides to look at this cache.
+	 * If the cache object is already existing, the method will return this object, otherwise it 
+	 * will create it and try to read it from the corresponding <waypoint>.xml file.
+	 * Depending on the parameters it is allowed that the <waypoint>.xml file does not yet exist,
+	 * or the user is warned that the file doesn't exist.
+	 * If more than <code>maxdetails</code> details are loaded, then the 5 last recently loaded 
+	 * caches are unloaded (to save ram). 
 	 * 
-	 * @param alarmuser if true an error message will be displayed to the user, if the details could not be read
-	 * @return the respective CacheHolderDetail, null if according xml-file could not be read
+	 * @param maybenew
+	 * 			  If true and the cache file could not be read, then an empty detail object is 
+	 *            returned.
+	 * @param alarmuser
+	 *            If true an error message will be displayed to the user, if the details could not
+	 *            be read, and the method returns null 
+	 * @return The respective CacheHolderDetail, or null
 	 */
-		
+
 	public CacheHolderDetail getCacheDetails(boolean maybenew, boolean alarmuser) {
-		if (details != null) {
-			if (details.hasUnsavedChanges) this.update(details);
-			else details.update(this);
-			return details;
+		if (details == null) {
+
+			details = new CacheHolderDetail(this);
+			try {
+				details.readCache(Global.getProfile().dataDir);
+			} catch (IOException e) {
+				if (alarmuser && !maybenew) {
+					(new MessageBox("Error", "Could not read cache details for cache: "
+					        + this.getWayPoint(), FormBase.OKB)).execute();
+				}
+				if (!maybenew) details = null;
+			}
+			if (details != null
+					  // for importing/spidering reasons helper objects with same waypoint are created
+					&& !cachesWithLoadedDetails.contains(this.getWayPoint())
+					  // helper objects may have empty waypoint
+					&& !this.getWayPoint().equals(CacheHolder.EMPTY)) {
+				cachesWithLoadedDetails.add(this.getWayPoint());
+				if (cachesWithLoadedDetails.size() >= Global.getPref().maxDetails) removeOldestDetails();
+			}
 		}
-		// FIXME Problem: Hier wird ein neues Detail-Objekt erzeugt, welches nat?rlich noch
-		//       Default-Werte in den Feldern stehen hat. 
-		//       Das Zur?cksetzen von UnsavedChanges ist erstmal ein Hack.
-		boolean hasUnsavedChanges = Global.getProfile().hasUnsavedChanges();
-		details = new CacheHolderDetail(this);
-		try {
-			details.readCache(Global.getProfile().dataDir);
-		} catch (IOException e) {
-			if (maybenew) details.update(this);
-			else {
-				if (alarmuser) (new MessageBox("Error", "Could not read cache details for cache: "+this.getWayPoint(), FormBase.OKB)).execute();
-				return null;
-			} 
-		}
-		if (! hasUnsavedChanges) Global.getProfile().resetUnsavedChanges();
-		detailsAdded();
 		return details;
 	}
+	
+	/**
+	 * Gets a detail object for the cache. If the object is already created, then this object is
+	 * returned, otherwise it's created from the cache.xml file. If no such file is found, an empty
+	 * object is returned.
+	 * @return The object representing the cache details
+	 */
+	public CacheHolderDetail getFreshDetails() {
+		return this.getCacheDetails(true, false);
+	}
+	/**
+	 * Gets a detail object for the cache. If the object is already created, then this object is
+	 * returned, otherwise it's created from the cache.xml file. If no such file is found, an error
+	 * message is displayed and <code>null</code> is returned.
+	 * @return The object representing the cache details, or <code>null</code>.
+	 */
+	public CacheHolderDetail getExistingDetails() {
+		return this.getCacheDetails(false, true);
+	}
 
 	/**
-	 * Call this after you added the cache with details to the 
-	 * cacheDB <br> It is assumed that that details is set
-	 * for an example see OCXMLImporter.endCache()
-	 *
+	 * Saves the cache to the corresponding <waypoint>.xml file, located in the profiles
+	 * directory. The waypoint of the 
+	 * cache should be set to do so.
 	 */
-	public void detailsAdded() {
-		cachesWithLoadedDetails.add(this);
-		if (cachesWithLoadedDetails.size() >= Global.getPref().maxDetails) removeOldestDetails();
+	public void save() {
+		this.getFreshDetails().saveCacheDetails(Global.getProfile().dataDir);
 	}
-
-	public void releaseCacheDetails() {
+	
+	void releaseCacheDetails() {
 		if (details != null && details.hasUnsavedChanges){
-			//calcRecommendationScore();
 			details.saveCacheDetails(Global.getProfile().dataDir);
-			this.update(details);
 		}
 		details = null;
-		cachesWithLoadedDetails.remove(this);
+		cachesWithLoadedDetails.remove(this.getWayPoint());
 	}
 
 	//final static int maxDetails = 50; 
 	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
 
 	public static void removeOldestDetails() {
-		for (int i=0; i<Global.getPref().deleteDetails; i++)
-			((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+		for (int i=0; i<Global.getPref().deleteDetails; i++) {
+			String wp = (String) cachesWithLoadedDetails.get(i);
+			CacheHolder ch = Global.getProfile().cacheDB.get(wp);
+			if (ch!=null) ch.releaseCacheDetails();
+		}	
 	}
 
 	public static void removeAllDetails() {
-		for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--)
-			((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+		for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--) {
+			String wp = (String) cachesWithLoadedDetails.get(i);
+			CacheHolder ch = Global.getProfile().cacheDB.get(wp);
+			if (ch!=null && ch.detailsLoaded()) ch.releaseCacheDetails();
+		}
 	}
 
 	/**
 	 * when importing caches you can set details.saveChanges = true
-	 * when the import ist finished call this method to save the pending changes
-	 *
+	 * when the import is finished call this method to save the pending changes
 	 */
 	public static void saveAllModifiedDetails() {
 		CacheHolder ch;
 		CacheHolderDetail chD;
 		for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--) {
-			ch = (CacheHolder)(cachesWithLoadedDetails.get(i));
-			chD = ch.getCacheDetails(false);
-			if (chD.hasUnsavedChanges) {
-				//ch.calcRecommendationScore();
-				chD.saveCacheDetails(Global.getProfile().dataDir);
-				ch.update(chD);
-			}
+			String wp = (String) cachesWithLoadedDetails.get(i);
+			ch = Global.getProfile().cacheDB.get(wp);
+			if (ch != null) {
+	            chD = ch.getCacheDetails(false);
+	            if (chD.hasUnsavedChanges) {
+		            //ch.calcRecommendationScore();
+		            chD.saveCacheDetails(Global.getProfile().dataDir);
+	            }
+            }
 		}
 	}
 
@@ -642,9 +724,9 @@
 				base = 16;
 			}
 			
-			for ( int pos = 0; pos < rightPart.length(); pos++ ) {
+			for ( int p = 0; p < rightPart.length(); p++ ) {
 				gcId *= base;
-				gcId += sequence.indexOf(rightPart.charAt(pos));
+				gcId += sequence.indexOf(rightPart.charAt(p));
 			}
 			
 	        if ( base == 31 ) {

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -14,12 +14,16 @@
 import ewe.ui.InputBox;
 import ewe.util.Vector;
 
-public class CacheHolderDetail extends CacheHolder {
-	  public String LongDescription = EMPTY;
-	  public String LastUpdate = EMPTY;
-	  public String Hints = EMPTY;
+public class CacheHolderDetail {
+	  
+	  
+	 /** CacheHolder which holds the detail. <b>Only</b> set by CacheHolder when creating detail! **/
+	  private CacheHolder parent = null;
+	  public String LongDescription = CacheHolder.EMPTY;
+	  public String LastUpdate = CacheHolder.EMPTY;
+	  public String Hints = CacheHolder.EMPTY;
 	  public LogList CacheLogs=new LogList();
-	  public String CacheNotes = EMPTY;
+	  public String CacheNotes = CacheHolder.EMPTY;
 	  public Vector Images = new Vector();
 	  public Vector ImagesText = new Vector();
 	  public Vector ImagesInfo = new Vector();
@@ -31,26 +35,26 @@
 	  public Vector CacheIcons = new Vector();
 	  public TravelbugList Travelbugs=new TravelbugList();
 	  //public String Bugs = EMPTY; Superceded by Travelbugs
-	  public String URL = EMPTY;
-	  public String Solver = EMPTY;
-	  public String OwnLogId = EMPTY;
+	  public String URL = CacheHolder.EMPTY;
+	  public String Solver = CacheHolder.EMPTY;
+	  public String OwnLogId = CacheHolder.EMPTY;
 	  public Log OwnLog = null;
-	  public String Country = EMPTY;
-	  public String State = EMPTY;
+	  public String Country = CacheHolder.EMPTY;
+	  public String State = CacheHolder.EMPTY;
 	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
 	   * If you want to save the changes automatically when the details are unloaded, set this to true */ 
 	  public boolean hasUnsavedChanges = false;
 	  
-	 public CacheHolderDetail() {
-	 }
-	 //public CacheHolderDetail(String wpt) {super(wpt); }
 	 public CacheHolderDetail(CacheHolder ch) {
-		 super(ch);
+		 parent = ch;
 	 }
 
+	 public CacheHolder getParent() {
+		 return parent;
+	 }
 	 public void setLongDescription(String longDescription) {
-	 	if (LongDescription.equals("")) setNew(true);
-	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) setUpdated(true);
+	 	if (LongDescription.equals("")) getParent().setNew(true);
+	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) getParent().setUpdated(true);
 	 	LongDescription = longDescription;
 	 }
 	 
@@ -64,17 +68,17 @@
 	 }
 	 
 	 public void setHints(String hints) {
-	 	if (!Hints.equals(hints)) setUpdated(true);
+	 	if (!Hints.equals(hints)) getParent().setUpdated(true);
 	 	Hints = hints;
 	 }
 	 
 	 public void setCacheLogs(LogList newLogs) {
 		 int size=newLogs.size();
 		 for (int i=size-1; i>=0; i--) { // Loop over all new logs, must start with oldest log
-			 if (CacheLogs.merge(newLogs.getLog(i))>=0) this.setLog_updated(true);
+			 if (CacheLogs.merge(newLogs.getLog(i))>=0) getParent().setLog_updated(true);
 		 }
 		 //CacheLogs=logs;
-		 setNoFindLogs(CacheLogs.countNotFoundLogs());
+		 getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
 	 }
 
 	 
@@ -85,13 +89,12 @@
 	 * @return CacheHolder with updated data
 	 */
 	public CacheHolderDetail update(CacheHolderDetail newCh){
-		  super.update(newCh);
 		  // flags
-		  if (this.is_found() && this.getCacheStatus().equals("")) this.setCacheStatus(MyLocale.getMsg(318,"Found"));
+		  if (getParent().is_found() && getParent().getCacheStatus().equals("")) getParent().setCacheStatus(MyLocale.getMsg(318,"Found"));
 
 		  //travelbugs:GPX-File contains all actual travelbugs but not the missions
 		  //  we need to check whether the travelbug is already in the existing list
-		  this.setHas_bugs(newCh.Travelbugs.size()>0);
+		  getParent().setHas_bugs(newCh.Travelbugs.size()>0);
 		  for (int i=newCh.Travelbugs.size()-1; i>=0; i--) {
 			 Travelbug tb=newCh.Travelbugs.getTB(i);  
 		     Travelbug oldTB=this.Travelbugs.find(tb.getName());
@@ -105,6 +108,11 @@
 		  // URL
 		  this.URL = newCh.URL;
 		  
+		  // Images
+		  this.Images = newCh.Images;
+		  this.ImagesInfo = newCh.ImagesInfo;
+		  this.ImagesText = newCh.ImagesText;
+		  
 		  setLongDescription(newCh.LongDescription);
 		  setHints(newCh.Hints);
 		  setCacheLogs(newCh.CacheLogs);
@@ -135,7 +143,7 @@
 				imgDesc = new InputBox("Description").input("",10);
 				//Create Destination Filename
 				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf("."));
-				imgDestName = this.getWayPoint() + "_U_" + (this.UserImages.size()+1) + ext;
+				imgDestName = getParent().getWayPoint() + "_U_" + (this.UserImages.size()+1) + ext;
 				
 				this.UserImages.add(imgDestName);
 				this.UserImagesText.add(imgDesc);
@@ -152,14 +160,19 @@
 		*	It fills information on cache details, hints, logs, notes and
 		*	images.
 		*/
-		public void readCache(String dir) throws IOException{
+		void readCache(String dir) throws IOException{
 			String dummy;
 			FileReader in = null;
-			if (new FileBugfix(dir + getWayPoint().toLowerCase() + ".xml").exists()) in = new FileReader(dir+getWayPoint().toLowerCase() + ".xml");
+			// If parent cache has empty waypoint then don't do anything. This might happen
+			// when a cache object is freshly created to serve as container for imported data
+			if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY)) return;
+			
+			if (new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml").exists()) in = new FileReader(dir+getParent().getWayPoint().toLowerCase() + ".xml");
 			if (in == null) {
-				if (new FileBugfix(dir + getWayPoint() + ".xml").exists()) in = new FileReader(dir+getWayPoint() + ".xml");
+				if (new FileBugfix(dir + getParent().getWayPoint() + ".xml").exists()) in = new FileReader(dir+getParent().getWayPoint() + ".xml");
 			}
-			if (in == null) throw new FileNotFoundException(dir+getWayPoint().toLowerCase()+".xml");
+			if (in == null) throw new FileNotFoundException(dir+getParent().getWayPoint().toLowerCase()+".xml");
+			Global.getPref().log("Reading file "+getParent().getWayPoint() + ".xml");
 			String text= in.readAll();
 			in.close();
 			Extractor ex = new Extractor(text, "<DETAILS><![CDATA[", "]]></DETAILS>", 0, true);		
@@ -267,8 +280,8 @@
 				URL = dummy;
 			}
 			else {
-				if (getWayPoint().startsWith("GC")) {
-					URL = "http://www.geocaching.com/seek/cache_details.aspx?wp="+ getWayPoint() + "&Submit6=Find&log=y";
+				if (getParent().getWayPoint().startsWith("GC")) {
+					URL = "http://www.geocaching.com/seek/cache_details.aspx?wp="+ getParent().getWayPoint() + "&Submit6=Find&log=y";
 				}
 			}
 			ex = new Extractor(text, "<SOLVER><![CDATA[", "]]></SOLVER>", 0, true);
@@ -280,28 +293,29 @@
 		*/
 		public void saveCacheDetails(String dir){
 			PrintWriter detfile;
+			
 			//File exists?
-			boolean exists = (new File(dir + getWayPoint() + ".xml")).exists();
+			boolean exists = (new File(dir + getParent().getWayPoint() + ".xml")).exists();
 			//yes: then delete
 			if (exists) {
-				boolean ok = (new File(dir + getWayPoint() + ".xml")).delete();
+				boolean ok = (new File(dir + getParent().getWayPoint() + ".xml")).delete();
 				if(ok) ok = true;
 			}
-			boolean exists2 = (new File(dir + getWayPoint().toLowerCase() + ".xml")).exists();
+			boolean exists2 = (new File(dir + getParent().getWayPoint().toLowerCase() + ".xml")).exists();
 			//yes: delete
 			if (exists2) {
-				boolean ok2 = (new File(dir + getWayPoint().toLowerCase() + ".xml")).delete();
+				boolean ok2 = (new File(dir + getParent().getWayPoint().toLowerCase() + ".xml")).delete();
 				if(ok2) ok2=true;
 			}
 			//Vm.debug("Writing to: " +dir + "for: " + wayPoint);
 			try{
-			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dir + getWayPoint().toLowerCase() + ".xml")));
+			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dir + getParent().getWayPoint().toLowerCase() + ".xml")));
 			} catch (Exception e) {
 				Global.getPref().log("Problem creating details file",e,true);
 				return;
 			}
 			try{
-				if(getWayPoint().length()>0){
+				if(getParent().getWayPoint().length()>0){
 				  detfile.print("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n");
 				  detfile.print("<CACHEDETAILS>\r\n");
 				  detfile.print("<DETAILS><![CDATA["+LongDescription+"]]></DETAILS>\r\n");
@@ -362,37 +376,22 @@
 				  detfile.print(Travelbugs.toXML());
 				  detfile.print("<URL><![CDATA["+URL+"]]></URL>\r\n");
 				  detfile.print("<SOLVER><![CDATA["+Solver+"]]></SOLVER>\r\n");
-				  detfile.print(toXML()); // This will allow restoration of index.xml
+				  detfile.print(getParent().toXML()); // This will allow restoration of index.xml
 				  detfile.print("</CACHEDETAILS>\n");
+				  Global.getPref().log("Writing file: "+getParent().getWayPoint().toLowerCase() + ".xml");
 				} // if length
 			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + getWayPoint() + " writing to a details file: " + e.getMessage());
+				Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: " + e.getMessage());
 			}
 			try{
 			  detfile.close();
 			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + getWayPoint() + " writing to a details file: " + e.getMessage());
+				Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: " + e.getMessage());
 			}
 			hasUnsavedChanges = false;
 		}
-		
+				
 		/**
-		 * Method for checking if to caches belongs to each other, e.g.
-		 * an additional waypoint belongs to the main cache.
-		 * Works currently only, if the last 4 or 5 chars of the waypoint are
-		 * the same, this is the gc.com way. 
-		 * @param ch cache to check
-		 * @return true if there is a relation, false otherwise
-		 */
-		public boolean belongsTo (CacheHolder ch) {
-			
-			// avoid self referencing
-			if (this.getWayPoint().equals(ch.getWayPoint())) return false;
-
-			return this.getWayPoint().endsWith(ch.getWayPoint().substring(2));
-		}
-		
-		/**
 		 * Return true if this cache has additional info for some pictures
 		 * @return true if cache has additional info, false otherwise
 		 */
@@ -408,3 +407,5 @@
 //	   }
 
 }
+
+

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/DataMover.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -194,9 +194,8 @@
 			 this.title=title;
 		 }
 		 public void doIt(int i,CacheHolder srcHolder) {
-			srcHolder.releaseCacheDetails();
-			deleteCacheFiles(srcHolder.getWayPoint(),profile.dataDir);
-			srcDB.removeElementAt(i);
+			 srcDB.removeElementAt(i);
+			 deleteCacheFiles(srcHolder.getWayPoint(),profile.dataDir);
 		 }
 	}
 	 
@@ -206,19 +205,16 @@
 			 this.dstProfile=dstProfile;
 		 }
 		 public void doIt(int i,CacheHolder srcHolder) {
-				srcHolder.releaseCacheDetails();
+				srcHolder.save();
+				deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
+				copyCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
 				// does cache exists in destDB ?
+				// Update database
 				int dstPos = dstProfile.getCacheIndex(srcHolder.getWayPoint());
 				if (dstPos >= 0){
-					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
-					copyCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
-					// Update database
 					dstProfile.cacheDB.set(dstPos,srcHolder);
 				}
 				else {
-					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
-					copyCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
-					// Update database
 					dstProfile.cacheDB.add(srcHolder);
 				}
 			 }		 
@@ -230,25 +226,20 @@
 				 this.dstProfile=dstProfile;
 			 }
 			 public void doIt(int i,CacheHolder srcHolder) {
+				 srcDB.removeElementAt(i);
+				 deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
+				 moveCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
 				// does cache exists in destDB ?
-				srcHolder.releaseCacheDetails();
+				 // Update database
 				int dstPos = dstProfile.getCacheIndex(srcHolder.getWayPoint());
 				if (dstPos >= 0){
-					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
-					moveCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
-					// Update database
 					dstProfile.cacheDB.set(dstPos,srcHolder);
-					srcDB.removeElementAt(i);
-					i--;
 				}
 				else {
-					deleteCacheFiles(srcHolder.getWayPoint(), dstProfile.dataDir);
-					moveCacheFiles(srcHolder.getWayPoint(),profile.dataDir, dstProfile.dataDir);
 					// Update database
 					dstProfile.cacheDB.add(srcHolder);
-					srcDB.removeElementAt(i);
-					i--;
 				}
+				i--;
 			 }		 
 		}
 	}

Modified: trunk/src/CacheWolf/DescriptionPanel.java
===================================================================
--- trunk/src/CacheWolf/DescriptionPanel.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/DescriptionPanel.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -15,7 +15,7 @@
 public class DescriptionPanel extends CellPanel{
 	HtmlDisplay disp = new HtmlDisplay();
 	mButton btnPlus, btnMinus;
-	CacheHolderDetail currCache;
+	CacheHolder currCache;
 	
 	CellPanel buttonP = new CellPanel();
 	CellPanel descP = new CellPanel();
@@ -37,7 +37,7 @@
          * Set the text to display. Text should be HTML formated.
          */
     // String description = null;
-    public void setText(CacheHolderDetail cache) {
+    public void setText(CacheHolder cache) {
         boolean isHtml;
         if (currCache == cache) return;
         int scrollto = 0;
@@ -49,16 +49,15 @@
                 scrollto = disp.getTopLine();
             isHtml = cache.is_HTML();
             if (cache.isAddiWpt()) {
-                CacheHolderDetail mainCache = cache.mainCache.getCacheDetails(true);
-                isHtml = mainCache.is_HTML();
-                if (cache.LongDescription != null && cache.LongDescription.length() > 0)
-                    desc = cache.LongDescription + (isHtml ? "<hr>\n" : "\n")
-                            + mainCache.LongDescription;
+                isHtml = cache.mainCache.is_HTML();
+                if (cache.getExistingDetails().LongDescription != null && cache.getExistingDetails().LongDescription.length() > 0)
+                    desc = cache.getExistingDetails().LongDescription + (isHtml ? "<hr>\n" : "\n")
+                            + cache.mainCache.getExistingDetails().LongDescription;
                 else
-                    desc = mainCache.LongDescription;
+                    desc = cache.mainCache.getExistingDetails().LongDescription;
             } else
                 // not an addi-wpt
-                desc = cache.LongDescription;
+                desc = cache.getExistingDetails().LongDescription;
         }
         // HtmlDisplay does not show the <sup> tag correctly, so we need to replace with ^
         if (desc.indexOf("<sup>")>=0) {
@@ -70,13 +69,13 @@
             int imageNo = 0;
             if (Global.getPref().descShowImg) {
                 Vector Images;
-                CacheHolderDetail chDimages; // cache which supplies the images (could be main cache)
+                CacheHolder chImages; // cache which supplies the images (could be main cache)
                 if (cache.isAddiWpt()) {
-                    chDimages=cache.mainCache.getCacheDetails(true);
+                    chImages=cache.mainCache;
                 } else {
-                    chDimages=cache;
+                    chImages=cache;
                 }
-            	Images = chDimages.Images;
+            	Images = chImages.getExistingDetails().Images;
                 StringBuffer s = new StringBuffer(desc.length() + Images.size() * 100);
                 int start = 0;
                 int pos;
@@ -110,7 +109,7 @@
                     s.append(desc.substring(start));
                 desc = s.toString();
                 if (imageNo<Images.getCount()) {
-                    desc += getPicDesc(imageNo, chDimages);
+                    desc += getPicDesc(imageNo, chImages.getExistingDetails());
                 }
             }
             //disp.setHtml(desc);
@@ -156,18 +155,6 @@
 		currCache = null;
 	}
 	
-	// Probably not needed anymore (Change in Rev. 1395)
-	private void redraw() {
-		int currLine;
-
-		Vm.showWait(true);
-		currLine = disp.getTopLine();
-		if (currCache.is_HTML())	disp.setHtml(desc);
-		else				disp.setPlainText(currCache.LongDescription);
-		disp.scrollTo(currLine,false);
-		Vm.showWait(false);
-	}
-	
 	/**
 	 * Eventhandler
 	 */

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/DetailsPanel.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -221,7 +221,7 @@
 		lblTerr.setText((ch.getTerrain().length()>0) ? (MyLocale.getMsg(1001,"T")+": "+ch.getTerrain()) : "");
 		lblDiff.setText((ch.getHard().length()>0)    ? (MyLocale.getMsg(1000,"D")+": "+ch.getHard()) : ""); 
 
-		if(isBigScreen)	mNotes.setText(ch.details.CacheNotes);
+		if(isBigScreen)	mNotes.setText(ch.getExistingDetails().CacheNotes);
 	}
 	
 	
@@ -377,7 +377,7 @@
 				else 	note = note + dtm.toString();
 				note = note + "\n";
 				thisCache.getCacheDetails(true).CacheNotes = note;
-				thisCache.getCacheDetails(true).saveCacheDetails( Global.getProfile().dataDir);
+				thisCache.save();
 			}
 			else if (ev.target == btnAddPicture){
 				thisCache.getCacheDetails(true).addUserImage(profile);
@@ -536,14 +536,9 @@
 		  // set status also on addi wpts
 		  ch.setAttributesToAddiWpts();
 		  dirty_notes=false;
-		  // if (dirty_details) { Global.getProfile().hasUnsavedChanges=true;}
 		  dirty_details=false;
 		  setNeedsTableUpdate(false);
-		  if (thisCache.details != null) thisCache.details.hasUnsavedChanges = false;
-		  thisCache.getCacheDetails(true).hasUnsavedChanges = true;
-		  
-		  // Global.mainTab.tbP.refreshTable(); this is done in mainTab.onLeavingPanel
-		  ////Vm.debug("New status updated!");
+		  thisCache.getFreshDetails().hasUnsavedChanges = true;
 	}
 
 	private class TravelbugInCacheScreen extends Form {

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -18,7 +18,7 @@
 	static Preferences pref;
 	Profile profile;
 	CacheDB cacheDB;
-	CacheHolderDetail chD;
+	CacheHolder holder;
 	String strData, saveDir, logData, logIcon, logDate, logFinder, logId;
 	boolean inWpt, inCache, inLogs, inBug;
 	public XMLElement document;
@@ -156,9 +156,9 @@
 			zaehlerGel = 0;
 		}
 		if (name.equals("wpt")) {
-			chD = new CacheHolderDetail();
-			chD.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
-			chD.LatLon=chD.pos.toString();
+			holder = new CacheHolder();
+			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
+			holder.LatLon=holder.pos.toString();
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
@@ -169,14 +169,14 @@
 		}
 		
 		if (name.equals("link")&& inWpt){
-			chD.URL = atts.getValue("href");
+			holder.getFreshDetails().URL = atts.getValue("href");
 			return;
 		}
 
 		if (name.equals("groundspeak:cache")) {
 			inCache = true;
-			chD.setAvailable(atts.getValue("available").equals("True"));
-			chD.setArchived(atts.getValue("archived").equals("True"));
+			holder.setAvailable(atts.getValue("available").equals("True"));
+			holder.setArchived(atts.getValue("archived").equals("True"));
 			return;
 		}
 
@@ -190,8 +190,8 @@
 			else if (status.equals("Unavailable")) available = false;
 			else if (status.equals("Draft")) available = false;
 			else if (status.equals("Archived")) archived = true;
-			chD.setArchived(archived);
-			chD.setAvailable(available);
+			holder.setArchived(archived);
+			holder.setAvailable(available);
 			return;
 		}
 		
@@ -201,11 +201,11 @@
 
 		
 		if (name.equals("groundspeak:long_description")) {
-			chD.setHTML(atts.getValue("html").toLowerCase().equals("true"));
+			holder.setHTML(atts.getValue("html").toLowerCase().equals("true"));
 		}
 		if (name.equals("description") || name.equals("terra:description") ) {
 			//set HTML always to true if from oc.de or TC
-			chD.setHTML(true);
+			holder.setHTML(true);
 		}
 
 		if (name.equals("groundspeak:logs") || name.equals("logs") || name.equals("terra:logs")) {
@@ -251,13 +251,13 @@
 				return;
 			}
 			if (name.equals("groundspeak:log") || name.equals("log") || name.equals("terra:log") ) {
-				chD.CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
+				holder.getFreshDetails().CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
 				if((logIcon.equals("icon_smile.gif") || logIcon.equals("11.png") || logIcon.equals("icon_attended.gif")) && 
 						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && logFinder.equalsIgnoreCase(pref.myAlias2)))) {
-							chD.setCacheStatus(logDate);
-							chD.setFound(true);
-							chD.OwnLogId = logId;
-							chD.OwnLog = new Log(logIcon,logDate,logFinder,logData);
+							holder.setCacheStatus(logDate);
+							holder.setFound(true);
+							holder.getFreshDetails().OwnLogId = logId;
+							holder.getFreshDetails().OwnLog = new Log(logIcon,logDate,logFinder,logData);
 				}
 				return;
 			}
@@ -266,42 +266,42 @@
 		if (name.equals("wpt")){
 			// Add cache Data only, if waypoint not already in database
 			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
-			int index=cacheDB.getIndex(chD.getWayPoint());
+			int index=cacheDB.getIndex(holder.getWayPoint());
 			//Vm.debug("here ?!?!?");
 			//Vm.debug("chould be new!!!!");
 			if (index == -1){
-				chD.setNoFindLogs(chD.CacheLogs.countNotFoundLogs());
-				chD.setNew(true);
-				cacheDB.add(new CacheHolder(chD));
+				holder.setNoFindLogs(holder.getFreshDetails().CacheLogs.countNotFoundLogs());
+				holder.setNew(true);
+				cacheDB.add(holder);
 				// don't spider additional waypoints, so check
 				// if waypoint starts with "GC"
 				if(doSpider == true) {
-					if(spiderOK == true && chD.is_archived() == false){
-							if(chD.LatLon.length() > 1){
+					if(spiderOK == true && holder.is_archived() == false){
+							if(holder.LatLon.length() > 1){
 							if(getMaps){
-								ParseLatLon pll = new ParseLatLon(chD.LatLon,".");
+								ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 								pll.parse();
 								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
 								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 							}
 						}
-					if(chD.getWayPoint().startsWith("GC")|| fromTC) {
+					if(holder.getWayPoint().startsWith("GC")|| fromTC) {
 						//spiderImages();
 						spiderImagesUsingSpider();
 						//Rename image sources
 						String text;
 						String orig;
 						String imgName;
-						orig = chD.LongDescription;
+						orig = holder.getFreshDetails().LongDescription;
 						Extractor ex = new Extractor(orig, "<img src=\"", ">", 0, false);
 						text = ex.findNext();
 						int num = 0;
 						while(ex.endOfSearch() == false && spiderOK == true){
 							//Vm.debug("Replacing: " + text);
-							if (num >= chD.ImagesText.getCount())break;
-							imgName = (String)chD.ImagesText.get(num);
-							chD.LongDescription = replace(chD.LongDescription, text, "[[Image: " + imgName + "]]");
+							if (num >= holder.getFreshDetails().ImagesText.getCount())break;
+							imgName = (String)holder.getFreshDetails().ImagesText.get(num);
+							holder.getFreshDetails().LongDescription = replace(holder.getFreshDetails().LongDescription, text, "[[Image: " + imgName + "]]");
 							num++;
 							text = ex.findNext();
 						}
@@ -309,30 +309,22 @@
 						
 					}
 				}
-				chD.saveCacheDetails(saveDir);
+				holder.save();
 				//crw.saveIndex(cacheDB,saveDir);
 			}
 			//Update cache data
 			else {
-				//Vm.debug("it is not new!");
-				CacheHolderDetail oldCh= new CacheHolderDetail(cacheDB.get(index));
-				try {
-					//Vm.debug("Try to load");
-					oldCh.readCache(saveDir);
-					//Vm.debug("Done loading");
-				} catch (Exception e) {Vm.debug("Could not open file: " + e.toString());};
-				oldCh.update(chD);
-				oldCh.saveCacheDetails(saveDir);
-				cacheDB.set(index, new CacheHolder(oldCh));
-				//crw.saveIndex(cacheDB,saveDir);
+				CacheHolder oldCh= cacheDB.get(index);
+				oldCh.update(holder);
+				oldCh.save();
 			}
 			
 			inWpt = false;
 			return;
 		}
 		if (name.equals("sym")&& strData.endsWith("Found")) {
-			chD.setFound(true);
-			chD.setCacheStatus(MyLocale.getMsg(318,"Found"));
+			holder.setFound(true);
+			holder.setCacheStatus(MyLocale.getMsg(318,"Found"));
 			return;
 		}
 		if (name.equals("groundspeak:travelbugs")) {
@@ -342,9 +334,9 @@
 
 		if (name.equals("groundspeak:name")&& inBug) {
 			Travelbug tb=new Travelbug(strData);
-			chD.Travelbugs.add(tb);
+			holder.getFreshDetails().Travelbugs.add(tb);
 			//holder.Bugs += "<b>Name:</b> " + strData + "<br><hr>";
-			chD.setHas_bugs(true);
+			holder.setHas_bugs(true);
 			return;
 		}
 		
@@ -353,7 +345,7 @@
 			//Date = strData.substring(5,7); // month
 			//Date += "/" + strData.substring(8,10); // day
 			//Date += "/" + strData.substring(0,4); // year
-			chD.setDateHidden(strData.substring(0,10)); //Date;
+			holder.setDateHidden(strData.substring(0,10)); //Date;
 			return;
 		}
 		// cache information
@@ -362,7 +354,7 @@
 		}
 		
 		if (name.equals("name") && inWpt && !inCache) {
-			chD.setWayPoint(strData);
+			holder.setWayPoint(strData);
 			//msgA.setText("import " + strData);
 			return;
 		}
@@ -371,87 +363,87 @@
 		// fill name with contents of <desc>, in case of gc.com the name is
 		// later replaced by the contents of <groundspeak:name> which is shorter
 		if (name.equals("desc")&& inWpt ) {
-			chD.setCacheName(strData);
+			holder.setCacheName(strData);
 			//Vm.debug("CacheName: " + strData);
 			//msgA.setText("import " + strData);
 			return;
 		}
 		if (name.equals("url")&& inWpt){
-			chD.URL = strData;
+			holder.getFreshDetails().URL = strData;
 			return;
 		}
 		
 		// Text for additional waypoints, no HTML
 		if (name.equals("cmt")&& inWpt){
-			chD.LongDescription = strData;
-			chD.setHTML(false);
+			holder.getFreshDetails().LongDescription = strData;
+			holder.setHTML(false);
 			return;
 		}
 		
 		// aditional wapypoint
 		if (name.equals("type")&& inWpt && !inCache && strData.startsWith("Waypoint")){
-			chD.setType(CacheType.typeText2Number(strData));
-			chD.setCacheSize("None");
+			holder.setType(CacheType.typeText2Number(strData));
+			holder.setCacheSize("None");
 		}
 
 		
 		if ((name.equals("groundspeak:name")|| name.equals("terra:name")) && inCache) {
-			chD.setCacheName(strData);
+			holder.setCacheName(strData);
 			return;
 		}
 		if (name.equals("groundspeak:owner") || name.equals("owner")||name.equals("terra:owner")) {
-			chD.setCacheOwner(strData);
-			if(pref.myAlias.equals(strData)) chD.setOwned(true);
+			holder.setCacheOwner(strData);
+			if(pref.myAlias.equals(strData)) holder.setOwned(true);
 			return;
 		}
 		if (name.equals("groundspeak:difficulty") || name.equals("difficulty") || name.equals("terra:mental_challenge")) {
-			chD.setHard(strData.replace('.',','));
+			holder.setHard(strData.replace('.',','));
 			return;
 		}
 		if (name.equals("groundspeak:terrain")|| name.equals("terrain")|| name.equals("terra:physical_challenge")) {
-			chD.setTerrain(strData.replace('.',','));
+			holder.setTerrain(strData.replace('.',','));
 			return;
 		}
 		if ((name.equals("groundspeak:type") || name.equals("type")|| name.equals("terra:style"))&& inCache){
-			chD.setType(CacheType.typeText2Number(strData));
+			holder.setType(CacheType.typeText2Number(strData));
 			return;
 		}
 		if (name.equals("groundspeak:container")|| name.equals("container")){
-			chD.setCacheSize(strData);
+			holder.setCacheSize(strData);
 			return;
 		}
 		if (name.equals("groundspeak:country")|| name.equals("country")){
-			chD.Country = strData;
+			holder.getFreshDetails().Country = strData;
 			return;
 		}
 		if (name.equals("groundspeak:state")|| name.equals("state")){
-			chD.State = strData;
+			holder.getFreshDetails().State = strData;
 			return;
 		}
 		if (name.equals("terra:size")){
-			chD.setCacheSize(TCSizetoText(strData));
+			holder.setCacheSize(TCSizetoText(strData));
 		}
 
 		if (name.equals("groundspeak:short_description")|| name.equals("summary")) {
-			if (chD.is_HTML())	chD.LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
-			else chD.LongDescription =strData+"\n";
+			if (holder.is_HTML())	holder.getFreshDetails().LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
+			else holder.getFreshDetails().LongDescription =strData+"\n";
 			return;
 		}
 
 		if (name.equals("groundspeak:long_description")|| name.equals("description")|| name.equals("terra:description")) {
-			if (chD.is_HTML())	chD.LongDescription +=SafeXML.cleanback(strData);
-			else chD.LongDescription +=strData;
+			if (holder.is_HTML())	holder.getFreshDetails().LongDescription +=SafeXML.cleanback(strData);
+			else holder.getFreshDetails().LongDescription +=strData;
 			return;
 		}
 		if (name.equals("groundspeak:encoded_hints") || name.equals("hints")) {
-			chD.Hints = Common.rot13(strData);
+			holder.getFreshDetails().Hints = Common.rot13(strData);
 			return;
 		}
 		
 		if (name.equals("terra:hint")) {
 			// remove "&lt;br&gt;<br>" from the end
 			int indexTrash = strData.indexOf("&lt;br&gt;<br>");
-			if (indexTrash > 0)	chD.Hints = Common.rot13(strData.substring(0,indexTrash));
+			if (indexTrash > 0)	holder.getFreshDetails().Hints = Common.rot13(strData.substring(0,indexTrash));
 			return;
 		}
 
@@ -523,13 +515,13 @@
 		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
 		
 		if (fromTC) {
-				imgSpider.getImages(chD.LongDescription, chD);
+				imgSpider.getImages(holder.getFreshDetails().LongDescription, holder.getFreshDetails());
 		}
 		else {
-			addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + chD.getWayPoint() ;
+			addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + holder.getWayPoint() ;
 			//Vm.debug(addr + "|");
 			cacheText = SpiderGC.fetch(addr);
-			imgSpider.getImages(cacheText, chD);
+			imgSpider.getImages(cacheText, holder.getFreshDetails());
 		}
 	}
 	

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -42,7 +42,7 @@
 	Preferences pref;
 	Profile profile;
 	String file;
-	CacheHolderDetail holder;
+	CacheHolder holder;
 
 	String strData = new String();
 
@@ -102,21 +102,20 @@
 			index = cacheDB.getIndex(holder.getWayPoint());
 			if (index == -1){
 				holder.setNew(true);
-				cacheDB.add(new CacheHolder(holder));
+				cacheDB.add(holder);
 			}
 			// update (overwrite) data
 			else {
 				holder.setNew(false);
-				cacheDB.set(index, new CacheHolder(holder));
 			}
 			// save all  (after each cache???)
-			holder.saveCacheDetails(profile.dataDir);
+			holder.save();
 			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 			return;
 		}
 
 		if (name.equals("link")){
-			holder.URL = strData;
+			holder.getFreshDetails().URL = strData;
 			return;
 		}
 
@@ -131,20 +130,14 @@
 		if (debugXML) Vm.debug(strData);
 	}
 
-	private CacheHolderDetail getHolder(String wpt){// See also OCXMLImporter
-		int index;
-		CacheHolderDetail ch;
+	private CacheHolder getHolder(String wpt){// See also OCXMLImporter
+		CacheHolder ch;
 		
-		index = cacheDB.getIndex(wpt);
-		if (index == -1){
-			ch = new CacheHolderDetail();
+		ch = cacheDB.get(wpt);
+		if (ch == null) {
+			ch = new CacheHolder();
 			ch.setWayPoint(wpt);
-			return ch;
 		}
-		ch = new CacheHolderDetail(cacheDB.get(index));
-		try {
-			ch.readCache(profile.dataDir);
-		} catch (Exception e) {Vm.debug("Could not open file: " + e.toString());};
 		return ch;
 	}
 

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/MainTab.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -30,8 +30,8 @@
 	ImagePanel imageP;
 	SolverPanel solverP;
 	String lastselected = "";
-	public CacheHolder ch=null;
-	CacheHolderDetail chD =null, chMain=null;
+	public CacheHolder ch=null, chMain=null;
+	CacheHolderDetail chD =null;
 	MainMenu mnuMain;
 	StatusBar statBar;
 	public MovingMap mm;
@@ -137,18 +137,13 @@
 			chMain=null;
 			cacheDirty=false;
 			if (tbP.getSelectedCache()>=Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache()<0) {
-				ch=null; chD=null; 
+				ch=null;
+				chD=null; 
 				lastselected="";
 			} else {
 				ch = cacheDB.get(tbP.getSelectedCache());
 				lastselected=ch.getWayPoint();  // Used in Parser.Skeleton
-				try {
-					chD = ch.getCacheDetails(true);
-					//chD=new CacheHolderDetail(ch);
-					//chD.readCache(profile.dataDir);//Vm.debug("MainTab:readCache "+chD.wayPoint+"/S:"+chD.Solver);
-				} catch(Exception e){
-					//Vm.debug("Error loading: "+ch.wayPoint);
-				}
+				chD = ch.getCacheDetails(true);
 			}
 		}
 		if (panelNo==1) { // Leaving the Details Panel
@@ -174,8 +169,8 @@
 				if (chMain==null) {
 					chD.Solver=solverP.getInstructions();
 				} else {
-					chMain.Solver=solverP.getInstructions();
-					chMain.saveCacheDetails(Global.getProfile().dataDir);//Vm.debug("mainT:SaveCache "+chMain.wayPoint+"/S:"+chMain.Solver);
+					chMain.getExistingDetails().Solver=solverP.getInstructions();
+					chMain.save();//Vm.debug("mainT:SaveCache "+chMain.wayPoint+"/S:"+chMain.Solver);
 					chMain=null;
 				}
 			}
@@ -207,55 +202,42 @@
 			break;
 		case 2: // Description Panel
 			MyLocale.setSIPOff();
-			descP.setText(chD);
+			descP.setText(ch);
 			break;
 		case 3: // Picture Panel
-			if (chD!=null) {
-				MyLocale.setSIPOff();
-				if (chD.isAddiWpt()) { 
-					imageP.setImages(chD.mainCache.getCacheDetails(true));
-				} else {
-					imageP.setImages(chD);
-				}
+			MyLocale.setSIPOff();
+			if (ch.isAddiWpt()) { 
+				imageP.setImages(ch.mainCache.getCacheDetails(true));
+			} else {
+				imageP.setImages(chD);
 			}
 			break;
 		case 4:  // Log Hint Panel
-			if (chD!=null) {
-				MyLocale.setSIPOff();
-				if (chD.isAddiWpt()) { 
-					hintLP.setText(chD.mainCache.getCacheDetails(true));
-				} else {
-					hintLP.setText(chD);
-				}
+			MyLocale.setSIPOff();
+			if (ch.isAddiWpt()) { 
+				hintLP.setText(ch.mainCache.getCacheDetails(true));
+			} else {
+				hintLP.setText(chD);
 			}
 			break;
 		case 5:  // Solver Panel
 			MyLocale.setSIPOff();
-			if (chD!=null) {
-				if (chD.isAddiWpt()) { 
-					chMain=chD.mainCache.getCacheDetails(true);//new CacheHolderDetail(chD.mainCache);
-/*					try {
-						chMain.readCache(profile.dataDir); //Vm.debug("mainT:readCache "+chD.wayPoint+"=>Main=>"+chMain.wayPoint+"/S:"+chMain.Solver);
-					} catch(Exception e){pref.log("Error reading cache .xml",e);}
-*/					solverP.setInstructions(chMain.Solver);
-				} else {
-					//Vm.debug("mainT: Waypoint:"+chD.wayPoint);
-					solverP.setInstructions(chD.Solver);
-				}
+			if (ch.isAddiWpt()) { 
+				solverP.setInstructions(ch.mainCache.getFreshDetails().Solver);
+			} else {
+				solverP.setInstructions(chD.Solver);
 			}
 			break;
 		case 6:  // CalcPanel
-			if (chD!=null) {
-				MyLocale.setSIPOff();
-				calcP.setFields(chD);
-			}
+			MyLocale.setSIPOff();
+			calcP.setFields(ch);
 			break;
 		case 7: // GotoPanel
 			MyLocale.setSIPOff();
 			break;
 		case 8:  // Cache Radar Panel
 			MyLocale.setSIPOff();
-			radarP.setParam(pref, cacheDB, chD==null?"":chD.getWayPoint());
+			radarP.setParam(pref, cacheDB, ch.getWayPoint());
 			radarP.drawThePanel();
 			break;
 		}
@@ -316,7 +298,6 @@
 				mainCache = selectedCache.mainCache.getWayPoint();
 			}			
 		}
-		detP.setNeedsTableUpdate(true);
 		if (CacheType.isAddiWpt(ch.getType()) && mainCache!=null && mainCache.length()>2) {
 			ch.setWayPoint(profile.getNewAddiWayPointName(mainCache));
 			profile.setAddiRef(ch);
@@ -335,6 +316,7 @@
 		oldCard=1;
 		if (this.cardPanel.selectedItem != 1) select(detP);
 		solverP.setInstructions("");
+		detP.setNeedsTableUpdate(true);
 		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
 	}
@@ -385,7 +367,7 @@
 	void updatePendingChanges() {
 		if (cacheDirty) {
 			if (chD != null)
-				chD.saveCacheDetails(Global.getProfile().dataDir);
+				chD.getParent().save();
 			cacheDirty = false;
 		}
 	}

Modified: trunk/src/CacheWolf/NewProfileWizard.java
===================================================================
--- trunk/src/CacheWolf/NewProfileWizard.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/NewProfileWizard.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -23,6 +23,7 @@
 				profile.setCenterCoords(cs.getCoords());
 			}
 			Global.mainForm.setTitle("Cachewolf "+Version.getRelease()+" - "+profile.name);
+			profile.notifyUnsavedChanges(true);
 		}
 		f.close(0);
 		return (code == 0);

Modified: trunk/src/CacheWolf/NotesScreen.java
===================================================================
--- trunk/src/CacheWolf/NotesScreen.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/NotesScreen.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -9,7 +9,7 @@
 */
 public class NotesScreen extends Form{
 	mTextPad wayNotes = new mTextPad();
-	CacheHolderDetail thisCache = null;
+	CacheHolderDetail chD = null;
 	mButton addDateTime;
 	mButton btSave = new mButton(MyLocale.getMsg(127,"Save"));
 	mButton cancelBtn = new mButton("Cancel");
@@ -24,8 +24,8 @@
 		this.title = "Notes";
 		setPreferredSize(Global.getPref().myAppWidth, Global.getPref().myAppHeight);
 		this.resizeOnSIP = true;
-		thisCache = ch;
-		wayNotes.setText(thisCache.CacheNotes);
+		chD = ch;
+		wayNotes.setText(chD.CacheNotes);
 		addLast(sbp.setTag(CellConstants.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
 		titleControls=new CellPanel();
 		titleControls.addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
@@ -46,12 +46,12 @@
 				wayNotes.setText(note);
 			}
 			if(ev.target == btSave){
-				thisCache.CacheNotes = wayNotes.getText();
-				thisCache.saveCacheDetails( Global.getProfile().dataDir);
+				chD.CacheNotes = wayNotes.getText();
+				chD.getParent().save();
 				this.close(0);
 			}
 			if(ev.target == cancelBtn){
-				if ( (!thisCache.CacheNotes.equals(wayNotes.getText())) ) {
+				if ( (!chD.CacheNotes.equals(wayNotes.getText())) ) {
 					if ( (new MessageBox("Warning", "You will loose any changes made to the notes. Do you want to continue?"
 							, FormBase.YESB|FormBase.NOB)).execute() == FormBase.IDYES) {
 						this.close(0);
@@ -59,11 +59,11 @@
 				} else this.close(0); // no changes -> exit without asking
 			} 
 			if(ev.target == titleOK){
-				if ( (!thisCache.CacheNotes.equals(wayNotes.getText())) ) {
+				if ( (!chD.CacheNotes.equals(wayNotes.getText())) ) {
 					if ( (new MessageBox("Warning", "Save changes made to the notes?"
 							, FormBase.YESB|FormBase.NOB)).execute() == FormBase.IDYES) {
-						thisCache.CacheNotes = wayNotes.getText();
-						thisCache.saveCacheDetails( Global.getProfile().dataDir);
+						chD.CacheNotes = wayNotes.getText();
+						chD.getParent().save();
 					}
 				}
 			}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -37,7 +37,7 @@
 	CacheDB cacheDB;
 	InfoBox inf;
 	CacheHolder ch;
-	CacheHolderDetail chD;
+	CacheHolder holder;
 	Preferences pref;
 	Profile profile;
 	Time dateOfthisSync;
@@ -91,7 +91,7 @@
 	 */
 	public boolean syncSingle(int number, InfoBox infB) {
 		ch = cacheDB.get(number);
-		chD= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
+		holder= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
 
 		if (infB.isClosed) {
 			if (askForOptions) return false; 
@@ -226,7 +226,7 @@
 		
 		picCnt = 0;
 		try{
-			chD = null;
+			holder = null;
 			file = fetch(url, "dummy");
 
 			//parse
@@ -263,15 +263,15 @@
 				success = false;
 			}
 		}catch (IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ chD.getWayPoint();
+			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ holder.getWayPoint();
 			success = false;
-			Vm.debug("Parse error: " + state + " " + chD.getWayPoint());
+			Vm.debug("Parse error: " + state + " " + holder.getWayPoint());
 			e.printStackTrace();
 		}catch (Exception e){ // here should be used the correct exception
-			if (chD != null)	finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ chD.getWayPoint();
+			if (holder != null)	finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.getWayPoint();
 			else finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: <unkown>";
 			success = false;
-			Vm.debug("Parse error: " + state + " Exception:" + e.toString()+"   "+chD.getOcCacheID());
+			Vm.debug("Parse error: " + state + " Exception:" + e.toString()+"   "+holder.getOcCacheID());
 			e.printStackTrace();
 		} finally {
 			if (tmpFile != null) tmpFile.delete();
@@ -354,27 +354,27 @@
 			cacheID = atts.getValue("id");
 		}
 		if(name.equals("type")){
-			chD.setType(CacheType.transOCType(new Integer(atts.getValue("id")).intValue())); 
+			holder.setType(CacheType.transOCType(new Integer(atts.getValue("id")).intValue())); 
 			return;
 		}
 		if(name.equals("status")){
-			if(atts.getValue("id").equals("1")) chD.setAvailable(true);
-			if(atts.getValue("id").equals("2")) chD.setAvailable(false);
+			if(atts.getValue("id").equals("1")) holder.setAvailable(true);
+			if(atts.getValue("id").equals("2")) holder.setAvailable(false);
 			if(atts.getValue("id").equals("3")) {
-				chD.setArchived(true);
-				chD.setAvailable(false);
+				holder.setArchived(true);
+				holder.setAvailable(false);
 			}
-			if(atts.getValue("id").equals("4")) chD.setAvailable(false);
+			if(atts.getValue("id").equals("4")) holder.setAvailable(false);
 			return;
 		}
 		if(name.equals("size")){
-			chD.setCacheSize(transSize(atts.getValue("id")));
+			holder.setCacheSize(transSize(atts.getValue("id")));
 			return;
 		}
 
 		if(name.equals("waypoints")){
-			chD.setWayPoint(atts.getValue("oc"));
-			if (chD.getWayPoint().length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
+			holder.setWayPoint(atts.getValue("oc"));
+			if (holder.getWayPoint().length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
 			return;
 		}
 
@@ -386,11 +386,11 @@
 		}
 
 		if (name.equals("desc")){
-			chD.setHTML(atts.getValue("html").equals("1")?true:false);
+			holder.setHTML(atts.getValue("html").equals("1")?true:false);
 		}
 
 		if (name.equals("language") && !atts.getValue("id").equals("DE")){
-			if (chD.LongDescription.length()> 0) ignoreDesc = true; // TODO "DE" in preferences adjustable
+			if (holder.getFreshDetails().LongDescription.length()> 0) ignoreDesc = true; // TODO "DE" in preferences adjustable
 			else ignoreDesc = false;
 		}
 	}
@@ -410,7 +410,7 @@
 				logIcon = GPXImporter.typeText2Image("Found");
 				break;
 			case 2:	logIcon = GPXImporter.typeText2Image("Not Found"); 
-			chD.setNoFindLogs(chD.getNoFindLogs()+1);
+			holder.setNoFindLogs(holder.getNoFindLogs()+1);
 			break;
 			case 3: logIcon = GPXImporter.typeText2Image("Note");
 			}
@@ -423,55 +423,53 @@
 		}
 	}
 
+	// TODO Do we have to release the "holder" cache details ?
 	private void endCache(String name){
 		if (name.equals("cache")){
-			chD.setLastSyncOC(dateOfthisSync.format("yyyyMMddHHmmss"));
+			holder.setLastSyncOC(dateOfthisSync.format("yyyyMMddHHmmss"));
 			int index;
-			index = cacheDB.getIndex(chD.getWayPoint());
+			index = cacheDB.getIndex(holder.getWayPoint());
 			if (index == -1){
-				chD.setNew(true);
-				CacheHolder ch = new CacheHolder(chD);
-				ch.details = chD;
-				cacheDB.add(ch);
-				ch.detailsAdded();
+				holder.setNew(true);
+				cacheDB.add(holder);
 				Integer indexInt = new Integer(cacheDB.size()-1);
-				DBindexID.put(chD.getOcCacheID(), indexInt);
+				DBindexID.put(holder.getOcCacheID(), indexInt);
 			}
 			// update (overwrite) data
 			else {
-				chD.setNew(false);
-				cacheDB.set(index, new CacheHolder(chD));
+				holder.setNew(false);
+				cacheDB.get(index).update(holder);
 				// save ocCacheID, in case, the previous data is from GPX
-				DBindexID.put(chD.getOcCacheID(), new Integer(index));
+				DBindexID.put(holder.getOcCacheID(), new Integer(index));
 			}
 			// clear data (picture, logs) if we do a complete Update
 			if (incUpdate == false){
-				chD.CacheLogs.clear();
-				chD.Images.clear();
-				chD.ImagesText.clear();
-				chD.ImagesInfo.clear();
+				holder.getFreshDetails().CacheLogs.clear();
+				holder.getFreshDetails().Images.clear();
+				holder.getFreshDetails().ImagesText.clear();
+				holder.getFreshDetails().ImagesInfo.clear();
 			}
 
 			// save all
-			chD.hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
+			holder.getFreshDetails().hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
 			// chD.saveCacheDetails(profile.dataDir); 
 			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
 			return;
 		}
 		if(name.equals("id")){ // </id>
-			chD = getHolder(strData); // Allocate a new CacheHolder object
-			chD.setOcCacheID(strData);
-			chD.URL = ocSeekUrl + cacheID;
+			holder = getHolder(strData); // Allocate a new CacheHolder object
+			holder.setOcCacheID(strData);
+			holder.getFreshDetails().URL = ocSeekUrl + cacheID;
 			return;
 		}
 
 		if(name.equals("name")){
-			chD.setCacheName(strData);
+			holder.setCacheName(strData);
 			return;
 		}
 		if(name.equals("userid")) {
-			chD.setCacheOwner(strData);
-			if(chD.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && chD.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) chD.setOwned(true);
+			holder.setCacheOwner(strData);
+			if(holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) holder.setOwned(true);
 			return;
 		}
 
@@ -480,24 +478,24 @@
 			return;
 		}
 		if(name.equals("latitude")) {
-			chD.pos.set(Common.parseDouble(strData),longitude);
-			chD.LatLon = chD.pos.toString();
+			holder.pos.set(Common.parseDouble(strData),longitude);
+			holder.LatLon = holder.pos.toString();
 			return;
 		}
 		if(name.equals("difficulty")) {
-			chD.setHard(strData);
+			holder.setHard(strData);
 			return;
 		}
 		if(name.equals("terrain")) {
-			chD.setTerrain(strData);
+			holder.setTerrain(strData);
 			return;
 		}
 		if(name.equals("datehidden")) {
-			chD.setDateHidden(strData.substring(0,10)); //Date;
+			holder.setDateHidden(strData.substring(0,10)); //Date;
 			return;
 		}
 		if (name.equals("country")){
-			chD.Country = strData;
+			holder.getFreshDetails().Country = strData;
 			return;
 		}
 	}
@@ -506,7 +504,7 @@
 
 		if (!ignoreDesc){
 			if (name.equals("cachedesc")){
-				if (pref.downloadPicsOC && chD.is_HTML()) {
+				if (pref.downloadPicsOC && holder.is_HTML()) {
 					String fetchUrl, imgTag, imgAltText;
 					Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)"); //  Ergebnis enth?lt keine Anf?hrungszeichen
 					Regex imgRegexAlt = new Regex("(?:alt=[\"\']([^>^\"^\']*)|alt=([^>^\"^\'^ ]*))"); // get alternative text for Pic
@@ -514,12 +512,12 @@
 					imgRegexUrl.setIgnoreCase(true);
 					int descIndex=0;
 					int numDownloaded=1;
-					while (imgRegexUrl.searchFrom(chD.LongDescription, descIndex)) { // "img" found
+					while (imgRegexUrl.searchFrom(holder.getFreshDetails().LongDescription, descIndex)) { // "img" found
 						imgTag=imgRegexUrl.stringMatched(1); // (1) enth?lt das gesamte <img ...>-tag
 						fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf?hrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anf?hrungszeichen 
 						if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
 						if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-							inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+chD.getWayPoint()));
+							inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+holder.getWayPoint()));
 							continue;
 						}
 						inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
@@ -536,37 +534,37 @@
 						getPic(fetchUrl, imgAltText);
 					}
 				}
-				chD.hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+				holder.getFreshDetails().hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
 				return;
 			}
 
 
 			if (name.equals("cacheid")){
 				// load cachedata
-				chD = getHolder(strData);
-				chD.setUpdated(true);
+				holder = getHolder(strData);
+				holder.setUpdated(true);
 				return;
 			}
 
 			if (name.equals("shortdesc")){
-				chD.LongDescription = strData;
+				holder.getFreshDetails().LongDescription = strData;
 				return;
 			}
 
 			if (name.equals("desc")){ // </desc>
-				if (chD.is_HTML())	chD.LongDescription +=SafeXML.cleanback(strData);
-				else chD.LongDescription +=strData;
+				if (holder.is_HTML())	holder.getFreshDetails().LongDescription +=SafeXML.cleanback(strData);
+				else holder.getFreshDetails().LongDescription +=strData;
 				return;
 			}
 			if (name.equals("hint")){
-				chD.Hints = Common.rot13(strData);
+				holder.getFreshDetails().Hints = Common.rot13(strData);
 				return;
 			}
 		}
 	}
 
 	private String createPicFilename(String fetchURL) {
-		String fileName = chD.getWayPoint() + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
+		String fileName = holder.getWayPoint() + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
 		return Common.ClearForFileName(fileName);
 	}
 	
@@ -575,23 +573,23 @@
 			if (!fetchURL.startsWith("http://")) fetchURL = new URL(new URL("http://" + OPENCACHING_HOST+"/"), fetchURL).toString(); // TODO this is not quite correct: actually the "base" URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
 			String fileName = createPicFilename(fetchURL);
 			// add title
-			chD.ImagesText.add(picDesc);
-			chD.ImagesInfo.add(null); // need to stay in sync with ImagesText
+			holder.getFreshDetails().ImagesText.add(picDesc);
+			holder.getFreshDetails().ImagesInfo.add(null); // need to stay in sync with ImagesText
 			try {
 				File ftest = new File(profile.dataDir + fileName);
 				if (ftest.exists()){
-					chD.Images.add(fileName);
+					holder.getFreshDetails().Images.add(fileName);
 				}
 				else {
 					if (pref.downloadPicsOC) {
-						chD.Images.add(fetch(fetchURL, fileName));
+						holder.getFreshDetails().Images.add(fetch(fetchURL, fileName));
 					}
 				}
 			} catch (IOException e) {
-				String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + chD.getWayPoint() + ": ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+fetchURL); 
+				String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + holder.getWayPoint() + ": ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+fetchURL); 
 				if (e.getMessage().toLowerCase().equalsIgnoreCase("could not connect") ||
 						e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+chD.getCacheName() + " ("+chD.getWayPoint()+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
+					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+holder.getCacheName() + " ("+holder.getWayPoint()+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
 				} 
 				inf.addWarning("\n"+ErrMessage);
 				//(new MessageBox(MyLocale.getMsg(144, "Warning"), ErrMessage, MessageBox.OKB)).exec();
@@ -599,7 +597,7 @@
 				e.printStackTrace();
 			}
 		} catch (MalformedURLException e) {
-			String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + chD.getWayPoint() + ": ignoring MalformedUrlException: " + e.getMessage()+ " while downloading from URL:" + fetchURL); 
+			String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + holder.getWayPoint() + ": ignoring MalformedUrlException: " + e.getMessage()+ " while downloading from URL:" + fetchURL); 
 			inf.addWarning("\n"+ErrMessage);
 			pref.log(ErrMessage);
 		}
@@ -624,33 +622,33 @@
 		}
 		if(name.equals("object")){
 			// get cachedata
-			chD = getHolder(strData);
+			holder = getHolder(strData);
 			return;
 		}
 		if(name.equals("picture")){ 
 			//String fileName = holder.wayPoint + "_" + picUrl.substring(picUrl.lastIndexOf("/")+1);
 			getPic(picUrl,picTitle);
-			chD.hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+			holder.getFreshDetails().hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
 			return;
 		}
 	}
 
 	private void endCacheLog(String name){
 		if (name.equals("cachelog")){ // </cachelog>
-			chD.CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
+			holder.getFreshDetails().CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
 			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) && logtype == 1) {
-						chD.setCacheStatus(logDate);
-						chD.setFound(true);
-						chD.OwnLogId = logId;
-						chD.OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
+						holder.setCacheStatus(logDate);
+						holder.setFound(true);
+						holder.getFreshDetails().OwnLogId = logId;
+						holder.getFreshDetails().OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
 			}
-			chD.hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
+			holder.getFreshDetails().hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
 			return;
 		}
 
 		if (name.equals("cacheid")){ // </cacheid>
 			// load cachedata
-			chD = getHolder(strData);
+			holder = getHolder(strData);
 			return;
 		}
 
@@ -675,7 +673,7 @@
 		CharArray realurl = new CharArray();
 		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
 		String address = realurl.toString();
-		if (chD != null) fileName = chD.getWayPoint() + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
+		if (holder != null) fileName = holder.getWayPoint() + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
 		// else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
 
 		//save file
@@ -723,21 +721,18 @@
 	}
 
 
-	private CacheHolderDetail getHolder(String wpt){// See also LOCXMLImporter
+	private CacheHolder getHolder(String wpt){// See also LOCXMLImporter
+		CacheHolder chx;
 		int index;
 		
 		index = cacheDB.getIndex(wpt);
-		if (index ==-1) index = searchID(wpt);
+		if (index == -1) index = searchID(wpt);
 		if (index == -1) {
-			chD = new CacheHolderDetail();
-			return chD;
+			chx = new CacheHolder();
+		} else {
+			chx = cacheDB.get(index);
 		}
-		chD = cacheDB.get(index).getCacheDetails(true);
-/*		try {
-			chD.readCache(profile.dataDir);
-		} catch (Exception e) {Vm.debug("Could not open file: " + e.toString());};
-	*/	return chD;
+		return chx;
 	}
 
-
 }

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/Parser.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -730,12 +730,8 @@
 					op.append(addiWpt.getCacheName());
 					op.append("] = \" $");
 					op.append(addiWpt.getWayPoint());
-					CacheHolderDetail chD=new CacheHolderDetail(addiWpt);
-					try {
-						chD.readCache(Global.getProfile().dataDir);
-					} catch( Exception ex) {};
-					if (chD.LongDescription.trim().length()>0)
-						op.append("\n   \""+STRreplace.replace(chD.LongDescription,"\"","\"\"")+"\"");
+					if (addiWpt.getExistingDetails().LongDescription.trim().length()>0)
+						op.append("\n   \""+STRreplace.replace(addiWpt.getExistingDetails().LongDescription,"\"","\"\"")+"\"");
 					op.append("\n   goto($");
 					op.append(addiWpt.getWayPoint());
 					op.append("); STOP\nENDIF\n\n");

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/Profile.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -519,7 +519,7 @@
 				if (mainCh != null) {
 					mainCh.addiWpts.add(ch);
 					ch.mainCache = mainCh;
-					ch.setAttributesFromMainCache(mainCh);
+					ch.setAttributesFromMainCache();
 				}// if
 			}// if
 		}// for

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -35,7 +35,8 @@
 				if (ch.is_filtered()) break; // Reached end of visible records
 				if(ch.getWayPoint().toUpperCase().indexOf(searchStr) <0 && 
 				   ch.getCacheName().toUpperCase().indexOf(searchStr) <0 && 
-				   ch.getCacheStatus().toUpperCase().indexOf(searchStr)<0){
+				   ch.getCacheStatus().toUpperCase().indexOf(searchStr)<0 /*&&
+				   ch.getExistingDetails().LongDescription.toUpperCase().indexOf(searchStr)<0*/){
 					ch.is_flaged = false;
 					ch.setFiltered(true);
 				} else

Modified: trunk/src/CacheWolf/ShowCacheInBrowser.java
===================================================================
--- trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -59,7 +59,7 @@
 		}
 	}
 	
-	public void showCache(CacheHolderDetail chD) {
+	public void showCache(CacheHolder chD) {
 		if (chD == null) return;
 		try {
 			Template tpl = new Template(args);
@@ -92,39 +92,39 @@
 						tpl.setParam("STATUS", chD.getCacheStatus());
 					
 					// Cache attributes
-					if (chD.attributes.getCount()>0) {
-						Vector attVect=new Vector(chD.attributes.getCount()+1);
-						for (int i=0; i<chD.attributes.getCount(); i++) {
+					if (chD.getExistingDetails().attributes.getCount()>0) {
+						Vector attVect=new Vector(chD.getExistingDetails().attributes.getCount()+1);
+						for (int i=0; i<chD.getExistingDetails().attributes.getCount(); i++) {
 							Hashtable atts=new Hashtable();
 							atts.put("IMAGE","<img src=\"file://"+
-									   Attribute.getImageDir()+chD.attributes.getName(i)+
-									   "\" border=0 alt=\""+chD.attributes.getInfo(i)+"\">");
+									   Attribute.getImageDir()+chD.getExistingDetails().attributes.getName(i)+
+									   "\" border=0 alt=\""+chD.getExistingDetails().attributes.getInfo(i)+"\">");
 							if (i % 5 ==4) 
 								atts.put("BR","<br/>");
 							else
 								atts.put("BR","");
-							atts.put("INFO",chD.attributes.getInfo(i));
+							atts.put("INFO",chD.getExistingDetails().attributes.getInfo(i));
 							attVect.add(atts);
 						}
 						tpl.setParam("ATTRIBUTES",attVect);
 					}
 					
 					tpl.setParam("DATE", chD.getDateHidden());
-					tpl.setParam("URL", chD.URL);
-					if (chD.Travelbugs.size()>0) tpl.setParam("BUGS",chD.Travelbugs.toHtml());
-					if (chD.CacheNotes!=null && chD.CacheNotes.trim().length()>0) tpl.setParam("NOTES", STRreplace.replace(chD.CacheNotes,"\n","<br/>\n"));
-					if (chD.Solver!=null && chD.Solver.trim().length()>0) tpl.setParam("SOLVER", STRreplace.replace(chD.Solver,"\n","<br/>\n"));
+					tpl.setParam("URL", chD.getExistingDetails().URL);
+					if (chD.getExistingDetails().Travelbugs.size()>0) tpl.setParam("BUGS",chD.getExistingDetails().Travelbugs.toHtml());
+					if (chD.getExistingDetails().CacheNotes!=null && chD.getExistingDetails().CacheNotes.trim().length()>0) tpl.setParam("NOTES", STRreplace.replace(chD.getExistingDetails().CacheNotes,"\n","<br/>\n"));
+					if (chD.getExistingDetails().Solver!=null && chD.getExistingDetails().Solver.trim().length()>0) tpl.setParam("SOLVER", STRreplace.replace(chD.getExistingDetails().Solver,"\n","<br/>\n"));
 					// Look for images
 					
-					StringBuffer s=new StringBuffer(chD.LongDescription.length());
+					StringBuffer s=new StringBuffer(chD.getExistingDetails().LongDescription.length());
 					int start=0;
 					int pos;
 					int imageNo=0;
 					Regex imgRex = new Regex("src=(?:\\s*[^\"|']*?)(?:\"|')(.*?)(?:\"|')");
-					while (start>=0 && (pos=chD.LongDescription.indexOf("<img",start))>0) {
-						if (imageNo >= chD.Images.getCount())break;
-						s.append(chD.LongDescription.substring(start,pos));
-						imgRex.searchFrom(chD.LongDescription,pos);
+					while (start>=0 && (pos=chD.getExistingDetails().LongDescription.indexOf("<img",start))>0) {
+						if (imageNo >= chD.getExistingDetails().Images.getCount())break;
+						s.append(chD.getExistingDetails().LongDescription.substring(start,pos));
+						imgRex.searchFrom(chD.getExistingDetails().LongDescription,pos);
 						String imgUrl=imgRex.stringMatched(1);
 						//Vm.debug("imgUrl "+imgUrl);
 						if (imgUrl.lastIndexOf('.')>0 && imgUrl.toLowerCase().startsWith("http")) {
@@ -132,27 +132,27 @@
 							// If we have an image which we stored when spidering, we can display it
         					if(imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")){
 								s.append("<img src=\"file://"+
-								   Global.getProfile().dataDir+chD.Images.get(imageNo)+"\">");
+								   Global.getProfile().dataDir+chD.getExistingDetails().Images.get(imageNo)+"\">");
 								imageNo++;
 							}
 						}
-						start=chD.LongDescription.indexOf(">",pos);
+						start=chD.getExistingDetails().LongDescription.indexOf(">",pos);
 						if (start>=0) start++;
 					}
-					if (start>=0) s.append(chD.LongDescription.substring(start));
+					if (start>=0) s.append(chD.getExistingDetails().LongDescription.substring(start));
 					tpl.setParam("DESCRIPTION", s.toString());
 					
 					// Do the remaining pictures which are not included in main body of text
 					// They will be hidden initially and can be displayed by clicking on a link
-					if (imageNo<chD.Images.size()) {
-						Vector imageVect=new Vector(chD.Images.size()-imageNo);
-						for (; imageNo<chD.Images.size(); imageNo++) {
+					if (imageNo<chD.getExistingDetails().Images.size()) {
+						Vector imageVect=new Vector(chD.getExistingDetails().Images.size()-imageNo);
+						for (; imageNo<chD.getExistingDetails().Images.size(); imageNo++) {
 							Hashtable imgs=new Hashtable();
 							imgs.put("IMAGE","<img src=\"file://"+
-									   Global.getProfile().dataDir+chD.Images.get(imageNo)+"\" border=0>");
-							imgs.put("IMAGETEXT",chD.ImagesText.get(imageNo));
-							if (imageNo<chD.ImagesInfo.size() && chD.ImagesInfo.get(imageNo)!=null)
-								imgs.put("IMAGECOMMENT",chD.ImagesInfo.get(imageNo));
+									   Global.getProfile().dataDir+chD.getExistingDetails().Images.get(imageNo)+"\" border=0>");
+							imgs.put("IMAGETEXT",chD.getExistingDetails().ImagesText.get(imageNo));
+							if (imageNo<chD.getExistingDetails().ImagesInfo.size() && chD.getExistingDetails().ImagesInfo.get(imageNo)!=null)
+								imgs.put("IMAGECOMMENT",chD.getExistingDetails().ImagesInfo.get(imageNo));
 							else
 								imgs.put("IMAGECOMMENT","");
 							imgs.put("I","'img"+new Integer(imageNo).toString()+"'");
@@ -161,10 +161,10 @@
 						tpl.setParam("IMAGES",imageVect);
 					}
 					
-					Vector logVect=new Vector(chD.CacheLogs.size());
-					for (int i=0; i<chD.CacheLogs.size(); i++) {
+					Vector logVect=new Vector(chD.getExistingDetails().CacheLogs.size());
+					for (int i=0; i<chD.getExistingDetails().CacheLogs.size(); i++) {
 						Hashtable logs=new Hashtable();
-						String log=STRreplace.replace(chD.CacheLogs.getLog(i).toHtml(),"http://www.geocaching.com/images/icons/","");
+						String log=STRreplace.replace(chD.getExistingDetails().CacheLogs.getLog(i).toHtml(),"http://www.geocaching.com/images/icons/","");
 						int posGt=log.indexOf('>'); // Find the icon which defines the type of log
 						if (posGt<0) {
 							logs.put("LOG",log);
@@ -184,7 +184,7 @@
 					}
 					tpl.setParam("LOGS",logVect);
 					if (!chD.is_available()) tpl.setParam("UNAVAILABLE","1");
-					if (!chD.Hints.equals("null"))tpl.setParam("HINT",Common.rot13(chD.Hints));
+					if (!chD.getExistingDetails().Hints.equals("null"))tpl.setParam("HINT",Common.rot13(chD.getExistingDetails().Hints));
 					
 					if (chD.hasAddiWpt()) {
 						Vector addiVect=new Vector(chD.addiWpts.size());
@@ -195,9 +195,7 @@
 							addis.put("NAME",ch.getCacheName());
 							addis.put("LATLON",ch.LatLon);
 							addis.put("IMG","<img src=\""+CacheType.type2pic(ch.getType())+"\">");
-							CacheHolderDetail chDA=new CacheHolderDetail(ch);
-							chDA.readCache(Global.getProfile().dataDir);
-							addis.put("LONGDESC",chDA.LongDescription); // Do we need to treat longDesc as above ?
+							addis.put("LONGDESC",ch.getExistingDetails().LongDescription); // Do we need to treat longDesc as above ?
 							addiVect.add(addis);
 						}
 						tpl.setParam("ADDIS",addiVect);

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -211,7 +211,8 @@
 	public int spiderSingle(int number, InfoBox infB, boolean forceLogin){
 		int ret=-1;
 		this.infB = infB;
-		CacheHolder ch = cacheDB.get(number);
+		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
+		ch.setWayPoint(cacheDB.get(number).getWayPoint());
 		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
 
 		// check if we need to login
@@ -219,25 +220,18 @@
 			if (this.login()!=FormBase.IDOK) return -1;
 			// loggedIn is already set by this.login()
 		}
-		CacheHolderDetail chD=ch.getCacheDetails(true); //new CacheHolderDetail(ch);
 		try{
-/*			// Get all existing details of the cache
-			try {
-				chD.readCache(profile.dataDir);
-			} catch (IOException ioex) {
-				pref.log("No .XML file found for cache "+chD.wayPoint);
-			};
-*/			// Read the cache data from GC.COM and compare to old data
+			// Read the cache data from GC.COM and compare to old data
 			boolean loadAllLogs = (MAXLOGS > 5);
-			ret=getCacheByWaypointName(chD,true,true,false,loadAllLogs);
+			ret=getCacheByWaypointName(ch,true,true,false,loadAllLogs);
 			// Save the spidered data
 			if (ret == 1) {
 				pref.log("Saving to:" + profile.dataDir);
-				chD.saveCacheDetails(profile.dataDir);
-				cacheDB.get(number).update(chD);
+				cacheDB.get(number).update(ch);
+				ch.save();
 			}
 		}catch(Exception ex){
-			pref.log("Error spidering " + chD.getWayPoint() + " in spiderSingle");
+			pref.log("Error spidering " + ch.getWayPoint() + " in spiderSingle");
 		}
 		return ret;
 	} // spiderSingle
@@ -284,7 +278,7 @@
 	public void doIt(boolean spiderAllFinds){
 		String postStr, dummy, ln, wpt;
 		Regex lineRex;
-		CacheHolderDetail chD;
+		CacheHolder holder;
 		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
 		if ( !spiderAllFinds && !origin.isValid()) {
 			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5509,"Coordinates for centre must be set"), FormBase.OKB)).execute();
@@ -468,13 +462,9 @@
 									cachesToUpdate.put(ch.getWayPoint(), ch);
 								}
 								ch.setArchived(is_archived_GC);
-								chD=ch.getCacheDetails(true,false);
-								ch.detailsAdded();
 							} else if (ch.is_available()!=is_available_GC) { // Update the database with the cache status
 								pref.log("Updating status of "+waypoint+" to "+(is_available_GC?"available":"not available"));
 								ch.setAvailable(is_available_GC);
-								chD=ch.getCacheDetails(true,false);
-								ch.detailsAdded();
 							} else {
 								cachesToUpdate.remove( ch.getWayPoint() );
 							}
@@ -511,7 +501,6 @@
 					}catch(Exception ex){
 						//Vm.debug("Couldn't get the next page");
 						pref.log("Error getting next page");
-					}finally{
 					}
 				}
 				//Vm.debug("Distance is now: " + distance);
@@ -556,18 +545,18 @@
 			// Get only caches not already available in the DB
 			if(cacheDB.getIndex(wpt) == -1){
 				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + wpt +" (" + (i+1) + " / " + totalCachesToLoad + ")");
-				chD = new CacheHolderDetail();
-				chD.setWayPoint(wpt);
-				int test = getCacheByWaypointName(chD,false,getImages,doNotgetFound,loadAllLogs);
+				holder = new CacheHolder();
+				holder.setWayPoint(wpt);
+				int test = getCacheByWaypointName(holder,false,getImages,doNotgetFound,loadAllLogs);
 				if (test == -1) {
 					infB.close(0);
 					break;
 				} else if (test == 0) {
 					spiderErrors++;
 				} else {
-					if (!chD.is_found() || !doNotgetFound ) {
-						chD.saveCacheDetails(profile.dataDir);
-						cacheDB.add(new CacheHolder(chD)); 
+					if (!holder.is_found() || !doNotgetFound ) {
+						cacheDB.add(holder); 
+						holder.save();
 					}
 				}
 			}
@@ -618,7 +607,7 @@
 	 *     This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
 	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
 	 */
-	private int getCacheByWaypointName(CacheHolderDetail chD, boolean isUpdate, boolean fetchImages, boolean doNotGetFound, boolean fetchAllLogs) {
+	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean doNotGetFound, boolean fetchAllLogs) {
 		int ret = 1;
 		while (true) {
 			String completeWebPage;
@@ -627,33 +616,33 @@
 			while (spiderTrys++<MAX_SPIDER_TRYS) {
 				ret = 1;
 				try{
-					String doc = p.getProp("getPageByName") + chD.getWayPoint() +(fetchAllLogs?p.getProp("fetchAllLogs"):"");
-					pref.log("Fetching: " + chD.getWayPoint());
+					String doc = p.getProp("getPageByName") + ch.getWayPoint() +(fetchAllLogs?p.getProp("fetchAllLogs"):"");
+					pref.log("Fetching: " + ch.getWayPoint());
 					completeWebPage = fetch(doc);
 					if	( completeWebPage.equals("")) {
-						pref.log("Could not fetch " + chD.getWayPoint());
+						pref.log("Could not fetch " + ch.getWayPoint());
 						if (!infB.isClosed) {
 							continue;
 						} else {
-							chD.setIncomplete(true);
+							ch.setIncomplete(true);
 							return -1;
 						}
 					}
 				}catch(Exception ex){
-					pref.log("Could not fetch " + chD.getWayPoint(),ex);
+					pref.log("Could not fetch " + ch.getWayPoint(),ex);
 					if (!infB.isClosed) {
 						continue;
 					} else {
-						chD.setIncomplete(true);
+						ch.setIncomplete(true);
 						return -1;
 					}
 				}
 				// Only analyse the cache data and fetch pictures if user has not closed the progress window
 				if (!infB.isClosed) {
 					try{
-						chD.setNew(!isUpdate);
-						chD.setUpdated(false);
-						chD.setLog_updated(false);
+						ch.setNew(!isUpdate);
+						ch.setUpdated(false);
+						ch.setLog_updated(false);
 
 						//first check if coordinates are available to prevent deleting existing coorinates
 						String latLon = getLatLon(completeWebPage);
@@ -663,99 +652,99 @@
 							continue; // Restart the spider
 						}
 
-						chD.setHTML(true);
-						chD.setAvailable(true);
-						chD.setArchived(false);
-						chD.setIncomplete(true);
+						ch.setHTML(true);
+						ch.setAvailable(true);
+						ch.setArchived(false);
+						ch.setIncomplete(true);
 						// Save size of logs to be able to check whether any new logs were added
 						//int logsz = chD.CacheLogs.size();
 						//chD.CacheLogs.clear();
-						chD.addiWpts.clear();
-						chD.Images.clear();
-						chD.ImagesText.clear();
-						chD.ImagesInfo.clear();
+						ch.addiWpts.clear();
+						ch.getFreshDetails().Images.clear();
+						ch.getFreshDetails().ImagesText.clear();
+						ch.getFreshDetails().ImagesInfo.clear();
 
-						if(completeWebPage.indexOf(p.getProp("cacheUnavailable")) >= 0) chD.setAvailable(false);
-						if(completeWebPage.indexOf(p.getProp("cacheArchived")) >= 0) chD.setArchived(true);
+						if(completeWebPage.indexOf(p.getProp("cacheUnavailable")) >= 0) ch.setAvailable(false);
+						if(completeWebPage.indexOf(p.getProp("cacheArchived")) >= 0) ch.setArchived(true);
 						//==========
 						// General Cache Data
 						//==========
-						chD.setLatLon(latLon);
-						pref.log("LatLon: " + chD.LatLon);
-						if (pref.debug) pref.log("chD.pos: " + chD.pos.toString());
+						ch.setLatLon(latLon);
+						pref.log("LatLon: " + ch.LatLon);
+						if (pref.debug) pref.log("chD.pos: " + ch.pos.toString());
 
 						pref.log("Trying description");
-						chD.setLongDescription(getLongDesc(completeWebPage));
+						ch.getFreshDetails().setLongDescription(getLongDesc(completeWebPage));
 						pref.log("Got description");
 
 						pref.log("Getting cache name");
-						chD.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
-						if (pref.debug) pref.log("Name: " + chD.getCacheName()); else pref.log("Got name");
+						ch.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
+						if (pref.debug) pref.log("Name: " + ch.getCacheName()); else pref.log("Got name");
 						
 						pref.log("Trying location (country/state)");
 						String location = getLocation(completeWebPage);
 						if (location.length() != 0) {
 							int countryStart = location.indexOf(",");
 							if (countryStart > -1) {
-								chD.Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
-								chD.State = SafeXML.cleanback(location.substring(0, countryStart).trim());								
+								ch.getFreshDetails().Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
+								ch.getFreshDetails().State = SafeXML.cleanback(location.substring(0, countryStart).trim());								
 							} else {
-								chD.Country = location.trim();
-								chD.State = "";
+								ch.getFreshDetails().Country = location.trim();
+								ch.getFreshDetails().State = "";
 							}
 							pref.log("Got location (country/state)");							
 						} else {
-							chD.Country = "";
-							chD.State = "";
+							ch.getFreshDetails().Country = "";
+							ch.getFreshDetails().State = "";
 							pref.log("No location (country/state) found");
 						}
 
 						pref.log("Trying owner");
-						chD.setCacheOwner(SafeXML.cleanback(getOwner(completeWebPage)).trim());
-						if(chD.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length()>0 && chD.getCacheOwner().equals(pref.myAlias2))) chD.setOwned(true);
-						if (pref.debug) pref.log("Owner: " + chD.getCacheOwner() +"; is_owned = "+chD.is_owned()+";  alias1,2 = ["+pref.myAlias+"|"+pref.myAlias2+"]");
+						ch.setCacheOwner(SafeXML.cleanback(getOwner(completeWebPage)).trim());
+						if(ch.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length()>0 && ch.getCacheOwner().equals(pref.myAlias2))) ch.setOwned(true);
+						if (pref.debug) pref.log("Owner: " + ch.getCacheOwner() +"; is_owned = "+ch.is_owned()+";  alias1,2 = ["+pref.myAlias+"|"+pref.myAlias2+"]");
 						else pref.log("Got owner");
 
 
 						pref.log("Trying date hidden");
-						chD.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
-						if (pref.debug) pref.log("Hidden: " + chD.getDateHidden());
+						ch.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
+						if (pref.debug) pref.log("Hidden: " + ch.getDateHidden());
 						else pref.log("Got date hidden");
 
 						pref.log("Trying hints");
-						chD.setHints(getHints(completeWebPage));
-						if (pref.debug) pref.log("Hints: " + chD.Hints);
+						ch.getFreshDetails().setHints(getHints(completeWebPage));
+						if (pref.debug) pref.log("Hints: " + ch.getFreshDetails().Hints);
 						else pref.log("Got hints");
 
 						pref.log("Trying size");
-						chD.setCacheSize(getSize(completeWebPage));
-						if (pref.debug) pref.log("Size: " + chD.getCacheSize());
+						ch.setCacheSize(getSize(completeWebPage));
+						if (pref.debug) pref.log("Size: " + ch.getCacheSize());
 						else pref.log("Got size");
 
 						pref.log("Trying difficulty");
-						chD.setHard(getDiff(completeWebPage));
-						if (pref.debug) pref.log("Hard: " + chD.getHard());
+						ch.setHard(getDiff(completeWebPage));
+						if (pref.debug) pref.log("Hard: " + ch.getHard());
 						else pref.log("Got difficulty");
 
 						pref.log("Trying terrain");
-						chD.setTerrain(getTerr(completeWebPage));
-						if (pref.debug) pref.log("Terr: " + chD.getTerrain());
+						ch.setTerrain(getTerr(completeWebPage));
+						if (pref.debug) pref.log("Terr: " + ch.getTerrain());
 						else pref.log("Got terrain");
 
 						pref.log("Trying cache type");
-						chD.setType(getType(completeWebPage));
-						if (pref.debug) pref.log("Type: " + chD.getType());
+						ch.setType(getType(completeWebPage));
+						if (pref.debug) pref.log("Type: " + ch.getType());
 						else pref.log("Got cache type");
 
 						//==========
 						// Logs
 						//==========
 						pref.log("Trying logs");
-						chD.setCacheLogs(getLogs(completeWebPage, chD));
+						ch.getFreshDetails().setCacheLogs(getLogs(completeWebPage, ch.getFreshDetails()));
 						pref.log("Found logs");
 
 						// If the switch is set to not store found caches and we found the cache => return
-						if (chD.is_found() && doNotGetFound) {
+						if (ch.is_found() && doNotGetFound) {
 							if (infB.isClosed) {
 								return -1;
 							} else {
@@ -767,15 +756,15 @@
 						// Bugs
 						//==========
 						// As there may be several bugs, we check whether the user has aborted
-						if (!infB.isClosed) getBugs(chD,completeWebPage);
-						chD.setHas_bugs(chD.Travelbugs.size()>0);
+						if (!infB.isClosed) getBugs(ch.getFreshDetails(),completeWebPage);
+						ch.setHas_bugs(ch.getFreshDetails().Travelbugs.size()>0);
 
 						//==========
 						// Images
 						//==========
 						if(fetchImages){
 							pref.log("Trying images");
-							getImages(completeWebPage, chD);
+							getImages(completeWebPage, ch.getFreshDetails());
 							pref.log("Got images");
 						}
 						//==========
@@ -783,20 +772,20 @@
 						//==========
 
 						pref.log("Getting additional waypoints");
-						getAddWaypoints(completeWebPage, chD.getWayPoint(), chD.is_found());
+						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch.is_found());
 						pref.log("Got additional waypoints");
 
 						//==========
 						// Attributes
 						//==========
 						pref.log("Getting attributes");
-						getAttributes(completeWebPage, chD);
+						getAttributes(completeWebPage, ch.getFreshDetails());
 						pref.log("Got attributes");
-						if (chD.is_new()) chD.setUpdated(false);
-						chD.setIncomplete(false);
+						if (ch.is_new()) ch.setUpdated(false);
+						ch.setIncomplete(false);
 						break;
 					}catch(Exception ex){
-						pref.log("Error reading cache: "+chD.getWayPoint());
+						pref.log("Error reading cache: "+ch.getWayPoint());
 						pref.log("Exception in getCacheByWaypointName: ",ex);
 					}
 					finally{}
@@ -1031,8 +1020,8 @@
 			String d=DateFormat.logdate2YMD(exDate.findNext());
 			if((icon.equals(p.getProp("icon_smile")) || icon.equals(p.getProp("icon_camera")) || icon.equals(p.getProp("icon_attended"))) &&
 				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && name.equalsIgnoreCase(pref.myAlias2))) )  {
-				chD.setFound(true);
-				chD.setCacheStatus(d);
+				chD.getParent().setFound(true);
+				chD.getParent().setCacheStatus(d);
 				chD.OwnLogId = logId;
 				chD.OwnLog = new Log(icon,d,name,logText);
 			}
@@ -1048,7 +1037,7 @@
 			exLogId.setSource(singleLog);
 			// We cannot simply stop if we have reached MAXLOGS just in case we are waiting for
 			// a log by our alias that happened earlier.
-			if (nLogs>=MAXLOGS && chD.is_found() && (chD.OwnLogId.length() != 0) && (chD.OwnLog != null) && !(chD.OwnLog.getDate().equals("1900-01-01"))) break;
+			if (nLogs>=MAXLOGS && chD.getParent().is_found() && (chD.OwnLogId.length() != 0) && (chD.OwnLog != null) && !(chD.OwnLog.getDate().equals("1900-01-01"))) break;
 		}
 		if (nLogs>MAXLOGS) {
 			reslts.add(Log.maxLog());
@@ -1118,7 +1107,7 @@
 		//========
 		String longDesc = "";
 		try {
-			if (chD.getWayPoint().startsWith("TC")) longDesc = doc;
+			if (chD.getParent().getWayPoint().startsWith("TC")) longDesc = doc;
 			else
 				longDesc = getLongDesc(doc);
 			longDesc = STRreplace.replace(longDesc, "<img", "<IMG");
@@ -1144,7 +1133,7 @@
 					if(imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")){
 						// Check whether image was already spidered for this cache
 						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.getWayPoint() + "_" + Convert.toString(imgCounter);
+						imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
 						if (idxUrl<0) { // New image
 							pref.log("Loading image: " + imgUrl+" as "+imgName);
 							spiderImage(imgUrl, imgName+imgType);
@@ -1152,7 +1141,7 @@
 							spideredUrls.add(imgUrl);
 						} else { // Image already spidered as wayPoint_'idxUrl'
 							pref.log("Already loaded image: " + imgUrl);
-							oldImgName = chD.getWayPoint() + "_" + Convert.toString(idxUrl);
+							oldImgName = chD.getParent().getWayPoint() + "_" + Convert.toString(idxUrl);
 							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
 						}
 						chD.ImagesText.add(imgName); // Keep the image name
@@ -1191,14 +1180,14 @@
 					if(imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")){
 						// Check whether image was already spidered for this cache
 						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.getWayPoint() + "_" + Convert.toString(imgCounter);
+						imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
 						if (idxUrl<0) { // New image
 							pref.log("Loading image: " + imgUrl);
 							spiderImage(imgUrl, imgName+imgType);
 							chD.Images.add(imgName+imgType);
 						} else { // Image already spidered as wayPoint_ 'idxUrl'
 							pref.log("Already loaded image: " + imgUrl);
-							oldImgName = chD.getWayPoint() + "_" + Convert.toString(idxUrl);
+							oldImgName = chD.getParent().getWayPoint() + "_" + Convert.toString(idxUrl);
 							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
 						}
 						chD.ImagesText.add(exImgName.findNext()); // Keep the image description
@@ -1231,7 +1220,7 @@
 						// Check whether image was already spidered for this cache
 						idxUrl=spideredUrls.find(imgUrl);
 						if (idxUrl<0) { // New image
-							imgName = chD.getWayPoint() + "_" + Convert.toString(imgCounter);
+							imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
 							pref.log("Loading image: " + imgUrl+" as "+imgName);
 							spiderImage(imgUrl, imgName+imgType);
 							chD.Images.add(imgName+imgType);
@@ -1317,7 +1306,7 @@
 			rowBlock = exRowBlock.findNext();
 			rowBlock = exRowBlock.findNext();
 			while(exRowBlock.endOfSearch()==false){
-				CacheHolderDetail cxD = new CacheHolderDetail();
+				CacheHolder hd = null;
 				Extractor exPrefix=new Extractor(rowBlock,p.getProp("prefixExStart"),p.getProp("prefixExEnd"),0,true);
 				String prefix=exPrefix.findNext();
 				String adWayPoint;
@@ -1328,35 +1317,36 @@
 				counter++;
 				int idx=profile.getCacheIndex(adWayPoint);
 				if (idx>=0) {
-					cxD=new CacheHolderDetail(cacheDB.get(idx));
-					try{ // If addi exists, try to read it to preserve the notes
-						cxD.readCache(profile.dataDir);
-					} catch (Exception ex) {};
+					// Creating new CacheHolder, but accessing old cache.xml file
+					hd=new CacheHolder();
+					hd.setWayPoint(adWayPoint);
+					hd.getExistingDetails(); // Accessing Details reads file if not yet done
 				} else {
-					cxD=new CacheHolderDetail(); cxD.setWayPoint(adWayPoint);
+					hd=new CacheHolder(); 
+					hd.setWayPoint(adWayPoint);
 				}
-				cxD.setUpdated(false); 
-				cxD.setNew(false);
+				hd.setUpdated(false); 
+				hd.setNew(false);
 				nameRex.search(rowBlock);
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
-				cxD.setCacheName(nameRex.stringMatched(1));
-				if(koordRex.didMatch()) cxD.setLatLon(koordRex.stringMatched(1));
-				if(typeRex.didMatch()) cxD.setType(CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1)));
+				hd.setCacheName(nameRex.stringMatched(1));
+				if(koordRex.didMatch()) hd.setLatLon(koordRex.stringMatched(1));
+				if(typeRex.didMatch()) hd.setType(CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1)));
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
-				cxD.setLongDescription(descRex.stringMatched(1));
-				cxD.setFound(is_found);
-				cxD.saveCacheDetails(profile.dataDir);
+				hd.getFreshDetails().setLongDescription(descRex.stringMatched(1));
+				hd.setFound(is_found);
+				hd.save();
 				if (idx<0){
-					cxD.setNew(true); 
-					cxD.setUpdated(false);
-					cacheDB.add(new CacheHolder(cxD));
+					hd.setNew(true); 
+					hd.setUpdated(false);
+					cacheDB.add(hd);
 				}else {
 					CacheHolder cx=cacheDB.get(idx);
 					if (cx.is_Checked && // Only re-spider existing addi waypoints that are ticked
 				 	   !cx.is_filtered()) { // and are visible (i.e.  not filtered)
-					   cx.update(cxD);
+					   cx.update(hd);
 					   cx.is_Checked=true;
 					}
 				}
@@ -1375,8 +1365,8 @@
 			chD.attributes.add(attribute);
 			attribute=attEx.findNext();
 		}
-		chD.setAttributesYes(chD.attributes.attributesYes);
-		chD.setAttributesNo(chD.attributes.attributesNo);
+		chD.getParent().setAttributesYes(chD.attributes.attributesYes);
+		chD.getParent().setAttributesNo(chD.attributes.attributesNo);
 	}
 
 

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -67,13 +67,8 @@
 			ch=cacheDB.get(curCacheNo);
 			cache=MyLocale.getMsg(6022,": Current cache: ")+ch.getWayPoint()+" - "+ch.getCacheName();
 			waypoint=ch.getWayPoint();
-			chD=new CacheHolderDetail(ch);
-			try {
-				chD.readCache(Global.getProfile().dataDir);
-			}catch (Exception ex) {
-				Global.getPref().log("Failed to read cache "+ch.getWayPoint());
-			};
-			tblSrcCache=chD.Travelbugs;
+			chD=ch.getExistingDetails();
+			tblSrcCache=ch.getExistingDetails().Travelbugs;
 		}
 		title="Travelbugs"+cache;
 		tcTbJourneyList=new tbListControl();
@@ -253,8 +248,8 @@
 			}
 			// If the list of travelbugs in the cache was modified, we need to save the cache too
 			if (chDmodified) {
-				chD.saveCacheDetails(Global.getProfile().dataDir);
 				ch.setHas_bugs(chD.Travelbugs.size()>0);
+				ch.save();
 			}
 			Vm.showWait(false);
 			chD=null;

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/myTableControl.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -189,9 +189,8 @@
 							nDeleted++;
 							h.progress = ((float)nDeleted)/(float)allCount;
 							h.changed();
-							dm.deleteCacheFiles(ch.getWayPoint(),profile.dataDir);
 							cacheDB.removeElementAt(i);
-							ch.releaseCacheDetails();
+							dm.deleteCacheFiles(ch.getWayPoint(),profile.dataDir);
 							ch=null;
 							if (pbf.isClosed) break;
 						}
@@ -250,7 +249,7 @@
 		if (selectedItem == miOpenOffline) {
 			if(browserPathIsValid()){
 				ShowCacheInBrowser sc=new ShowCacheInBrowser();
-				sc.showCache(cacheDB.get(tbp.getSelectedCache()).getCacheDetails(false, true));
+				sc.showCache(cacheDB.get(tbp.getSelectedCache()));
 			}
 		}
 		if (selectedItem == miOpen){

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -24,6 +24,7 @@
 	private static final Color COLOR_SELECTED	= new Color(198,198,198);
 	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived && Found
 	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);	
+	private static final Color COLOR_DETAILS_LOADED		= new Color(229,206,235);
 	private CacheDB cacheDB;
 	/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
 	 * the element j (as per the list below) is visible in column i. 
@@ -180,6 +181,7 @@
 				else if( ch.is_owned())     ta.fillColor = COLOR_OWNED;
 				else if( ch.is_found())     ta.fillColor = COLOR_FOUND;
 				else if( ch.is_flaged)        ta.fillColor = COLOR_FLAGED;
+				else if( Global.getPref().debug && ch.detailsLoaded()) ta.fillColor = COLOR_DETAILS_LOADED;
 			} catch (Exception e) {};
 		} else if (row==-1 && colMap[col]==0 && Global.getProfile().showBlacklisted()) ta.fillColor=Color.Black;
 		return ta;

Modified: trunk/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/CWGPSPoint.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/CacheWolf/navi/CWGPSPoint.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -143,7 +143,7 @@
 		if (doLogging){
 			try {
 				logFile.close();
-			} catch (IOException e) {}
+			} catch (IOException e) {/*Too lazy to do something */}
 			if (logTimer > 0) {
 				Vm.cancelTimer(logTimer);
 				logTimer = 0;

Modified: trunk/src/exp/ASCExporter.java
===================================================================
--- trunk/src/exp/ASCExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/ASCExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -19,7 +19,7 @@
 		this();
 	}
 	
-	public String record (CacheHolderDetail holder, String lat, String lon){
+	public String record (CacheHolder holder, String lat, String lon){
 		StringBuffer strBuf = new StringBuffer(100);
 		String dummy;
 		dummy = holder.getCacheName();

Modified: trunk/src/exp/ExploristExporter.java
===================================================================
--- trunk/src/exp/ExploristExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/ExploristExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -105,7 +105,6 @@
 		String fileBaseName;
 		String str = null;
 		CacheHolder ch;
-		CacheHolderDetail holder;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
@@ -148,18 +147,10 @@
 										/ 200 + ".gs"))));
 					}
 
-					holder = new CacheHolderDetail(ch);
 					expCount++;
 					h.progress = (float) expCount / (float) counter;
 					h.changed();
-					try {
-						if (needCacheDetails) {
-							holder.readCache(profile.dataDir);
-						}
-					} catch (IOException e) {
-						continue;
-					}
-					str = record(holder);
+					str = record(ch);
 					if (str != null)
 						outp.print(str);
 				}// if
@@ -205,7 +196,8 @@
 	 *            cachedata
 	 * @return formated cache data
 	 */
-	public String record(CacheHolderDetail chD) {
+	public String record(CacheHolder ch) {
+		CacheHolderDetail det = ch.getExistingDetails();
 		/*
 		static protected final int GC_AW_PARKING = 50;
 		static protected final int GC_AW_STAGE_OF_MULTI = 51;
@@ -216,65 +208,65 @@
 		*/
 		StringBuffer sb = new StringBuffer();
 		sb.append("$PMGNGEO,");
-		sb.append(chD.pos.getLatDeg(CWPoint.DMM));
-		sb.append(chD.pos.getLatMin(CWPoint.DMM));
+		sb.append(ch.pos.getLatDeg(CWPoint.DMM));
+		sb.append(ch.pos.getLatMin(CWPoint.DMM));
 		sb.append(",");
 		sb.append("N,");
-		sb.append(chD.pos.getLonDeg(CWPoint.DMM));
-		sb.append(chD.pos.getLonMin(CWPoint.DMM));
+		sb.append(ch.pos.getLonDeg(CWPoint.DMM));
+		sb.append(ch.pos.getLonMin(CWPoint.DMM));
 		sb.append(",");
 		sb.append("E,");
 		sb.append("0000,"); // Height
 		sb.append("M,"); // in meter
-		sb.append(chD.getWayPoint());
+		sb.append(ch.getWayPoint());
 		sb.append(",");
 		String add = "";
-		if (chD.isAddiWpt()) {
-			if (chD.getType() == 50) {
+		if (ch.isAddiWpt()) {
+			if (ch.getType() == 50) {
 				add = "Pa:";
-			} else if (chD.getType() == 51) {
+			} else if (ch.getType() == 51) {
 				add = "St:";
-			} else if (chD.getType() == 52) {
+			} else if (ch.getType() == 52) {
 				add = "Qu:"; 
-			} else if (chD.getType() == 53) {	
+			} else if (ch.getType() == 53) {	
 				add = "Fi:";
-			} else if (chD.getType() == 54) {
+			} else if (ch.getType() == 54) {
 				add = "Tr:";
-			} else if (chD.getType() == 55) {	
+			} else if (ch.getType() == 55) {	
 				add = "Re:";
 			}
-			sb.append(add).append(removeCommas(chD.getCacheName()));
+			sb.append(add).append(removeCommas(ch.getCacheName()));
 		} else {
-			sb.append(removeCommas(chD.getCacheName()));
+			sb.append(removeCommas(ch.getCacheName()));
 		}		
 		sb.append(",");
-		sb.append(removeCommas(chD.getCacheOwner()));
+		sb.append(removeCommas(ch.getCacheOwner()));
 		sb.append(",");
-		sb.append(removeCommas(Common.rot13(chD.Hints)));
+		sb.append(removeCommas(Common.rot13(det.Hints)));
 		sb.append(",");
 		
 		if (!add.equals("")) { // Set Picture in Explorist to Virtual
 			sb.append("Virtual Cache");
-		} else if (chD.getType() != 8) { // Rewrite Unknown Caches
-			sb.append(CacheType.transType(chD.getType()));
+		} else if (ch.getType() != 8) { // Rewrite Unknown Caches
+			sb.append(CacheType.transType(ch.getType()));
 		} else {
 			sb.append("Mystery Cache");
 		}
 		sb.append(",");
-		sb.append(toGsDateFormat(chD.getDateHidden()));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(toGsDateFormat(ch.getDateHidden()));  // created - DDMMYYY, YYY = year - 1900
 		sb.append(",");
 		String lastFound = "0000";
-		for (int i = 0; i < chD.CacheLogs.size(); i++) {
-			if (chD.CacheLogs.getLog(i).isFoundLog() && chD.CacheLogs.getLog(i).getDate().compareTo(lastFound) > 0 ) {
-				lastFound = chD.CacheLogs.getLog(i).getDate();
+		for (int i = 0; i < det.CacheLogs.size(); i++) {
+			if (det.CacheLogs.getLog(i).isFoundLog() && det.CacheLogs.getLog(i).getDate().compareTo(lastFound) > 0 ) {
+				lastFound = det.CacheLogs.getLog(i).getDate();
 			}
 		}
 		
 		sb.append(toGsDateFormat(lastFound)); // lastFound - DDMMYYY, YYY = year - 1900
 		sb.append(",");
-		sb.append(removeCommas(chD.getHard()));
+		sb.append(removeCommas(ch.getHard()));
 		sb.append(",");
-		sb.append(removeCommas(chD.getTerrain()));
+		sb.append(removeCommas(ch.getTerrain()));
 		sb.append("*41");
 		return Exporter.simplifyString(sb.toString() + "\r\n");
 	}

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/Exporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -74,7 +74,6 @@
 		File outFile;
 		String str;
 		CacheHolder ch;
-		CacheHolderDetail holder;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
@@ -101,29 +100,25 @@
 			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
 			str = this.header();
 			if (str != null) outp.print(str);
-			holder=new CacheHolderDetail();
 			for(int i = 0; i<cacheDB.size(); i++){
 				ch=cacheDB.get(i);
 				if(ch.is_black() == false && ch.is_filtered() == false){
 					expCount++;
 					h.progress = (float)expCount/(float)counter;
 					h.changed();
-					if (needCacheDetails) holder = ch.getCacheDetails(false, false);
-					else holder.update(ch);
-					if (needCacheDetails && holder == null) continue;
 					switch (this.howManyParams) {
 					case NO_PARAMS:
-						str = record(holder);
+						str = record(ch);
 						break;
 					case LAT_LON:
-						if (holder.pos.isValid() == false) continue;
-						str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.pos.isValid() == false) continue;
+						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
 					case LAT_LON|COUNT: 
-						if (holder.pos.isValid() == false) continue;
-						str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-									 holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+						if (ch.pos.isValid() == false) continue;
+						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+									 ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
 											 i);
 						break;
 					default:
@@ -219,7 +214,7 @@
 	 * @param ch	cachedata
 	 * @return formated cache data
 	 */	
-	public String record(CacheHolderDetail chD){
+	public String record(CacheHolder chD){
 		return null;
 	}
 
@@ -230,7 +225,7 @@
 	 * @param lon
 	 * @return formated cache data
 	 */
-	public String record(CacheHolderDetail ch, String lat, String lon){
+	public String record(CacheHolder ch, String lat, String lon){
 		return null;
 	}
 	/**
@@ -241,7 +236,7 @@
 	 * @param count of actual record
 	 * @return formated cache data
 	 */
-	public String record(CacheHolderDetail ch, String lat, String lon, int count){
+	public String record(CacheHolder ch, String lat, String lon, int count){
 		return null;
 	}
 	

Modified: trunk/src/exp/GPXExporter.java
===================================================================
--- trunk/src/exp/GPXExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/GPXExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -50,9 +50,9 @@
 		return strBuf.toString();
 	}
 	
-	public String record(CacheHolderDetail ch, String lat, String lon, int counter) {
+	public String record(CacheHolder ch, String lat, String lon, int counter) {
 		StringBuffer strBuf = new StringBuffer(1000);
-
+		CacheHolderDetail det = ch.getExistingDetails();
 		try{
 			strBuf.append("  <wpt lat=\""+lat+"\" lon=\""+lon+"\">\r\n");
 		
@@ -60,7 +60,7 @@
 			strBuf.append("    <time>").append(tim.toString()).append("T00:00:00.0000000-07:00</time>\r\n");
 			strBuf.append("    <name>").append(ch.getWayPoint()).append("</name>\r\n");
 			if (ch.isAddiWpt()){
-				strBuf.append("    <cmt>").append(SafeXML.cleanGPX(ch.LongDescription)).append("</cmt>\r\n");
+				strBuf.append("    <cmt>").append(SafeXML.cleanGPX(det.LongDescription)).append("</cmt>\r\n");
 			}
 			strBuf.append("    <desc>").append(SafeXML.cleanGPX(ch.getCacheName())).append(" by ").append(SafeXML.cleanGPX(ch.getCacheOwner())).append("</desc>\r\n");
 			strBuf.append("    <url>http://www.geocaching.com/seek/cache_details.aspx?wp=").append(ch.getWayPoint()).append("&amp;Submit6=Find</url>\r\n");
@@ -93,53 +93,53 @@
 				}
 				strBuf.append("      <groundspeak:terrain>").append(diffTerr).append("</groundspeak:terrain>\r\n");
 				
-				strBuf.append("      <groundspeak:country>").append(SafeXML.cleanGPX(ch.Country)+"</groundspeak:country>\r\n");
-				strBuf.append("      <groundspeak:state>").append(SafeXML.cleanGPX(ch.State)+"</groundspeak:state>\r\n");
+				strBuf.append("      <groundspeak:country>").append(SafeXML.cleanGPX(det.Country)+"</groundspeak:country>\r\n");
+				strBuf.append("      <groundspeak:state>").append(SafeXML.cleanGPX(det.State)+"</groundspeak:state>\r\n");
 												
 				String dummyHTML = ch.is_HTML() ? STRING_TRUE:STRING_FALSE;
 				strBuf.append("      <groundspeak:long_description html=\"" ).append( dummyHTML ).append( "\">\r\n");
-				strBuf.append("      ").append(SafeXML.cleanGPX(ch.LongDescription));
+				strBuf.append("      ").append(SafeXML.cleanGPX(det.LongDescription));
 				strBuf.append("      \n</groundspeak:long_description>\r\n");
-				strBuf.append("	  <groundspeak:encoded_hints>").append(SafeXML.cleanGPX(Common.rot13(ch.Hints))).append("</groundspeak:encoded_hints>\r\n");
+				strBuf.append("	  <groundspeak:encoded_hints>").append(SafeXML.cleanGPX(Common.rot13(det.Hints))).append("</groundspeak:encoded_hints>\r\n");
 				strBuf.append("      <groundspeak:logs>\r\n");
 				if ( Global.getPref().exportGpxAsMyFinds && ch.is_found() ) {
-					if ( ch.OwnLogId.length() != 0 ) {
-						strBuf.append("        <groundspeak:log id=\"" ).append( ch.OwnLogId ).append( "\">\r\n");						
+					if ( det.OwnLogId.length() != 0 ) {
+						strBuf.append("        <groundspeak:log id=\"" ).append( det.OwnLogId ).append( "\">\r\n");						
 					} else {
 						strBuf.append("        <groundspeak:log id=\"" ).append( Integer.toString(counter) ).append( "\">\r\n");
 					}
 					strBuf.append("          <groundspeak:date>").append(SafeXML.cleanGPX(ch.GetStatusDate())).append("T").append(SafeXML.cleanGPX(ch.GetStatusTime())).append(":00</groundspeak:date>\r\n");
-					if ( ch.OwnLog != null ) {
-						strBuf.append("          <groundspeak:type>").append(image2TypeText(ch.OwnLog.getIcon())).append("</groundspeak:type>\r\n");
+					if ( det.OwnLog != null ) {
+						strBuf.append("          <groundspeak:type>").append(image2TypeText(det.OwnLog.getIcon())).append("</groundspeak:type>\r\n");
 					} else {
 						strBuf.append("          <groundspeak:type>Found it</groundspeak:type>\r\n");
 					}
 					strBuf.append("          <groundspeak:finder id=\"").append(SafeXML.cleanGPX(Global.getPref().gcMemberId)).append("\">").append(SafeXML.cleanGPX(Global.getPref().myAlias)).append("</groundspeak:finder>\r\n");
-					if ( ch.OwnLog != null ) {
-						strBuf.append("          <groundspeak:text encoded=\"False\">").append(SafeXML.cleanGPX(ch.OwnLog.getMessage())).append("</groundspeak:text>\r\n");
+					if ( det.OwnLog != null ) {
+						strBuf.append("          <groundspeak:text encoded=\"False\">").append(SafeXML.cleanGPX(det.OwnLog.getMessage())).append("</groundspeak:text>\r\n");
 					} else {
 						strBuf.append("          <groundspeak:text encoded=\"False\"></groundspeak:text>\r\n");		
 					}
 					strBuf.append("        </groundspeak:log>\r\n");
 				} else {
-					int numberOfLogs = java.lang.Math.min(Global.getPref().numberOfLogsToExport, ch.CacheLogs.size());
-					if (numberOfLogs < 0) numberOfLogs = ch.CacheLogs.size();
+					int numberOfLogs = java.lang.Math.min(Global.getPref().numberOfLogsToExport, det.CacheLogs.size());
+					if (numberOfLogs < 0) numberOfLogs = det.CacheLogs.size();
 					for (int i = 0; i < numberOfLogs; i++) {
 						strBuf.append("        <groundspeak:log id=\"" ).append( Integer.toString(i) ).append( "\">\r\n");
-						strBuf.append("          <groundspeak:date>").append(SafeXML.cleanGPX(ch.CacheLogs.getLog(i).getDate())).append("T00:00:00</groundspeak:date>\r\n");
-						strBuf.append("          <groundspeak:type>").append(image2TypeText(ch.CacheLogs.getLog(i).getIcon())).append("</groundspeak:type>\r\n");
-						strBuf.append("          <groundspeak:finder id=\"\">").append(SafeXML.cleanGPX(ch.CacheLogs.getLog(i).getLogger())).append("</groundspeak:finder>\r\n");
-						strBuf.append("          <groundspeak:text encoded=\"False\">").append(SafeXML.cleanGPX(ch.CacheLogs.getLog(i).getMessage())).append("</groundspeak:text>\r\n");
+						strBuf.append("          <groundspeak:date>").append(SafeXML.cleanGPX(det.CacheLogs.getLog(i).getDate())).append("T00:00:00</groundspeak:date>\r\n");
+						strBuf.append("          <groundspeak:type>").append(image2TypeText(det.CacheLogs.getLog(i).getIcon())).append("</groundspeak:type>\r\n");
+						strBuf.append("          <groundspeak:finder id=\"\">").append(SafeXML.cleanGPX(det.CacheLogs.getLog(i).getLogger())).append("</groundspeak:finder>\r\n");
+						strBuf.append("          <groundspeak:text encoded=\"False\">").append(SafeXML.cleanGPX(det.CacheLogs.getLog(i).getMessage())).append("</groundspeak:text>\r\n");
 						strBuf.append("        </groundspeak:log>\r\n");
 					}
 				}
 				strBuf.append("      </groundspeak:logs>\r\n");
-				if ( Global.getPref().exportTravelbugs && (ch.Travelbugs.size() > 0) ) {
-					ch.Travelbugs.size();
+				if ( Global.getPref().exportTravelbugs && (det.Travelbugs.size() > 0) ) {
+					det.Travelbugs.size();
 					strBuf.append("      <groundspeak:travelbugs>\r\n");
-					for (int i = 0; i < ch.Travelbugs.size(); i++) {
+					for (int i = 0; i < det.Travelbugs.size(); i++) {
 						strBuf.append("        <groundspeak:travelbug id=\"").append(Integer.toString(i)).append("\" ref=\"\">\r\n");
-						strBuf.append("          <groundspeak:name>").append(SafeXML.cleanGPX(ch.Travelbugs.getTB(i).getName())).append("</groundspeak:name>\r\n");
+						strBuf.append("          <groundspeak:name>").append(SafeXML.cleanGPX(det.Travelbugs.getTB(i).getName())).append("</groundspeak:name>\r\n");
 						strBuf.append("        </groundspeak:travelbug>\r\n");						
 					}
 					strBuf.append("      </groundspeak:travelbugs>\r\n");					

Modified: trunk/src/exp/HTMLExporter.java
===================================================================
--- trunk/src/exp/HTMLExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/HTMLExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -40,7 +40,7 @@
 	}
 	
 	public void doIt(){
-		CacheHolderDetail holder;
+		CacheHolderDetail det;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
@@ -83,63 +83,63 @@
 
 				ch = cacheDB.get(i);
 				if(	ch.is_black() == false && ch.is_filtered() == false){
-					holder=ch.getCacheDetails(false,true);
+					det=ch.getExistingDetails();
 					varParams = new Hashtable();
-					varParams.put("TYPE", CacheType.transType(holder.getType()));
-					varParams.put("SIZE", holder.getCacheSize());
-					varParams.put("WAYPOINT", holder.getWayPoint());
-					varParams.put("NAME", holder.getCacheName());
-					varParams.put("OWNER", holder.getCacheOwner());
-					varParams.put("DIFFICULTY", holder.getHard());
-					varParams.put("TERRAIN", holder.getTerrain());
-					varParams.put("DISTANCE", holder.getDistance());
-					varParams.put("BEARING", holder.bearing);
-					varParams.put("LATLON", holder.LatLon);
-					varParams.put("STATUS", holder.getCacheStatus());
-					varParams.put("DATE", holder.getDateHidden());
+					varParams.put("TYPE", CacheType.transType(ch.getType()));
+					varParams.put("SIZE", ch.getCacheSize());
+					varParams.put("WAYPOINT", ch.getWayPoint());
+					varParams.put("NAME", ch.getCacheName());
+					varParams.put("OWNER", ch.getCacheOwner());
+					varParams.put("DIFFICULTY", ch.getHard());
+					varParams.put("TERRAIN", ch.getTerrain());
+					varParams.put("DISTANCE", ch.getDistance());
+					varParams.put("BEARING", ch.bearing);
+					varParams.put("LATLON", ch.LatLon);
+					varParams.put("STATUS", ch.getCacheStatus());
+					varParams.put("DATE", ch.getDateHidden());
 					cache_index.add(varParams);
 					//We can generate the individual page here!
 					try{
 						Template page_tpl = new Template(template_init_page);
-						page_tpl.setParam("TYPE", CacheType.transType(holder.getType()));
-						page_tpl.setParam("SIZE", holder.getCacheSize());
-						page_tpl.setParam("WAYPOINT", holder.getWayPoint());
-						page_tpl.setParam("NAME", holder.getCacheName());
-						page_tpl.setParam("OWNER", holder.getCacheOwner());
-						page_tpl.setParam("DIFFICULTY", holder.getHard());
-						page_tpl.setParam("TERRAIN", holder.getTerrain());
-						page_tpl.setParam("DISTANCE", holder.getDistance());
-						page_tpl.setParam("BEARING", holder.bearing);
-						page_tpl.setParam("LATLON", holder.LatLon);
-						page_tpl.setParam("STATUS", holder.getCacheStatus());
-						page_tpl.setParam("DATE", holder.getDateHidden());
-						if (holder.is_HTML())
-							page_tpl.setParam("DESCRIPTION", modifyLongDesc(holder,targetDir));
+						page_tpl.setParam("TYPE", CacheType.transType(ch.getType()));
+						page_tpl.setParam("SIZE", ch.getCacheSize());
+						page_tpl.setParam("WAYPOINT", ch.getWayPoint());
+						page_tpl.setParam("NAME", ch.getCacheName());
+						page_tpl.setParam("OWNER", ch.getCacheOwner());
+						page_tpl.setParam("DIFFICULTY", ch.getHard());
+						page_tpl.setParam("TERRAIN", ch.getTerrain());
+						page_tpl.setParam("DISTANCE", ch.getDistance());
+						page_tpl.setParam("BEARING", ch.bearing);
+						page_tpl.setParam("LATLON", ch.LatLon);
+						page_tpl.setParam("STATUS", ch.getCacheStatus());
+						page_tpl.setParam("DATE", ch.getDateHidden());
+						if (ch.is_HTML())
+							page_tpl.setParam("DESCRIPTION", modifyLongDesc(det,targetDir));
 						else {
 							String dummyText = new String();
-							dummyText = STRreplace.replace(holder.LongDescription, "\n", "<br>");
+							dummyText = STRreplace.replace(det.LongDescription, "\n", "<br>");
 							page_tpl.setParam("DESCRIPTION",dummyText);
 							
 						}
-						page_tpl.setParam("HINTS", holder.Hints);
-						page_tpl.setParam("DECRYPTEDHINTS", Common.rot13(holder.Hints));
+						page_tpl.setParam("HINTS", det.Hints);
+						page_tpl.setParam("DECRYPTEDHINTS", Common.rot13(det.Hints));
 						StringBuffer sb=new StringBuffer(2000);
-						for(int j = 0; j<holder.CacheLogs.size(); j++){
-							sb.append(STRreplace.replace(holder.CacheLogs.getLog(j).toHtml(),"http://www.geocaching.com/images/icons/",null));
+						for(int j = 0; j<det.CacheLogs.size(); j++){
+							sb.append(STRreplace.replace(det.CacheLogs.getLog(j).toHtml(),"http://www.geocaching.com/images/icons/",null));
 							sb.append("<br>");
-							icon=holder.CacheLogs.getLog(j).getIcon();
+							icon=det.CacheLogs.getLog(j).getIcon();
 							if (logIcons.find(icon)<0) logIcons.add(icon); // Add the icon to list of icons to copy to dest directory
 						}
 						page_tpl.setParam("LOGS", sb.toString());
-						page_tpl.setParam("NOTES", STRreplace.replace(holder.CacheNotes, "\n","<br>")); 
+						page_tpl.setParam("NOTES", STRreplace.replace(det.CacheNotes, "\n","<br>")); 
 						// Cache Images
 						cacheImg.clear();
-						for(int j = 0; j<holder.Images.size(); j++){
+						for(int j = 0; j<det.Images.size(); j++){
 							imgParams = new Hashtable();
-							String imgFile = new String((String)holder.Images.get(j));
+							String imgFile = new String((String)det.Images.get(j));
 							imgParams.put("FILE", imgFile);
-							if (j < holder.ImagesText.size())
-								imgParams.put("TEXT",holder.ImagesText.get(j));
+							if (j < det.ImagesText.size())
+								imgParams.put("TEXT",det.ImagesText.get(j));
 							else
 								imgParams.put("TEXT",imgFile);
 							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
@@ -148,12 +148,12 @@
 						page_tpl.setParam("cacheImg", cacheImg);
 						// Log images
 						logImg.clear();
-						for(int j = 0; j<holder.LogImages.size(); j++){
+						for(int j = 0; j<det.LogImages.size(); j++){
 							logImgParams = new Hashtable();
-							String logImgFile = (String) holder.LogImages.get(j);
+							String logImgFile = (String) det.LogImages.get(j);
 							logImgParams.put("FILE", logImgFile);
-							if (j < holder.LogImagesText.size())
-								logImgParams.put("TEXT",holder.LogImagesText.get(j));
+							if (j < det.LogImagesText.size())
+								logImgParams.put("TEXT",det.LogImagesText.get(j));
 							else
 								logImgParams.put("TEXT",logImgFile);
 							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
@@ -162,12 +162,12 @@
 						page_tpl.setParam("logImg", logImg);
 						// User images
 						usrImg.clear();
-						for(int j = 0; j<holder.UserImages.size(); j++){
+						for(int j = 0; j<det.UserImages.size(); j++){
 							usrImgParams = new Hashtable();
-							String usrImgFile = new String((String)holder.UserImages.get(j));
+							String usrImgFile = new String((String)det.UserImages.get(j));
 							usrImgParams.put("FILE", usrImgFile);
-							if (j < holder.UserImagesText.size())
-								usrImgParams.put("TEXT",holder.UserImagesText.get(j));
+							if (j < det.UserImagesText.size())
+								usrImgParams.put("TEXT",det.UserImagesText.get(j));
 							else
 								usrImgParams.put("TEXT",usrImgFile);
 							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
@@ -178,7 +178,7 @@
 						// Map images
 						mapImg.clear();
 						mapImgParams = new Hashtable();
-						String mapImgFile = new String(holder.getWayPoint() + "_map.gif");
+						String mapImgFile = new String(ch.getWayPoint() + "_map.gif");
 						// check if map file exists
 						File test = new File(profile.dataDir + mapImgFile);
 						if (test.exists()) {
@@ -188,7 +188,7 @@
 							mapImg.add(mapImgParams);
 							
 							mapImgParams = new Hashtable();
-							mapImgFile = holder.getWayPoint() + "_map_2.gif";
+							mapImgFile = ch.getWayPoint() + "_map_2.gif";
 							mapImgParams.put("FILE", mapImgFile);
 							mapImgParams.put("TEXT",mapImgFile);
 							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
@@ -198,7 +198,7 @@
 						}
 
 						
-						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.getWayPoint()+".html")));
+						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + ch.getWayPoint()+".html")));
 						pagefile.print(page_tpl.output());
 						pagefile.close();
 					}catch(Exception e){

Modified: trunk/src/exp/KMLExporter.java
===================================================================
--- trunk/src/exp/KMLExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/KMLExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -109,30 +109,23 @@
 						h.progress = (float)expCount/(float)counter;
 						h.changed();
 						
-						holder=new CacheHolderDetail(ch);
-						try {
-							holder.readCache(profile.dataDir);
-						} catch (IOException e) {
-							continue;
-						}
-						if (holder.pos.isValid()){
-							str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.pos.isValid()){
+							str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 							if (str != null) outp.print(str);
 						}
 						if (ch.hasAddiWpt()){
 							boolean createdAdditionalWaypointsFolder = false;
 							for(int j = 0; j<ch.addiWpts.size(); j++){
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
-								holder=new CacheHolderDetail(addiWpt);
 								expCount++;
-								if (holder.pos.isValid() &&  ! holder.is_filtered()){
+								if (ch.pos.isValid() &&  ! addiWpt.is_filtered()){
 									if (! createdAdditionalWaypointsFolder) {
 										outp.print(startFolder("Additional Waypoints", false));
 										createdAdditionalWaypointsFolder = true;
 									}
-									str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-										     holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+									str = record(addiWpt, addiWpt.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+											addiWpt.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 									if (str != null) outp.print(str);
 								}
 								
@@ -272,12 +265,13 @@
 	}
 
 
-	public String record(CacheHolderDetail ch, String lat, String lon){
+	public String record(CacheHolder ch, String lat, String lon){
 		StringBuffer strBuf = new StringBuffer(200);
+		CacheHolderDetail det = ch.getExistingDetails();
 		
 		strBuf.append("   <Placemark>\r\n");
-		if (ch.URL != null){
-			strBuf.append("      <description>"+SafeXML.clean(ch.URL)+"</description>\r\n");
+		if (det.URL != null){
+			strBuf.append("      <description>"+SafeXML.clean(det.URL)+"</description>\r\n");
 		}
 		strBuf.append("      <name>"+ ch.getWayPoint() + " - " + SafeXML.clean(ch.getCacheName()) +"</name>\r\n");
 		strBuf.append("      <LookAt>\r\n");
@@ -313,7 +307,7 @@
 		return strBuf.toString();
 	}
 	
-	private String getColor(CacheHolderDetail ch){
+	private String getColor(CacheHolder ch){
 		if (ch.is_found()) return COLOR_FOUND;
 		if (ch.is_owned()) return COLOR_OWNED;
 		if (ch.is_archived() || !ch.is_available()) return COLOR_NOT_AVAILABLE;

Modified: trunk/src/exp/LocExporter.java
===================================================================
--- trunk/src/exp/LocExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/LocExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -35,14 +35,16 @@
 		return "<?xml version=\"1.0\"?><loc version=\"1.0\" src=\"EasyGPS\">\r\n";
 	}
 	
-	public String record(CacheHolderDetail chD){
+	public String record(CacheHolder ch){
+		CacheHolderDetail det = ch.getExistingDetails();
+		
 		// filter out not valid coords
-		if (!chD.pos.isValid()) return null;
+		if (!ch.pos.isValid()) return null;
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append("<waypoint>\r\n   <name id=\"");
-		String wptName=simplifyString(chD.getWayPoint());
+		String wptName=simplifyString(ch.getWayPoint());
 		if (Global.getPref().addDetailsToWaypoint) {
-			wptName += getShortDetails( chD );			
+			wptName += getShortDetails( ch );			
 		}
 		if (Global.getPref().garminMaxLen==0)
 			strBuf.append(wptName);
@@ -52,25 +54,25 @@
 			} catch (Exception ex){ pref.log("Invalid value for garmin.MaxWaypointLength"); }
 		}
 		strBuf.append("\"><![CDATA[");
-		strBuf.append(simplifyString(chD.getCacheName()));
+		strBuf.append(simplifyString(ch.getCacheName()));
 		if (Global.getPref().addDetailsToName) {
 			if ( !Global.getPref().addDetailsToWaypoint ) {
-				strBuf.append( getShortDetails( chD ) );
+				strBuf.append( getShortDetails( ch ) );
 			}
-			if ( (!chD.Hints.equals("null")) && (chD.Hints.length() > 0) ) {
+			if ( (!det.Hints.equals("null")) && (det.Hints.length() > 0) ) {
 				strBuf.append(":");
-				strBuf.append( simplifyString(Common.rot13(chD.Hints)) );			
+				strBuf.append( simplifyString(Common.rot13(det.Hints)) );			
 			}
 		}
 		strBuf.append("]]></name>\r\n   <coord lat=\"");
-		strBuf.append(chD.pos.getLatDeg(CWPoint.DD));
+		strBuf.append(ch.pos.getLatDeg(CWPoint.DD));
 		strBuf.append("\" lon=\"");
-		strBuf.append(chD.pos.getLonDeg(CWPoint.DD));
+		strBuf.append(ch.pos.getLonDeg(CWPoint.DD));
 		strBuf.append("\"/>\r\n   <type>");
 		if (gm!=null) {
-			strBuf.append(gm.getIcon(chD));
+			strBuf.append(gm.getIcon(ch));
 		} else {
-			if (chD.is_found())
+			if (ch.is_found())
 				strBuf.append("Geocache Found");
 			else
 				strBuf.append("Geocache");
@@ -115,19 +117,19 @@
 			}
 		}		
 		
-		public String getIcon(CacheHolderDetail chD) {
+		public String getIcon(CacheHolder ch) {
 			// First check if there is a mapping for "cache found"
-			if (chD.is_found()) {
+			if (ch.is_found()) {
 				for (int i=0; i<mapSize; i++)
 					// TODO Geht das noch sch?ner...? ................ <------------------------------>
-					if (symbols[i].onlyIfFound!=null && symbols[i].type.equals(String.valueOf(chD.getType()))) return symbols[i].name;
+					if (symbols[i].onlyIfFound!=null && symbols[i].type.equals(String.valueOf(ch.getType()))) return symbols[i].name;
 			}
 			// Now try mapping the cache irrespective of the "found" status
 			for (int i=0; i<mapSize; i++)
-				if (symbols[i].type.equals(String.valueOf(chD.getType()))) return symbols[i].name;
+				if (symbols[i].type.equals(String.valueOf(ch.getType()))) return symbols[i].name;
 		
 			// If it is not a mapped type, just use the standard mapping
-			if (chD.is_found())
+			if (ch.is_found())
 				return "Geocache Found";
 			else
 				return "Geocache";

Modified: trunk/src/exp/MSARCSVExporter.java
===================================================================
--- trunk/src/exp/MSARCSVExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/MSARCSVExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -22,7 +22,7 @@
 		return "Name;Breitengrad;L\u00E4ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink\r";
 	}
 
-	public String record(CacheHolderDetail ch, String lat, String lon) {
+	public String record(CacheHolder ch, String lat, String lon) {
 		StringBuffer str = new StringBuffer(200);
 		str.append("\"" + ch.getWayPoint() + " - " + ch.getCacheName() + "\";");
 		str.append(lat + ";" + lon +";");
@@ -30,7 +30,7 @@
 		str.append("\"" + ch.getCacheSize() + "\";");
 		str.append("\"" + ch.getWayPoint() + "\";");
 		str.append("\"" + ch.getDateHidden() + "\";");
-		str.append("\"" + ch.URL + "\"\r\n");
+		str.append("\"" + ch.getExistingDetails().URL + "\"\r\n");
 
 		return str.toString();
 	}

Modified: trunk/src/exp/OVLExporter.java
===================================================================
--- trunk/src/exp/OVLExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/OVLExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -14,7 +14,7 @@
 		this.setHowManyParams(LAT_LON|COUNT);
 	}
 	
-	public String record(CacheHolderDetail ch, String lat, String lon, int counter){
+	public String record(CacheHolder ch, String lat, String lon, int counter){
 		StringBuffer str = new StringBuffer(200);
 		double tmp;
 		str.append("[Symbol "+Convert.toString(2*counter + 1)+"]\r\n");

Modified: trunk/src/exp/OziExporter.java
===================================================================
--- trunk/src/exp/OziExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/OziExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -23,7 +23,7 @@
 		return strBuf.toString();
 	}
 
-	public String record(CacheHolderDetail ch, String lat, String lon){
+	public String record(CacheHolder ch, String lat, String lon){
 		StringBuffer strBuf = new StringBuffer(200);
 		String tmpName;
 

Modified: trunk/src/exp/PCX5Exporter.java
===================================================================
--- trunk/src/exp/PCX5Exporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/PCX5Exporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -34,7 +34,7 @@
 		return strBuf.toString();
 	}
 	
-	public String record(CacheHolderDetail ch){
+	public String record(CacheHolder ch){
 		StringBuffer strBuf = new StringBuffer(200);
 		String latlonstr, dummy;
 

Modified: trunk/src/exp/TPLExporter.java
===================================================================
--- trunk/src/exp/TPLExporter.java	2009-04-14 08:37:14 UTC (rev 1747)
+++ trunk/src/exp/TPLExporter.java	2009-04-17 16:41:09 UTC (rev 1748)
@@ -146,7 +146,7 @@
 	}
 	
 	public void doIt(){
-		CacheHolderDetail holder;
+		CacheHolderDetail det;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		ewe.sys.Handle h = new ewe.sys.Handle();
@@ -184,56 +184,50 @@
 
 			for(int i = 0; i<counter;i++){
 				ch = cacheDB.get(i);
+				det = ch.getExistingDetails();
 				h.progress = (float)i/(float)counter;
 				h.changed();
 				if(ch.is_black() == false && ch.is_filtered() == false){
 					if (ch.pos.isValid() == false) continue;
-					holder=new CacheHolderDetail(ch);
-					try{
-						holder.readCache(profile.dataDir);
-					}catch(Exception e){
-						Vm.debug("Problem reading cache page");
-						Global.getPref().log("Exception in TplExporter = Problem reading cache page, Cache: " + holder.getWayPoint(), e, true);
-					}
 					try {
 						Regex dec = new Regex("[,.]",myFilter.decSep);
 						if (myFilter.badChars != null) rex = new Regex("["+myFilter.badChars+"]","");
 						varParams = new Hashtable();
-						varParams.put("TYPE", CacheType.transType(holder.getType()));
-						varParams.put("SHORTTYPE", CacheType.transType(holder.getType()).substring(0,1));
-						varParams.put("SIZE", holder.getCacheSize());
-						varParams.put("SHORTSIZE", holder.getCacheSize().substring(0,1));
-						varParams.put("WAYPOINT", holder.getWayPoint());
-						varParams.put("OWNER", holder.getCacheOwner());
-						varParams.put("DIFFICULTY", dec.replaceAll(holder.getHard()));
-						varParams.put("TERRAIN", dec.replaceAll(holder.getTerrain()));
-						varParams.put("DISTANCE", dec.replaceAll(holder.getDistance()));
-						varParams.put("BEARING", holder.bearing);
-						varParams.put("LATLON", holder.LatLon);
-						varParams.put("LAT", dec.replaceAll(holder.pos.getLatDeg(CWPoint.DD)));
-						varParams.put("LON", dec.replaceAll(holder.pos.getLonDeg(CWPoint.DD)));
-						varParams.put("STATUS", holder.getCacheStatus());
-						varParams.put("STATUS_DATE", holder.GetStatusDate());
-						varParams.put("STATUS_TIME", holder.GetStatusTime());
-						varParams.put("DATE", holder.getDateHidden());
-						varParams.put("URL", holder.URL);
-						varParams.put("DESCRIPTION", holder.LongDescription);
+						varParams.put("TYPE", CacheType.transType(ch.getType()));
+						varParams.put("SHORTTYPE", CacheType.transType(ch.getType()).substring(0,1));
+						varParams.put("SIZE", ch.getCacheSize());
+						varParams.put("SHORTSIZE", ch.getCacheSize().substring(0,1));
+						varParams.put("WAYPOINT", ch.getWayPoint());
+						varParams.put("OWNER", ch.getCacheOwner());
+						varParams.put("DIFFICULTY", dec.replaceAll(ch.getHard()));
+						varParams.put("TERRAIN", dec.replaceAll(ch.getTerrain()));
+						varParams.put("DISTANCE", dec.replaceAll(ch.getDistance()));
+						varParams.put("BEARING", ch.bearing);
+						varParams.put("LATLON", ch.LatLon);
+						varParams.put("LAT", dec.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
+						varParams.put("LON", dec.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
+						varParams.put("STATUS", ch.getCacheStatus());
+						varParams.put("STATUS_DATE", ch.GetStatusDate());
+						varParams.put("STATUS_TIME", ch.GetStatusTime());
+						varParams.put("DATE", ch.getDateHidden());
+						varParams.put("URL", det.URL);
+						varParams.put("DESCRIPTION", det.LongDescription);
 						if (myFilter.badChars != null) {
-							varParams.put("NAME", rex.replaceAll(holder.getCacheName()));
-							varParams.put("NOTES", rex.replaceAll(holder.CacheNotes));
-							varParams.put("HINTS", rex.replaceAll(holder.Hints));
-							varParams.put("DECRYPTEDHINTS", rex.replaceAll(Common.rot13(holder.Hints)));
+							varParams.put("NAME", rex.replaceAll(ch.getCacheName()));
+							varParams.put("NOTES", rex.replaceAll(det.CacheNotes));
+							varParams.put("HINTS", rex.replaceAll(det.Hints));
+							varParams.put("DECRYPTEDHINTS", rex.replaceAll(Common.rot13(det.Hints)));
 						} else {
-							varParams.put("NAME", holder.getCacheName());
-							varParams.put("NOTES", holder.CacheNotes);
-							varParams.put("HINTS", holder.Hints);
-							varParams.put("DECRYPTEDHINTS", Common.rot13(holder.Hints));
+							varParams.put("NAME", ch.getCacheName());
+							varParams.put("NOTES", det.CacheNotes);
+							varParams.put("HINTS", det.Hints);
+							varParams.put("DECRYPTEDHINTS", Common.rot13(det.Hints));
 						}
 						cache_index.add(varParams);
 					}catch(Exception e){
-						Vm.debug("Problem getting Parameter, Cache: " + holder.getWayPoint());
+						Vm.debug("Problem getting Parameter, Cache: " + ch.getWayPoint());
 						e.printStackTrace();
-						Global.getPref().log("Exception in TplExporter = Problem getting Parameter, Cache: " + holder.getWayPoint(), e, true);
+						Global.getPref().log("Exception in TplExporter = Problem getting Parameter, Cache: " + ch.getWayPoint(), e, true);
 					}
 				}
 			}



From engywuck at mail.berlios.de  Fri Apr 17 20:44:55 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 20:44:55 +0200
Subject: [Cachewolf-svn] r1749 - trunk/src/CacheWolf
Message-ID: <200904171844.n3HIitlC027459@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 20:44:53 +0200 (Fri, 17 Apr 2009)
New Revision: 1749

Modified:
   trunk/src/CacheWolf/CacheDB.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Optimizing rebuild of cacheDB to reduce object creation and memory allocation to a minimum.

Modified: trunk/src/CacheWolf/CacheDB.java
===================================================================
--- trunk/src/CacheWolf/CacheDB.java	2009-04-17 16:41:09 UTC (rev 1748)
+++ trunk/src/CacheWolf/CacheDB.java	2009-04-17 18:44:53 UTC (rev 1749)
@@ -2,8 +2,11 @@
 
 import utils.MutableInteger;
 import ewe.util.Comparer;
+import ewe.util.Enumeration;
 import ewe.util.Hashtable;
+import ewe.util.Iterator;
 import ewe.util.Vector;
+import ewe.util.Map.MapEntry;
 
 /**
  * @author torsti
@@ -124,6 +127,76 @@
 	    hashDB.clear();
 	    vectorDB.clear();
     }
+	
+	/**
+	 * Same as <br>
+	 * <code>clear();<br>addAll(cachesA);<br>addAll(cachesB);<br></code>but optimized 
+	 * to reduce object creation. <br>
+	 * Thus builds cacheDB out of caches of vectors cachesA and cachesB, added in this order.
+	 * 
+	 * @param cachesA
+	 *            First Vector of CacheHolder object to add to CacheDB
+	 * @param cachesB
+	 *            Second Vector of CacheHolder object to add to CacheDB
+	 */
+	public void rebuild(Vector cachesA, Vector cachesB) {
+		int vectorSize = vectorDB.size();
+		int cachesAsize = 0;
+		int cachesBsize = 0;
+		// First negate all hashtable position values, to distinguish the old from the new values
+		Iterator iter = hashDB.entries();
+		while (iter.hasNext()) {
+			MutableInteger mInt = (MutableInteger) ((MapEntry) iter.next()).getValue();
+			mInt.setInt(-mInt.getInt());
+		}
+		// Then set all vector elements at the proper position
+		for (int abc=1; abc <= 2; abc++) {
+			Vector cachesAB = null;
+			int offset = 0;
+			if (abc == 1) {
+				cachesAB=cachesA;
+				if (cachesA != null) cachesAsize = cachesA.size();
+			} else {
+				cachesAB=cachesB;
+				if (cachesA != null) offset = cachesA.size();
+				if (cachesB != null) cachesBsize = cachesB.size();
+			}
+			if (cachesAB == null) continue;
+			for (int i=offset; i<cachesAB.size()+offset; i++) {
+				CacheHolder ch = (CacheHolder) cachesAB.get(i-offset);
+				if (i < vectorSize) {
+					vectorDB.set(i, ch);
+				} else {
+					vectorDB.add(ch);
+				}
+				hashDB.put(ch.getWayPoint(), this.getIntObj(ch.getWayPoint(), i)); 
+			}
+		}
+		// If there are more elements in vectorDB than in the sum of sizes of cachesA and cachesB
+		// then the rest has to be deleted.
+		for (int i=vectorDB.size()-1; i >= cachesAsize + cachesBsize ; i--) {
+			vectorDB.del(i);
+		}
+		// Now delete any element from hashDB which still has a negative position value
+		Vector wpToDelete = null;
+		MapEntry me = null;
+		iter = hashDB.entries();
+		while (iter.hasNext()) {
+			me = (MapEntry) iter.next();
+			MutableInteger mInt = (MutableInteger) me.getValue();
+			if (mInt.getInt()<0) {
+				if (wpToDelete == null) wpToDelete = new Vector();
+				String wp = (String) me.getKey();
+				wpToDelete.add(wp);
+			}
+		}
+		if (wpToDelete != null) {
+			for (int i=0; i<wpToDelete.size(); i++) {
+				String wp = (String) wpToDelete.get(i);
+				hashDB.remove(wp);
+			}
+		}	
+	}
 
 	/** Removes a CacheHolder object at the specified position in the cache list. The following
 	 * elements are renumbered.<br>

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-17 16:41:09 UTC (rev 1748)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-17 18:44:53 UTC (rev 1749)
@@ -154,9 +154,7 @@
 			} // if filtered
 		}
 		// rebuild database
-		cacheDB.clear();
-		cacheDB.addAll(sortDB);
-		cacheDB.addAll(filteredDB);
+		cacheDB.rebuild(sortDB, filteredDB);
 		this.numRows = sortDB.getCount();
 	}
 	



From engywuck at mail.berlios.de  Fri Apr 17 21:36:51 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 21:36:51 +0200
Subject: [Cachewolf-svn] r1750 - trunk/src/CacheWolf
Message-ID: <200904171936.n3HJapjP031448@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 21:36:49 +0200 (Fri, 17 Apr 2009)
New Revision: 1750

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
Improving colour representation of caches in list: If a cache is selected, it's grey color blends to the color of the caches state. Result: Even if a cache is selected, you can see if it's found, available, etc...

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-17 18:44:53 UTC (rev 1749)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-17 19:36:49 UTC (rev 1750)
@@ -21,10 +21,13 @@
 	private static final Color COLOR_OWNED		= new Color(135,206,235);
 	private static final Color COLOR_AVAILABLE	= new Color(255,69,0);
 	private static final Color COLOR_ARCHIVED	= new Color(139,37,0);
-	private static final Color COLOR_SELECTED	= new Color(198,198,198);
+//	private static final Color COLOR_SELECTED	= new Color(198,198,198);
+	private static final Color COLOR_SELECTED	= new Color(141,141,141);
 	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived && Found
 	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);	
 	private static final Color COLOR_DETAILS_LOADED		= new Color(229,206,235);
+	private static final Color COLOR_WHITE      = new Color(255,255,255);
+	private static final Color COLOR_LINE      = new Color(255,255,255);
 	private CacheDB cacheDB;
 	/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
 	 * the element j (as per the list below) is visible in column i. 
@@ -162,29 +165,52 @@
 	* Method to set the row color of the table displaying the
 	* cache list, depending on different flags set to the cache.
 	*/
+	/* (non-Javadoc)
+	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean, ewe.ui.TableCellAttributes)
+	 */
 	public TableCellAttributes getCellAttributes(int row,int col,boolean  isSelected, TableCellAttributes ta){
 		ta = super.getCellAttributes(row, col, isSelected, ta);
 		ta.alignment = CellConstants.LEFT;
 		ta.anchor = CellConstants.LEFT;
+		// The default color of a line is white
+		COLOR_LINE.set(255, 255, 255);
 		if(row >= 0){ 
 			try {
+				// Now find out if the line should be painted in an other color.
+				// Selected lines are not considered, so far
 			   CacheHolder ch = cacheDB.get(row);
-				if(isSelected == true) ta.fillColor = COLOR_SELECTED;
-				else if(ch.is_available() == false && ch.is_found() == true){
-					ta.fillColor = COLOR_ARCHFND_BG;   // Green BG
+				if(ch.is_available() == false && ch.is_found() == true){
+					COLOR_LINE.set(COLOR_ARCHFND_BG);   // Green BG
 					ta.foreground = COLOR_ARCHFND_FG;  // Red FG
 				}
-				else if( ch.is_archived())  ta.fillColor = COLOR_ARCHIVED;
-				else if(!ch.is_available()) ta.fillColor = COLOR_AVAILABLE;
-				else if( ch.is_owned())     ta.fillColor = COLOR_OWNED;
-				else if( ch.is_found())     ta.fillColor = COLOR_FOUND;
-				else if( ch.is_flaged)        ta.fillColor = COLOR_FLAGED;
-				else if( Global.getPref().debug && ch.detailsLoaded()) ta.fillColor = COLOR_DETAILS_LOADED;
+				else if( ch.is_archived())  COLOR_LINE.set(COLOR_ARCHIVED);
+				else if(!ch.is_available()) COLOR_LINE.set(COLOR_AVAILABLE);
+				else if( ch.is_owned())     COLOR_LINE.set(COLOR_OWNED);
+				else if( ch.is_found())     COLOR_LINE.set(COLOR_FOUND);
+				else if( ch.is_flaged)        COLOR_LINE.set(COLOR_FLAGED);
+				else if( Global.getPref().debug && ch.detailsLoaded()) COLOR_LINE.set(COLOR_DETAILS_LOADED);
+				
+				// Now, if a line is selected, blend the determined color with the selection 
+				// color.
+				if (isSelected) mergeColor(COLOR_LINE, COLOR_LINE, COLOR_SELECTED);
+				ta.fillColor = COLOR_LINE;
 			} catch (Exception e) {};
 		} else if (row==-1 && colMap[col]==0 && Global.getProfile().showBlacklisted()) ta.fillColor=Color.Black;
 		return ta;
 	}
 
+	/**
+	 * Determines the arithmetic mean value of two colors and stores the result in the 
+	 * third color.
+	 * @param colorMerged Resulting color
+	 * @param colorA First color to merge. May be same object as <code>colorMerged</code>.
+	 * @param colorB Second color to merge. May be same object as <code>colorMerged</code>.
+	 */
+	private void mergeColor(Color colorMerged, Color colorA, Color colorB) {
+		colorMerged.set((colorA.getRed()+colorB.getRed())/2,
+				         (colorA.getGreen()+colorB.getGreen())/2,
+				         (colorA.getBlue()+colorB.getBlue())/2);
+	}
 	public int calculateRowHeight(int row){
 		return java.lang.Math.max(18, charHeight+4);
 	}



From engywuck at mail.berlios.de  Fri Apr 17 22:47:14 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 22:47:14 +0200
Subject: [Cachewolf-svn] r1751 - in trunk/src/CacheWolf: . navi
Message-ID: <200904172047.n3HKlEmd004934@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 22:47:03 +0200 (Fri, 17 Apr 2009)
New Revision: 1751

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/GPSPortOptions.java
   trunk/src/CacheWolf/HttpConnection.java
   trunk/src/CacheWolf/ImagePanel.java
   trunk/src/CacheWolf/LogList.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/Rebuild.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/Tokenizer.java
   trunk/src/CacheWolf/TravelbugJourneyList.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/TravelbugList.java
   trunk/src/CacheWolf/myInteractivePanel.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/CWGPSPoint.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapImporter.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
   trunk/src/CacheWolf/navi/MapsList.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/Navigate.java
   trunk/src/CacheWolf/navi/TransformCoordinates.java
Log:
Cleaning up: Removing all "Empty blocks should be documented" warnings, either by documenting, by filling or by removing.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -275,7 +275,7 @@
 				        setAttributesNo(Convert.parseLong(xmlString.substring(start + 1, end)));
 		        }
 	        } catch (Exception ex) {
-
+	        	Global.getPref().log("Ignored Exception", ex, true);
 	        }
         }
 	

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/DataMover.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -186,7 +186,7 @@
 	private abstract class Executor {
 		String title;
 		Profile dstProfile;
-		public void doIt(int i, CacheHolder srcHolder){}
+		public abstract void doIt(int i, CacheHolder srcHolder);
 	}
 	 
 	private class Deleter extends Executor {

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/DetailsPanel.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -436,7 +436,9 @@
 				} catch(IllegalArgumentException e) {
 					try {
 						t.parse(foundDate,"y-M-d");
-					} catch(IllegalArgumentException e1) {}
+					} catch(IllegalArgumentException e1) {
+						// No parsable date given - should not appear
+					}
 				};
 				dc.reset(t);
 				if (dc.execute()==ewe.ui.FormBase.IDOK) {

Modified: trunk/src/CacheWolf/GPSPortOptions.java
===================================================================
--- trunk/src/CacheWolf/GPSPortOptions.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/GPSPortOptions.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -58,7 +58,9 @@
 		while (run){
 			try {
 				sleep(200);
-			} catch (InterruptedException e) {}
+			} catch (InterruptedException e) {
+				Global.getPref().log("Ignored exception", e, true);
+			}
 			if (comSp != null)	{  
 				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
 				if (comLength > 0)	{
@@ -83,7 +85,9 @@
 		if (comSp != null) {
 			ret = comSp.close(); //compSp == null can happen if a exception occured 
 			try { ewe.sys.mThread.sleep(500); // wait in order to give the system time to close the serial port
-			} catch (InterruptedException e) {}
+			} catch (InterruptedException e) {
+				Global.getPref().log("Ignored exception", e, true);
+			}
 		}
 		else ret = true;
 		return ret;
@@ -284,7 +288,9 @@
 				}
 				if (gpsPort.nonBlockingRead().indexOf("$GP", 0) >= 0) gpsfound = true;
 			}
-			try {ewe.sys.mThread.sleep(200); } catch (InterruptedException e) {}
+			try {ewe.sys.mThread.sleep(200); } catch (InterruptedException e) {
+				Global.getPref().log("Ignored exception", e, true);
+			}
 		}
 		gpsPort.stop();
 		if (gpsfound)	 txtOutput.appendText(MyLocale.getMsg(7114, " - GPS Port found\n"), true);

Modified: trunk/src/CacheWolf/HttpConnection.java
===================================================================
--- trunk/src/CacheWolf/HttpConnection.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/HttpConnection.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -202,7 +202,7 @@
 			ByteArray got = td.encodeText(Vm.getStringChars(s),0,s.length(),true,null);
 			setPostData(got.toBytes());
 		}catch(IOException e){
-			
+			Global.getPref().log("Ignored exception", e, true);
 		}
 	}
 	else if (data instanceof InputStream) bytesToPost = new StreamAdapter((InputStream)data);

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/ImagePanel.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -34,7 +34,7 @@
 	/**
 	* Constructor to create the image panel.<p>
 	*/
-	public ImagePanel(){
+	public ImagePanel(){ // Public constructor
 	}
 	
 	static CacheHolderDetail oldCache=null;
@@ -239,7 +239,9 @@
 							File f=new File(((ImagePanelImage)which).fileName);
 							f.delete();
 							removeImage(which);
-						} catch(Exception e) {};
+						} catch(Exception e) {
+							Global.getPref().log("Ignored Exception", e, true);
+						};
 				}
 			}
 		} else { 

Modified: trunk/src/CacheWolf/LogList.java
===================================================================
--- trunk/src/CacheWolf/LogList.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/LogList.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -8,7 +8,7 @@
 	private Vector logList=new Vector(10);
 
 	/** Construct an empty Log list */
-	public LogList() {
+	public LogList() { // Public constructor
 	}
 	
 	/** Get the Log at a certain position in the list */

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/MainMenu.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -86,6 +86,7 @@
 			p.waitFor();
 			gpsbabelFound = true;
 		}catch(IOException ioex){
+			Global.getPref().log("Ignored Exception", ioex, true);
 		}
 		if ( !gpsbabelFound ) {
 			try{
@@ -95,6 +96,7 @@
 				addExeToGpsbabel = true;
 				gpsbabelFound = true;
 			}catch(IOException ioex){
+				Global.getPref().log("Ignored Exception", ioex, true);
 			}
 		}		
 		

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/Parser.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -154,7 +154,7 @@
 	Vector tokenStack;
 	Vector messageStack;
 
-	public Parser(){
+	public Parser(){ // Global constructor
 	}
 
 ///////////////////////////////////////////

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/Preferences.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -712,7 +712,9 @@
 		}catch(Exception ex){
 			Vm.debug("Error writing to log file!");
 		}finally{
-			if (logFile != null) try {logFile.close(); } catch (IOException ioe) {}
+			if (logFile != null) try {logFile.close(); } catch (IOException ioe) {
+				Global.getPref().log("Ignored Exception", ioe, true);
+			}
 		}
 	}
 

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/Profile.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -86,7 +86,7 @@
 	 * Constructor for a profile
 	 *
 	 */
-	public Profile(){
+	public Profile(){ // public constructor
 	}
 
 

Modified: trunk/src/CacheWolf/Rebuild.java
===================================================================
--- trunk/src/CacheWolf/Rebuild.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/Rebuild.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -10,7 +10,8 @@
 public class Rebuild {
 	String [] xmlFiles;
 	
-	public Rebuild() {}
+	public Rebuild() { // Public constructor
+	}
 	
 	public void rebuild() {	
 		int i;

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -431,7 +431,9 @@
 				dummy = listBlockRex.stringMatched(1);
 				try{
 					lineRex.search(dummy);
-				}catch(NullPointerException nex){}
+				}catch(NullPointerException nex){
+					Global.getPref().log("Ignored Exception", nex, true);
+				}
 				while(lineRex.didMatch()){
 					//Vm.debug(getDist(lineRex.stringMatched(1)) + " / " +getWP(lineRex.stringMatched(1)));
 					found_on_page++;
@@ -788,7 +790,6 @@
 						pref.log("Error reading cache: "+ch.getWayPoint());
 						pref.log("Exception in getCacheByWaypointName: ",ex);
 					}
-					finally{}
 				} else {
 					break;
 				}
@@ -1437,7 +1438,9 @@
 			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
 			sock.close();
 			return getResponseHeaders(conn)+c_data.toString();
-		} catch (Exception e) {	}
+		} catch (Exception e) {	
+			Global.getPref().log("Ignored Exception", e, true);
+		}
 		return "";
 	}
 

Modified: trunk/src/CacheWolf/Tokenizer.java
===================================================================
--- trunk/src/CacheWolf/Tokenizer.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/Tokenizer.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -29,7 +29,7 @@
 	TokenObj thisToken;
 	Vector messageStack;
 	
-	public Tokenizer(){
+	public Tokenizer(){ // Public constructor
 	}
 
     private void err(String str) throws Exception {
@@ -251,6 +251,8 @@
 				else if (newLineIsSeparator && (look=='\\' || look=='_')) ;
 				else err(MyLocale.getMsg(1732,"Invalid character")); 
 			}
-		} catch (Exception e) {}
+		} catch (Exception e) {
+			Global.getPref().log("Ignored Exception", e, true);
+		}
 	}
 }

Modified: trunk/src/CacheWolf/TravelbugJourneyList.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyList.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/TravelbugJourneyList.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -74,7 +74,8 @@
 		return count;
 	}
 	
-	TravelbugJourneyList() {}
+	TravelbugJourneyList() { // Public constructor
+	}
 	
 	/**
 	 * Return a list of the travelbugs still in my possession

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -211,7 +211,9 @@
 				} catch(IllegalArgumentException e) {
 					try {
 						t.parse(foundDate,"y-M-d");
-					} catch(IllegalArgumentException e1) {}
+					} catch(IllegalArgumentException e1) {
+						// Can't parse date - should not happen
+					}
 				};
 				dc.reset(t);
 				if (dc.execute()==ewe.ui.FormBase.IDOK) {
@@ -575,6 +577,7 @@
 					CWWrapper.exec(Global.getPref().browser, s);
 					Global.getPref().log("Executing: \""+Global.getPref().browser+"\" \""+s+"\"");
 				} catch (Exception ioex) {
+					Global.getPref().log("Ignored Exception", ioex, true);
 				}
 			}
 		}

Modified: trunk/src/CacheWolf/TravelbugList.java
===================================================================
--- trunk/src/CacheWolf/TravelbugList.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/TravelbugList.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -44,7 +44,7 @@
 	}
 	
 	/** Construct an empty travelbug list */
-	public TravelbugList() {
+	public TravelbugList() { // public constructor
 	}
 	
 	/** Find a travelbug in the list. 

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -116,9 +116,6 @@
 	 public void stopDragging(DragContext dc) {		 
 		canScroll=true;
 	 }
-	 public void draggingStarted(ImageDragContext dc) {}
-	 public void draggingStopped(ImageDragContext dc) {}
-	 
 	 public boolean imageBeginDragged(AniImage which,Point pos) {
 		if (!Global.mainForm.cacheListVisible) return false;
 		canScroll=false;

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -194,7 +194,9 @@
 				// color.
 				if (isSelected) mergeColor(COLOR_LINE, COLOR_LINE, COLOR_SELECTED);
 				ta.fillColor = COLOR_LINE;
-			} catch (Exception e) {};
+			} catch (Exception e) {
+				Global.getPref().log("Ignored Exception", e, true);
+			};
 		} else if (row==-1 && colMap[col]==0 && Global.getProfile().showBlacklisted()) ta.fillColor=Color.Black;
 		return ta;
 	}

Modified: trunk/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/CWGPSPoint.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/CWGPSPoint.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -208,7 +208,9 @@
 					try {
 						logFile.write(NMEA.substring(start,end+3)+"\n");
 						logWritten = true;
-					} catch (IOException e) {}
+					} catch (IOException e) {
+						Global.getPref().log("Ignored Exception", e, true);
+					}
 				}
 
 				Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
@@ -247,8 +249,12 @@
 								break;
 							}
 						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
-						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
-						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
+							Global.getPref().log("Ignored Exception", e, true);
+						} break;
+						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
+							Global.getPref().log("Ignored Exception", e, true);
+						} break;
 						} // switch
 					} // while
 					if (Fix > 0) this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", CWPoint.DMM);
@@ -262,10 +268,14 @@
 						i++;
 						if (currToken.length()==0) continue;
 						switch (i){
-						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
+						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
+							Global.getPref().log("Ignored Exception", e, true);
+						}
 						if (this.Bear > 360) Vm.debug("Error bear VTG");
 						break;
-						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} 
+						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
+							Global.getPref().log("Ignored Exception", e, true);
+						} 
 						break;
 						} // switch
 					} // while
@@ -301,25 +311,35 @@
 							break;
 						case 4: latNS = currToken; interpreted = true;
 						break;
-						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {
+							Global.getPref().log("Ignored Exception", e, true);
+						}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {
+							Global.getPref().log("Ignored Exception", e, true);
+						}
 						break;
 						case 6: lonEW = currToken;
 						interpreted = true;
 						break;
 						case 7: if (status.equals("A")){
 							try {this.Speed = Common.parseDouble(currToken)*1.854;
-							interpreted = true; } catch (NumberFormatException e) { }
+							interpreted = true; } catch (NumberFormatException e) { 
+								Global.getPref().log("Ignored Exception", e, true);
+							}
 						}
 						break;
 						case 8: if (status.equals("A") && currToken.length()> 0){
 							try {this.Bear = Common.parseDouble(currToken);
-							interpreted = true; } catch (NumberFormatException e) { }
+							interpreted = true; } catch (NumberFormatException e) {
+								Global.getPref().log("Ignored Exception", e, true);
+							}
 						}
 						break;
 						case 9: if (status.equals("A") && currToken.length()> 0){
 							try {this.Date = currToken;
-							interpreted = true; } catch (NumberFormatException e) { }
+							interpreted = true; } catch (NumberFormatException e) { 
+								Global.getPref().log("Ignored Exception", e, true);
+							}
 						}
 						break;
 						} // switch

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -306,8 +306,6 @@
 				if (mainT.ch != null && mainT.ch.pos.isValid()) centerTo = new CWPoint(mainT.ch.pos);
 				else {
 					if (pref.curCentrePt.isValid()) centerTo = new CWPoint(pref.curCentrePt);
-					else {
-					}
 				}
 			}
 		}

Modified: trunk/src/CacheWolf/navi/MapImporter.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImporter.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/MapImporter.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -188,7 +188,9 @@
 				try {
 					if (in != null) in.close();
 					if (out  != null) out.close(); 
-				} catch (Throwable e) {}
+				} catch (Throwable e) {
+					Global.getPref().log("Ignored Exception", e, true);
+				}
 			}
 			//Check for a .map file
 			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));

Modified: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -55,7 +55,8 @@
 	static private String digSep = MyLocale.getDigSeparator();
 	private int coordTrans = 0; 
 
-	public MapInfoObject() { }
+	public MapInfoObject() { // Public constructor
+	}
 
 	public MapInfoObject(MapInfoObject map) {
 		super (map.topleft, map.buttomright);
@@ -417,7 +418,7 @@
 		public int bitMapX = 0;
 		public int bitMapY = 0;
 
-		public GCPoint(){
+		public GCPoint(){ // Public constructor
 		}
 
 		public GCPoint(CWPoint p) {

Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/MapsList.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -441,7 +441,9 @@
 		*/
 		try {
 			if (filenamei.startsWith("FF1")) sortEntryBBox = filenamei.substring(0, filenamei.indexOf("E-"));
-		} catch (IndexOutOfBoundsException ex) { }
+		} catch (IndexOutOfBoundsException ex) {
+			Global.getPref().log("Ignored Exception", ex, true);
+		}
 		if (sortEntryBBox == null ) { //|| sortEntryScaleCenterPx.length() < 16) {
 			try {
 				map = new MapInfoObject(path, filename);

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -434,8 +434,12 @@
 		try {
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 			addMissingOverlays();
-		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
-		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null 
+		} catch (NullPointerException e) {
+			// hapens if currentmap == null or PosCircle not valid
+		} 
+		catch (IllegalArgumentException e) {
+			// happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
+		}  
 	}
 
 	public void destroyOverlaySet() {
@@ -2030,7 +2034,9 @@
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+		}catch (NegativeArraySizeException e) {
+			// happens in substring when a dividing line selected 
+		} 
 	}
 
 	public void onEvent(Event ev){

Modified: trunk/src/CacheWolf/navi/Navigate.java
===================================================================
--- trunk/src/CacheWolf/navi/Navigate.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/Navigate.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -198,7 +198,9 @@
 				//Vm.debug("Loop? " + noData);
 				noData++;
 				if (noData > 5) { myGPS.noDataError(); }
-			} catch (InterruptedException e) {}
+			} catch (InterruptedException e) {
+				Global.getPref().log("Ignored Exception", e, true);
+			}
 			if (comSp != null)	{
 				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
 				//Vm.debug("Length: " + comBuff.length);
@@ -245,7 +247,9 @@
 	public void run () {
 		run = true;
 		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {}
+			try { sleep (calldelay);} catch (InterruptedException e) {
+				Global.getPref().log("Ignored Exception", e, true);
+			}
 			ticked.ticked();
 		}
 	}

Modified: trunk/src/CacheWolf/navi/TransformCoordinates.java
===================================================================
--- trunk/src/CacheWolf/navi/TransformCoordinates.java	2009-04-17 19:36:49 UTC (rev 1750)
+++ trunk/src/CacheWolf/navi/TransformCoordinates.java	2009-04-17 20:47:03 UTC (rev 1751)
@@ -95,7 +95,9 @@
 	static final Area ITALY_SICILIA_GK = new Area(wgs84ToGaussKrueger(ITALY_SICILIA.topleft, EPSG_ITALIAN_GB_EW2).toTrackPoint(GkPoint.ITALIAN_GB),
 			wgs84ToGaussKrueger(ITALY_SICILIA.buttomright, EPSG_ITALIAN_GB_EW2).toTrackPoint(GkPoint.ITALIAN_GB));
 
-	private TransformCoordinates() {} // as all members are static, so avoid instantiation
+	private TransformCoordinates() {
+		// as all members are static, so avoid instantiation
+	} 
 
 	/* replaced by getGkRegion
 	public static boolean isGermanGk(int epsgcode) {



From engywuck at mail.berlios.de  Fri Apr 17 22:49:19 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 22:49:19 +0200
Subject: [Cachewolf-svn] r1752 - trunk/src/CacheWolf/navi
Message-ID: <200904172049.n3HKnJbA005141@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 22:49:17 +0200 (Fri, 17 Apr 2009)
New Revision: 1752

Modified:
   trunk/src/CacheWolf/navi/MapsList.java
Log:
Cleaning up: Removing "Null comparison always yields false" warning.


Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2009-04-17 20:47:03 UTC (rev 1751)
+++ trunk/src/CacheWolf/navi/MapsList.java	2009-04-17 20:49:17 UTC (rev 1752)
@@ -302,7 +302,7 @@
 					if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
 					else {
 						if ( (latNearer || lonNearer )) { 
-							if (bestMap == null || mi.center.getDistanceRad(ll) < bestMap.center.getDistanceRad(ll) ) better = true;
+							if (mi.center.getDistanceRad(ll) < bestMap.center.getDistanceRad(ll) ) better = true;
 						}
 					}
 				} // same scale



From engywuck at mail.berlios.de  Fri Apr 17 22:50:53 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 22:50:53 +0200
Subject: [Cachewolf-svn] r1753 - trunk/src/CacheWolf/navi
Message-ID: <200904172050.n3HKorLg005309@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 22:50:51 +0200 (Fri, 17 Apr 2009)
New Revision: 1753

Modified:
   trunk/src/CacheWolf/navi/MapImporter.java
   trunk/src/CacheWolf/navi/MapsList.java
Log:
Removing "Redundant null checks" warnings.

Modified: trunk/src/CacheWolf/navi/MapImporter.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImporter.java	2009-04-17 20:49:17 UTC (rev 1752)
+++ trunk/src/CacheWolf/navi/MapImporter.java	2009-04-17 20:50:51 UTC (rev 1753)
@@ -297,7 +297,7 @@
 						} // if
 
 					} // while
-					if (inMap != null)	inMap.close();
+					inMap.close();
 				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
 					inf.addWarning("\n"+MyLocale.getMsg(4117, "Error while importing .map-file: ")+ex.getMessage());
 				} catch(IOException ex){

Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2009-04-17 20:49:17 UTC (rev 1752)
+++ trunk/src/CacheWolf/navi/MapsList.java	2009-04-17 20:50:51 UTC (rev 1753)
@@ -220,7 +220,7 @@
 				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
 					better = true; // mi map has a better (lower) scale than the last knwon good map
 				} else {
-					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
+					if (scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
 						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
 						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
 						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated



From engywuck at mail.berlios.de  Fri Apr 17 22:55:48 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 22:55:48 +0200
Subject: [Cachewolf-svn] r1754 - in trunk/src: CacheWolf CacheWolf/navi utils
Message-ID: <200904172055.n3HKtmKl005639@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 22:55:37 +0200 (Fri, 17 Apr 2009)
New Revision: 1754

Modified:
   trunk/src/CacheWolf/CWPoint.java
   trunk/src/CacheWolf/CacheDB.java
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheType.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/Common.java
   trunk/src/CacheWolf/DBStats.java
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/HttpConnection.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MyLocale.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/ShowCacheInBrowser.java
   trunk/src/CacheWolf/StatusBar.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/myInteractivePanel.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapImage.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/utils/MessageBoxFixed.java
Log:
Cleaning up: Removing unused imports.

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/CWPoint.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -7,7 +7,6 @@
 import CacheWolf.navi.GeodeticCalculator;
 
 import com.bbn.openmap.proj.coords.*;
-import com.bbn.openmap.proj.*;
 import com.bbn.openmap.*;
 import com.stevesoft.ewe_pat.Regex;
 

Modified: trunk/src/CacheWolf/CacheDB.java
===================================================================
--- trunk/src/CacheWolf/CacheDB.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/CacheDB.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -2,7 +2,6 @@
 
 import utils.MutableInteger;
 import ewe.util.Comparer;
-import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
 import ewe.util.Vector;

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -1,23 +1,12 @@
 package CacheWolf;
 
-import utils.FileBugfix;
 import CacheWolf.navi.Metrics;
 
 import com.stevesoft.ewe_pat.Regex;
 
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.io.BufferedWriter;
-import ewe.io.File;
-import ewe.io.FileNotFoundException;
-import ewe.io.FileReader;
-import ewe.io.FileWriter;
 import ewe.io.IOException;
-import ewe.io.PrintWriter;
 import ewe.sys.Convert;
-import ewe.sys.Vm;
 import ewe.ui.FormBase;
-import ewe.ui.InputBox;
 import ewe.ui.MessageBox;
 import ewe.util.Vector;
 

Modified: trunk/src/CacheWolf/CacheType.java
===================================================================
--- trunk/src/CacheWolf/CacheType.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/CacheType.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -4,7 +4,6 @@
 package CacheWolf;
 
 import ewe.fx.Image;
-import ewe.sys.Convert;
 import ewe.sys.Vm;
 
 

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/CalcPanel.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -3,7 +3,6 @@
 import CacheWolf.navi.Metrics;
 import ewe.ui.*;
 import ewe.ui.formatted.TextDisplay;
-import ewe.util.Vector;
 import ewe.fx.Dimension;
 import ewe.fx.FontMetrics;
 

Modified: trunk/src/CacheWolf/Common.java
===================================================================
--- trunk/src/CacheWolf/Common.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/Common.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -1,12 +1,8 @@
 package CacheWolf;
 
 import utils.FileBugfix;
-import ewe.io.Base64Codec;
 import ewe.io.File;
-import ewe.io.IOException;
 import ewe.sys.Convert;
-import ewe.util.ByteArray;
-import ewe.io.JavaUtf8Codec;
 
 public final class Common {
 

Modified: trunk/src/CacheWolf/DBStats.java
===================================================================
--- trunk/src/CacheWolf/DBStats.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/DBStats.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -1,5 +1,4 @@
 package CacheWolf;
-import ewe.util.*;
 
 /**
  * @author Marc

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/DataMover.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -5,7 +5,6 @@
 import ewe.filechooser.FileChooserBase;
 import ewe.io.*;
 import ewe.ui.*;
-import ewe.util.Vector;
 import ewe.sys.*;
 
 

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/DetailsPanel.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -2,7 +2,6 @@
 
 import ewe.ui.*;
 import ewe.fx.*;
-import ewe.util.*;
 import ewe.sys.*;
 
 /**

Modified: trunk/src/CacheWolf/HttpConnection.java
===================================================================
--- trunk/src/CacheWolf/HttpConnection.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/HttpConnection.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -2,7 +2,6 @@
 import ewe.data.Property;
 import ewe.data.PropertyList;
 import ewe.io.AsciiCodec;
-import ewe.io.Base64Codec;
 import ewe.io.FileBase;
 import ewe.io.IOException;
 import ewe.io.IOHandle;
@@ -15,7 +14,6 @@
 import ewe.io.StreamAdapter;
 import ewe.io.StreamUtils;
 import ewe.io.TextCodec;
-import ewe.net.MalformedURLException;
 import ewe.net.Socket;
 import ewe.net.URL;
 import ewe.sys.Convert;

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -27,7 +27,6 @@
 package CacheWolf;
 
 import ewe.sys.Vm;
-import ewe.util.*;
 import ewe.io.*;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/MainTab.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -7,7 +7,6 @@
 import ewe.sys.Vm;
 import ewe.ui.*;
 import ewe.fx.*;
-import ewe.util.*;
 
 /**
  *	This class creates the tabbed panel and sets the tabs to the respective

Modified: trunk/src/CacheWolf/MyLocale.java
===================================================================
--- trunk/src/CacheWolf/MyLocale.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/MyLocale.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -10,8 +10,6 @@
 import ewe.sys.*;
 import ewe.sys.Double;
 import ewe.sys.Long;
-import ewe.ui.FormBase;
-import ewe.ui.Gui;
 import ewe.ui.Window;
 import ewe.ui.WindowConstants;
 /**

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/Profile.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -12,7 +12,6 @@
 import ewe.sys.Handle;
 import ewe.sys.Vm;
 import ewe.ui.ProgressBarForm;
-import ewe.util.*;
 
 /**
  * This class holds a profile, i.e. a group of caches with a centre location

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/RadarPanel.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -1,6 +1,5 @@
 package CacheWolf;
 import ewe.ui.*;
-import ewe.util.*;
 import ewe.fx.*;
 import ewe.graphics.*;
 

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -1,5 +1,4 @@
 package CacheWolf;
-import ewe.util.*;
 
 /**
 *	A class to perform a search on the cache database.

Modified: trunk/src/CacheWolf/ShowCacheInBrowser.java
===================================================================
--- trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -8,7 +8,6 @@
 import ewe.io.FileWriter;
 import ewe.io.IOException;
 import ewe.io.PrintWriter;
-import ewe.sys.Convert;
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/StatusBar.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -2,7 +2,6 @@
 
 import ewe.sys.Vm;
 import ewe.ui.*;
-import ewe.util.*;
 import ewe.fx.*;
 
 /**

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -16,7 +16,6 @@
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.*;
-import ewe.util.*;
 import ewe.fx.*;
 
 public class TravelbugJourneyScreen extends Form  {

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -1,7 +1,6 @@
 package CacheWolf;
 import ewe.graphics.*;
 import ewe.ui.*;
-import ewe.util.Vector;
 import ewe.sys.*;
 import ewe.fx.*;
 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/myTableControl.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -6,7 +6,6 @@
 import ewe.fx.*;
 import ewe.io.File;
 import ewe.io.IOException;
-import ewe.util.*;
 
 /**
  *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -11,7 +11,6 @@
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
 import ewe.ui.*;
-import ewe.util.Vector;
 import ewe.fx.*;
 import ewe.graphics.AniImage;
 //import ewe.io.IOException;

Modified: trunk/src/CacheWolf/navi/MapImage.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImage.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/navi/MapImage.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -2,12 +2,7 @@
 import ewe.fx.*;
 import ewe.graphics.*;
 import ewe.io.FileInputStream;
-import ewe.io.FileReader;
 import ewe.io.IOException;
-import ewe.io.InputStream;
-import ewe.io.InputStreamReader;
-import ewe.io.Stream;
-import ewe.util.ByteArray;
 /** 
  * class that can be used with any x and any y
  * it will save taht location and make itself automatically

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -7,13 +7,11 @@
 import CacheWolf.Global;
 import CacheWolf.InfoBox;
 import CacheWolf.MyLocale;
-import CacheWolf.NewProfileWizard;
 import CacheWolf.Preferences;
 import ewe.io.FileBase;
 import ewe.sys.Convert;
 import ewe.sys.Vm;
 import ewe.ui.*;
-import ewe.util.Vector;
 
 /**
  * @author pfeffer

Modified: trunk/src/utils/MessageBoxFixed.java
===================================================================
--- trunk/src/utils/MessageBoxFixed.java	2009-04-17 20:50:51 UTC (rev 1753)
+++ trunk/src/utils/MessageBoxFixed.java	2009-04-17 20:55:37 UTC (rev 1754)
@@ -2,7 +2,6 @@
 
 package utils;
 
-import ewe.sys.Vm;
 import ewe.sys.mThread;
 import ewe.ui.MessageBox;
 /**



From engywuck at mail.berlios.de  Fri Apr 17 22:58:44 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 22:58:44 +0200
Subject: [Cachewolf-svn] r1755 - in trunk/src/CacheWolf: . navi
Message-ID: <200904172058.n3HKwiVe006167@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 22:58:41 +0200 (Fri, 17 Apr 2009)
New Revision: 1755

Modified:
   trunk/src/CacheWolf/Attribute.java
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/CacheWolf.java
   trunk/src/CacheWolf/GPSPortOptions.java
   trunk/src/CacheWolf/HintLogPanel.java
   trunk/src/CacheWolf/MyLocale.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/navi/GotoPanel.java
Log:
Cleanup: Access to static fields and methods now directly by using class.

Modified: trunk/src/CacheWolf/Attribute.java
===================================================================
--- trunk/src/CacheWolf/Attribute.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/Attribute.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -2,6 +2,7 @@
 
 import ewe.fx.mImage;
 import ewe.io.File;
+import ewe.io.FileBase;
 
 /**
  * This class represents a single attribute
@@ -114,7 +115,7 @@
 			"flashlight-yes.gif"    // 89 Flashlight required
 	};
 	private static mImage [] attributeImages=new mImage[90];
-	private static String IMAGEDIR=STRreplace.replace(File.getProgramDirectory()+"/attributes/", "//", "/");
+	private static String IMAGEDIR=STRreplace.replace(FileBase.getProgramDirectory()+"/attributes/", "//", "/");
 	
 	public static String getImageDir() {
 		return IMAGEDIR; 

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/CacheList.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -37,7 +37,7 @@
 		lstCaches=new myList(10,1,false); lstCaches.text="CacheList"; 
 		lstCaches.addItem(MyLocale.getMsg(180,"Drag caches"));lstCaches.addItem(MyLocale.getMsg(181,"here"));
 		ScrollablePanel scp=lstCaches.getScrollablePanel();
-		addLast(scp,STRETCH,FILL); scp.setOptions(MyScrollBarPanel.NeverShowHorizontalScrollers);
+		addLast(scp,STRETCH,FILL); scp.setOptions(ScrollablePanel.NeverShowHorizontalScrollers);
 		// The buttons to move the selected cache
 		addNext(btnDown=new mButton(imgDown),HSHRINK,HFILL); btnDown.modify(Disabled,0);
 		addLast(btnUp=new mButton(imgUp),HSHRINK,HFILL); btnUp.modify(Disabled,0);

Modified: trunk/src/CacheWolf/CacheWolf.java
===================================================================
--- trunk/src/CacheWolf/CacheWolf.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/CacheWolf.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -48,7 +48,7 @@
 							configfile = args[i+1];
 							i++;
 						} else {
-							(new MessageBox("Error", MyLocale.getMsg(7200, "Usage: CacheWolf [-c <path to pref.xml>] [-debug]"), MessageBox.OKB)).execute();
+							(new MessageBox("Error", MyLocale.getMsg(7200, "Usage: CacheWolf [-c <path to pref.xml>] [-debug]"), FormBase.OKB)).execute();
 							// return usage info
 							ewe.sys.Vm.exit(1);
 						}

Modified: trunk/src/CacheWolf/GPSPortOptions.java
===================================================================
--- trunk/src/CacheWolf/GPSPortOptions.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/GPSPortOptions.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -168,7 +168,7 @@
 				txtOutput.setText("");
 				new mThread() {
 					public void run() {
-						btnTest.set(mButton.Disabled, true);
+						btnTest.set(ControlConstants.Disabled, true);
 						btnTest.repaintNow();
 						btnScan.setText(Gui.getTextFrom(MyLocale.getMsg(7119,"Stop")));
 						btnScan.repaintNow();
@@ -199,7 +199,7 @@
 					private void fin() {
 						scanRunning = false;
 						if (btnTest != null) {
-							btnTest.set(mButton.Disabled, false);
+							btnTest.set(ControlConstants.Disabled, false);
 							btnTest.repaintNow();
 						}
 						if (btnScan != null) {
@@ -217,7 +217,7 @@
 				ed_.fromControls();
 				txtOutput.setText(MyLocale.getMsg(7117, "Displaying data from serial port directly:\n"));
 				try {
-					btnScan.set(mButton.Disabled, true);
+					btnScan.set(ControlConstants.Disabled, true);
 					btnScan.repaintNow();
 					this.portName = Common.fixSerialPortName(portName);
 					serThread = new mySerialThread(this, txtOutput);
@@ -225,7 +225,7 @@
 					btnTest.setText(Gui.getTextFrom(MyLocale.getMsg(7118, "Stop")));
 					gpsRunning = true;
 				} catch (IOException e) {
-					btnScan.set(mButton.Disabled, false);
+					btnScan.set(ControlConstants.Disabled, false);
 					btnScan.repaintNow();
 					txtOutput.appendText(MyLocale.getMsg(7108, "Failed to open serial port: ") + this.portName + ", IOException: " + e.getMessage() + "\n", true);
 				}
@@ -234,7 +234,7 @@
 				serThread.stop();
 				btnTest.setText(Gui.getTextFrom(MyLocale.getMsg(7104,"Test$t")));
 				gpsRunning = false;
-				btnScan.set(mButton.Disabled, false);
+				btnScan.set(ControlConstants.Disabled, false);
 				btnScan.repaintNow();
 			}
 

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/HintLogPanel.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -9,6 +9,7 @@
 import ewe.graphics.ImageDragContext;
 import ewe.graphics.InteractivePanel;
 import ewe.io.File;
+import ewe.io.FileBase;
 import ewe.sys.*;
 import ewe.fx.Image;
 import ewe.fx.Rect;
@@ -103,7 +104,7 @@
 		try {
 			logs.startHtml();
 			// set documentroot to prevent html renderer from loading remote images
-			logs.getDecoderProperties().set("documentroot", File.getProgramDirectory());
+			logs.getDecoderProperties().set("documentroot", FileBase.getProgramDirectory());
 			logs.addHtml(dummy.toString(), new ewe.sys.Handle());
 			logs.endHtml();
 		} catch (Exception e) {

Modified: trunk/src/CacheWolf/MyLocale.java
===================================================================
--- trunk/src/CacheWolf/MyLocale.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/MyLocale.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -7,6 +7,7 @@
 import utils.FileBugfix;
 import ewe.fx.Rect;
 import ewe.io.File;
+import ewe.io.FileBase;
 import ewe.sys.*;
 import ewe.sys.Double;
 import ewe.sys.Long;
@@ -39,7 +40,7 @@
 	public static String initErrors;
 
 	private static String getLocaleFileName(String languageshort) {
-		return File.makePath(File.getProgramDirectory(), "languages/" + languageshort.toUpperCase() + ".cfg");
+		return FileBase.makePath(FileBase.getProgramDirectory(), "languages/" + languageshort.toUpperCase() + ".cfg");
 	}
 
 	/**

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/Preferences.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -252,7 +252,7 @@
 			r.close();
 		}catch(IOException e){
 			log("IOException reading config file: " + pathToConfigFile, e, true);
-			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(176, "First start - using default preferences \n For experts only: \n Could not read preferences file:\n") + pathToConfigFile, MessageBox.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(176, "First start - using default preferences \n For experts only: \n Could not read preferences file:\n") + pathToConfigFile, FormBase.OKB)).execute();
 		}catch(Exception e){
 			if (e instanceof NullPointerException)
 				log("Error reading pref.xml: NullPointerException in Element "+lastName +". Wrong attribute?",e,true);

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-17 20:55:37 UTC (rev 1754)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-17 20:58:41 UTC (rev 1755)
@@ -119,7 +119,7 @@
 		lblGPS.modifyAll(ControlConstants.WantHoldDown, 0);
 
 		lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat));
-		lblPosition.anchor = mLabel.CENTER;
+		lblPosition.anchor = CellConstants.CENTER;
 		lblPosition.setMenu(mnuContextFormt);
 		lblPosition.modifyAll(ControlConstants.WantHoldDown, 0);
 		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -397,7 +397,7 @@
 				pref.curCentrePt.set(myNavigation.gpsPos);
 				mainT.updateBearDist();
 				Vm.showWait(false);
-				} else (new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(1514, "Cannot recalculate distances, because the GPS position is not set"), MessageBox.OKB)).execute();
+				} else (new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(1514, "Cannot recalculate distances, because the GPS position is not set"), FormBase.OKB)).execute();
 			}
 			//Start moving map
 			if (ev.target == btnMap){



From engywuck at mail.berlios.de  Fri Apr 17 22:59:47 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 22:59:47 +0200
Subject: [Cachewolf-svn] r1756 - trunk/src/CacheWolf/navi
Message-ID: <200904172059.n3HKxlVX006280@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 22:59:45 +0200 (Fri, 17 Apr 2009)
New Revision: 1756

Modified:
   trunk/src/CacheWolf/navi/Area.java
Log:
Removed warning: Unnecessary cast from int to double

Modified: trunk/src/CacheWolf/navi/Area.java
===================================================================
--- trunk/src/CacheWolf/navi/Area.java	2009-04-17 20:58:41 UTC (rev 1755)
+++ trunk/src/CacheWolf/navi/Area.java	2009-04-17 20:59:45 UTC (rev 1756)
@@ -110,8 +110,8 @@
 	 public static String getEasyFindString(CWPoint p, int prec) {
 		 double longinrange = p.lonDec;
 		 if (longinrange > 180) longinrange -= 180;
-		 int lat = (int) (((p.latDec+90d)/180d) * (double)(1 << (prec)));
-		 int lon = (int) (((longinrange+180)/360) * (double) (1 << (prec)));
+		 int lat = (int) (((p.latDec+90d)/180d) * (1 << (prec)));
+		 int lon = (int) (((longinrange+180)/360) * (1 << (prec)));
 		 String ret = "";
 		 int tmp;
 		 for (int i=prec-1; i>=0;  i--) {



From engywuck at mail.berlios.de  Fri Apr 17 23:10:43 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 23:10:43 +0200
Subject: [Cachewolf-svn] r1757 - in trunk/src: CacheWolf exp
Message-ID: <200904172110.n3HLAhwd007919@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 23:10:30 +0200 (Fri, 17 Apr 2009)
New Revision: 1757

Modified:
   trunk/src/CacheWolf/Attribute.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/GPSPortOptions.java
   trunk/src/CacheWolf/HintLogPanel.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MyLocale.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/exp/KMLExporter.java
Log:
Removing unused members.

Modified: trunk/src/CacheWolf/Attribute.java
===================================================================
--- trunk/src/CacheWolf/Attribute.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/CacheWolf/Attribute.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -1,7 +1,6 @@
 package CacheWolf;
 
 import ewe.fx.mImage;
-import ewe.io.File;
 import ewe.io.FileBase;
 
 /**

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/CacheWolf/FilterScreen.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -38,7 +38,6 @@
 	private CellPanel pnlContainer=new CellPanel();
 	private CellPanel pnlSearch=new CellPanel();
 	private CellPanel pnlRose = new CellPanel();
-	private CellPanel pnlButtons=new CellPanel();
 	private CellPanel pnlAddi=new CellPanel();
 	private CellPanel pnlCacheAttributes=new CellPanel();
 	private CardPanel cp=new CardPanel();

Modified: trunk/src/CacheWolf/GPSPortOptions.java
===================================================================
--- trunk/src/CacheWolf/GPSPortOptions.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/CacheWolf/GPSPortOptions.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -257,7 +257,6 @@
 	
 	private boolean testPort(String port, int baud){
 		mySerialThread gpsPort; 
-		int gpsLen;
 		long now;
 		
 		SerialPortOptions testspo= new SerialPortOptions();

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/CacheWolf/HintLogPanel.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -8,7 +8,6 @@
 import ewe.graphics.AniImage;
 import ewe.graphics.ImageDragContext;
 import ewe.graphics.InteractivePanel;
-import ewe.io.File;
 import ewe.io.FileBase;
 import ewe.sys.*;
 import ewe.fx.Image;

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/CacheWolf/MainMenu.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -23,14 +23,14 @@
  *     20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
  */
 public class MainMenu extends MenuBar {
-	private MenuItem profiles, preferences, mnuContext,loadcaches,loadOC, /* savenexit, */ savenoxit,exit,search,searchAll,searchClr;
+	private MenuItem preferences, mnuContext,loadcaches,loadOC, /* savenexit, */ savenoxit,exit,search,searchAll,searchClr;
 	private MenuItem downloadmap, kalibmap, importmap;
 	private MenuItem spider, spiderAllFinds, update, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTom, exportMSARCSV;
 	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
-	private MenuItem exportLOC, exportGPS, exportCacheMate,mnuSeparator;
+	private MenuItem exportLOC, exportGPS, mnuSeparator;
 	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete,orgRebuild;
 	public MenuItem cacheTour,orgTravelbugs, mnuForceLogin;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditCenter;
@@ -41,8 +41,7 @@
 
 	public MainMenu(Form f){
 		father = f;
-		String cwd = FileBase.getProgramDirectory();
-
+	
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for profiles, part of "Application" menu below
 		///////////////////////////////////////////////////////////////////////
@@ -127,7 +126,7 @@
 		// Create the "Application" pulldown menu
 		///////////////////////////////////////////////////////////////////////
 		MenuItem [] appMenuItems=new MenuItem[11];
-		appMenuItems[0] = profiles 	 = new MenuItem(MyLocale.getMsg(121,"Profile"), 0, profileMenu); 
+		appMenuItems[0] = new MenuItem(MyLocale.getMsg(121,"Profile"), 0, profileMenu); 
 		appMenuItems[1] = preferences = new MenuItem(MyLocale.getMsg(108,"Preferences")); 
 		appMenuItems[2] = mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,"Centre"));
 		appMenuItems[3] = mnuContext = new MenuItem(MyLocale.getMsg(134,"Current Cache"));

Modified: trunk/src/CacheWolf/MyLocale.java
===================================================================
--- trunk/src/CacheWolf/MyLocale.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/CacheWolf/MyLocale.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -6,7 +6,6 @@
 
 import utils.FileBugfix;
 import ewe.fx.Rect;
-import ewe.io.File;
 import ewe.io.FileBase;
 import ewe.sys.*;
 import ewe.sys.Double;

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -26,7 +26,6 @@
 	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived && Found
 	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);	
 	private static final Color COLOR_DETAILS_LOADED		= new Color(229,206,235);
-	private static final Color COLOR_WHITE      = new Color(255,255,255);
 	private static final Color COLOR_LINE      = new Color(255,255,255);
 	private CacheDB cacheDB;
 	/** How the columns are mapped onto the list view. If colMap[i]=j, it means that

Modified: trunk/src/exp/KMLExporter.java
===================================================================
--- trunk/src/exp/KMLExporter.java	2009-04-17 20:59:45 UTC (rev 1756)
+++ trunk/src/exp/KMLExporter.java	2009-04-17 21:10:30 UTC (rev 1757)
@@ -58,7 +58,6 @@
 		String str;
 		CacheHolder ch;
 		CacheHolder addiWpt;
-		CacheHolderDetail holder;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 		



From engywuck at mail.berlios.de  Fri Apr 17 23:44:47 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Fri, 17 Apr 2009 23:44:47 +0200
Subject: [Cachewolf-svn] r1758 - trunk/src/CacheWolf
Message-ID: <200904172144.n3HLile7011744@sheep.berlios.de>

Author: engywuck
Date: 2009-04-17 23:44:45 +0200 (Fri, 17 Apr 2009)
New Revision: 1758

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
Fixed: Updating cache doesn't affect check status anymore.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-17 21:10:30 UTC (rev 1757)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-17 21:44:45 UTC (rev 1758)
@@ -371,9 +371,11 @@
 		this.addiWpts = ch.addiWpts;
 		this.mainCache=ch.mainCache;
 		this.setNew(ch.is_new());
-		this.is_flaged = ch.is_flaged;
-		this.is_Checked = ch.is_Checked;
-		//this.dirty = ch.dirty;
+		// I don't think that updating a cache with current data should affect the state
+		// if a cache is checked or a search result. So the following two assignments are
+		// removed.
+//		this.is_flaged = ch.is_flaged;
+//		this.is_Checked = ch.is_Checked;
 		this.setOcCacheID(ch.getOcCacheID());
 		this.setNoFindLogs(ch.getNoFindLogs());
 		this.setHas_bugs(ch.has_bugs());



From mik77 at mail.berlios.de  Sat Apr 18 00:48:49 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 18 Apr 2009 00:48:49 +0200
Subject: [Cachewolf-svn] r1759 - in trunk: res_noewe src/CacheWolf
Message-ID: <200904172248.n3HMmnI0027674@sheep.berlios.de>

Author: mik77
Date: 2009-04-18 00:48:46 +0200 (Sat, 18 Apr 2009)
New Revision: 1759

Modified:
   trunk/res_noewe/legende.html
   trunk/src/CacheWolf/myTableModel.java
Log:
Show disabled/archived status always as text color, if another status is shown as background.

Modified: trunk/res_noewe/legende.html
===================================================================
--- trunk/res_noewe/legende.html	2009-04-17 21:44:45 UTC (rev 1758)
+++ trunk/res_noewe/legende.html	2009-04-17 22:48:46 UTC (rev 1759)
@@ -4,8 +4,8 @@
 
 <b><i>Listenansicht (farbige Zeilen)</i></b>
 <table>
-<tr><td><font color="#FF0000"=>Cache ist nicht suchbar</font></td></tr>
-<tr><td><font color="#93170C"=>Cache wurde archiviert</font></td></tr>
+<tr><td><font color="#FF8000"=>Cache ist nicht suchbar</font></td></tr>
+<tr><td><font color="#C80000"=>Cache wurde archiviert</font></td></tr>
 <tr><td><font color="#1D4AEE"=>Eigene Caches</font></td></tr>
 <tr><td><font color="#0BB206"=>Gefundene Caches</font></td></tr>
 </table>

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-17 21:44:45 UTC (rev 1758)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-17 22:48:46 UTC (rev 1759)
@@ -19,14 +19,12 @@
 	private static final Color COLOR_FLAGED		= new Color(255,255,0);
 	private static final Color COLOR_FOUND		= new Color(152,251,152);
 	private static final Color COLOR_OWNED		= new Color(135,206,235);
-	private static final Color COLOR_AVAILABLE	= new Color(255,69,0);
-	private static final Color COLOR_ARCHIVED	= new Color(139,37,0);
+	private static final Color COLOR_AVAILABLE	= new Color(255,128,0);
+	private static final Color COLOR_ARCHIVED	= new Color(200,0,0);
 //	private static final Color COLOR_SELECTED	= new Color(198,198,198);
 	private static final Color COLOR_SELECTED	= new Color(141,141,141);
-	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived && Found
-	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);	
 	private static final Color COLOR_DETAILS_LOADED		= new Color(229,206,235);
-	private static final Color COLOR_LINE      = new Color(255,255,255);
+	private static final Color COLOR_WHITE   	= new Color(255,255,255);
 	private CacheDB cacheDB;
 	/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
 	 * the element j (as per the list below) is visible in column i. 
@@ -172,27 +170,37 @@
 		ta.alignment = CellConstants.LEFT;
 		ta.anchor = CellConstants.LEFT;
 		// The default color of a line is white
-		COLOR_LINE.set(255, 255, 255);
+		Color lineColor      = new Color(255,255,255);
+		lineColor.set(COLOR_WHITE);
 		if(row >= 0){ 
 			try {
 				// Now find out if the line should be painted in an other color.
 				// Selected lines are not considered, so far
-			   CacheHolder ch = cacheDB.get(row);
-				if(ch.is_available() == false && ch.is_found() == true){
-					COLOR_LINE.set(COLOR_ARCHFND_BG);   // Green BG
-					ta.foreground = COLOR_ARCHFND_FG;  // Red FG
+				CacheHolder ch = cacheDB.get(row);
+				if( ch.is_owned())     lineColor.set(COLOR_OWNED);
+				else if( ch.is_found())     lineColor.set(COLOR_FOUND);
+				else if( ch.is_flaged)        lineColor.set(COLOR_FLAGED);
+				else if( Global.getPref().debug && ch.detailsLoaded()) lineColor.set(COLOR_DETAILS_LOADED);
+
+				if( ch.is_archived() ) {
+					if ( lineColor.equals(COLOR_WHITE) ) {
+						lineColor.set(COLOR_ARCHIVED);
+					} else {
+						ta.foreground = COLOR_ARCHIVED;
+					}
 				}
-				else if( ch.is_archived())  COLOR_LINE.set(COLOR_ARCHIVED);
-				else if(!ch.is_available()) COLOR_LINE.set(COLOR_AVAILABLE);
-				else if( ch.is_owned())     COLOR_LINE.set(COLOR_OWNED);
-				else if( ch.is_found())     COLOR_LINE.set(COLOR_FOUND);
-				else if( ch.is_flaged)        COLOR_LINE.set(COLOR_FLAGED);
-				else if( Global.getPref().debug && ch.detailsLoaded()) COLOR_LINE.set(COLOR_DETAILS_LOADED);
-				
+				else if(!ch.is_available() ) {
+					if ( lineColor.equals(COLOR_WHITE) ) {
+						lineColor.set(COLOR_AVAILABLE);
+					} else {
+						ta.foreground = COLOR_AVAILABLE;
+					}
+				}
+
 				// Now, if a line is selected, blend the determined color with the selection 
 				// color.
-				if (isSelected) mergeColor(COLOR_LINE, COLOR_LINE, COLOR_SELECTED);
-				ta.fillColor = COLOR_LINE;
+				if (isSelected) mergeColor(lineColor, lineColor, COLOR_SELECTED);
+				ta.fillColor = lineColor;
 			} catch (Exception e) {
 				Global.getPref().log("Ignored Exception", e, true);
 			};



From engywuck at mail.berlios.de  Sat Apr 18 09:27:20 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sat, 18 Apr 2009 09:27:20 +0200
Subject: [Cachewolf-svn] r1760 - trunk/src/CacheWolf
Message-ID: <200904180727.n3I7RKGN017331@sheep.berlios.de>

Author: engywuck
Date: 2009-04-18 09:27:18 +0200 (Sat, 18 Apr 2009)
New Revision: 1760

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
Again some optimization in computing cell colours: 1. Computed colour is reused in the same row without recomputation. 2. Reduced object creation.

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-17 22:48:46 UTC (rev 1759)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-18 07:27:18 UTC (rev 1760)
@@ -25,6 +25,11 @@
 	private static final Color COLOR_SELECTED	= new Color(141,141,141);
 	private static final Color COLOR_DETAILS_LOADED		= new Color(229,206,235);
 	private static final Color COLOR_WHITE   	= new Color(255,255,255);
+	private Color lineColorBG                   = new Color(255,255,255);
+	private Color lineColorFG                   = new Color(0,0,0);
+	private Color lastColorBG                   = new Color(255,255,255);
+	private Color lastColorFG                   = new Color(0,0,0);
+	private int lastRow = -2;
 	private CacheDB cacheDB;
 	/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
 	 * the element j (as per the list below) is visible in column i. 
@@ -56,6 +61,7 @@
 //	private int lastRow=-1;
 	private myTableControl tcControl;
 	public boolean showExtraWptInfo=true;
+	private int dbgCnt=0;
 	
 	public myTableModel(myTableControl tc, FontMetrics fm){
 		super();
@@ -159,52 +165,75 @@
 	}
 	
 	/**
-	* Method to set the row color of the table displaying the
-	* cache list, depending on different flags set to the cache.
-	*/
-	/* (non-Javadoc)
+	 * Method to set the row color of the table displaying the cache list, depending on different
+	 * flags set to the cache.
+	 */
+	/*
+	 * (non-Javadoc)
+	 * 
 	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean, ewe.ui.TableCellAttributes)
 	 */
-	public TableCellAttributes getCellAttributes(int row,int col,boolean  isSelected, TableCellAttributes ta){
+	public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected,
+	        TableCellAttributes ta) {
 		ta = super.getCellAttributes(row, col, isSelected, ta);
 		ta.alignment = CellConstants.LEFT;
 		ta.anchor = CellConstants.LEFT;
 		// The default color of a line is white
-		Color lineColor      = new Color(255,255,255);
-		lineColor.set(COLOR_WHITE);
-		if(row >= 0){ 
-			try {
-				// Now find out if the line should be painted in an other color.
-				// Selected lines are not considered, so far
-				CacheHolder ch = cacheDB.get(row);
-				if( ch.is_owned())     lineColor.set(COLOR_OWNED);
-				else if( ch.is_found())     lineColor.set(COLOR_FOUND);
-				else if( ch.is_flaged)        lineColor.set(COLOR_FLAGED);
-				else if( Global.getPref().debug && ch.detailsLoaded()) lineColor.set(COLOR_DETAILS_LOADED);
+		lineColorBG.set(COLOR_WHITE);
+		// Determination of colors is only done for first column. Other columns take same
+		// color.
+		if (row >= 0) {
+			if (row != lastRow) {
+				try {
+					Vm.debug(String.valueOf(row) + " / " + String.valueOf(col) + " / "
+							+ String.valueOf(dbgCnt++));
+					// Now find out if the line should be painted in an other color.
+					// Selected lines are not considered, so far
+					CacheHolder ch = cacheDB.get(row);
+					if (ch.is_owned())
+						lineColorBG.set(COLOR_OWNED);
+					else if (ch.is_found())
+						lineColorBG.set(COLOR_FOUND);
+					else if (ch.is_flaged)
+						lineColorBG.set(COLOR_FLAGED);
+					else if (Global.getPref().debug && ch.detailsLoaded())
+						lineColorBG.set(COLOR_DETAILS_LOADED);
 
-				if( ch.is_archived() ) {
-					if ( lineColor.equals(COLOR_WHITE) ) {
-						lineColor.set(COLOR_ARCHIVED);
-					} else {
-						ta.foreground = COLOR_ARCHIVED;
+					if (ch.is_archived()) {
+						if (lineColorBG.equals(COLOR_WHITE)) {
+							lineColorBG.set(COLOR_ARCHIVED);
+						} else {
+							ta.foreground = COLOR_ARCHIVED;
+						}
+					} else if (!ch.is_available()) {
+						if (lineColorBG.equals(COLOR_WHITE)) {
+							lineColorBG.set(COLOR_AVAILABLE);
+						} else {
+							ta.foreground = COLOR_AVAILABLE;
+						}
 					}
-				}
-				else if(!ch.is_available() ) {
-					if ( lineColor.equals(COLOR_WHITE) ) {
-						lineColor.set(COLOR_AVAILABLE);
-					} else {
-						ta.foreground = COLOR_AVAILABLE;
-					}
-				}
 
-				// Now, if a line is selected, blend the determined color with the selection 
-				// color.
-				if (isSelected) mergeColor(lineColor, lineColor, COLOR_SELECTED);
-				ta.fillColor = lineColor;
-			} catch (Exception e) {
-				Global.getPref().log("Ignored Exception", e, true);
-			};
-		} else if (row==-1 && colMap[col]==0 && Global.getProfile().showBlacklisted()) ta.fillColor=Color.Black;
+					// Now, if a line is selected, blend the determined color with the selection
+					// color.
+					if (isSelected)
+						mergeColor(lineColorBG, lineColorBG, COLOR_SELECTED);
+					ta.fillColor = lineColorBG;
+					lastColorBG.set(ta.fillColor);
+					lastColorFG.set(ta.foreground);
+					lastRow = row;
+				} catch (Exception e) {
+					Global.getPref().log("Ignored Exception", e, true);
+				};
+			} else  {
+				// Here: We already had this row.
+				// Take color computed for last column 
+				ta.fillColor = lastColorBG;
+				ta.foreground = lastColorFG;
+			}
+		} else if (row == -1 && colMap[col] == 0 && Global.getProfile().showBlacklisted()) {
+			ta.fillColor = Color.Black;
+			lastColorBG.set(ta.fillColor);
+		}
 		return ta;
 	}
 



From engywuck at mail.berlios.de  Sat Apr 18 09:33:20 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sat, 18 Apr 2009 09:33:20 +0200
Subject: [Cachewolf-svn] r1761 - trunk/src/CacheWolf
Message-ID: <200904180733.n3I7XKG3020288@sheep.berlios.de>

Author: engywuck
Date: 2009-04-18 09:33:19 +0200 (Sat, 18 Apr 2009)
New Revision: 1761

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
Ooops - forgot some debug statements.

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-18 07:27:18 UTC (rev 1760)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-18 07:33:19 UTC (rev 1761)
@@ -21,12 +21,10 @@
 	private static final Color COLOR_OWNED		= new Color(135,206,235);
 	private static final Color COLOR_AVAILABLE	= new Color(255,128,0);
 	private static final Color COLOR_ARCHIVED	= new Color(200,0,0);
-//	private static final Color COLOR_SELECTED	= new Color(198,198,198);
 	private static final Color COLOR_SELECTED	= new Color(141,141,141);
 	private static final Color COLOR_DETAILS_LOADED		= new Color(229,206,235);
 	private static final Color COLOR_WHITE   	= new Color(255,255,255);
 	private Color lineColorBG                   = new Color(255,255,255);
-	private Color lineColorFG                   = new Color(0,0,0);
 	private Color lastColorBG                   = new Color(255,255,255);
 	private Color lastColorFG                   = new Color(0,0,0);
 	private int lastRow = -2;
@@ -61,7 +59,6 @@
 //	private int lastRow=-1;
 	private myTableControl tcControl;
 	public boolean showExtraWptInfo=true;
-	private int dbgCnt=0;
 	
 	public myTableModel(myTableControl tc, FontMetrics fm){
 		super();
@@ -185,8 +182,6 @@
 		if (row >= 0) {
 			if (row != lastRow) {
 				try {
-					Vm.debug(String.valueOf(row) + " / " + String.valueOf(col) + " / "
-							+ String.valueOf(dbgCnt++));
 					// Now find out if the line should be painted in an other color.
 					// Selected lines are not considered, so far
 					CacheHolder ch = cacheDB.get(row);



From engywuck at mail.berlios.de  Sat Apr 18 11:35:58 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sat, 18 Apr 2009 11:35:58 +0200
Subject: [Cachewolf-svn] r1762 - trunk/src/CacheWolf
Message-ID: <200904180935.n3I9Zwnr004053@sheep.berlios.de>

Author: engywuck
Date: 2009-04-18 11:35:57 +0200 (Sat, 18 Apr 2009)
New Revision: 1762

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
Bugfix: Had to exclude reuse of line colour for first row - otherwise colour of first row wouldn't reset if focus is moved from first to other line. Does someone know a better solution...?

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-18 07:33:19 UTC (rev 1761)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-18 09:35:57 UTC (rev 1762)
@@ -180,7 +180,7 @@
 		// Determination of colors is only done for first column. Other columns take same
 		// color.
 		if (row >= 0) {
-			if (row != lastRow) {
+			if (row==0 || row != lastRow) {
 				try {
 					// Now find out if the line should be painted in an other color.
 					// Selected lines are not considered, so far



From engywuck at mail.berlios.de  Sat Apr 18 19:32:26 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sat, 18 Apr 2009 19:32:26 +0200
Subject: [Cachewolf-svn] r1763 - in trunk/src: CacheWolf CacheWolf/navi exp
Message-ID: <200904181732.n3IHWQsF018842@sheep.berlios.de>

Author: engywuck
Date: 2009-04-18 19:32:16 +0200 (Sat, 18 Apr 2009)
New Revision: 1763

Modified:
   trunk/src/CacheWolf/DescriptionPanel.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/MapImporter.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/exp/ExploristExporter.java
Log:
Cleanup: Removed warning "... may be null at this location" by adding extra checks or little changings in programming.

Modified: trunk/src/CacheWolf/DescriptionPanel.java
===================================================================
--- trunk/src/CacheWolf/DescriptionPanel.java	2009-04-18 09:35:57 UTC (rev 1762)
+++ trunk/src/CacheWolf/DescriptionPanel.java	2009-04-18 17:32:16 UTC (rev 1763)
@@ -65,7 +65,7 @@
         	desc=STRreplace.replace(desc, "</sup>",")");
         }
         Vm.showWait(true);
-        if (isHtml) {
+        if (cache!=null && isHtml) {
             int imageNo = 0;
             if (Global.getPref().descShowImg) {
                 Vector Images;

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2009-04-18 09:35:57 UTC (rev 1762)
+++ trunk/src/CacheWolf/TablePanel.java	2009-04-18 17:32:16 UTC (rev 1763)
@@ -117,17 +117,20 @@
 		int rownum = 0;
 		if (wayPoint != null) {
 			rownum = Global.getProfile().cacheDB.getIndex(wayPoint);
+			// If it is not visible: Go backward in the list of the 
+			// previously visible caches and look if you find
+			// any cache that is now still visible.
 			if ( (rownum < 0) || (rownum>=myMod.numRows) ) {
-				// If it is not visible: Go backward in the list of the 
-				// previously visible caches and look if you find
-				// any cache that is now still visible.
-				int i;
-				for (i=sel-1; i>=0; i--) {
-					CacheHolder checkCache = (CacheHolder) oldVisibleCaches.get(i);
-					rownum = Global.getProfile().cacheDB.getIndex(checkCache.getWayPoint());
-					if ((rownum >= 0) && (rownum < myMod.numRows)) break;
-					rownum = 0;	
-				}
+				if (oldVisibleCaches!=null) {
+	                int i;
+	                for (i = sel - 1; i >= 0; i--) {
+		                CacheHolder checkCache = (CacheHolder) oldVisibleCaches.get(i);
+		                rownum = Global.getProfile().cacheDB.getIndex(checkCache.getWayPoint());
+		                if ((rownum >= 0) && (rownum < myMod.numRows))
+			                break;
+		                rownum = 0;
+	                }
+                }
 			}	
 		}
 		selectRow(rownum);

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2009-04-18 09:35:57 UTC (rev 1762)
+++ trunk/src/CacheWolf/UrlFetcher.java	2009-04-18 17:32:16 UTC (rev 1763)
@@ -36,9 +36,9 @@
 		final int maxRedirections = 5;
 		HttpConnection conn = null;
 		Socket sock = null;
-		int i=-1;
+		int i=0;
 		String urltmp = new String(url);
-		while (urltmp != null && i <= maxRedirections ) { // allow max 5 redirections (http 302 location)
+		do  { // allow max 5 redirections (http 302 location)
 			if (realurl != null) realurl.copyFrom(new String(urltmp));
 			i++;
 			conn = new HttpConnection(urltmp);
@@ -48,7 +48,7 @@
 			sock = conn.connect();
 			if (conn.responseCode >= 400) throw new IOException("URL: "+ urltmp + "\nhttp response code: " + conn.responseCode);
 			urltmp = conn.getRedirectTo();
-		}
+		} while (urltmp != null && i <= maxRedirections ); 
 		if (i > maxRedirections) throw new IOException("too many http redirections while trying to fetch: "+url + " only "+maxRedirections+" are allowed");
 		ByteArray daten = conn.readData(sock);
 		sock.close();

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-18 09:35:57 UTC (rev 1762)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-18 17:32:16 UTC (rev 1763)
@@ -381,7 +381,7 @@
 				sortedBy = mappedCol;
 				cacheDB.sort(new MyComparer(cacheDB, mappedCol,numRows), sortAsc);
 				updateRows();
-				if(a != null){
+				if(a != null && ch!=null){
 					int rownum = Global.getProfile().getCacheIndex(ch.getWayPoint());
 					if(rownum >= 0){
 						tcControl.cursorTo(rownum, 0, true);

Modified: trunk/src/CacheWolf/navi/MapImporter.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImporter.java	2009-04-18 09:35:57 UTC (rev 1762)
+++ trunk/src/CacheWolf/navi/MapImporter.java	2009-04-18 17:32:16 UTC (rev 1763)
@@ -165,11 +165,9 @@
 			try {
 				in = new FileInputStream(curInFullPath);
 				buf = new byte[1024*10];
-				boolean first = true;
 				ByteArray header = new ByteArray(buf);
 				while ((len = in.read(buf)) > 0) {
-					if (first) {
-						first = false;
+					if (out==null) {
 						header.copyFrom(buf, 0, len);
 						ImageInfo tmpII = Image.getImageInfo(header,null);
 						imageWidth = tmpII.width;

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2009-04-18 09:35:57 UTC (rev 1762)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2009-04-18 17:32:16 UTC (rev 1763)
@@ -1950,7 +1950,10 @@
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+					if (!curMapFound && curMap!=null && map.mapName.equals(curMap.mapName)) { 
+						oldmap = row; 
+						curMapFound = true; 
+					}
 				} else inList[i] = false;
 			}
 		}
@@ -1969,7 +1972,10 @@
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+					if (!curMapFound  && curMap!=null && map.mapName.equals(curMap.mapName)) { 
+						oldmap = row; 
+						curMapFound = true; 
+					}
 				}
 			}
 		}
@@ -1987,7 +1993,10 @@
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+					if (!curMapFound  && curMap!=null && map.mapName.equals(curMap.mapName)) { 
+						oldmap = row; 
+						curMapFound = true; 
+					}
 				}
 			}
 		}
@@ -1998,7 +2007,10 @@
 			if(!inList[i]) {
 				list.addItem(i + ": " + ml.filename);
 				row++;
-				if (!curMapFound && ml.filename.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				if (!curMapFound && curMap!=null && ml.filename.equals(curMap.mapName)) { 
+					oldmap = row; 
+					curMapFound = true; 
+				}
 			}
 		}
 		list.selectItem(oldmap, true);

Modified: trunk/src/exp/ExploristExporter.java
===================================================================
--- trunk/src/exp/ExploristExporter.java	2009-04-18 09:35:57 UTC (rev 1762)
+++ trunk/src/exp/ExploristExporter.java	2009-04-18 17:32:16 UTC (rev 1763)
@@ -133,15 +133,16 @@
 		}
 
 		try {
-			PrintWriter outp = null;
+			// Set initial value for outp to calm down compiler
+			PrintWriter outp = new PrintWriter(new BufferedWriter(
+								new FileWriter(new File(fileBaseName + expCount
+										/ 200 + ".gs"))));
 			for (int i = 0; i < cacheDB.size(); i++) {
 				ch = cacheDB.get(i);
 				if (ch.is_black() == false && ch.is_filtered() == false) {
 					// all 200 caches we need a new file
-					if (expCount % 200 == 0) {
-						if (outp != null) {
-							outp.close();
-						}
+					if (expCount % 200 == 0 && expCount > 0) {
+						outp.close();
 						outp = new PrintWriter(new BufferedWriter(
 								new FileWriter(new File(fileBaseName + expCount
 										/ 200 + ".gs"))));



From engywuck at mail.berlios.de  Sat Apr 18 20:17:43 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Sat, 18 Apr 2009 20:17:43 +0200
Subject: [Cachewolf-svn] r1764 - in trunk/src/CacheWolf: . navi
Message-ID: <200904181817.n3IIHh6I011024@sheep.berlios.de>

Author: engywuck
Date: 2009-04-18 20:17:32 +0200 (Sat, 18 Apr 2009)
New Revision: 1764

Modified:
   trunk/src/CacheWolf/AttributesSelector.java
   trunk/src/CacheWolf/DateTimeChooser.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/ImagePanel.java
   trunk/src/CacheWolf/InfoScreen.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Matrix.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/TravelbugList.java
   trunk/src/CacheWolf/myInteractivePanel.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapImporter.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
Cleanup: Removed warning "Field/Parameter ... is hiding field..." mostly by renaming variables.

Modified: trunk/src/CacheWolf/AttributesSelector.java
===================================================================
--- trunk/src/CacheWolf/AttributesSelector.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/AttributesSelector.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -90,8 +90,8 @@
 
 	public void showAttributePalette() {
 		iap.images.clear();
-		int width = 170;
-		int x = 2; int y = 2;
+		int myWidth = 170;
+		int myX = 2; int myY = 2;
 		long bitMask = 0;
 		String attrName;
 		String value;
@@ -113,14 +113,14 @@
 				img.attrNr = i;
 				img.bitMask = bitMask;
 
-				if (x+TILESIZE > width) {
-					x = 2;
-					y += TILESIZE;
+				if (myX+TILESIZE > myWidth) {
+					myX = 2;
+					myY += TILESIZE;
 				}
-				img.location=new Rect(x,y,TILESIZE,TILESIZE);
+				img.location=new Rect(myX,myY,TILESIZE,TILESIZE);
 				//System.out.println("img.location=new Rect("+x+","+y+","+TILESIZE+","+TILESIZE+");");
 				iap.addImage(img);
-				x += TILESIZE;
+				myX += TILESIZE;
 			}
 		}
 		iap.repaintNow();

Modified: trunk/src/CacheWolf/DateTimeChooser.java
===================================================================
--- trunk/src/CacheWolf/DateTimeChooser.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/DateTimeChooser.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -42,10 +42,10 @@
 		//return new Time(day,month,year);
 	}
 	
-	void addTable(TableControl tc,TableModel tm,String name) {
+	void addTable(TableControl tc,TableModel tm,String pName) {
 		tc.setTableModel(tm);
 		tc.setClickMode(true);
-		panels.addItem(tc,name,null);
+		panels.addItem(tc,pName,null);
 		//tc.addListener(this);
 	}
 	

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/FilterScreen.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -80,9 +80,9 @@
 		mButton mb=new mButton(new mImage(imgName)); mb.borderWidth=0; mb.modify(NotEditable|PreferredSizeOnly,0);
 		return mb;
 	}
-	private void addTitle(CellPanel c, String title) {
+	private void addTitle(CellPanel c, String pTitle) {
 		mLabel lblTitle;
-		c.addLast(lblTitle=new mLabel(title),HSTRETCH,FILL|CENTER);
+		c.addLast(lblTitle=new mLabel(pTitle),HSTRETCH,FILL|CENTER);
 		lblTitle.backGround=new Color(127,127,127); 
 		lblTitle.foreGround=Color.White; 
 		lblTitle.setTag(INSETS,new Insets(2,0,4,0));

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/ImagePanel.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -99,7 +99,7 @@
 	 */
 	private void addTitle(String title) {
 		AniImage aImg;
-		Font font = new Font("Verdana", Font.BOLD, 20);
+		Font titleFont = new Font("Verdana", Font.BOLD, 20);
 		FontMetrics fm = getFontMetrics();
 		int stringWidth = fm.getTextWidth(title);
 		int stringHeight = fm.getHeight();
@@ -108,7 +108,7 @@
 		g.setColor(new Color(195,195,195));
 		g.fillRect(0,0,stringWidth*2,stringHeight+5);
 		g.setColor(new Color(0,0,0));
-		g.setFont(font);
+		g.setFont(titleFont);
 		g.drawText(title, 0,0);
 		g.free();
 		aImg = new AniImage(img);
@@ -119,10 +119,10 @@
 	
 	/**
 	 * Add the images to the panel. Can add both normal and user images
-	 * @param images Vector of images or userImages
+	 * @param pImages Vector of images or userImages
 	 * @param imagesText Vector of image texts or user image texts
 	 */
-	private void addImages(Vector images, Vector imagesText) {
+	private void addImages(Vector pImages, Vector imagesText) {
 		String location, imgText;
 		mImage mI;
 		int scaleX, scaleY;
@@ -130,8 +130,8 @@
 		ImagePanelImage ipi;
 		AniImage AimgText;
 		locCounter=0;
-		for(int i = 0; i<images.size(); i++){
-			location = profile.dataDir + (String)images.get(i);
+		for(int i = 0; i<pImages.size(); i++){
+			location = profile.dataDir + (String)pImages.get(i);
 			if (!(new FileBugfix(location)).exists()) {
 				location=NO_IMAGE;
 				if (!pref.showDeletedImages) continue; // Don't show the deleted Image if user does not want it
@@ -203,18 +203,18 @@
 		
 	}
 	
-	private AniImage getImageText(String text){
-		Font font = new Font("Verdana", Font.BOLD, 14);
+	private AniImage getImageText(String pText){
+		Font aniImageFont = new Font("Verdana", Font.BOLD, 14);
 		FontMetrics fm = getFontMetrics();
-		int stringWidth = fm.getTextWidth(text);
+		int stringWidth = fm.getTextWidth(pText);
 		int stringHeight = fm.getHeight();
 		Image img = new Image(stringWidth*2,stringHeight+5);
 		Graphics g = new Graphics(img);
 		g.setColor(new Color(195,195,195));
 		g.fillRect(0,0,stringWidth*2,stringHeight+5);
 		g.setColor(new Color(0,0,0));
-		g.setFont(font);
-		g.drawText(text, 0,0);
+		g.setFont(aniImageFont);
+		g.drawText(pText, 0,0);
 		g.free();
 		AniImage a = new AniImage(img);
 		return a;

Modified: trunk/src/CacheWolf/InfoScreen.java
===================================================================
--- trunk/src/CacheWolf/InfoScreen.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/InfoScreen.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -18,19 +18,19 @@
 	
 	public InfoScreen(String datei, String tit, boolean readFromFile, Preferences p){
 		pref = p;
-		String text = new String();
+		String myText = new String();
 		this.setTitle(tit);
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		if(readFromFile == true){
 			try{
 				FileReader in = new FileReader(datei);
-				text = in.readAll();
+				myText = in.readAll();
 				in.close();
 			}catch(Exception ex){
 				//Vm.debug("Error! Could not open " + datei);
 			}
-		} else text = datei;
-		disp.setHtml(text);
+		} else myText = datei;
+		disp.setHtml(myText);
 		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
 		this.addLast(sbp);
 		this.addLast(btCancel = new mButton(MyLocale.getMsg(3000,"Close")),CellConstants.DONTSTRETCH, CellConstants.FILL);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/MainTab.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -275,12 +275,12 @@
 	/**
 	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to 
 	 * offer the user the possibility of entering an new waypoint
-	 * at a given position. ch must already been preset with a valid
+	 * at a given position. pCh must already been preset with a valid
 	 * CacheHolder object
 	 * 
-	 * @param ch
+	 * @param pCh
 	 */
-	public void newWaypoint(CacheHolder ch){
+	public void newWaypoint(CacheHolder pCh){
 		//When creating a new waypoint, simulate a change to the list view
 		//if we are currently NOT in the list view
 		if (oldCard != 0)
@@ -297,21 +297,21 @@
 				mainCache = selectedCache.mainCache.getWayPoint();
 			}			
 		}
-		if (CacheType.isAddiWpt(ch.getType()) && mainCache!=null && mainCache.length()>2) {
-			ch.setWayPoint(profile.getNewAddiWayPointName(mainCache));
-			profile.setAddiRef(ch);
+		if (CacheType.isAddiWpt(pCh.getType()) && mainCache!=null && mainCache.length()>2) {
+			pCh.setWayPoint(profile.getNewAddiWayPointName(mainCache));
+			profile.setAddiRef(pCh);
 		} else { 
-			ch.setWayPoint(profile.getNewWayPointName());
-			ch.setType(0);
-			lastselected=ch.getWayPoint();
+			pCh.setWayPoint(profile.getNewWayPointName());
+			pCh.setType(0);
+			lastselected=pCh.getWayPoint();
 		}
-		ch.setCacheSize("None");
-		chD = ch.getCacheDetails(true);
-		this.ch = ch;
-		cacheDB.add(ch);
+		pCh.setCacheSize("None");
+		chD = pCh.getCacheDetails(true);
+		this.ch = pCh;
+		cacheDB.add(pCh);
 		Global.getProfile().notifyUnsavedChanges(true); // Just to be sure 
 		tbP.myMod.numRows++;
-		detP.setDetails(ch);
+		detP.setDetails(pCh);
 		oldCard=1;
 		if (this.cardPanel.selectedItem != 1) select(detP);
 		solverP.setInstructions("");

Modified: trunk/src/CacheWolf/Matrix.java
===================================================================
--- trunk/src/CacheWolf/Matrix.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/Matrix.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -154,12 +154,12 @@
 	/**
 	*	Method to calculate the determinate of a matrix
 	*/
-	public double Determinant(double[][] matrix) {
-		int tms = matrix.length;
+	public double Determinant(double[][] pMatrix) {
+		int tms = pMatrix.length;
 		double det = 1;
-		matrix = UpperTriangle(matrix);
+		pMatrix = UpperTriangle(pMatrix);
 		for (int i = 0; i < tms; i++) {
-			det = det * matrix[i][i];
+			det = det * pMatrix[i][i];
 		} // multiply down diagonal
 		det = det * iDF; // adjust w/ determinant factor
 		return det;

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -342,8 +342,8 @@
 
 	}
 
-	public void characters(char[] ch,int start,int length){
-		String chars = new String(ch,start,length);
+	public void characters(char[] ch2,int start,int length){
+		String chars = new String(ch2,start,length);
 		strData += chars;
 		if (debugGPX) Vm.debug(strData);
 	}

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/RadarPanel.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -95,11 +95,11 @@
 	* Private method to draw the caches.
 	*/
 	private void drawCaches(){
-		Font font = new Font("Gui", Font.BOLD,Global.getPref().fontSize);
-		FontMetrics fm = getFontMetrics(font);
+		Font radarFont = new Font("Gui", Font.BOLD,Global.getPref().fontSize);
+		FontMetrics fm = getFontMetrics(radarFont);
 		AniImage aImg;
 		RadarPanelImage rpi;
-		int x,y = 0;
+		int drX,drY = 0;
 		CacheHolder holder;
 		double degrees;
 		double pi180=java.lang.Math.PI / 180.0;
@@ -107,9 +107,9 @@
 			holder = cacheDB.get(i);
 			if(!holder.is_filtered() && holder.pos.isValid()) {
 				degrees = holder.degrees * pi180;
-				x =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
-				y = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
-				if(centerX+x>=0 && centerY+y>=0 && centerX+x<=width && centerY+y <= height){
+				drX =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
+				drY = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
+				if(centerX+drX>=0 && centerY+drY>=0 && centerX+drX<=width && centerY+drY <= height){
 					if (toggleMod>0) {
 						String s;
 						if (toggleMod==1)
@@ -120,13 +120,13 @@
 							int tw;
 							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
 							Graphics g = new Graphics(img);
-							g.setFont(font);
+							g.setFont(radarFont);
 							g.setColor(Color.Black);
 							g.fillRect(0,0,tw, fm.getHeight());
 							g.setColor(Color.White);
 							g.drawText(s, 0,0);
 							aImg = new AniImage(img);
-							aImg.setLocation(centerX+x+5,centerY+y);
+							aImg.setLocation(centerX+drX+5,centerY+drY);
 							aImg.transparentColor = Color.Black;
 							aImg.properties = mImage.IsNotHot;
 							iActP.addImage(aImg);
@@ -138,7 +138,7 @@
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;
-					rpi.setLocation(centerX+x-7,centerY+y-7);
+					rpi.setLocation(centerX+drX-7,centerY+drY-7);
 					iActP.addImage(rpi);
 					if(holder.getWayPoint().equals(selectedWaypoint)){ // Draw red circle around selected wpt
 						Image imgCircle = new Image(20, 20);
@@ -148,7 +148,7 @@
 						gCircle.setColor(new Color(255,0,0));
 						gCircle.drawEllipse(0,0, 20,20);
 						aImg = new AniImage(imgCircle);
-						aImg.setLocation(centerX+x-9,centerY+y-9);
+						aImg.setLocation(centerX+drX-9,centerY+drY-9);
 						aImg.transparentColor = new Color(0,0,0);
 						aImg.properties = mImage.IsNotHot;
 						iActP.addImage(aImg);

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -90,34 +90,34 @@
 			return ERR_LOGIN;
 		}
 		//Get password
-		InfoBox infB = new InfoBox(MyLocale.getMsg(5506,"Password"), MyLocale.getMsg(5505,"Enter Password"), InfoBox.INPUT);
-		infB.feedback.setText(passwort); // Remember the PWD for next time
-		infB.feedback.isPassword=true;
-		int code = infB.execute();
-		passwort = infB.getInput();
-		infB.close(0);
+		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506,"Password"), MyLocale.getMsg(5505,"Enter Password"), InfoBox.INPUT);
+		localInfB.feedback.setText(passwort); // Remember the PWD for next time
+		localInfB.feedback.isPassword=true;
+		int code = localInfB.execute();
+		passwort = localInfB.getInput();
+		localInfB.close(0);
 		if(code != FormBase.IDOK) return code;
 
 		// Now start the login proper
-		infB = new InfoBox(MyLocale.getMsg(5507,"Status"), MyLocale.getMsg(5508,"Logging in..."));
-		infB.exec();
+		localInfB = new InfoBox(MyLocale.getMsg(5507,"Status"), MyLocale.getMsg(5508,"Logging in..."));
+		localInfB.exec();
 		try{
 			pref.log("[login]:Fetching login page");
 			//Access the page once to get a viewstate
 			start = fetch(loginPage);   //http://www.geocaching.com/login/Default.aspx
 			if (start.equals("")) {
-				infB.close(0);
+				localInfB.close(0);
 				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5499,"Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 				pref.log("[login]:Could not fetch: gc.com login page");
 				return ERR_LOGIN;
 			}
 		} catch(Exception ex){
-			infB.close(0);
+			localInfB.close(0);
 			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5499,"Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 			pref.log("[login]:Could not fetch: gc.com login page",ex);
 			return ERR_LOGIN;
 		}
-		if (!infB.isClosed) { // If user has not aborted, we continue
+		if (!localInfB.isClosed) { // If user has not aborted, we continue
 			Regex rexCookieID = new Regex("(?i)Set-Cookie: userid=(.*?);.*");
 			Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
 			Regex rexEventvalidation = new Regex("id=\"__EVENTVALIDATION\" value=\"(.*?)\" />");
@@ -162,13 +162,13 @@
 							pref.log("[login.LoginUrl]:"+sb.toString());
 							pref.log("[login.Answer]:"+start);
 						}
-						infB.close(0);
+						localInfB.close(0);
 						(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5501,"Login failed! Wrong account or password?"), FormBase.OKB)).execute();
 						return ERR_LOGIN;
 					}
 				}catch(Exception ex){
 					pref.log("[login]:Login failed with exception.", ex);
-					infB.close(0);
+					localInfB.close(0);
 					(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5501,"Login failed. Error loading page after login."), FormBase.OKB)).execute();
 					return ERR_LOGIN;
 				}
@@ -193,8 +193,8 @@
 				cookieSession = rexCookieSession.stringMatched(1);
 			//Vm.debug("cookieSession = " + cookieSession);
 		}
-		boolean loginAborted=infB.isClosed;
-		infB.close(0);
+		boolean loginAborted=localInfB.isClosed;
+		localInfB.close(0);
 		if (loginAborted)
 			return FormBase.IDCANCEL;
 		else {
@@ -208,9 +208,9 @@
 	 * It assumes a login has already been performed!
 	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
 	 */
-	public int spiderSingle(int number, InfoBox infB, boolean forceLogin){
+	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin){
 		int ret=-1;
-		this.infB = infB;
+		this.infB = pInfB;
 		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
 		ch.setWayPoint(cacheDB.get(number).getWayPoint());
 		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
@@ -250,18 +250,18 @@
 				return "";
 			}
 		}
-		InfoBox infB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
-		infB.exec();
+		InfoBox localInfB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
+		localInfB.exec();
 		try{
 			String doc = p.getProp("waypoint") + wayPoint;
 			pref.log("Fetching: " + wayPoint);
 			completeWebPage = fetch(doc);
 		}catch(Exception ex){
-			infB.close(0);
+			localInfB.close(0);
 			pref.log("Could not fetch " + wayPoint,ex);
 			return "";
 		}
-		infB.close(0);
+		localInfB.close(0);
 		try {
 			return getLatLon(completeWebPage);
 		} catch (Exception ex) {
@@ -1451,9 +1451,9 @@
 			boolean gotany = false;
 
 			for (int i = 0; i < pl.size(); i++) {
-				Property p = (Property)pl.get(i);
-				if (p.value != null) {
-					sb.append(p.name).append(": ").append(p.value).append("\r\n");
+				Property currProp = (Property)pl.get(i);
+				if (currProp.value != null) {
+					sb.append(currProp.name).append(": ").append(currProp.value).append("\r\n");
 					gotany = true;
 				}
 			}

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/TablePanel.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -70,11 +70,11 @@
 		return tc.cursor.y;
 	}
 	
-	public void saveColWidth(Preferences pref){
+	public void saveColWidth(Preferences pPref){
 		String colWidths=myMod.getColWidths();
-		if (!colWidths.equals(pref.listColWidth)) {
-			pref.listColWidth=colWidths;
-			pref.savePreferences();
+		if (!colWidths.equals(pPref.listColWidth)) {
+			pPref.listColWidth=colWidths;
+			pPref.savePreferences();
 		}
 	}
 	

Modified: trunk/src/CacheWolf/TravelbugList.java
===================================================================
--- trunk/src/CacheWolf/TravelbugList.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/TravelbugList.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -29,8 +29,8 @@
 	}
 
 	/** Add a travelbug to the list */
-	public void add(Travelbug tb) {
-		tbList.add(tb);
+	public void add(Travelbug pTb) {
+		tbList.add(pTb);
 	}
 	
 	/** Remove a travelbug from the list */
@@ -39,8 +39,8 @@
 	}
 
 	/** Replace a travelbug in the list */
-	public void replace(int i, Travelbug tb) {
-		tbList.set(i, tb);
+	public void replace(int i, Travelbug pTb) {
+		tbList.set(i, pTb);
 	}
 	
 	/** Construct an empty travelbug list */
@@ -69,7 +69,7 @@
 		while(fnd>=0) {
 			int fnd2=htmlList.indexOf("<br>",fnd+12);
 			int fnd3=htmlList.indexOf("<b>Name:</b>",fnd2+4);
-			Travelbug tb=new Travelbug(htmlList.substring(fnd+12,fnd2));
+			Travelbug tb2=new Travelbug(htmlList.substring(fnd+12,fnd2));
 			String mission;
 			if (fnd3>0) {
 				mission=htmlList.substring(fnd2+4,fnd3);
@@ -77,8 +77,8 @@
 				mission=htmlList.substring(fnd2+4);
 			}
 			if (mission.endsWith("<hr>")) mission=mission.substring(0,mission.length()-4);
-			tb.setMission(mission);
-			tbList.add(tb);
+			tb2.setMission(mission);
+			tbList.add(tb2);
 			fnd=fnd3;
 		}
 	}

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -16,14 +16,18 @@
 	boolean penMoving = false;
 	int x1,y1,x2,y2 = 0;
 	static Color RED = new Color(255,0,0);
-	Font font = new Font("gui", Font.BOLD,Global.getPref().fontSize);
-	FontMetrics fm = getFontMetrics(font);
+	//Font font = new Font("gui", Font.BOLD,Global.getPref().fontSize);
+	FontMetrics fm = null;
 	long timePenOn=0;
 	AniImage imgInfo;
 	String strDifficulty=MyLocale.getMsg(1120,"Diff");
 	String strTerrain=MyLocale.getMsg(1121,"Terr");
 	AniImage imgDrag; // Allows the dragging of the cache into the cachelist
 	boolean canScroll=true;
+	{
+		font = new Font("gui", Font.BOLD,Global.getPref().fontSize);
+		fm = getFontMetrics(font);
+	}
 	
 	private void clearInfo() {
 		removeImage(imgInfo);

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/myTableControl.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -122,8 +122,8 @@
 	
 	 
 	/** always select a whole row */
-	public boolean isSelected(int row,int col) {
-		return row==selection.y;
+	public boolean isSelected(int pRow,int pCol) {
+		return pRow==selection.y;
 	}
 	
 	public void popupMenuEvent(Object selectedItem){
@@ -286,7 +286,6 @@
 	int row;
 	
 	public void startDragging(DragContext dc) {
-		CacheDB cacheDB=Global.getProfile().cacheDB;
 		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
 		 wayPoint=null;
 		 if (p.y>=0) { 
@@ -331,18 +330,18 @@
 	 		super.dragged(dc);
 	 }
 
-	 public void cursorTo(int row,int col,boolean selectNew) {
-		if (row != -2 && col != -2 && !canSelect(row,col)) return;
-		cursor.set(col,row);
+	 public void cursorTo(int pRow,int pCol,boolean selectNew) {
+		if (pRow != -2 && pCol != -2 && !canSelect(pRow,pCol)) return;
+		cursor.set(pCol,pRow);
 		if (selectNew){
 			clearSelectedCells(oldExtendedSelection);
 			paintCells(null,oldExtendedSelection);
-			if (row != -2 && col != -2){
-				if (scrollToVisible(row,col)) repaintNow();
-				addToSelection(Rect.buff.set(0,row,model.numCols,1),true);
+			if (pRow != -2 && pCol != -2){
+				if (scrollToVisible(pRow,pCol)) repaintNow();
+				addToSelection(Rect.buff.set(0,pRow,model.numCols,1),true);
 				//fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
 				clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
-				if (clickMode) clicked(row,col);
+				if (clickMode) clicked(pRow,pCol);
 				clickedFlags = 0;
 			}
 		}

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -179,10 +179,10 @@
 //		}	
 	}
 	
-	public void resizeTo(int width, int height){
-		super.resizeTo(width, height);
+	public void resizeTo(int pWidth, int pHeight){
+		super.resizeTo(pWidth, pHeight);
 		Rect coordsRect = CoordsP.getRect();
-		int roseHeight = height - coordsRect.y - coordsRect.height;
+		int roseHeight = pHeight - coordsRect.y - coordsRect.height;
 		if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
 			//some space for the SIP button
 			if ( (Vm.getParameter(VmConstants.VM_FLAGS) & (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
@@ -190,9 +190,9 @@
 				roseHeight -= screen.height / 14;				
 			}
 		}
-		roseP.resizeTo(width, roseHeight); 
-		icRose.resizeTo(width, roseHeight);
-		compassRose.resize(width, roseHeight);
+		roseP.resizeTo(pWidth, roseHeight); 
+		icRose.resizeTo(pWidth, roseHeight);
+		compassRose.resize(pWidth, roseHeight);
 	}
 
 

Modified: trunk/src/CacheWolf/navi/MapImporter.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImporter.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/navi/MapImporter.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -48,9 +48,9 @@
 	 *	info panel below the map.
 	 *	It helps to identify how good the georeferencing works based on the set GCPs.
 	 */
-	public void updatePosition(int x, int y){
+	public void updatePosition(int px, int py){
 		if(GCPs.size()>=3  || (wfl.topleft.isValid())){
-			CWPoint p = wfl.calcLatLon(x,y);
+			CWPoint p = wfl.calcLatLon(px,py);
 			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
 		}
 	}

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -59,7 +59,6 @@
 	float scale;
 	int overlapping;
 	boolean overviewmap;
-	int numCaches;
 
 	public MapLoaderGui(CacheDB cacheDBi) {
 		super();
@@ -222,9 +221,9 @@
 		}
 		if (overviewmap) {
 			progressBox.setInfo(MyLocale.getMsg(1824, "downloading overview map")); 
-			float scale = MapLoader.getScale(center, radius * 1000, size);
+			float overviewScale = MapLoader.getScale(center, radius * 1000, size);
 			try {
-				mapLoader.downloadMap(center, scale, size, mapsDir);
+				mapLoader.downloadMap(center, overviewScale, size, mapsDir);
 			} catch (Exception e) {
 				progressBox.addWarning(MyLocale.getMsg(1825, "Overview map: Ignoring error:")+" " + e.getMessage()+"\n");
 			}

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2009-04-18 17:32:16 UTC (rev 1763)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2009-04-18 18:17:32 UTC (rev 1764)
@@ -144,19 +144,19 @@
 		mmp.addImage(buttonImageZoom1to1);
 		//target distance
 		int fontSize = ( 3 * pref.fontSize ) / 2;
-		Font font = new Font("Helvetica", Font.PLAIN, fontSize );
-		fm = getFontMetrics(font);
+		Font imageFont = new Font("Helvetica", Font.PLAIN, fontSize );
+		fm = getFontMetrics(imageFont);
 		DistanceImage = new AniImage();
 		DistanceImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight() ), Color.White); // consider the size of the font used
 		DistanceImageGraphics = new Graphics(DistanceImage.image);
-		DistanceImageGraphics.setFont(font);
+		DistanceImageGraphics.setFont(imageFont);
 		DistanceImage.properties = mImage.AlwaysOnTop;
 		mmp.addImage(DistanceImage);
 		//scale
 		ScaleImage = new AniImage();
 		ScaleImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight() ), Color.White); // consider the size of the font used
 		ScaleImageGraphics = new Graphics(ScaleImage.image);
-		ScaleImageGraphics.setFont(font);
+		ScaleImageGraphics.setFont(imageFont);
 		ScaleImage.properties = mImage.AlwaysOnTop;
 		mmp.addImage(ScaleImage);
 		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialise mapImage.screenSize
@@ -661,13 +661,13 @@
 		int ww = ws.width;
 		int wh = ws.height;
 		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
-		int num, x, y;
+		int num, pX, pY;
 		for (int yi=0; yi<3; yi++) {
 			for (int xi=0; xi<3; xi++) {
 				num = yi*3+xi;
-				x = posOnScreen.x+(xi-1)*ww;
-				y = posOnScreen.y+(yi-1)*wh; 
-				TrackOverlays[num].setLocation(x, y);
+				pX = posOnScreen.x+(xi-1)*ww;
+				pY = posOnScreen.y+(yi-1)*wh; 
+				TrackOverlays[num].setLocation(pX, pY);
 			}
 		}
 	}
@@ -773,9 +773,9 @@
 		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 	}
 
-	public CWPoint ScreenXY2LatLon (int x, int y){
+	public CWPoint ScreenXY2LatLon (int px, int py){
 		Point mapPos = getMapPositionOnScreen();
-		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
+		return currentMap.calcLatLon(px - mapPos.x, py - mapPos.y);
 	}
 
 
@@ -793,9 +793,9 @@
 		}
 	}
 
-	public MapSymbol addSymbol(String name, String filename, CWPoint where) {
+	public MapSymbol addSymbol(String pName, String filename, CWPoint where) {
 		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, filename, where);
+		MapSymbol ms = new MapSymbol(pName, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
 		Point pOnScreen = getXYonScreen(where);
@@ -805,15 +805,15 @@
 		return ms;
 	}
 	
-	public void addSymbolIfNecessary(String name, Object mapObject, Image imSymb, CWPoint where) {
-		if (findMapSymbol(name) >= 0) return;
-		else addSymbol(name, mapObject, imSymb, where);
+	public void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
+		if (findMapSymbol(pName) >= 0) return;
+		else addSymbol(pName, mapObject, imSymb, where);
 		
 	}
 		
-	public void addSymbol(String name, Object mapObject, Image imSymb, CWPoint ll) {
+	public void addSymbol(String pName, Object mapObject, Image imSymb, CWPoint ll) {
 		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, ll);
+		MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
 		ms.properties = mImage.AlwaysOnTop;
 		Point pOnScreen = getXYonScreen(ll);
 		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
@@ -850,8 +850,8 @@
 		if (gotoPos != null) symbols.add(gotoPos);
 	}
 
-	public void removeMapSymbol(String name) {
-		int symbNr = findMapSymbol(name);
+	public void removeMapSymbol(String pName) {
+		int symbNr = findMapSymbol(pName);
 		if (symbNr != -1) removeMapSymbol(symbNr);
 	}
 
@@ -866,12 +866,12 @@
 		symbols.removeElementAt(SymNr);
 	}
 
-	public int findMapSymbol(String name) {
+	public int findMapSymbol(String pName) {
 		if (symbols == null) return -1;
 		MapSymbol ms;
 		for (int i = symbols.size() -1; i >= 0 ; i--) {
 			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == name) return i;
+			if (ms.name == pName) return i;
 		}
 		return -1;
 	}
@@ -1076,22 +1076,22 @@
 	public Object[] getRectForMapChange(CWPoint ll) {
 		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
 		int h = (height != 0 ? height : pref.myAppHeight);
-		int x, y;
+		int pX, pY;
 		CWPoint cll;
 		Boolean posCircleOnScreen = java.lang.Boolean.FALSE;
 		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h && ll.isValid()) {
 			posCircleOnScreen = java.lang.Boolean.TRUE;
-			x = posCircleX; // posCircle is inside the screen
-			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			pX = posCircleX; // posCircle is inside the screen
+			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
 		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
 			cll = ScreenXY2LatLon(w/2, h/2);
-			x = w/2;
-			y = h/2;
+			pX = w/2;
+			pY = h/2;
 		} 
 		Object[] ret = new Object[3];
 		ret[0] = cll;
-		ret[1] = new Rect(x, y, w, h);
+		ret[1] = new Rect(pX, pY, w, h);
 		ret[2] = posCircleOnScreen;
 		return ret; 
 	}



From engywuck at mail.berlios.de  Mon Apr 20 19:27:18 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Mon, 20 Apr 2009 19:27:18 +0200
Subject: [Cachewolf-svn] r1765 - in trunk: res_noewe/languages src/CacheWolf
Message-ID: <200904201727.n3KHRI0R023667@sheep.berlios.de>

Author: engywuck
Date: 2009-04-20 19:27:00 +0200 (Mon, 20 Apr 2009)
New Revision: 1765

Added:
   trunk/src/CacheWolf/SearchBox.java
Modified:
   trunk/res_noewe/languages/DE.cfg
   trunk/res_noewe/languages/EN.cfg
   trunk/res_noewe/languages/FR.cfg
   trunk/res_noewe/languages/NL.cfg
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/SearchCache.java
Log:
Added possibility to search in Description and Notes of cache.

Modified: trunk/res_noewe/languages/DE.cfg
===================================================================
--- trunk/res_noewe/languages/DE.cfg	2009-04-18 18:17:32 UTC (rev 1764)
+++ trunk/res_noewe/languages/DE.cfg	2009-04-20 17:27:00 UTC (rev 1765)
@@ -107,6 +107,7 @@
 		215=nach LOC
 		216=Immer bei GC einloggen
 		217=Spider alle Funde von geocaching.com
+		218=Auch in Beschreibung/Notizen
 		300=Type:
 		301=Gr%f6%dfe:
 		302=Wegpunkt:

Modified: trunk/res_noewe/languages/EN.cfg
===================================================================
--- trunk/res_noewe/languages/EN.cfg	2009-04-18 18:17:32 UTC (rev 1764)
+++ trunk/res_noewe/languages/EN.cfg	2009-04-20 17:27:00 UTC (rev 1765)
@@ -107,6 +107,7 @@
 		215=to LOC
 		216=Always login to GC
 		217=Spider all finds from geocaching.com
+		218=Also in description/notes
 		300=Type:
 		301=Size:
 		302=Waypoint:

Modified: trunk/res_noewe/languages/FR.cfg
===================================================================
--- trunk/res_noewe/languages/FR.cfg	2009-04-18 18:17:32 UTC (rev 1764)
+++ trunk/res_noewe/languages/FR.cfg	2009-04-20 17:27:00 UTC (rev 1765)
@@ -104,6 +104,7 @@
 		212=Effacer toutes les fichier .xml (et images) qui ne sont pas en index.xml
 		213=Effacer les fichier .xml orpheline
 		214=Nouveau waypoint
+		218=Aussi dans description/notes
 		300=Type:
 		301=Gabarit:
 		302=Waypoint:

Modified: trunk/res_noewe/languages/NL.cfg
===================================================================
--- trunk/res_noewe/languages/NL.cfg	2009-04-18 18:17:32 UTC (rev 1764)
+++ trunk/res_noewe/languages/NL.cfg	2009-04-20 17:27:00 UTC (rev 1765)
@@ -96,6 +96,7 @@
 		205=Radar
 		206=Lijst
 		214=Nieuwe Waypoint
+		218=Ook in opmerkingen/beschrijving
 		300=Type:
 		301=Grote:
 		302=Waypoint:

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2009-04-18 18:17:32 UTC (rev 1764)
+++ trunk/src/CacheWolf/MainMenu.java	2009-04-20 17:27:00 UTC (rev 1765)
@@ -38,6 +38,7 @@
 	private TablePanel tbp;
 	private FilterScreen scnFilter=new FilterScreen();
 	private boolean addExeToGpsbabel = false;
+	private static boolean searchInDescriptionAndNotes = false;
 
 	public MainMenu(Form f){
 		father = f;
@@ -245,10 +246,12 @@
 	}
 
 	public static void search() {
-		String srch = new InputBox(MyLocale.getMsg(119,"Search for:")).input("",10);
+		SearchBox inp = new SearchBox(MyLocale.getMsg(119,"Search for:"));
+		String srch = inp.input(null,"",searchInDescriptionAndNotes,10);
 		if (srch != null) {
+			searchInDescriptionAndNotes = inp.useNoteDesc();
 			SearchCache ssc = new SearchCache(Global.getProfile().cacheDB);
-			ssc.search(srch);
+			ssc.search(srch, searchInDescriptionAndNotes);
 			Global.mainTab.tbP.refreshTable();
 		}
 	}

Added: trunk/src/CacheWolf/SearchBox.java
===================================================================
--- trunk/src/CacheWolf/SearchBox.java	2009-04-18 18:17:32 UTC (rev 1764)
+++ trunk/src/CacheWolf/SearchBox.java	2009-04-20 17:27:00 UTC (rev 1765)
@@ -0,0 +1,95 @@
+package CacheWolf;
+
+import ewe.ui.CellConstants;
+import ewe.ui.Control;
+import ewe.ui.Frame;
+import ewe.ui.InputBox;
+import ewe.ui.mCheckBox;
+
+/**
+ * A SearchBox is a customized input box optimized for searching in CacheWolf. The actual
+ * implementation is able to display a CheckBox which with label "in Notes/Description".
+
+ * @author Engywuck
+ */
+public class SearchBox extends InputBox {
+
+	protected mCheckBox useNoteDesc;
+	protected boolean buildingForm = false;
+
+	/**
+	 * Creates the search box with given title.
+	 * @param title The titel of the box
+	 */
+	public SearchBox(String title) {
+		super(title);
+	}
+
+	/**
+	 * Displays the search Box and returns the String value entered, if OK is pressed, otherwise
+	 * the value is null.
+	 * @param initialValue Initial value to display in the search box
+	 * @param checkUseNoteDesc Initial value for check box
+	 * @param pWidth ?
+	 * @return String to search for if ok is pressed and a string is entered, <code>null</code> otherwise.
+	 */
+	public String input(String initialValue, boolean checkUseNoteDesc, int pWidth) {
+		return this.input(null, initialValue, checkUseNoteDesc, pWidth);
+	}
+	
+	protected String input(Frame pParent, String initialValue, boolean checkUseNoteDesc, int pWidth) {
+		String result;
+		buildingForm = true;
+		useNoteDesc = new mCheckBox(MyLocale.getMsg(218,"Also in description/notes"));//,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		useNoteDesc.setState(checkUseNoteDesc);		
+		result = super.input(pParent, initialValue, pWidth);
+		return result;
+    }
+	
+	/**
+	 * Queries the check box if it is checked or not.
+	 * @return <code>True</code> if check box is checked, <code>false</code> if not.
+	 */
+	public boolean useNoteDesc() {
+		boolean result = false;
+		if (useNoteDesc != null) {
+			result = useNoteDesc.getState();
+		}
+		return result;
+	}
+	
+	public Control addLast(Control c) {
+		// This method is a dirty hack, because in InputBox every thing, from creation of the 
+		// controls to displaying it and returning the return value is done at once.
+		// To be able to add other controls, I have to enhance the addLast(Control) method - not
+		// nice but it works.
+		Control result;
+		if (!buildingForm) {
+			result = super.addLast(c);
+		} else {
+			buildingForm = false;
+			this.addControlsBeforeInput();
+			result = super.addLast(c);
+			this.addControlsAfterInput();
+		}
+		return result;
+	}
+
+	/**
+	 * Called before creating the input box. Additional controls may be added here.
+	 */
+	private void addControlsBeforeInput() {
+		// For future use 
+	}
+
+	/**
+	 * Called after creating the input box. Additional controls may be added here.
+	 */
+	private void addControlsAfterInput() {
+		if (useNoteDesc != null) {
+			this.addLast(useNoteDesc,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		}
+    }
+
+
+}

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-18 18:17:32 UTC (rev 1764)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-20 17:27:00 UTC (rev 1765)
@@ -20,7 +20,7 @@
 	* and / or cache name) is flagged as matching. The search only
 	* acts on the filtered (=visible) set of caches
 	*/
-	public void search(String searchStr){
+	public void search(String searchStr, boolean searchInDescriptionAndNotes){
 		if(searchStr.length()>0){
 			Global.getProfile().selectionChanged = true;
 			searchStr = searchStr.toUpperCase();
@@ -34,8 +34,10 @@
 				if (ch.is_filtered()) break; // Reached end of visible records
 				if(ch.getWayPoint().toUpperCase().indexOf(searchStr) <0 && 
 				   ch.getCacheName().toUpperCase().indexOf(searchStr) <0 && 
-				   ch.getCacheStatus().toUpperCase().indexOf(searchStr)<0 /*&&
-				   ch.getExistingDetails().LongDescription.toUpperCase().indexOf(searchStr)<0*/){
+				   ch.getCacheStatus().toUpperCase().indexOf(searchStr)<0 &&
+				   (! searchInDescriptionAndNotes || 
+					ch.getExistingDetails().LongDescription.toUpperCase().indexOf(searchStr)<0 &&
+					ch.getExistingDetails().CacheNotes.toUpperCase().indexOf(searchStr)<0)){
 					ch.is_flaged = false;
 					ch.setFiltered(true);
 				} else



From engywuck at mail.berlios.de  Tue Apr 21 21:38:54 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Tue, 21 Apr 2009 21:38:54 +0200
Subject: [Cachewolf-svn] r1766 - in trunk: res_noewe/languages src/CacheWolf
Message-ID: <200904211938.n3LJcscS012965@sheep.berlios.de>

Author: engywuck
Date: 2009-04-21 21:38:50 +0200 (Tue, 21 Apr 2009)
New Revision: 1766

Added:
   trunk/src/CacheWolf/CWProgressBar.java
Modified:
   trunk/res_noewe/languages/DE.cfg
   trunk/res_noewe/languages/EN.cfg
   trunk/res_noewe/languages/FR.cfg
   trunk/res_noewe/languages/NL.cfg
   trunk/src/CacheWolf/SearchCache.java
Log:
Added a progress bar if Searching is done in details/notes. Introduced class CWProgressBar which should serve as CacheWolf adapted progress bar with easy-to-use convenience methods.

Modified: trunk/res_noewe/languages/DE.cfg
===================================================================
--- trunk/res_noewe/languages/DE.cfg	2009-04-20 17:27:00 UTC (rev 1765)
+++ trunk/res_noewe/languages/DE.cfg	2009-04-21 19:38:50 UTC (rev 1766)
@@ -108,6 +108,7 @@
 		216=Immer bei GC einloggen
 		217=Spider alle Funde von geocaching.com
 		218=Auch in Beschreibung/Notizen
+		219=Suche...
 		300=Type:
 		301=Gr%f6%dfe:
 		302=Wegpunkt:

Modified: trunk/res_noewe/languages/EN.cfg
===================================================================
--- trunk/res_noewe/languages/EN.cfg	2009-04-20 17:27:00 UTC (rev 1765)
+++ trunk/res_noewe/languages/EN.cfg	2009-04-21 19:38:50 UTC (rev 1766)
@@ -108,6 +108,7 @@
 		216=Always login to GC
 		217=Spider all finds from geocaching.com
 		218=Also in description/notes
+		219=Searching...
 		300=Type:
 		301=Size:
 		302=Waypoint:

Modified: trunk/res_noewe/languages/FR.cfg
===================================================================
--- trunk/res_noewe/languages/FR.cfg	2009-04-20 17:27:00 UTC (rev 1765)
+++ trunk/res_noewe/languages/FR.cfg	2009-04-21 19:38:50 UTC (rev 1766)
@@ -105,6 +105,7 @@
 		213=Effacer les fichier .xml orpheline
 		214=Nouveau waypoint
 		218=Aussi dans description/notes
+		219=Cherchant...
 		300=Type:
 		301=Gabarit:
 		302=Waypoint:

Modified: trunk/res_noewe/languages/NL.cfg
===================================================================
--- trunk/res_noewe/languages/NL.cfg	2009-04-20 17:27:00 UTC (rev 1765)
+++ trunk/res_noewe/languages/NL.cfg	2009-04-21 19:38:50 UTC (rev 1766)
@@ -97,6 +97,7 @@
 		206=Lijst
 		214=Nieuwe Waypoint
 		218=Ook in opmerkingen/beschrijving
+		219=Zoeken...
 		300=Type:
 		301=Grote:
 		302=Waypoint:

Added: trunk/src/CacheWolf/CWProgressBar.java
===================================================================
--- trunk/src/CacheWolf/CWProgressBar.java	2009-04-20 17:27:00 UTC (rev 1765)
+++ trunk/src/CacheWolf/CWProgressBar.java	2009-04-21 19:38:50 UTC (rev 1766)
@@ -0,0 +1,93 @@
+package CacheWolf;
+
+import ewe.sys.Handle;
+import ewe.ui.ProgressBarForm;
+
+public class CWProgressBar {
+
+	protected MyProgressBarForm pbf;
+	protected Handle h;
+	private float minValue = 0.0f;
+	private float maxValue = 100.0f;
+	private boolean allowExit = true;
+	private boolean showProgress = false;
+	
+	/**
+	 * Constructs a progress bar object, adapted for CacheWolf purposes.
+	 * @param title The string shown in the title of the progress bar
+	 * @param pMinValue The minimum of possible values
+	 * @param pMaxValue The maximum of possible values
+	 * @param pShowProgress If <code>true</code> the progress bar is shown, if <code>false</code>
+	 * The progress bar will not show. Then usage of methods of this class will (nearly) have no 
+	 * effect.
+	 */
+	public CWProgressBar(String title, int pMinValue, int pMaxValue, boolean pShowProgress) {
+		if (pShowProgress) {
+			this.showProgress = true;
+	        pbf = new MyProgressBarForm();
+	        pbf.showMainTask = false;
+	        h = new Handle();
+	        h.progressResolution = 0.01f;
+	        pbf.setTask(h, title);
+	        this.minValue = pMinValue;
+	        if (pMaxValue != pMinValue) {
+		        this.maxValue = pMaxValue;
+	        } else {
+	        	this.maxValue = pMinValue + 100;
+	        }
+        }
+	}
+	
+	/**
+	 * Shows the progress bar
+	 */
+	public void exec() {
+		if (this.showProgress) pbf.exec();
+	}
+	
+	/**
+	 * The current position of the progress bar.
+	 * @param value Should be between minValue and maxValue
+	 */
+	public void setPosition(int value){
+		if (this.showProgress) {
+	        h.setProgress(value / (maxValue-minValue));
+        }
+	}
+	
+	/**
+	 * If set to yes the user is allowed to close the progress bar
+	 * by clicking the closing x.
+	 * @param value <code>true</code> if the user should be allowed to close the progress bar
+	 * by x.
+	 */
+	public void allowExit(boolean value) {
+		this.allowExit = value;
+	}
+	
+	/**
+	 * Is true if the user closed the progress bar
+	 * @return Closed by user or not
+	 */
+	public boolean isClosed() {
+		if (this.showProgress) return pbf.isClosed; else return false;
+	}
+	
+	/**
+	 * Exits the progress bar with given exit value
+	 * @param value ?
+	 */
+	public void exit(int value) {
+		this.allowExit(true);
+		if (this.showProgress) pbf.exit(value);
+	}	
+	
+	class MyProgressBarForm extends ProgressBarForm {
+		boolean isClosed=false;
+		protected boolean canExit(int exitCode) {
+			isClosed = allowExit;
+			return isClosed;
+		}
+	}
+}
+	

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-20 17:27:00 UTC (rev 1765)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-21 19:38:50 UTC (rev 1766)
@@ -1,5 +1,7 @@
 package CacheWolf;
 
+import ewe.sys.Vm;
+
 /**
 *	A class to perform a search on the cache database.
 *	The searchstr is searched for in the waypoint
@@ -25,11 +27,22 @@
 			Global.getProfile().selectionChanged = true;
 			searchStr = searchStr.toUpperCase();
 			CacheHolder ch;
+			int counter = 0;
+			if (searchInDescriptionAndNotes) {
+				for(int i=0 ; i<cacheDB.size(); i++) {
+					if (cacheDB.get(i).is_filtered()) break;
+					counter++;
+				}
+			}
+			CWProgressBar cwp = new CWProgressBar("Searching...", 0, counter, searchInDescriptionAndNotes);
+			cwp.exec();
+			cwp.allowExit(true);
 			//Search through complete database
 			//Mark finds by setting is_flaged
 			//TableModel will be responsible for displaying
 			//marked caches.
 			for(int i = 0;i < cacheDB.size();i++){
+				cwp.setPosition(i);
 				ch = cacheDB.get(i);
 				if (ch.is_filtered()) break; // Reached end of visible records
 				if(ch.getWayPoint().toUpperCase().indexOf(searchStr) <0 && 
@@ -42,8 +55,10 @@
 					ch.setFiltered(true);
 				} else
 					ch.is_flaged=true;
+				if (cwp.isClosed()) break;
 			} // for
-		     Global.mainTab.tbP.selectRow(0);
+			cwp.exit(0);
+		    Global.mainTab.tbP.selectRow(0);
 		} // if
 	}
 	



From engywuck at mail.berlios.de  Tue Apr 21 21:39:58 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Tue, 21 Apr 2009 21:39:58 +0200
Subject: [Cachewolf-svn] r1767 - trunk/src/CacheWolf
Message-ID: <200904211939.n3LJdwJO013533@sheep.berlios.de>

Author: engywuck
Date: 2009-04-21 21:39:56 +0200 (Tue, 21 Apr 2009)
New Revision: 1767

Modified:
   trunk/src/CacheWolf/SearchCache.java
Log:
Ooops, forgot SAVE before commiting.

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-21 19:38:50 UTC (rev 1766)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-21 19:39:56 UTC (rev 1767)
@@ -34,7 +34,7 @@
 					counter++;
 				}
 			}
-			CWProgressBar cwp = new CWProgressBar("Searching...", 0, counter, searchInDescriptionAndNotes);
+			CWProgressBar cwp = new CWProgressBar(MyLocale.getMsg(219,"Searching..."), 0, counter, searchInDescriptionAndNotes);
 			cwp.exec();
 			cwp.allowExit(true);
 			//Search through complete database



From engywuck at mail.berlios.de  Tue Apr 21 23:08:03 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Tue, 21 Apr 2009 23:08:03 +0200
Subject: [Cachewolf-svn] r1768 - trunk/src/CacheWolf
Message-ID: <200904212108.n3LL83oS024072@sheep.berlios.de>

Author: engywuck
Date: 2009-04-21 23:08:01 +0200 (Tue, 21 Apr 2009)
New Revision: 1768

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Improving efficiency in usage of IconAndText objects in myTableModel: Needed objects (which rarely change) are cached in CacheHolder, so they don't have to get created each time the table model wants to access them.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-21 19:39:56 UTC (rev 1767)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-21 21:08:01 UTC (rev 1768)
@@ -4,6 +4,8 @@
 
 import com.stevesoft.ewe_pat.Regex;
 
+import ewe.fx.FontMetrics;
+import ewe.fx.IconAndText;
 import ewe.io.IOException;
 import ewe.sys.Convert;
 import ewe.ui.FormBase;
@@ -112,6 +114,9 @@
 
 	private long attributesYes = 0;
 	private long attributesNo  = 0;
+	
+	private IconAndText iconAndTextWP = null;
+	private int iconAndTextWPLevel = 0;
 
 		static char decSep,notDecSep;
 	static {
@@ -734,6 +739,31 @@
 
 	// Getter and Setter for private properties
 
+	/**
+	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the 
+	 * last call of the method, the same (cached) object is returned. If the object is
+	 * null or the level is different, a new object is created.<br> 
+	 * @param level 4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
+	 * @param fm Font metrics
+	 * @return New or old IconAndText object
+	 */
+	public IconAndText getIconAndTextWP(int level, FontMetrics fm) {
+		IconAndText result;
+		if (level == iconAndTextWPLevel && iconAndTextWP != null) {
+			result = iconAndTextWP;
+		} else {
+			switch (level) {
+				case 4: iconAndTextWP = new IconAndText(myTableModel.skull, this.getWayPoint(), fm); break;
+				case 3: iconAndTextWP = new IconAndText(myTableModel.yellow, this.getWayPoint(), fm); break;
+				case 2: iconAndTextWP = new IconAndText(myTableModel.red, this.getWayPoint(), fm); break;
+				case 1: iconAndTextWP = new IconAndText(myTableModel.blue, this.getWayPoint(), fm); break;
+			}
+			result = iconAndTextWP;
+			iconAndTextWPLevel = level;
+		}
+		return result;
+	}
+	
 	public String getCacheStatus() {
     	return cacheStatus;
     }
@@ -866,6 +896,7 @@
 
 	public void setLog_updated(boolean is_log_updated) {
 		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);		
+		if (is_log_updated && iconAndTextWPLevel==1) iconAndTextWP = null;
     	this.log_updated = is_log_updated;
     }
 
@@ -875,6 +906,7 @@
 
 	public void setUpdated(boolean is_updated) {
 		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);		
+		if (is_updated && iconAndTextWPLevel==2) iconAndTextWP = null;
     	this.cache_updated = is_updated;
     }
 
@@ -883,7 +915,8 @@
     }
 
 	public void setIncomplete(boolean is_incomplete) {
-		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);		
+		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);	
+		if (is_incomplete && iconAndTextWPLevel==4) iconAndTextWP = null;
     	this.incomplete = is_incomplete;
     }
 
@@ -902,7 +935,8 @@
 
 	public void setNew(boolean is_new) {
 		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);		
-    	this.newCache = is_new;
+		if (is_new && iconAndTextWPLevel==3) iconAndTextWP = null;
+		this.newCache = is_new;
     }
 
 	public String getOcCacheID() {

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2009-04-21 19:39:56 UTC (rev 1767)
+++ trunk/src/CacheWolf/SearchCache.java	2009-04-21 21:08:01 UTC (rev 1768)
@@ -1,7 +1,5 @@
 package CacheWolf;
 
-import ewe.sys.Vm;
-
 /**
 *	A class to perform a search on the cache database.
 *	The searchstr is searched for in the waypoint

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-04-21 19:39:56 UTC (rev 1767)
+++ trunk/src/CacheWolf/myTableModel.java	2009-04-21 21:08:01 UTC (rev 1768)
@@ -45,7 +45,7 @@
 			MyLocale.getMsg(1026,"#Rec"),MyLocale.getMsg(1027,"OC-IDX")};
 	
 	private static Image noFindLogs[] = new Image[4];
-	private mImage red, blue, yellow, skull; // green
+	public static mImage red, blue, yellow, skull; // green
 	private Image checkboxTicked,checkboxUnticked;
 	private mImage bug;
 	private boolean sortAsc = false;
@@ -285,10 +285,10 @@
 						return ch.getTerrain();
 					case 4: // Waypoint
 						if (showExtraWptInfo) {
-							if(ch.is_incomplete()) return new IconAndText(skull, ch.getWayPoint(), fm);
-							if(ch.is_new()       ) return new IconAndText(yellow, ch.getWayPoint(), fm);
-							if(ch.is_updated()    ) return new IconAndText(red, ch.getWayPoint(), fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
-							if(ch.is_log_updated()) return new IconAndText(blue, ch.getWayPoint(), fm);
+							if(ch.is_incomplete()) return ch.getIconAndTextWP(4, fm);
+							if(ch.is_new()       ) return ch.getIconAndTextWP(3, fm);
+							if(ch.is_updated()    ) return ch.getIconAndTextWP(2, fm);
+							if(ch.is_log_updated()) return ch.getIconAndTextWP(1, fm);
 						}
 						return ch.getWayPoint();
 					case 5: // Cachename



From engywuck at mail.berlios.de  Tue Apr 21 23:29:27 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Tue, 21 Apr 2009 23:29:27 +0200
Subject: [Cachewolf-svn] r1769 - trunk/src/CacheWolf
Message-ID: <200904212129.n3LLTRGo026066@sheep.berlios.de>

Author: engywuck
Date: 2009-04-21 23:29:26 +0200 (Tue, 21 Apr 2009)
New Revision: 1769

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
Needless intermediate variable removed.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-21 21:08:01 UTC (rev 1768)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-21 21:29:26 UTC (rev 1769)
@@ -748,20 +748,16 @@
 	 * @return New or old IconAndText object
 	 */
 	public IconAndText getIconAndTextWP(int level, FontMetrics fm) {
-		IconAndText result;
-		if (level == iconAndTextWPLevel && iconAndTextWP != null) {
-			result = iconAndTextWP;
-		} else {
+		if (level != iconAndTextWPLevel || iconAndTextWP == null) {
 			switch (level) {
 				case 4: iconAndTextWP = new IconAndText(myTableModel.skull, this.getWayPoint(), fm); break;
 				case 3: iconAndTextWP = new IconAndText(myTableModel.yellow, this.getWayPoint(), fm); break;
 				case 2: iconAndTextWP = new IconAndText(myTableModel.red, this.getWayPoint(), fm); break;
 				case 1: iconAndTextWP = new IconAndText(myTableModel.blue, this.getWayPoint(), fm); break;
 			}
-			result = iconAndTextWP;
 			iconAndTextWPLevel = level;
 		}
-		return result;
+		return iconAndTextWP;
 	}
 	
 	public String getCacheStatus() {



From araber95 at mail.berlios.de  Wed Apr 22 00:55:46 2009
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 22 Apr 2009 00:55:46 +0200
Subject: [Cachewolf-svn] r1770 - trunk/res_noewe/webmapservices
Message-ID: <200904212255.n3LMtkuL025298@sheep.berlios.de>

Author: araber95
Date: 2009-04-22 00:55:42 +0200 (Wed, 22 Apr 2009)
New Revision: 1770

Modified:
   trunk/res_noewe/webmapservices/de-sn_p.wms
Log:
error : no layer selected. now layer = c colorphotos

Modified: trunk/res_noewe/webmapservices/de-sn_p.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sn_p.wms	2009-04-21 21:29:26 UTC (rev 1769)
+++ trunk/res_noewe/webmapservices/de-sn_p.wms	2009-04-21 22:55:42 UTC (rev 1770)
@@ -19,7 +19,7 @@
 #LayersUrlPart:     LAYERS=ortho_color|Mittelsachsen 2002|0.000498903|0.0498903
 #LayersUrlPart:     LAYERS=ortho_rgb06_lowres|Sachsen 2006-2008 LowRes|4.98853|4989.03
 #LayersUrlPart:     LAYERS=ortho_rgb06|Sachsen 2006-2008|0.000498903|4.98853
-#LayersUrlPart:	LAYERS=c
+LayersUrlPart:	LAYERS=c
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84:	N 51.85920 E 011.76510



From engywuck at mail.berlios.de  Wed Apr 22 18:13:48 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Wed, 22 Apr 2009 18:13:48 +0200
Subject: [Cachewolf-svn] r1771 - trunk/src/CacheWolf
Message-ID: <200904221613.n3MGDm3A028084@sheep.berlios.de>

Author: engywuck
Date: 2009-04-22 18:13:46 +0200 (Wed, 22 Apr 2009)
New Revision: 1771

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
After spidering GC the cache state icons should be correct now. (http://www.geoclub.de/viewtopic.php?p=525916#p525916)

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-21 22:55:42 UTC (rev 1770)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-22 16:13:46 UTC (rev 1771)
@@ -369,13 +369,13 @@
 		this.setAvailable(ch.is_available());
 		this.setOwned(ch.is_owned());
 		this.setFiltered(ch.is_filtered());
-		this.setLog_updated(ch.is_log_updated());
-		this.setUpdated(ch.is_updated());
+//		this.setLog_updated(ch.is_log_updated());
+//		this.setUpdated(ch.is_updated());
 		this.setIncomplete(ch.is_incomplete());
 		this.setBlack(ch.is_black());
 		this.addiWpts = ch.addiWpts;
 		this.mainCache=ch.mainCache;
-		this.setNew(ch.is_new());
+//		this.setNew(ch.is_new());
 		// I don't think that updating a cache with current data should affect the state
 		// if a cache is checked or a search result. So the following two assignments are
 		// removed.
@@ -736,6 +736,24 @@
 
 		return result;
 	}
+	
+	/**
+	 * Initializes the caches states (and its addis) before updating, so that the "new", "updated",
+	 * "log_updated" and "incomplete" properties are properly set. 
+	 * @param newCache <code>true</code> if it is a new cache (i.e. a cache not existing in CacheDB),
+	 * <code>false</code> otherwise.
+	 */
+	public void initStates(boolean newCache) {
+		this.setNew(newCache);
+		this.setUpdated(false);
+		this.setLog_updated(false);
+		this.setIncomplete(false);
+		if (!newCache && this.hasAddiWpt()) {
+			for (int i=0; i<this.addiWpts.size(); i++) {
+				((CacheHolder)this.addiWpts.get(i)).initStates(newCache);
+			}
+		}
+	}
 
 	// Getter and Setter for private properties
 

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-21 22:55:42 UTC (rev 1770)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-22 16:13:46 UTC (rev 1771)
@@ -226,9 +226,10 @@
 			ret=getCacheByWaypointName(ch,true,true,false,loadAllLogs);
 			// Save the spidered data
 			if (ret == 1) {
-				pref.log("Saving to:" + profile.dataDir);
-				cacheDB.get(number).update(ch);
-				ch.save();
+				CacheHolder cacheInDB = cacheDB.get(number);
+				cacheInDB.initStates(false);
+				cacheInDB.update(ch);
+				cacheInDB.save();
 			}
 		}catch(Exception ex){
 			pref.log("Error spidering " + ch.getWayPoint() + " in spiderSingle");
@@ -642,9 +643,7 @@
 				// Only analyse the cache data and fetch pictures if user has not closed the progress window
 				if (!infB.isClosed) {
 					try{
-						ch.setNew(!isUpdate);
-						ch.setUpdated(false);
-						ch.setLog_updated(false);
+						ch.initStates(!isUpdate);
 
 						//first check if coordinates are available to prevent deleting existing coorinates
 						String latLon = getLatLon(completeWebPage);
@@ -783,7 +782,7 @@
 						pref.log("Getting attributes");
 						getAttributes(completeWebPage, ch.getFreshDetails());
 						pref.log("Got attributes");
-						if (ch.is_new()) ch.setUpdated(false);
+						//if (ch.is_new()) ch.setUpdated(false);
 						ch.setIncomplete(false);
 						break;
 					}catch(Exception ex){
@@ -1326,8 +1325,7 @@
 					hd=new CacheHolder(); 
 					hd.setWayPoint(adWayPoint);
 				}
-				hd.setUpdated(false); 
-				hd.setNew(false);
+				hd.initStates(idx<0);
 				nameRex.search(rowBlock);
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
@@ -1338,17 +1336,17 @@
 				descRex.search(rowBlock);
 				hd.getFreshDetails().setLongDescription(descRex.stringMatched(1));
 				hd.setFound(is_found);
-				hd.save();
 				if (idx<0){
-					hd.setNew(true); 
-					hd.setUpdated(false);
 					cacheDB.add(hd);
+					hd.save();
 				}else {
 					CacheHolder cx=cacheDB.get(idx);
 					if (cx.is_Checked && // Only re-spider existing addi waypoints that are ticked
 				 	   !cx.is_filtered()) { // and are visible (i.e.  not filtered)
+					   cx.initStates(false);
 					   cx.update(hd);
 					   cx.is_Checked=true;
+					   cx.save();
 					}
 				}
 				rowBlock = exRowBlock.findNext();



From engywuck at mail.berlios.de  Wed Apr 22 18:34:40 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Wed, 22 Apr 2009 18:34:40 +0200
Subject: [Cachewolf-svn] r1772 - trunk/src/CacheWolf
Message-ID: <200904221634.n3MGYe99000523@sheep.berlios.de>

Author: engywuck
Date: 2009-04-22 18:34:37 +0200 (Wed, 22 Apr 2009)
New Revision: 1772

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
Resetting states of all caches when spidering. (http://tinyurl.com/dzjh7p)

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-04-22 16:13:46 UTC (rev 1771)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-04-22 16:34:37 UTC (rev 1772)
@@ -288,10 +288,10 @@
 		if (System.getProperty("os.name")!=null)pref.log("Operating system: "+System.getProperty("os.name")+"/"+System.getProperty("os.arch"));
 		if (System.getProperty("java.vendor")!=null)pref.log("Java: "+System.getProperty("java.vendor")+"/"+System.getProperty("java.version"));
 		CacheHolder ch;
-		// Reset is_new()
+		// Reset states for all caches when spidering (http://tinyurl.com/dzjh7p)
 		for(int i = 0; i<cacheDB.size();i++){
 			ch = cacheDB.get(i);
-			ch.setNew(false);
+			if (ch.mainCache==null) ch.initStates(false);
 		}
 		String start = "";
 		Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*)\" />");



From engywuck at mail.berlios.de  Wed Apr 22 18:44:28 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Wed, 22 Apr 2009 18:44:28 +0200
Subject: [Cachewolf-svn] r1773 - trunk/src/CacheWolf
Message-ID: <200904221644.n3MGiS4u010009@sheep.berlios.de>

Author: engywuck
Date: 2009-04-22 18:44:21 +0200 (Wed, 22 Apr 2009)
New Revision: 1773

Modified:
   trunk/src/CacheWolf/MainMenu.java
Log:
Removing ubiquitous exception trace.

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2009-04-22 16:34:37 UTC (rev 1772)
+++ trunk/src/CacheWolf/MainMenu.java	2009-04-22 16:44:21 UTC (rev 1773)
@@ -86,7 +86,7 @@
 			p.waitFor();
 			gpsbabelFound = true;
 		}catch(IOException ioex){
-			Global.getPref().log("Ignored Exception", ioex, true);
+			// Most of the time there will be an exception, so don't complain
 		}
 		if ( !gpsbabelFound ) {
 			try{
@@ -96,7 +96,7 @@
 				addExeToGpsbabel = true;
 				gpsbabelFound = true;
 			}catch(IOException ioex){
-				Global.getPref().log("Ignored Exception", ioex, true);
+				// Most of the time there will be an exception, so don't complain
 			}
 		}		
 		



From engywuck at mail.berlios.de  Wed Apr 22 20:14:15 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Wed, 22 Apr 2009 20:14:15 +0200
Subject: [Cachewolf-svn] r1774 - in trunk/src/CacheWolf: . navi
Message-ID: <200904221814.n3MIEFKZ020009@sheep.berlios.de>

Author: engywuck
Date: 2009-04-22 20:14:13 +0200 (Wed, 22 Apr 2009)
New Revision: 1774

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/Matrix.java
   trunk/src/CacheWolf/navi/GotoPanel.java
Log:
Againg: Removing compiler warnings. (re-deprecated some methods - I hope that's ok)

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-04-22 16:44:21 UTC (rev 1773)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-04-22 18:14:13 UTC (rev 1774)
@@ -740,17 +740,17 @@
 	/**
 	 * Initializes the caches states (and its addis) before updating, so that the "new", "updated",
 	 * "log_updated" and "incomplete" properties are properly set. 
-	 * @param newCache <code>true</code> if it is a new cache (i.e. a cache not existing in CacheDB),
+	 * @param pNewCache <code>true</code> if it is a new cache (i.e. a cache not existing in CacheDB),
 	 * <code>false</code> otherwise.
 	 */
-	public void initStates(boolean newCache) {
-		this.setNew(newCache);
+	public void initStates(boolean pNewCache) {
+		this.setNew(pNewCache);
 		this.setUpdated(false);
 		this.setLog_updated(false);
 		this.setIncomplete(false);
-		if (!newCache && this.hasAddiWpt()) {
+		if (!pNewCache && this.hasAddiWpt()) {
 			for (int i=0; i<this.addiWpts.size(); i++) {
-				((CacheHolder)this.addiWpts.get(i)).initStates(newCache);
+				((CacheHolder)this.addiWpts.get(i)).initStates(pNewCache);
 			}
 		}
 	}

Modified: trunk/src/CacheWolf/Matrix.java
===================================================================
--- trunk/src/CacheWolf/Matrix.java	2009-04-22 16:44:21 UTC (rev 1773)
+++ trunk/src/CacheWolf/Matrix.java	2009-04-22 18:14:13 UTC (rev 1774)
@@ -237,8 +237,10 @@
 	
 	/**
 	*	"Old" helper method used by some other classes in cachewolf.
-	*	@deprecated Do not use when coding new classes!
 	*/
+	//  No reason for deprecation, so I removed it. Or is there a better substitution for this
+	//  method?
+	//	@deprecated Do not use when coding new classes!
 	public static double dot(double p1, double p2, double q1, double q2, double x1, double x2){
 		double dt,AB0,AB1,BC0,BC1 = 0;
 		AB0 = q1 - p1;
@@ -251,8 +253,10 @@
 	
 	/**
 	*	"Old" helper method used by some other classes in cachewolf.
-	*	@deprecated Do not use when coding new classes!
 	*/
+	//  No reason for deprecation, so I removed it. Or is there a better substitution for this
+	//  method?
+	//	@deprecated Do not use when coding new classes!
 	public static double cross(double p1, double p2, double q1, double q2, double x1, double x2){
 		double cr,AB0,AB1,AC0,AC1 = 0;
 		AB0 = q1 - p1;
@@ -265,8 +269,10 @@
 	
 	/**
 	*	"Old" helper method used by some other classes in cachewolf.
-	*	@deprecated Do not use when coding new classes!
 	*/
+	//  No reason for deprecation, so I removed it. Or is there a better substitution for this
+	//  method?
+	//	@deprecated Do not use when coding new classes!
 	public static double dist(double p1, double p2, double q1, double q2){
 		double d1, d2,dt = 0;
 		d1 = p1 - q1;

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-22 16:44:21 UTC (rev 1773)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-04-22 18:14:13 UTC (rev 1774)
@@ -738,24 +738,6 @@
 		}
 	}
 
-	/**
-	 * draw single arrow 
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
-	 */
-	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad;
-		int x, y, centerX = location.width/2, centerY = location.height/2;
-		int arrowLength = roseRadius; 
-
-		angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
-		y = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad) * scale).intValue();
-		g.setPen(new Pen(col,Pen.SOLID,3));
-		g.drawLine(centerX,centerY,x,y);
-	}
-	
 	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
 		int centerX = location.width/2, centerY = location.height/2;
@@ -816,67 +798,6 @@
 		}
 	}
 	
-	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = roseRadius * scale;
-		float halfArrowWidth = arrowLength * 0.1f;
-		
-		int[] pointsX = new int[3];
-		int[] pointsY = new int[3];
-
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(colFront, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
-		
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		
-		g.setBrush(new Brush(colRear, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
-	}
-	
-	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = roseRadius * scale;
-		float halfArrowWidth = arrowLength * 0.12f;
-		
-		int[] pointsX = new int[8];
-		int[] pointsY = new int[8];
-
-		pointsX[0] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
-		pointsY[0] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
-		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
-		pointsX[3] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[3] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[4] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsY[4] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsX[5] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[5] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		pointsX[6] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
-		g.setPen(new Pen(colRear,Pen.SOLID,1));
-		g.setBrush(new Brush(colRear, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 8);
-		
-		g.setBrush(new Brush(colFront, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
-	}
-	
 	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight,
 			Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
 		float subScale1 = 1.0f;



From mik77 at mail.berlios.de  Fri Apr 24 15:07:47 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 24 Apr 2009 15:07:47 +0200
Subject: [Cachewolf-svn] r1775 - in trunk: res_noewe src/CacheWolf
Message-ID: <200904241307.n3OD7l3b002862@sheep.berlios.de>

Author: mik77
Date: 2009-04-24 15:07:39 +0200 (Fri, 24 Apr 2009)
New Revision: 1775

Modified:
   trunk/res_noewe/wolflang.html
   trunk/src/CacheWolf/Parser.java
Log:
Gau?-Kr?ger added to target formats of solver format-method

Modified: trunk/res_noewe/wolflang.html
===================================================================
--- trunk/res_noewe/wolflang.html	2009-04-22 18:14:13 UTC (rev 1774)
+++ trunk/res_noewe/wolflang.html	2009-04-24 13:07:39 UTC (rev 1775)
@@ -61,7 +61,7 @@
 cp() # get current GPS position<br>
 distance(coordinate1,coordinate2)<br>  
 format(coordinate,fmt) <br>
-  <i>where fmt="CW" or "UTM" or "DMS" or "DD"</i><br>
+  <i>where fmt="CW" or "UTM" or "DMS" or "DD" or "DMM" or "GK"</i><br>
 goto(coordinate)<br>
 goto(coordinate,waypointname)<br>
 project(coordinate,angle,distance)<br><br>

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2009-04-22 18:14:13 UTC (rev 1774)
+++ trunk/src/CacheWolf/Parser.java	2009-04-24 13:07:39 UTC (rev 1775)
@@ -528,7 +528,8 @@
     	else if (fmtStr.equals("dmm")) fmt=CWPoint.DMM;
     	else if (fmtStr.equals("dms")) fmt=CWPoint.DMS;
     	else if (fmtStr.equals("utm")) fmt=CWPoint.UTM;
-    	else if (!fmtStr.equals("cw")) err(MyLocale.getMsg(1713,"Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM"));
+    	else if (fmtStr.equals("gk")) fmt=CWPoint.GK;
+    	else if (!fmtStr.equals("cw")) err(MyLocale.getMsg(1713,"Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM/GK"));
     	return cwPt.toString(fmt);
     }
 



From mik77 at mail.berlios.de  Sat Apr 25 02:36:14 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 25 Apr 2009 02:36:14 +0200
Subject: [Cachewolf-svn] r1776 - trunk/src/CacheWolf
Message-ID: <200904250036.n3P0aEU3003130@sheep.berlios.de>

Author: mik77
Date: 2009-04-25 02:36:06 +0200 (Sat, 25 Apr 2009)
New Revision: 1776

Modified:
   trunk/src/CacheWolf/GPXImporter.java
Log:
simple dirty hack to handle GPX files with UTF-8 BOM

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-04-24 13:07:39 UTC (rev 1775)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-04-25 00:36:06 UTC (rev 1776)
@@ -115,6 +115,8 @@
 							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
 							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel));
 							infB.exec();
+							if (r.read() != 65279)
+								r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
 							parse(r);
 							r.close();
 							infB.close(0);
@@ -125,6 +127,8 @@
 					r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
 					infB = new InfoBox("Info",(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel));
 					infB.show();
+					if (r.read() != 65279)
+						r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
 					parse(r);
 					r.close();
 					infB.close(0);



From mik77 at mail.berlios.de  Sun Apr 26 20:59:36 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sun, 26 Apr 2009 20:59:36 +0200
Subject: [Cachewolf-svn] r1777 - trunk/src/CacheWolf
Message-ID: <200904261859.n3QIxat6032750@sheep.berlios.de>

Author: mik77
Date: 2009-04-26 20:59:34 +0200 (Sun, 26 Apr 2009)
New Revision: 1777

Modified:
   trunk/src/CacheWolf/MainTab.java
Log:
Save solver data in main cache (again) when leaving SolverPanel and AddiWP is active

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-04-25 00:36:06 UTC (rev 1776)
+++ trunk/src/CacheWolf/MainTab.java	2009-04-26 18:59:34 UTC (rev 1777)
@@ -222,6 +222,7 @@
 		case 5:  // Solver Panel
 			MyLocale.setSIPOff();
 			if (ch.isAddiWpt()) { 
+				chMain=ch.mainCache;
 				solverP.setInstructions(ch.mainCache.getFreshDetails().Solver);
 			} else {
 				solverP.setInstructions(chD.Solver);



From engywuck at mail.berlios.de  Mon Apr 27 17:28:45 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Mon, 27 Apr 2009 17:28:45 +0200
Subject: [Cachewolf-svn] r1778 - trunk/src/CacheWolf/navi
Message-ID: <200904271528.n3RFSjiE019771@sheep.berlios.de>

Author: engywuck
Date: 2009-04-27 17:28:44 +0200 (Mon, 27 Apr 2009)
New Revision: 1778

Modified:
   trunk/src/CacheWolf/navi/MapImporter.java
Log:
Bug fixed: Importing of maps now successfull even with more than one map.

Modified: trunk/src/CacheWolf/navi/MapImporter.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImporter.java	2009-04-26 18:59:34 UTC (rev 1777)
+++ trunk/src/CacheWolf/navi/MapImporter.java	2009-04-27 15:28:44 UTC (rev 1778)
@@ -166,6 +166,7 @@
 				in = new FileInputStream(curInFullPath);
 				buf = new byte[1024*10];
 				ByteArray header = new ByteArray(buf);
+				out = null; // May be unequal to null because of prior loop
 				while ((len = in.read(buf)) > 0) {
 					if (out==null) {
 						header.copyFrom(buf, 0, len);



From engywuck at mail.berlios.de  Mon Apr 27 19:33:46 2009
From: engywuck at mail.berlios.de (engywuck at mail.berlios.de)
Date: Mon, 27 Apr 2009 19:33:46 +0200
Subject: [Cachewolf-svn] r1779 - trunk/src/CacheWolf
Message-ID: <200904271733.n3RHXkLt017901@sheep.berlios.de>

Author: engywuck
Date: 2009-04-27 19:33:42 +0200 (Mon, 27 Apr 2009)
New Revision: 1779

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/SolverPanel.java
Log:
The solvers output panel is cleared if the selection is moved to a cache that doesn't belong to the previous one. 

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-04-27 15:28:44 UTC (rev 1778)
+++ trunk/src/CacheWolf/MainTab.java	2009-04-27 17:33:42 UTC (rev 1779)
@@ -223,9 +223,9 @@
 			MyLocale.setSIPOff();
 			if (ch.isAddiWpt()) { 
 				chMain=ch.mainCache;
-				solverP.setInstructions(ch.mainCache.getFreshDetails().Solver);
+				solverP.setInstructions(ch.mainCache);
 			} else {
-				solverP.setInstructions(chD.Solver);
+				solverP.setInstructions(ch);
 			}
 			break;
 		case 6:  // CalcPanel
@@ -315,7 +315,7 @@
 		detP.setDetails(pCh);
 		oldCard=1;
 		if (this.cardPanel.selectedItem != 1) select(detP);
-		solverP.setInstructions("");
+		solverP.setInstructions(pCh);
 		detP.setNeedsTableUpdate(true);
 		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
 

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2009-04-27 15:28:44 UTC (rev 1778)
+++ trunk/src/CacheWolf/SolverPanel.java	2009-04-27 17:33:42 UTC (rev 1779)
@@ -25,7 +25,8 @@
 	Vector msgFIFO = new Vector();
 	Menu mnuContext;
 	private String originalInstructions="";
-	mButton btnDegRad; 
+	mButton btnDegRad;
+	private CacheHolder ch; 
 	
 	public boolean isDirty() {
 		return !originalInstructions.equals(getInstructions());
@@ -34,11 +35,33 @@
 	public String getInstructions() {
 		return mText.getText();
 	}
+	/**
+	 * Sets the instructions in the solver panel. The last remembered cache of the solver panel
+	 * is not changed.
+	 * @param text The instructions to set.
+	 */
 	public void setInstructions(String text) {
 		originalInstructions=text;
 		mText.setText(text);
 		mText.repaint();
 	}
+	/**
+	 * Sets the instructions of the solver panel to the solver code in the given cache.
+	 * The current cache is remembered. If the instructions are set for an other cache, 
+	 * then the output panel is cleared if the cache objects do not belong to each other.
+	 * @param pCh The cache who's solver code is used
+	 */
+	public void setInstructions(CacheHolder pCh) {
+		if (pCh != null) {
+	        this.setInstructions(pCh.getFreshDetails().Solver);
+	        if (!pCh.hasSameMainCache(ch)) {
+		        this.clearOutput();
+	        }
+        } else {
+        	this.setInstructions("");
+        }
+		ch = pCh;
+	}
 	
 	
 	private class OutputPanel extends mTextPad {
@@ -131,6 +154,13 @@
 		}
 		mOutput.appendText(msgStr,true);
     }
+    
+    /**
+     * Clears the output panel
+     */
+    void clearOutput() {
+    	mOutput.setText("");
+    }
 	
 	public void onEvent(Event ev){
 		if (ev instanceof DataChangeEvent) Global.mainTab.cacheDirty=true;



From mik77 at mail.berlios.de  Thu Apr 30 08:55:40 2009
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Thu, 30 Apr 2009 08:55:40 +0200
Subject: [Cachewolf-svn] r1780 - trunk/src/CacheWolf
Message-ID: <200904300655.n3U6teci019284@sheep.berlios.de>

Author: mik77
Date: 2009-04-30 08:55:33 +0200 (Thu, 30 Apr 2009)
New Revision: 1780

Modified:
   trunk/src/CacheWolf/GPXImporter.java
Log:
 - c&p bug fixed.

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-04-27 17:33:42 UTC (rev 1779)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-04-30 06:55:33 UTC (rev 1780)
@@ -116,7 +116,7 @@
 							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel));
 							infB.exec();
 							if (r.read() != 65279)
-								r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
+								r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
 							parse(r);
 							r.close();
 							infB.close(0);



