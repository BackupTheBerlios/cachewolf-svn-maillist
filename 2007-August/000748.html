<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r856 - trunk/src/CacheWolf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r856%20-%20trunk/src/CacheWolf&In-Reply-To=%3C200708302118.l7ULIeGQ028184%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000747.html">
   <LINK REL="Next"  HREF="000749.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r856 - trunk/src/CacheWolf</H1>
    <B>pfeffer at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r856%20-%20trunk/src/CacheWolf&In-Reply-To=%3C200708302118.l7ULIeGQ028184%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r856 - trunk/src/CacheWolf">pfeffer at mail.berlios.de
       </A><BR>
    <I>Thu Aug 30 23:18:40 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000747.html">[Cachewolf-svn] r855 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="000749.html">[Cachewolf-svn] r857 - in trunk: resources src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#748">[ date ]</a>
              <a href="thread.html#748">[ thread ]</a>
              <a href="subject.html#748">[ subject ]</a>
              <a href="author.html#748">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pfeffer
Date: 2007-08-30 23:18:25 +0200 (Thu, 30 Aug 2007)
New Revision: 856

Added:
   trunk/src/CacheWolf/SkyOrientation.java
Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Navigate.java
Log:
Mond und Sterne k&#195;&#182;nnen jetzt ausgew&#195;&#164;hlt werden als Nachtnavigationshilfe im Kontextmen&#195;&#188; der Goto-Rose

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-08-30 21:01:15 UTC (rev 855)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-08-30 21:18:25 UTC (rev 856)
@@ -33,7 +33,7 @@
 
 	mLabel lblPosition, lblSats, lblSpeed, lblBearMov, lblBearWayP, lblDist, lblHDOP;
 	mLabel lblSatsText, lblSpeedText, lblDirText, lblDistText, lblSunAzimut;
-	mLabel lblGPS, lblDST, lblCurr, lblWayP;
+	mLabel lblGPS, lblDST, lblCurr, lblWayP, lblLuminary;
 	mLabel lblLog;
 	mCheckBox chkLog;
 	mInput inpLogSeconds;
@@ -64,9 +64,11 @@
 	GotoRose rose;
 	int ticker = 0;
 	
-	Menu mnuContext;
+	Menu mnuContextFormt;
 	MenuItem miDMM, miDMS, miDD, miUTM;
-
+	
+	Menu mnuContextRose;
+	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
 	/**
 	 * Create GotoPanel 
 	 * @param Preferences 	global preferences
@@ -90,34 +92,44 @@
 
 		//Format selection for coords		
 		//context menu
-		mnuContext = new Menu();
-		mnuContext.addItem(miDD = new MenuItem(&quot;d.d&#176;&quot;));
+		mnuContextFormt = new Menu();
+		mnuContextFormt.addItem(miDD = new MenuItem(&quot;d.d&#176;&quot;));
 		miDD.modifiers &amp;= ~MenuItem.Checked;
-		mnuContext.addItem(miDMM = new MenuItem(&quot;d&#176;m.m\'&quot;));
+		mnuContextFormt.addItem(miDMM = new MenuItem(&quot;d&#176;m.m\'&quot;));
 		miDMM.modifiers |= MenuItem.Checked;
-		mnuContext.addItem(miDMS = new MenuItem(&quot;d&#176;m\'s\&quot;&quot;));
+		mnuContextFormt.addItem(miDMS = new MenuItem(&quot;d&#176;m\'s\&quot;&quot;));
 		miDMS.modifiers &amp;= ~MenuItem.Checked;
-		mnuContext.addItem(miUTM = new MenuItem(&quot;UTM&quot;));
+		mnuContextFormt.addItem(miUTM = new MenuItem(&quot;UTM&quot;));
 		miUTM.modifiers &amp;= ~MenuItem.Checked;
 		currFormat = CWPoint.DMM;
 
+		// Create context menu for compass rose: select luminary for orientation
+		mnuContextRose = new Menu();
+		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+			else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+		}
+
 		//Coords
 		CoordsP.addNext(lblGPS = new mLabel(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblGPS.backGround = RED;
-		lblGPS.setMenu(mnuContext);
+		lblGPS.setMenu(mnuContextFormt);
 		lblGPS.modifyAll(Control.WantHoldDown, 0);
 		CoordsP.addLast(lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		lblPosition.setMenu(mnuContext);
+		lblPosition.setMenu(mnuContextFormt);
 		lblPosition.modifyAll(Control.WantHoldDown, 0);
 		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,&quot;DST:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblDST.backGround = new Color(0,0,255);
-		lblDST.setMenu(mnuContext);
+		lblDST.setMenu(mnuContextFormt);
 		lblDST.modifyAll(Control.WantHoldDown, 0);
 		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 
 		//Rose for bearing
 		compassRose = new GotoRose(&quot;rose.png&quot;);
 		icRose = new ImageControl(compassRose);
+		icRose.setMenu(mnuContextRose);
+		icRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
 		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
 
 		//Goto
@@ -160,9 +172,9 @@
 		chkLog.setState(false);
 		inpLogSeconds.columns = 5;
 
-		LogP.addNext(lblGPS = new mLabel(&quot;Sonne: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblGPS.backGround = YELLOW;
-		lblGPS.setTag(SPAN, new Dimension(2,1));
+		LogP.addNext(lblLuminary = new mLabel(SkyOrientation.getLuminaryName(myNavigation.luminary)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblLuminary.backGround = YELLOW;
+		lblLuminary.setTag(SPAN, new Dimension(2,1));
 
 		LogP.addLast(lblSunAzimut = new mLabel(&quot;---&quot;),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.NORTH));
 		lblSunAzimut.setText(&quot;---&quot;);
@@ -275,7 +287,7 @@
 			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
 			speed.set(myNavigation.gpsPos.getSpeed());
 			lblSpeed.setText(MyLocale.formatDouble(speed,&quot;0.0&quot;) + &quot; km/h&quot;);
-			sunAzimut.set((double)myNavigation.sunAzimut);
+			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
 			if (sunAzimut.value &gt;= -360) lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,&quot;0.0&quot;) + &quot; Grad&quot;);
 			else lblSunAzimut.setText(&quot;--- Grad&quot;);
 			bearMov.set(myNavigation.gpsPos.getBear());
@@ -346,22 +358,22 @@
 	public void onEvent(Event ev){
 		if (ev instanceof MenuEvent) { 
 			if (ev.type == MenuEvent.SELECTED ) {
-				MenuItem action = (MenuItem) mnuContext.getSelectedItem(); 
-				if (mnuContext.getSelectedItem() != null) {
+				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem(); 
+				if (action != null) {
 					if (action == miDD) {
-						mnuContext.close();
+						mnuContextFormt.close();
 						currFormat = CWPoint.DD;
 					}
 					if (action == miDMM) {
-						mnuContext.close();
+						mnuContextFormt.close();
 						currFormat = CWPoint.DMM;
 					}
 					if (action == miDMS) {
-						mnuContext.close();
+						mnuContextFormt.close();
 						currFormat = CWPoint.DMS;
 					}
 					if (action == miUTM) {
-						mnuContext.close();
+						mnuContextFormt.close();
 						currFormat = CWPoint.UTM;
 					}
 					miDD.modifiers &amp;= ~MenuItem.Checked;
@@ -377,6 +389,16 @@
 
 					lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
 					btnGoto.setText(getGotoBtnText());
+				} // end lat-lon-format context menu
+				action = (MenuItem) mnuContextRose.getSelectedItem();
+				if (action != null) {
+					for (int i=0; i&lt;miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							myNavigation.setLuminary(i);
+							miLuminary[i].modifiers |= MenuItem.Checked;
+							lblLuminary.setText(SkyOrientation.getLuminaryName(myNavigation.luminary));
+						} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+					}
 				}
 			}
 		}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-08-30 21:01:15 UTC (rev 855)
+++ trunk/src/CacheWolf/MovingMap.java	2007-08-30 21:18:25 UTC (rev 856)
@@ -855,7 +855,7 @@
 		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
 		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
 			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
-					myNavigation.sunAzimut, (float)myNavigation.gpsPos.getBear());
+					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
 			ShowLastAddedPoint(myNavigation.curTrack);

Modified: trunk/src/CacheWolf/Navigate.java
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-08-30 21:01:15 UTC (rev 855)
+++ trunk/src/CacheWolf/Navigate.java	2007-08-30 21:18:25 UTC (rev 856)
@@ -15,7 +15,8 @@
 	public CWGPSPoint gpsPos = new CWGPSPoint();
 	public Track curTrack = null;
 	Color trackColor = new Color(255,0,0); // red
-	public float sunAzimut = -361;
+	CWPoint skyOrientationDir = new CWPoint();
+	int luminary = SkyOrientation.SUN;
 
 	public GotoPanel gotoPanel = null;
 	public MovingMap movingMap = null;
@@ -95,6 +96,13 @@
 		if (gotoPanel != null) gotoPanel.destChanged(destination);
 		if (movingMap != null) movingMap.destChanged(destination);
 	}
+	/**
+	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * @param lu
+	 */
+	public void setLuminary(int lu) {
+		luminary = lu;
+	}
 	public void ticked() {
 		int fix = gpsPos.getFix();
 		if (fix &gt; 0 &amp;&amp; (gpsPos.getSats()&gt;= 0)) {
@@ -109,365 +117,116 @@
 				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
 			}
 			try {
-				sunAzimut = getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
+				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
+				double jd = SkyOrientation.utc2juliandate(gpsPos.Time, gpsPos.Date);
+				skyOrientationDir = SkyOrientation.getLuminaryDir(luminary, jd, gpsPos);
+				ewe.sys.Vm.debug(&quot;neu: &quot;+ skyOrientationDir.lonDec+ &quot;jd: &quot; + jd);
 			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf&#252;gbar wenn es einen Fix gibt)
-				sunAzimut = -361; // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
+				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
 			}
 
 		} else {
-			sunAzimut = -361;
+			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it		
 		}
 		gotoPanel.updateGps(fix);
 		if (movingMap != null) movingMap.updateGps(fix);
 	}
+}
 
-	/**
-	 * @param utc in the format as it comes from gps DDMMYY
-	 * @param datum in the format as it comes from gps HHMMSS
-	 * @param lat in degrees in WGS84
-	 * @param lon in degrees in WGS84
-	 * @return Azimut of the sun in degrees from north
-	 * @throws NumberFormatException when utc / datum could not be interpreted
-	 * this is prgrammed acording to the algorithmus described in <A HREF="http://de.wikipedia.org/wiki/Sonnenstand">http://de.wikipedia.org/wiki/Sonnenstand</A>
-	 */
-	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
-		//	(new MessageBox(&quot;test&quot;, &quot;utc:&quot;+utc+&quot; datum: &quot;+datum+&quot;, lat: &quot;+lat+&quot;, len: &quot;+lon, MessageBox.OKB)).exec();
-		try {
-			int tag, monat, jahr, stunde, minute, sekunde;
-			tag = Convert.parseInt(datum.substring(0, 2));
-			monat = Convert.parseInt(datum.substring(2, 4));
-			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
-			stunde=Convert.parseInt(utc.substring(0, 2));
-			minute=Convert.parseInt(utc.substring(2, 4));
-			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
-			// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
-			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
-			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
-			double b = 2 - a + java.lang.Math.floor((double)a/4.);
-			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
-			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
-			// Ekliptikalkoordinaten der Sonne berechnen (see <A HREF="http://de.wikipedia.org/wiki/Sonnenstand">http://de.wikipedia.org/wiki/Sonnenstand</A> )
-			double n = jd - 2451545.0;
-			double l = 280.46 + 0.9856474 * n;
-			double g = 357.528 + 0.9856003 * n;
-			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
-			// Rektaszension alpha und Deklination delta der Sonne berechnen
-			double e = 23.439 -0.0000004 * n;
-			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
-			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
-			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
-			if (alphaNenner&lt;0) {alpha +=180;}
-			// Azimut
-			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
-			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60. + (double)sekunde/3600.);
-			double theta = thetaHG * 15. + lon;
-			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
-			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
-			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
-					azimutNenner);
-			azimut = (float) (azimut * 180f / java.lang.Math.PI);
-			if (azimutNenner&lt;0) azimut +=180.;
-			// null = Sueden auf Null = Norden umrechnen
-			azimut +=180.;
-			if (azimut &gt;360.) azimut -=360.;
-		/*	ewe.sys.Vm.debug(&quot;sunAzimut1: &quot; + azimut);
-			ewe.sys.Vm.debug(&quot;sun Elevation: &quot; +getSunAzimut2 (utc, datum, lat, lon).latDec);
-			CWPoint MoonDir = getMoonAzimut(jd, new CWPoint(lat, lon));
-			ewe.sys.Vm.debug(&quot;Moon Elevation: &quot; + MoonDir.latDec + &quot;Moon Azimut: &quot; + MoonDir.lonDec);
-			CWPoint OrionDir = getOrionAzimut(jd, new CWPoint(lat, lon));
-			ewe.sys.Vm.debug(&quot;Alnilam (Orion) Elevation: &quot; + OrionDir.latDec + &quot;Alnilam (Orion) Azimut: &quot; + OrionDir.lonDec );
-			*/
-			return azimut;
-		} catch (IndexOutOfBoundsException e) {
-			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
-			// NumberFormatException wird au&#223;erdem von Convert.ParseInt direkt geworfen wenn
-			// nicht in Int konvertiert werden kann
-			throw new NumberFormatException();
-		}
-	}
+/**
+ * Thread for reading data from COM-port
+ *
+ */
+class SerialThread extends mThread{
+	SerialPort comSp;   
+	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	int comLength = 0;
+	CWGPSPoint myGPS;
+	boolean run, tcpForward;
+	Socket tcpConn;
+	String lastError = new String();
 
-	public static CWPoint getSunAzimut2 (String utc, String datum, double lat, double lon) {
-		double jd = utc2juliandate(utc, datum);
-		CWPoint eclCoos = getSunEclipticCoos(jd);
-		// calculate ecliptic coos
-		// convert coos
-		return ecliptic2AzimutCoos(new CWPoint(lat, lon), jd, eclCoos);
-	}
-	
-	public static CWPoint getMoonAzimut(double jd, CWPoint onEarth) {
-		CWPoint eclCoo = getMoonEclipticCoos(jd);
-		return ecliptic2AzimutCoos(onEarth, jd, eclCoo);
-	}
-	
-	public static CWPoint getOrionAzimut(double jd, CWPoint onEarth) {
-		// Koordinaten Alnilam (mittlerer G&#252;rtelstern des Orion), Rektaszension 5h36m13s; Deklination -1&#176;12'7 TODO &#196;quinoktium 2000
-		// Source: wikipedia
-		return equatorial2AzimutCoos(onEarth, jd, new CWPoint(-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) ); // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) &lt;- wikipedia // -1.19748, 5.60978 * 15.) &lt;- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  &lt;- Stellarium
-	}
-	
-	/**
-	 * get the ecliptic coordinates of the sun
-	 * @param juliandate
-	 * @return
-	 */
-	public static CWPoint getSunEclipticCoos(double juliandate) {
-		double n = juliandate - 2451545.0;
-		double l = 280.46 + 0.9856474 * n;
-		double g = 357.528 + 0.9856003 * n;
-		double lambda = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
-		return new CWPoint(0, lambda);
-	}
-	
-	
-	// the following code is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A>
-	// ignores the time difference between juliandate and TDT, which is something like 1 minute
-	public static CWPoint getMoonEclipticCoos(double julianDate) {
-		final double DEG = Math.PI / 180;  
-		final double RAD = 1/DEG;
-		double sunAnomalyMean = 360*DEG/365.242191*(julianDate - 2447891.5) + 279.403303*DEG - 282.768422*DEG;
-		double D = julianDate-2447891.5;
-
-		// Mean Moon orbit elements as of 1990.0
-		double l0 = 318.351648*DEG;
-		double P0 =  36.340410*DEG;
-		double N0 = 318.510107*DEG;
-		double i  = 5.145396*DEG;
-
-		double l = 13.1763966*DEG*D+l0;
-		double MMoon = l-0.1114041*DEG*D-P0; // Moon's mean anomaly M
-		double N = N0-0.0529539*DEG*D;       // Moon's mean ascending node longitude
-		
-		double sunlon = getSunEclipticCoos(julianDate).lonDec; 
-		double C = l-sunlon;
-		double Ev = 1.2739*DEG*Math.sin(2*C-MMoon);
-		double Ae = 0.1858*DEG*Math.sin(sunAnomalyMean);
-		double A3 = 0.37*DEG*Math.sin(sunAnomalyMean);
-
-		double MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
-		double Ec = 6.2886*DEG*Math.sin(MMoon2);  // equation of centre
-		double A4 = 0.214*DEG*Math.sin(2*MMoon2);
-		double l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
-		double V = 0.6583*DEG*Math.sin(2*(l2-sunlon));
-
-		double l3 = l2+V; // true orbital longitude;
-		double N2 = N-0.16*DEG*Math.sin(sunAnomalyMean);
-
-		CWPoint moonCoor = new CWPoint();  
-		moonCoor.lonDec = (( N2 + Math.atan2( Math.sin(l3-N2)*Math.cos(i), Math.cos(l3-N2) ) ) * RAD)% 360;
-		moonCoor.latDec = Math.asin( Math.sin(l3-N2)*Math.sin(i) ) * RAD;
-		//moonCoor.orbitLon = l3;
-		return moonCoor;
-		
-		/*
-		double e  = 0.054900;
-		double a  = 384401; // km
-		double diameter0 = 0.5181*DEG; // angular diameter of Moon at a distance
-		double parallax0 = 0.9507*DEG; // parallax at distance a
-
-		  // relative distance to semi mayor axis of lunar oribt
-		  moonCoor.distance = (1-sqr(e)) / (1+e*Math.cos(MMoon2+Ec) );
-		  moonCoor.diameter = diameter0/moonCoor.distance; // angular diameter in radians
-		  moonCoor.parallax = parallax0/moonCoor.distance; // horizontal parallax in radians
-		  moonCoor.distance *= a;	// distance in km
-
-		  // Age of Moon in radians since New Moon (0) - Full Moon (pi)
-		  moonCoor.moonAge = Mod2Pi(l3-sunCoor.lon);   
-		  moonCoor.phase   = 0.5*(1-Math.cos(moonCoor.moonAge)); // Moon phase, 0-1
-
-		  var phases = new Array(&quot;Neumond&quot;, &quot;Zunehmende Sichel&quot;, &quot;Erstes Viertel&quot;, &quot;Zunnehmender Mond&quot;, 
-		  	&quot;Vollmond&quot;, &quot;Abnehmender Mond&quot;, &quot;Letztes Viertel&quot;, &quot;Abnehmende Sichel&quot;, &quot;Neumond&quot;);
-		  var mainPhase = 1./29.53*360*DEG; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
-		  var p = Mod(moonCoor.moonAge, 90.*DEG);
-		  if (p &lt; mainPhase || p &gt; 90*DEG-mainPhase) p = 2*Math.round(moonCoor.moonAge / (90.*DEG));
-		  else p = 2*Math.floor(moonCoor.moonAge / (90.*DEG))+1;
-		  moonCoor.moonPhase = phases[p];
-
-		  moonCoor.sign = Sign(moonCoor.lon);
-		  return (float) moonCoor.lonDec;
-		return 0;
-	}
-		 */
-	}
-
-		public static CWPoint ecliptic2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint ecliptic) {
-			CWPoint equat = ecliptic2Equatorial(ecliptic, julianDate);
-			return equatorial2AzimutCoos(onEarth, julianDate, equat);
-		}
-		/**
-		 * convert rektaszension alpha and deklination delta to azimut
-		 * @param onEarth pos. on earth for which the azimut is wanted
-		 * @param julianDate
-		 * @param equatorial: lonDec = rektaszension (alpha), latDec = Deklination (delta)
-		 * @return lonDec: azimut in degrees from north, lat: elevation in degrees from horizont
-		 * alogithism from wikipedia sonnenbahn
-		 */
-		public static CWPoint equatorial2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint equatorial) {
-			double stunde = ((julianDate + 0.5) % 1) * 24;
-			double jd0 = julianDate - stunde /24; // julian date at UTC 0:00
-			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
-			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * stunde; // + (double)minute/60.);
-			double theta = thetaHG * 15. + onEarth.lonDec;
-			double tau = (theta - equatorial.lonDec ) /180*Math.PI;
-			double phi = onEarth.latDec/180*Math.PI;
-			double azimutNenner = Math.cos(tau)*Math.sin(phi)-
-				Math.tan(equatorial.latDec/180*Math.PI)*Math.cos(onEarth.latDec/180*java.lang.Math.PI);
-			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-equatorial.lonDec)/180*Math.PI)/
-					azimutNenner);
-			azimut = (float) (azimut * 180f / java.lang.Math.PI);
-			if (azimutNenner&lt;0) azimut +=180.;
-			// null = Sueden auf Null = Norden umrechnen
-			azimut +=180.;
-			if (azimut &gt;360.) azimut -=360.;
-			double h = 180 / Math.PI * Math.asin(Math.cos(equatorial.latDec/180*Math.PI) * Math.cos(tau)*Math.cos(phi) + Math.sin(equatorial.latDec/180 *Math.PI) * Math.sin(phi));
-			return new CWPoint(h, azimut);
-		}
-
-		/**
-		 * convert from eliptical to equatorial coordinates
-		 * @param juliandate
-		 * @param eklipCoo ecliptic coos in degrees  
-		 * @return lon: Deklination (delta), lat: Rektaszension (alpha) in degree
-		 * this is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A> 
-		 */
-		public static CWPoint ecliptic2Equatorial(CWPoint eklipCoo, double juliandate) {
-			double T = (juliandate - 2451545.0)/36525.; // Epoch 2000 January 1.5
-			double eps = (23.+(26+21.45/60)/60 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600 ) / 180 * java.lang.Math.PI; // schiefe der Ekliptik
-			double coseps = Math.cos(eps);
-			double sineps = Math.sin(eps);
-
-			double sinlon = Math.sin(eklipCoo.lonDec / 180 * Math.PI);
-			CWPoint equatorial = new CWPoint();
-			equatorial.lonDec = (180 / Math.PI * Math.atan2( (sinlon*coseps-Math.tan(eklipCoo.latDec /180 * Math.PI)*sineps), Math.cos(eklipCoo.lonDec/180 * Math.PI) ) ) % 360; // rektaszension (alpha)
-			equatorial.latDec = 180 / Math.PI * Math.asin( Math.sin(eklipCoo.latDec/180 * Math.PI)*coseps + Math.cos(eklipCoo.latDec/180 * Math.PI)*sineps*sinlon ); // deklination (delta)
-
-			return equatorial;
-		}
-		
-		/**
-		 * @param utc in the format as it comes from gps DDMMYY
-		 * @param datum in the format as it comes from gps HHMMSS
-		 * @return juliandate
-		 * @throws NumberFormatException if utc / datum could not be parsed successfully
-		 */
-		public static double utc2juliandate(String utc, String datum) {
+	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
+		try{
+			comSp = new SerialPort(spo);
+		} catch (IOException e) {
+			throw new IOException(spo.portName);
+		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
+		if (forwardIP.length()&gt;0) { 
 			try {
-				int tag, monat, jahr, stunde, minute, sekunde;
-				tag     = Convert.parseInt(datum.substring(0, 2));
-				monat   = Convert.parseInt(datum.substring(2, 4));
-				jahr    = Convert.parseInt(datum.substring(4, 6)) + 2000;
-				stunde  = Convert.parseInt(utc.substring(0, 2));
-				minute  = Convert.parseInt(utc.substring(2, 4));
-				sekunde = Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
-				// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
-				if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
-				double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
-				double b = 2 - a + java.lang.Math.floor((double)a/4.);
-				double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
-				return jd;
-				//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
-			} catch (IndexOutOfBoundsException e) {
-				// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
-				// NumberFormatException wird au&#223;erdem von Convert.ParseInt direkt geworfen wenn
-				// nicht in Int konvertiert werden kann
-				throw new NumberFormatException();
+				tcpConn = new Socket(forwardIP, 23);
+				tcpForward = true;
+			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
 			}
 		}
+		myGPS = GPSPoint;
 	}
 
-	/**
-	 * Thread for reading data from COM-port
-	 *
-	 */
-	class SerialThread extends mThread{
-		SerialPort comSp;   
-		byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
-		int comLength = 0;
-		CWGPSPoint myGPS;
-		boolean run, tcpForward;
-		Socket tcpConn;
-		String lastError = new String();
-
-		public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
-			try{
-				comSp = new SerialPort(spo);
-			} catch (IOException e) {
-				throw new IOException(spo.portName);
-			} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
-			if (forwardIP.length()&gt;0) { 
-				try {
-					tcpConn = new Socket(forwardIP, 23);
-					tcpForward = true;
-				} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-				} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
+	public void run() {
+		int noData = 0;
+		int notinterpreted = 0;
+		run = true;
+		while (run){
+			try {
+				sleep(1000);
+				//Vm.debug(&quot;Loop? &quot; + noData);
+				noData++;
+				if (noData &gt; 5) { myGPS.noDataError(); }
+			} catch (InterruptedException e) {}
+			if (comSp != null)	{
+				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
+				//Vm.debug(&quot;Length: &quot; + comBuff.length);
+				if (comLength &gt; 0)	{
+					noData = 0;
+					String str = mString.fromAscii(comBuff, 0, comLength); 
+					if (tcpForward) {
+						try {
+							tcpConn.write(comBuff, 0, comLength);
+						} catch (IOException e) { tcpForward = false; }
+					}
+					//Vm.debug(str);
+					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
+					if (notinterpreted &gt; 22) myGPS.noInterpretableData();
 				}
 			}
-			myGPS = GPSPoint;
-		}
+		} // while
+		myGPS.noData();
+		tcpConn.close();
+	}
 
-		public void run() {
-			int noData = 0;
-			int notinterpreted = 0;
-			run = true;
-			while (run){
-				try {
-					sleep(1000);
-					//Vm.debug(&quot;Loop? &quot; + noData);
-					noData++;
-					if (noData &gt; 5) { myGPS.noDataError(); }
-				} catch (InterruptedException e) {}
-				if (comSp != null)	{
-					comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-					//Vm.debug(&quot;Length: &quot; + comBuff.length);
-					if (comLength &gt; 0)	{
-						noData = 0;
-						String str = mString.fromAscii(comBuff, 0, comLength); 
-						if (tcpForward) {
-							try {
-								tcpConn.write(comBuff, 0, comLength);
-							} catch (IOException e) { tcpForward = false; }
-						}
-						//Vm.debug(str);
-						if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
-						if (notinterpreted &gt; 22) myGPS.noInterpretableData();
-					}
-				}
-			} // while
-			myGPS.noData();
-			tcpConn.close();
-		}
-
-		public void stop() {
-			run = false;
-			if (comSp != null) comSp.close();
-		}
+	public void stop() {
+		run = false;
+		if (comSp != null) comSp.close();
 	}
+}
 
-	/** 
-	 * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
-	 * Using the Vm.requestTimer-Method causes &quot;ewe.sys.EventDirectionException: This task cannot be done within 
-	 * a Timer Tick.&quot; in the ewe-vm when form.close is called.  
-	 */
+/** 
+ * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
+ * Using the Vm.requestTimer-Method causes &quot;ewe.sys.EventDirectionException: This task cannot be done within 
+ * a Timer Tick.&quot; in the ewe-vm when form.close is called.  
+ */
 
-	class UpdateThread extends mThread {
-		public boolean run;
-		public int calldelay;
-		public Navigate ticked;
+class UpdateThread extends mThread {
+	public boolean run;
+	public int calldelay;
+	public Navigate ticked;
 
-		public UpdateThread (Navigate gp, int cd) {
-			ticked = gp;
-			calldelay = cd;
-		}
+	public UpdateThread (Navigate gp, int cd) {
+		ticked = gp;
+		calldelay = cd;
+	}
 
-		public void run () {
-			run = true;
-			while (run) {
-				try { sleep (calldelay);} catch (InterruptedException e) {}
-				ticked.ticked();
-			}
+	public void run () {
+		run = true;
+		while (run) {
+			try { sleep (calldelay);} catch (InterruptedException e) {}
+			ticked.ticked();
 		}
+	}
 
-		public void stop() {
-			run = false;
-		}
+	public void stop() {
+		run = false;
 	}
+}
 

Added: trunk/src/CacheWolf/SkyOrientation.java
===================================================================
--- trunk/src/CacheWolf/SkyOrientation.java	2007-08-30 21:01:15 UTC (rev 855)
+++ trunk/src/CacheWolf/SkyOrientation.java	2007-08-30 21:18:25 UTC (rev 856)
@@ -0,0 +1,321 @@
+package CacheWolf;
+
+import ewe.sys.Convert;
+
+public class SkyOrientation {
+
+	public final static int SUN = 0;
+	public final static int MOON = 1;
+	public static final int ALIOTH = 2; // brightest star in Grater Bear (Grosser Wagen) Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36&quot;
+	public static final int GREATER_BEAR = ALIOTH;
+	public static final int ALNILAM = 3; //Orion = Alnilam = mittlerer Guertelstern Aequinoktium 2000): Rektaszension 5h36m13s; Deklination -1 Grad 12'7&quot;
+	public static final int ORION = ALNILAM; 
+	public static final int CASSIOPEIA_GAMMA = 4; // Kassiopeia Gamma: 00h 56m 42.50s	+60 Grad 43' 00.3&quot;
+	public static final int CASSIOPEIA = CASSIOPEIA_GAMMA;
+	public static final int DENEB = 5;
+	public static final int CYGNUS = DENEB; // Cygnus = Schwan
+	
+	public static final CWPoint[] STARS = {
+		// (Deklination, Rektaszension)
+		/*ALIOTH*/		new CWPoint(55. +57./60. + 36./3600., (12. + 54./60. + 2./3600.)*15.), // ALIOTH: Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36&quot;
+		/*ALNILAM*/		new CWPoint(-1. -12./60. -7./3600., (5.+36./60. + 13./3600.)*15.), // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) &lt;- wikipedia // -1.19748, 5.60978 * 15.) &lt;- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  &lt;- Stellarium 
+		/*Cassiopeia*/	new CWPoint(60. + 43./60. + 0.3/3600., (0 + 56./60. +42.5/3600.)*15.), // CASSIOPALA_GAMMA 00h 56m 42.50s, 60 Grad 43' 00.3&quot; &lt;-- wikipedia, Stellarium: 57m 11s, 60 Grad 45' 29&quot;
+		/*Deneb*/		new CWPoint(45. + 16./60. + 49.2/3600., (20 + 41./60. +25.6/3600.)*15.) // im Schwan (Sommerdreieck) Quelle: Stellarium
+		// Krez des S&#252;dens
+		// Sirius
+	};
+	
+	public static String [] LUMINARY_NAMES = { // TODO MyLocale.getMsg(xxx, &quot;Sun&quot;),
+		MyLocale.getMsg(6100, &quot;Sun&quot;), 
+		MyLocale.getMsg(6101, &quot;Moon&quot;), 
+		MyLocale.getMsg(6102, &quot;Grater Bear&quot;),
+		MyLocale.getMsg(6103, &quot;Orion&quot;),
+		MyLocale.getMsg(6104, &quot;Cassiopeia&quot;), 
+		MyLocale.getMsg(6105, &quot;Cygnus&quot;)
+	};
+
+	public static String [] LUMINARY_DESC = { // TODO MyLocale.getMsg(xxx, &quot;Sun&quot;),
+		MyLocale.getMsg(6100, &quot;Sun&quot;), 
+		MyLocale.getMsg(6101, &quot;Moon&quot;), 
+		MyLocale.getMsg(6122, &quot;Alioth in Greater Bear&quot;),
+		MyLocale.getMsg(6123, &quot;Alnilam in Orion&quot;),
+		MyLocale.getMsg(6124, &quot;Cassiopeia Gamma&quot;), 
+		MyLocale.getMsg(6125, &quot;Deneb in Cygnus&quot;)
+	};
+
+	public static String getLuminaryName(int luminary) {
+		return LUMINARY_NAMES[luminary]; 
+	}
+	
+	public static String getLuminaryDesc(int lu) {
+		return LUMINARY_DESC[lu];
+	}
+
+	/**
+	 * get azimuth from north and elevation for horizont for a given 
+	 * Luminary (planet or star) 
+	 * @param luminary one of SUN, MOON, ALIOTH, GRAETER_BEAR, ALNILAM, ORION, CASSIOPEIA_GAMMA, CASSIOPEIA
+	 * @param jd julian date must be calculated in advance e.g. from utc2julian
+	 * @param onEarth place on earth of the observer
+	 * @return lon = azimuth from north, lat = elevation from horizont
+	 */
+	public static CWPoint getLuminaryDir(int luminary, double jd, CWPoint onEarth) {
+		switch (luminary) {
+		case SUN: return getSunDir(jd, onEarth);
+		case MOON: return getMoonDir(jd, onEarth);
+		default: 
+			return equatorial2AzimutCoos(onEarth, jd, STARS[luminary-MOON-1]);
+		}
+	}
+
+	/**
+	 * @param utc in the format as it comes from gps DDMMYY
+	 * @param datum in the format as it comes from gps HHMMSS
+	 * @return juliandate
+	 * @throws NumberFormatException if utc / datum could not be parsed successfully
+	 */
+	public static double utc2juliandate(String utc, String datum) {
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag     = Convert.parseInt(datum.substring(0, 2));
+			monat   = Convert.parseInt(datum.substring(2, 4));
+			jahr    = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde  = Convert.parseInt(utc.substring(0, 2));
+			minute  = Convert.parseInt(utc.substring(2, 4));
+			sekunde = Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
+			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			return jd;
+			//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird au&#223;erdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
+		//	(new MessageBox(&quot;test&quot;, &quot;utc:&quot;+utc+&quot; datum: &quot;+datum+&quot;, lat: &quot;+lat+&quot;, len: &quot;+lon, MessageBox.OKB)).exec();
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag = Convert.parseInt(datum.substring(0, 2));
+			monat = Convert.parseInt(datum.substring(2, 4));
+			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde=Convert.parseInt(utc.substring(0, 2));
+			minute=Convert.parseInt(utc.substring(2, 4));
+			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
+			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+			// Ekliptikalkoordinaten der Sonne berechnen (see <A HREF="http://de.wikipedia.org/wiki/Sonnenstand">http://de.wikipedia.org/wiki/Sonnenstand</A> )
+			double n = jd - 2451545.0;
+			double l = 280.46 + 0.9856474 * n;
+			double g = 357.528 + 0.9856003 * n;
+			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+			// Rektaszension alpha und Deklination delta der Sonne berechnen
+			double e = 23.439 -0.0000004 * n;
+			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
+			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
+			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
+			if (alphaNenner&lt;0) {alpha +=180;}
+			// Azimut
+			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60. + (double)sekunde/3600.);
+			double theta = thetaHG * 15. + lon;
+			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
+			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
+			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
+					azimutNenner);
+			azimut = (float) (azimut * 180f / java.lang.Math.PI);
+			if (azimutNenner&lt;0) azimut +=180.;
+			// null = Sueden auf Null = Norden umrechnen
+			azimut +=180.;
+			if (azimut &gt;360.) azimut -=360.;
+			ewe.sys.Vm.debug(&quot;sunAzimut1: &quot; + azimut);
+			ewe.sys.Vm.debug(&quot;sun Elevation: &quot; +getSunAzimut2 (utc, datum, lat, lon).latDec);
+			CWPoint MoonDir = getMoonDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug(&quot;Moon Elevation: &quot; + MoonDir.latDec + &quot;Moon Azimut: &quot; + MoonDir.lonDec);
+			CWPoint OrionDir = getAlnilamDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug(&quot;Alnilam (Orion) Elevation: &quot; + OrionDir.latDec + &quot;Alnilam (Orion) Azimut: &quot; + OrionDir.lonDec );
+			
+			return azimut;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird ausserdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	public static CWPoint getSunAzimut2 (String utc, String datum, double lat, double lon) {
+		double jd = utc2juliandate(utc, datum);
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(new CWPoint(lat, lon), jd, eclCoos);
+	}
+
+	public static CWPoint getSunDir (double jd, CWPoint onEarth) {
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoos);
+	}
+
+	public static CWPoint getMoonDir(double jd, CWPoint onEarth) {
+		CWPoint eclCoo = getMoonEclipticCoos(jd);
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoo);
+	}
+
+	public static CWPoint getAlnilamDir(double jd, CWPoint onEarth) {
+		// Koordinaten Alnilam (mittlerer Guertelstern des Orion), Rektaszension 5h36m13s; Deklination -1&#176;12'7 TODO Aequinoktium 2000
+		// Source: wikipedia
+		return equatorial2AzimutCoos(onEarth, jd, new CWPoint(-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) ); // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) &lt;- wikipedia // -1.19748, 5.60978 * 15.) &lt;- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  &lt;- Stellarium
+	}
+
+	/**
+	 * get the ecliptic coordinates of the sun
+	 * @param juliandate
+	 * @return
+	 */
+	public static CWPoint getSunEclipticCoos(double juliandate) {
+		double n = juliandate - 2451545.0;
+		double l = 280.46 + 0.9856474 * n;
+		double g = 357.528 + 0.9856003 * n;
+		double lambda = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+		return new CWPoint(0, lambda);
+	}
+
+
+	// the following code is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A>
+	// ignores the time difference between juliandate and TDT, which is something like 1 minute
+	public static CWPoint getMoonEclipticCoos(double julianDate) {
+		final double DEG = Math.PI / 180;  
+		final double RAD = 1/DEG;
+		double sunAnomalyMean = 360*DEG/365.242191*(julianDate - 2447891.5) + 279.403303*DEG - 282.768422*DEG;
+		double D = julianDate-2447891.5;
+
+		// Mean Moon orbit elements as of 1990.0
+		double l0 = 318.351648*DEG;
+		double P0 =  36.340410*DEG;
+		double N0 = 318.510107*DEG;
+		double i  = 5.145396*DEG;
+
+		double l = 13.1763966*DEG*D+l0;
+		double MMoon = l-0.1114041*DEG*D-P0; // Moon's mean anomaly M
+		double N = N0-0.0529539*DEG*D;       // Moon's mean ascending node longitude
+
+		double sunlon = getSunEclipticCoos(julianDate).lonDec; 
+		double C = l-sunlon;
+		double Ev = 1.2739*DEG*Math.sin(2*C-MMoon);
+		double Ae = 0.1858*DEG*Math.sin(sunAnomalyMean);
+		double A3 = 0.37*DEG*Math.sin(sunAnomalyMean);
+
+		double MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
+		double Ec = 6.2886*DEG*Math.sin(MMoon2);  // equation of centre
+		double A4 = 0.214*DEG*Math.sin(2*MMoon2);
+		double l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
+		double V = 0.6583*DEG*Math.sin(2*(l2-sunlon));
+
+		double l3 = l2+V; // true orbital longitude;
+		double N2 = N-0.16*DEG*Math.sin(sunAnomalyMean);
+
+		CWPoint moonCoor = new CWPoint();  
+		moonCoor.lonDec = (( N2 + Math.atan2( Math.sin(l3-N2)*Math.cos(i), Math.cos(l3-N2) ) ) * RAD)% 360;
+		moonCoor.latDec = Math.asin( Math.sin(l3-N2)*Math.sin(i) ) * RAD;
+		//moonCoor.orbitLon = l3;
+		return moonCoor;
+
+		/*
+		double e  = 0.054900;
+		double a  = 384401; // km
+		double diameter0 = 0.5181*DEG; // angular diameter of Moon at a distance
+		double parallax0 = 0.9507*DEG; // parallax at distance a
+
+		  // relative distance to semi mayor axis of lunar oribt
+		  moonCoor.distance = (1-sqr(e)) / (1+e*Math.cos(MMoon2+Ec) );
+		  moonCoor.diameter = diameter0/moonCoor.distance; // angular diameter in radians
+		  moonCoor.parallax = parallax0/moonCoor.distance; // horizontal parallax in radians
+		  moonCoor.distance *= a;	// distance in km
+
+		  // Age of Moon in radians since New Moon (0) - Full Moon (pi)
+		  moonCoor.moonAge = Mod2Pi(l3-sunCoor.lon);   
+		  moonCoor.phase   = 0.5*(1-Math.cos(moonCoor.moonAge)); // Moon phase, 0-1
+
+		  var phases = new Array(&quot;Neumond&quot;, &quot;Zunehmende Sichel&quot;, &quot;Erstes Viertel&quot;, &quot;Zunnehmender Mond&quot;, 
+		  	&quot;Vollmond&quot;, &quot;Abnehmender Mond&quot;, &quot;Letztes Viertel&quot;, &quot;Abnehmende Sichel&quot;, &quot;Neumond&quot;);
+		  var mainPhase = 1./29.53*360*DEG; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
+		  var p = Mod(moonCoor.moonAge, 90.*DEG);
+		  if (p &lt; mainPhase || p &gt; 90*DEG-mainPhase) p = 2*Math.round(moonCoor.moonAge / (90.*DEG));
+		  else p = 2*Math.floor(moonCoor.moonAge / (90.*DEG))+1;
+		  moonCoor.moonPhase = phases[p];
+
+		  moonCoor.sign = Sign(moonCoor.lon);
+		  return (float) moonCoor.lonDec;
+		return 0;
+	}
+		 */
+	}
+
+	public static CWPoint ecliptic2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint ecliptic) {
+		CWPoint equat = ecliptic2Equatorial(ecliptic, julianDate);
+		return equatorial2AzimutCoos(onEarth, julianDate, equat);
+	}
+	/**
+	 * convert rektaszension alpha and deklination delta to azimuth / elevation
+	 * @param onEarth pos. on earth for which the azimut is wanted
+	 * @param julianDate
+	 * @param equatorial: lonDec = rektaszension (alpha), latDec = Deklination (delta)
+	 * @return lonDec: azimuth in degrees from north, lat: elevation in degrees from horizont
+	 * alogithism from wikipedia sonnenbahn
+	 */
+	public static CWPoint equatorial2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint equatorial) {
+		double stunde = ((julianDate + 0.5) % 1) * 24;
+		double jd0 = julianDate - stunde /24; // julian date at UTC 0:00
+		double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+		double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * stunde; // + (double)minute/60.);
+		double theta = thetaHG * 15. + onEarth.lonDec;
+		double tau = (theta - equatorial.lonDec ) /180*Math.PI;
+		double phi = onEarth.latDec/180*Math.PI;
+		double azimutNenner = Math.cos(tau)*Math.sin(phi)-
+		Math.tan(equatorial.latDec/180*Math.PI)*Math.cos(onEarth.latDec/180*java.lang.Math.PI);
+		float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-equatorial.lonDec)/180*Math.PI)/
+				azimutNenner);
+		azimut = (float) (azimut * 180f / java.lang.Math.PI);
+		if (azimutNenner&lt;0) azimut +=180.;
+		double h = 180 / Math.PI * Math.asin(Math.cos(equatorial.latDec/180*Math.PI) * Math.cos(tau)*Math.cos(phi) + Math.sin(equatorial.latDec/180 *Math.PI) * Math.sin(phi));
+		// null = Sueden auf Null = Norden umrechnen
+		azimut +=180.;
+		if (azimut &gt;360.) azimut -=360.;
+		return new CWPoint(h, azimut);
+	}
+
+	/**
+	 * convert from eliptical to equatorial coordinates
+	 * @param juliandate
+	 * @param eklipCoo ecliptic coos in degrees  
+	 * @return lon: Deklination (delta), lat: Rektaszension (alpha) in degree
+	 * this is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A> 
+	 */
+	public static CWPoint ecliptic2Equatorial(CWPoint eklipCoo, double juliandate) {
+		double T = (juliandate - 2451545.0)/36525.; // Epoch 2000 January 1.5
+		double eps = (23.+(26+21.45/60)/60 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600 ) / 180 * java.lang.Math.PI; // schiefe der Ekliptik
+		double coseps = Math.cos(eps);
+		double sineps = Math.sin(eps);
+
+		double sinlon = Math.sin(eklipCoo.lonDec / 180 * Math.PI);
+		CWPoint equatorial = new CWPoint();
+		equatorial.lonDec = (180 / Math.PI * Math.atan2( (sinlon*coseps-Math.tan(eklipCoo.latDec /180 * Math.PI)*sineps), Math.cos(eklipCoo.lonDec/180 * Math.PI) ) ) % 360; // rektaszension (alpha)
+		equatorial.latDec = 180 / Math.PI * Math.asin( Math.sin(eklipCoo.latDec/180 * Math.PI)*coseps + Math.cos(eklipCoo.latDec/180 * Math.PI)*sineps*sinlon ); // deklination (delta)
+
+		return equatorial;
+	}
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000747.html">[Cachewolf-svn] r855 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="000749.html">[Cachewolf-svn] r857 - in trunk: resources src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#748">[ date ]</a>
              <a href="thread.html#748">[ thread ]</a>
              <a href="subject.html#748">[ subject ]</a>
              <a href="author.html#748">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
