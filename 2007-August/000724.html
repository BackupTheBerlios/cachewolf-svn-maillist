<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r834 - trunk/src/CacheWolf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r834%20-%20trunk/src/CacheWolf&In-Reply-To=%3C200708261243.l7QChuF0006926%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000723.html">
   <LINK REL="Next"  HREF="000725.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r834 - trunk/src/CacheWolf</H1>
    <B>salzkammergut at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r834%20-%20trunk/src/CacheWolf&In-Reply-To=%3C200708261243.l7QChuF0006926%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r834 - trunk/src/CacheWolf">salzkammergut at mail.berlios.de
       </A><BR>
    <I>Sun Aug 26 14:43:56 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000723.html">[Cachewolf-svn] r833 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="000725.html">[Cachewolf-svn] r835 - in trunk: resources src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#724">[ date ]</a>
              <a href="thread.html#724">[ thread ]</a>
              <a href="subject.html#724">[ subject ]</a>
              <a href="author.html#724">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: salzkammergut
Date: 2007-08-26 14:43:34 +0200 (Sun, 26 Aug 2007)
New Revision: 834

Added:
   trunk/src/CacheWolf/TableColumnChooser.java
   trunk/src/CacheWolf/Travelbug.java
   trunk/src/CacheWolf/TravelbugJourney.java
   trunk/src/CacheWolf/TravelbugJourneyList.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/TravelbugList.java
   trunk/src/CacheWolf/TravelbugPickup.java
   trunk/src/CacheWolf/TravelbugScreen.java
Log:
Nachtrag zum vorherigen Commit. Aus mir unklaren Gruenden wurden diese Dateien nicht eingecheckt.

Added: trunk/src/CacheWolf/TableColumnChooser.java
===================================================================
--- trunk/src/CacheWolf/TableColumnChooser.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/TableColumnChooser.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,204 @@
+package CacheWolf;
+
+import ewe.fx.*;
+import ewe.sys.Convert;
+import ewe.sys.VMApp;
+import ewe.sys.VMApps;
+import ewe.sys.Vm;
+import ewe.ui.*;
+import ewe.util.*;
+
+public class TableColumnChooser extends CellPanel {
+
+	String [] colNames;
+	Vector shownCols=new Vector(13);
+	Vector hiddenCols=new Vector(13);
+	private mButton btnDown,btnUp,btnLeft,btnRight;
+	private myList lstShown,lstHidden;
+	
+	/**
+	 * 
+	 * @param colNames String array of ALL column names
+	 * @param selectedCols The selected columns separated by ,
+	 */
+	public TableColumnChooser(String [] colNames, String selectedCols) {
+        this.colNames=colNames;
+		addNext(new mLabel(MyLocale.getMsg(6050,&quot;Show column&quot;)));
+        addNext(new mLabel(&quot;&quot;));
+        addLast(new mLabel(MyLocale.getMsg(6051,&quot;Don't show column&quot;)));
+        
+        addNext(new ScrollBarPanel(lstShown=new myList(6,shownCols),ScrollBarPanel.AlwaysShowVerticalScrollers));
+        CellPanel cpMid=new CellPanel();
+        cpMid.addLast(new mLabel(&quot;&quot;));
+        mImage imgRight=new mImage(&quot;ewe/rightarrowsmall.bmp&quot;);imgRight.transparentColor=Color.White;
+        mImage imgLeft=new mImage(&quot;ewe/leftarrowsmall.bmp&quot;);imgLeft.transparentColor=Color.White;
+        cpMid.addLast(btnRight=new mButton(imgRight));
+        cpMid.addLast(new mLabel(&quot;&quot;));
+        cpMid.addLast(btnLeft=new mButton(imgLeft));
+        cpMid.addLast(new mLabel(&quot;&quot;));
+        addNext(cpMid,VSTRETCH,VFILL);
+        addLast(new ScrollBarPanel(lstHidden=new myList(6,hiddenCols),ScrollBarPanel.AlwaysShowVerticalScrollers));
+        
+        CellPanel pnlButtons=new CellPanel();
+		mImage imgDown=new mImage(&quot;ewe/downarrowsmall.bmp&quot;); imgDown.transparentColor=Color.White;
+		mImage imgUp=new mImage(&quot;ewe/uparrowsmall.bmp&quot;); imgUp.transparentColor=Color.White;
+        pnlButtons.addNext(btnDown=new mButton(imgDown),HSTRETCH,HFILL); btnDown.modify(Disabled,0);
+		pnlButtons.addLast(btnUp=new mButton(imgUp),HSTRETCH,HFILL); btnUp.modify(Disabled,0);
+        addNext(pnlButtons);
+        addNext(new mLabel(&quot;&quot;));
+        addLast(new mLabel(&quot;&quot;));
+        
+        // Set up
+        for (int i=0; i&lt;colNames.length; i++) hiddenCols.add(colNames[i]);
+        StringTokenizer st=new StringTokenizer(selectedCols,&quot;,&quot;);
+        int iCol;
+        while (st.hasMoreTokens()) {
+        	iCol=Common.parseInt(st.nextToken());
+        	if (iCol&gt;=0 &amp;&amp; iCol&lt;colNames.length) {
+        		shownCols.add(colNames[iCol]);
+        		hiddenCols.remove(colNames[iCol]);
+        	}
+        }
+        changeUpDownButtonStatus();
+	}
+
+	public String getSelectedCols() {
+		StringBuffer sb=new StringBuffer(40);
+		for (int i=0; i&lt;lstShown.items.size(); i++) {
+			String colName=(String)lstShown.items.elementAt(i);
+			for (int j=0; j&lt;colNames.length; j++) {
+				if (colName.equals(colNames[j])) {
+					if (sb.length()!=0) sb.append(',');
+					sb.append(j);
+					break;
+				}
+			}
+		}
+		return sb.toString();
+	}
+	
+	/** Enable the up/down buttons only if at least 2 caches are in the list */
+	private void changeUpDownButtonStatus() {
+		btnUp.modify(0,Disabled);
+		if (lstShown.items.size()&lt;2 || lstShown.getSelectedIndex(0)==0) btnUp.modify(Disabled,0);
+		btnDown.modify(0,Disabled);
+		if (lstShown.items.size()&lt;2 || lstShown.getSelectedIndex(0)==lstShown.items.size()-1) btnDown.modify(Disabled,0);
+		btnUp.repaintNow();
+		btnDown.repaintNow();
+	}
+
+	
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type==ControlEvent.PRESSED) {
+			if (ev.target==btnUp) {
+				lstShown.moveUp();
+			} else if (ev.target==btnDown) {
+				lstShown.moveDown();
+			} else if (ev.target==btnRight) {
+				// Need to leave at least one item in shown list
+				if (lstShown.items.size()&gt;1)
+					lstShown.moveItem(lstHidden,lstShown.getSelectedIndex(0));
+			} else if (ev.target==btnLeft) {
+				lstHidden.moveItem(lstShown,lstHidden.getSelectedIndex(0));
+			}
+			changeUpDownButtonStatus();
+		} else if (ev instanceof ListEvent &amp;&amp; ev.target==lstShown)
+			changeUpDownButtonStatus();
+		super.onEvent(ev);
+	}
+	
+	private class myList extends mList {
+
+		//public Vector items;
+		int idx;
+		
+		myList(int rows, Vector elements) {
+			super(rows,1,false);
+			//this.items=elements;
+			items=elements;
+		}
+
+		// Move selected element down by one
+    	public void moveDown() {
+			idx=getSelectedIndex(0);
+    		if (idx&gt;=0) {
+	    		String s=(String) items.elementAt(idx);
+				items.del(idx);
+	    		items.insertElementAt(s,idx+1);
+	    		select(idx+1);
+	    		repaint();
+    		}
+    	}
+    	
+    	// Move selected element up by one
+    	public void moveUp() {
+			idx=getSelectedIndex(0);
+    		if (idx&gt;=0) {
+				String s=(String) items.elementAt(idx);
+				items.del(idx);
+	    		items.insertElementAt(s,idx-1);
+	    		select(idx-1);
+	    		repaint();
+    		}
+    	}
+    	
+    	
+		public void startDragging(DragContext dc) {
+			 idx=getSelectedIndex(0);
+			 // Can only drag if we have a valid index (at least on element in list)
+			 // Also if we drag from lstShown, we must leave at least one item in list
+			 if (idx&gt;=0 &amp;&amp; idx&lt;items.size() &amp;&amp; (this!=lstShown || items.size()&gt;1)) {
+				 IconAndText imgDrag=new IconAndText();
+				 imgDrag.addColumn(items.elementAt(idx));
+				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
+			 }
+		}
+	
+		public void dragged(DragContext dc) {
+			if (dc.dragData!=null) dc.imageDrag();
+		}
+		 
+		public void stopDragging(DragContext dc) {
+			 if (dc.dragData==null) return;
+			 dc.stopImageDrag(true);
+			 Point p = Gui.getPosInParent(this,getWindow());
+			 p.x += dc.curPoint.x;
+			 p.y += dc.curPoint.y;
+			 Control dest = getWindow().findChild(p.x,p.y);
+		     if (dest instanceof myList) { 
+		    	 moveItem((myList)dest,idx);
+		    	 changeUpDownButtonStatus();
+		     }
+		 }
+		
+		public void moveItem(myList dst, int srcIdx) {
+			 if(srcIdx&lt;0) return;
+	    	 String colToMove=(String) items.elementAt(srcIdx);
+	    	 items.del(srcIdx);
+	    	 ((myList)dst).items.add(colToMove);
+	    	 repaint();
+	    	 dst.repaint();
+	    	 if (srcIdx&gt;=items.size()) select(items.size()-1);
+		}
+	
+	} // myList
+	
+	/**
+	 * Converts a comma delimited string into an integer array.
+	 * Each value is checked and has to be between min and max, If not it is
+	 * replaced with default
+	 */ 
+	public static int[] str2Array(String configString, int min, int max, int def) {
+		Vector strConfigVector=new Vector(14);
+		SubString.split(configString,',',strConfigVector);
+		int i;
+		int nElem=strConfigVector.size();
+		int []res=new int[nElem];
+		for (i=0; i&lt;nElem; i++) {
+			res[i]=Common.parseInt((String)strConfigVector.elementAt(i));
+			if (res[i]&lt;min || res[i]&gt;max) res[i]=def;
+		}
+		return res;
+	}
+	
+}

Added: trunk/src/CacheWolf/Travelbug.java
===================================================================
--- trunk/src/CacheWolf/Travelbug.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/Travelbug.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,88 @@
+package CacheWolf;
+/**
+ * This contains the basic information of a GC travelbug.
+ * @author salzkammergut
+ *
+ */
+public class Travelbug {
+	/** GC unique id or guid (both are used depending on how the TB is picked up).
+	 * Travelbugs retrieved from a cache use the guid, travelbugs entered manually
+	 * use the id */
+	private String guid;       //0
+	/** GC Name i.e. &quot;First Roman Geocoin&quot; */
+	private String name;       //1
+	/** GC tracking no i.e. 652345, needed for logging */
+	private String trackingNo; //2 
+	/** GC Mission */
+	private String mission;    //3
+
+	/** Construct a travelbug with a given name */
+	public Travelbug(String name) {
+		this(&quot;&quot;,name,&quot;&quot;);
+	}
+
+	/** Construct a travelbug with id, name and mission */
+	public Travelbug(String guid, String name, String mission) {
+		this.guid = guid;
+		this.name = name;
+		this.mission = mission;
+		this.trackingNo=&quot;&quot;;
+	}
+	
+	public String getGuid() {
+		return guid;
+	}
+
+	public void setGuid(String guid) {
+		this.guid = guid;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public void setName(String name) {
+		this.name = name;
+	}
+
+	public String getTrackingNo() {
+		return trackingNo;
+	}
+
+	public void setTrackingNo(String trackingNo) {
+		this.trackingNo = trackingNo;
+	}
+
+	public void setMission(String mission) {
+		this.mission = mission;
+	}
+
+	public String getMission() {
+		return this.mission;
+	}
+	
+	/** Return XML representation of travelbug for storing in cache.xml */
+	public String toXML(){
+		StringBuffer s=new StringBuffer(300);
+		s.append(&quot;  &lt;tb guid=\&quot;&quot;);
+		s.append(guid);
+		s.append(&quot;\&quot;&gt;&lt;name&gt;&lt;![CDATA[&quot;);
+		s.append(name);
+		s.append(&quot;]]&gt;&lt;/name&gt;&lt;![CDATA[&quot;);
+		s.append(mission);
+		s.append(&quot;]]&gt;&lt;/tb&gt;\n&quot;);
+		return s.toString();
+	}
+	
+	/** Return HTML representation of travelbug for display on screen */
+	public String toHtml(){
+		StringBuffer s=new StringBuffer(300);
+		s.append(&quot;&lt;b&gt;Name:&lt;/b&gt; &quot;);
+		s.append(name);
+		s.append(&quot;&lt;br&gt;&quot;);
+		s.append(mission);
+		s.append(&quot;&lt;hr&gt;&quot;);
+		return s.toString();
+	}
+
+}

Added: trunk/src/CacheWolf/TravelbugJourney.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourney.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/TravelbugJourney.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,320 @@
+package CacheWolf;
+
+/**
+ * A travelbug journey starts in a cache (from....) where the tb is picked up and 
+ * ends in another cache (to...) where the travelbug is dropped. For both transfers
+ * the date/time is recorded and a flag (...Logged) is kept, indicating whether the
+ * transfer has been logged to GC.
+ * @author salzkammergut
+ */
+import ewe.fx.Image;
+import ewe.sys.*;
+
+public class TravelbugJourney  {
+	/** 
+	 * The travelbug concerned @see Travelbug 
+	 */
+	private Travelbug tb;
+	/** 
+	 * The profile from where the travelbug was picked up 
+	 */
+	private String fromProfile;//4:
+	/** 
+	 * The waypoint within the profile where the travelbug was picked up 
+	 */
+	private String fromWaypoint;//5:
+	/** 
+	 * The date and time when the travelbug was picked up 
+	 */
+	private String fromDate;   //6: 
+	/** 
+	 * Flag that indicates whether the pick-up was logged with GC 
+	 */
+	private boolean fromLogged;//7:
+	/** 
+	 * The profile where the travelbug was dropped 
+	 */
+	private String toProfile;  //8:
+	/** 
+	 * The waypoint within the profile where the travelbug was dropped 
+	 */
+	private String toWaypoint; //9:
+	/** 
+	 * The date and time when the travelbug was dropped 
+	 */
+	private String toDate;     //10:
+	/** 
+	 * Flag that indicates whether the drop was logged with GC 
+	 */
+	private boolean toLogged;  //11:
+	/**
+	 * When retrieving the elements of a travelbug journey by number, this
+	 * virtual column is used to retrieve the AND of fromLogged and toLogged. 
+	 * It thus returns true only if bith transactions have been logged.
+	 */
+	public static final int BOTHLOGGED=12;
+	
+	public TravelbugJourney(String id, String name, String trackingNo, String fromProfile, 
+			String fromWaypoint, String fromDate, String fromLogged,
+			String toProfile, String toWaypoint, String toDate, String toLogged,
+			String mission) {
+		tb=new Travelbug(id,name,mission);
+		tb.setTrackingNo(trackingNo);
+		this.fromProfile = fromProfile;
+		this.fromWaypoint = fromWaypoint;
+		this.fromDate = fromDate;
+		this.fromLogged = Convert.toBoolean(fromLogged);
+		this.toProfile = toProfile;
+		this.toWaypoint = toWaypoint;
+		this.toDate = toDate;
+		this.toLogged = Convert.toBoolean(toLogged);
+	}
+
+	public TravelbugJourney(String name) {
+		tb=new Travelbug(&quot;&quot;,name,&quot;&quot;);
+		tb.setTrackingNo(&quot;&quot;);
+		setFromProfile(&quot;&quot;);
+		setFromWaypoint(&quot;&quot;);
+		setFromDate(&quot;&quot;);    
+		setFromLogged(&quot;&quot;);
+		setToProfile(&quot;&quot;);
+		setToWaypoint(&quot;&quot;);
+		setToDate(&quot;&quot;);   
+		setToLogged(&quot;&quot;); 
+	}
+
+	public TravelbugJourney(Travelbug tb, String profile, String waypoint) {
+		this.tb=tb;
+		setFromProfile(profile);
+		setFromWaypoint(waypoint);
+		setFromDate(getDateTime());    
+		setToProfile(&quot;&quot;);
+		setToWaypoint(&quot;&quot;);
+		setToDate(&quot;&quot;);   
+		setFromLogged(&quot;&quot;);
+		setToLogged(&quot;&quot;); 
+	}
+	
+	/** Drop a travelbug in a profile/waypoint and set the current date-time as
+	 * the drop date-time.
+	 * @param profile The profile where the tb is dropped
+	 * @param waypoint the waypoint where the tb is dropped
+	 */
+	public void dropTravelbug(String profile, String waypoint) {
+		setToProfile(profile);
+		setToWaypoint(waypoint);
+		setToDate(getDateTime());    
+	}
+	
+	private static Image checkboxTicked = new Image(&quot;checkboxTicked.png&quot;);
+	private static Image checkboxUnticked= new Image(&quot;checkboxUnticked.png&quot;);
+	
+	/** Get an element of a TravelbugJourney by number. This is used when
+	 * displaying the journey in list format.
+	 * @param elementNo The element (=column) to get
+	 * @return The requested element as a String or Image
+	 */
+	public Object getElementByNumber(int elementNo) {
+		switch(elementNo) {
+	    	//--- Travelbug ---
+		    case 0: return tb.getGuid();
+		   	case 1:	return tb.getName();
+			case 2: return tb.getTrackingNo();
+			case 3: return tb.getMission();
+		    //--- TravelbugJourney ---
+			case 4: return getFromProfile();
+			case 5: return getFromWaypoint();
+			case 6: return getFromDate();
+			case 7: if (getFromLogged())
+						return checkboxTicked;
+					else
+						return checkboxUnticked;
+			case 8: return getToProfile();
+			case 9: return getToWaypoint();
+			case 10: return getToDate();
+			case 11: if(getToLogged())
+						return checkboxTicked;
+					else
+						return checkboxUnticked;
+			/* Special case 12: Return Z if both moves have been logged, blank otherwise
+			 This allows the not logged tbJourneys to be sorted to the top.*/
+			case 12: return bothLogsDone() ? &quot;Z&quot;: &quot; &quot;;
+			default: return &quot;?&quot;;
+		}
+	}
+
+	/** Return the name of the journey element by number, i.e. the title column
+	 * of a list.
+	 * @param elementNo The element (=column) to get
+	 * @return The name as a String
+	 */
+	public static String getElementNameByNumber(int elementNo) {
+		switch (elementNo) {
+		    //--- Travelbug ---
+			case 0: return MyLocale.getMsg(6000,&quot;Guid&quot;);
+		   	case 1:	return MyLocale.getMsg(6001,&quot;Name&quot;);
+			case 2: return MyLocale.getMsg(6002,&quot;track#&quot;);
+			case 3: return MyLocale.getMsg(6003,&quot;Mission&quot;);
+		    //--- TravelbugJourney ---
+			case 4: return MyLocale.getMsg(6004,&quot;From Prof&quot;);
+			case 5: return MyLocale.getMsg(6005,&quot;From Wpt&quot;);
+			case 6: return MyLocale.getMsg(6006,&quot;From Date&quot;);
+			case 7: return MyLocale.getMsg(6007,&quot;From Log&quot;);
+			case 8: return MyLocale.getMsg(6008,&quot;To Prof&quot;);
+			case 9: return MyLocale.getMsg(6009,&quot;To Wpt&quot;);
+			case 10: return MyLocale.getMsg(6010,&quot;To Date&quot;);
+			case 11: return MyLocale.getMsg(6011,&quot;To Log&quot;);
+			default: return &quot;?&quot;;
+		}
+	}
+	
+	/** Return the travelbug that defines the journey */
+	public Travelbug getTb() {
+		if (tb==null) tb=new Travelbug(&quot;&quot;);
+		return tb;
+	}
+	
+	/** The date when the travelbug was picked up */
+	public String getFromDate() {
+		return fromDate;
+	}
+
+	/** The date when the travelbug was picked up */
+	public void setFromDate(String fromDate) {
+		this.fromDate = fromDate;
+	}
+
+	/** The profile where the travelbug was picked up */
+	public String getFromProfile() {
+		return fromProfile;
+	}
+
+	/** The profile where the travelbug was picked up */
+	public void setFromProfile(String fromProfile) {
+		this.fromProfile = fromProfile;
+	}
+
+	/** The waypoint where the travelbug was picked up */
+	public String getFromWaypoint() {
+		return fromWaypoint;
+	}
+
+	/** The waypoint where the travelbug was picked up */
+	public void setFromWaypoint(String fromWaypoint) {
+		this.fromWaypoint = fromWaypoint;
+	}
+
+	/** The log status of the travelbug pick-up transaction */
+	public void setFromLogged(String fromLogged) {
+		this.fromLogged = Convert.toBoolean(fromLogged);
+	}
+
+	/** The log status of the travelbug pick-up transaction */
+	public void setFromLogged(boolean fromLogged) {
+		this.fromLogged = fromLogged;
+	}
+
+	/** The log status of the travelbug pick-up transaction */
+	public boolean getFromLogged() {
+		return this.fromLogged;
+	}
+
+	/** The date when the travelbug was dropped */
+	public String getToDate() {
+		return toDate;
+	}
+
+	/** The date when the travelbug was dropped */
+	public void setToDate(String toDate) {
+		this.toDate = toDate;
+	}
+
+	/** The profile where the travelbug was dropped */
+	public String getToProfile() {
+		return toProfile;
+	}
+
+	/** The profile where the travelbug was dropped */
+	public void setToProfile(String toProfile) {
+		this.toProfile = toProfile;
+	}
+
+	/** The waypoint where the travelbug was dropped */
+	public String getToWaypoint() {
+		return toWaypoint;
+	}
+
+	/** The waypoint where the travelbug was dropped */
+	public void setToWaypoint(String toWaypoint) {
+		this.toWaypoint = toWaypoint;
+	}
+
+	/** The log status of the travelbug drop transaction */
+	public void setToLogged(String toLogged) {
+		this.toLogged = Convert.toBoolean(toLogged);
+	}
+
+	/** The log status of the travelbug drop transaction */
+	public void setToLogged(boolean toLogged) {
+		this.toLogged = toLogged;
+	}
+
+	/** The log status of the travelbug drop transaction */
+	public boolean getToLogged() {
+		return this.toLogged;
+	}
+	
+	/** True if both transactions (pick-up and drop) have been logged with GC. */
+	public boolean bothLogsDone() {
+		return this.toLogged &amp;&amp; this.fromLogged;
+	}
+	
+	/**
+	 * Returns true if the travelbug is currently in my posession, i.e. it has
+	 * a pick-up date but no drop date.
+	 * @return The status to the travelbug
+	 */public boolean inMyPosession() {
+		return !fromDate.equals(&quot;&quot;) &amp;&amp; toDate.equals(&quot;&quot;);
+	}
+
+	/** Returns an XML representation of a TravelbugJourney for storing in a file */
+	public String toXML(){
+		StringBuffer s=new StringBuffer(200);
+		s.append(&quot;  &lt;tbj&quot;);
+		appendElem(s,&quot;id&quot;,tb.getGuid(),false);
+		appendElem(s,&quot;trackingNo&quot;,tb.getTrackingNo(),false);
+		appendElem(s,&quot;fromProfile&quot;,fromProfile,true);
+		appendElem(s,&quot;fromWaypoint&quot;,fromWaypoint,false);
+		appendElem(s,&quot;fromDate&quot;,fromDate,false);
+		appendElem(s,&quot;fromLogged&quot;,(new Boolean(fromLogged)).toString(),false);
+		appendElem(s,&quot;toProfile&quot;,toProfile,true);
+		appendElem(s,&quot;toWaypoint&quot;,toWaypoint,false);
+		appendElem(s,&quot;toDate&quot;,toDate,false);
+		appendElem(s,&quot;toLogged&quot;,(new Boolean(toLogged)).toString(),false);
+		s.append(&quot;&gt;&lt;name&gt;&lt;![CDATA[&quot;);
+		s.append(tb.getName());
+		s.append(&quot;]]&gt;&lt;/name&gt;&lt;![CDATA[&quot;);
+		s.append(tb.getMission());
+		s.append(&quot;]]&gt;&lt;/tbj&gt;\n&quot;);
+		return s.toString();
+	}
+	
+	private void appendElem(StringBuffer s,String name,String value,boolean clean) {
+		s.append(&quot; &quot;);
+		s.append(name);
+		s.append(&quot;=\&quot;&quot;);
+		if (clean)
+			s.append(SafeXML.clean(value));
+		else
+			s.append(value);
+		s.append(&quot;\&quot;&quot;);
+	}
+	
+	/** Returns the current date-time in format YYYY-MM-DD HH:MM */
+	private String getDateTime() {
+		Time t=new Time();
+		return MyLocale.formatLong(t.year,&quot;0000&quot;)+&quot;-&quot;+MyLocale.formatLong(t.month,&quot;00&quot;)+&quot;-&quot;+
+		       MyLocale.formatLong(t.day,&quot;00&quot;)+&quot; &quot;+MyLocale.formatLong(t.hour,&quot;00&quot;)+&quot;:&quot;+MyLocale.formatLong(t.minute,&quot;00&quot;);
+	}
+	
+}

Added: trunk/src/CacheWolf/TravelbugJourneyList.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyList.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/TravelbugJourneyList.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,217 @@
+package CacheWolf;
+
+/**
+ * A list of @see TravelbugJourney s.
+ */
+import ewe.io.BufferedWriter;
+import ewe.io.File;
+import ewe.io.FileWriter;
+import ewe.io.PrintWriter;
+import ewe.util.*;
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+
+public class TravelbugJourneyList extends MinML {
+
+	/** The Vector holdin the travelbug journeys */
+	private Vector tbJourneyList=new Vector(10);
+	
+	/** Return a TravelbugJourney */
+	public TravelbugJourney getTBJourney(int i) {
+		return (TravelbugJourney) tbJourneyList.elementAt(i);
+	}
+	
+	/** Number of TravelbugJourneys in list */
+	public int size() {
+		return tbJourneyList.size();
+	}
+	
+	/** Clear the list */
+	public void clear() {
+		tbJourneyList.clear();
+	}
+
+	/** Add a TravelbugJourney to the list */
+	public void add(TravelbugJourney tb) {
+		tbJourneyList.add(tb);
+	}
+	
+	/** Remove an element of the list */
+	public void remove(int i) {
+		tbJourneyList.removeElementAt(i);
+	}
+
+	/** Add e Travelbug pick-up to the list (creating a new Journey) */
+	public void addTbPickup(Travelbug tb, String profile, String waypoint) {
+		tbJourneyList.add(new TravelbugJourney(tb,profile,waypoint));
+	}
+	
+	
+	/** Add a Travelbug drop to the list for a given Travelbug which must be in the
+	 * list
+	 */
+	public void addTbDrop(Travelbug tb,String profile, String waypoint) {
+		int i=findTB(tb);
+		if (i&gt;=0) {
+			getTBJourney(i).dropTravelbug(profile,waypoint);
+		}
+	}
+	
+	/** Find a travelbug in the list */
+	private int findTB(Travelbug tb) {
+		for (int i=size()-1; i&gt;=0; i--) {
+			if (tb.getName().equals(getTBJourney(i).getTb().getName())) return i;
+		}
+		return -1;
+	}
+	
+	/** Count the number of journeys where at least one log still needs to be done
+	 */
+	public int countNonLogged() {
+		int count=0;
+		for (int i=size()-1; i&gt;=0; i--)
+			if (!getTBJourney(i).bothLogsDone()) count++;
+		return count;
+	}
+	
+	TravelbugJourneyList() {}
+	
+	/**
+	 * Return a list of the travelbugs still in my possession
+	 * @return 
+	 */
+	public TravelbugList getMyTravelbugs() {
+		TravelbugList tbl=new TravelbugList();
+		int size=size();
+		for (int i=0; i&lt;size; i++) {
+			TravelbugJourney tbj=getTBJourney(i);
+			if (tbj.inMyPosession()) tbl.add(tbj.getTb());
+		}
+		return tbl;
+	}
+	
+	// Variables needed for reading the TB list
+	private String lastName;
+	private StringBuffer xmlElement=new StringBuffer(200);
+	private TravelbugJourney tbJ;
+	/**
+	 * Method to open and parse the travelbugs.xml file which contains the tavelbugs
+	 * which were picked up and dropped by us. 
+	 */
+	public boolean readTravelbugsFile(){
+		try{
+			String datei = Global.getPref().baseDir + &quot;/&quot; + &quot;travelbugs.xml&quot;;
+			datei = datei.replace('\\', '/');
+			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(datei));
+			parse(r);
+			r.close();
+		}catch(Exception e){
+			if (e instanceof NullPointerException)
+				Global.getPref().log(&quot;Error reading travelbugs.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+			else 
+				Global.getPref().log(&quot;Error reading travelbugs.xml: &quot;, e);
+			return false;
+		}
+		return true;
+	}
+	
+	/**
+	 * Method that gets called when a new element has been identified in travelbugs.xml
+	 */
+	public void startElement(String name, AttributeList atts){
+		//Vm.debug(&quot;name = &quot;+name);
+		lastName=name;
+		if (name.equals(&quot;tbj&quot;)) {
+			tbJ=new TravelbugJourney(
+				atts.getValue(&quot;id&quot;),
+				&quot;&quot;,
+				atts.getValue(&quot;trackingNo&quot;),
+				SafeXML.cleanback(atts.getValue(&quot;fromProfile&quot;)),
+				atts.getValue(&quot;fromWaypoint&quot;),
+				atts.getValue(&quot;fromDate&quot;),
+				atts.getValue(&quot;fromLogged&quot;),
+				SafeXML.cleanback(atts.getValue(&quot;toProfile&quot;)),
+				atts.getValue(&quot;toWaypoint&quot;),
+				atts.getValue(&quot;toDate&quot;),
+				atts.getValue(&quot;toLogged&quot;),
+				&quot;&quot;);
+		}
+	}
+
+	public void characters( char ch[], int start, int length ) {
+			xmlElement.append(ch,start,length); // Collect the mission
+	}	
+
+	public void endElement(String tag){
+		if (tag.equals(&quot;tbj&quot;)) {
+			tbJ.getTb().setMission(xmlElement.toString());
+			tbJourneyList.add(tbJ);
+			xmlElement.delete(0,xmlElement.length());
+		}
+		if (tag.equals(&quot;name&quot;)) {
+			tbJ.getTb().setName(xmlElement.toString());
+			xmlElement.delete(0,xmlElement.length());
+		}
+	}
+	
+	/**
+	 * Method to save current travelbugs in the travelbugs.xml file
+	 */
+	public void saveTravelbugsFile(){
+		String baseDir=Global.getPref().baseDir;
+		try {
+			File backup=new File(baseDir+&quot;travelbugs.bak&quot;);
+			if (backup.exists()) backup.delete();
+			File travelbugs=new File(baseDir+&quot;travelbugs.xml&quot;);
+			travelbugs.rename(&quot;travelbugs.bak&quot;);
+		} catch (Exception ex) {
+			Global.getPref().log(&quot;Error deleting backup or renaming travelbugs.xml&quot;);
+		}
+		String datei = baseDir + &quot;travelbugs.xml&quot;;
+		try{
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(datei)));
+			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot;);
+			outp.print(&quot;&lt;travelbugJourneys&gt;\n&quot;);	
+			int size=tbJourneyList.size();
+			for (int i=0; i&lt;size; i++) outp.print(((TravelbugJourney)tbJourneyList.elementAt(i)).toXML());
+			outp.print(&quot;&lt;/travelbugJourneys&gt;\n&quot;);	
+			outp.close();
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem saving: &quot; +datei,e,true);
+		}
+	}
+
+	/** Sort the list of travelbug journeys by any column */
+	public void sort(int column, boolean ascending) {
+		tbJourneyList.sort(new tbjComparer(column),ascending);
+	}
+
+	/** Sort only part of the travelbug journey list. This is used to sort the
+	 * non-logged journeys, which are at the start of the list
+	 * @param column Column to sort by @see TravelbugJourney
+	 * @param ascending Sort order
+	 * @param nElem Number of elements to sort
+	 */
+	public void sortFirstHalf(int column, boolean ascending,int nElem) {
+		Object[] no = new Object[nElem];
+		for (int i=0; i&lt;nElem; i++) no[i]=tbJourneyList.elementAt(i);
+		Utils.sort(null,no,new tbjComparer(column),ascending);
+		for (int i=0; i&lt;nElem; i++) tbJourneyList.set(i,no[i]);
+	}
+	
+	private class tbjComparer implements Comparer {
+		private int col;
+		tbjComparer(int column) {
+			col=column;
+		}
+		
+		public int compare(Object o1, Object o2){
+			Object oo1=((TravelbugJourney) o1).getElementByNumber(col);
+			Object oo2=((TravelbugJourney) o2).getElementByNumber(col);
+			return oo1.toString().compareTo(oo2.toString());
+		}
+	}
+
+	
+	
+}

Added: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,602 @@
+package CacheWolf;
+
+/**
+ * A list to manage the travelbugs. Each row represents one @see TravelbugJourney.
+ * The lower half of the screen which is separated from the top by a splitter bar,
+ * contains four tabs: One for the travelbug, one for the source (where the travelbug 
+ * was picked up), one for the destination (where the travelbug was dropped) and one
+ * for the mission. These tabs are used for inputting data about the travelbug journey.
+ * The travelbugs are read from file travelbugs.xml which is stored in the base directory.
+ * When the screen is closed, all data is written back to the file.
+ * @author salzkammergut
+ */
+
+import ewe.sys.Convert;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.*;
+import ewe.util.*;
+import ewe.fx.*;
+
+public class TravelbugJourneyScreen extends Form  {
+	
+	/** The list control */
+	private tbListControl tcTbJourneyList;
+	/** The list model */
+	private tbListTableModel modTbJourneyList;
+	/** The actual journeys */
+	private TravelbugJourneyList tblMyTravelbugJourneys;
+	/** The panel for the lower half of the screen */
+	private CellPanel lowerpane;
+	private mInput inpName,inpTrackingNo, 
+		   inpFromDate, inpFromProfile, inpFromWaypoint, 
+	       inpToDate, inpToProfile, inpToWaypoint;
+	private mLabel lblId;
+	private mButton btnFromDate,btnToDate;
+	private mCheckBox chkFromLogged, chkToLogged;
+	private HtmlDisplay txtMission;
+	private mTabbedPanel pnlTab;
+    /**	 List of TBs in the current cache */
+	private TravelbugList tblSrcCache; 
+	/** The currently selected row */
+	private int selectedRow=-1;
+	/** A label which holds the number of currently displayed travelbug journeys*/
+	private mLabel lblNumVisibleJourneys;
+	private final Color RED=new Color(255,0,0);
+	private int exitKeys[]={75009};
+	/** A flag to track whether the current cache has to be saved because a travelbug
+	 * was added to or taken from it.
+	 */
+	private boolean chDmodified=false;
+	
+	/** The current cache */
+	private CacheHolderDetail chD;
+	/** The base data of the current cache */
+	private CacheHolder ch;
+	/** The name of the current waypoint */
+	private String waypoint=&quot;&quot;;
+	
+	public TravelbugJourneyScreen() {
+		Vector cacheDB=Global.getProfile().cacheDB;
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+		CellPanel tablepane = split.getNextPanel();
+		int curCacheNo=Global.mainTab.tbP.getSelectedCache();
+		String cache=&quot;&quot;;
+		if (curCacheNo&lt;cacheDB.size()) {
+			ch=(CacheHolder)cacheDB.elementAt(curCacheNo);
+			cache=MyLocale.getMsg(6022,&quot;: Current cache: &quot;)+ch.wayPoint+&quot; - &quot;+ch.CacheName;
+			waypoint=ch.wayPoint;
+			chD=new CacheHolderDetail(ch);
+			try {
+				chD.readCache(Global.getProfile().dataDir);
+			}catch (Exception ex) {
+				Global.getPref().log(&quot;Failed to read cache &quot;+ch.wayPoint);
+			};
+			tblSrcCache=chD.Travelbugs;
+		}
+		title=&quot;Travelbugs&quot;+cache;
+		tcTbJourneyList=new tbListControl();
+		tcTbJourneyList.setTableModel(modTbJourneyList=new tbListTableModel());
+		tablepane.addLast(new ScrollBarPanel(tcTbJourneyList,ScrollBarPanel.AlwaysShowVerticalScrollers),STRETCH,FILL);
+	
+		lowerpane = split.getNextPanel();
+		
+		pnlTab=new mTabbedPanel();
+		pnlTab.extraControlsRight=lblNumVisibleJourneys=new mLabel(&quot;  0&quot;);
+		//------------------------------------------------
+		// First Tab - Name &amp; Tracking #
+		//------------------------------------------------
+		CellPanel pnlName=new CellPanel();
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6025,&quot;Name:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(inpName=new mInput(),HSTRETCH,HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6026,&quot;Tracking #:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(inpTrackingNo=new mInput(),HSTRETCH,HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6027,&quot;ID/GUID:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(lblId=new mLabel(&quot;&quot;),HSTRETCH,HFILL);
+		pnlTab.addCard(pnlName,MyLocale.getMsg(6028,&quot;Name&quot;),&quot;Name&quot;);
+		
+		//------------------------------------------------
+		// Second Tab - Where was the TB picked up from
+		//------------------------------------------------
+		CellPanel pnlFrom=new CellPanel();
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(inpFromProfile=new mInput(),HSTRETCH,HFILL);
+		pnlFrom.addLast(inpFromWaypoint=new mInput(),HSTRETCH,HFILL);
+		
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030,&quot;Date found:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(inpFromDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate=new mButton(new mImage(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		btnFromDate.modify(0,ControlConstants.TakesKeyFocus);
+		
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addLast(chkFromLogged=new mCheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
+		chkFromLogged.exitKeys=exitKeys;
+		pnlFrom.addLast(new mLabel(&quot;&quot;));
+		
+		pnlTab.addCard(pnlFrom,MyLocale.getMsg(6032,&quot;From&quot;),&quot;From&quot;);
+
+		//------------------------------------------------
+		// Third Tab - Where was the TB dropped
+		//------------------------------------------------
+		CellPanel pnlTo=new CellPanel();
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addNext(inpToProfile=new mInput(),HSTRETCH,HFILL);
+		pnlTo.addLast(inpToWaypoint=new mInput(),HSTRETCH,HFILL);
+		
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033,&quot;Date dropped:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addNext(inpToDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		//inpToDate.modifyAll(DisplayOnly,0);
+		pnlTo.addLast(btnToDate=new mButton(new mImage(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		btnToDate.modify(0,ControlConstants.TakesKeyFocus);
+		//pnlTo.addLast(new mLabel(&quot;&quot;));
+		
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addLast(chkToLogged=new mCheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
+		chkToLogged.exitKeys=exitKeys;
+		pnlTo.addLast(new mLabel(&quot;&quot;));
+		
+		pnlTab.addCard(pnlTo,MyLocale.getMsg(6034,&quot;To&quot;),&quot;To&quot;);
+		
+		//------------------------------------------------
+		// Last Panel - TB Mission
+		//------------------------------------------------
+		CellPanel pnlDest=new CellPanel();
+		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035,&quot;Mission:&quot;)));
+		pnlDest.addLast(txtMission=new HtmlDisplay(),STRETCH,FILL);
+		txtMission.rows=3;
+		pnlTab.addCard(pnlDest,MyLocale.getMsg(6036,&quot;Mission&quot;),&quot;Mission&quot;);
+
+		
+		lowerpane.addLast(pnlTab,STRETCH,FILL);
+		
+		
+		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
+		addLast(split,STRETCH,FILL);
+		//setPreferredSize(MyLocale.getScreenWidth()&lt;=240?240:MyLocale.getScreenWidth()*2/3,240);
+		
+		tblMyTravelbugJourneys=new TravelbugJourneyList();
+		tblMyTravelbugJourneys.readTravelbugsFile();
+		modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		// Get the columns to display and their widths from preferences
+		modTbJourneyList.columnMap=
+			TableColumnChooser.str2Array(Global.getPref().travelbugColMap,0,11,0);
+		modTbJourneyList.colWidth=
+			TableColumnChooser.str2Array(Global.getPref().travelbugColWidth,10,1024,50);
+		modTbJourneyList.numCols=modTbJourneyList.columnMap.length;
+		
+		modTbJourneyList.select(0,12,true);
+		/* Restore the saved setting about showing only non-logged bugs */
+		if (Global.getPref().travelbugShowOnlyNonLogged) {
+			tcTbJourneyList.toggleNonLogged();
+		}
+		updateNumBugs();
+	}
+	
+	/** Indicate the number of journeys currently displayed */
+	private void updateNumBugs() {
+		lblNumVisibleJourneys.setText(&quot;&quot;+modTbJourneyList.numRows);
+		lblNumVisibleJourneys.repaint();
+	}
+	
+	/** The control which had the last focus */
+	private Control currentControl;
+	
+	public void onEvent(Event ev){
+		// Update the table from the input form  
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) &amp;&amp; selectedRow!=-1 &amp;&amp;
+				selectedRow&lt;tblMyTravelbugJourneys.size()){
+			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			if (currentControl==inpName) 			tbj.getTb().setName(inpName.getText());
+			else if (currentControl==inpTrackingNo)  tbj.getTb().setTrackingNo(inpTrackingNo.getText());
+			else if (currentControl==inpFromProfile) tbj.setFromProfile(inpFromProfile.getText());
+			else if (currentControl==inpFromWaypoint)tbj.setFromWaypoint(inpFromWaypoint.getText());
+			else if (currentControl==inpFromDate)    tbj.setFromDate(inpFromDate.getText());
+			else if (currentControl==chkFromLogged)  tbj.setFromLogged(chkFromLogged.state);
+			else if (currentControl==inpToProfile)   tbj.setToProfile(inpToProfile.getText());
+			else if (currentControl==inpToWaypoint)  tbj.setToWaypoint(inpToWaypoint.getText());
+			else if (currentControl==inpToDate)      tbj.setToDate(inpToDate.getText());
+			else if (currentControl==chkToLogged)    tbj.setToLogged(chkToLogged.state);
+			//else if (ev.target==txtMission)     tb.setMission(txtMission.getText());
+			tcTbJourneyList.repaint();
+		}
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED &amp;&amp; selectedRow!=-1){
+			if (ev.target==inpTrackingNo) {pnlTab.selectNextTab(true,true); Gui.takeFocus(inpFromProfile,Control.ByKeyboard);pnlTab.repaint(); }
+			if (ev.target==inpFromDate) Gui.takeFocus(chkFromLogged,Control.ByKeyboard);
+			if (ev.target==inpToDate) Gui.takeFocus(chkToLogged,Control.ByKeyboard);
+			if (ev.target==btnFromDate || ev.target==btnToDate) {
+				mInput inpDate=ev.target==btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale());
+				dc.title=MyLocale.getMsg(328,&quot;Date found&quot;); 
+				dc.setPreferredSize(240,240);
+				String foundDate=inpDate.getText();
+				Time t=new Time();
+				try {
+					t.parse(foundDate,&quot;y-M-d H:m&quot;);
+				} catch(IllegalArgumentException e) {
+					try {
+						t.parse(foundDate,&quot;y-M-d&quot;);
+					} catch(IllegalArgumentException e1) {}
+				};
+				dc.reset(t);
+				if (dc.execute()==ewe.ui.FormBase.IDOK) {
+				  inpDate.setText(Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;)+&quot; &quot;+dc.time);
+				  if (ev.target==btnFromDate){ 
+					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
+					  Gui.takeFocus(chkFromLogged,Control.ByKeyboard);
+				  } else {
+					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
+					  Gui.takeFocus(chkToLogged,Control.ByKeyboard);
+				  } tcTbJourneyList.repaint();
+				}				
+			}
+		}
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED){
+			pnlTab.selectNextTab(true,true); 
+			if (ev.target==chkFromLogged) Gui.takeFocus(inpToProfile,Control.ByKeyboard);
+			if (ev.target==chkToLogged) Gui.takeFocus(txtMission,Control.ByKeyboard);
+		}
+		// The user closed the travelbugs screen
+		if (ev instanceof FormEvent &amp;&amp; ev.type==FormEvent.CLOSED  &amp;&amp; chD!=null) {
+			tblMyTravelbugJourneys.saveTravelbugsFile();
+			tblMyTravelbugJourneys.clear();
+			// Save the flag about showing non-logged journeys only
+			boolean old=Global.getPref().travelbugShowOnlyNonLogged;
+			Global.getPref().travelbugShowOnlyNonLogged=(tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked;
+			String travelbugColWidth=modTbJourneyList.getColWidths();
+			// If the preferences changed, save the pref.xml file
+			Vm.showWait(true);
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) ||
+				old!=Global.getPref().travelbugShowOnlyNonLogged) {
+				Global.getPref().travelbugColWidth=travelbugColWidth;
+				Global.getPref().savePreferences();
+			}
+			// If the list of travelbugs in the cache was modified, we need to save the cache too
+			if (chDmodified) {
+				chD.saveCacheDetails(Global.getProfile().dataDir);
+				ch.has_bug=chD.Travelbugs.size()&gt;0;
+			}
+			Vm.showWait(false);
+			chD=null;
+		}
+		updateNumBugs();
+		currentControl=Gui.focusedControl();
+	}
+	
+	
+//==============================================================
+// tbListTableModel
+//==============================================================
+class tbListTableModel extends TableModel {
+	private FontMetrics fm;
+	private Image imgRed;
+	tbListTableModel() {
+		
+		fillToEqualHeights=true;
+		allRowsSameSize=true;
+		hasRowHeaders=false;
+		//shadeAlternateRows=true;
+		cursorSize=new Dimension(12,1);
+		clipData=true;
+		fm=this.fm;
+		// A red dot indicates that the journey has not been completely logged
+		imgRed = new Image(&quot;red.png&quot;);
+	}
+    private int colWidth[];
+	private int columnMap[];
+	
+	public Object getCellText(int row, int col) {
+		return null;
+	}
+
+	public Object getCellData(int row, int col){
+		if(row == -1){
+			return TravelbugJourney.getElementNameByNumber(columnMap[col]);
+		} else {
+			int map=columnMap[col];
+			// If we have not yet logged the from or the to, a red dot is placed in front of the first item
+			if (col==0 &amp;&amp; (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() ||
+				!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) { 
+				// Is it a column with a checkbox?
+				if (map!=7 &amp;&amp; map!=11) 
+					return new IconAndText((IImage)imgRed,(String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map),fm);
+				else { // Checkbox - special treatment
+					IconAndText iat=new IconAndText((IImage)imgRed,&quot;&quot;,fm);
+					iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+					return iat;
+				}
+			} else 
+				return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
+		}	
+	}
+	public int calculateRowHeight(int row) {
+		return charHeight+2;
+	}
+	
+	public int calculateColWidth(int col){
+		if(col == -1) 
+        	return 0;
+        else if (col&lt;numCols)
+        	return colWidth[columnMap[col]];
+        else return 0;
+	}
+	
+	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
+		ta=super.getCellAttributes(row,col,isSelected,ta);
+		ta.alignment = ta.LEFT;
+		ta.anchor = ta.LEFT;
+		// Color the elements red, if we have not yet logged
+		if (row&gt;=0)
+		switch (columnMap[col]) {
+		case 6: // fromDate
+				if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged()) ta.foreground=RED;
+				break;
+		case 10: // toDate
+				if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged()) ta.foreground=RED;
+				break;
+		}
+		return ta;
+	}
+
+	private void showFields(TravelbugJourney tbj) {
+	   	inpName.setText(tbj.getTb().getName());
+		inpTrackingNo.setText(tbj.getTb().getTrackingNo());
+		lblId.setText(tbj.getTb().getGuid());
+		inpFromProfile.setText(tbj.getFromProfile());
+		inpFromWaypoint.setText(tbj.getFromWaypoint());
+		inpFromDate.setText(tbj.getFromDate());
+		chkFromLogged.setState(tbj.getFromLogged());
+		inpToProfile.setText(tbj.getToProfile());
+		inpToWaypoint.setText(tbj.getToWaypoint());
+		inpToDate.setText(tbj.getToDate());
+		chkToLogged.setState(tbj.getToLogged());
+		txtMission.setHtml(tbj.getTb().getMission());
+	}
+	
+	private boolean sortAsc=false;
+	private int sortedBy = -1;
+	private int lastRow=-1;
+	public int penEventModifiers; 
+
+	public boolean penPressed(Point onTable,Point cell){
+		boolean retval=false;
+		if(cell!=null &amp;&amp; cell.y == -1){ // Hit a header =&gt; sort the table accordingly
+			Vm.showWait(true);
+			if (cell.x == sortedBy) sortAsc=!sortAsc;
+			else sortAsc = false;
+			sortedBy = cell.x;
+			// Check whether the list only shows non-logged journeys. If so, a subset
+			// of the table must be sorted
+			if ((tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+				tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc,modTbJourneyList.numRows);
+			} else { // Showing all journeys - sort the full table
+				tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+			}
+			tcTbJourneyList.repaint();
+			Vm.showWait(false);
+			retval = true;
+		} else if (cell!=null &amp;&amp; cell.y&gt;=0 &amp;&amp; (penEventModifiers &amp; IKeys.SHIFT)&gt;0) {
+			// A range of rows can be marked by shift-click on the first and last row
+			if (lastRow!=-1) { // Second row being marked with shift key pressed
+				if (lastRow&lt;cell.y)
+					toggleSelect(lastRow,cell.y);
+				else
+					toggleSelect(cell.y,lastRow);
+				lastRow=-1;
+				retval=true;
+			} else { // Remember this row as start of range, but don't toggle yet
+				lastRow=cell.y;
+			}
+		} else { // Single row marked
+			lastRow=-1;
+		}
+		return retval;
+	}
+
+	/** Select a range of rows */
+	private void toggleSelect(int fromRow, int toRow) {
+		tcTbJourneyList.clearSelection(null);
+		tcTbJourneyList.addToSelection(new Rect(0,fromRow,numCols,toRow-fromRow+1),false,true);
+	}
+	
+	/**
+	 * Return the column widths as a comma delimited string for storing in the preferences
+	 * @return
+	 */
+	private String getColWidths() {
+		// Update the list with the current widths
+		for (int col=0; col&lt;numCols; col++) {
+			colWidth[columnMap[col]]=getColWidth(col);
+		}
+		// Convert to string
+		StringBuffer sb=new StringBuffer(40);
+		for (int i=0; i&lt;colWidth.length; i++) {
+			if (sb.length()!=0) sb.append(',');
+			sb.append(colWidth[i]);
+		}
+		return sb.toString();
+	}
+}
+
+//==============================================================
+//tbListControl
+//==============================================================
+class tbListControl extends TableControl {
+	private MenuItem mnuNewTB, mnuDeleteTB,mnuGetMission,mnuOpenOnline,mnuDropTB,mnuPickupTB,mnuDeleteTBs;
+	public MenuItem mnuToggleList;
+	private Menu mnuFullMenu,mnuDeleteMenu;
+	
+	tbListControl() {
+		MenuItem[] TBMenuItems=new MenuItem[10];
+		TBMenuItems[0]= mnuPickupTB = new MenuItem(MyLocale.getMsg(6040,&quot;Pick up TB from current cache&quot;));
+		TBMenuItems[1]= mnuDropTB = new MenuItem(MyLocale.getMsg(6041,&quot;Drop TB in cache&quot;));
+		TBMenuItems[2]= new MenuItem(&quot;-&quot;);
+		TBMenuItems[3]= mnuNewTB = new MenuItem(MyLocale.getMsg(6042,&quot;New Travelbug&quot;));
+		TBMenuItems[4]= mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043,&quot;Delete Travelbug&quot;));
+		TBMenuItems[5]= new MenuItem(&quot;-&quot;);
+		TBMenuItems[6]= mnuGetMission = new MenuItem(MyLocale.getMsg(6044,&quot;Get Mission&quot;));
+		TBMenuItems[7]= mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045,&quot;Open on-line&quot;));
+		TBMenuItems[8]= new MenuItem(&quot;-&quot;);
+		TBMenuItems[9]= mnuToggleList = new MenuItem(MyLocale.getMsg(6046,&quot;Show only not logged&quot;));
+		mnuFullMenu=new Menu(TBMenuItems,&quot;&quot;);
+		// A second pop-up menu with only one entry, if a range of rows is selected
+		MenuItem[] TBMenuItemsDel=new MenuItem[1];
+		TBMenuItemsDel[0]=mnuDeleteTBs=new MenuItem(MyLocale.getMsg(6047,&quot;Delete selected Travelbugs&quot;));
+		mnuDeleteMenu=new Menu(TBMenuItemsDel,&quot;&quot;);
+		mnuDropTB.modifiers|=MenuItem.Disabled;
+		mnuDeleteTB.modifiers|=MenuItem.Disabled;
+		mnuGetMission.modifiers|=MenuItem.Disabled;
+		mnuOpenOnline.modifiers|=MenuItem.Disabled;
+	}
+	
+	public void onEvent(Event ev) {
+		Rect sel=getSelection(null);
+		if (sel.y&lt;tblMyTravelbugJourneys.size()) {
+			mnuDeleteTB.modifiers&amp;=~MenuItem.Disabled;
+			mnuGetMission.modifiers&amp;=~MenuItem.Disabled;
+			mnuOpenOnline.modifiers&amp;=~MenuItem.Disabled;
+			if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession()) 
+				mnuDropTB.modifiers&amp;=~MenuItem.Disabled;
+			else
+				mnuDropTB.modifiers|=MenuItem.Disabled;
+		} else {
+			mnuDeleteTB.modifiers|=MenuItem.Disabled;
+			mnuGetMission.modifiers|=MenuItem.Disabled;
+			mnuOpenOnline.modifiers|=MenuItem.Disabled;
+		}
+		// If more than one row is selected, show the limited pop-up menu
+		if (sel.height&gt;1)
+			setMenu(mnuDeleteMenu);
+		else
+			setMenu(mnuFullMenu);
+	    if (ev instanceof PenEvent) modTbJourneyList.penEventModifiers=((PenEvent)ev).modifiers;
+		super.onEvent(ev);
+	}
+
+	public void penRightReleased(Point p){
+		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+	}
+
+	public void penHeld(Point p){
+		menuState.doShowMenu(p,true,null); 
+	}
+
+	public void popupMenuEvent(Object selectedItem){
+		if (selectedItem==mnuPickupTB) {
+			Travelbug tb=TravelbugPickup.pickupTravelbug(tblSrcCache);	
+			if (tb!=null) {
+				chDmodified=true;
+				tblMyTravelbugJourneys.addTbPickup(tb,Global.getProfile().name,waypoint);
+				modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+				tcTbJourneyList.repaint();
+			}
+		}
+		if (selectedItem==mnuDropTB) {
+			if (selectedRow&gt;=0 &amp;&amp; selectedRow&lt;modTbJourneyList.numRows) {
+				Travelbug tb=tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
+				chD.Travelbugs.add(tb);
+				tblMyTravelbugJourneys.addTbDrop(tb,Global.getProfile().name,waypoint);
+				chDmodified=true;
+				ch.has_bug=true;
+			}
+			repaint();
+		}
+		if (selectedItem==mnuNewTB) {
+			TravelbugJourney tbj=new TravelbugJourney(&quot;New&quot;);
+			tbj.setFromProfile(Global.getProfile().name);
+			tbj.setFromWaypoint(waypoint);
+			tblMyTravelbugJourneys.add(tbj);
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+			cursorTo(tblMyTravelbugJourneys.size()-1,1,true);
+			tcTbJourneyList.repaint();
+		}
+		if (selectedItem==mnuDeleteTB &amp;&amp; selectedRow&gt;=0) {
+			tblMyTravelbugJourneys.remove(selectedRow);
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+			if (selectedRow&gt;0) 
+				cursorTo(selectedRow-1,0,true);
+			else
+				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+			tcTbJourneyList.repaint();
+		}
+		/* Delete a group of travelbugs which have been marked with Shift-Click */
+		if (selectedItem==mnuDeleteTBs) {  
+			Rect sel=getSelection(null);
+			for (int i=0; i&lt;sel.height; i++)
+				tblMyTravelbugJourneys.remove(sel.y);
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+			if (sel.y&lt;modTbJourneyList.numRows) 
+				cursorTo(sel.y,0,true);
+			else
+				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+			tcTbJourneyList.repaint();
+		}
+		if (selectedItem==mnuGetMission &amp;&amp; selectedRow&gt;-1) {
+			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
+			Vm.showWait(true);
+			// First check whether ID is set, if not get it
+			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+			// If we have an ID, we can get the mission
+			if (tbj.getTb().getGuid().length()!=0) 
+				tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+			Vm.showWait(false);
+			tcTbJourneyList.repaint();
+			txtMission.setHtml(tbj.getTb().getMission());
+			lblId.setText(tbj.getTb().getGuid());
+			lowerpane.repaint();
+		}
+		if (selectedItem==mnuOpenOnline &amp;&amp; selectedRow&gt;=0) {
+			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
+			Vm.showWait(true);
+			// First check whether ID is set, if not get it
+			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+			if (tbj.getTb().getGuid().length()!=0) {
+				Vm.showWait(false);
+				try {
+					String s;
+					if (tbj.getTb().getGuid().length()&gt;10)
+						s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot;+tbj.getTb().getGuid()+&quot;\&quot;&quot;;
+					else
+						s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot;+tbj.getTb().getGuid()+&quot;\&quot;&quot;;
+									
+					Vm.exec(s);
+					Global.getPref().log(&quot;Executing: &quot;+s); 
+				} catch (Exception ioex) {
+				}
+			}
+		}
+		if (selectedItem==mnuToggleList) {
+			toggleNonLogged();
+		}
+		updateNumBugs();
+	}
+	
+	/** Toggle between displaying all journeys or just those which still need to be logged */
+	public void toggleNonLogged() {
+		mnuToggleList.modifiers^=MenuItem.Checked;
+		if ((mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+			// First sort the non-logged items to the top
+			tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
+			// 		modListTable.numRows=tblMyTravelbugJourneys.size();
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.countNonLogged();
+		} else {
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		}
+		tcTbJourneyList.repaint();
+	}
+	
+	
+	public void cursorTo(int row,int col,boolean selectNew) {
+		TravelbugJourney tbj;
+		super.cursorTo(row,col,selectNew);
+		selectedRow=row;
+		if (row&gt;=0) { 
+			modTbJourneyList.showFields(tbj=tblMyTravelbugJourneys.getTBJourney(row));
+		} else {
+			modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+		}
+	}
+}
+
+}

Added: trunk/src/CacheWolf/TravelbugList.java
===================================================================
--- trunk/src/CacheWolf/TravelbugList.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/TravelbugList.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,143 @@
+package CacheWolf;
+/**
+ * A list of GC travelbugs
+ * @author salzkammergut
+ */
+import ewe.util.Vector;
+import ewe.io.*;
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+
+public class TravelbugList extends MinML{
+
+	/** The Vector containing the Travelbug objects */
+	private Vector tbList=new Vector(10);
+	
+	/** Get the travelbug at a certain position in the list */
+	public Travelbug getTB(int i) {
+		return (Travelbug) tbList.elementAt(i);
+	}
+	
+	/** Return the size of the list */
+	public int size() {
+		return tbList.size();
+	}
+	
+	/** Clear the travelbug list */
+	public void clear() {
+		tbList.clear();
+	}
+
+	/** Add a travelbug to the list */
+	public void add(Travelbug tb) {
+		tbList.add(tb);
+	}
+	
+	/** Trmove a travelbug from the list */
+	public void remove(int i) {
+		tbList.removeElementAt(i);
+	}
+	
+	/** Construct an empty travelbug list */
+	public TravelbugList() {
+	}
+	
+	/** Convert the old representation to a new one. In the old representation,
+	 * all travelbugs were stored as one HTML string within the cache.xml file.
+	 * This representation does not include the id or guid and does not allow for
+	 * unique identification of the travelbug (Several travelbugs with identical
+	 * names may exist, so the id/guid must be stored to uniquely identify the travelbug. 
+	 * All TBs are stored as one HTML string &lt;b&gt;Name:&lt;/b&gt;name_of_tb&lt;br&gt;mission&lt;hr&gt;
+	 */
+	public void addFromHTML(String htmlList) {
+		int fnd;
+		fnd=htmlList.indexOf(&quot;&lt;b&gt;Name:&lt;/b&gt;&quot;);
+		while(fnd&gt;=0) {
+			int fnd2=htmlList.indexOf(&quot;&lt;br&gt;&quot;,fnd+12);
+			int fnd3=htmlList.indexOf(&quot;&lt;b&gt;Name:&lt;/b&gt;&quot;,fnd2+4);
+			Travelbug tb=new Travelbug(htmlList.substring(fnd+12,fnd2));
+			String mission;
+			if (fnd3&gt;0) {
+				mission=htmlList.substring(fnd2+4,fnd3);
+			} else {
+				mission=htmlList.substring(fnd2+4);
+			}
+			if (mission.endsWith(&quot;&lt;hr&gt;&quot;)) mission=mission.substring(0,mission.length()-4);
+			tb.setMission(mission);
+			tbList.add(tb);
+			fnd=fnd3;
+		}
+	}
+	
+	/** Return list of travelbugs in HTML representation */
+	public String toHtml() {
+		int size=tbList.size();
+		StringBuffer s=new StringBuffer(size*300);
+		for (int i=0; i&lt;size; i++) {
+			s.append(getTB(i).toHtml());
+		}
+		return s.toString();
+	}
+
+	/** Return list of travelbugs in XML representation */
+	public String toXML() {
+		int size=tbList.size();
+		StringBuffer s=new StringBuffer(size*300);
+		s.append(&quot;&lt;TRAVELBUGS&gt;\n&quot;);
+		for (int i=0; i&lt;size; i++) {
+			s.append(getTB(i).toXML());
+		}
+		s.append(&quot;&lt;/TRAVELBUGS&gt;\n&quot;);
+		return s.toString();
+	}
+	
+	/*=====================================================================
+	 * The following section implements the XML parser for a travelbug list
+       as contained in the cache.xml file 
+      =====================================================================*/ 	    
+	private String lastName=&quot;&quot;;
+	private Travelbug tb;
+	private StringBuffer xmlElement=new StringBuffer(200);
+	
+	/** 
+	 * Parse the travelbug part of a cache. The XML String passed as an argument
+	 * must contain the enclosing &lt;TRAVELBUGS&gt; ... &lt;/TRAVELBUGS&gt; XML tags. 
+	 */
+	public void addFromXML(String XMLString) {
+		try {
+			parse(new StringReader(XMLString));
+		} catch (Exception e) {
+			if (e instanceof NullPointerException)
+				Global.getPref().log(&quot;Error reading cache-travelbug list: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+			else 
+				Global.getPref().log(&quot;Error reading cache-travelbug list: &quot;, e);
+		};
+	}
+	
+	/**
+	 * Method that gets called when a new element has been identified
+	 */
+	public void startElement(String name, AttributeList atts){
+		lastName=name;
+		if (name.equals(&quot;tb&quot;)) {
+			tb=new Travelbug(atts.getValue(&quot;guid&quot;),&quot;&quot;,&quot;&quot;);
+		}
+	}
+
+	public void characters( char ch[], int start, int length ) {
+			xmlElement.append(ch,start,length); // Collect the mission or the name
+	}	
+
+	public void endElement(String tag){
+		if (tag.equals(&quot;tb&quot;)) {
+			tb.setMission(xmlElement.toString());
+			tbList.add(tb);
+			xmlElement.delete(0,xmlElement.length());
+		}
+		if (tag.equals(&quot;name&quot;)) {
+			tb.setName(xmlElement.toString());
+			xmlElement.delete(0,xmlElement.length());
+		}
+	}
+
+}

Added: trunk/src/CacheWolf/TravelbugPickup.java
===================================================================
--- trunk/src/CacheWolf/TravelbugPickup.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/TravelbugPickup.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,36 @@
+package CacheWolf;
+
+import ewe.ui.InputBox;
+
+public class TravelbugPickup {
+
+	/**
+	 * Choose a travelbug from those listed in the travelbug list and delete it, if
+	 * the operation was not cancelled.
+	 * @param tbl List of travelbugs from where a bug is picked up
+	 */
+	public static Travelbug pickupTravelbug(TravelbugList tbl) {
+		Travelbug tb=null;
+		TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,&quot;Pick up travelbug&quot;),true);
+		tbs.execute(); // Select TB to pick up
+		if (tbs.selectedItem&gt;=0) { // Was a TB selected ?
+			// If the returned item is bigger than number of bugs in cache
+			// we have found a new unlisted bug. 
+			if (tbs.selectedItem==tbl.size()) {
+				InputBox ibox=new InputBox(MyLocale.getMsg(6018,&quot;Travelbug name&quot;));
+				String name=ibox.input(&quot;&quot;,240);
+				if (name==null) return null; // No name given
+				tb=new Travelbug(name);
+			} else { // A bug in the list was chosen
+				tb=tbl.getTB(tbs.selectedItem);
+				// Remove the tb from the list
+				tbl.remove(tbs.selectedItem);
+			}
+			InputBox ibox=new InputBox(MyLocale.getMsg(6019,&quot;Tracking number&quot;));
+			String trackingNo=ibox.input(&quot;&quot;,240);
+			if (trackingNo==null) trackingNo=&quot;&quot;;
+			tb.setTrackingNo(trackingNo);
+		}
+		return tb;
+	}
+}

Added: trunk/src/CacheWolf/TravelbugScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugScreen.java	2007-08-26 12:22:01 UTC (rev 833)
+++ trunk/src/CacheWolf/TravelbugScreen.java	2007-08-26 12:43:34 UTC (rev 834)
@@ -0,0 +1,76 @@
+package CacheWolf;
+
+import ewe.ui.*;
+
+/**
+ * Choose a travelbug to pick up or drop
+ * @author salzkammergut
+ */ 
+public class TravelbugScreen extends Form {
+	private myList disp;
+	private mButton btCancel,btAccept;
+	/** The index into the list of travelbugs indicating the selected bug */
+	public int selectedItem=-1;
+	
+	/**
+	 * A screen to choose a travelbug from a list of bugs
+	 * @param tbl The list of travelbugs from which to choose
+	 * @param title The title of the screen
+	 * @param allowNew True if a travelbug not on the list can be selected
+	 */
+	TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
+		this.setTitle(title);
+		this.setPreferredSize(240, -1);
+		disp=new myList(tbl,allowNew);
+		ScrollBarPanel sbp = new ScrollBarPanel(disp, ScrollBarPanel.NeverShowHorizontalScrollers);
+		this.addLast(sbp);
+		this.addNext(btCancel = new mButton(MyLocale.getMsg(614,&quot;Cancel&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(btAccept = new mButton(&quot;OK&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		btAccept.modify(Disabled,0);
+	}
+
+	public void onEvent(Event ev){
+        if (ev instanceof ListEvent &amp;&amp; ev.type==ListEvent.SELECTED) {
+        	btAccept.modify(0,Disabled);
+        	btAccept.repaint();
+        }
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btCancel){
+				this.close(0);
+			}
+			if (ev.target == btAccept){
+				this.close(0);
+				selectedItem=disp.getSelectedIndex(0);
+			}
+		}
+	}
+
+	private class myList extends SimpleList {
+		private TravelbugList tbl;
+		private boolean allowNew;
+		private int size; 
+		myList(TravelbugList tbl,boolean allowNew) {
+			this.tbl=tbl;
+			this.size=tbl.size();
+			this.allowNew=allowNew;
+		}
+		
+		public Object getObjectAt(int idx) {
+			return getDisplayItem(idx);		
+		}
+		public int getItemCount() {
+			return tbl.size()+ (allowNew?1:0);
+		}
+		public String getDisplayItem(int idx) {
+			if (idx==size)
+				return MyLocale.getMsg(6015,&quot;*** OTHER ***&quot;);
+			else if (tbl.getTB(idx).getName().indexOf(&quot;&amp;#&quot;)&lt;0)
+				return tbl.getTB(idx).getName();
+			else // If the name contains HTML entities, we need to convert it back
+				return SafeXML.cleanback(tbl.getTB(idx).getName());
+		}
+	}
+
+
+
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000723.html">[Cachewolf-svn] r833 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="000725.html">[Cachewolf-svn] r835 - in trunk: resources src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#724">[ date ]</a>
              <a href="thread.html#724">[ thread ]</a>
              <a href="subject.html#724">[ subject ]</a>
              <a href="author.html#724">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
