From bilbowolf at mail.berlios.de  Wed Jan  3 08:34:58 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 3 Jan 2007 08:34:58 +0100
Subject: [Cachewolf-svn] r339 - trunk/src/CacheWolf
Message-ID: <200701030734.l037YwAr003144@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-03 08:34:56 +0100 (Wed, 03 Jan 2007)
New Revision: 339

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
Status "Found" wird nun beim spidern gesetzt.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2006-12-30 14:56:41 UTC (rev 338)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-03 07:34:56 UTC (rev 339)
@@ -703,7 +703,10 @@
 			//Vm.debug("--------------------------------------------");
 			icon = exIcon.findNext();
 			name = exName.findNext();
-			if(icon.equals("icon_smile.gif") && name.equals(pref.myAlias)) ch.is_found = true;
+			if(icon.equals("icon_smile.gif") && name.equals(pref.myAlias)) {
+				ch.is_found = true;
+				ch.CacheStatus = MyLocale.getMsg(318,"Found");
+			}
 			reslts.add("<img src='"+ icon +"'>&nbsp;" + exDate.findNext()+ " " + name + exLog.findNext());
 			
 			singleLog = exSingleLog.findNext();



From admin at berlios.de  Wed Jan  3 08:37:07 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 3 Jan 2007 08:37:07 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9843] Filter funktioniert nicht
Message-ID: <200701030737.l037b7jL003217@unicorn.berlios.de>

Bug #9843, was updated on 2006-Dec-30 20:56
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: Invalid
Bug Group: None
Priority: 9
Submitted by: cw-tester
Assigned to : none
Summary: Filter funktioniert nicht

Details: Egal was ich filtern m?chte. Es werden immer alle gefiltert oder keiner.

Follow-Ups:

Date: 2007-Jan-03 08:37
By: bilbowolf

Comment:
mache ich wieder zu, da ich gerade am umbauen des filter bin. Habe dies in dern release notes auch geschrieben. siehe n?chste BE
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9843&group_id=2211


From admin at berlios.de  Wed Jan  3 08:37:20 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 3 Jan 2007 08:37:20 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9843] Filter funktioniert nicht
Message-ID: <200701030737.l037bK7p003239@unicorn.berlios.de>

Bug #9843, was updated on 2006-Dec-30 20:56
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Closed
Resolution: Invalid
Bug Group: None
Priority: 9
Submitted by: cw-tester
Assigned to : none
Summary: Filter funktioniert nicht

Details: Egal was ich filtern m?chte. Es werden immer alle gefiltert oder keiner.

Follow-Ups:

Date: 2007-Jan-03 08:37
By: bilbowolf

Comment:
mache ich wieder zu, da ich gerade am umbauen des filter bin. Habe dies in dern release notes auch geschrieben. siehe n?chste BE
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9843&group_id=2211


From admin at berlios.de  Wed Jan  3 08:38:44 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 3 Jan 2007 08:38:44 +0100 (CET)
Subject: [Feature #2954] Cache löschen
Message-ID: <200701030738.l037ci8I003268@unicorn.berlios.de>

Feature Request #2954, was updated on 2006-Dec-06 15:55
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2954&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Cache l?schen

By: bilbowolf
Date: 2007-Jan-03 08:38

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

wurde von? erledigt. Danke!

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Dec-06 15:55

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

aus dem Detailschirm herausnehmen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2954&group_id=2211


From admin at berlios.de  Wed Jan  3 17:07:37 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 3 Jan 2007 17:07:37 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2924] Anzeige der GotoPosition in
	MovingMap
Message-ID: <200701031607.l03G7b2R002371@unicorn.berlios.de>

Feature Request #2924, was updated on 2006-Dec-02 03:18
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2924&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: Anzeige der GotoPosition in MovingMap

By: albsucher
Date: 2007-Jan-03 17:07

Message:
Logged In: YES 
user_id=26380
Browser: Mozilla/5.0 (X11; U; Linux i686; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

Also ganz ehrlich ich hab die MM noch nie benutzt und w?sste
jetzt auch nicht was genau ich da testen soll???
Sorry...

----------------------------------------------------------------------

By: pfeffer
Date: 2006-Dec-02 03:18

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

Anzeige der GotoPosition in MovingMap

ist erledigt, bitte testen

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2924&group_id=2211


From kalli at mail.berlios.de  Thu Jan  4 10:49:38 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Thu, 4 Jan 2007 10:49:38 +0100
Subject: [Cachewolf-svn] r340 - trunk/src/CacheWolf
Message-ID: <200701040949.l049nc02015146@sheep.berlios.de>

Author: kalli
Date: 2007-01-04 10:49:35 +0100 (Thu, 04 Jan 2007)
New Revision: 340

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Feature 002997: Filter fuer addi wpts

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-03 07:34:56 UTC (rev 339)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-04 09:49:35 UTC (rev 340)
@@ -65,7 +65,14 @@
   public boolean is_HTML = true;
   public boolean is_Checked = false;
     
-  public CacheHolder update(CacheHolder newCh){
+  
+  /**
+ * Method to update an existing cache with new data. This is
+ * necessary to avoid missing old logs.
+ * @param newCh new cache data
+ * @return CacheHolder with updated data
+ */
+public CacheHolder update(CacheHolder newCh){
 	  // flags
 	  this.is_available = newCh.is_available;
 	  this.is_archived = newCh.is_archived;
@@ -154,7 +161,11 @@
  	return this;
   }
   
-  public void addUserImage(Profile profile){
+  /**
+   * Adds a user image to the cache data
+   * @param profile
+   */
+	public void addUserImage(Profile profile){
 	  File imgFile;
 	  String imgDesc, imgDestName;
 	  
@@ -176,6 +187,10 @@
 			saveCacheDetails(profile.dataDir);
 		}
   }
+  /**
+   * Adds a new log to the cachedata 
+   * @param logEntry
+   */
   public void addLog(String logEntry){
 	  //Logs
 	  //<img src='icon_smile.gif'>&nbsp;2005-10-30 by Schatzpirat</strong><br>
@@ -394,6 +409,22 @@
 		}
 	}
 	
+	/**
+	 * Method foch checking if to caches belongs to each other, e.g.
+	 * an additional waypoint belongs to the main cache.
+	 * Works currently only, if the last 4 or 5 chars of the waypoint are
+	 * the same, this is the gc.com way. 
+	 * @param ch cache to check
+	 * @return true if there is a relation, false otherwise
+	 */
+	public boolean belongsTo (CacheHolder ch) {
+		
+		// avoid self referencing
+		if (this.wayPoint.equals(ch.wayPoint)) return false;
+
+		return this.wayPoint.endsWith(ch.wayPoint.substring(2));
+	}
+	
   
   
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-03 07:34:56 UTC (rev 339)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-04 09:49:35 UTC (rev 340)
@@ -48,7 +48,7 @@
 		
 		addLast(new ScrollBarPanel(tc = new myTableControl()));
 		addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all"),MyLocale.getMsg(1017,"All add. wpts")},MyLocale.getMsg(1013,"With selection"));
+		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),MyLocale.getMsg(1018,"Sel. add. wpts."),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all"),MyLocale.getMsg(1017,"All add. wpts")},MyLocale.getMsg(1013,"With selection"));
 		tc.setMenu(m);
 		tc.profile=profile;
 		tc.db = cacheDB;

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-03 07:34:56 UTC (rev 339)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-04 09:49:35 UTC (rev 340)
@@ -52,6 +52,22 @@
 			}
 			tbp.refreshTable();
 		}
+
+		if (selectedItem.toString().equals(MyLocale.getMsg(1018,"Sel. add. wpts."))){
+			CacheHolder ch_addi;
+			for(int i = 0; i <	db.size(); i++){
+				ch = (CacheHolder)db.get(i);
+				if (ch.is_Checked && !CacheType.isAddiWpt(ch.type)){
+					// search addi wpts to main cache
+					for (int j = 0; j < db.size(); j++){
+						ch_addi = (CacheHolder)db.get(j);
+						if (ch_addi.belongsTo(ch))ch_addi.is_Checked = true;
+					}
+				}
+			}
+			tbp.refreshTable();
+		}
+
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1011,"Filter"))){
 			for(int i = 0; i <	db.size(); i++){



From kalli at mail.berlios.de  Thu Jan  4 10:51:16 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Thu, 4 Jan 2007 10:51:16 +0100
Subject: [Cachewolf-svn] r341 - trunk/resources
Message-ID: <200701040951.l049pGZK015288@sheep.berlios.de>

Author: kalli
Date: 2007-01-04 10:51:14 +0100 (Thu, 04 Jan 2007)
New Revision: 341

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Feature 002997: Filter fuer addi wpts

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-04 09:49:35 UTC (rev 340)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-04 09:51:14 UTC (rev 341)
@@ -162,6 +162,7 @@
 		1015=Alle w%e4hlen
 		1016=Alle abw%e4hlen
 		1017=Alle add. Wpts
+		1018=Sel. add. Wpts
 		1100=Profile
 		1101=Profil 1
 		1102=Profil 2
@@ -396,6 +397,7 @@
 		1015=Select all
 		1016=De-select all
 		1017=All add. wpts
+		1018=Sel. add. Wpts
 		1100=Profiles
 		1101=Profile 1
 		1102=Profile 2



From bilbowolf at mail.berlios.de  Thu Jan  4 17:25:28 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Thu, 4 Jan 2007 17:25:28 +0100
Subject: [Cachewolf-svn] r342 - in trunk: resources src/CacheWolf
Message-ID: <200701041625.l04GPSjw014450@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-04 17:25:25 +0100 (Thu, 04 Jan 2007)
New Revision: 342

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Zentrumsknopf nun im Pop-Up der Listenansicht und aus der Detailansicht entfernt.

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-04 09:51:14 UTC (rev 341)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-04 16:25:25 UTC (rev 342)
@@ -163,6 +163,7 @@
 		1016=Alle abw%e4hlen
 		1017=Alle add. Wpts
 		1018=Sel. add. Wpts
+		1019=Zentrum
 		1100=Profile
 		1101=Profil 1
 		1102=Profil 2
@@ -398,6 +399,7 @@
 		1016=De-select all
 		1017=All add. wpts
 		1018=Sel. add. Wpts
+		1019=Center
 		1100=Profiles
 		1101=Profile 1
 		1102=Profile 2

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-04 09:51:14 UTC (rev 341)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-04 16:25:25 UTC (rev 342)
@@ -83,7 +83,7 @@
 		this.addLast(wayStatus.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(308,"Notes:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(btnCenter = new mButton(MyLocale.getMsg(309,"Make Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//this.addLast(btnCenter = new mButton(MyLocale.getMsg(309,"Make Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 //		this.addLast(btnDelete = new mButton(MyLocale.getMsg(310,"Delete")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
 		ScrollBarPanel sbp = new ScrollBarPanel(wayNotes);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-04 09:51:14 UTC (rev 341)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-04 16:25:25 UTC (rev 342)
@@ -3,7 +3,7 @@
 import ewe.ui.*;
 import ewe.fx.*;
 import ewe.util.*;
-import ewe.sys.*;
+//import ewe.sys.*;
 
 /**
 *	This class creates the tabbed panel and sets the tabs to the respective

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-04 09:51:14 UTC (rev 341)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-04 16:25:25 UTC (rev 342)
@@ -48,7 +48,7 @@
 		
 		addLast(new ScrollBarPanel(tc = new myTableControl()));
 		addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),MyLocale.getMsg(1018,"Sel. add. wpts."),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all"),MyLocale.getMsg(1017,"All add. wpts")},MyLocale.getMsg(1013,"With selection"));
+		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1019,"Center"),MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),MyLocale.getMsg(1018,"Sel. add. wpts."),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all"),MyLocale.getMsg(1017,"All add. wpts")},MyLocale.getMsg(1013,"With selection"));
 		tc.setMenu(m);
 		tc.profile=profile;
 		tc.db = cacheDB;
@@ -164,7 +164,6 @@
 		}
 	} //updateBearingDistance
 	
-	
 	public void onEvent(Event ev)
 	{
 		////Vm.debug(ev.toString());

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-04 09:51:14 UTC (rev 341)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-04 16:25:25 UTC (rev 342)
@@ -103,6 +103,18 @@
 			Vm.showWait(false);
 			tbp.refreshTable();
 		}
+		if (selectedItem.toString().equals(MyLocale.getMsg(1019,"Center"))){
+			CacheHolder thisCache = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
+			CWPoint cp=new CWPoint(thisCache.LatLon);
+			if (!cp.isValid()){
+				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
+				tmpMB.exec();
+			} else {				
+				pref.curCentrePt.set(cp);
+				TablePanel.updateBearingDistance(db, pref);
+				tbp.refreshTable();
+			}
+		}
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1010,"Goto"))){
 //			Point a = new Point();



From admin at berlios.de  Thu Jan  4 17:34:06 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 4 Jan 2007 17:34:06 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2955] Wegpunkt als Zentrum
Message-ID: <200701041634.l04GY5Hc003360@unicorn.berlios.de>

Feature Request #2955, was updated on 2006-Dec-06 15:56
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2955&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Wegpunkt als Zentrum

By: bilbowolf
Date: 2007-Jan-04 17:34

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

erledigt mit revision 342

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Dec-06 15:56

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

aus dem Detailschirm nehmen und in das Pop-Up 
von der Listenansicht integrieren.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2955&group_id=2211


From admin at berlios.de  Thu Jan  4 17:35:32 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 4 Jan 2007 17:35:32 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3007] Je Profil ein Suchradius
Message-ID: <200701041635.l04GZWwx003387@unicorn.berlios.de>

Feature Request #3007, was updated on 2007-Jan-04 17:35
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3007&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Je Profil ein Suchradius

By: bilbowolf
Date: 2007-Jan-04 17:35

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

siehe: http://www.geoclub.de/ftopic13318.html

Hier der Text aus dem Forum:
es scheint, dass CW sich die letzte Suchradius von 
OC.de und GC.com global gemerkt hat. Sch?ner 
w?re es, wenn diese Suchradien dem Profil 
zugeordnet werden. 

Wenn ich z.B. Profil A mit einem Suchradius von 5 
km aktualisiert habe, danach Profil B mit 25 km, 
w?re es n?tzlich wenn beim n?chsten Update von 
Profil A wieder 5 km vorgeschlagen w?rde. 
Stattdessen erscheint jedoch 25 km. 

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3007&group_id=2211


From kalli at mail.berlios.de  Thu Jan  4 21:07:56 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Thu, 4 Jan 2007 21:07:56 +0100
Subject: [Cachewolf-svn] r343 - trunk/src/CacheWolf
Message-ID: <200701042007.l04K7uG8016096@sheep.berlios.de>

Author: kalli
Date: 2007-01-04 21:07:54 +0100 (Thu, 04 Jan 2007)
New Revision: 343

Modified:
   trunk/src/CacheWolf/RadarPanel.java
Log:
Bug #9809: Cachetype "Mega-Event" mit aufgenommen.
Im Radarpanel hat noch etwas gefehlt.

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-01-04 16:25:25 UTC (rev 342)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-01-04 20:07:54 UTC (rev 343)
@@ -23,7 +23,7 @@
 	int scaleKm = 30;
 	int centerX, centerY;
 	int height, width;
-	Image cacheImages[] = new Image[138];
+	Image cacheImages[] = new Image[454];
 	String selectedWaypoint = new String();
 	MainTab mt;
 	boolean penMoving = false;
@@ -55,6 +55,7 @@
 		cacheImages[53] = new Image("flag.png");
 
 		cacheImages[137] = new Image("137.png");
+		cacheImages[453] = new Image("453.png");
 		this.addLast(iActP = new myInteractivePanel(), this.STRETCH, this.FILL);
 		CellPanel cp = new CellPanel();
 		cp.addNext(btMinus,this.DONTSTRETCH, (this.DONTFILL|this.WEST));



From admin at berlios.de  Fri Jan  5 01:18:50 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 5 Jan 2007 01:18:50 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2982] Filterkriterien anzeigen
Message-ID: <200701050018.l050Io3U004287@unicorn.berlios.de>

Feature Request #2982, was updated on 2006-Dec-19 12:25
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2982&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: Filterkriterien anzeigen

By: cw-tester
Date: 2006-Dec-19 12:25

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

wenn ich mehrere Filter anwende ist es manchmal
interessant auch sp?ter noch zu wissen welche das
waren. Hier w?rde helfen, wenn bei erneutem Aufruf von
'Filter erzeugen' einfach die vorher gew?hlten
Kriterien angezeigt werden.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2982&group_id=2211


From admin at berlios.de  Fri Jan  5 01:19:56 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 5 Jan 2007 01:19:56 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2951] Solver: Fehlermeldung fehlt
Message-ID: <200701050019.l050Ju8Y007145@unicorn.berlios.de>

Feature Request #2951, was updated on 2006-Dec-06 12:11
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2951&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: Solver: Fehlermeldung fehlt

By: pfeffer
Date: 2006-Dec-06 12:11

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

http://www.geoclub.de/ftopic12853.html

[quote="2cachefix"]Grunds?tzlich sieht das f?r mich
ausf?hrbar aus.
A = 1;
B= 3;
C= 4;
?N 48 12.00"show(A+B);
D = A \* 4000 / C ? 10 \* 400;
"Die n?chste Position ist: "show(D)" befindet sich hier";
[/quote]

Der Grund f?r die InexOutOfBoundsExeption liegt in
irgendwelchen Sonderzeichen (?), auch der Backslash vor
dem "*" st?rt wohl. Das aktuelle Beispiel in der Doku
auf cachewolf.berlios.de funktioniert.
Trotzdem hast Du recht: es sollte ein entsprechender
Fehler ausgegeben werden.

Gru?,
  Pfeffer.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2951&group_id=2211


From bilbowolf at mail.berlios.de  Fri Jan  5 12:50:11 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Fri, 5 Jan 2007 12:50:11 +0100
Subject: [Cachewolf-svn] r344 - trunk/src/CacheWolf
Message-ID: <200701051150.l05BoBWq020390@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-05 12:50:00 +0100 (Fri, 05 Jan 2007)
New Revision: 344

Modified:
   trunk/src/CacheWolf/Filter.java
Log:
Filter auf positiv gesetzt.

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-04 20:07:54 UTC (rev 343)
+++ trunk/src/CacheWolf/Filter.java	2007-01-05 11:50:00 UTC (rev 344)
@@ -205,9 +205,17 @@
 		CacheHolder ch = new CacheHolder();
 		int cacheTypePattern = 0;
 		int cacheRosePattern = 0;
+		int inDist = 0, matchDist = 0;
+		int inDiff = 0, matchDiff = 0;
+		int inTerr = 0, matchTerr = 0;
+		int inFound = 0, matchFound = 0;
+		int matchOwned = 0, inOwned = 0;
+		int matchArchived = 0, inArchived = 0;
+		int matchAvaliable = 0, inAvailable = 0;
+		
 		double dummyd1, dummyd2;
 		String dummy = new String();
-		//Loop db and math once against type pattern and once against rose pattern
+		//Loop db and match once against type pattern and once against rose pattern
 		//Default is_filtered = true, means will not be displayed!
 		//If cache matches type and rose pattern then is_filtered is set to false
 		//Still in the loop check aginst diff, terr, dist, found by, found last
@@ -242,166 +250,70 @@
 			if(ch.bearing.equals("S")) cacheRosePattern |= S;
 			if(ch.bearing.equals("SSE")) cacheRosePattern |= SSE;
 			if(ch.bearing.equals("SE")) cacheRosePattern |= SE;
-/*			
-			Vm.debug(ch.wayPoint);
-			Vm.debug("Type Pattern: " + cacheTypePattern);
-			Vm.debug("Type Match Pattern: " + typeMatchPattern);
-			Vm.debug("AND: " + (cacheTypePattern & typeMatchPattern));
-			*/ 
-			if((cacheTypePattern & typeMatchPattern) == 0 &&(cacheRosePattern & roseMatchPattern) == 0) ch.is_filtered = false;
-			
-			/*
-			if(dist.length()>0 && ch.is_filtered == false){
-				dummy = ch.distance.substring(0,ch.distance.length()-3);
-				dummyd1 = Common.parseDouble(dummy); 
-				dummyd2 = Common.parseDouble(dist); 
-				if(distdirec == SMALLER && dummyd2 >= dummyd1) ch.is_filtered = true;
-				if(distdirec == GREATER && dummyd2 <= dummyd1) ch.is_filtered = true;
-			}
-			
-			if(diff.length()>0 && ch.is_filtered == false){
-				dummyd1 = Common.parseDouble(ch.hard);
-				dummyd2 = Common.parseDouble(diff);
-				if(diffdirec == SMALLER && dummyd2 >= dummyd1) ch.is_filtered = true;
-				if(diffdirec == GREATER && dummyd2 <= dummyd1) ch.is_filtered = true;
-			}
-			
-			if(terr.length()>0 && ch.is_filtered == false){
-				dummyd1 = Common.parseDouble(ch.terrain);
-				dummyd2 = Common.parseDouble(terr);
-				if(terrdirec == SMALLER && dummyd2 >= dummyd1) ch.is_filtered = true;
-				if(terrdirec == GREATER && dummyd2 <= dummyd1) ch.is_filtered = true;
-			}
-			
-			if(ch.is_found == false && foundByMe == true && ch.is_filtered == false) ch.is_filtered = true;
-			if(ch.is_owned == false && ownedByMe == true && ch.is_filtered == false) ch.is_filtered = true;
-			
-			if(ch.is_archived == false && archived == true && ch.is_filtered == false) ch.is_filtered = true;
-			if(ch.is_available == false && notAvailable == true && ch.is_filtered == false) ch.is_filtered = true;
-			*/
-			cacheDB.set(i,ch);
-		} // for
-	}
-	
-	
-	public void doFilter_old(Vector cacheDB, String dir){
-		byVec = mString.split(by, ',');
-		CacheHolder ch;
-		//CacheReaderWriter crw = new CacheReaderWriter();
-		String dummy = new String();
-		FileReader in;
-		String text = new String();
-		String logStr = new String();
-		String foundStr = new String();
-		Extractor ex, ex2;
-		double dummyd1, dummyd2;
-		
-		for(int i = 0; i < cacheDB.size(); i++){
-			//is_changed = false;
-			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered = false;
-			if(bearing.indexOf("|"+ch.bearing+"|")>=0) ch.is_filtered = true;
-			if(type.indexOf("|"+ch.type+"|") >= 0) ch.is_filtered = true;
-			
-			//Vm.debug("Dist: " + Convert.toString(distdirec));
+
 			if(dist.length()>0){
+				matchDist = 1;
+				inDist = 0;
 				dummy = ch.distance.substring(0,ch.distance.length()-3);
 				dummyd1 = Common.parseDouble(dummy); 
 				dummyd2 = Common.parseDouble(dist); 
-				if(distdirec == SMALLER && dummyd2 <= dummyd1) ch.is_filtered = true;
-				if(distdirec == GREATER && dummyd2 >= dummyd1) ch.is_filtered = true;
+				if(distdirec == SMALLER && dummyd2 <= dummyd1) inDist = 1;
+				if(distdirec == GREATER && dummyd2 >= dummyd1) inDist = 1;
 			}
 			
 			if(diff.length()>0){
+				matchDiff = 1;
+				inDiff = 0;
 				dummyd1 = Common.parseDouble(ch.hard);
 				dummyd2 = Common.parseDouble(diff);
-				if(diffdirec == SMALLER && dummyd2 <= dummyd1) ch.is_filtered = true;
-				if(diffdirec == GREATER && dummyd2 >= dummyd1) ch.is_filtered = true;
+				if(diffdirec == SMALLER && dummyd2 <= dummyd1) inDiff = 1;
+				if(diffdirec == GREATER && dummyd2 >= dummyd1) inDiff = 1;
 			}
 			
 			if(terr.length()>0){
+				matchTerr = 1;
+				inTerr = 0;
 				dummyd1 = Common.parseDouble(ch.terrain);
 				dummyd2 = Common.parseDouble(terr);
-				if(terrdirec == SMALLER && dummyd2 <= dummyd1) ch.is_filtered = true;
-				if(terrdirec == GREATER && dummyd2 >= dummyd1) ch.is_filtered = true;
+				if(terrdirec == SMALLER && dummyd2 <= dummyd1) inTerr = 1;
+				if(terrdirec == GREATER && dummyd2 >= dummyd1) inTerr = 1;
 			}
 			
+			if(foundByMe == true){
+				inFound = 0;
+				matchFound = 1;
+				if(ch.is_found) inFound = 1; 
+			}
 			
-			if(ch.is_found == true && foundByMe == true) ch.is_filtered = true;
-			if(ch.is_owned == true && ownedByMe == true) ch.is_filtered = true;
+			if(ownedByMe){
+				matchOwned = 1;
+				inOwned = 0;
+				if(ch.is_owned) inOwned = 1;
+			}
 			
-			if(ch.is_archived == true && archived == true) ch.is_filtered = true;
-			if(ch.is_available == false && notAvailable == true) ch.is_filtered = true;
-			
-			// now the filters that require we scan the detail cache pages
-			// found by
-			if(by.length()>0 || days.length()>0){
-				try{
-				in = new FileReader(dir+ch.wayPoint+".xml");
-				text = new String();
-				text = in.readAll();
-				in.close();
-				}catch(Exception e){
-					//Vm.debug("Error reading xml file");
-				}
+			if(archived){
+				matchArchived = 1;
+				inArchived = 0;
+				if(ch.is_archived) inArchived = 1;
 			}
-			if(by.length()>0){
-				ex = new Extractor(text, "<LOGS>", "</LOGS>", 0, true);
-				logStr = ex.findNext();
-				ex2 = new Extractor(logStr, "<img src='icon_smile.gif'>&nbsp;", "</", 0, true);
-				foundStr = (ex2.findNext()).toUpperCase();
-				while(ex2.endOfSearch() == false){
-					for(int p = 0; p<byVec.length;p++){
-						//Vm.debug(byVec[p]);
-						if(foundStr.indexOf(byVec[p].toUpperCase()) >= 0) ch.is_filtered = true;
-					}
-					foundStr = ex2.findNext();
-				} //while
-				
+			if(notAvailable){
+				matchAvaliable = 1;
+				inAvailable = 0;
+				if(ch.is_available) inAvailable = 1;
 			}
-			// found or not found in the last days....
-			if(days.length()>0){
-				try{
-					int tage = Convert.parseInt(days);
-					// what is todays date?
-					Time dtm = new Time();
-					DateChange dca = new DateChange();
-					dtm.getTime();
-					
-					ex = new Extractor(text, "<LOGS>", "</LOGS>", 0, true);
-					logStr = ex.findNext();
-					Extractor annex;
-					Extractor trex;
-					int tag,monat,jahr = 0;
-					String logLogStr = new String();
-					annex = new Extractor(logStr, "<img src='icon_smile.gif'>&nbsp;", " by",0,true);
-					logLogStr = annex.findNext();
-					while(!annex.endOfSearch()){
-						logLogStr = "-" + logLogStr + "-";
-						//Vm.debug("Log: " + logLogStr + " for " + ch.wayPoint);
-						trex = new Extractor(logLogStr,"-","-",0,true);
-						jahr = Convert.parseInt(trex.findNext());
-						monat = Convert.parseInt(trex.findNext());
-						tag = Convert.parseInt(trex.findNext());
-						dca = Time.dateDifference(dtm,new Time(tag, monat, jahr), dca);
-						//Vm.debug("tag: " +tag + " monat: " + monat + " jahr: " +jahr);
-						//Vm.debug("tag: " +dtm.day + " monat: " + dtm.month + " jahr: " +dtm.year);
-						//Vm.debug("Diff: " + dca.totalDays + " Tage + " + tage + " filt: " +ch.is_filtered);
-						if(daysdirec == FOUND && dca.totalDays <= tage) ch.is_filtered = true;
-						if(daysdirec == NOTFOUND && dca.totalDays >= tage) ch.is_filtered = true;
-						//Vm.debug("filt: " + ch.is_filtered);
-						if(ch.is_filtered == true) break;
-						logLogStr = annex.findNext();
-					}
-					//if(ch.is_filtered == true) break;
-				} catch (NumberFormatException nfex){
-					//Vm.debug(nfex.toString());
-				}
-			}
+
+			if((cacheTypePattern & typeMatchPattern) >= 1 &&
+					(cacheRosePattern & roseMatchPattern) >= 1 && 
+					(~(matchDist ^ inDist)) == -1 &&
+					(~(matchDiff ^ inDiff)) == -1 &&
+					(~(matchTerr ^ inTerr)) == -1 &&
+					(~(matchFound ^ inFound)) == -1 &&
+					(~(matchOwned ^ inOwned)) == -1 &&
+					(~(matchArchived ^ inArchived)) == -1 &&
+					(~(matchAvaliable ^ inAvailable)) == -1)
+					ch.is_filtered = false;
 			cacheDB.set(i,ch);
-		}
-		
-		//sort filtered and adapt the count in the table!
+		} // for
 	}
 	
 	/**



From bilbowolf at mail.berlios.de  Fri Jan  5 13:23:43 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Fri, 5 Jan 2007 13:23:43 +0100
Subject: [Cachewolf-svn] r345 - in trunk: resources src/CacheWolf
Message-ID: <200701051223.l05CNhTL029037@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-05 13:23:41 +0100 (Fri, 05 Jan 2007)
New Revision: 345

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/MainForm.java
Log:
Infobox wird angezeigt, waehrend die index.xml nach der Profilauswahl geladen wird.

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-05 11:50:00 UTC (rev 344)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-05 12:23:41 UTC (rev 345)
@@ -240,6 +240,7 @@
 		4500=Ges:
 		4501=Gez:
 		4502=Gef:
+		5000=Lade Cacheliste
 		{..}
 		{en}
 		100=to HTML

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-05 11:50:00 UTC (rev 344)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-05 12:23:41 UTC (rev 345)
@@ -6,7 +6,7 @@
 
 /**
 *	Mainform is responsible for building the user interface.
-*	Class ID = not required
+*	Class ID = 5000
 */
 public class MainForm extends Form {
 	
@@ -44,14 +44,19 @@
 			this.setPreferredSize(800, 600);
 		this.resizeOnSIP = true;
 		// Load CacheList
-		Vm.showWait(true);
+		
 		try{
 			pref.readPrefFile();
 			addGuiFont();
 			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
 				ewe.sys.Vm.exit(0); // User MUST select or create a profile
 			long start = Vm.getTimeStampLong();
+			Vm.showWait(true);
+			InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
+			infB.exec();
 			profile.readIndex();
+			infB.close(0);
+			Vm.showWait(false);
 			pref.curCentrePt.set(profile.centre);
 			long end = Vm.getTimeStampLong();
 			Vm.debug("index.xml read: " + Convert.toString(end - start)+ " msec");
@@ -70,7 +75,7 @@
 		this.addLast(mMenu = new MainMenu(this, pref, profile),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		this.addLast(mTab = new MainTab(pref,profile,statBar),CellConstants.STRETCH, CellConstants.FILL);
 		mMenu.setTablePanel(mTab.getTablePanel());
-		Vm.showWait(false);
+		
 	}
 
 	



From admin at berlios.de  Fri Jan  5 13:24:33 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 5 Jan 2007 13:24:33 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #1988] Filter auf "Positiv"
Message-ID: <200701051224.l05COXRr004972@unicorn.berlios.de>

Feature Request #1988, was updated on 2006-Mar-17 16:50
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1988&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Filter auf "Positiv"

By: bilbowolf
Date: 2007-Jan-05 13:24

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

erledigt

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Mar-17 16:50

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; IE Autoconfiguration; .NET CLR 1.1.4322)

Der Filter muss von selektierte wegfiltern auf nur 
die anzeigen, wo alle filterkriterien passen 
ge?ndert werden.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1988&group_id=2211


From admin at berlios.de  Fri Jan  5 13:34:06 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 5 Jan 2007 13:34:06 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2597] GPx-Import: Bilder und/oder Karten
	laden
Message-ID: <200701051234.l05CY6Mi017152@unicorn.berlios.de>

Feature Request #2597, was updated on 2006-Sep-02 11:51
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2597&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: GPx-Import: Bilder und/oder Karten laden

By: bilbowolf
Date: 2007-Jan-05 13:34

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Ist (doch) erledigt.

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Dec-18 20:16

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Muss nochmal ?berarbeitet werden.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2597&group_id=2211


From bilbowolf at mail.berlios.de  Fri Jan  5 13:34:56 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Fri, 5 Jan 2007 13:34:56 +0100
Subject: [Cachewolf-svn] r346 - trunk/src/CacheWolf
Message-ID: <200701051234.l05CYu8W030527@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-05 13:34:55 +0100 (Fri, 05 Jan 2007)
New Revision: 346

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
Kleiner Bugfix bei der Anzeige der Infobox beim spidern.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-01-05 12:23:41 UTC (rev 345)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-05 12:34:55 UTC (rev 346)
@@ -223,7 +223,7 @@
 		
 		
 		InfoBox infB = new InfoBox("Status", "Fetching first page...");
-		infB.show();
+		infB.exec();
 		//Get first page
 		try{
 			pref.log("Fetching first list page: http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD) + "&f=1");



From admin at berlios.de  Fri Jan  5 13:38:36 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 5 Jan 2007 13:38:36 +0100 (CET)
Subject: [Feature #2226] Filter für Earthcache und Megaevent
Message-ID: <200701051238.l05CcaD5022071@unicorn.berlios.de>

Feature Request #2226, was updated on 2006-May-23 19:19
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2226&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Filter f?r Earthcache und Megaevent

By: kalli
Date: 2006-May-23 19:19

Message:
Logged In: YES 
user_id=24621
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; de) Opera 8.50

Earthcaches k?nnen nicht gefiltert werden, siehe 
http://www.geoclub.de/ftopic9243.html

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2226&group_id=2211


From admin at berlios.de  Fri Jan  5 13:39:43 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 5 Jan 2007 13:39:43 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2982] Filterkriterien anzeigen
Message-ID: <200701051239.l05CdhZR023279@unicorn.berlios.de>

Feature Request #2982, was updated on 2006-Dec-19 12:25
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2982&group_id=2211

Category: 0.9n
Status: Deleted
Priority: 5
Summary: Filterkriterien anzeigen

By: bilbowolf
Date: 2007-Jan-05 13:39

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Ist (quasi) doppelt: siehe 002953.

Daher mache ich diesen zu.

----------------------------------------------------------------------

By: cw-tester
Date: 2006-Dec-19 12:25

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

wenn ich mehrere Filter anwende ist es manchmal
interessant auch sp?ter noch zu wissen welche das
waren. Hier w?rde helfen, wenn bei erneutem Aufruf von
'Filter erzeugen' einfach die vorher gew?hlten
Kriterien angezeigt werden.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2982&group_id=2211


From admin at berlios.de  Fri Jan  5 13:39:55 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 5 Jan 2007 13:39:55 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2982] Filterkriterien anzeigen
Message-ID: <200701051239.l05Cdt00023390@unicorn.berlios.de>

Feature Request #2982, was updated on 2006-Dec-19 12:25
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2982&group_id=2211

Category: 0.9n
Status: Deleted
Priority: 5
Summary: Filterkriterien anzeigen

By: bilbowolf
Date: 2007-Jan-05 13:39

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Ist (quasi) doppelt: siehe 002953.

Daher mache ich diesen zu.

----------------------------------------------------------------------

By: bilbowolf
Date: 2007-Jan-05 13:39

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Ist (quasi) doppelt: siehe 002953.

Daher mache ich diesen zu.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2982&group_id=2211


From kalli at mail.berlios.de  Sat Jan  6 14:21:18 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sat, 6 Jan 2007 14:21:18 +0100
Subject: [Cachewolf-svn] r347 - trunk/src/CacheWolf
Message-ID: <200701061321.l06DLIJm018884@sheep.berlios.de>

Author: kalli
Date: 2007-01-06 14:21:17 +0100 (Sat, 06 Jan 2007)
New Revision: 347

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
Prefix fuer addi wpts auf zwei Stellen formatiert
Kann auch mit 7-stelligen wpts umgehen.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-01-05 12:34:55 UTC (rev 346)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-06 13:21:17 UTC (rev 347)
@@ -448,7 +448,7 @@
 				*/
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
-				cx.wayPoint = Convert.toString(counter) + ch.wayPoint.substring(2,6);
+				cx.wayPoint = MyLocale.formatLong(counter, "00") + ch.wayPoint.substring(2);
 				counter++;
 				cx.LongDescription = descRex.stringMatched(1); 
 				//Vm.debug(descRex.stringMatched(1));



From admin at berlios.de  Sat Jan  6 16:10:40 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 6 Jan 2007 16:10:40 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9752] sonderzeichen
Message-ID: <200701061510.l06FAeaU007241@unicorn.berlios.de>

Bug #9752, was updated on 2006-Dec-17 22:21
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: sonderzeichen

Details: 0.9m schafft es bei (leider unregelm??ig) cachnamen zu verst?mmeln, die "sonderzeichen" enthalten. klassiker sind die umlaute sowie ' & < und > . irgendwann, beim xten import eines gpx files wird zerst?ckelt. leider ist es noch nicht einmal immer das erste oder das letzte dieser zeichen wobei diese positionen schon recht h?ufig betroffen sind.

Follow-Ups:

Date: 2007-Jan-06 16:10
By: salzkammergut

Comment:
Wo genau werden Cachenamen verst?mmelt?

Beim Spidern?
Beim Einlesen von GPX Dateien?
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9752&group_id=2211


From admin at berlios.de  Sat Jan  6 16:17:21 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 6 Jan 2007 16:17:21 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9752] sonderzeichen
Message-ID: <200701061517.l06FHLpZ007763@unicorn.berlios.de>

Bug #9752, was updated on 2006-Dec-17 22:21
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: sonderzeichen

Details: 0.9m schafft es bei (leider unregelm??ig) cachnamen zu verst?mmeln, die "sonderzeichen" enthalten. klassiker sind die umlaute sowie ' & < und > . irgendwann, beim xten import eines gpx files wird zerst?ckelt. leider ist es noch nicht einmal immer das erste oder das letzte dieser zeichen wobei diese positionen schon recht h?ufig betroffen sind.

Follow-Ups:

Date: 2007-Jan-06 16:17
By: greiol

Comment:
"beim xten import eines gpx files"
-------------------------------------------------------

Date: 2007-Jan-06 16:10
By: salzkammergut

Comment:
Wo genau werden Cachenamen verst?mmelt?

Beim Spidern?
Beim Einlesen von GPX Dateien?
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9752&group_id=2211


From admin at berlios.de  Sat Jan  6 16:40:48 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 6 Jan 2007 16:40:48 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9752] sonderzeichen
Message-ID: <200701061540.l06FemA1009156@unicorn.berlios.de>

Bug #9752, was updated on 2006-Dec-17 22:21
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: sonderzeichen

Details: 0.9m schafft es bei (leider unregelm??ig) cachnamen zu verst?mmeln, die "sonderzeichen" enthalten. klassiker sind die umlaute sowie ' & < und > . irgendwann, beim xten import eines gpx files wird zerst?ckelt. leider ist es noch nicht einmal immer das erste oder das letzte dieser zeichen wobei diese positionen schon recht h?ufig betroffen sind.

Follow-Ups:

Date: 2007-Jan-06 16:40
By: greiol

Comment:
fangen wir mal mit was einfachem und sauber reproduzierbaren an.

ein gepx das diese caches enth?lt:
http://www.geocaching.com/seek/nearest.aspx?key=gc+by+emzett
-------------------------------------------------------

Date: 2007-Jan-06 16:17
By: greiol

Comment:
"beim xten import eines gpx files"
-------------------------------------------------------

Date: 2007-Jan-06 16:10
By: salzkammergut

Comment:
Wo genau werden Cachenamen verst?mmelt?

Beim Spidern?
Beim Einlesen von GPX Dateien?
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9752&group_id=2211


From salzkammergut at mail.berlios.de  Sat Jan  6 20:54:46 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 6 Jan 2007 20:54:46 +0100
Subject: [Cachewolf-svn] r348 - trunk/src/CacheWolf
Message-ID: <200701061954.l06JskKg002443@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-06 20:54:43 +0100 (Sat, 06 Jan 2007)
New Revision: 348

Modified:
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Ein-/ausgeblendete Spalten werden sofort nach "Anwenden" der Praeferenzen angezeigt.
Beginn Umbau auf Global

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-06 13:21:17 UTC (rev 347)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-06 19:54:43 UTC (rev 348)
@@ -11,8 +11,8 @@
 public class MainForm extends Form {
 	
 	StatusBar statBar;
-	Preferences pref = Preferences.getPrefObject(); // Singleton pattern
-	Profile profile = new Profile();
+	Preferences pref = Global.getPref(); // Singleton pattern
+	Profile profile = Global.getProfile();
 	MainTab mTab;
 	MainMenu mMenu;
 
@@ -70,9 +70,9 @@
 				Vm.setSIP(Vm.SIP_LEAVE_BUTTON|Vm.SIP_ON);
 			}
 		} else Vm.setSIP(0);
-		Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
+		//Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
 		statBar = new StatusBar(pref, profile.cacheDB);
-		this.addLast(mMenu = new MainMenu(this, pref, profile),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(mMenu = new MainMenu(this),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		this.addLast(mTab = new MainTab(pref,profile,statBar),CellConstants.STRETCH, CellConstants.FILL);
 		mMenu.setTablePanel(mTab.getTablePanel());
 		
@@ -111,6 +111,7 @@
 	
 	public void onEvent(Event ev){ // Preferences have been changed by PreferencesScreen
 		if(pref.dirty == true){
+			mTab.getTablePanel().myMod.setColumnNamesAndWidths();	
 		    mTab.getTablePanel().refreshTable();
 			pref.dirty = false;
 		}

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-06 13:21:17 UTC (rev 347)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-06 19:54:43 UTC (rev 348)
@@ -30,15 +30,9 @@
 	private MenuItem orgCopy, orgMove, orgDelete;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditProfile;
 	private Form father;
-	private Preferences pref;
-	private Vector cacheDB;
 	private TablePanel tbp;
-	private Profile profile;
 	
-	public MainMenu(Form f, Preferences p, Profile prof){
-		profile=prof;
-		cacheDB = profile.cacheDB;
-		pref = p;
+	public MainMenu(Form f){
 		father = f;
 		String cwd = File.getProgramDirectory();
 
@@ -162,6 +156,9 @@
 	}
 	
 	public void onEvent(Event ev){
+		Preferences pref=Global.getPref();
+		Profile profile=Global.getProfile();
+		Vector cacheDB=profile.cacheDB;
 		if (ev instanceof MenuEvent){ //&& ev.type == MenuEvent.PRESSED
 			MenuEvent mev = (MenuEvent)ev;
 			if(mev.selectedItem == wolflang){
@@ -190,9 +187,10 @@
 			}
 			if(mev.selectedItem == mnuOpenProfile){
 				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
+					profile.cacheDB.clear();
 					profile.readIndex();
 					pref.curCentrePt.set(profile.centre);
-					tbp.resetModel(cacheDB);
+					tbp.resetModel();
 				}
 			}
 			if(mev.selectedItem == mnuEditProfile){
@@ -202,6 +200,7 @@
 				f.close(0);
 			}
 			if(mev.selectedItem == preferences){
+				tbp.saveColWith(pref);
 				PreferencesScreen pfs = new PreferencesScreen(pref);
 				pfs.execute(father.getFrame(), Gui.CENTER_FRAME);
 				pref.readPrefFile();
@@ -238,12 +237,12 @@
 						}
 					}
 				}
-				tbp.resetModel(cacheDB);
+				tbp.resetModel();
 			}
 			if(mev.selectedItem == loadOC){
 				OCXMLImporter oc = new OCXMLImporter(pref,profile);
 				oc.doIt();
-				tbp.resetModel(cacheDB);
+				tbp.resetModel();
 			}
 			if(mev.selectedItem == filtCreate){
 				FilterScreen fsc = new FilterScreen(cacheDB, pref.baseDir);
@@ -261,10 +260,10 @@
 				pcx.doIt(PCX5Exporter.MODE_AUTO);
 				ProgressBarForm pbf = new ProgressBarForm();
 				pbf.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
-				String cwd = new String();
-				cwd = File.getProgramDirectory() + "/temp.pcx";
+				String cwd = File.getProgramDirectory() + "/temp.pcx";
 				try{
 					ewe.sys.Process p = Vm.exec("gpsbabel -s -i pcx -f "+ cwd +" -o garmin -F " + pref.garminConn +":");
+					Vm.debug("gpsbabel -s -i pcx -f "+ cwd +" -o garmin -F " + pref.garminConn +":");
 					p.waitFor();
 				}catch(IOException ioex){};
 				pbf.clear();
@@ -297,7 +296,7 @@
 			}
 			
 			if(mev.selectedItem == filtSelected){
-				CacheHolder ch = new CacheHolder();
+				CacheHolder ch;
 				for(int i = 0; i <	cacheDB.size(); i++){
 					ch = (CacheHolder)cacheDB.get(i);
 					ch.is_filtered = false;
@@ -443,28 +442,9 @@
 				}
 			}
 			if(mev.selectedItem == spider){
-				//GeoToadUI gtUI = new GeoToadUI(myPreferences, File.getProgramDirectory(),cacheDB);
 				SpiderGC spGC = new SpiderGC(pref, profile);
 				spGC.doIt();
-				tbp.resetModel(cacheDB);
-				/*
-				gtUI.execute();
-				File ftest = new File(File.getProgramDirectory() + "/temp.gpx");
-				if(ftest.exists()){
-					if(gtUI.chkImport.getState()){
-						//if(chkSpoilers.getState()) inf = new InfoBox("GPX", "import + spoiler");
-						//else inf = new InfoBox("GPX", "import");
-						//inf.show();
-						GPXImporter imp = new GPXImporter(cacheDB, File.getProgramDirectory() + "/temp.gpx", myPreferences);
-						if(gtUI.chkSpoilers.getState()) {
-							imp.doIt(GPXImporter.DOIT_WITHSPOILER);
-						} else imp.doIt(GPXImporter.DOIT_NOSPOILER);
-					} else {
-						//Vm.debug("timer checking...");					
-					}
-					tbp.resetModel(cacheDB);
-				}
-				*/
+				tbp.resetModel();
 			}
 			if(mev.selectedItem == exit){
 				ewe.sys.Vm.exit(0);

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-06 13:21:17 UTC (rev 347)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-06 19:54:43 UTC (rev 348)
@@ -26,6 +26,7 @@
 		this.statBar = statBar;
 		cacheDB = profile.cacheDB;
 		pref = p;
+/*
 		String [] spName = {" ","?",MyLocale.getMsg(1000,"D"),"T",MyLocale.getMsg(1002,"Waypoint"),"Name",MyLocale.getMsg(1004,"Location"),MyLocale.getMsg(1005,"Owner"),MyLocale.getMsg(1006,"Hidden"),MyLocale.getMsg(1007,"Status"),MyLocale.getMsg(1008,"Dist"),MyLocale.getMsg(1009,"Bear")};
 		String[] jester;
 		int colWidth[];
@@ -45,7 +46,7 @@
 				ji++;
 			}
 		}
-		
+*/		
 		addLast(new ScrollBarPanel(tc = new myTableControl()));
 		addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1019,"Center"),MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),MyLocale.getMsg(1018,"Sel. add. wpts."),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all"),MyLocale.getMsg(1017,"All add. wpts")},MyLocale.getMsg(1013,"With selection"));
@@ -54,7 +55,7 @@
 		tc.db = cacheDB;
 		tc.pref = p;
 		tc.tbp = this;
-		myMod = new myTableModel(cacheDB, jester, colWidth, tc, getFontMetrics());
+		myMod = new myTableModel(tc, getFontMetrics());
 		myMod.hasRowHeaders = false;
 		myMod.hasColumnHeaders  = true;
 		tc.setTableModel(myMod);
@@ -87,45 +88,18 @@
 		}
 	}
 	
-	public void resetModel(Vector cacheDB) {
-		myMod.setVector(cacheDB);
+	public void resetModel() {
+		//RB  myMod.setVector(cacheDB);
+		myMod.numRows = cacheDB.size();
 		updateBearingDistance(cacheDB, pref);
 		////Vm.debug("IS mypref loaded? " + myPreferences.mylgDeg);
-		tc.setTableModel(myMod);
+		// tc.setTableModel(myMod); Not needed ?
 		tc.update(true);
 		statBar.updateDisplay();
 	}
 	
 	public void refreshTable(){
-/*		Auskommentiert f?r bug 9529 - vergessene Spaltenbreite
-        Weil bei jedem refresh ein neues TableModel Objekt erzeugt wurde, werden
-        die Spaltenbreiten vergessen.
-        Derzeit nur auskommentiert um eventuelle Nebeneffekte zu prfen.
-         
- 		String [] spName = {" ","?",MyLocale.getMsg(1000,"D"),"T",MyLocale.getMsg(1002,"Waypoint"),"Name",MyLocale.getMsg(1004,"Location"),MyLocale.getMsg(1005,"Owner"),MyLocale.getMsg(1006,"Hidden"),MyLocale.getMsg(1007,"Status"),MyLocale.getMsg(1008,"Dist"),MyLocale.getMsg(1009,"Bear")};
-		String[] jester;
-		int colWidth[];
-
-		int colnum = 0;
-		
-		for(int i = 0; i<=11; i++){
-			if(myPreferences.tablePrefs[i] == 1) colnum++;
-		}
-		jester = new String[colnum];
-		colWidth = new int[colnum];
-		int ji = 0;
-		for(int i = 0; i<=11;i++){
-			if(myPreferences.tablePrefs[i] == 1){
-				jester[ji] = spName[i];
-				colWidth[ji] = myPreferences.tableWidth[i];
-				ji++;
-			}
-		}
-		myMod = new myTableModel(cacheDB, jester, colWidth, tc, getFontMetrics());
-		myMod.hasRowHeaders = false;
-		myMod.hasColumnHeaders  = true;
-		tc.setTableModel(myMod);
-*/		myMod.updateRows();
+		myMod.updateRows();
 		tc.update(true);
 		statBar.updateDisplay();
 	}

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-06 13:21:17 UTC (rev 347)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-06 19:54:43 UTC (rev 348)
@@ -29,7 +29,7 @@
 	String nmCheck, nmQuest, nmD,nmT,nmWay,nmName,nmLoc,nmOwn,nmHid,nmStat,nmDist,nmBear = new String();
 	Image checkboxTicked,checkboxUnticked;
 	
-	public myTableModel(Vector DB, String[] colNs,int[] colWidth, myTableControl tc, FontMetrics fm){
+	public myTableModel(myTableControl tc, FontMetrics fm){
 		super();
 		nmCheck = " ";
 		nmQuest = "?";
@@ -45,15 +45,15 @@
 		nmBear = MyLocale.getMsg(1009,"Bear");
 		fm = this.fm;
 		tcControl = tc;
-		cacheDB = DB;
+		setColumnNamesAndWidths(); 
+		cacheDB = Global.getProfile().cacheDB;
 		this.numRows = cacheDB.size();
 		Dimension selrow = new Dimension(-1,1);
 		this.cursorSize = selrow;
-		colName = new String[colNs.length];
-		colName = colNs;
-		breiten = new int[colWidth.length];
-		breiten = colWidth;
-		this.numCols = colName.length;
+		//colName = new String[colNs.length];
+		//colName = colNs;
+		//breiten = new int[colWidth.length];
+		//breiten = colWidth;
 		cacheImages[0] = new Image("0.png");
 		//cacheImages[1] = new Image();
 		cacheImages[2] = new Image("2.png");
@@ -93,11 +93,43 @@
 		checkboxUnticked= new Image("checkboxUnticked.png");
 	}
 	
-	public void setVector(Vector DB){
-		cacheDB = DB;
-		this.numRows = cacheDB.size();
+	/**
+	 * Sets the column names and widths from preferences
+	 *
+	 */
+	public void setColumnNamesAndWidths() {
+		String [] spName = {" ","?",MyLocale.getMsg(1000,"D"),"T",MyLocale.getMsg(1002,"Waypoint"),"Name",MyLocale.getMsg(1004,"Location"),MyLocale.getMsg(1005,"Owner"),MyLocale.getMsg(1006,"Hidden"),MyLocale.getMsg(1007,"Status"),MyLocale.getMsg(1008,"Dist"),MyLocale.getMsg(1009,"Bear")};
+		String[] jester;
+		int colWidth[];
+		int colnum = 0;
+		Preferences pref=Global.getPref();
+		
+		for(int i = 0; i<=11; i++){
+			if(pref.tablePrefs[i] == 1) colnum++;
+		}
+		jester = new String[colnum];
+		colWidth = new int[colnum];
+		
+		int ji = 0;
+		for(int i = 0; i<=11;i++){
+			if(pref.tablePrefs[i] == 1){
+				jester[ji] = spName[i];
+				colWidth[ji] = pref.tableWidth[i];
+				ji++;
+			}
+		}
+		colName = jester;
+		breiten = colWidth;
+		this.numCols = colName.length;
+		clearCellAdjustments();
+		//remapColumns(null);
 	}
 	
+	//RBpublic void setVector(Vector DB){
+	//	cacheDB = DB;
+	//	this.numRows = cacheDB.size();
+	//}
+	
 	public void updateRows(){
 		this.numRows = cacheDB.size();
 		int counter = 0;



From salzkammergut at mail.berlios.de  Sat Jan  6 22:15:19 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 6 Jan 2007 22:15:19 +0100
Subject: [Cachewolf-svn] r349 - trunk/src/CacheWolf
Message-ID: <200701062115.l06LFJPD011051@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-06 22:15:15 +0100 (Sat, 06 Jan 2007)
New Revision: 349

Modified:
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Distanz und letztes Synch-Datum im Profil gespeichert (FR 3007)
Bugfix: Sanduhr bei Abbruch SpiderGC deaktiviert

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-01-06 19:54:43 UTC (rev 348)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-01-06 21:15:15 UTC (rev 349)
@@ -89,7 +89,7 @@
 			ewe.io.Reader r;
 			String file;
 			
-			OCXMLImporterScreen options = new OCXMLImporterScreen(pref, "Spider Options", OCXMLImporterScreen.IMAGESANDMAPS);
+			OCXMLImporterScreen options = new OCXMLImporterScreen("Spider Options", OCXMLImporterScreen.IMAGESANDMAPS);
 			options.distanceInput.modify(ewe.ui.ControlConstants.Invisible,0);
 			options.distLbl.modify(ewe.ui.ControlConstants.Invisible,0);
 			if (options.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-01-06 19:54:43 UTC (rev 348)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-01-06 21:15:15 UTC (rev 349)
@@ -57,9 +57,9 @@
 		pref = p;
 		profile=prof;
 		cacheDB = profile.cacheDB;
-		if(pref.last_sync_opencaching == null ||
-			pref.last_sync_opencaching.length() < 12){
-			pref.last_sync_opencaching = "20050801000000";
+		if(profile.last_sync_opencaching == null ||
+			profile.last_sync_opencaching.length() < 12){
+			profile.last_sync_opencaching = "20050801000000";
 			incUpdate = false;
 		}
 		user = p.myAlias.toLowerCase();
@@ -83,19 +83,19 @@
 			String lastS =  profile.last_sync_opencaching;
 			CWPoint center = pref.curCentrePt; // No need to clone curCentrePt as center is only read
 
-			OCXMLImporterScreen importOpt = new OCXMLImporterScreen(pref, MyLocale.getMsg(1600, "Opencaching.de Download"),OCXMLImporterScreen.ALL);
+			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, "Opencaching.de Download"),OCXMLImporterScreen.ALL);
 			if (importOpt.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
     		Vm.showWait(true);
 			String dist = importOpt.distanceInput.getText();
 			if (dist.length()== 0) return;
 			//check, if distance is greater than before
-			if (Convert.toInt(dist) > Convert.toInt(pref.distOC) ||
+			if (Convert.toInt(dist) > Convert.toInt(profile.distOC) ||
 			  pref.downloadmissingOC  ){
 				// resysnc
 				lastS = "20050801000000";
 				incUpdate = false;
 			}
-			pref.distOC = dist;
+			profile.distOC = dist;
 			// Clear status of caches in db
 			CacheHolder ch;
 			for(int i = 0; i<cacheDB.size();i++){
@@ -167,9 +167,8 @@
 		}
 		Vm.showWait(false);
 		if (success) {
-			// @TODO: this should be saved in the index.xml not with the profiles!
-			pref.last_sync_opencaching = dateOfthisSync.format("yyyyMMddHHmmss");
-			pref.savePreferences();
+			profile.last_sync_opencaching = dateOfthisSync.format("yyyyMMddHHmmss");
+			//pref.savePreferences();
 			profile.saveIndex(pref);
 			finalMessage=MyLocale.getMsg(1607,"Update from opencaching successful");
 		}

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-01-06 19:54:43 UTC (rev 348)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-01-06 21:15:15 UTC (rev 349)
@@ -14,22 +14,22 @@
  */
 public class OCXMLImporterScreen extends Form {
 	mButton cancelB, okB;
-	Preferences myPreferences;
+	Preferences pref;
 	mInput distanceInput;
 	mCheckBox imagesCheckBox, mapsCheckBox, missingCheckBox;
 	mLabel distLbl;
 	static int IMAGESANDMAPS = 0;
 	static int ALL = 1;
 	
-	public OCXMLImporterScreen(Preferences myPreferences, String title, int options) {
+	public OCXMLImporterScreen(String title, int options) {
 		super();
-		this.myPreferences = myPreferences; // myPreferences sollte sp?ter auch diese Einstellungen speichern
+		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
 		
 
 		this.title = title;
 		this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,"Distance:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		distanceInput = new mInput();
-		distanceInput.setText(myPreferences.distOC);
+		distanceInput.setText(Global.getProfile().distOC);
 		this.addLast(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));	
 		
 		imagesCheckBox = new mCheckBox();
@@ -59,9 +59,9 @@
 			}
 			if (ev.target == okB){
 				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr?ft werden kann, ob es gr??er oder kleiner ist als vorher
-					myPreferences.downloadMapsOC = mapsCheckBox.state;
-					myPreferences.downloadPicsOC = imagesCheckBox.state;
-					if (missingCheckBox!=null) myPreferences.downloadmissingOC = missingCheckBox.state;
+					pref.downloadMapsOC = mapsCheckBox.state;
+					pref.downloadPicsOC = imagesCheckBox.state;
+					if (missingCheckBox!=null) pref.downloadmissingOC = missingCheckBox.state;
 					// @todo: sofort speichern?
 				this.close(Form.IDOK);
 				}

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-06 19:54:43 UTC (rev 348)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-06 21:15:15 UTC (rev 349)
@@ -58,8 +58,8 @@
 	public String garminConn="com1";  // The type of connection which GPSBABEL uses: com1 OR usb.
 	// TODO Add garminConn to user interface. For the time being this can only be set by manually editing the pref file
 		
-	public String last_sync_opencaching = new String();
-	public String distOC = new String();
+	//public String last_sync_opencaching = new String();
+	//public String distOC = new String();
 	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
 	public boolean downloadMapsOC = true;
 	public boolean downloadmissingOC = false;
@@ -247,17 +247,15 @@
 		curCentrePt.set(lats[i]+" "+longs[i]);
 		//mydatadir=profdirs[i];
 		if(lastSyncOC[i] == null || lastSyncOC[i].endsWith("null")){
-			last_sync_opencaching = "20050801000000";
+			prof.last_sync_opencaching = "20050801000000";
 		}else {
-			last_sync_opencaching = lastSyncOC[i];
+			prof.last_sync_opencaching = lastSyncOC[i];
 		}
 		if(lastDistOC[i] == null || lastDistOC[i].endsWith("null")){
-			distOC = "0";
+			prof.distOC = "0";
 		} else {
-			distOC = lastDistOC[i];
+			prof.distOC = lastDistOC[i];
 		}
-		prof.last_sync_opencaching=last_sync_opencaching;
-		prof.distOC=distOC;
 		prof.centre.set(lats[i]+" "+longs[i]);
 		prof.dataDir=profdirs[i];
 	}
@@ -273,20 +271,6 @@
 		lastName=name;
 		String tmp;
 		if(name.equals("browser")) browser = atts.getValue("name");
-		if(name.equals("syncOC")) {
-			if (atts.getValue("date") == null || atts.getValue("date").endsWith("null")){
-				last_sync_opencaching = "20050801000000";
-			}
-			else {
-				last_sync_opencaching = atts.getValue("date");
-			}
-			if (atts.getValue("dist") == null || atts.getValue("dist").endsWith("null")){
-				distOC = "0";
-			}
-			else {
-				distOC =  atts.getValue("dist");
-			}
-		}
 		if(name.equals("fixedsip")) {
 			if(atts.getValue("state").equals("true")) {
 				fixSIP = true;
@@ -448,11 +432,11 @@
 	public void savePreferences(){
 		String datei = File.getProgramDirectory() + "/" + "pref.xml";
 		datei = datei.replace('\\', '/');
-		last_sync_opencaching = last_sync_opencaching==null?"20050801000000":last_sync_opencaching;
-		distOC = distOC==null?"0":distOC;
+		//last_sync_opencaching = last_sync_opencaching==null?"20050801000000":last_sync_opencaching;
+		//distOC = distOC==null?"0":distOC;
 		if (currProfile > 0) {
-			lastSyncOC[currProfile -1] = last_sync_opencaching;
-			lastDistOC[currProfile - 1] = distOC;
+			lastSyncOC[currProfile -1] = Global.getProfile().last_sync_opencaching;
+			lastDistOC[currProfile - 1] = Global.getProfile().distOC;
 		}
 
 		try{
@@ -491,7 +475,7 @@
 			outp.print("    <lastprofile autoreload=\""+autoReloadLastProfile+"\">"+lastProfile+"</lastprofile>\n"); //RB
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			// Obsolete data kept for backward compatibility
-			outp.print("	<syncOC date = \"" + last_sync_opencaching + "\" dist = \"" + distOC +  "\"/>\n");
+			//outp.print("	<syncOC date = \"" + last_sync_opencaching + "\" dist = \"" + distOC +  "\"/>\n");
 			outp.print("	<location lat = \""+curCentrePt.getLatDeg(CWPoint.DD)+"\" long = \""+curCentrePt.getLonDeg(CWPoint.DD)+"\"/>\n");
 			//outp.print("	<datadir dir = \""+ mydatadir +"\"/>\n");
 			outp.print("	<profile1 name = \""+profiles[0]+"\" lat = \""+ lats[0] +"\" lon = \""+ longs[0] +"\" dir = \""+ profdirs[0] +"\" lastsyncoc= \"" + lastSyncOC[0] + "\" lastdistoc= \"" + lastDistOC[0] + "\" />\n");

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-06 19:54:43 UTC (rev 348)
+++ trunk/src/CacheWolf/Profile.java	2007-01-06 21:15:15 UTC (rev 349)
@@ -80,6 +80,12 @@
 			if (savedCentre.isValid())
 				detfile.print("    <CENTRE lat=\""+savedCentre.getNSLetter() + " " + savedCentre.getLatDeg(CWPoint.CW) + "&deg; " + savedCentre.getLatMin(CWPoint.CW)+ "\" "+
 				                        "long=\""+savedCentre.getEWLetter() + " " + savedCentre.getLonDeg(CWPoint.CW) + "&deg; " + savedCentre.getLonMin(CWPoint.CW)+"\"/>\n");
+			if(last_sync_opencaching == null || last_sync_opencaching.endsWith("null") || last_sync_opencaching.equals("")){
+				last_sync_opencaching = "20050801000000";
+			}
+			if(distOC == null || distOC.endsWith("null") || distOC.equals("")){
+				distOC = "0";
+			}
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
@@ -148,9 +154,9 @@
 					//Vm.debug("Centre "+lat+" "+lon);
 					centre.set(lat+" "+lon,CWPoint.CW); // Fast parse
 				} else if (text.indexOf("<SYNCOC")>=0) {
-					int start=text.indexOf("date=\"")+6;
+					int start=text.indexOf("date = \"")+8;
 					last_sync_opencaching=text.substring(start,text.indexOf("\"",start));
-					start=text.indexOf("dist=\"")+6;
+					start=text.indexOf("dist = \"")+8;
 					distOC=text.substring(start,text.indexOf("\"",start));
 				}
 			}

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-01-06 19:54:43 UTC (rev 348)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-06 21:15:15 UTC (rev 349)
@@ -210,10 +210,13 @@
 		String doc = new String();
 		
 		int ok = login();
-		if(ok == Form.IDCANCEL) return;
+		if(ok == Form.IDCANCEL) {
+			Vm.showWait(false);
+			return;
+		}
 		
-		OCXMLImporterScreen options = new OCXMLImporterScreen(pref, "Spider Options", OCXMLImporterScreen.IMAGESANDMAPS);
-		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
+		OCXMLImporterScreen options = new OCXMLImporterScreen("Spider Options", OCXMLImporterScreen.IMAGESANDMAPS);
+		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {Vm.showWait(false);	return; }
 		String dist = options.distanceInput.getText();
 		if (dist.length()== 0) return;
 		distance = Convert.toDouble(dist);



From admin at berlios.de  Sat Jan  6 22:18:45 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 6 Jan 2007 22:18:45 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3007] Je Profil ein Suchradius
Message-ID: <200701062118.l06LIjTd029012@unicorn.berlios.de>

Feature Request #3007, was updated on 2007-Jan-04 17:35
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3007&group_id=2211

Category: None
Status: Closed
Priority: 5
Summary: Je Profil ein Suchradius

By: salzkammergut
Date: 2007-Jan-06 22:18

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Rev 349

----------------------------------------------------------------------

By: bilbowolf
Date: 2007-Jan-04 17:35

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

siehe: http://www.geoclub.de/ftopic13318.html

Hier der Text aus dem Forum:
es scheint, dass CW sich die letzte Suchradius von 
OC.de und GC.com global gemerkt hat. Sch?ner 
w?re es, wenn diese Suchradien dem Profil 
zugeordnet werden. 

Wenn ich z.B. Profil A mit einem Suchradius von 5 
km aktualisiert habe, danach Profil B mit 25 km, 
w?re es n?tzlich wenn beim n?chsten Update von 
Profil A wieder 5 km vorgeschlagen w?rde. 
Stattdessen erscheint jedoch 25 km. 

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3007&group_id=2211


From salzkammergut at mail.berlios.de  Sun Jan  7 00:45:04 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Jan 2007 00:45:04 +0100
Subject: [Cachewolf-svn] r350 - trunk/src/CacheWolf
Message-ID: <200701062345.l06Nj4Ir025443@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-07 00:44:58 +0100 (Sun, 07 Jan 2007)
New Revision: 350

Modified:
   trunk/src/CacheWolf/ImagePanel.java
Log:
Sonderzeichen in Bildernamen

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2007-01-06 21:15:15 UTC (rev 349)
+++ trunk/src/CacheWolf/ImagePanel.java	2007-01-06 23:44:58 UTC (rev 350)
@@ -112,7 +112,7 @@
 				addImage(ipi);
 				//Name of picture:
 				if(cache.ImagesText.size()>i){
-					imgText = (String)cache.ImagesText.get(i);
+					imgText = SafeXML.cleanback((String)cache.ImagesText.get(i));
 					if(imgText.length()==0) imgText = "???";
 					AimgText = new AniImage();
 					AimgText = getImageText(imgText);



From kalli at mail.berlios.de  Sun Jan  7 11:41:42 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 7 Jan 2007 11:41:42 +0100
Subject: [Cachewolf-svn] r351 - trunk/src/CacheWolf
Message-ID: <200701071041.l07Afg3c009840@sheep.berlios.de>

Author: kalli
Date: 2007-01-07 11:41:40 +0100 (Sun, 07 Jan 2007)
New Revision: 351

Modified:
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SafeXML.java
Log:
Bugfix f?\195?\188r Behandlung des Endes der Zeile

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-06 23:44:58 UTC (rev 350)
+++ trunk/src/CacheWolf/Profile.java	2007-01-07 10:41:40 UTC (rev 351)
@@ -91,11 +91,12 @@
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
-					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+"\" latlon = \""+ SafeXML.clean(ch.LatLon) +"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch!
 .ocCacheID + "\"/>\n");
+					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+"\" latlon = \""+ SafeXML.clean(ch.LatLon) +"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch!
 .ocCacheID + "\" />\n");
 				}
 			}
 			detfile.print("</CACHELIST>\n");
 			detfile.close();
+			CacheHolder.buildReferences(cacheDB);
 		}catch(Exception e){
 			Vm.debug("Problem writing to index file "+e.toString());
 		}
@@ -145,6 +146,10 @@
 					ch.is_HTML = ex.findNext().equals("false") ? false : true;
 					ch.noFindLogs = Convert.toInt(ex.findNext());
 					ch.ocCacheID = ex.findNext();
+					// remove "/>
+					ch.ocCacheID = SafeXML.replace(ch.ocCacheID,"\"/>", null);
+					// remove additional " if present
+					ch.ocCacheID = SafeXML.replace(ch.ocCacheID,"\"", null);
 					cacheDB.add(ch);
 				} else if (text.indexOf("<CENTRE")>=0) { // lat=  lon=
 					int start=text.indexOf("lat=\"")+5;
@@ -161,6 +166,9 @@
 				}
 			}
 			in.close();
+			// Build references between caches and addi wpts
+			CacheHolder.buildReferences(cacheDB);
+			
 		} catch (FileNotFoundException e) {
 			Vm.debug("index.xml not found"); // Normal when profile is opened for first time
 			//e.printStackTrace();

Modified: trunk/src/CacheWolf/SafeXML.java
===================================================================
--- trunk/src/CacheWolf/SafeXML.java	2007-01-06 23:44:58 UTC (rev 350)
+++ trunk/src/CacheWolf/SafeXML.java	2007-01-07 10:41:40 UTC (rev 351)
@@ -435,7 +435,7 @@
 		 *   @param  f  String to look for.
 		 *   @param  r  String to replace it with, or null to just remove it.
 		 */ 
-		private static String replace( String s, String f, String r )
+		public static String replace( String s, String f, String r )
 		{
 		   if (s == null)  return s;
 		   if (f == null)  return s;



From kalli at mail.berlios.de  Sun Jan  7 11:45:17 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 7 Jan 2007 11:45:17 +0100
Subject: [Cachewolf-svn] r352 - in trunk: resources src/CacheWolf
Message-ID: <200701071045.l07AjHp8010112@sheep.berlios.de>

Author: kalli
Date: 2007-01-07 11:45:13 +0100 (Sun, 07 Jan 2007)
New Revision: 352

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Feature Request #2997: 
- Addi wpts werden jetzt immer unter dem Hauptcache angezeigt
- Wird der Hauptcache selektiert (Haken), werden auch die addi wpts mit selektiert



Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-07 10:41:40 UTC (rev 351)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-07 10:45:13 UTC (rev 352)
@@ -161,8 +161,6 @@
 		1014=Aktualisieren
 		1015=Alle w%e4hlen
 		1016=Alle abw%e4hlen
-		1017=Alle add. Wpts
-		1018=Sel. add. Wpts
 		1019=Zentrum
 		1100=Profile
 		1101=Profil 1
@@ -398,8 +396,6 @@
 		1014=Update
 		1015=Select all
 		1016=De-select all
-		1017=All add. wpts
-		1018=Sel. add. Wpts
 		1019=Center
 		1100=Profiles
 		1101=Profile 1

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-07 10:41:40 UTC (rev 351)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-07 10:45:13 UTC (rev 352)
@@ -64,6 +64,8 @@
   public boolean is_selected = false;
   public boolean is_HTML = true;
   public boolean is_Checked = false;
+  public Vector addiWpts = new Vector();
+  public CacheHolder mainCache;
     
   
   /**
@@ -410,7 +412,7 @@
 	}
 	
 	/**
-	 * Method foch checking if to caches belongs to each other, e.g.
+	 * Method for checking if to caches belongs to each other, e.g.
 	 * an additional waypoint belongs to the main cache.
 	 * Works currently only, if the last 4 or 5 chars of the waypoint are
 	 * the same, this is the gc.com way. 
@@ -425,6 +427,45 @@
 		return this.wayPoint.endsWith(ch.wayPoint.substring(2));
 	}
 	
+   
+   public boolean isAddiWpt(){
+	   return CacheType.isAddiWpt(this.type);
+   }
+   
+   public boolean hasAddiWpt() {
+	   if (this.addiWpts.getCount()>0) return true;
+	   else return false;
+   }
+   
+   public static void buildReferences(Vector cacheDB){
+	   CacheHolder ch, mainCh;
+	   Hashtable dbIndex = new Hashtable();
+	   Integer index;
+	   // Build index for faster search and clear all references
+	   for(int i = 0; i<cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.addiWpts.clear();
+			ch.mainCache = null;
+			dbIndex.put((String)ch.wayPoint, new Integer(i));
+	   }
+	   // Build refeneces
+	   for(int i = 0; i<cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.isAddiWpt()) {
+				//search main cache
+				if (ch.wayPoint.length() == 5){
+					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(1));
+				} 
+				else {
+					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
+				}
+				if (index != null) {
+					mainCh = (CacheHolder) cacheDB.get(index.intValue());
+					mainCh.addiWpts.add(ch);
+					ch.mainCache = mainCh;
+				}// if
+			}// if
+	   }// for
+   }
   
-  
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-07 10:41:40 UTC (rev 351)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-07 10:45:13 UTC (rev 352)
@@ -49,7 +49,7 @@
 */		
 		addLast(new ScrollBarPanel(tc = new myTableControl()));
 		addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1019,"Center"),MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),MyLocale.getMsg(1018,"Sel. add. wpts."),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all"),MyLocale.getMsg(1017,"All add. wpts")},MyLocale.getMsg(1013,"With selection"));
+		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1019,"Center"),"-",MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all")},MyLocale.getMsg(1013,"With selection"));
 		tc.setMenu(m);
 		tc.profile=profile;
 		tc.db = cacheDB;
@@ -94,6 +94,7 @@
 		updateBearingDistance(cacheDB, pref);
 		////Vm.debug("IS mypref loaded? " + myPreferences.mylgDeg);
 		// tc.setTableModel(myMod); Not needed ?
+		myMod.updateRows();
 		tc.update(true);
 		statBar.updateDisplay();
 	}

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-07 10:41:40 UTC (rev 351)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-07 10:45:13 UTC (rev 352)
@@ -43,31 +43,6 @@
 			}
 			tbp.refreshTable();
 		}
-
-		if (selectedItem.toString().equals(MyLocale.getMsg(1017,"All add. wpts"))){
-			for(int i = 0; i <	db.size(); i++){
-				ch = (CacheHolder)db.get(i);
-				if (CacheType.isAddiWpt(ch.type))ch.is_Checked = true;
-				//db.set(i, ch);
-			}
-			tbp.refreshTable();
-		}
-
-		if (selectedItem.toString().equals(MyLocale.getMsg(1018,"Sel. add. wpts."))){
-			CacheHolder ch_addi;
-			for(int i = 0; i <	db.size(); i++){
-				ch = (CacheHolder)db.get(i);
-				if (ch.is_Checked && !CacheType.isAddiWpt(ch.type)){
-					// search addi wpts to main cache
-					for (int j = 0; j < db.size(); j++){
-						ch_addi = (CacheHolder)db.get(j);
-						if (ch_addi.belongsTo(ch))ch_addi.is_Checked = true;
-					}
-				}
-			}
-			tbp.refreshTable();
-		}
-
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1011,"Filter"))){
 			for(int i = 0; i <	db.size(); i++){
@@ -125,6 +100,7 @@
 			tbp.myGotoPanel.setDestination((ch.LatLon));
 //this.getSelectedCell(((Menu)selectedItem).curPoint)..LatLon
 		}
+
 	}
 	
 	public void  penDoubleClicked(Point where) {

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-07 10:41:40 UTC (rev 351)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-07 10:45:13 UTC (rev 352)
@@ -28,6 +28,7 @@
 	FontMetrics fm;
 	String nmCheck, nmQuest, nmD,nmT,nmWay,nmName,nmLoc,nmOwn,nmHid,nmStat,nmDist,nmBear = new String();
 	Image checkboxTicked,checkboxUnticked;
+	static Color RED = new Color(255,0,0);
 	
 	public myTableModel(myTableControl tc, FontMetrics fm){
 		super();
@@ -91,6 +92,7 @@
 		bug = new mImage("bug.png");
 		checkboxTicked = new Image("checkboxTicked.png");
 		checkboxUnticked= new Image("checkboxUnticked.png");
+		updateRows();
 	}
 	
 	/**
@@ -131,19 +133,36 @@
 	//}
 	
 	public void updateRows(){
-		this.numRows = cacheDB.size();
-		int counter = 0;
-		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.is_filtered == true) counter++;
+		Vector sortDB = new Vector();
+		Vector filteredDB = new Vector();
+		CacheHolder ch, addiWpt;
+		// sort cacheDB:
+		// - addi wpts are listet behind the main cache
+		// - filtered caches are moved to the end
+		for (int i=0; i<cacheDB.size(); i++){
+			ch = (CacheHolder) cacheDB.get(i);
+			if (ch.is_filtered) {
+				filteredDB.add(ch);
+			} else {
+				if (ch.isAddiWpt()){
+					// check if main wpt is filtered
+					if (ch.mainCache.is_filtered) sortDB.add(ch);
+				} else {
+					sortDB.add(ch);
+					if (ch.hasAddiWpt()){
+						for (int j=0; j<ch.addiWpts.getCount();j++){
+							addiWpt = (CacheHolder)ch.addiWpts.get(j);
+							if (!addiWpt.is_filtered) sortDB.add(addiWpt);
+						}
+					}// if hasAddiWpt
+				} // if AddiWpt
+			} // if filtered
 		}
-		//Vm.debug("Counter: " + Convert.toString(counter));
-		if(counter > 0){
-			this.numRows = this.numRows - counter;
-			cacheDB.sort(new MyComparer("filter"), false);
-		}
-		 
+		// rebuild database
+		cacheDB.clear();
+		cacheDB.addAll(sortDB);
+		cacheDB.addAll(filteredDB);
+		this.numRows = sortDB.getCount();
 	}
 	
 	/**
@@ -211,7 +230,6 @@
 	public Object getCellData(int row, int col){
 		IconAndText wpVal = new IconAndText(); //(IImage)bug, "Test Me", fm);
 		Object rettext = new Object();
-		int collector = 0;
 			if(row == -1) {
 				rettext = (String)colName[col];
 			}
@@ -232,7 +250,7 @@
 								if (ch.is_Checked) rettext=checkboxTicked; 
 								else rettext=checkboxUnticked;
 							}
-							if(colName[col].equals(nmQuest)) rettext = (IImage)cacheImages[Convert.parseInt(ch.type)];				
+							if(colName[col].equals(nmQuest)) rettext = (IImage) cacheImages[Convert.parseInt(ch.type)];
 							if(colName[col].equals(nmD)) rettext = (String)ch.hard;
 							if(colName[col].equals(nmT)) rettext = (String)ch.terrain;
 							if(colName[col].equals(nmWay)){
@@ -258,7 +276,9 @@
 								wpVal.addColumn(rettext);
 								rettext = wpVal;
 							}
-							if(colName[col].equals(nmLoc)) rettext = (String)ch.LatLon;
+							if(colName[col].equals(nmLoc)) {
+								rettext = (String)ch.LatLon;
+							}
 							if(colName[col].equals(nmOwn)) rettext = (String)ch.CacheOwner;
 							if(colName[col].equals(nmHid)) rettext = (String)ch.DateHidden;
 							if(colName[col].equals(nmStat)) rettext = (String)ch.CacheStatus;
@@ -281,6 +301,19 @@
 			if (cell.y>=0 && cell.x==0) {
 				CacheHolder ch = (CacheHolder)cacheDB.get(cell.y);
 				ch.is_Checked= !ch.is_Checked;
+				// set the ceckbox also for addi wpts
+				if (ch.hasAddiWpt()){
+					CacheHolder addiWpt;
+					int off = 1;
+					for (int i=0;i<ch.addiWpts.getCount();i++){
+						addiWpt = (CacheHolder)ch.addiWpts.get(i);
+						addiWpt.is_Checked = ch.is_Checked;
+						if (!addiWpt.is_filtered){
+							tcControl.repaintCell(cell.y + off++, 0);
+						}
+					}
+					
+				}
 				updateRows();
 				// Don't consume the event. Why ?
 			}
@@ -339,9 +372,8 @@
 	
 	private int getCacheIndex(String wp){
 		int retval = -1;
-		CacheHolder ch = new CacheHolder();
+		CacheHolder ch;
 		for(int i = 0; i<cacheDB.size();i++){
-			ch = new CacheHolder();
 			ch = (CacheHolder)cacheDB.get(i);
 			if(ch.wayPoint.equals(wp)){
 				return i;



From admin at berlios.de  Sun Jan  7 11:46:06 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 7 Jan 2007 11:46:06 +0100 (CET)
Subject: [Feature #2997] Filter für addi wpts
Message-ID: <200701071046.l07Ak6jR014739@unicorn.berlios.de>

Feature Request #2997, was updated on 2006-Dec-28 19:53
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2997&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Filter f?r addi wpts

By: kalli
Date: 2007-Jan-07 11:46

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

L?sung
- Addi wpts werden jetzt immer unter dem Hauptcache 
angezeigt
- Wird der Hauptcache selektiert (Haken), werden auch 
die addi wpts mit selektiert


----------------------------------------------------------------------

By: kalli
Date: 2006-Dec-28 19:53

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

siehe http://www.geoclub.de/ftopic13172.html

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2997&group_id=2211


From admin at berlios.de  Sun Jan  7 12:24:39 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 7 Jan 2007 12:24:39 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2967] GPS-Genauigkeit anzeigen
Message-ID: <200701071124.l07BOdPe016915@unicorn.berlios.de>

Feature Request #2967, was updated on 2006-Dec-12 21:38
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2967&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: GPS-Genauigkeit anzeigen

By: kalli
Date: 2006-Dec-12 21:38

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

siehe http://www.geoclub.de/ftopic12927.html

Erste L?sung: HDOP wird im Goto-Panel mit 
angegeben.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2967&group_id=2211


From kalli at mail.berlios.de  Sun Jan  7 12:51:45 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 7 Jan 2007 12:51:45 +0100
Subject: [Cachewolf-svn] r353 - trunk/src/CacheWolf
Message-ID: <200701071151.l07BpjnY027355@sheep.berlios.de>

Author: kalli
Date: 2007-01-07 12:51:36 +0100 (Sun, 07 Jan 2007)
New Revision: 353

Modified:
   trunk/src/CacheWolf/MainTab.java
Log:
Feature Request #2203: Statusaenderungen im Detailspanel werden auf dei addi wpts uebertragen.

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-07 10:45:13 UTC (rev 352)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-07 11:51:36 UTC (rev 353)
@@ -119,6 +119,16 @@
 					  if(pref.myAlias.equals(ch.CacheOwner)) ch.is_owned = true;
 					  ch.CacheNotes = detP.wayNotes.getText();
 					  ch.type = detP.transSelect(detP.wayType.getInt());
+					  // set status also on addi wpts
+					  if (ch.hasAddiWpt()){
+						  CacheHolder addiWpt;
+						  for (int i=0;i<ch.addiWpts.getCount();i++){
+							  addiWpt = (CacheHolder)ch.addiWpts.get(i);
+							  addiWpt.CacheStatus = ch.CacheStatus;
+							  addiWpt.is_found = ch.is_found;
+							  addiWpt.is_owned = ch.is_owned;
+						  }
+					  }
 					  cDB.set(tbP.getSelectedCache(), ch);
 					  detP.dirty_status = false;
 					  tbP.refreshTable();



From kalli at mail.berlios.de  Sun Jan  7 13:04:44 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 7 Jan 2007 13:04:44 +0100
Subject: [Cachewolf-svn] r354 - trunk/src/CacheWolf
Message-ID: <200701071204.l07C4ibn008037@sheep.berlios.de>

Author: kalli
Date: 2007-01-07 13:04:41 +0100 (Sun, 07 Jan 2007)
New Revision: 354

Modified:
   trunk/src/CacheWolf/MainForm.java
Log:
Debugmessage fuer Ladezeit der index.xml rausgenommen.

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-07 11:51:36 UTC (rev 353)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-07 12:04:41 UTC (rev 354)
@@ -50,7 +50,6 @@
 			addGuiFont();
 			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
 				ewe.sys.Vm.exit(0); // User MUST select or create a profile
-			long start = Vm.getTimeStampLong();
 			Vm.showWait(true);
 			InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
 			infB.exec();
@@ -58,8 +57,6 @@
 			infB.close(0);
 			Vm.showWait(false);
 			pref.curCentrePt.set(profile.centre);
-			long end = Vm.getTimeStampLong();
-			Vm.debug("index.xml read: " + Convert.toString(end - start)+ " msec");
 			TablePanel.updateBearingDistance(profile.cacheDB,pref);
 		} catch (Exception e){
 			if(pref.debug == true) Vm.debug("MainForm:: Exception:: " + e.toString());



From salzkammergut at mail.berlios.de  Sun Jan  7 17:25:02 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Jan 2007 17:25:02 +0100
Subject: [Cachewolf-svn] r356 - trunk/src/CacheWolf
Message-ID: <200701071625.l07GP2EM028489@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-07 17:24:58 +0100 (Sun, 07 Jan 2007)
New Revision: 356

Modified:
   trunk/src/CacheWolf/ImagePanel.java
   trunk/src/CacheWolf/ImagePanelImage.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Preferences.java
Log:
Cachebilder und Benutzerbilder koennen in ImagePanel jetzt auch mit rechter Maustaste geloescht werden um Platz zu sparen.
Geloeschte Bilder koennen ueber eine Option in pref.xml ausgeblendet werden (muss noch in PreferencesScreen nachgetragen werden).

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2007-01-07 14:17:39 UTC (rev 355)
+++ trunk/src/CacheWolf/ImagePanel.java	2007-01-07 16:24:58 UTC (rev 356)
@@ -3,6 +3,8 @@
 import ewe.sys.*;
 import ewe.fx.*;
 import ewe.ui.*;
+import ewe.io.*;
+import ewe.util.*;
 
 
 /**
@@ -10,23 +12,28 @@
 *	allows the user to click on an image that will then be displayed in its original size
 *	as long as the image fits the application size. If the application size is not sufficient
 *	then the image will be scaled to the available screen size.
+*   A right mouseclick on an image will open a dialogue to delete the file. 
 */
 public class ImagePanel extends InteractivePanel{
+	/** Picture to replace deleted pictures */
+	private final String NO_IMAGE="no_picture.png";
+	/** Minimum time (msec) to recognize a long pen down event (=right mouse key) */
+	private final int LONG_PEN_DOWN_DURATION=500;
+
 	Preferences pref;
 	Profile profile;
+	//private final int thumb_max_size = 300;
+	//private final int thumb_min_size = 100;
+	private final int padding = 20;
+	private int thumb_size = 0;
+	private int locX, locY, locCounter;
+	/** Start and duration of pen-pressed event to simulate right mouse key */
+	private long start, duration=0;
 	
-	int thumb_max_size = 300;
-	int thumb_min_size = 100;
-	int padding = 20;
-	int thumb_size = 0;
 	/**
 	* Constructor to create the image panel.<p>
-	* Also calculates the possible sizes for the
-	* thumbnail view.
 	*/
-	public ImagePanel(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
+	public ImagePanel(){
 	}
 	
 	/**
@@ -35,17 +42,12 @@
 	* @see MainTab#onEvent(Event ev)
 	*/
 	public void setImages(CacheHolder cache){
-		String imgText = new String();
-		AniImage AimgText;
-		double dummyC = 0;
+		pref = Global.getPref();
+		profile=Global.getProfile();
 		Vm.showWait(true);
-		ImageList liste = images;
+		clearImages();
 		thumb_size = (int)((pref.myAppWidth-2*padding) / 3);
 		thumb_size = thumb_size - padding;
-		int lgr = liste.size();
-		for(int i = 0; i<lgr;i++){
-			this.removeImage((AniImage)liste.get(0));
-		}
 		int rowCounter = cache.Images.size() + cache.UserImages.size();
 		rowCounter = (int)(rowCounter/3)+1;
 		Rect r = new Rect(new Dimension(pref.myAppWidth,rowCounter*thumb_size+rowCounter*padding+padding));
@@ -53,13 +55,45 @@
 		//this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
 		this.checkScrolls();
 		this.refresh();
+		addTitle(MyLocale.getMsg(340,"Cache Images:"));
+		locY = 20;
+		locX = padding;
+		addImages(cache.Images,cache.ImagesText);
+		// load user images
+		if(locCounter==1 || locCounter ==2) locY = locY + thumb_size;
+		//Vm.debug("thumb_size: " + Convert.toString(thumb_size));
+		//Vm.debug("locy after: " + Convert.toString(locY));
+		addTitle(MyLocale.getMsg(341,"User Images:"));
+		locY = locY + 20;
+		locX = padding;
+		locCounter = 0;
+		addImages(cache.UserImages,cache.UserImagesText);
+		
+		this.refresh();
+		Vm.showWait(false);
+		//this.repaintNow();
+	}
+
+	/**
+	 * Clear the images in the panel
+	 *
+	 */
+	private void clearImages() {
+		int lgr = images.size();
+		for(int i = 0; i<lgr;i++){
+			this.removeImage((AniImage)images.get(0));
+		}
+	}
+	
+	/**
+	 * Add a title above the cache images and above the user images
+	 * @param title Title to add ("cache images" or "user images")
+	 */
+	private void addTitle(String title) {
 		AniImage aImg;
-		String location = new String();
 		Font font = new Font("Verdana", Font.BOLD, 20);
 		FontMetrics fm = getFontMetrics();
-		
-		// load cache images
-		int stringWidth = fm.getTextWidth("Cache Images");
+		int stringWidth = fm.getTextWidth(title);
 		int stringHeight = fm.getHeight();
 		Image img = new Image(stringWidth*2,stringHeight+5);
 		Graphics g = new Graphics(img);
@@ -67,20 +101,32 @@
 		g.fillRect(0,0,stringWidth*2,stringHeight+5);
 		g.setColor(new Color(0,0,0));
 		g.setFont(font);
-		g.drawText("Cache Images:", 0,0);
+		g.drawText(title, 0,0);
 		g.free();
 		aImg = new AniImage(img);
 		addImage(aImg);
 		aImg.refresh();
+	}
+	
+	/**
+	 * Add the images to the panel. Can add both normal and user images
+	 * @param images Vector of images or userImages
+	 * @param imagesText Vector of image texts or user image texts
+	 */
+	private void addImages(Vector images, Vector imagesText) {
+		String location, imgText;
 		mImage mI;
-		int locX, locY;
-		int scaleX, scaleY = 0;
-		locY = 20;
-		locX = padding;
-		int locCounter = 0;
+		int scaleX, scaleY;
+		double dummyC;
 		ImagePanelImage ipi;
-		for(int i = 0; i<cache.Images.size(); i++){
-			location = profile.dataDir + (String)cache.Images.get(i);
+		AniImage AimgText;
+		
+		for(int i = 0; i<images.size(); i++){
+			location = profile.dataDir + (String)images.get(i);
+			if (!(new File(location)).exists()) {
+				location=NO_IMAGE;
+				if (!pref.showDeletedImages) continue; // Don't show the deleted Image if user does not want it
+			}
 			try{
 				mI = new mImage(location);
 				// actuall new mImage(location); should do the following "if" but it doesn't anyhow
@@ -107,18 +153,21 @@
 				mI = mI.scale(scaleX,scaleY,null,0);
 				ipi = new ImagePanelImage(mI);
 				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
-
 				ipi.setLocation(locX, locY);
 				addImage(ipi);
 				//Name of picture:
-				if(cache.ImagesText.size()>i){
-					imgText = SafeXML.cleanback((String)cache.ImagesText.get(i));
+				if(imagesText.size()>i){
+					if (location.equals(NO_IMAGE))
+						imgText=MyLocale.getMsg(342,"Deleted");
+					else
+						imgText = SafeXML.cleanback((String)imagesText.get(i));
 					if(imgText.length()==0) imgText = "???";
 					AimgText = new AniImage();
 					AimgText = getImageText(imgText);
 					AimgText.setLocation(locX,locY+scaleY);
 					addImage(AimgText);
 					AimgText.refresh();
+					ipi.imageText = imgText; 
 				}
 				ipi.refresh();
 				locX = locX + thumb_size + padding;
@@ -130,103 +179,15 @@
 					locY = locY+thumb_size+padding;
 				}
 			}catch(IllegalArgumentException imex){ // file not found, could not decode etc.
-				Locale l = Vm.getLocale();
-				LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-				MessageBox tmp = new MessageBox((String)lr.get(321,"Fehler"), (String)lr.get(322,"Kann Bild/Karte nicht laden")+":\n"+imex.getMessage(), MessageBox.OKB); // @todo: language support
+				MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht laden")+":\n"+imex.getMessage(), MessageBox.OKB); // @todo: language support
 				tmp.exec();
 			} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox("Error","Not enough free memory to load cache image:\n"+location,MessageBox.OKB)).exec();
+				(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+":\n"+location,MessageBox.OKB)).exec();
 			} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox("Error","Not enough free memory to load cache image:\n"+location,MessageBox.OKB)).exec();
+				(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+"\n"+location,MessageBox.OKB)).exec();
 			}
 		} //for
-		//Vm.debug("LocCounter: " +Convert.toString(locCounter));
-		//Vm.debug("locy before: " + Convert.toString(locY));
 		
-		// load user images
-		if(locCounter==1 || locCounter ==2) locY = locY + thumb_size;
-		//Vm.debug("thumb_size: " + Convert.toString(thumb_size));
-		//Vm.debug("locy after: " + Convert.toString(locY));
-		stringWidth = fm.getTextWidth("User Images");
-		Image img2 = new Image(stringWidth*2,stringHeight+5);
-		Graphics g2 = new Graphics(img2);
-		g2.setColor(new Color(195,195,195));
-		g2.fillRect(0,0,stringWidth*2,stringHeight+5);
-		g2.setColor(new Color(0,0,0));
-		g2.setFont(font);
-		g2.drawText("User Images:", 0,0);
-		g2.free();
-		aImg = new AniImage(img2);
-		aImg.setLocation(0, locY);
-		addImage(aImg);
-		aImg.refresh();
-		locY = locY + 20;
-		locX = padding;
-		locCounter = 0;
-		for(int i = 0; i<cache.UserImages.size(); i++){
-			location = profile.dataDir + (String)cache.UserImages.get(i);
-			//Vm.debug(location);
-			try{
-				mI = new mImage(location);
-				if (mI.getWidth() <= 0 || mI.getHeight() <= 0 ) throw new IllegalArgumentException(location);
-				scaleX = thumb_size;
-				scaleY = thumb_size;
-				dummyC = 0;
-				if(mI.getWidth()>mI.getHeight()){
-					scaleX = thumb_size;
-					dummyC = (double)mI.getHeight()/ (double)mI.getWidth();
-					dummyC = dummyC * (double)thumb_size;
-					scaleY = (int)dummyC;
-				}
-				if(mI.getWidth() <= mI.getHeight()){
-					scaleY = thumb_size;
-					dummyC = (double)mI.getWidth()/(double)mI.getHeight();
-					dummyC = dummyC * (double)thumb_size;
-					scaleX = (int)dummyC;
-				}
-				if(mI.getWidth() <= thumb_size){
-					scaleX = mI.getWidth();
-					scaleY = mI.getHeight();
-				}
-				mI = mI.scale(scaleX,scaleY,null,0);
-				ipi = new ImagePanelImage(mI);
-				ipi.fileName = location;
-				ipi.setLocation(locX, locY);
-				addImage(ipi);
-				//Name of picture:
-				if(cache.UserImagesText.size()>i){
-					imgText = (String)cache.UserImagesText.get(i);
-					if(imgText.length()==0) imgText = "???";
-					AimgText = new AniImage();
-					AimgText = getImageText(imgText);
-					AimgText.setLocation(locX,locY+scaleY);
-					addImage(AimgText);
-					AimgText.refresh();
-				}
-				ipi.refresh();
-				locX = locX + thumb_size + padding;
-				locCounter++;
-				if(locCounter > 2) {
-					locCounter = 0;
-					locX = padding;
-					locY = locY+thumb_size+padding;
-				}
-			}catch(IllegalArgumentException imex){ // file not found, could not decode etc.
-				Locale l = Vm.getLocale();
-				LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-				MessageBox tmp = new MessageBox((String)lr.get(321,"Fehler"), (String)lr.get(322,"Kann Bild/Karte nicht laden")+":\n"+imex.getMessage(), MessageBox.OKB); // @todo: language support
-				tmp.exec();
-			} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing 
-				(new MessageBox("Error","Not enough free memory to load user image:\n"+location,MessageBox.OKB)).exec();
-			} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox("Error","Not enough free memory to load cache image:\n"+location,MessageBox.OKB)).exec();
-			}
-		} //for
-		
-		
-		this.refresh();
-		Vm.showWait(false);
-		//this.repaintNow();
 	}
 	
 	private AniImage getImageText(String text){
@@ -245,29 +206,59 @@
 		AniImage a = new AniImage(img);
 		return a;
 	}
+
+	
 	/**
 	* React to when a user clicks an image.
-	* Will open a new window displaying the image scaled
-	* to window size if the image is larger, otherwise
-	* the true size is displayed.
+	* If left mouse key is clicked, will open a new window displaying the image scaled
+	* to window size if the image is larger, otherwise the true size is displayed.
+	* If right mouse key is clicked, a dialogue to delete the image wil be displayed
 	*/
 	public void imageClicked(AniImage which, Point pos){
-		String fn = new String();
-		if(which instanceof ImagePanelImage){
-			ImagePanelImage ich = (ImagePanelImage)which;
-			fn = ich.fileName;
-			try {
-				ImageDetailForm iF = new ImageDetailForm(fn, pref);
-				iF.execute(null, Gui.CENTER_FRAME);
-			} catch (IllegalArgumentException e) {
-				Locale l = Vm.getLocale();
-				LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-				MessageBox tmp = new MessageBox((String)lr.get(321,"Fehler"), (String)lr.get(322,"Kann Bild/Karte nicht finden"), MessageBox.OKB); // @todo: language support
-				tmp.exec();
-			} catch (OutOfMemoryError e) {
-				(new MessageBox("Error","Not enough free memory to load image\n"+fn,MessageBox.OKB)).exec();
+//		Vm.debug("Clicked"+pos.x+","+pos.y+" "+(((Control.currentPenEvent.modifiers&PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON)?"RIGHT":"LEFT") );
+		if ((Control.currentPenEvent.modifiers&PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON || duration>LONG_PEN_DOWN_DURATION) {
+			// Right button pressed - delete image to conserve space
+			if (which instanceof ImagePanelImage && !((ImagePanelImage)which).fileName.equals(NO_IMAGE)) {
+				MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(344,"Delete image")+" \""+((ImagePanelImage)which).imageText+"\"?", MessageBox.IDYES |MessageBox.IDNO);
+				if (mBox.execute() == MessageBox.IDOK){
+						//Vm.debug("Deleting "+((ImagePanelImage)which).fileName);
+						try {
+							File f=new File(((ImagePanelImage)which).fileName);
+							f.delete();
+							removeImage(which);
+						} catch(Exception e) {};
+				}
 			}
-			
+		} else { 
+			String fn = new String();
+			if(which instanceof ImagePanelImage){
+				ImagePanelImage ich = (ImagePanelImage)which;
+				fn = ich.fileName;
+				try {
+					ImageDetailForm iF = new ImageDetailForm(fn, pref);
+					iF.execute(null, Gui.CENTER_FRAME);
+				} catch (IllegalArgumentException e) {
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht finden"), MessageBox.OKB); // @todo: language support
+					tmp.exec();
+				} catch (OutOfMemoryError e) {
+					(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+"\n"+fn,MessageBox.OKB)).exec();
+				}
+			}
 		}
 	}
-}
+
+	/**
+	 * Create a "pen held down" event on hardware that does not support a right mouse key (e.g. Windows Mobile)
+	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate 
+	 * between left and right mouse keys.
+	 */
+	public void onPenEvent(PenEvent ev) {
+		if (ev.type==PenEvent.PEN_DOWN) {
+			start = Vm.getTimeStampLong();
+		}
+		if (ev.type==PenEvent.PEN_UP) {
+			duration=Vm.getTimeStampLong()-start;
+		}
+		super.onPenEvent(ev);
+	}
+}
\ No newline at end of file

Modified: trunk/src/CacheWolf/ImagePanelImage.java
===================================================================
--- trunk/src/CacheWolf/ImagePanelImage.java	2007-01-07 14:17:39 UTC (rev 355)
+++ trunk/src/CacheWolf/ImagePanelImage.java	2007-01-07 16:24:58 UTC (rev 356)
@@ -10,6 +10,7 @@
 */
 public class ImagePanelImage extends AniImage{
 	public String fileName = new String();
+	public String imageText = null;
 	public ImagePanelImage(mImage i){
 		super(i);
 	}

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-07 14:17:39 UTC (rev 355)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-07 16:24:58 UTC (rev 356)
@@ -47,7 +47,7 @@
 		c = this.addCard(descP, MyLocale.getMsg(1202,"Description"), null);
 		c.iconize(new Image("descr.gif"),true);
 		
-		c = this.addCard(new ScrollBarPanel(imageP = new ImagePanel(pref, profile)), MyLocale.getMsg(1203,"Images"), null);
+		c = this.addCard(new ScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203,"Images"), null);
 		c.iconize(new Image("images.gif"),true);
 		
 		c = this.addCard(hintLP, MyLocale.getMsg(1204,"Hints & Logs"), null);

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-07 14:17:39 UTC (rev 355)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-07 16:24:58 UTC (rev 356)
@@ -42,6 +42,7 @@
 	public String myAlias2 = new String();
 	/** The path to the browser */
 	public String browser = new String();
+	public boolean showDeletedImages=true; /* Used in ImagePanel */
 		
 	public int myAppHeight = 0;
 	public int myAppWidth = 0;
@@ -181,61 +182,6 @@
 		savePreferences();
 		return true;
 		
-/*		
-		//Check if there are "profiles" entries. If yes display a form
-		//so the user may choose a profile.
-		try{
-		if(showProfileSelector){
-			if(profiles[0].equals("null")) profiles[0] = "";
-			if(profiles[1].equals("null")) profiles[1] = "";
-			if(profiles[2].equals("null")) profiles[2] = "";
-			if(profiles[3].equals("null")) profiles[3] = "";
-			if(profiles[0].length()>0 ||
-			   profiles[1].length()>0 ||
-			   profiles[2].length()>0 ||
-			   profiles[3].length()>0){
-				   Vm.showWait(false);
-				   Form f = new ProfilesForm(profiles);
-				   int code = f.execute(); // 0 for cancel, 1-4 for profile
-				   currProfile = code;
-				   Vm.showWait(true);
-				   if(code > 0){
-					   if(profiles[code-1].length()>0){
-							mydatadir = profdirs[code-1];
-							if(lastSyncOC[code-1] == null || lastSyncOC[code-1].endsWith("null")){
-								last_sync_opencaching = "20050801000000";
-							}
-							else {
-								last_sync_opencaching = lastSyncOC[code-1];
-							}
-							if(lastDistOC[code-1] == null || lastDistOC[code-1].endsWith("null")){
-								distOC = "0";
-							}
-							else {
-								distOC = lastDistOC[code-1];
-							}
-							curCentrePt.set(lats[code-1]+" "+longs[code-1]);
-							// Copy it into profile
-							prof.last_sync_opencaching=last_sync_opencaching;
-							prof.distOC=distOC;
-							prof.centre.set(lats[code-1]+" "+longs[code-1]);
-							prof.dataDir=profdirs[code-1];
-					   }
-				   } else {
-					   // No profile selected
-					   prof.dataDir=mydatadir;
-				   }
-				   //if(mydatadir.indexOf('.') > 0){
-				   //String cwd = File.getProgramDirectory();
-				   //mydatadir = cwd + "/" + mydatadir.substring(1, mydatadir.length()-2);
-				   //Vm.debug("Datadir? " + mydatadir);
-				   //}
-			   }
-		}
-		}catch(Exception e){
-			Vm.debug(e.toString());
-		}
-*/		
 	}
 	
 	/**
@@ -406,6 +352,9 @@
 			tmp = atts.getValue("width");
 			if (tmp != null) tableWidth[11] = Convert.parseInt(tmp);
 		}
+		if (name.equals("imagepanel")) {
+			showDeletedImages = Boolean.valueOf(atts.getValue("showdeletedimages")).booleanValue();
+		}
 	}
 
 	public void characters( char ch[], int start, int length )
@@ -473,6 +422,7 @@
 			outp.print("    <fixedsip state = \""+fixSIP+"\"/>\n");
 			outp.print("    <garmin connection = \""+garminConn+"\"/>\n");
 			outp.print("    <lastprofile autoreload=\""+autoReloadLastProfile+"\">"+lastProfile+"</lastprofile>\n"); //RB
+			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			// Obsolete data kept for backward compatibility
 			//outp.print("	<syncOC date = \"" + last_sync_opencaching + "\" dist = \"" + distOC +  "\"/>\n");



From admin at berlios.de  Sun Jan  7 17:31:30 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 7 Jan 2007 17:31:30 +0100 (CET)
Subject: [Feature #3021] Bilder löschen
Message-ID: <200701071631.l07GVUAD005658@unicorn.berlios.de>

Feature Request #3021, was updated on 2007-Jan-07 17:31
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3021&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: Bilder l?schen

By: salzkammergut
Date: 2007-Jan-07 17:31

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Cachebilder und Benutzerbilder koennen in ImagePanel
jetzt auch mit rechter Maustaste geloescht werden um
Platz zu sparen.
Geloeschte Bilder koennen ueber eine Option in pref.xml
ausgeblendet werden.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3021&group_id=2211


From admin at berlios.de  Sun Jan  7 17:31:50 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 7 Jan 2007 17:31:50 +0100 (CET)
Subject: [Feature #3021] Bilder löschen
Message-ID: <200701071631.l07GVocC005676@unicorn.berlios.de>

Feature Request #3021, was updated on 2007-Jan-07 17:31
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3021&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Bilder l?schen

By: salzkammergut
Date: 2007-Jan-07 17:31

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Cachebilder und Benutzerbilder koennen in ImagePanel
jetzt auch mit rechter Maustaste geloescht werden um
Platz zu sparen.
Geloeschte Bilder koennen ueber eine Option in pref.xml
ausgeblendet werden.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3021&group_id=2211


From salzkammergut at mail.berlios.de  Sun Jan  7 17:43:24 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Jan 2007 17:43:24 +0100
Subject: [Cachewolf-svn] r357 - trunk/src/CacheWolf
Message-ID: <200701071643.l07GhOOO030106@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-07 17:43:22 +0100 (Sun, 07 Jan 2007)
New Revision: 357

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
Ein vergessenes \n an <imagepanel />... angehaengt

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-07 16:24:58 UTC (rev 356)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-07 16:43:22 UTC (rev 357)
@@ -422,7 +422,7 @@
 			outp.print("    <fixedsip state = \""+fixSIP+"\"/>\n");
 			outp.print("    <garmin connection = \""+garminConn+"\"/>\n");
 			outp.print("    <lastprofile autoreload=\""+autoReloadLastProfile+"\">"+lastProfile+"</lastprofile>\n"); //RB
-			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>");
+			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			// Obsolete data kept for backward compatibility
 			//outp.print("	<syncOC date = \"" + last_sync_opencaching + "\" dist = \"" + distOC +  "\"/>\n");



From pfeffer at mail.berlios.de  Sun Jan  7 15:17:42 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 7 Jan 2007 15:17:42 +0100
Subject: [Cachewolf-svn] r355 - trunk/src/CacheWolf
Message-ID: <200701071417.l07EHgiN012475@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-07 15:17:39 +0100 (Sun, 07 Jan 2007)
New Revision: 355

Modified:
   trunk/src/CacheWolf/Common.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/TrackOverlay.java
   trunk/src/CacheWolf/TrackPoint.java
Log:
Tracks werden jetzt immer richtig angezeigt
Fehler bei Bilddateinamen beim download von Opencaching.de, die "?" enthielten wird "?" nun ersetzt, so dass kein Fehler mehr auftritt

Modified: trunk/src/CacheWolf/Common.java
===================================================================
--- trunk/src/CacheWolf/Common.java	2007-01-07 12:04:41 UTC (rev 354)
+++ trunk/src/CacheWolf/Common.java	2007-01-07 14:17:39 UTC (rev 355)
@@ -103,6 +103,10 @@
 		strBuf.append(strHex);
 		return strBuf.toString();
 	}
+	public static String ClearForFileName(String str) {
+		String ret = str.replace('?', '_');
+		return ret;
+	}
 
 
 }

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-07 12:04:41 UTC (rev 354)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-07 14:17:39 UTC (rev 355)
@@ -13,9 +13,6 @@
 import ewe.sys.Double;
 
 
-
-
-
 /**
  * Thread for reading data from COM-port
  *
@@ -28,7 +25,7 @@
 	boolean run, tcpForward;
 	Socket tcpConn;
 	String lastError = new String();
-	
+
 	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
 		try{
 			comSp = new SerialPort(spo);
@@ -65,7 +62,7 @@
 					String str = mString.fromAscii(comBuff, 0, comLength); 
 					if (tcpForward) {
 						try {
-						tcpConn.write(comBuff, 0, comLength);
+							tcpConn.write(comBuff, 0, comLength);
 						} catch (IOException e) { tcpForward = false; }
 					}
 					//Vm.debug(str);
@@ -77,7 +74,7 @@
 		myGPS.noData();
 		tcpConn.close();
 	}
-	
+
 	public void stop() {
 		run = false;
 		if (comSp != null) comSp.close();
@@ -94,20 +91,20 @@
 	public boolean run;
 	public int calldelay;
 	public GotoPanel ticked;
-	
+
 	public UpdateThread (GotoPanel gp, int cd) {
 		ticked = gp;
 		calldelay = cd;
 	}
-	
+
 	public void run () {
 		run = true;
 		while (run) {
 			try { sleep (calldelay);} catch (InterruptedException e) {}
-		  ticked.ticked();
+			ticked.ticked();
 		}
 	}
-	
+
 	public void stop() {
 		run = false;
 	}
@@ -115,10 +112,10 @@
 
 
 /**
-*	Class to create the panel which handles the connection to the GPS-device<br>
-*	Displays: current position,speed and bearing; relation to destination waypoint<br>
-*	Class ID: 1500
-*/
+ *	Class to create the panel which handles the connection to the GPS-device<br>
+ *	Displays: current position,speed and bearing; relation to destination waypoint<br>
+ *	Class ID: 1500
+ */
 
 
 public class GotoPanel extends CellPanel {
@@ -131,14 +128,14 @@
 	mCheckBox chkDMM, chkDMS, chkDD, chkUTM;
 	CheckBoxGroup chkFormat = new CheckBoxGroup();
 	int currFormat;
-	
+
 	mLabel lblPosition, lblSats, lblSpeed, lblBearMov, lblBearWayP, lblDist, lblHDOP;
 	mLabel lblSatsText, lblSpeedText, lblDirText, lblDistText, lblSunAzimut;
 	mLabel lblGPS, lblDST, lblCurr, lblWayP;
 	mLabel lblLog;
 	mCheckBox chkLog;
 	mInput inpLogSeconds;
-	
+
 	MainTab mainT;
 	Vector cacheDB;
 	DetailsPanel detP;
@@ -152,30 +149,30 @@
 	CellPanel roseP = new CellPanel();
 	CellPanel GotoP = new CellPanel();
 	CellPanel LogP = new CellPanel();
-	
+
 	SerialThread serThread;
 	UpdateThread tickerThread;
-	
+
 	ImageControl ic; 
-	
+
 	static Color RED = new Color(255,0,0);
 	static Color YELLOW = new Color(255,255,0);
 	static Color GREEN = new Color(0,255,0);
 	static Color BLUE = new Color(0,255,255);
-	
+
 	static Font BOLD = new Font("Arial", Font.BOLD, 14);
 
 	int centerX, centerY;
-	
+
 	int ticker = 0;
-	
+
 	boolean mapsLoaded = false;
 	public boolean runMovingMap = false;
 	Vector availableMaps = new Vector();
 	MapInfoObject tempMIO = new MapInfoObject();
 	MovingMap mmp;
 	Track currTrack;
-	
+
 	/**
 	 * Create GotoPanel 
 	 * @param Preferences 	global preferences
@@ -196,7 +193,7 @@
 		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		ButtonP.addNext(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		ButtonP.addLast(btnMap = new mButton("Map"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		
+
 		//Format selection for coords
 		FormatP.addNext(chkDD =new mCheckBox("d.d?"),CellConstants.DONTSTRETCH, CellConstants.WEST);
 		FormatP.addNext(chkDMM =new mCheckBox("d?m.m\'"),CellConstants.DONTSTRETCH, CellConstants.WEST);
@@ -209,7 +206,7 @@
 		chkUTM.setGroup(chkFormat);
 		currFormat = CWPoint.DMM;
 		chkFormat.selectIndex(currFormat);
-		
+
 		//Coords
 		CoordsP.addNext(lblGPS = new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblGPS.backGround = RED;
@@ -224,7 +221,7 @@
 		centerY = img.getHeight() / 2;
 		centerX = img.getWidth() / 2;
 		roseP.addLast(ic,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
-		
+
 		//Goto
 		//things from GPS
 		GotoP.addLast(lblCurr = new mLabel(MyLocale.getMsg(1501,"Current")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -238,7 +235,7 @@
 		GotoP.addLast(lblHDOP = new mLabel("HDOP: " + Convert.toString(gpsPosition.getHDOP())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblHDOP.font = BOLD;
 
-		
+
 		GotoP.addLast(lblSpeed = new mLabel(Convert.toString(gpsPosition.getSpeed())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblSpeed.font = BOLD;
 
@@ -251,10 +248,10 @@
 		lblWayP.font = BOLD;
 		GotoP.addLast(lblBearWayP = new mLabel("0"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblBearWayP.font = BOLD;
-		
+
 		GotoP.addLast(lblDist = new mLabel("0"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblDist.font = BOLD;
-		
+
 		LogP.addNext(lblLog = new mLabel("Log "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		LogP.addNext(chkLog = new mCheckBox(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		LogP.addNext(inpLogSeconds = new mInput("10"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -263,23 +260,16 @@
 		chkLog.useCross = true;
 		chkLog.setState(false);
 		inpLogSeconds.columns = 5;
-		
+
 		LogP.addNext(lblGPS = new mLabel("Sonne: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblGPS.backGround = YELLOW;
 		lblGPS.setTag(SPAN, new Dimension(2,1));
-		
+
 		LogP.addLast(lblSunAzimut = new mLabel("---"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.NORTH));
-		// for debuging
-		//Double sunAzimut = new Double();
-		//sunAzimut.set((getSunAzimut("060000","060806", 48.1, 11.6))); //wikipedia vergleich
-		//getSunAzimut("060000","060806", 48.1, 11.6))); //wikipedia vergleich
-		//sunAzimut.set((getSunAzimut("121336.000","130906",50.744 , 7.0933)));
-		//sunAzimut.set((getSunAzimut("121436.000","130906",50.744 , 7.0933)));
-		//lblSunAzimut.setText(l.format(Locale.FORMAT_PARSE_NUMBER,sunAzimut,"0.0") + " Grad");
 		lblSunAzimut.setText("---");
 		lblSunAzimut.font = BOLD;
 
-		
+
 		//add Panels
 		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
 		this.addLast(FormatP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
@@ -289,7 +279,7 @@
 		this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
 
 		// for debuging
-/*		CWGPSPoint myGPS;
+		/*		CWGPSPoint myGPS;
 		myGPS = new CWGPSPoint();
 		String ex = new String();
 		boolean test = false;
@@ -306,28 +296,28 @@
 		test = myGPS.examine("$GPGSV,4,2,13,29,72,289,38,26,63,296,41,09,12,259,35,18,14,324,*79");
 		test = myGPS.examine("$GPGSV,4,3,13,19,09,025,,17,06,138,,21,06,300,,37,29,171,40*7A");
 		test = myGPS.examine("$GPGSV,4,4,13,39,29,166,38*40");
-		*/
-		
+		 */
+
 		//while (true){
-//			int notinterpreted = 0;
-//					if (myGPS.examine("@??H @??H?@??HH???????H")) { notinterpreted = 0;} else notinterpreted++;
-//					if (notinterpreted > 5) myGPS.noInterpretableData();
-//					// myGPS.noInterpretableData();
-//				
-//
+//		int notinterpreted = 0;
+//		if (myGPS.examine("@??H @??H?@??HH???????H")) { notinterpreted = 0;} else notinterpreted++;
+//		if (notinterpreted > 5) myGPS.noInterpretableData();
+//		// myGPS.noInterpretableData();
+
+
 //		}	
-		}
-	
+	}
+
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
 	 * @param ctrl the control to paint on
 	 * @param moveDir degrees of movement
 	 * @param destDir degrees of destination waypoint
 	 */
-	
+
 	private void drawArrows(Control ctrl,double moveDir, double destDir, double sunAziumt){
 		Graphics g = ctrl.getGraphics();
-		
+
 		if (g != null) {
 			ctrl.repaintNow();
 			// draw only valid arrows
@@ -348,15 +338,15 @@
 	private void drawArrow(Graphics g, double angle, Color col) {
 		double angleRad;
 		int x, y;
-		
+
 		angleRad = angle * java.lang.Math.PI / 180;
 		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
 		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
 		g.setPen(new Pen(col,Pen.SOLID,3));
 		g.drawLine(centerX,centerY,x,y);
-		
+
 	}
-	
+
 	/**
 	 * set the coords of the destination  
 	 * @param dest destination
@@ -376,14 +366,10 @@
 		btnGoto.setText(toPoint.toString(currFormat));
 		mainT.select(this);
 	}
-	
+
 	/**
 	 * method which is called if a timer is set up  
-	 * 
 	 */ 
-	/**
-	 * 
-	 */
 	public void ticked() {
 		Double bearMov = new Double();
 		Double bearWayP = new Double();
@@ -394,101 +380,85 @@
 
 		//		Vm.debug("ticked");
 		int fix = gpsPosition.getFix();
-		//if(!runMovingMap){
-			lblSats.setText("Sats: " + Convert.toString(gpsPosition.getSats()));
-			lblHDOP.setText("HDOP: " + Convert.toString(gpsPosition.getHDOP()));
-			// display values only, if signal good
-			if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
-				//gpsPosition.printAll();
-				Vm.debug("currTrack.add: voher");
+		lblSats.setText("Sats: " + Convert.toString(gpsPosition.getSats()));
+		lblHDOP.setText("HDOP: " + Convert.toString(gpsPosition.getHDOP()));
+		// display values only, if signal good
+		if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
+			//gpsPosition.printAll();
+			//Vm.debug("currTrack.add: voher");
+			try {
 				currTrack.add(gpsPosition);
-				Vm.debug("currTrack.add: nachher");
-				lblPosition.setText(gpsPosition.toString(currFormat));
-				speed.set(gpsPosition.getSpeed());
-				lblSpeed.setText(MyLocale.formatDouble(speed,"0.0") + " km/h");
-				try { 
-					sunAzimut.set(getSunAzimut(gpsPosition.Time, gpsPosition.Date, gpsPosition.latDec, gpsPosition.lonDec));
-					lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,"0.0") + " Grad");
-				} catch (NumberFormatException e) { 
-					// irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf?gbar wenn es einen Fix gibt)
-					sunAzimut.set(500); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
-					lblSunAzimut.setText("---");
-				}//sunAzimut.set(getSunAzimut("141303","130906", 50.744, 7.0935));
+			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
+				currTrack = new Track(RED); 
+				currTrack.add(gpsPosition);
+				if (mmp != null) mmp.addTrack(currTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
+			}
+			//Vm.debug("currTrack.add: nachher");
+			lblPosition.setText(gpsPosition.toString(currFormat));
+			speed.set(gpsPosition.getSpeed());
+			lblSpeed.setText(MyLocale.formatDouble(speed,"0.0") + " km/h");
+			try { 
+				sunAzimut.set(getSunAzimut(gpsPosition.Time, gpsPosition.Date, gpsPosition.latDec, gpsPosition.lonDec));
+				lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,"0.0") + " Grad");
+			} catch (NumberFormatException e) { 
+				// irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf?gbar wenn es einen Fix gibt)
+				sunAzimut.set(500); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
+				lblSunAzimut.setText("---");
+			}//sunAzimut.set(getSunAzimut("141303","130906", 50.744, 7.0935));
 
-				bearMov.set(gpsPosition.getBear());
-				lblBearMov.setText(bearMov.toString(0,0,0) + " Grad");
-				bearWayP.set(gpsPosition.getBearing(toPoint));
-				lblBearWayP.setText(bearWayP.toString(0,0,0) + " Grad");
+			bearMov.set(gpsPosition.getBear());
+			lblBearMov.setText(bearMov.toString(0,0,0) + " Grad");
+			bearWayP.set(gpsPosition.getBearing(toPoint));
+			lblBearWayP.setText(bearWayP.toString(0,0,0) + " Grad");
 
-				dist.set(gpsPosition.getDistance(toPoint));
+			dist.set(gpsPosition.getDistance(toPoint));
 
-				if (dist.value >= 1){
-					lblDist.setText(MyLocale.formatDouble(dist,"0.000")+ " km");
-				}
-				else {
-					dist.set(dist.value * 1000);
-					lblDist.setText(dist.toString(3,0,0) + " m");
-				}
+			if (dist.value >= 1){
+				lblDist.setText(MyLocale.formatDouble(dist,"0.000")+ " km");
+			}
+			else {
+				dist.set(dist.value * 1000);
+				lblDist.setText(dist.toString(3,0,0) + " m");
+			}
 
-				drawArrows(ic,bearMov.value,bearWayP.value, sunAzimut.value);
+			drawArrows(ic,bearMov.value,bearWayP.value, sunAzimut.value);
 
-				// Set background to signal quality
-				lblSats.backGround = GREEN;
-				//return;
-			}
+			// Set background to signal quality
+			lblSats.backGround = GREEN;
+		}
 
-			// receiving data, but signal ist not good
-			if ((fix == 0) && (gpsPosition.getSats()>= 0)) {
-				lblSats.backGround = YELLOW;
-				//return;
+		// receiving data, but signal ist not good
+		if ((fix == 0) && (gpsPosition.getSats()>= 0)) {
+			lblSats.backGround = YELLOW;
+		}
+		// receiving no data
+		if (fix == -1) {
+			if (lblSats.backGround != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
+			lblSats.backGround = RED;
+			stopGPS();
+		}
+		// cannot interprete data
+		if (fix == -2) {
+			if (lblSats.backGround != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+gpsPosition.lastStrExamined, MessageBox.OKB)).exec();
+			lblSats.backGround = RED;
+			stopGPS();
+		}
+
+		// In moving map mode
+		if (mmp != null && runMovingMap ) { // neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
+			if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
+				Vm.debug("ShowLastAddedPoint: voher");
+				mmp.ShowLastAddedPoint(currTrack);
+				Vm.debug("ShowLastAddedPoint: nachher");
+				mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
+				mmp.setGpsStatus(MovingMap.gotFix);
 			}
-			// receiving no data
-			if (fix == -1) {
-				if (lblSats.backGround != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
-				lblSats.backGround = RED;
-				stopGPS();
-				//return;
+			if ((fix == 0) && (gpsPosition.getSats()== 0)) {
+				mmp.setGpsStatus(MovingMap.lostFix);
 			}
-			// cannot interprete data
-			if (fix == -2) {
-				if (lblSats.backGround != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+gpsPosition.lastStrExamined, MessageBox.OKB)).exec();
-				lblSats.backGround = RED;
-				stopGPS();
-				//return;
+			if (fix < 0 ) {
+				mmp.setGpsStatus(MovingMap.noGPSData);
 			}
-
-	//	}else{ // In moving map mode
-			if (mmp != null && runMovingMap ) { // neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
-//				currTrack.add(new CWPoint(50.71343, 007.09998));
-//				mmp.ShowLastAddedPoint(currTrack);
-//				currTrack.add(new CWPoint(50.748, 7.09958));
-//				currTrack.add(new CWPoint(50.75, 7.09958));
-//				currTrack.add(new CWPoint(50.755, 7.09958));
-//				currTrack.add(new CWPoint(50.76, 7.09958));
-//				currTrack.add(new CWPoint(50.765, 7.09958));
-//				gpsPosition.latDec = 50.75;
-//				gpsPosition.lonDec = 7.1;
-//				mmp.updatePosition(50.75, 7.1);
-//				mmp.addSymbol("test", "110.png", 50.7446, 7.0935);
-//				try {Thread.sleep(5000);} catch (InterruptedException e) {};
-//				gpsPosition.latDec = 50.74;
-//				gpsPosition.lonDec = 7.1;
-//				mmp.updatePosition(50.74, 7.1);
-				if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
-					Vm.debug("ShowLastAddedPoint: voher");
-					mmp.ShowLastAddedPoint(currTrack);
-					Vm.debug("ShowLastAddedPoint: nachher");
-					mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
-					mmp.setGpsStatus(MovingMap.gotFix);
-				}
-				if ((fix == 0) && (gpsPosition.getSats()== 0)) {
-					mmp.setGpsStatus(MovingMap.lostFix);
-				}
-				if (fix < 0 ) {
-					mmp.setGpsStatus(MovingMap.noGPSData);
-				}
-
-		//	}
 		}
 	}
 
@@ -496,11 +466,11 @@
 		tickerThread = new UpdateThread(this, 1000);
 		tickerThread.start();
 	}
-	
+
 	public void stopDisplayTimer(){
 		if (tickerThread != null) tickerThread.stop();
 	}
-	
+
 	/**
 	 * @param utc in the format as it comes from gps DDMMYY
 	 * @param datum in the format as it comes from gps HHMMSS
@@ -510,7 +480,7 @@
 	 * @throws NumberFormatException when utc / datum could not be interpreted
 	 */
 	public double getSunAzimut (String utc, String datum, double lat, double lon) {
-	//	(new MessageBox("test", "utc:"+utc+" datum: "+datum+", lat: "+lat+", len: "+lon, MessageBox.OKB)).exec();
+		//	(new MessageBox("test", "utc:"+utc+" datum: "+datum+", lat: "+lat+", len: "+lon, MessageBox.OKB)).exec();
 		try {
 			int tag, monat, jahr, stunde, minute, sekunde;
 			tag = Convert.parseInt(datum.substring(0, 2));
@@ -557,7 +527,7 @@
 			throw new NumberFormatException();
 		}
 	}
-	
+
 	private void stopGPS() {
 		serThread.stop();
 		stopDisplayTimer();
@@ -568,7 +538,7 @@
 		this.repaintNow(); // without this the change in the background color will not be displayed
 		chkLog.modify(0,ControlConstants.Disabled);
 	}
-	
+
 	public void startGps() {
 		if (serThread != null) if (serThread.isAlive()) return;
 		try {
@@ -593,7 +563,7 @@
 		currTrack = new Track(RED);
 	}
 
-	
+
 	/**
 	 * Eventhandler
 	 */
@@ -612,8 +582,8 @@
 			if (ev.target == btnGPS){
 				if (btnGPS.getText().equals("Start")) startGps();
 				else stopGPS();
-				}
-			
+			}
+
 			// set current position as center and recalculate distance of caches in MainTab 
 			if (ev.target == btnCenter){
 				Vm.showWait(true);
@@ -632,7 +602,7 @@
 						mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
 						mmp.ignoreGps = true;
 					}
-					if (currTrack != null) mmp.addOverlaySet(currTrack);
+					if (currTrack != null) mmp.addTrack(currTrack);
 					mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
 					mmp.exec();
 				}
@@ -649,8 +619,8 @@
 						String rawFileName = new String();
 						dateien = files.list("*.png", File.LIST_FILES_ONLY);
 						for(int i = 0; i < dateien.length;i++){
-								ext = new Extractor(dateien[i], "", ".", 0, true);
-								rawFileName = ext.findNext();
+							ext = new Extractor(dateien[i], "", ".", 0, true);
+							rawFileName = ext.findNext();
 							try {
 								tempMIO = new MapInfoObject();
 								tempMIO.loadwfl(mapsPath, rawFileName);
@@ -667,18 +637,9 @@
 						mmp.loadMap(toPoint.latDec, toPoint.lonDec);
 					} else
 						mmp.loadMap(gpsPosition.latDec, gpsPosition.lonDec);
-					if (currTrack != null) mmp.addOverlaySet(currTrack);
+					if (currTrack != null) mmp.addTrack(currTrack);
 					mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
 					mmp.exec();
-					//				mmp.updatePosition(50.733, 7.096);
-					/*				mmp.updatePosition(50.74455, 7.0935);
-				try {  Thread.sleep(2000);	} catch (InterruptedException e){ }
-				mmp.updatePosition(50.733, 7.096);
-				try {  Thread.sleep(2000);	} catch (InterruptedException e){ }
-				mmp.updatePosition(50.7, 7.0);
-				try {  Thread.sleep(2000);	} catch (InterruptedException e){ }
-				mmp.updatePosition(50.733, 7.096);
-					 */	
 				}
 
 			} // if (ev.target == btnMap

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-07 12:04:41 UTC (rev 354)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-07 14:17:39 UTC (rev 355)
@@ -25,6 +25,7 @@
 	GotoPanel gotoPanel;
 	Vector cacheDB;
 	TrackOverlay[] TrackOverlays;
+	Vector tracks;
 	MapInfoObject currentMap;
 	AniImage statusImageHaveSignal = new AniImage("position_green.png");
 	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
@@ -55,47 +56,38 @@
 		mmp = new MovingMapPanel(this, maps, gotoPanel, cacheDB);
 		this.addLast(mmp);
 	}
+	public void addTrack(Track tr) {
+		if (tr == null) return;
+		if (tracks == null) tracks = new Vector();
+		if (tracks.find(tr) >= 0 ) return; // track already in list
+		tracks.add(tr);
+		addOverlaySet();
+	}
+	
+	public void addTracks(Track[] trs) {
+		if (trs==null || trs.length == 0) return;
+		for (int i=0; i<trs.length; i++) {
+			addTrack(trs[i]);
+		}
+		addOverlaySet();
+	}
+	
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
 	 * 
-	 * @param tr: tr==null - use the tracks which are already in use
+	 * add tracks with addtrack(track) before
 	 */
 	
-	public void addOverlaySet(Track tr) {
-		if (tr == null && TrackOverlays == null) return; // no tracks
-		Track[] trs;
-		if (tr==null && TrackOverlays != null) trs=getTracks(); 
-		else {
-			trs=new Track[1];
-			trs[0]=tr;
-		}
+	public void addOverlaySet() {
+		if (tracks == null) return; // no tracks
 		if (TrackOverlays != null) {
 			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
 		}
-		addMissingOverlays(trs);
-		repaintNow();
+		addMissingOverlays();
 	}
 	
-	public Track[] getTracks(){
-		Track[] trs=null;
-		if (TrackOverlays == null) return null;
-		// copy tracks from existing Overlays
-		for (int i=0; i<TrackOverlays.length; i++) {
-			if (TrackOverlays[i] != null) {
-				if (TrackOverlays[i].tracks != null) {
-					trs = new Track[TrackOverlays[i].tracks.size()];
-					for (int t=0; t<trs.length; t++) {
-						trs[t]=(Track)TrackOverlays[i].tracks.get(t); 
-					}
-				}
-				break;
-			}
-		}
-		return trs;
-	}
 
-	public void addMissingOverlays(Track[] trs) {
-		if (trs == null) trs=getTracks();
+	public void addMissingOverlays() {
 		Point upperleft = getMapXYPosition();
 		int ww = pref.myAppWidth;
 		int wh = pref.myAppHeight;
@@ -107,7 +99,7 @@
 				if (TrackOverlays[i]==null) { 
 					TrackOverlays[i]= new TrackOverlay(currentMap.calcLatLon(-upperleft.x+(xi-1)*ww, -upperleft.y+(yi-1)*wh), ww, wh, currentMap); 
 					TrackOverlays[i].setLocation(0, 0);
-					TrackOverlays[i].addTracks(trs);
+					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
 				}
@@ -227,9 +219,6 @@
 		if (TrackOverlays == null || tr == null) return;
 		for (int i=0; i<TrackOverlays.length; i++){
 			TrackOverlays[i].paintLastAddedPoint(tr);
-			//TrackOverlays[i].draw.drawRect(50, 50, 100, 100);
-			//TrackOverlays[i].image.set
-			//TrackOverlays[i].draw.flush(); doesn't helpt :-(
 		}
 	}
 
@@ -254,8 +243,8 @@
 		updateOverlayOnlyPos();
 		if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
 				TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
-			rearangeOverlays(); // TODO Fehler: wenn ein Sprung gemacht wurde, sind werden alle Overlays gel?scht -> Information ?ber bereits laufende Tracks gehen verloren -> vorher sp?eichern.
-			addMissingOverlays(null);
+			rearangeOverlays();
+			addMissingOverlays();
 			// updateOverlayOnlyPos(); is called from addMissingOverlays 
 		}
 	}
@@ -387,7 +376,6 @@
 		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
 		this.mmp.addImage(ms.pic);
 		symbols.add(ms);
-//		repaintNow();
 	}
 	
 	public void setGotoPosition(double lat, double lon) {
@@ -534,7 +522,7 @@
 			mmp.mapImage.setLocation(0,0);
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
-			addOverlaySet(null);
+			addOverlaySet();
 			updateOnlyPosition(lat, lon, false);
 			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
 			Vm.showWait(false);
@@ -545,7 +533,7 @@
 				mmp.mapImage.free();
 				mmp.mapImage = null;
 			}
-			addOverlaySet(null);
+			addOverlaySet();
 			updateOnlyPosition(lat, lon, false);
 			inf.close(0);
 			Vm.showWait(false);
@@ -557,7 +545,7 @@
 				mmp.mapImage.free();
 				mmp.mapImage = null;
 			}
-			addOverlaySet(null);
+			addOverlaySet();
 			updateOnlyPosition(lat, lon, false);
 			inf.close(0);
 			Vm.showWait(false);
@@ -569,7 +557,7 @@
 				mmp.mapImage.free();
 				mmp.mapImage = null;
 			}
-			addOverlaySet(null);
+			addOverlaySet();
 			updateOnlyPosition(lat, lon, false);
 			inf.close(0);
 			Vm.showWait(false);
@@ -625,10 +613,6 @@
 		mm.posCircle.move(p.x+diffX, p.y+diffY);
 		mm.posCircleX = mm.posCircleX+diffX;
 		mm.posCircleY = mm.posCircleY+diffY;
-		//mm.ignoreGpsStatutsChanges = false;
-		//mm.setGpsStatus(MovingMap.noGPS);   // TODO mm.posCircle.move(, y)
-		//mm.ignoreGpsStatutsChanges = true;
-		// for debugging: mm.updatePosition(10, 10);
 		mm.updateSymbolPositions();
 		mm.updateOverlayPos();
 		this.repaintNow();
@@ -683,8 +667,8 @@
 		if (which == mm.ButtonImageGpsOn) {
 			if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
 				mm.gotoPanel.startGps();
-				mm.addOverlaySet(mm.gotoPanel.currTrack); // use new track when gps now started
-			} else mm.addOverlaySet(null); // use existing tracks if gps was already running
+				mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
+			} else mm.addOverlaySet(); // use existing tracks if gps was already running
 			mm.SnapToGps();
 		}
 		if (which == mm.arrowRight)	{	moveMap(-10,0);	}
@@ -711,12 +695,17 @@
 		this.maps = maps;
 		MapInfoObject map;
 		ScrollBarPanel scb;
+		boolean[] inList = new boolean[maps.size()];
 		if (gotopos != null && Gps != null) {
 			list.addItem("--- Karten von akt. Position und Ziel ---");
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) list.addItem(i + ": " + map.mapName);
+				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
+					{
+					list.addItem(i + ": " + map.mapName);
+					inList[i] = true;
+					} else inList[i] = false;
 			}
 		}
 		if (Gps != null) {
@@ -724,7 +713,11 @@
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if(map.inBound(Gps.latDec, Gps.lonDec) == true) list.addItem(i + ": " + map.mapName);
+				if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
+					{
+					list.addItem(i + ": " + map.mapName);
+					inList[i] = true;
+					}
 			}
 		}
 		if (gotopos != null) {
@@ -732,14 +725,17 @@
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if(map.inBound(gotopos)) list.addItem(i + ": " + map.mapName);
+				if(map.inBound(gotopos)) {
+					list.addItem(i + ": " + map.mapName);
+					inList[i] = true;
+				}
 			}
 		}
 		list.addItem("--- andere Karten ---");
 		for(int i = 0; i<maps.size();i++){
 			map = new MapInfoObject();
 			map = (MapInfoObject)maps.get(i);
-			if(!mapIsInList(i)) list.addItem(i + ": " + map.mapName);
+			if(!inList[i]) list.addItem(i + ": " + map.mapName);
 		}
 		
 		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
@@ -751,7 +747,7 @@
 		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
 		okButton.setHotKey(0, KeyEvent.getActionKey(true));
 	}
-	private boolean mapIsInList(int mapNr){
+	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
 		String testitem = new String();
 		int testitemnr;
 		for (int i=0; i<list.countListItems(); i++) {

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-01-07 12:04:41 UTC (rev 354)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-01-07 14:17:39 UTC (rev 355)
@@ -159,6 +159,11 @@
 			} else { finalMessage = "IOException: "+e.getMessage(); }
 			success = false;
 			}
+		}catch (IllegalArgumentException e) {
+			finalMessage=MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ holder.wayPoint;
+			success = false;
+			Vm.debug("Parse error: " + state + " " + holder.wayPoint);
+			e.printStackTrace();
 		}catch (Exception e){ // here schould be used the correct exepion
 			finalMessage=MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.wayPoint;
 			success = false;
@@ -263,6 +268,7 @@
 		
 		if(name.equals("waypoints")){
 			holder.wayPoint = atts.getValue("oc");
+			if (holder.wayPoint.length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
 			return;
 		}
 
@@ -456,6 +462,7 @@
 	
 	private void getPic(String fetchURL, String picDesc){
 		String fileName = holder.wayPoint + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
+		fileName = Common.ClearForFileName(fileName);
 		// add title
 		holder.ImagesText.add(picDesc);
 		try {

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-01-07 12:04:41 UTC (rev 354)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-01-07 14:17:39 UTC (rev 355)
@@ -1,52 +1,43 @@
 package CacheWolf;
 
+//import java.awt.image.BufferedImage;
+
 import ewe.fx.Color;
 import ewe.fx.Graphics;
 import ewe.fx.Image;
 import ewe.fx.Pen;
 import ewe.graphics.AniImage;
-import ewe.ui.MessageBox;
+import ewe.sys.Convert;
 import ewe.fx.Point;
 
-import ewe.util.Utils;
 import ewe.util.Vector;
-import ewe.io.BufferedWriter;
-import ewe.io.FileWriter;
-import ewe.io.IOException;
-import ewe.io.PrintWriter;
 
+
 public class TrackOverlay extends AniImage {
 	TrackPoint topLeft;
 	TrackPoint bottomRight;
 	Graphics draw;
+	int test;
 	MapInfoObject trans; 
 	Vector tracks;
+	boolean imageChangesDontShow = false;
+	public Point trackPixels[] = null;
+	public Color trackPixelsColor[] = null;
+	public int numPixels = 0;
 	final static Color transparentColor = Color.White;
 	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
 		topLeft = new TrackPoint(topLefti);
 		trans = transi;
 		bottomRight = calcLatLonInImage(widthi, highti);
 		setImage(new Image(widthi, highti), transparentColor);
-		//properties = AlwaysOnTop;
+		//properties = AlwaysOnTop; // arrows are above, so dont set it.
 		draw = new Graphics(image);
+		draw.setDrawOp(Graphics.DRAW_OVER);
 		draw.setColor(transparentColor);
 		draw.fillRect(0, 0, widthi, highti);
 	}
-	public void setBottimRightLatLon(double lat, double lon) {
-		bottomRight = new TrackPoint(lat, lon);
-	}
-	public void addTrack(Track tr) {
-		if (tr == null) return;
-		if (tracks == null) tracks = new Vector();
-		tracks.add(tr);
-	}
-	public void addTracks(Track[] trs) {
-		if (trs==null || trs.length == 0) return;
-		for (int i=0; i<trs.length; i++) {
-			addTrack(trs[i]);
-		}
-		
-	}
+
+	
 	public void paintTracks() {
 		if (tracks == null || tracks.size() == 0) return;
 		int tri, i;
@@ -56,15 +47,16 @@
 			draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
 			if (tr.num > 0) {
 				for (i=0; i < tr.num; i++) {
-					paintPoint(tr.TrackPoints[i].latDec, tr.TrackPoints[i].lonDec);
+					paintPoint(tr.trackColor, tr.TrackPoints[i].latDec, tr.TrackPoints[i].lonDec);
 				}
 			}
 		}
 	}
 
-	public void paintPoint(double lat, double lon){
+		
+	public void paintPoint(Color f, double lat, double lon){
 		if (lat<bottomRight.latDec || lat > topLeft.latDec || lon<topLeft.lonDec || lon>bottomRight.lonDec) return;
-		ewe.sys.Vm.debug("showlastaddedpoint, lat: "+lat+"   lon: "+lon);
+		//ewe.sys.Vm.debug("showlastaddedpoint, lat: "+lat+"   lon: "+lon);
 		double b[] = new double[2];
 		int x, y;
 		b[0] = lat - topLeft.latDec; // see calcXYinImage (TrackPoint p) 
@@ -73,19 +65,31 @@
 		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
 		//draw.drawLine(x, y, x, y);
 		ewe.sys.Vm.debug("showlastaddedpoint, x: "+x+"   y: "+y+"loc.x: "+location.x+"  loc.y:"+location.y);
-		draw.drawRect(x-1, y-1, 2, 2, 1);
-	//	draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536;
-		//image._awtImage.raster.data
-		//image.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats?chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
-		int[] markPixels = new int[4];
-		for (int i = 0; i<markPixels.length; i++) { markPixels[i] = -65536; }
-		image.setPixels(markPixels, 0 , 400, 300, 1, 1, 0);
-		//draw.flush();
-		//ewe.ui.PenEvent.refreshTip(draw.surface);
-		//draw.setPixelRGB(x, y, -65536);
-		this.changed();
+		draw.fillRect(x-1, y-1, 3, 3);
+		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
+			int yd;
+			for  (int xd=-1; xd<=1; xd++) {
+				for (yd=-1; yd<=1; yd++) {
+					((BufferedImage)image.bufferedImage).setRGB(x+xd, y+yd, -65536);
+				}
+			} */
+		if (imageChangesDontShow) {
+			try {addPixelIfNeccessary(x, y, f); }
+			catch (IndexOutOfBoundsException e) // thrown when there are more than pixels stored than possible
+			{   
+				draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+				draw.drawImage(image,null,transparentColor,0,0,location.width,location.height);
+				removeAllPixels();
+			}
+		}
 	}
 	
+	private void removeAllPixels() {
+		numPixels = 0;
+		trackPixels = null;
+		trackPixelsColor = null;
+	}
+
 	public Point calcXYinImage (TrackPoint p) {
 		double b[] = new double[2]; // see method paintPoint it should actually call this method but it doesn't because of speed raesons
 		int x, y;
@@ -95,27 +99,113 @@
 		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
 		return new Point(x,y);
 	}
-	
+
 	public TrackPoint calcLatLonInImage (double x, double y) {
 		// see trans.calcLatLon(p);
-		 TrackPoint ll = new TrackPoint(); 
-		 ll.latDec = (double)x * trans.affine[0] + (double)y * trans.affine[2] + topLeft.latDec;
-		 ll.lonDec = (double)x * trans.affine[1] + (double)y * trans.affine[3] + topLeft.lonDec;
-		 return ll;
+		TrackPoint ll = new TrackPoint(); 
+		ll.latDec = (double)x * trans.affine[0] + (double)y * trans.affine[2] + topLeft.latDec;
+		ll.lonDec = (double)x * trans.affine[1] + (double)y * trans.affine[3] + topLeft.lonDec;
+		return ll;
 	}
-	
-	public void addTrackPoint(Track tr, double lat, double lon) {
-	tr.add(lat, lon);
-	paintPoint(lat, lon);
+
+	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
+		if (trackPixels==null) { trackPixels = new Point[1]; trackPixelsColor = new Color[1000]; } 
+		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
+		trackPixelsColor[numPixels] = f.getCopy();
+		numPixels++;
 	}
-	
+
+	public void addPixelIfNeccessary(int x, int y, Color f){
+		int ll =(numPixels<50 ? 0 : numPixels-50); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
+		for (int i=numPixels-1; i>=ll; i--) {
+			if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) return; 
+		}
+		addPixel(x, y, f);
+	}
+
 	public void paintLastAddedPoint(Track tr) {
 		draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
-		paintPoint(tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec);
+		paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec);
 	}
+
 	public boolean isOnScreen() { // i assume that location.width = screen.width and the same for hight
 		if ( (location.x + location.width > 0 && location.x < location.width) || 
 				(location.y + location.height > 0 && location.y < location.height) ) return true;
 		else return false;
 	}
+	
+	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
+		super.doDraw(g, options);
+		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
+		// draw trackpoints which were added after image changes don't show up on the screen
+		if (tracks == null || tracks.size() == 0) return;
+		int i;
+		for (i=0; i<numPixels; i++) {
+			g.setColor(trackPixelsColor[i]);
+			g.fillRect(trackPixels[i].x-1, trackPixels[i].y-1, 3, 3);
+		}
+		g.drawText(Convert.toString(test), 10, 10);
+		g.drawRect(10 + test, 10, 10, 10);
+		//g.setPixelRGB(x, y, rgb);
+		test++;
+	}
 }
+
+
+/* draw zeichnet auf _awtImage
+ * image.drawImage erzeugt bufferedImage, wenn es vorher null war 
+ * und kopiert den entsprechenden Teil in das ?bergebene Surface
+ * Das Problem ist, dass bufferedImage nicht mehr upgedatet wird, wenn
+ * es einmal erzugt wurde. Es wird nur dann upgedatet, wenn das Image ein anderes wird
+ * oder die Maske eine andere. Das Update erfolgt dann ?ber doDraw, was doCheckMask aufruft,
+ * das das eigentliche kopieren aus _awtImage vornimmt.
+ * 
+ *  Problem: das kopieren von _awtImage in BufferedImage ist sehr zeitaufw?ndig, weil
+ *  es keine native Routine ist und jedes Pixel einzeln gepr?ft wird.
+ *  Deswegen w?re die beste L?sung, wenn ich bufferedImage direkt updaten k?nnte.
+ *  Aber bufferedImage ist privat, ich kann auch in abgeleiteten Klassen nicht drauf
+ *  zugreifen. 
+ *  
+ *  Zur Not w?re auch denkbar, doDraw zu ?berschreiben, um bei jedem Aufruf alle 
+ *  Trackpoints neu zu zeichnen.
+ */
+// was alles nicht funktioniert:
+//drawmask.setDrawOp(Graphics.DRAW_OVER);
+//	drawmask.drawRect(x-1, y-1, 2, 2, 1);
+//this.setImage(image, mask);
+// n?chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
+//image.rgb
+//	draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
+//	((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
+//	image
+//	((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats?chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
+//int[] markPixels = new int[4];
+//for (int i = 0; i<markPixels.length; i++) { markPixels[i] = -65536; }
+// image.transparent = null; hilft auhc nicht
+//image.mask = null;
+//image.bufferedImage = null;
+//image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
+//ewe.fx.mImage mark = new mImage();
+//Image mark = new Image(2,2);
+//new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
+//mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
+// image.bufferedImage = null; // this solves the problem
+//toCursor(null);
+//this.draw(draw);
+//image=(BufferedImage)this.toNativeImage(transparentColor);
+//(java.awt.Image.b)
+//image.bufferedImage=null;
+//draw.flush();
+//ewe.ui.PenEvent.refreshTip(draw.surface);
+//draw.setPixelRGB(x, y, -65536);
+//this.changed(); hilft auch nicht
+// this.refresh(); // hilft nicht :-(
+//	lastDrawn.x = lastDrawn.x -10; hilft auch nicht
+// imageMayChange = true; // hilft auch nicht :-(
+
+/*
+ * this class is only needed to have a fast access to the list of pixels
+ * which are added but aniimage.draw will not lead to a change on the screen
+ * so that these pixels will be drawn seperately by doDraw
+ * 
+ */

Modified: trunk/src/CacheWolf/TrackPoint.java
===================================================================
--- trunk/src/CacheWolf/TrackPoint.java	2007-01-07 12:04:41 UTC (rev 354)
+++ trunk/src/CacheWolf/TrackPoint.java	2007-01-07 14:17:39 UTC (rev 355)
@@ -42,7 +42,7 @@
 	
 	public Track(Color f) {
 		trackColor = f;
-		TrackPoints = new TrackPoint[2000];
+		TrackPoints = new TrackPoint[5000];
 		num = 0;
 	}
 	
@@ -50,7 +50,10 @@
 		TrackPoints[num] = new TrackPoint(lat, lon);
 		num++;
 	}
-	public void add(TrackPoint t) {
+	/*
+	 * throws IndexOutOfBoundsException when track is full
+	 */
+	public void add(TrackPoint t) { 
 		if (TrackPoints == null || t == null) return;
 		TrackPoints[num] = new TrackPoint(t);
 		num++;



From salzkammergut at mail.berlios.de  Sun Jan  7 17:57:40 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Jan 2007 17:57:40 +0100
Subject: [Cachewolf-svn] r358 - trunk/src/CacheWolf
Message-ID: <200701071657.l07Gvee9031550@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-07 17:57:37 +0100 (Sun, 07 Jan 2007)
New Revision: 358

Modified:
   trunk/src/CacheWolf/CacheWolf.java
   trunk/src/CacheWolf/LoadScreen.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/Spider.java
Log:
Klassen Spider und LoadScreen entfernt, da nicht in Verwendung.
(Derzeit nur durch Entfernen von allem Code - wie kann man diese Klassen und auch GeoToad loeschen)?

Modified: trunk/src/CacheWolf/CacheWolf.java
===================================================================
--- trunk/src/CacheWolf/CacheWolf.java	2007-01-07 16:43:22 UTC (rev 357)
+++ trunk/src/CacheWolf/CacheWolf.java	2007-01-07 16:57:37 UTC (rev 358)
@@ -242,15 +242,6 @@
 		//}
 		
 		if(args.length > 0){
-			//Vm.debug("in args!!!!");
-			//Vm.sleep(500);
-			if(args[0].equals("spider")){
-				//Vm.debug("Starting cmd line mode");
-				//Vm.sleep(500);
-				// args are: spider distance profileName
-				Form mainF = new MainForm(args[0], args[1], args[2]);
-				mainF.execute();
-			}
 			if(args[0].equals("test")){
 				Test t=new Test(); 
 				t.testAll();

Modified: trunk/src/CacheWolf/LoadScreen.java
===================================================================
--- trunk/src/CacheWolf/LoadScreen.java	2007-01-07 16:43:22 UTC (rev 357)
+++ trunk/src/CacheWolf/LoadScreen.java	2007-01-07 16:57:37 UTC (rev 358)
@@ -1,176 +0,0 @@
-package CacheWolf;
-import ewe.ui.*;
-import ewe.ui.MessageBox;
-import ewe.sys.*;
-import ewe.util.*;
-import ewe.filechooser.*;
-import ewe.io.*;
-
-/**
-*	This class displays the screen offering the user the different options
-* 	to spider the caches. From this screen the spider is activated and starts
-*	working.
-*	Class ID = 900
-*/
-public class LoadScreen extends Form{
-/* skg20061225: Commented out - needs to be deleted as it is not referenced
- * The functionality seems to be taken over by SpiderGC
- * 
- 	
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-	Spider mySpidy;
-	mTextPad liste = new mTextPad();
-	mButton btList = new mButton((String)lr.get(900,"List"));
-	mButton btLoc = new mButton((String)lr.get(901,"Loc"));
-	mButton btNearest = new mButton((String)lr.get(902,"Nearest"));
-	mButton btCancel = new mButton((String)lr.get(903,"Cancel"));
-	mButton btMulti = new mButton((String)lr.get(904,"Multi"));
-	mButton btGPX = new mButton("GPX");
-
-	Vector cacheDB = new Vector();
-	Preferences myP = new Preferences();
-	MessageArea msgArea;
-	Handle spiderHandle;
-	Lock spiderLock = new Lock(); 
-	boolean spiderRunning = false;
-	
-	public LoadScreen(Vector DB, Preferences p){
-		cacheDB = DB;
-		myP = p;
-		this.setPreferredSize(200,200);
-		this.title = (String)lr.get(905,"Load Caches");
-		this.addLast(new mLabel((String)lr.get(906,"List of Caches:")),this.DONTSTRETCH, (this.DONTFILL|this.WEST));
-		this.addLast(liste, this.STRETCH, this.FILL);
-		CellPanel cp = new CellPanel();
-		cp.addNext(btList, this.HSTRETCH, this.FILL);
-		cp.addNext(btLoc, this.HSTRETCH, this.FILL);
-		cp.addNext(btNearest, this.HSTRETCH, this.FILL);
-		cp.addNext(btGPX, this.HSTRETCH, this.FILL);
-		cp.addLast(btMulti, this.HSTRETCH, this.FILL);
-		cp.addLast(msgArea = new MessageArea(""), this.HSTRETCH, this.FILL|this.WEST);
-		cp.addLast(btCancel, this.HSTRETCH, this.FILL);
-		this.addLast(cp, this.HSTRETCH, this.FILL);
-	} // LoadScreen
-	
-	private void startSpiderRunning(){ 
-		 spiderLock.synchronize(); try{ 
-		   //Make sure it is not already running. 
-		   if (spiderRunning) return; 
-		   spiderRunning = true; 
-		   new mThread(){ 
-		    public void run(){ 
-		     //mySpidy = new Spider(cacheDB, myP, msgArea,   Spider.SPIDERLOC); 
-		     //mySpidy.setUp(data); 
-		     //spiderHandle = mySpidy.getHandle(); 
-		     mySpidy.run();  
-		     try{ 
-		     spiderHandle.waitUntilStopped(); 
-		     }catch(Exception e){ 
-		     }finally{ 
-		   spiderLock.synchronize(); 
-		   spiderRunning = false; 
-		   spiderLock.release(); 
-		   close(0); 
-		     }      
-		     } 
-		   }.start();    
-		 }finally{spiderLock.release();} 
-	} 
-
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if(ev.target == btCancel){
-				if(spiderRunning == true){
-					//spiderHandle.stop(1);
-					Handle hdl = mySpidy.stopTask(1);
-					Vm.debug("Done? " + mySpidy.shouldStop);
-					try{
-						hdl.waitUntilStopped();
-					}catch(Exception ex){}
-					//mySpidy.stopTask(0);
-				}
-				this.close(0);
-			}
-			if(ev.target == btLoc){
-				LOCReader lor = new LOCReader(myP.mydatadir);
-				Vector data = new Vector();
-				data = lor.doIt();
-				mySpidy = new Spider(cacheDB, myP,msgArea, Spider.SPIDERLOC);
-				mySpidy.setUp(data);
-				spiderHandle = mySpidy.getHandle();
-				mySpidy.run();
-				try{
-					spiderHandle.waitUntilStopped();
-				}catch(Exception e){}
-				this.close(0);
-			}
-			if(ev.target == btList){
-				Vector data = new Vector();
-				data = mString.split(liste.getText(), ',', data);
-				mySpidy = new Spider(cacheDB, myP, msgArea, Spider.SPIDERLOC);
-				mySpidy.setUp(data);
-				spiderHandle = mySpidy.getHandle();
-				mySpidy.run();
-				try{
-					spiderHandle.waitUntilStopped();
-				}catch(Exception e){}
-				this.close(0);
-			}
-			if(ev.target == btNearest){
-				if(myP.existCenter() == true){
-					String dist = new InputBox((String)lr.get(907,"Max distance:")).input("50",10);
-					mySpidy = new Spider(cacheDB, myP, msgArea, Spider.SPIDERNEAREST);
-					mySpidy.setUp(dist);
-					spiderHandle = mySpidy.getHandle();
-					startSpiderRunning();
-				} else {
-					MessageBox mb = new MessageBox("Error!", "Koordinates in preferences not set!", 1);
-					mb.execute();
-				}
-				//this.close(0);
-			}
-			if(ev.target == btMulti){
-				FileChooser fc = new FileChooser(FileChooser.OPEN, myP.mydatadir);
-				fc.setTitle((String)lr.get(908,"Select waypoints file"));
-				if(fc.execute() != fc.IDCANCEL){
-					String dist = new InputBox((String)lr.get(907,"Max distance:")).input("1",10);
-					try{
-						FileReader in = new FileReader(fc.getChosenFile());
-						String text = new String();
-						Vector vct = new Vector();
-						text = in.readAll();
-						in.close();
-						if(!(text.substring(text.length()-2,text.length()-1).equals(";"))){
-							text = text + ";";
-						}
-						vct = mString.split(text, ';', vct);
-						mySpidy = new Spider(cacheDB, myP,msgArea, Spider.SPIDERMULTI);
-						mySpidy.setUp(vct, dist);
-						spiderHandle = mySpidy.getHandle();
-						mySpidy.run();
-						try{
-							spiderHandle.waitUntilStopped();
-						}catch(Exception e){}
-					}catch(Exception ex){
-						//Vm.debug("Error reading waypoint file");
-					}
-				} else {
-				}
-			this.close(0);
-			}
-			if(ev.target == btGPX){
-				FileChooser fc = new FileChooser(FileChooser.OPEN, myP.mydatadir);
-				fc.addMask("*.gpx");
-				fc.setTitle((String)lr.get(909,"Select GPX file"));
-				if(fc.execute() != fc.IDCANCEL){
-					//GPXImporter gpx = new GPXImporter(cacheDB, fc.getChosenFile().toString(),myP.mydatadir,msgArea);
-					//gpx.doIt();
-					//this.close(0);
-				}
-			}
-		}
-		super.onEvent(ev);
-	}
-*/
-}

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-07 16:43:22 UTC (rev 357)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-07 16:57:37 UTC (rev 358)
@@ -76,21 +76,6 @@
 	}
 
 	
-	public MainForm(String what, String dist, String profileName){
-		try{
-			pref.readPrefFile();
-			addGuiFont();
-			pref.lastProfile=profileName;
-			pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_OFF,false);
-			profile.readIndex();
-			Spider mySpidy = new Spider(pref, profile,null, Spider.SPIDERNEAREST);
-			mySpidy.SpiderNearest(dist);
-			ewe.sys.Vm.exit(0);
-		} catch (Exception e){
-			//Vm.debug(e.toString());
-		}
-	}
-	
 	private void addGuiFont(){
 		Font defaultGuiFont = mApp.findFont("gui");
 		int sz = (pref.fontSize);

Modified: trunk/src/CacheWolf/Spider.java
===================================================================
--- trunk/src/CacheWolf/Spider.java	2007-01-07 16:43:22 UTC (rev 357)
+++ trunk/src/CacheWolf/Spider.java	2007-01-07 16:57:37 UTC (rev 358)
@@ -1,932 +0,0 @@
-package CacheWolf;
-import ewe.net.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.util.*;
-import ewe.ui.*;
-
-/**
-*	The class to spider:<br>
-*	a) the cache list<br>
-*	b) the cache details<br><br>
-*	This class still needs thorough documentation<br>
-*	Class ID=800
-*/
-
-/**
-*	Spider Travelbugs:
-*	Das hier f?r welche abgelegt sind (auf Cache Detailseite)
-/////////////////////
-*	<span id="lnkTravelBugs"><tr><td VALIGN="TOP" ALIGN="LEFT"><img SRC="../images/wpttypes/21.gif" WIDTH="22" HEIGHT="30"></td><td VALIGN="TOP" ALIGN="LEFT" COLSPAN="2"><font face="Verdana" size="2"><FONT SIZE="1">Travel Bugs have been seen in this cache -</FONT><br>
-*<A HREF="../track/details.aspx?guid=8e52e5d8-6922-40f4-9b09-5b521297468e">BlackLog</A><br>
-*<A HREF="../track/details.aspx?guid=bc5f6513-ad4c-41b1-b299-759cf4b78d84">Ostrov Hotel</A><br>
-*<A HREF="../track/details.aspx?guid=ec0a978e-3491-4315-8ab0-7e2c417b0d84">TB - Alan Stewart </A>
-*<br><A HREF="../track/details.aspx?guid=bdd919d9-73a1-47b7-8ba8-5f0584e7f33e">Theodore the Traveling Toad</A>
-*<br><A HREF="../track/details.aspx?guid=092d0214-a601-407e-84cb-cd514598106c">Forgetful Jones - Denkedran Jost</A><br>
-*<br><FONT SIZE=1><A HREF="../track/">What is a Travel Bug?</A><br><a href="../track/search.aspx?wid=a4ff6781-84fa-466c-ba0f-028128e06a7a">View Bug History</a></font></font></td></tr></span>
-/////////////////////
-*
-*	Bild von dem Bug:
-*       <img id="BugDetail_BugImage" src="http://img.groundspeak.com/track/display/35c891d1-b4e4-4f85-b88e-176bb5b13ceb.jpg" alt="Our 2nd TravelBug - BlackLog" align="Right" border="0" />
-*
-*	Ziel des Bugs:
-*	<span id="BugDetail_BugGoal">
-*	...
-*	</span>
-*	und!
-*	<span id="BugDetail_BugDetails">
-*	...
-*	</span>
-*
-*/
-public class Spider extends TaskObject{
-	public static int SPIDERMULTI = 0;
-	public static int SPIDERNEAREST = 1;
-	public static int SPIDERLOC = 2;
-	public static String proxy;
-	public static String port;
-	private int SpiderType = -1;
-	private Vector caches_identified = new Vector();
-	private String caches_available = new String();
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	ProgressBarForm pbf = new ProgressBarForm();
-	MessageArea msgA;
-	Vector data;
-	String distance;
-/** skg: 20061225 Commented out as it is not used	
-	protected void doRun(){
-		switch(SpiderType){
-			case 0: SpiderMulti(data, distance);
-				break;
-			case 1: SpiderNearest(distance);
-				break;
-			case 2: SpiderLOC(data);
-				break;
-		}
-	}
-	
-	public void setUp(Vector dta){
-		data = dta;
-	}
-	public void setUp(String dst){
-		distance = dst;
-	}
-	public void setUp(Vector vct, String dist){
-		data = vct;
-		distance = dist;
-	}
-*/	
-	
-	/**
-	*	Initializes a spider. It also identifies which caches
-	*	are already available in the database.
-	*
-	*   This seems to be used for spidering caches in batch mode
-	*/
-	public Spider(Preferences p, Profile prof, MessageArea msg, int SpT){
-		msgA = msg;
-		SpiderType = SpT;
-		cacheDB = profile.cacheDB;
-		profile=prof;
-		pref = p;
-		proxy = pref.myproxy;
-		port = pref.myproxyport;
-		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size(); i++){
-			ch = (CacheHolder)cacheDB.get(i);
-// TODO Change to hashTable or StringBuffer			
-			caches_available = caches_available + ";" + ch.wayPoint;  
-		}
-		//Vm.debug("Setup caches avail: " + caches_available);
-	}
-	
-	/**
-	*	Performs an initial fetch to a given address. In this case
-	*	it will be a gc.com address. This method is used to obtain
-	*	the result of a search for caches screen.
-	*/
-	private static String fetch(String address) throws IOException
-	   	{
-			//Vm.debug(address);
-			HttpConnection conn;
-			if(proxy.length() > 0){
-				conn = new HttpConnection(proxy, Convert.parseInt(port), address);
-				//Vm.debug(address);
-			} else {
-				conn = new HttpConnection(address);
-			}
-			conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-			conn.setRequestorProperty("Connection", "close");
-			conn.documentIsEncoded = true;
-			Socket sock = conn.connect();
-			ByteArray daten = conn.readData(sock);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			////Vm.debug(c_data.toString());
-			sock.close();
-			return c_data.toString();
-		}
-	
-	/**
-	*	After a fetch to gc.com the next fetches have to use the post method.
-	*	This method does exactly that. Actually this method is generic in the sense
-	*	that it can be used to post to a URL using http post.
-	*/
-	private static String fetch_post(String address, String document) throws IOException 
-	   	{
-			
-			String line = new String();
-			String totline = new String();
-			if(proxy.length()==0){
-				try {
-					// Create a socket to the host
-					String hostname = "www.geocaching.com";
-					int port = 80;
-					//InetAddress addr = InetAddress.getByName(hostname);
-					Socket socket = new Socket(hostname, port);
-				
-					// Send header
-					String path = "/seek/nearest.aspx";
-					BufferedWriter wr = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), "UTF8"));
-					BufferedReader rd = new BufferedReader(new InputStreamReader(socket.getInputStream()));
-					wr.write("POST "+path+" HTTP/1.1\r\n");
-					wr.write("Host: www.geocaching.com\r\n");
-					wr.write("Content-Length: "+document.length()+"\r\n");
-					wr.write("Content-Type: application/x-www-form-urlencoded\r\n");
-					wr.write("Connection: close\r\n");
-					wr.write("\r\n");
-					// Send data
-					wr.write(document);
-					wr.write("\r\n");
-					wr.flush();
-					//Vm.debug("Sent the data!");
-					// Get response
-					while ((line = rd.readLine()) != null) {
-						totline += line + "\n";
-					}
-					wr.close();
-					rd.close();
-				} catch (Exception e) {
-				}
-			} else {
-				HttpConnection conn;
-				conn = new HttpConnection(proxy, Convert.parseInt(port), address);
-				JavaUtf8Codec codec = new JavaUtf8Codec();
-				conn.documentIsEncoded = true;
-				//Vm.debug(address + " / " + document);
-				//document = document + "\r\n";
-				//conn.setPostData(document.toCharArray());
-				conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-				conn.setPostData(codec.encodeText(document.toCharArray(),0,document.length(),true,null));
-				conn.setRequestorProperty("Content-Type", "application/x-www-form-urlencoded");
-				conn.setRequestorProperty("Connection", "close");
-				Socket sock = conn.connect();
-				
-				//Vm.debug("getting stuff!");
-				ByteArray daten = conn.readData(sock);
-				//Vm.debug("coming back!");
-				CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-				sock.close();
-				//Vm.debug(c_data.toString());
-				totline =  c_data.toString();
-			}
-			return totline;
-		}
-		
-	/**
-	*	This mehtod is to be called after LOC files from gc.com
-	*	have been analysed. It spiders each identified cache step by step.
-	*/
-	public void SpiderLOC(Vector locs){
-		for(int i = 0; i<locs.size();i++){
-			caches_identified.add((String)locs.get(i));
-		}
-		try{
-			doSpider(Convert.toString(locs.size()), false);
-		}catch (Exception e){
-			//Vm.debug("Problem with spider");
-		}
-	}
-	
-	/**
-	*	This method spiders all caches in a radius of PERIP. It
-	*	converts to km to identify those caches outside of PERIP.
-	*	Center point is what is currently set in preferences.
-	*/
-	public void SpiderNearest(String perip){
-			//ParseLatLon pll;
-			//pbf.display(MyLocale.getMsg(800,"Collecting list"), MyLocale.getMsg(801,"collecting..."), pForm);
-			if(msgA != null)  msgA.setText(MyLocale.getMsg(801,"collecting..."));
-			double periInt = Convert.parseDouble(perip);
-			double distDbl;
-			int cacheCounter = 0;
-			int page_number = 5; //gc.com starts with 5! for page 2...
-			// initial fetch
-			//String url_for_next_page = new String();
-			String sourcePage = new String();
-			String listString = new String();
-			String v_state = new String();
-			//String ev_argument = new String(); //not used?
-			String ev_target = new String();
-			String cache = new String();
-			String dist = new String();
-			//String document = new String();
-			String NS = pref.curCentrePt.getNSLetter().equals("N") ? "1" : "-1";
-			String WE = pref.curCentrePt.getEWLetter().equals("E") ? "1" : "-1";
-			String searchStr = 
-				        "lat_ns="     + NS +
-						"&lat_h="     + pref.curCentrePt.getLatDeg(CWPoint.DMM) +
-						"&lat_mmss="  + pref.curCentrePt.getLatMin(CWPoint.DMM) +
-						"&long_ew="   + WE +
-						"&long_h="    + pref.curCentrePt.getLonDeg(CWPoint.DMM) +
-						"&long_mmss=" + pref.curCentrePt.getLatMin(CWPoint.DMM);
-			boolean more = true;
-			Extractor sourceEx, listEx, listExDist, listExCache;
-			try{
-				sourcePage = fetch("http://www.geocaching.com/seek/nearest.aspx?"+searchStr);
-			} catch (Exception ex){
-				ex.printStackTrace();
-				//Vm.debug(ex.toString());
-			}
-			//do we have a valid page or maybe there are no caches in required distance?
-			if(sourcePage.indexOf("Sorry, no results were found for this search")==-1){
-				do{
-					// analyse page
-					// first get relevant section
-					listEx = new Extractor(sourcePage, "Last Found", "Distances measured", 0, true);
-					listString = listEx.findNext();
-					//Vm.debug(listString);
-					// now get the details within the section
-					listExDist = new Extractor(listString, "<br />", "</td>", 0, true);
-					listExCache = new Extractor(listString, "</a> (", ")<br>", 0, true);
-					cache = listExCache.findNext();
-					dist = listExDist.findNext();
-					while (listExDist.endOfSearch() == false) {
-						dist = dist.substring(0, dist.length()-2);
-						if(dist.indexOf(".") == -1) dist = "0." + dist;
-						if(pref.digSeparator.equals(",")) dist = dist.replace('.',',');
-						distDbl = 0;
-						try{
-							distDbl = Convert.parseDouble(dist);
-							distDbl = distDbl * 1.6093;
-						} catch (NumberFormatException nfe){
-							Vm.debug("Number format exception: " +cache);
-						}
-						if( distDbl <= periInt) {
-							//add to list to spider
-							caches_identified.add(cache);
-							cacheCounter++;
-							//pbf.display(MyLocale.getMsg(800,"Collecting list"), Convert.toString(cacheCounter) + MyLocale.getMsg(802," caches identified: collecting more..."), pForm);
-							if(msgA != null)  msgA.setText(Convert.toString(cacheCounter) + MyLocale.getMsg(802," caches identified: collecting more..."));
-							//more = true;
-							//Vm.debug(dist +" : " +cache);
-						} else {
-							// reached edge... stop getting list pages
-							more = false;
-						}
-						cache = listExCache.findNext();
-						dist = listExDist.findNext();
-					}
-					// get next page
-					if(more == true){
-						sourceEx = new Extractor(sourcePage, "<input type=\"hidden\" name=\"__VIEWSTATE\" value=\"", "\" />",0, true);
-						v_state = sourceEx.findNext();
-						ev_target = "ResultsPager:_ctl" + Convert.toString(page_number);
-						page_number++;
-						if(page_number >= 15) page_number = 5;
-						String data = new String();
-						data = URL.encodeURL("lat_ns",false) + "=" + URL.encodeURL(NS,false);
-						data += "&" + URL.encodeURL("lat_h",false) +"="+ URL.encodeURL(pref.curCentrePt.getLatDeg(CWPoint.DMM),false);
-						data += "&" + URL.encodeURL("lat_mmss",false) +"="+ URL.encodeURL(pref.curCentrePt.getLatMin(CWPoint.DMM),false);
-						data += "&" + URL.encodeURL("long_ew",false) +"="+ URL.encodeURL(WE,false);
-						data += "&" + URL.encodeURL("long_h",false) +"="+ URL.encodeURL(pref.curCentrePt.getLonDeg(CWPoint.DMM),false);
-						data += "&" + URL.encodeURL("long_mmss",false) +"="+ URL.encodeURL(pref.curCentrePt.getLonMin(CWPoint.DMM),false);
-						data += "&" + URL.encodeURL("__EVENTTARGET",false) +"="+ URL.encodeURL(ev_target,false);
-						data += "&" + URL.encodeURL("__EVENTARGUMENT",false) +"="+ URL.encodeURL("",false);
-						data += "&" + URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(v_state,false);
-						//Vm.debug("This is viewstate: " + v_state);
-						//document = "origin_lat=" +URL.encodeURL("48",false) +"&origin_lon=" + URL.encodeURL("11",false) +"&submit3=" + URL.encodeURL("Submit",false) +	"&__EVENTTARGET="+URL.encodeURL(ev_target,false) +"&__EVENTARGUMENT=&__VIEWSTATE="+URL.encodeURL(v_state,false);
-						//document = "origin_lat=48&origin_lon=11&submit3=Submit&__EVENTTARGET="+ev_target +"&__EVENTARGUMENT=&__VIEWSTATE="+v_state;
-						//document = URL.encodeURL("lat_ns="+NS+"&lat_h="+myPref.mylgDeg+ "&lat_mmss=" +myPref.mylgMin+ "&long_ew=" + WE+ "&long_h=" + myPref.mybrDeg+ "&long_mmss=" + myPref.mybrMin +"&submit3=Submit&__EVENTTARGET="+ev_target +"&__EVENTARGUMENT=&__VIEWSTATE="+v_state,false);
-						//document = "?lat_ns=1&amp;lat_h=48&amp;lat_mmss=07.915&amp;long_ew=1&amp;long_h=11&amp;long_mmss=35.597";
-						//document = "lat_ns="+URL.encodeURL(NS,false)+"&lat_h="+URL.encodeURL(myPref.mylgDeg,false) + "&lat_mmss=" +URL.encodeURL(myPref.mylgMin,false) + "&long_ew=" + URL.encodeURL(WE,false)+ "&long_h=" + URL.encodeURL(myPref.mybrDeg,false) + "&long_mmss=" + URL.encodeURL(myPref.mybrMin,false) +"&submit3=" + URL.encodeURL("Submit",false) +	"&__EVENTTARGET="+URL.encodeURL(ev_target,false) +"&__EVENTARGUMENT="+URL.encodeURL("",false) +	"&__VIEWSTATE="+URL.encodeURL(v_state,false);
-						//document = "__EVENTTARGET="+URL.encodeURL(ev_target,false) +"&__EVENTARGUMENT="+URL.encodeURL("",false) +	"&__VIEWSTATE="+URL.encodeURL(v_state,false);
-						//document = "__VIEWSTATE="+URL.encodeURL(v_state,false)+"&__EVENTTARGET="+ev_target;
-						try{
-							sourcePage = "";
-							sourcePage = fetch_post("http://www.geocaching.com/seek/nearest.aspx", data);
-							//sourcePage = fetch_post("http://localhost/post.php", data);
-							//more = false;
-							//Vm.debug(sourcePage);
-						} catch (Exception ex){
-							ex.printStackTrace();
-							////Vm.debug(ex.toString());
-						}
-					}
-					//Vm.debug("running....");
-					if(shouldStop == true) break;
-				} while (more == true);
-			}//if sourcepage valid
-			//pbf.display(MyLocale.getMsg(800,"Collecting list"), Convert.toString(cacheCounter) + MyLocale.getMsg(803," Done!"), pForm);
-			if(msgA != null) msgA.setText(Convert.toString(cacheCounter) + MyLocale.getMsg(803," Done!"));
-			if(shouldStop == false){
-				try{
-					doSpider(Convert.toString(cacheCounter), true);
-				}catch(IOException ex){
-					//Vm.debug("Problem with Spider");
-				}
-			}
-		}
-		
-		/**
-		*	Call this method to find out if a cache has already been
-		*	spidered.
-		*/
-		/*skg 20061223: Not used
-		private boolean isAlreadyFetched(String wp){
-			if(caches_available.indexOf(wp) == -1) return false;
-			else return true;
-		}
-		*/
-		/**
-		*	Method that performs a multi point spider.
-		*	User will choose this option when identification of caches
-		*	along a route is required.
-		*/
-		/**skg 20061225: Not used
-		public void SpiderMulti(Vector wpts, String dist){
-			//first save current preference settings
-			CWPoint SavedCentre=new CWPoint(pref.curCentrePt);
-			
-			//loop through the vector and perform a spidernearest
-			for(int i = 0; i<wpts.size(); i++){
-				pref.curCentrePt.set((String)wpts.get(i)); // Can use Regex here as time is not of concern
-				if(shouldStop == true) break;
-				//do the spider
-				SpiderNearest(dist);
-			}
-			
-			//save back preferences
-			pref.curCentrePt.set(SavedCentre);
-		}
-		*/
-	
-		/**
-		*	Method that actually gathers details on a cache.
-		*	The string total is just for information purposes.
-		*	This method actually loops through the vector
-		*	"caches_identified", that holds caches that are not
-		*	available in the database.
-		*/
-		private void doSpider(String total, boolean update_existing) throws IOException {
-			MapLoader mpl;
-			ParseLatLon pll;
-			Extractor cacheEx;
-			Extractor tempEx, tempEx2;
-			CacheHolder ch;
-			int doneCounter = 1;
-			String wp = new String();
-			String document = new String();
-			String imgLoc = new String();
-			String dummy = new String();
-			String dummy2 = new String();
-			String dummy3 = new String();
-			String dummy4 = new String();
-			String dummy5 = new String();
-			String dummy6 = new String();
-			boolean found = false;
-			//time to add existing caches to the identified list, ommitting double entries
-			if(shouldStop == false){
-				if(update_existing == true){
-					for(int x = 0; x < cacheDB.size(); x++){
-						found = false;
-						ch = new CacheHolder();
-						ch = (CacheHolder)cacheDB.get(x);
-						for(int y = 0; y<caches_identified.size(); y++){
-							dummy = new String();
-							dummy = (String)caches_identified.get(y);
-							dummy = dummy.trim();
-							if(ch.wayPoint.toUpperCase().equals(dummy.toUpperCase()) == true) found = true;
-						}
-						if(found == false && ch.is_found == false) caches_identified.add(ch.wayPoint);
-					}
-					total = Convert.toString(caches_identified.size());
-				}
-			}
-			for(int i = 0; i<caches_identified.size(); i++){
-				ch = new CacheHolder();
-				wp = (String)caches_identified.get(i);
-				wp = wp.trim();
-				//make sure we do not get doubles!
-				//Vm.debug(caches_available);
-				
-				//Vm.debug("Do not have going in for: " + wp);
-				//pbf.display(MyLocale.getMsg(804,"Collecting Cache Details"), MyLocale.getMsg(805,"Fetching: ") + wp + " (" +Convert.toString(doneCounter)+" of "+total+")", pForm);
-				if(msgA != null) msgA.setText(MyLocale.getMsg(805,"Fetching: ") + wp + " (" +Convert.toString(doneCounter)+" of "+total+")");
-				try{
-					document = fetch("http://www.geocaching.com/seek/cache_details.aspx?wp="+wp+"&Submit6=Find&log=y");
-				}catch(Exception ex){
-					//Vm.debug("Problem with page: "+wp);
-				}
-				//if(caches_available.indexOf(wp) == -1){	
-				cacheEx = new Extractor(document, "<span id=\"CacheName\">", "</span>",0,true);
-				ch.CacheName = cacheEx.findNext();
-				cacheEx = new Extractor(document, "<span id=\"ErrorText\">", "</span>",0,true);
-				dummy = cacheEx.findNext();
-				if(dummy.indexOf("has been archived")>=0) ch.is_archived = true;
-				if(dummy.indexOf("temporarily unavailable")>=0) ch.is_available = false;
-				
-				cacheEx = new Extractor(document, "<span id=\"CacheOwner\"><b><font size=\"2\">by ", "[<A",0,true);
-				ch.CacheOwner = cacheEx.findNext();
-				//Vm.debug(ch.CacheOwner);
-				if(ch.CacheOwner.indexOf(pref.myAlias)>=0) ch.is_owned = true;
-				if(ch.is_owned == true) ch.CacheStatus = "Owner";
-				cacheEx = new Extractor(document, "<span id=\"LatLon\"><font size=\"3\">", "</STRONG><br /><STRONG></font></span>",0,true);
-				ch.LatLon = cacheEx.findNext();
-				ch.LatLon = replace(ch.LatLon, "?", "&#176;");
-				cacheEx = new Extractor(document, "<span id=\"DateHidden\">", "</span>",0,true);
-				ch.DateHidden = cacheEx.findNext();
-				ch.wayPoint = wp;
-				cacheEx = new Extractor(document, "<span id=\"ShortDescription\">", "</span>",0,true);
-				ch.LongDescription = cacheEx.findNext();
-				cacheEx = new Extractor(document, "<span id=\"LongDescription\">", "<STRONG>Additional Hints&nbsp;",0,true);
-				ch.LongDescription += cacheEx.findNext();
-				cacheEx = new Extractor(document, "<span id=\"Hints\">", "</span>",0,true);
-				ch.Hints = cacheEx.findNext();
-				cacheEx = new Extractor(document, "<img src=\"../images/WptTypes/", ".gif\"",0,true);
-				ch.type = cacheEx.findNext();
-				if(ch.type.equals("11") == false){
-					cacheEx = new Extractor(document, "This is a <strong>", "</strong> cache.",0,true);
-					ch.CacheSize = cacheEx.findNext();
-				}
-				
-				cacheEx = new Extractor(document, "<span id=\"CacheLogs\">", "</span>",0,true);
-				dummy = cacheEx.findNext();
-				//is found?
-				if(pref.myAlias.length()>0){
-					tempEx = new Extractor(dummy, "icon_smile.gif", "</A>",0,true);
-					dummy3 = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						if(dummy3.indexOf(pref.myAlias)>0) ch.is_found = true;
-						dummy3 = tempEx.findNext();
-					}
-					tempEx = new Extractor(dummy, "icon_camera.gif", "</A>",0,true);
-					dummy3 = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						if(dummy3.indexOf(pref.myAlias)>0) ch.is_found = true;
-						dummy3 = tempEx.findNext();
-					}
-					tempEx = new Extractor(dummy, "icon_attended.gif", "</A>",0,true);
-					dummy3 = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						if(dummy3.indexOf(pref.myAlias)>0) ch.is_found = true;
-						dummy3 = tempEx.findNext();
-					}
-				}
-				if(ch.is_found == true) ch.CacheStatus = "Found";
-				
-				cacheEx = new Extractor(dummy, "<STRONG><IMG SRC='http:", "</font></td></tr><tr><td VALIGN='TOP' ALIGN='LEFT'><font face='Verdana' size='2'>",0,true);
-				dummy = cacheEx.findNext();
-				//int maxLogs = myPref.nLogs;
-				
-				while(cacheEx.endOfSearch() == false){
-					//maxLogs--;
-					//Vm.debug(dummy);
-					//extract any images if they exist
-					tempEx = new Extractor(dummy, "<A HREF='./log.aspx?IID=", "&", 0 ,true);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						ch.LogImages.add(imgLoc);
-						//Vm.debug(imgLoc);
-						imgLoc = tempEx.findNext();
-					}
-					
-					//Erase stuff in [...]
-					tempEx = new Extractor(dummy, "[", "]", 0, false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						dummy = replace(dummy, imgLoc, "");
-						imgLoc = tempEx.findNext();
-					}
-					
-					//rename image link to [[name_of_image]]
-					tempEx = new Extractor(dummy, "<A HREF='./log.aspx?IID=", "</A>", 0 ,false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						tempEx2 = new Extractor(imgLoc, "'>", "</", 0 ,true);
-						dummy2 = tempEx2.findNext();
-						dummy2 = dummy2.substring(0, dummy2.length()-1);
-						ch.LogImagesText.add(dummy2);
-						dummy = replace(dummy, imgLoc, " [[ "+dummy2+" ]] ");
-						imgLoc = tempEx.findNext();
-					}
-					//repoint log icons
-					dummy = replace(dummy, "<IMG SRC='../images/icon_camera.gif' align=left>", "<img src='icon_camera.gif'>");
-					dummy = replace(dummy, "<IMG SRC='../images/icon_smile.gif' align=left>", "<img src='icon_smile.gif'>");
-					dummy = replace(dummy, "<IMG SRC='../images/icon_attended.gif' align=left>", "<img src='icon_attended.gif'>");
-					
-					dummy = replace(dummy, "//www.geocaching.com/images/icons/", "<img src='");
-					
-					//Erase HTML stuff in logs
-					//table tags
-					tempEx = new Extractor(dummy, "<table", ">", 0, false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						dummy = replace(dummy, imgLoc, "");
-						imgLoc = tempEx.findNext();
-					}
-					tempEx = new Extractor(dummy, "<TABLE", ">", 0, false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						dummy = replace(dummy, imgLoc, "");
-						imgLoc = tempEx.findNext();
-					}
-					tempEx = new Extractor(dummy, "<td", ">", 0, false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						dummy = replace(dummy, imgLoc, "");
-						imgLoc = tempEx.findNext();
-					}
-					tempEx = new Extractor(dummy, "<TD", ">", 0, false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						dummy = replace(dummy, imgLoc, "");
-						imgLoc = tempEx.findNext();
-					}
-					dummy = replace(dummy, "<tr>", "");
-					dummy = replace(dummy, "<TR>", "");
-					dummy = replace(dummy, "</tr>", "");
-					dummy = replace(dummy, "</TR>", "");
-					dummy = replace(dummy, "</td>", "");
-					dummy = replace(dummy, "</TD>", "");
-					dummy = replace(dummy, "</table>", "");
-					dummy = replace(dummy, "</TABLE>", "");
-					// a href
-					tempEx = new Extractor(dummy, "<A HREF=", ">", 0, false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						dummy = replace(dummy, imgLoc, "");
-						imgLoc = tempEx.findNext();
-					}
-					tempEx = new Extractor(dummy, "<A NAME=", ">", 0, false);
-					imgLoc = new String();
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						dummy = replace(dummy, imgLoc, "");
-						imgLoc = tempEx.findNext();
-					}
-					dummy = replace(dummy, "</A>", "");
-					//End of erase html stuff in logs
-					
-					ch.CacheLogs.add(dummy);
-					dummy = cacheEx.findNext();
-				} //while
-				
-				
-				// Search for Travelbugs
-				
-				cacheEx = new Extractor(document, "<span id=\"lnkTravelBugs\">","</span>",0,true);
-				dummy = cacheEx.findNext();
-				if(dummy.length()>0){
-					cacheEx = new Extractor(dummy, "<A HREF","</A>",0,true);
-					dummy2 = cacheEx.findNext();
-					while(cacheEx.endOfSearch() == false){
-						tempEx2 = new Extractor(dummy2, "guid=","\">",0,true);
-						//we need only those where guid exist
-						dummy4 = tempEx2.findNext();
-						if(dummy4.length()>0){
-							// Have a bug, lets get description and picture
-							dummy5 = fetch("http://www.geocaching.com//track/details.aspx?guid="+dummy4);
-							tempEx = new Extractor(dummy5,"<span id=\"lbHeading\">","</span>",0,true);
-							dummy6 = tempEx.findNext();
-							ch.Bugs += "<b>Name:</b> " + dummy6 + "<br>";
-							tempEx = new Extractor(dummy5,"<span id=\"BugDetail_BugGoal\">","</span>",0,true);
-							dummy6 = tempEx.findNext();
-							ch.Bugs += "<b>Goal: </b>" + dummy6 + "<br>";
-							tempEx = new Extractor(dummy5,"<span id=\"BugDetail_BugDetails\">","</span>",0,true);
-							dummy6 = tempEx.findNext();
-							ch.Bugs += "<b>Details:</b> " + dummy6 + "<br><br><hr>";
-							ch.has_bug = true;
-						}
-						dummy2 = cacheEx.findNext();
-					}
-				}
-				// End of search for travelbugs
-				
-				cacheEx = new Extractor(document, "<span id=\"Terrain\">", "</span>",0,true);
-				dummy = cacheEx.findNext();
-				cacheEx = new Extractor(dummy, "/stargreen", "gif",0,true);
-				double counter = 0;
-				cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					counter++;
-					cacheEx.findNext();
-				}
-				cacheEx = new Extractor(dummy, "/halfstargreen", "gif",0,true);
-				cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					counter = counter + 0.5;
-					cacheEx.findNext();
-				}
-				ch.terrain = Convert.toString(counter);
-
-				counter = 0;				
-				cacheEx = new Extractor(document, "<span id=\"Difficulty\">", "</span>",0,true);
-				dummy = new String();
-				dummy = cacheEx.findNext();
-				cacheEx = new Extractor(dummy, "/staryellow", "gif",0,true);
-				cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					counter++;
-					cacheEx.findNext();
-				}
-				cacheEx = new Extractor(dummy, "/halfstaryellow", "gif",0,true);
-				cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					counter = counter + 0.5;
-					cacheEx.findNext();
-				}
-				ch.hard = Convert.toString(counter);
-				////Vm.debug("Hard: " +ch.hard + " / Terrain: " + ch.terrain);
-				// Replace image tags in description
-				// get unique images from everywhere
-				// Replace image tags in logs
-				// Get images in logs
-
-				//hier ist ein Problem....
-				//c) dann in LongDescription
-				//d) dann in den logs
-				
-				//first find cacheattributes
-				/*
-				cacheEx = new Extractor(document, "<img src=\"../images/attributes/", "\" Alt",0,true);
-				
-				img = cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					ch.attributes.add(img);
-					img = cacheEx.findNext();
-				}
-				*/
-				
-				//get the images in the image span
-				cacheEx = new Extractor(document, "<span id=\"Images\">", "</span>",0,true);
-				imgLoc = new String();
-				String tmpDoc = new String();
-				tmpDoc = cacheEx.findNext();
-				if(cacheEx.endOfSearch() == false){
-					tempEx = new Extractor(tmpDoc, "<A HREF=\"", "\" target=", 0, true);
-					imgLoc = tempEx.findNext();
-					while(tempEx.endOfSearch() == false){
-						ch.Images.add(imgLoc);
-						////Vm.debug("Got: " + imgLoc);
-						imgLoc = tempEx.findNext();
-					}
-				}
-				
-				//get and replace images in the longdescription
-				
-				////Vm.debug("1");
-				ch.LongDescription = " " + ch.LongDescription;
-				cacheEx = new Extractor(ch.LongDescription, "<img src = \"", "\"", 0 ,true);
-				imgLoc = new String();
-				imgLoc = cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					ch.Images.add(imgLoc);
-					imgLoc = cacheEx.findNext();
-				}
-				////Vm.debug("2");
-				cacheEx = new Extractor(ch.LongDescription, "<img src = \"", ">", 0 ,false);
-				imgLoc = new String();
-				imgLoc = cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					ch.LongDescription = replace(ch.LongDescription, imgLoc, "");
-					imgLoc = cacheEx.findNext();
-				}
-				
-				////Vm.debug("3--------------------------");
-				cacheEx = new Extractor(ch.LongDescription, "<img src=\"", "\"", 0 ,true);
-				imgLoc = new String();
-				imgLoc = cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					ch.Images.add(imgLoc);
-					imgLoc = cacheEx.findNext();
-				}
-				
-				////Vm.debug("4");
-				cacheEx = new Extractor(ch.LongDescription, "<img src=\"", ">", 0 ,false);
-				imgLoc = new String();
-				imgLoc = cacheEx.findNext();
-				while(cacheEx.endOfSearch() == false){
-					ch.LongDescription = replace(ch.LongDescription, imgLoc, "");
-					imgLoc = cacheEx.findNext();
-				}
-				// have all the images, now spider them!
-				HttpConnection connImg;
-				Socket sockImg;
-				FileOutputStream fos;
-				String datei = new String();
-				String imageOrig = new String();
-				String imageType = new String();
-				String imageList = new String();
-				ByteArray daten;
-				int imgCounter = 0;
-				
-				// Images 
-				//Vm.debug("Have images: " + Convert.toString(ch.Images.size()));
-				for(int p = 0; p<ch.Images.size(); p++){
-					imgCounter++;
-					imageOrig = (String)ch.Images.get(p);
-					//Vm.debug("Checking: " + imageOrig);
-					//sleep(1500);
-					//make sure we do not get the images more than once!
-					if(imageList.indexOf(imageOrig) == -1){
-						//some images are fetched using PHP
-						//we don't want these images
-						if(imageOrig.lastIndexOf(".php") <= 0){
-							imageList = imageList + ";" + imageOrig;
-							if(proxy.length()>0){
-							connImg = new HttpConnection(proxy, Convert.parseInt(port), imageOrig);
-							}else{
-								connImg = new HttpConnection(imageOrig);
-							}
-							imageType = imageOrig.substring(imageOrig.lastIndexOf("."), imageOrig.lastIndexOf(".")+4);
-							datei = profile.dataDir + ch.wayPoint + "_" + Convert.toString(imgCounter)+ imageType;
-							ch.Images.set(p, ch.wayPoint + "_" + Convert.toString(imgCounter) + imageType);
-							//connImg.keepAliveMode = true;
-							connImg.setRequestorProperty("Connection", "close");
-							//Vm.debug("Connecting...");
-							try{
-								sockImg = connImg.connect();
-								daten = connImg.readData(sockImg);
-								fos = new FileOutputStream(new File(datei));
-								fos.write(daten.toBytes());
-								fos.close();
-								sockImg.close();
-							}catch(IOException ioex){
-								//Vm.debug("File not found!");
-								ch.Images.removeElementAt(p);
-							}
-						}
-					} else {
-						ch.Images.removeElementAt(p);
-					}
-				}
-				//Log Images
-				//Vm.debug("Going into log images");
-				
-				for(int p = 0; p<ch.LogImages.size(); p++){
-					imgCounter++;
-					imageOrig = (String)ch.LogImages.get(p);
-					//Vm.debug("Fetching Log Image: " +imageOrig);
-					datei = profile.dataDir + ch.wayPoint + "_L_" + Convert.toString(imgCounter)+ ".jpg";
-					File dateiF = new File(datei);
-					//no need to save the file if it already exists!
-					ch.LogImages.set(p, ch.wayPoint + "_L_" + Convert.toString(imgCounter) + ".jpg");
-					if(!dateiF.exists()){
-						imageOrig = "http://img.groundspeak.com/cache/log/"+imageOrig+".jpg";
-						if(proxy.length()>0){
-							connImg = new HttpConnection(proxy, Convert.parseInt(port), imageOrig);
-						}else{
-							connImg = new HttpConnection(imageOrig);
-						}
-						//connImg.keepAliveMode = true;
-						connImg.setRequestorProperty("Connection", "close");
-						sockImg = connImg.connect();
-						daten = connImg.readData(sockImg);
-						fos = new FileOutputStream(dateiF);
-						fos.write(daten.toBytes());
-						
-						fos.close();
-						sockImg.close();
-					} //if file does not exist
-				}
-				
-				//Vm.debug("Out of log images...");
-				
-				//Now check if cache has already been spidered earlier.
-				//If yes change the status flags accordingly
-				if(caches_available.indexOf(ch.wayPoint) < 0){ //no, this is a new cache
-					//Vm.debug("Cache is new exists!!!!!!!!!!!!");
-					ch.is_new = true;
-					ch.is_update = false;
-					ch.is_log_update = false;
-					cacheDB.add(ch);
-					caches_available = caches_available + ";" +wp;
-				}else{ //yes cache exists
-					//Vm.debug("Cache exists!!!!!!!!!!!!");
-					CacheHolder checkCache = getCache(ch.wayPoint);
-					ch.is_new = false;
-					ch.is_update = false;
-					ch.is_log_update = false;
-					//Check if description changed
-					if(ch.LongDescription.equals(checkCache.LongDescription) == false){
-						ch.is_update = true;
-						//Vm.debug(ch.LongDescription + "\n\n--------------\n\n");
-						//Vm.debug(checkCache.LongDescription);
-					}
-					//Check if there are new logs
-					/*
-					if(ch.CacheLogs.size() != checkCache.CacheLogs.size()){
-						ch.is_log_update = true;
-						//Vm.debug("Log check: spidered: " + ch.CacheLogs.size() + " old: "+ checkCache.CacheLogs.size());
-					}*/
-					changeCache(ch);
-				}
-				
-				ch.saveCacheDetails(profile.dataDir);	
-				ch.CacheName = SafeXML.cleanback(ch.CacheName);
-				if(ch.CacheName.equals("An Error Has Occured")){
-					ch.type = "0";
-				}
-				ch.LatLon = SafeXML.cleanback(ch.LatLon);
-				ch.CacheOwner = SafeXML.cleanback(ch.CacheOwner);
-				//} // if cache exists				
-				//Save cache index list (index.xml)
-				//after each spider
-				document = new String();
-				doneCounter++;
-				profile.saveIndex(pref);
-				if(!ch.CacheName.equals("An Error Has Occured") && ch.LatLon.length() > 1){
-					pll = new ParseLatLon(ch.LatLon,".");
-					pll.parse();
-					mpl = new MapLoader(pll.getLatDeg(),pll.getLonDeg(), pref.myproxy, pref.myproxyport);
-					mpl.loadTo(profile.dataDir + "/" + ch.wayPoint + "_map.gif", "3");
-					mpl.loadTo(profile.dataDir + "/" + ch.wayPoint + "_map_2.gif", "10");
-				}
-				if(shouldStop == true) break;
-			} // for
-			/*
-			for(int i = 0; i < cacheDB.size();i++){
-				ch = (CacheHolder)cacheDB.get(i);
-				ch.CacheName = SafeXML.cleanback(ch.CacheName);
-				ch.LatLon = SafeXML.cleanback(ch.LatLon);
-				ch.CacheOwner = SafeXML.cleanback(ch.CacheOwner);
-				cacheDB.set(i, ch);
-			}*/
-
-			//pbf.clear();
-		}
-		
-		private void changeCache(CacheHolder ch){
-			CacheHolder retCH = new CacheHolder();
-			String waypoint = new String();
-			waypoint = ch.wayPoint;
-			int i = 0;
-			for(i = 0; i<cacheDB.size();i++){
-				retCH = new CacheHolder();
-				retCH = (CacheHolder)cacheDB.get(i);
-				if(retCH.wayPoint.equals(waypoint)) break;
-			}
-			cacheDB.set(i,ch);
-		}
-		
-		/**
-		*	This method will load all information available for a
-		*	cache. It returns a CacheHolder object.
-		*/
-		private CacheHolder getCache(String waypoint){
-			CacheHolder retCH=null;
-			for(int i = 0; i<cacheDB.size();i++){
-				retCH = (CacheHolder)cacheDB.get(i);
-				if(retCH.wayPoint.equals(waypoint)) {
-					try{
-						retCH.readCache(profile.dataDir);
-					}catch(Exception ex){};
-					return retCH;
-				}
-			}
-			return retCH;
-		}
-		
-		/**
-		 *   Replace all instances of a String in a String.
-		 *   @param  s  String to alter.
-		 *   @param  f  String to look for.
-		 *   @param  r  String to replace it with, or null to just remove it.
-		 */ 
-		private String replace( String s, String f, String r )
-		{
-		   if (s == null)  return s;
-		   if (f == null)  return s;
-		   if (r == null)  r = "";
-		
-		   int index01 = s.indexOf( f );
-		   while (index01 != -1)
-		   {
-			  s = s.substring(0,index01) + r + s.substring(index01+f.length());
-			  index01 += r.length();
-			  index01 = s.indexOf( f, index01 );
-		   }
-		   return s;
-		}
-}



From admin at berlios.de  Sun Jan  7 18:09:16 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 7 Jan 2007 18:09:16 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2203] Markierungen
Message-ID: <200701071709.l07H9GNW007575@unicorn.berlios.de>

Feature Request #2203, was updated on 2006-May-09 21:06
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2203&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Markierungen

By: kalli
Date: 2007-Jan-07 18:09

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

erledigt

----------------------------------------------------------------------

By: albsucher
Date: 2006-Dec-06 22:10

Message:
Logged In: YES 
user_id=26380
Browser: Mozilla/5.0 (X11; U; Linux i686; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

Ich frag mich ob wir evt. etwas gegens?tzliches meinen,
daher nochmals meine Idee:
In der Listenansicht sollten nicht nur der Cache selbst
sondern alle additional waypoints ebenfalls so markiert
werden wie der cache selbst (z.B. gefunden, owner,...)
Das erleichtert die ?bersicht.

Die Idee mit dem markieren find ich dennoch nicht schlecht,
so findet man schnell alle zugeh??rigen wp's.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2203&group_id=2211


From kalli at mail.berlios.de  Sun Jan  7 18:18:25 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 7 Jan 2007 18:18:25 +0100
Subject: [Cachewolf-svn] r359 - trunk/src/CacheWolf
Message-ID: <200701071718.l07HIPkL001217@sheep.berlios.de>

Author: kalli
Date: 2007-01-07 18:18:24 +0100 (Sun, 07 Jan 2007)
New Revision: 359

Removed:
   trunk/src/CacheWolf/LoadScreen.java
   trunk/src/CacheWolf/Spider.java
Log:
Files LoadScreen.java und Spider.java geloescht.
Geht ganz einfach: z.B. in eclipse rechten Mausklick auf die Datei im Package Explorer, dann Delete. Danach ein Commit gemacht, und schwupps sind sie weg (ab der Revision).


Deleted: trunk/src/CacheWolf/LoadScreen.java
===================================================================

Deleted: trunk/src/CacheWolf/Spider.java
===================================================================



From pfeffer at mail.berlios.de  Sun Jan  7 18:31:16 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 7 Jan 2007 18:31:16 +0100
Subject: [Cachewolf-svn] r360 - trunk/src/CacheWolf
Message-ID: <200701071731.l07HVGll005513@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-07 18:31:12 +0100 (Sun, 07 Jan 2007)
New Revision: 360

Modified:
   trunk/src/CacheWolf/TrackOverlay.java
Log:
Debug-zeugs entfernt

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-01-07 17:18:24 UTC (rev 359)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-01-07 17:31:12 UTC (rev 360)
@@ -109,7 +109,7 @@
 	}
 
 	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
-		if (trackPixels==null) { trackPixels = new Point[1]; trackPixelsColor = new Color[1000]; } 
+		if (trackPixels==null) { trackPixels = new Point[500]; trackPixelsColor = new Color[500]; } 
 		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
 		trackPixelsColor[numPixels] = f.getCopy();
 		numPixels++;
@@ -144,10 +144,9 @@
 			g.setColor(trackPixelsColor[i]);
 			g.fillRect(trackPixels[i].x-1, trackPixels[i].y-1, 3, 3);
 		}
-		g.drawText(Convert.toString(test), 10, 10);
-		g.drawRect(10 + test, 10, 10, 10);
-		//g.setPixelRGB(x, y, rgb);
-		test++;
+		//g.drawText(Convert.toString(test), 10, 10);
+		//g.drawRect(10 + test, 10, 10, 10);
+		//test++;
 	}
 }
 



From salzkammergut at mail.berlios.de  Sun Jan  7 20:40:55 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Jan 2007 20:40:55 +0100
Subject: [Cachewolf-svn] r361 - in trunk: resources src/CacheWolf
Message-ID: <200701071940.l07JetZA031515@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-07 20:40:51 +0100 (Sun, 07 Jan 2007)
New Revision: 361

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/TablePanel.java
Log:
Update vom PreferencesScreen in zwei Tabs (kann kuenftig leicht erweitert werden).
Neue Optionen zur Darstellung (Menue unten, Tabs unten).

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-07 17:31:12 UTC (rev 360)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-07 19:40:51 UTC (rev 361)
@@ -88,6 +88,11 @@
 		324= - neu versuchen?
 		325=Zuwenige Referenzpunkte, Karte nicht kalibriert
 		326=Es steht keine kalibrierte Karte zur Verf%fcgung
+		340=Cachebilder:
+		341=Eigene Bilder:
+		342=Gel%f6scht
+		343=Nicht genug Speicher um Bild zu laden
+		344=Datei l%f6schen
 		400=Dekodieren
 		500=Umschalten
 		600=Pr%e4ferenzen
@@ -111,6 +116,15 @@
 		618=Kopieren
 		619=Parse
 		620=Speichern
+		621=Allgemein
+		622=Ansicht
+		623=Bilder:
+		624=Gel%f6schte Bilder zeigen
+		625=Ansicht (braucht Neustart):
+		626=Men%fc oben
+		627=Tabs oben
+		628=Status zeigen
+		629=Profil auto. laden
 		700=Filter setzen
 		701=Entfernung
 		702=Schwierigkeit
@@ -324,6 +338,11 @@
 		324= - retry?
 		325=Not enough reference points, map not calibrated
 		326=No calibrated map available
+		340=Cache Images:
+		341=User Images:
+		342=Deleted
+		343=Not enough free memory to load cache image
+		344=Delete image
 		400=Dekode
 		500=Switch
 		600=Preferences
@@ -347,6 +366,15 @@
 		618=Copy
 		619=Parse
 		620=Save
+		621=General
+		622=Screen
+		623=Images:
+		624=Show deleted images
+		625=Screen layout (needs restart):
+		626=Menu top
+		627=Tabs top
+		628=Show status
+		629=Autoload last profile
 		700=Set filter
 		701=Distance
 		702=Difficulty

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-07 17:31:12 UTC (rev 360)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-07 19:40:51 UTC (rev 361)
@@ -10,7 +10,7 @@
 */
 public class MainForm extends Form {
 	
-	StatusBar statBar;
+	StatusBar statBar=null;
 	Preferences pref = Global.getPref(); // Singleton pattern
 	Profile profile = Global.getProfile();
 	MainTab mTab;
@@ -68,9 +68,14 @@
 			}
 		} else Vm.setSIP(0);
 		//Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
-		statBar = new StatusBar(pref, profile.cacheDB);
-		this.addLast(mMenu = new MainMenu(this),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		this.addLast(mTab = new MainTab(pref,profile,statBar),CellConstants.STRETCH, CellConstants.FILL);
+		if (pref.showStatus) statBar = new StatusBar(pref, profile.cacheDB);
+		if (pref.menuAtTop) {
+			this.addLast(mMenu = new MainMenu(this),CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(mTab = new MainTab(pref,profile,statBar),CellConstants.STRETCH, CellConstants.FILL);
+		} else {
+			this.addLast(mTab = new MainTab(pref,profile,statBar),CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(mMenu = new MainMenu(this),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		}
 		mMenu.setTablePanel(mTab.getTablePanel());
 		
 	}

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-07 17:31:12 UTC (rev 360)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-07 19:40:51 UTC (rev 361)
@@ -33,6 +33,7 @@
 	public MainTab(Preferences p, Profile prof,StatusBar statBar){
 		pref = p;
 		profile=prof;
+		if (!pref.tabsAtTop) tabLocation=SOUTH;
 		cDB = profile.cacheDB;
 		MyLocale.setSIPButton();
 		ch.wayPoint = "null";

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-07 17:31:12 UTC (rev 360)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-07 19:40:51 UTC (rev 361)
@@ -11,8 +11,6 @@
 *	A class to hold the preferences that were loaded upon start up of CacheWolf.
 *	This class is also capable of parsing the prefs.xml file as well as
 *	saving the current settings of preferences.
-*  Last change:
-*    20061123 salzkammergut Added garminConn, used MyLocale
 */
 public class Preferences extends MinML{
 	
@@ -58,7 +56,11 @@
 	public String lastDistOC[] = new String[4];
 	public String garminConn="com1";  // The type of connection which GPSBABEL uses: com1 OR usb.
 	// TODO Add garminConn to user interface. For the time being this can only be set by manually editing the pref file
-		
+
+	public boolean menuAtTop=true;
+	public boolean tabsAtTop=true;
+	public boolean showStatus=true;
+	
 	//public String last_sync_opencaching = new String();
 	//public String distOC = new String();
 	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
@@ -355,6 +357,11 @@
 		if (name.equals("imagepanel")) {
 			showDeletedImages = Boolean.valueOf(atts.getValue("showdeletedimages")).booleanValue();
 		}
+		if (name.equals("screen")) {
+			menuAtTop=Boolean.valueOf(atts.getValue("menuattop")).booleanValue();
+			tabsAtTop=Boolean.valueOf(atts.getValue("tabsattop")).booleanValue();
+			showStatus=Boolean.valueOf(atts.getValue("showstatus")).booleanValue();
+		}
 	}
 
 	public void characters( char ch[], int start, int length )
@@ -422,6 +429,7 @@
 			outp.print("    <fixedsip state = \""+fixSIP+"\"/>\n");
 			outp.print("    <garmin connection = \""+garminConn+"\"/>\n");
 			outp.print("    <lastprofile autoreload=\""+autoReloadLastProfile+"\">"+lastProfile+"</lastprofile>\n"); //RB
+			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\"/>\n");
 			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			// Obsolete data kept for backward compatibility

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2007-01-07 17:31:12 UTC (rev 360)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2007-01-07 19:40:51 UTC (rev 361)
@@ -15,77 +15,117 @@
 public class PreferencesScreen extends Form {
 	mButton cancelB, applyB, brwBt, gpsB,btnCentre;
 	mChoice NS, EW;
-	mInput NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize;
-	mCheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad;
+	mInput NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS;
+	mCheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, 
+	          chkTabsAtTop, chkShowStatus;
+	mTabbedPanel mTab;
+	mChoice chcGarminPort;
+	
 	Preferences pref;
-
-	CellPanel content = new CellPanel();
+	
+	CellPanel pnlGeneral = new CellPanel();
+	CellPanel pnlDisplay = new CellPanel();
 	ScrollBarPanel scp;
+	String [] garminPorts= new String[]{"com1","com2","com3","com4","usb"};
 	
 	public PreferencesScreen (Preferences p){
-		scp = new ScrollBarPanel(content);
+		mTab=new mTabbedPanel();
+		
+		//scp = new ScrollBarPanel(pnlGeneral);
 		pref = p;
 		this.title = MyLocale.getMsg(600,"Preferences");
 		//this.resizable = false;
 		//this.moveable = true;
 		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 		
-		
-		content.addNext(new mLabel(MyLocale.getMsg(601,"Your Alias:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addLast(new mLabel("Browser:"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		/////////////////////////////////////////////////////////
+		// First panel - General
+		/////////////////////////////////////////////////////////
+		pnlGeneral.addNext(new mLabel(MyLocale.getMsg(601,"Your Alias:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addNext(new mLabel("Browser:"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addLast(gpsB = new mButton("GPS"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
 		Alias = new mInput();
 		Browser = new mInput();
 		Alias.setText(pref.myAlias);
 		Browser.setText(pref.browser);
-		content.addNext(Alias,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addNext(Alias,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//content.addNext(Alias.setTag(Control.SPAN, new Dimension(3,1)),content.DONTSTRETCH, (content.HFILL|content.WEST));
-		content.addNext(Browser,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addLast(gpsB = new mButton("GPS"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-
-			//content.addLast(new mLabel(MyLocale.getMsg(602,"Your Location:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			//content.addLast(btnCentre = new mButton(pref.curCentrePt.toString(CWPoint.CW)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-			content.addNext(new mLabel(MyLocale.getMsg(603,"Data Directory:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			content.addLast(brwBt = new mButton(MyLocale.getMsg(604,"Browse")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
-			DataDir = new mInput();
-			DataDir.setText(pref.baseDir);
-			content.addLast(DataDir.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
-			content.addLast(chkAutoLoad = new mCheckBox("Autoload last profile"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
+		pnlGeneral.addNext(Browser,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addLast(inpGPS=new mInput(""));
+		inpGPS.modify(ControlConstants.Disabled|ControlConstants.NoFocus,0);
+		inpGPS.setText(pref.mySPO.portName+"/"+pref.mySPO.baudRate);
+		
+		pnlGeneral.addNext(new mLabel(MyLocale.getMsg(603,"Data Directory:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addLast(brwBt = new mButton(MyLocale.getMsg(604,"Browse")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
+		DataDir = new mInput();
+		DataDir.setText(pref.baseDir);
+		pnlGeneral.addLast(DataDir.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
+		pnlGeneral.addLast(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629,"Autoload last profile")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
 			
 		//content.addNext(nLogs = new mInput(),content.DONTSTRETCH, (content.DONTFILL|content.WEST));
 		//nLogs.setText(Convert.toString(myPreferences.nLogs));
 		//content.addLast(new mLabel("Logs"), content.DONTSTRETCH, (content.DONTFILL|content.WEST));
-		content.addNext(new mLabel("Proxy"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addNext(new mLabel("Port"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addLast(new mLabel("Font"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addNext(Proxy = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlGeneral.addNext(new mLabel("Proxy"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addNext(new mLabel("Port"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addLast(new mLabel("Font"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addNext(Proxy = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		Proxy.setText(pref.myproxy);
-		content.addNext(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		content.addLast(fontSize = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlGeneral.addNext(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlGeneral.addLast(fontSize = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		ProxyPort.setText(pref.myproxyport);
 		fontSize.setText(Convert.toString(pref.fontSize));
-		content.addLast(new mLabel(MyLocale.getMsg(605,"Display Preferences")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addNext(dif = new mCheckBox(MyLocale.getMsg(606,"Difficulty")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlGeneral.addNext(new mLabel("Garmin PC Port"));
+		pnlGeneral.addNext(chcGarminPort=new mChoice(garminPorts,0));
+		chcGarminPort.selectItem(pref.garminConn);
+		pnlGeneral.addLast(new mLabel(""));
+		
+		/////////////////////////////////////////////////////////
+		// Second panel - Screen
+		/////////////////////////////////////////////////////////
+		
+		pnlDisplay.addLast(new mLabel(MyLocale.getMsg(605,"Display Preferences")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addNext(dif = new mCheckBox(MyLocale.getMsg(606,"Difficulty")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[2] == 1) dif.setState(true);
-		content.addNext(ter = new mCheckBox(MyLocale.getMsg(607,"Terrain")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addNext(ter = new mCheckBox(MyLocale.getMsg(607,"Terrain")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[3] == 1) ter.setState(true);
-		content.addLast(loc = new mCheckBox(MyLocale.getMsg(608,"Location")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addLast(loc = new mCheckBox(MyLocale.getMsg(608,"Location")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[6] == 1) loc.setState(true);
-		content.addNext(own = new mCheckBox(MyLocale.getMsg(609,"Owner")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addNext(own = new mCheckBox(MyLocale.getMsg(609,"Owner")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[7] == 1) own.setState(true); 
-		content.addNext(hid = new mCheckBox(MyLocale.getMsg(610,"Hidden")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addNext(hid = new mCheckBox(MyLocale.getMsg(610,"Hidden")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[8] == 1) hid.setState(true);
-		content.addLast(stat = new mCheckBox(MyLocale.getMsg(611,"Status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addLast(stat = new mCheckBox(MyLocale.getMsg(611,"Status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[9] == 1) stat.setState(true);
-		content.addNext(dist = new mCheckBox(MyLocale.getMsg(612,"Distance")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addNext(dist = new mCheckBox(MyLocale.getMsg(612,"Distance")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[10] == 1) dist.setState(true);
-		content.addLast(bear = new mCheckBox(MyLocale.getMsg(613,"Bearing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addLast(bear = new mCheckBox(MyLocale.getMsg(613,"Bearing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[11] == 1) bear.setState(true);
-		content.addNext(cancelB = new mButton(MyLocale.getMsg(614,"Cancel")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addLast(applyB = new mButton(MyLocale.getMsg(615,"Apply")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addLast(new mLabel(MyLocale.getMsg(623,"Images")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,"Show deleted images")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
+		pnlDisplay.addLast(new mLabel(MyLocale.getMsg(625,"Screen layout (needs restart)")));
+		pnlDisplay.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,"Menu top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		chkMenuAtTop.setState(pref.menuAtTop);
+		pnlDisplay.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,"Tabs top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		chkTabsAtTop.setState(pref.tabsAtTop);
+		pnlDisplay.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,"Show status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		chkShowStatus.setState(pref.showStatus);
+		//pnlDisplay.addLast(new mLabel(""));
+		
+		
+		mTab.addCard(pnlGeneral,MyLocale.getMsg(621,"General"),null);
+		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,"Screen"),null);
+		//this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+		
+		this.addLast(mTab);
+		addNext(cancelB = new mButton(MyLocale.getMsg(614,"Cancel")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		addLast(applyB = new mButton(MyLocale.getMsg(615,"Apply")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
 	
-		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+
+	
 	}
 	
 	public void onEvent(Event ev){
@@ -122,6 +162,11 @@
 				pref.tablePrefs[10] = (dist.getState()==true ? 1 : 0);
 				pref.tablePrefs[11] = (bear.getState()==true ? 1 : 0);
 				pref.autoReloadLastProfile=chkAutoLoad.getState();
+				pref.showDeletedImages=chkShowDeletedImg.getState();
+				pref.garminConn=chcGarminPort.getSelectedItem().toString();
+				pref.menuAtTop=chkMenuAtTop.getState();
+				pref.tabsAtTop=chkTabsAtTop.getState();
+				pref.showStatus=chkShowStatus.getState();
 				pref.savePreferences();
 				pref.dirty = true; // Need to update table in case columns were enabled/disabled
 				this.close(0);
@@ -144,6 +189,8 @@
 					pref.mySPO.baudRate = spo.baudRate;
 					pref.forwardGPS = spo.forwardGpsChkB.getState();
 					pref.forwardGpsHost = spo.inputBoxForwardHost.getText();
+					inpGPS.setText(pref.mySPO.portName+"/"+pref.mySPO.baudRate);
+
 				}
 			}
 			// change destination waypoint

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-07 17:31:12 UTC (rev 360)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-07 19:40:51 UTC (rev 361)
@@ -48,7 +48,7 @@
 		}
 */		
 		addLast(new ScrollBarPanel(tc = new myTableControl()));
-		addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		if (statBar!=null) addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1019,"Center"),"-",MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all")},MyLocale.getMsg(1013,"With selection"));
 		tc.setMenu(m);
 		tc.profile=profile;
@@ -96,13 +96,13 @@
 		// tc.setTableModel(myMod); Not needed ?
 		myMod.updateRows();
 		tc.update(true);
-		statBar.updateDisplay();
+		if (statBar!=null) statBar.updateDisplay();
 	}
 	
 	public void refreshTable(){
 		myMod.updateRows();
 		tc.update(true);
-		statBar.updateDisplay();
+		if (statBar!=null) statBar.updateDisplay();
 	}
 	
 	/**



From pfeffer at mail.berlios.de  Sun Jan  7 21:38:53 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 7 Jan 2007 21:38:53 +0100
Subject: [Cachewolf-svn] r362 - in trunk: resources src/CacheWolf
Message-ID: <200701072038.l07Kcr3e007246@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-07 21:38:50 +0100 (Sun, 07 Jan 2007)
New Revision: 362

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MovingMap.java
Log:
in der MovingMap k?\195?\182nnen jetzt leere Karten mit unterschiedlichen Massstaeben gewaehlt werden

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-07 19:40:51 UTC (rev 361)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-07 20:38:50 UTC (rev 362)
@@ -88,6 +88,7 @@
 		324= - neu versuchen?
 		325=Zuwenige Referenzpunkte, Karte nicht kalibriert
 		326=Es steht keine kalibrierte Karte zur Verf%fcgung
+		327=Information
 		340=Cachebilder:
 		341=Eigene Bilder:
 		342=Gel%f6scht
@@ -233,6 +234,7 @@
 		1618=Ignoriere Fehler in Cache:+
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
+		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp?ter erneut versuchen\n Status:
 		2000=GPX Export
 		2001=von
 		3000=Schlie%dfen
@@ -338,6 +340,7 @@
 		324= - retry?
 		325=Not enough reference points, map not calibrated
 		326=No calibrated map available
+		327=Information
 		340=Cache Images:
 		341=User Images:
 		342=Deleted
@@ -482,6 +485,7 @@
 		1618=Ignoring error in Cache:+
 		1619=: could not download image from URL:+
 		1620=downloading embedded images:+
+		1621=Error while interpreting data\n from Opencaching.de,\nThis is most probaly a bug at Opencaching.de\nRetry later\n Status:
 		2000=GPX Export
 		2001=of
 		3000=Close

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-07 19:40:51 UTC (rev 361)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-07 20:38:50 UTC (rev 362)
@@ -168,8 +168,6 @@
 
 	boolean mapsLoaded = false;
 	public boolean runMovingMap = false;
-	Vector availableMaps = new Vector();
-	MapInfoObject tempMIO = new MapInfoObject();
 	MovingMap mmp;
 	Track currTrack;
 
@@ -595,54 +593,17 @@
 			//Start moving map
 			if (ev.target == btnMap){
 				runMovingMap = true;
-				if (mmp != null && mmp.mmp.mapImage != null) {
-					if (serThread == null || !serThread.isAlive() ) {
-						// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-						mmp.ignoreGps = false;
-						mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
-						mmp.ignoreGps = true;
-					}
-					if (currTrack != null) mmp.addTrack(currTrack);
-					mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
-					mmp.exec();
+				if (mmp == null) mmp = new MovingMap(pref, this, cacheDB); // this also loads the list of maps
+				if (serThread == null || !serThread.isAlive() ) {
+					// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
+					mmp.ignoreGps = false;
+					mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
+					mmp.ignoreGps = true;
 				}
-				else {
-					if(mapsLoaded == false){
-						Vm.showWait(true);
-						InfoBox inf = new InfoBox("Info", "Loading list of maps...");
-						inf.exec();
-						String dateien[];
-						String mapsPath = new String();
-						mapsPath = File.getProgramDirectory() + "/maps/";
-						File files = new File(mapsPath);
-						Extractor ext;
-						String rawFileName = new String();
-						dateien = files.list("*.png", File.LIST_FILES_ONLY);
-						for(int i = 0; i < dateien.length;i++){
-							ext = new Extractor(dateien[i], "", ".", 0, true);
-							rawFileName = ext.findNext();
-							try {
-								tempMIO = new MapInfoObject();
-								tempMIO.loadwfl(mapsPath, rawFileName);
-								availableMaps.add(tempMIO);
-								mapsLoaded = true;
-							}catch(IOException ex){ } // TODO etwas genauer auch Fehlermeldung ausgeben? Bei vorhandenen .wfl-Datei mit ung?ltigen Werten Fehler ausgeben oder wie jetz einfach ignorieren?
-						}
-						inf.close(0);
-					} // if(mapsLoaded == false)
-					mmp = new MovingMap(pref, availableMaps, this, cacheDB);
-					Vm.showWait(false);
-					if (serThread == null || !serThread.isAlive() ) {
-						// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-						mmp.loadMap(toPoint.latDec, toPoint.lonDec);
-					} else
-						mmp.loadMap(gpsPosition.latDec, gpsPosition.lonDec);
-					if (currTrack != null) mmp.addTrack(currTrack);
-					mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
-					mmp.exec();
-				}
-
-			} // if (ev.target == btnMap
+				if (currTrack != null) mmp.addTrack(currTrack);
+				mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
+				mmp.exec();
+			} 
 			// create new waypoint with current GPS-position
 			if (ev.target == btnSave){
 				CacheHolder ch = new CacheHolder();

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-07 19:40:51 UTC (rev 361)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-07 20:38:50 UTC (rev 362)
@@ -45,9 +45,31 @@
  */	
 	
 	public MapInfoObject() {
-		double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
-		if(testA == 4.5) digSep = ","; else digSep = ".";
+		digSep = MyLocale.getDigSeparator();
+		//double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
+		//if(testA == 4.5) digSep = ","; else digSep = ".";
 	}
+	
+	/*
+	 * constructes an MapInfoObject without an associated map
+	 * but with 1 Pixel = scale meters
+	 */
+	public MapInfoObject(double scale) {
+		digSep = MyLocale.getDigSeparator();
+		mapName="empty 1 Pixel = "+scale+"meters";
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scale;
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deg; //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=0; //left
+		affine[5]=1; //top
+		lowlat = 0; //bottom 
+		lowlon = 1; //right
+		doCalculations();
+	}
+	
 	/**
 	 * Method to load a .wfl-file
 	 * @throws IOException when there was a problem reading .wfl-file

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-07 19:40:51 UTC (rev 361)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-07 20:38:50 UTC (rev 362)
@@ -2,6 +2,8 @@
 
 import ewe.ui.*;
 import ewe.graphics.*;
+import ewe.io.File;
+import ewe.io.IOException;
 import ewe.sys.*;
 import ewe.fx.*;
 import ewe.util.Vector;
@@ -44,18 +46,81 @@
 	boolean ignoreGps = false;
 	boolean ignoreGpsStatutsChanges = false;
 	boolean autoSelectMap = true;
+	boolean forceMapLoad = false; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
 	
-	public MovingMap(Preferences pref, Vector maps, GotoPanel gP, Vector cacheDB){
+	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
 		this.cacheDB = cacheDB;
 		gotoPanel = gP;
-		this.maps = maps;
 		this.pref = pref;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		this.title = "Moving Map";
+		this.backGround = Color.Black;
 		currentMap = new MapInfoObject();
-		mmp = new MovingMapPanel(this, maps, gotoPanel, cacheDB);
+		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
+		mmp.addImage(posCircle);
+		setGpsStatus(noGPS);
+		ButtonImageChooseMap.setLocation(10,10);
+		ButtonImageChooseMap.properties = AniImage.AlwaysOnTop;
+		ButtonImageGpsOn.setLocation(pref.myAppWidth-25, 10);
+		ButtonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		arrowUp.setLocation(pref.myAppWidth/2, 10);
+		arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
+		arrowLeft.setLocation(10, pref.myAppHeight/2+7);
+		arrowRight.setLocation(pref.myAppWidth-25, pref.myAppHeight/2+7);
+		arrowUp.properties = AniImage.AlwaysOnTop;
+		arrowDown.properties = AniImage.AlwaysOnTop;
+		arrowLeft.properties = AniImage.AlwaysOnTop;
+		arrowRight.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(arrowUp);
+		mmp.addImage(arrowDown);
+		mmp.addImage(arrowLeft);
+		mmp.addImage(arrowRight);
+		mmp.addImage(ButtonImageChooseMap);
+		mmp.addImage(ButtonImageGpsOn);
+		posCircle.properties = AniImage.AlwaysOnTop;
+		loadMaps();
 	}
+
+	/**
+	 * loads the list of maps
+	 *
+	 */
+	public void loadMaps(){
+		Vm.showWait(true);
+		resetCenterOfMap();
+		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
+		inf.exec();
+		maps = new Vector();
+		String dateien[];
+		String mapsPath = new String();
+		mapsPath = File.getProgramDirectory() + "/maps/";
+		File files = new File(mapsPath);
+		Extractor ext;
+		String rawFileName = new String();
+		dateien = files.list("*.png", File.LIST_FILES_ONLY);
+		MapInfoObject tempMIO;
+		for(int i = 0; i < dateien.length;i++){
+			ext = new Extractor(dateien[i], "", ".", 0, true);
+			rawFileName = ext.findNext();
+			try {
+				tempMIO = new MapInfoObject();
+				tempMIO.loadwfl(mapsPath, rawFileName);
+				maps.add(tempMIO);
+			}catch(IOException ex){ } // TODO etwas genauer auch Fehlermeldung ausgeben? Bei vorhandenen .wfl-Datei mit ung?ltigen Werten Fehler ausgeben oder wie jetz einfach ignorieren?
+		}
+		if (maps.isEmpty())
+			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung"), MessageBox.OKB)).execute();
+		tempMIO = new MapInfoObject(1.0);
+		maps.add(tempMIO);
+		tempMIO = new MapInfoObject(5.0);
+		maps.add(tempMIO);
+		tempMIO = new MapInfoObject(50.0);
+		maps.add(tempMIO);
+		inf.close(0);
+		Vm.showWait(false);
+	}
+
 	public void addTrack(Track tr) {
 		if (tr == null) return;
 		if (tracks == null) tracks = new Vector();
@@ -239,7 +304,7 @@
 	}
 	
 	public void updateOverlayPos() {
-//		if (TrackOverlays == null) return;
+		if (TrackOverlays == null) return;
 		updateOverlayOnlyPos();
 		if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
 				TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
@@ -280,50 +345,6 @@
 	}
 	
 	
-	/**
-	 * Constructs the map panel and initializes everything that is neccessary
-	 *
-	 */
-	public void loadMap(double lat, double lon){
-		resetCenterOfMap();
-		posCircleLat = lat;
-		posCircleLon = lon;
-		if (!maps.isEmpty()){
-			posCircle.properties = AniImage.AlwaysOnTop;
-			try {
-				int bestmap = getBestMap(posCircleLat, posCircleLon);
-				setMap((MapInfoObject)maps.get(bestmap), posCircleLat, posCircleLon);
-			} catch (IndexOutOfBoundsException ex) { // wird von maps.get geworfen, wenn die Liste der Maps leer ist, sollte eigentlich nicht vorkommen, solange bestmaps immer eine g?ltige Antwort liefert
-				LocalResource lr = Vm.getLocale().getLocalResource("cachewolf.Languages",true);
-				(new MessageBox((String)lr.get(321, "Error"), (String)lr.get(326, "Es steht keine kalibrierte Karte zur Verf?gung"), MessageBox.OKB)).execute();
-			}
-		//	addOverlays(); // map must be known and must be added after map
-			mmp.addImage(posCircle);
-			setGpsStatus(noGPS);
-			ButtonImageChooseMap.setLocation(10,10);
-			ButtonImageChooseMap.properties = AniImage.AlwaysOnTop;
-			ButtonImageGpsOn.setLocation(pref.myAppWidth-25, 10);
-			ButtonImageGpsOn.properties = AniImage.AlwaysOnTop;
-			arrowUp.setLocation(pref.myAppWidth/2, 10);
-			arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
-			arrowLeft.setLocation(10, pref.myAppHeight/2+7);
-			arrowRight.setLocation(pref.myAppWidth-25, pref.myAppHeight/2+7);
-			arrowUp.properties = AniImage.AlwaysOnTop;
-			arrowDown.properties = AniImage.AlwaysOnTop;
-			arrowLeft.properties = AniImage.AlwaysOnTop;
-			arrowRight.properties = AniImage.AlwaysOnTop;
-			mmp.addImage(arrowUp);
-			mmp.addImage(arrowDown);
-			mmp.addImage(arrowLeft);
-			mmp.addImage(arrowRight);
-			mmp.addImage(ButtonImageChooseMap);
-			mmp.addImage(ButtonImageGpsOn);
-		} else { // catch (IndexOutOfBoundsException ex) { // wird von maps.get geworfen, wenn die Liste der Maps leer ist
-			LocalResource lr = Vm.getLocale().getLocalResource("cachewolf.Languages",true);
-			(new MessageBox((String)lr.get(321, "Error"), (String)lr.get(326, "Es steht keine kalibrierte Karte zur Verf?gung"), MessageBox.OKB)).execute();
-			throw new IndexOutOfBoundsException("no calibrated maps available"); 
-		}
-	}
 	
 	public void resetCenterOfMap() {
 		posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
@@ -431,7 +452,7 @@
 			updateSymbolPositions();
 			if (updateOverlay && TrackOverlays != null) updateOverlayPos();
 		//}
-		mmp.repaintNow();
+		mmp.repaintNow(); // TODO test if the "if" above can be used
 		//Vm.debug("update only position");			
 	}
 	/**
@@ -442,8 +463,9 @@
 			updateOnlyPosition(lat, lon, true);
 			if (autoSelectMap) {
 				Point mapPos = getMapXYPosition();
-				if (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
-					|| 	mmp.mapImage == null ) 	{
+				if (forceMapLoad || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
+					|| 	mmp.mapImage == null )) 	{
+					forceMapLoad = false;
 					//Vm.debug("Screen not completly covered by map");
 					if (java.lang.Math.abs(lastCompareX-mapPos.x) > MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > MyLocale.getScreenHeight()/10) {
 						// more then 1/10 of screen moved since last time we tried to find a better map
@@ -484,6 +506,7 @@
 		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 		lastCompareY = Integer.MAX_VALUE;
 		autoSelectMap = true;
+		forceMapLoad = true;
 //		updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
 	}
 
@@ -518,7 +541,8 @@
 				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
 				Vm.getUsedMemory(true); // calls the garbage collection
 				} // give memory free before loading the new map to avoid out of memory error  
-			mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+			if (currentMap.fileName.length()>0) mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+			else mmp.mapImage = new AniImage();
 			mmp.mapImage.setLocation(0,0);
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
@@ -583,16 +607,9 @@
 */
 class MovingMapPanel extends InteractivePanel{
 	MovingMap mm;
-	Vector maps;
-	CellPanel gotoPanel;
 	AniImage mapImage;
-	Vector cacheDB;
-	Vector imageLayers;
-	public MovingMapPanel(MovingMap f, Vector maps, GotoPanel gP, Vector cacheDB){
-		this.cacheDB = cacheDB;
-		gotoPanel = gP;
+	public MovingMapPanel(MovingMap f){
 		this.mm = f;
-		this.maps = maps;
 	}
 	
 	/*public void addAniImage(AniImage ai, int layer) {
@@ -616,18 +633,17 @@
 		mm.updateSymbolPositions();
 		mm.updateOverlayPos();
 		this.repaintNow();
-
 	}
 
 	public void chooseMap() {
 		CWPoint gpspos;
 		if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
 		else gpspos = null;
-		ListBox l = new ListBox(maps, gpspos, mm.getGotoPos());
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
 		if(l.execute() == FormBase.IDOK){
 //			Vm.debug("Trying map: " + l.selectedMap.fileName);
 			mm.autoSelectMap = false;
-			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon)) {
+			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.fileName.length()==0) {
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
 				mm.ignoreGpsStatutsChanges = false;
 			} else {
@@ -668,8 +684,8 @@
 			if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
 				mm.gotoPanel.startGps();
 				mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
-			} else mm.addOverlaySet(); // use existing tracks if gps was already running
-			mm.SnapToGps();
+			} //else mm.addOverlaySet(); // use existing tracks if gps was already running
+			mm.SnapToGps(); // TODO es w?re sch?n, wenn klick auf SnapToGPS nach einem OutOfMemoryError erneut versuchen w?rde, die map zu laden
 		}
 		if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}
@@ -765,7 +781,6 @@
 	public int myExecute() {
 		if (this.maps.size()==1) {
 			//this.selectedMap = 1;
-			this.selectedMap = new MapInfoObject();
 			this.selectedMap = (MapInfoObject) maps.get(0);
 			return FormBase.IDOK;
 		}



From salzkammergut at mail.berlios.de  Sun Jan  7 22:58:43 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Jan 2007 22:58:43 +0100
Subject: [Cachewolf-svn] r363 - in trunk: resources src/CacheWolf
Message-ID: <200701072158.l07Lwh46016409@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-07 22:58:39 +0100 (Sun, 07 Jan 2007)
New Revision: 363

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/HintLogPanel.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
Log:
Hintlogs jetzt mit Splitter zwischen Hints und Logs zur Groessenanpassung von Hints bzw. Logs.
Anzahl der Logs pro Seite kann in Pr?\195?\164ferenzen eingestellt werden (Default=5)

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-07 20:38:50 UTC (rev 362)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-07 21:58:39 UTC (rev 363)
@@ -126,6 +126,7 @@
 		627=Tabs oben
 		628=Status zeigen
 		629=Profil auto. laden
+		630=Hinweise/Logs:  Logs pro Seite 
 		700=Filter setzen
 		701=Entfernung
 		702=Schwierigkeit
@@ -378,6 +379,7 @@
 		627=Tabs top
 		628=Show status
 		629=Autoload last profile
+		630=HintLogPanel:  Logs per page 
 		700=Set filter
 		701=Distance
 		702=Difficulty

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-01-07 20:38:50 UTC (rev 362)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-01-07 21:58:39 UTC (rev 363)
@@ -22,30 +22,24 @@
 	mButton moreBt = new mButton(">>");
 	mButton prevBt = new mButton("<<");
 	public HintLogPanel(){
-		//SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
-		//CellPanel hintpane = split.getNextPanel();
-		//CellPanel logpane = split.getNextPanel();
-		boolean smallScreen=MyLocale.getScreenHeight()<300;
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+
+		CellPanel hintpane = split.getNextPanel();
+		CellPanel logpane = split.getNextPanel();
+		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
 		
 		ScrollBarPanel sbphint = new ScrollBarPanel(hint);
-		this.addLast(sbphint,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		if (smallScreen){
-			this.addNext(prevBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-			this.addNext(decodeButton,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-			decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
-			this.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
-		} else {
-			this.addLast(decodeButton,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		}
+		hintpane.addLast(sbphint,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		sbphint.setMinimumSize(0,0);
+		hintpane.addNext(prevBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		hintpane.addNext(decodeButton,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
+		hintpane.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
 		
 		ScrollBarPanel sbplog = new ScrollBarPanel(logs, ScrollBarPanel.NeverShowHorizontalScrollers);
-		this.addLast(sbplog,CellConstants.STRETCH, CellConstants.FILL);
-		if (!smallScreen){
-			this.addNext(prevBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-			this.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		}	
+		logpane.addLast(sbplog,CellConstants.STRETCH, CellConstants.FILL);
 		hint.modify(Control.NotEditable,0);
-		//this.addLast(split);
+		this.addLast(split);
 	}
 	
 	public void setText(CacheHolder cache){
@@ -57,15 +51,15 @@
 		for(int i = 0; i<cache.CacheLogs.size(); i++){
 			dummy += (String)cache.CacheLogs.get(i)+"</br>";
 			counter++;
-			if(counter >= 5 || counter >= cache.CacheLogs.size()) break;
+			if(counter >= Global.getPref().logsPerPage || counter >= cache.CacheLogs.size()) break;
 		}
 		crntLogPosition = 0;
 		logs.setHtml(dummy);
 		moreBt.modify(0,Control.Disabled);
 		prevBt.modify(0,Control.Disabled);
-		if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
-			Vm.setSIP(0);
-		}
+//		if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
+//			Vm.setSIP(0);
+//		}
 		Vm.showWait(false);
 		////Vm.debug("In log: " + cache.CacheLogs);
 	}
@@ -78,7 +72,7 @@
 	*/
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			int minLogs = java.lang.Math.min(5, cache.CacheLogs.size());
+			int minLogs = java.lang.Math.min(Global.getPref().logsPerPage, cache.CacheLogs.size());
 			if(ev.target == moreBt){
 				prevBt.modify(0,Control.Disabled);
 				prevBt.repaintNow();

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-07 20:38:50 UTC (rev 362)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-07 21:58:39 UTC (rev 363)
@@ -55,14 +55,13 @@
 	public String lastSyncOC[] = new String[4];
 	public String lastDistOC[] = new String[4];
 	public String garminConn="com1";  // The type of connection which GPSBABEL uses: com1 OR usb.
-	// TODO Add garminConn to user interface. For the time being this can only be set by manually editing the pref file
-
+	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
 	public boolean menuAtTop=true;
 	public boolean tabsAtTop=true;
 	public boolean showStatus=true;
-	
-	//public String last_sync_opencaching = new String();
-	//public String distOC = new String();
+	// This setting determines how many logs are shown per page of hintlogs (default 5)
+	public final int DEFAULT_LOGS_PER_PAGE=5;
+	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
 	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
 	public boolean downloadMapsOC = true;
 	public boolean downloadmissingOC = false;
@@ -78,8 +77,7 @@
 	private StringBuffer collectElement=null; 
 	private String lastName; // The string to the last XML that was processed
 	
-	private String LOGFILENAME="log.txt";
-	
+	private final String LOGFILENAME="log.txt";
 	// The following declarations may eventually be moved to a separate class
 	/** The actual directory of a profile, for new profiles this is a direct child of baseDir */
 	//TODO Find all references amd move to profile.dataDir
@@ -362,6 +360,9 @@
 			tabsAtTop=Boolean.valueOf(atts.getValue("tabsattop")).booleanValue();
 			showStatus=Boolean.valueOf(atts.getValue("showstatus")).booleanValue();
 		}
+		if (name.equals("hintlogpanel")) {
+			logsPerPage = Convert.parseInt(atts.getValue("logsperpage"));
+		}
 	}
 
 	public void characters( char ch[], int start, int length )
@@ -431,6 +432,7 @@
 			outp.print("    <lastprofile autoreload=\""+autoReloadLastProfile+"\">"+lastProfile+"</lastprofile>\n"); //RB
 			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\"/>\n");
 			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>\n");
+			outp.print("    <hintlogpanel logsperpage=\""+logsPerPage+"\"/>\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			// Obsolete data kept for backward compatibility
 			//outp.print("	<syncOC date = \"" + last_sync_opencaching + "\" dist = \"" + distOC +  "\"/>\n");

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2007-01-07 20:38:50 UTC (rev 362)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2007-01-07 21:58:39 UTC (rev 363)
@@ -15,7 +15,7 @@
 public class PreferencesScreen extends Form {
 	mButton cancelB, applyB, brwBt, gpsB,btnCentre;
 	mChoice NS, EW;
-	mInput NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS;
+	mInput NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS, inpLogsPerPage;
 	mCheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, 
 	          chkTabsAtTop, chkShowStatus;
 	mTabbedPanel mTab;
@@ -64,9 +64,6 @@
 		pnlGeneral.addLast(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629,"Autoload last profile")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
 			
-		//content.addNext(nLogs = new mInput(),content.DONTSTRETCH, (content.DONTFILL|content.WEST));
-		//nLogs.setText(Convert.toString(myPreferences.nLogs));
-		//content.addLast(new mLabel("Logs"), content.DONTSTRETCH, (content.DONTFILL|content.WEST));
 		pnlGeneral.addNext(new mLabel("Proxy"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		pnlGeneral.addNext(new mLabel("Port"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		pnlGeneral.addLast(new mLabel("Font"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -84,36 +81,57 @@
 		/////////////////////////////////////////////////////////
 		// Second panel - Screen
 		/////////////////////////////////////////////////////////
-		
-		pnlDisplay.addLast(new mLabel(MyLocale.getMsg(605,"Display Preferences")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlDisplay.addNext(dif = new mCheckBox(MyLocale.getMsg(606,"Difficulty")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		Frame frmDisplay=new Frame();
+		frmDisplay.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		frmDisplay.addLast(new mLabel(MyLocale.getMsg(605,"Display Preferences")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addNext(dif = new mCheckBox(MyLocale.getMsg(606,"Difficulty")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[2] == 1) dif.setState(true);
-		pnlDisplay.addNext(ter = new mCheckBox(MyLocale.getMsg(607,"Terrain")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addNext(ter = new mCheckBox(MyLocale.getMsg(607,"Terrain")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[3] == 1) ter.setState(true);
-		pnlDisplay.addLast(loc = new mCheckBox(MyLocale.getMsg(608,"Location")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addLast(loc = new mCheckBox(MyLocale.getMsg(608,"Location")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[6] == 1) loc.setState(true);
-		pnlDisplay.addNext(own = new mCheckBox(MyLocale.getMsg(609,"Owner")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addNext(own = new mCheckBox(MyLocale.getMsg(609,"Owner")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[7] == 1) own.setState(true); 
-		pnlDisplay.addNext(hid = new mCheckBox(MyLocale.getMsg(610,"Hidden")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addNext(hid = new mCheckBox(MyLocale.getMsg(610,"Hidden")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[8] == 1) hid.setState(true);
-		pnlDisplay.addLast(stat = new mCheckBox(MyLocale.getMsg(611,"Status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addLast(stat = new mCheckBox(MyLocale.getMsg(611,"Status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[9] == 1) stat.setState(true);
-		pnlDisplay.addNext(dist = new mCheckBox(MyLocale.getMsg(612,"Distance")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addNext(dist = new mCheckBox(MyLocale.getMsg(612,"Distance")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[10] == 1) dist.setState(true);
-		pnlDisplay.addLast(bear = new mCheckBox(MyLocale.getMsg(613,"Bearing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmDisplay.addLast(bear = new mCheckBox(MyLocale.getMsg(613,"Bearing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		if(pref.tablePrefs[11] == 1) bear.setState(true);
-		pnlDisplay.addLast(new mLabel(MyLocale.getMsg(623,"Images")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlDisplay.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,"Show deleted images")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		dist.setTag(INSETS,new Insets(0,0,2,0));
+		bear.setTag(INSETS,new Insets(0,0,2,0));
+		pnlDisplay.addLast(frmDisplay,CellConstants.STRETCH,CellConstants.FILL);
+		
+		Frame frmImages=new Frame();
+		frmImages.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		frmImages.addNext(new mLabel(MyLocale.getMsg(623,"Images:")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,"Show deleted images")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
+		chkShowDeletedImg.setTag(INSETS,new Insets(0,0,2,0));
 		if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
-		pnlDisplay.addLast(new mLabel(MyLocale.getMsg(625,"Screen layout (needs restart)")));
-		pnlDisplay.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,"Menu top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+				
+		Frame frmScreen=new Frame();
+		frmScreen.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		frmScreen.addLast(new mLabel(MyLocale.getMsg(625,"Screen layout (needs restart):")));
+		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,"Menu top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		chkMenuAtTop.setTag(INSETS,new Insets(0,0,2,0));
 		chkMenuAtTop.setState(pref.menuAtTop);
-		pnlDisplay.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,"Tabs top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,"Tabs top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		chkTabsAtTop.setState(pref.tabsAtTop);
-		pnlDisplay.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,"Show status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		chkTabsAtTop.setTag(INSETS,new Insets(0,0,2,0));
+		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,"Show status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		chkShowStatus.setState(pref.showStatus);
-		//pnlDisplay.addLast(new mLabel(""));
+		chkShowStatus.setTag(INSETS,new Insets(0,0,2,0));
+		pnlDisplay.addLast(frmScreen,CellConstants.STRETCH,CellConstants.FILL);
 		
+		Frame frmHintLog=new Frame();
+		//frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+        frmHintLog.addNext(new mLabel(MyLocale.getMsg(630,"HintLogPanel:  Logs per page ")));	
+		frmHintLog.addNext(inpLogsPerPage=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.WEST);
+		inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
+		pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
 		
 		mTab.addCard(pnlGeneral,MyLocale.getMsg(621,"General"),null);
 		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,"Screen"),null);
@@ -139,7 +157,9 @@
 					pref.baseDir = DataDir.getText();
 				//}
 				pref.fontSize = Convert.toInt(fontSize.getText());
-				
+				if (pref.fontSize<6) pref.fontSize=12;
+				pref.logsPerPage=Convert.toInt(inpLogsPerPage.getText());
+				if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
 				Font defaultGuiFont = mApp.findFont("gui");
 				int sz = (pref.fontSize);
 				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 



From salzkammergut at mail.berlios.de  Sun Jan  7 23:48:06 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Jan 2007 23:48:06 +0100
Subject: [Cachewolf-svn] r364 - trunk/src/CacheWolf
Message-ID: <200701072248.l07Mm6sc021249@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-07 23:48:04 +0100 (Sun, 07 Jan 2007)
New Revision: 364

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
Log:
Kleiner update des HintlogPanel

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-01-07 21:58:39 UTC (rev 363)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-01-07 22:48:04 UTC (rev 364)
@@ -8,13 +8,13 @@
 *	It holds a method to cryt and decrypt hints.
 *	Two buttons allow for navigation through the logs. 5 logs are displayed at
 *   together. This was implemented to allow for better performance on the
-*	PocketPC.
+*	PocketPC. This number can be changed in the preferences.
 *	Class ID=400
 */
 public class HintLogPanel extends CellPanel{
 	int crntLogPosition = 0;
 	CacheHolder cache;
-	
+	private final int DEFAULT_STRINGBUFFER_SIZE=8000;
 	mTextPad hint = new mTextPad();
 	//mTextPad logs = new mTextPad();
 	HtmlDisplay logs = new HtmlDisplay();
@@ -42,28 +42,35 @@
 		this.addLast(split);
 	}
 	
+	
 	public void setText(CacheHolder cache){
 		this.cache = cache;
-		Vm.showWait(true);
 		if(!cache.Hints.equals("null")) hint.setText(cache.Hints);
-		String dummy = new String();
-		int counter = 0;
-		for(int i = 0; i<cache.CacheLogs.size(); i++){
-			dummy += (String)cache.CacheLogs.get(i)+"</br>";
-			counter++;
-			if(counter >= Global.getPref().logsPerPage || counter >= cache.CacheLogs.size()) break;
-		}
 		crntLogPosition = 0;
-		logs.setHtml(dummy);
+		setLogs(0);
 		moreBt.modify(0,Control.Disabled);
 		prevBt.modify(0,Control.Disabled);
 //		if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
 //			Vm.setSIP(0);
 //		}
-		Vm.showWait(false);
 		////Vm.debug("In log: " + cache.CacheLogs);
 	}
 	
+	void setLogs(int crntLogPosition) {
+		Vm.showWait(true);
+		StringBuffer dummy = new StringBuffer(DEFAULT_STRINGBUFFER_SIZE);
+		int counter = 0;
+		int nLogs=cache.CacheLogs.size();
+		int logsPerPage=Global.getPref().logsPerPage;
+		for(int i = crntLogPosition; i<nLogs; i++){
+			dummy.append((String)cache.CacheLogs.get(i));
+			dummy.append("</br>");
+			if(++counter >= logsPerPage) break;
+		}
+		logs.setHtml(dummy.toString());
+		Vm.showWait(false);
+	}
+	
 	/**
 	* Method that handles user input on this panel.
 	* It handles decryption of hints and navigation through
@@ -83,32 +90,18 @@
 					moreBt.modify(Control.Disabled,0);
 					moreBt.repaintNow();
 				}
-				String dummy = new String();
-				int counter = 0;
-				for(int i = crntLogPosition; i<cache.CacheLogs.size(); i++){
-					dummy += (String)cache.CacheLogs.get(i)+"</br>";
-					counter++;
-					if(counter >= minLogs) break;
-				}
-				logs.setHtml(dummy);
+				setLogs(crntLogPosition);
 			} // = moreBt
 			if(ev.target == prevBt){
 				moreBt.modify(0,Control.Disabled);
 				moreBt.repaintNow();
-				String dummy = new String();
 				crntLogPosition -= minLogs;
 				if(crntLogPosition <= 0) {
 					prevBt.modify(Control.Disabled,0);
 					prevBt.repaintNow();
 					crntLogPosition = 0;
 				}
-				int counter = 0;
-				for(int i = crntLogPosition; i<cache.CacheLogs.size(); i++){
-					dummy += (String)cache.CacheLogs.get(i)+"</br>";
-					counter++;
-					if(counter >= minLogs) break;
-				}
-				logs.setHtml(dummy);
+				setLogs(crntLogPosition);
 			}
 			if(ev.target == decodeButton){
 				hint.setText(Common.rot13(hint.getText()));



From salzkammergut at mail.berlios.de  Mon Jan  8 00:47:26 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 8 Jan 2007 00:47:26 +0100
Subject: [Cachewolf-svn] r365 - trunk/src/CacheWolf
Message-ID: <200701072347.l07NlQAt029061@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-08 00:47:23 +0100 (Mon, 08 Jan 2007)
New Revision: 365

Modified:
   trunk/src/CacheWolf/CacheWolf.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
Log:
Profil kann nur geladen werden wenn Listenansicht ausgewaehlt.
Bei anderen Ansichten werden "Neues Profil" und "Profil laden" gesperrt.


Modified: trunk/src/CacheWolf/CacheWolf.java
===================================================================
--- trunk/src/CacheWolf/CacheWolf.java	2007-01-07 22:48:04 UTC (rev 364)
+++ trunk/src/CacheWolf/CacheWolf.java	2007-01-07 23:47:23 UTC (rev 365)
@@ -225,7 +225,7 @@
 		//args[0]: spider
 		//args[1]: distance
 		ewe.sys.Vm.startEwe(args);
-		Gui.screenIs(Gui.PDA_SCREEN);
+/*		Gui.screenIs(Gui.PDA_SCREEN);
 		Rect s = (Rect)Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new Rect(),0);
 		//Gui.screenIs(Gui.PDA_SCREEN)
 		if (Vm.isMobile() && s.height >= 400) {
@@ -236,7 +236,7 @@
 			mApp.fontsChanged();
 			mApp.mainApp.font = newGuiFont;
 		}
-		
+*/		
 		//if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
 		//	Vm.setSIP(Vm.SIP_LEAVE_BUTTON);
 		//}
@@ -245,14 +245,12 @@
 			if(args[0].equals("test")){
 				Test t=new Test(); 
 				t.testAll();
-				Form mainF = new MainForm();
-				mainF.execute();
 			}
-		}else{
-		  Form mainF = new MainForm();
-		  mainF.execute();
 		}
+		Form mainF = new MainForm();
+		mainF.execute();
 		
+		
 		//Form mainF = new MainForm();
 		//mainF.execute();
 		ewe.sys.Vm.exit(0);

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-07 22:48:04 UTC (rev 364)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-07 23:47:23 UTC (rev 365)
@@ -38,9 +38,11 @@
 		this.exitSystemOnClose = true;
 		this.resizable = true;
 		this.moveable = true;
-		if(Vm.isMobile() == true) 
+		if(Vm.isMobile() == true) {
 			this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
-		else 
+			this.resizable = false;
+			this.moveable = false;
+		} else 
 			this.setPreferredSize(800, 600);
 		this.resizeOnSIP = true;
 		// Load CacheList
@@ -50,12 +52,12 @@
 			addGuiFont();
 			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
 				ewe.sys.Vm.exit(0); // User MUST select or create a profile
-			Vm.showWait(true);
 			InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
-			infB.exec();
+			infB.show();
+			infB.waitUntilPainted(1000);
 			profile.readIndex();
 			infB.close(0);
-			Vm.showWait(false);
+			Vm.showWait(true);
 			pref.curCentrePt.set(profile.centre);
 			TablePanel.updateBearingDistance(profile.cacheDB,pref);
 		} catch (Exception e){
@@ -69,15 +71,17 @@
 		} else Vm.setSIP(0);
 		//Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
 		if (pref.showStatus) statBar = new StatusBar(pref, profile.cacheDB);
+		mMenu = new MainMenu(this);
+		mTab = new MainTab(mMenu,statBar);
 		if (pref.menuAtTop) {
-			this.addLast(mMenu = new MainMenu(this),CellConstants.DONTSTRETCH, CellConstants.FILL);
-			this.addLast(mTab = new MainTab(pref,profile,statBar),CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(mTab,CellConstants.STRETCH, CellConstants.FILL);
 		} else {
-			this.addLast(mTab = new MainTab(pref,profile,statBar),CellConstants.STRETCH, CellConstants.FILL);
-			this.addLast(mMenu = new MainMenu(this),CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(mTab,CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
 		mMenu.setTablePanel(mTab.getTablePanel());
-		
+		Vm.showWait(false);
 	}
 
 	

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-07 22:48:04 UTC (rev 364)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-07 23:47:23 UTC (rev 365)
@@ -155,6 +155,16 @@
 		tbp = t;
 	}
 	
+	public void allowProfileChange(boolean profileChangeAllowed) {
+		if (profileChangeAllowed) {
+			mnuNewProfile.modifiers&=~MenuItem.Disabled;
+			mnuOpenProfile.modifiers&=~MenuItem.Disabled;
+		} else {
+			mnuNewProfile.modifiers|=MenuItem.Disabled;
+			mnuOpenProfile.modifiers|=MenuItem.Disabled;
+		}
+	}
+	
 	public void onEvent(Event ev){
 		Preferences pref=Global.getPref();
 		Profile profile=Global.getProfile();

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-07 22:48:04 UTC (rev 364)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-07 23:47:23 UTC (rev 365)
@@ -27,12 +27,12 @@
 	SolverPanel solverP;
 	String lastselected = new String();
 	CacheHolder ch = new CacheHolder();
-	//Locale l = Vm.getLocale();
-	//LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
+	MainMenu mnuMain;
 	
-	public MainTab(Preferences p, Profile prof,StatusBar statBar){
-		pref = p;
-		profile=prof;
+	public MainTab(MainMenu mainMenu,StatusBar statBar){
+		mnuMain=mainMenu;
+		pref = Global.getPref();
+		profile=Global.getProfile();
 		if (!pref.tabsAtTop) tabLocation=SOUTH;
 		cDB = profile.cacheDB;
 		MyLocale.setSIPButton();
@@ -67,7 +67,7 @@
 		c = this.addCard(radarP, "Radar", null);
 		radarP.setMainTab(this);
 		c.iconize(new Image("radar.gif"),true);
-		
+		mnuMain.allowProfileChange(true);
 	}
 	
 	public TablePanel getTablePanel(){
@@ -93,7 +93,9 @@
 		{
 		  ////Vm.debug(ev.toString());
 		  if(ev instanceof MultiPanelEvent){
+			  mnuMain.allowProfileChange(false);	  
 			  if(this.getSelectedItem() == 0){
+				  mnuMain.allowProfileChange(true);	  
 //				  Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,0);
 //				  Vm.setSIP(0);
 				  MyLocale.setSIPOff();



From pfeffer at mail.berlios.de  Mon Jan  8 02:12:46 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 8 Jan 2007 02:12:46 +0100
Subject: [Cachewolf-svn] r366 - trunk/src/CacheWolf
Message-ID: <200701080112.l081Ck57011689@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-08 02:12:41 +0100 (Mon, 08 Jan 2007)
New Revision: 366

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
in MovingMap werden alle markierten Wegpunkte angezeigt

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-07 23:47:23 UTC (rev 365)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-08 01:12:41 UTC (rev 366)
@@ -4,6 +4,7 @@
 import ewe.util.Vector;
 import ewe.util.mString;
 import ewe.fx.*;
+import ewe.graphics.AniImage;
 import ewe.io.*;
 import ewe.net.Socket;
 //import ewe.io.IOException;
@@ -602,6 +603,18 @@
 				}
 				if (currTrack != null) mmp.addTrack(currTrack);
 				mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
+				if (mainT.tbP.myMod.cacheSelectionChanged) {
+					mainT.tbP.myMod.cacheSelectionChanged = false;
+					mmp.removeAllMapSymbolsButGoto();
+					for (int i=cacheDB.size()-1; i>=0; i--) {
+						CacheHolder ch = (CacheHolder) cacheDB.get(i);
+						if (ch.is_Checked) {
+							CWPoint tmpll = new CWPoint(ch.LatLon);
+							int ct = Convert.parseInt(ch.type);
+							mmp.addSymbol(ch.CacheName, new AniImage(myTableModel.cacheImages[ct]), tmpll.latDec, tmpll.lonDec);
+						}
+					}
+				}
 				mmp.exec();
 			} 
 			// create new waypoint with current GPS-position

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-07 23:47:23 UTC (rev 365)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-08 01:12:41 UTC (rev 366)
@@ -63,9 +63,9 @@
 		affine[1]=pixel2deg; //x2lon
 		affine[2]=-pixel2deg; //y2lat
 		affine[3]=0; //y2lon
-		affine[4]=0; //left
-		affine[5]=1; //top
-		lowlat = 0; //bottom 
+		affine[4]=1; //top
+		affine[5]=0; //left
+		lowlat = 0; //buttom
 		lowlon = 1; //right
 		doCalculations();
 	}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-07 23:47:23 UTC (rev 365)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-08 01:12:41 UTC (rev 366)
@@ -46,7 +46,7 @@
 	boolean ignoreGps = false;
 	boolean ignoreGpsStatutsChanges = false;
 	boolean autoSelectMap = true;
-	boolean forceMapLoad = false; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
 	
 	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
 		this.cacheDB = cacheDB;
@@ -117,6 +117,10 @@
 		maps.add(tempMIO);
 		tempMIO = new MapInfoObject(50.0);
 		maps.add(tempMIO);
+		tempMIO = new MapInfoObject(250.0);
+		maps.add(tempMIO);
+		tempMIO = new MapInfoObject(1000.0);
+		maps.add(tempMIO);
 		inf.close(0);
 		Vm.showWait(false);
 	}
@@ -171,13 +175,6 @@
 			}
 		}
 		updateOverlayOnlyPos();
-		/*
-		mmp.images.moveOnTop(arrowUp);
-		mmp.images.moveOnTop(arrowDown);
-		mmp.images.moveOnTop(arrowLeft);
-		mmp.images.moveOnTop(arrowRight);
-		mmp.images.moveOnTop(ButtonImageGpsOn);
-		mmp.images.moveOnTop(ButtonImageChooseMap);*/
 	}
 	
 	private void destroyOverlay(int ov) {
@@ -382,7 +379,7 @@
 		if (symbols == null) return;
 		Point pOnScreen;
 		MapSymbol symb;
-		for (int i=0; i<symbols.size(); i++) {
+		for (int i=symbols.size()-1; i>=0; i--) {
 			symb = (MapSymbol)symbols.get(i);
 			pOnScreen = getXYinMap(symb.lat, symb.lon);
 			symb.pic.setLocation(pOnScreen.x-symb.pic.getWidth()/2, pOnScreen.y-symb.pic.getHeight()/2);
@@ -395,9 +392,19 @@
 		ms.loadImage();
 		Point pOnScreen=getXYinMap(lat, lon);
 		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
-		this.mmp.addImage(ms.pic);
 		symbols.add(ms);
+		mmp.addImage(ms.pic);
 	}
+	public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, " ", lat, lon);
+		ms.pic = imSymb;
+		ms.pic.properties = AniImage.AlwaysOnTop;
+		Point pOnScreen=getXYinMap(lat, lon);
+		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms.pic);
+	}
 	
 	public void setGotoPosition(double lat, double lon) {
 		removeMapSymbol("goto");
@@ -412,6 +419,12 @@
 		return new CWPoint(ms.lat, ms.lon);
 	}
 	
+	public void removeAllMapSymbolsButGoto(){
+		for (int i=symbols.size()-1; i>=0; i--) {
+			if (((MapSymbol)symbols.get(i)).name != "goto") removeMapSymbol(i);
+		}
+	}
+	
 	public void removeMapSymbol(String name) {
 		int symbNr = findMapSymbol(name);
 		if (symbNr != -1) removeMapSymbol(symbNr);
@@ -610,6 +623,7 @@
 	AniImage mapImage;
 	public MovingMapPanel(MovingMap f){
 		this.mm = f;
+		this.autoMoveToTop = false;
 	}
 	
 	/*public void addAniImage(AniImage ai, int layer) {
@@ -657,22 +671,7 @@
 				mm.posCircleY = 0;
 				mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
 			}
-			//Go through cache db to paint caches that are in bounds of the map
-			/*
-				CWPoint tempPoint;
-				CacheHolder ch = new CacheHolder();
-				Graphics g = new Graphics(mapImage);
-				for(int i = 0; i < cacheDB.size();i++){
-					ch = (CacheHolder)cacheDB.get(i);
-					tempPoint = new CWPoint(ch.LatLon, CWPoint.CW);
-					if(mm.currentMap.inBound(tempPoint) == true) { //yes cache is on map!
-
-					}
-				}
-				g.free();
-			 */
 		}
-
 	}
 	
 	/**
@@ -684,8 +683,8 @@
 			if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
 				mm.gotoPanel.startGps();
 				mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
-			} //else mm.addOverlaySet(); // use existing tracks if gps was already running
-			mm.SnapToGps(); // TODO es w?re sch?n, wenn klick auf SnapToGPS nach einem OutOfMemoryError erneut versuchen w?rde, die map zu laden
+			} 
+			mm.SnapToGps();
 		}
 		if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-07 23:47:23 UTC (rev 365)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-08 01:12:41 UTC (rev 366)
@@ -32,6 +32,7 @@
 				ch.is_Checked = true;
 				//db.set(i, ch);
 			}
+			tbp.myMod.cacheSelectionChanged = true;
 			tbp.refreshTable();
 		}
 		
@@ -41,6 +42,7 @@
 				ch.is_Checked = false;
 				//db.set(i, ch);
 			}
+			tbp.myMod.cacheSelectionChanged = true;
 			tbp.refreshTable();
 		}
 		

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-07 23:47:23 UTC (rev 365)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-08 01:12:41 UTC (rev 366)
@@ -16,10 +16,11 @@
 */
 public class myTableModel extends TableModel{
 	
+	public boolean cacheSelectionChanged = false;
 	Vector cacheDB;
 	String[] colName;
-	Image cacheImages[] = new Image[454];
-	Image noFindLogs[] = new Image[4];
+	static Image cacheImages[] = new Image[454];
+	static Image noFindLogs[] = new Image[4];
 	int[] breiten;
 	Image red, blue, green, yellow;
 	mImage bug;
@@ -299,6 +300,7 @@
 		try{
 			// Check whether the click is on the checkbox image
 			if (cell.y>=0 && cell.x==0) {
+				cacheSelectionChanged = true;
 				CacheHolder ch = (CacheHolder)cacheDB.get(cell.y);
 				ch.is_Checked= !ch.is_Checked;
 				// set the ceckbox also for addi wpts



From admin at berlios.de  Mon Jan  8 03:20:39 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 03:20:39 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2927] Track in MovinMap anzeigen
Message-ID: <200701080220.l082KdN0010681@unicorn.berlios.de>

Feature Request #2927, was updated on 2006-Dec-03 16:34
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2927&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Track in MovinMap anzeigen

By: pfeffer
Date: 2007-Jan-08 03:20

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

dieses Problem habe ich nun gel?st. Bitte testen.
(geht jetzt auch, wenn man keine kalibrierte Karte hat!)

----------------------------------------------------------------------

By: pfeffer
Date: 2006-Dec-08 17:47

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

die Trackanzeige ist eigentlich fertig (mit SVN 282).
Allerdings gibt es ein wesentliches Problem: neue
Trackingpunkte werden nicht dragestellt, obwohl sie im
Programm gezeichnet werden. Erst das komplette Neuerstellen
des Overlays f?hrt zur Anzeige :-( (das kann man erreichen
in dem man den button "snap to GPS" dr?ckt)


die Methode ShowLastAddedPoint in MovingMap.java bringt in
der Ewe-Vm nicht das, was sie soll. Nach meinen Tests
funktioniert's hingegen in der Java-VM.

Irgendjemand ne Idee?

Gru?,
  Pfeffer.


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2927&group_id=2211


From admin at berlios.de  Mon Jan  8 03:22:35 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 03:22:35 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2924] Anzeige der GotoPosition in
	MovingMap
Message-ID: <200701080222.l082MZHe010770@unicorn.berlios.de>

Feature Request #2924, was updated on 2006-Dec-02 03:18
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2924&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: Anzeige der GotoPosition in MovingMap

By: pfeffer
Date: 2007-Jan-08 03:22

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

so, jetz (nach SVN 366) kann man die MovingMap auch ohne
kalibrierte Karte nutzen

----------------------------------------------------------------------

By: albsucher
Date: 2007-Jan-03 17:07

Message:
Logged In: YES 
user_id=26380
Browser: Mozilla/5.0 (X11; U; Linux i686; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

Also ganz ehrlich ich hab die MM noch nie benutzt und w?sste
jetzt auch nicht was genau ich da testen soll???
Sorry...

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2924&group_id=2211


From admin at berlios.de  Mon Jan  8 03:24:27 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 03:24:27 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3025] MovingMap: verschieben per
	klick-and-dra
Message-ID: <200701080224.l082ORgt010845@unicorn.berlios.de>

Feature Request #3025, was updated on 2007-Jan-08 03:24
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: verschieben per klick-and-dra

By: pfeffer
Date: 2007-Jan-08 03:24

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

MovingMap: verschieben per klick-and-drag

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211


From pfeffer at mail.berlios.de  Mon Jan  8 03:25:40 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 8 Jan 2007 03:25:40 +0100
Subject: [Cachewolf-svn] r367 - trunk/src/CacheWolf
Message-ID: <200701080225.l082Pe1s019269@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-08 03:25:38 +0100 (Mon, 08 Jan 2007)
New Revision: 367

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
[ Feature Request #3025 ] MovingMap: verschieben per klick-and-drag

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-08 01:12:41 UTC (rev 366)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-08 02:25:38 UTC (rev 367)
@@ -556,7 +556,8 @@
 				} // give memory free before loading the new map to avoid out of memory error  
 			if (currentMap.fileName.length()>0) mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
 			else mmp.mapImage = new AniImage();
-			mmp.mapImage.setLocation(0,0);
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable; 
+			mmp.mapImage.move(0,0);
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
 			addOverlaySet();
@@ -607,9 +608,6 @@
 	public void onEvent(Event ev){
 		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
 			gotoPanel.runMovingMap = false;
-		//	ignoreGps = true;
-			//setGpsStatus(noGPS);
-			//gotoPanel.stopTheTimer();
 		}
 		super.onEvent(ev);
 	}
@@ -621,34 +619,46 @@
 class MovingMapPanel extends InteractivePanel{
 	MovingMap mm;
 	AniImage mapImage;
+	Point saveMapLoc = null;
+	boolean saveGpsIgnoreStatus;
 	public MovingMapPanel(MovingMap f){
 		this.mm = f;
-		this.autoMoveToTop = false;
+		//this.autoMoveToTop = false;
 	}
-	
-	/*public void addAniImage(AniImage ai, int layer) {
-		if (imageLayers == null) imageLayers = new Vector();
-		for (int i = images.size()-1; i >= 0, i--) {
-			if (AniImage.class.getName()==TrackOverlay.class.getName())
-			images.sort(h, comparer, descending)ort(comparer, descending))
+	public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (! (which == mapImage || which instanceof TrackOverlay) ) return false;
+		saveGpsIgnoreStatus = mm.ignoreGps; 
+		mm.ignoreGps = true;
+		saveMapLoc = mapImage.getLocation(null);
+		return super.imageBeginDragged(mapImage, pos);
 		}
+
+	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+		boolean ret = super.imageNotDragged(dc, pos);
+		mapMoved(mapImage.location.x - saveMapLoc.x, mapImage.location.y - saveMapLoc.y);
+		mm.ignoreGps = saveGpsIgnoreStatus;
+		return ret;
+	 
 	}
-	*/
 	public void moveMap(int diffX, int diffY) {
 		Point p = new Point();
 		if (mapImage!= null) {
 			p = mapImage.getLocation(null);
 			mapImage.move(p.x+diffX,p.y+diffY);
 		}
-		p = mm.posCircle.getLocation(null);
+		mapMoved(diffX, diffY);
+	}
+	
+	public void mapMoved(int diffX, int diffY){
+		Point p = mm.posCircle.getLocation(null);
 		mm.posCircle.move(p.x+diffX, p.y+diffY);
 		mm.posCircleX = mm.posCircleX+diffX;
 		mm.posCircleY = mm.posCircleY+diffY;
 		mm.updateSymbolPositions();
 		mm.updateOverlayPos();
 		this.repaintNow();
+		
 	}
-
 	public void chooseMap() {
 		CWPoint gpspos;
 		if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);



From admin at berlios.de  Mon Jan  8 03:26:05 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 03:26:05 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3025] MovingMap: verschieben per
	klick-and-dra
Message-ID: <200701080226.l082Q5Bi010903@unicorn.berlios.de>

Feature Request #3025, was updated on 2007-Jan-08 03:24
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: verschieben per klick-and-dra

By: pfeffer
Date: 2007-Jan-08 03:26

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

erledigt mit SVN-Update 367.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-08 03:24

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

MovingMap: verschieben per klick-and-drag

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211


From admin at berlios.de  Mon Jan  8 03:38:02 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 03:38:02 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3026] MovingMap: Anzeige markierter Caches
Message-ID: <200701080238.l082c2c2011619@unicorn.berlios.de>

Feature Request #3026, was updated on 2007-Jan-08 03:38
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3026&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Anzeige markierter Caches

By: pfeffer
Date: 2007-Jan-08 03:38

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

MovingMap: Anzeige markierter Caches

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3026&group_id=2211


From admin at berlios.de  Mon Jan  8 03:38:53 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 03:38:53 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3026] MovingMap: Anzeige markierter Caches
Message-ID: <200701080238.l082crt6011666@unicorn.berlios.de>

Feature Request #3026, was updated on 2007-Jan-08 03:38
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3026&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: Anzeige markierter Caches

By: pfeffer
Date: 2007-Jan-08 03:38

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

mit irgendeinem SVN-Update um ca. 360-367 erledigt.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-08 03:38

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

MovingMap: Anzeige markierter Caches

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3026&group_id=2211


From admin at berlios.de  Mon Jan  8 11:12:43 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 11:12:43 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3025] MovingMap: verschieben per
	klick-and-dra
Message-ID: <200701081012.l08AChaK005907@unicorn.berlios.de>

Feature Request #3025, was updated on 2007-Jan-08 03:24
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: verschieben per klick-and-dra

By: pfeffer
Date: 2007-Jan-08 03:26

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

erledigt mit SVN-Update 367.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-08 03:24

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

MovingMap: verschieben per klick-and-drag

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211


From admin at berlios.de  Mon Jan  8 12:38:07 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 12:38:07 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2987] /maps Verzeichnis
Message-ID: <200701081138.l08Bc7Tw011348@unicorn.berlios.de>

Feature Request #2987, was updated on 2006-Dec-21 17:39
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: /maps Verzeichnis

By: salzkammergut
Date: 2007-Jan-08 12:38

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Das Maps Verzeichnis ist

mapsDir = Global.getProfile().dataDir+"maps";

----------------------------------------------------------------------

By: salzkammergut
Date: 2006-Dec-28 21:44

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Wenn unterhalb des Basisverzeichnisses ein maps Verzeichnis
liegt, wird es nicht als Profil angezeigt. 

Der maps Code mu? noch umgestellt werden. 
Das Maps Verzeichnis ist

mapsDir = profile.dataDir+"maps";



----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211


From admin at berlios.de  Mon Jan  8 12:38:08 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 12:38:08 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2987] /maps Verzeichnis
Message-ID: <200701081138.l08Bc8fg011358@unicorn.berlios.de>

Feature Request #2987, was updated on 2006-Dec-21 17:39
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: /maps Verzeichnis

By: salzkammergut
Date: 2007-Jan-08 12:38

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Das Maps Verzeichnis ist

mapsDir = Global.getProfile().dataDir+"maps";

----------------------------------------------------------------------

By: salzkammergut
Date: 2007-Jan-08 12:38

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Das Maps Verzeichnis ist

mapsDir = Global.getProfile().dataDir+"maps";

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211


From admin at berlios.de  Mon Jan  8 12:40:10 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 12:40:10 +0100 (CET)
Subject: [Feature #2984] aktualisieren nach Präferenzänderung
Message-ID: <200701081140.l08BeAYl011559@unicorn.berlios.de>

Feature Request #2984, was updated on 2006-Dec-19 20:24
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2984&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: aktualisieren nach Pr?ferenz?nderung

By: cw-tester
Date: 2006-Dec-19 20:24

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; .NET CLR 2.0.50727)

Wenn ich die Pr?ferenzen ?ndere und speichere 
wird die Liste nicht aktualisiert. Wenn ich z.B. eine 
Spalte ausblenden/einblenden m?chte, sollte das 
mit dem Speichern sofort aktualisiert werden.


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2984&group_id=2211


From admin at berlios.de  Mon Jan  8 18:27:29 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 18:27:29 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3028] MovingMap: Download von GoogleEarth
Message-ID: <200701081727.l08HRTjU008478@unicorn.berlios.de>

Feature Request #3028, was updated on 2007-Jan-08 18:27
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3028&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Download von GoogleEarth

By: pfeffer
Date: 2007-Jan-08 18:27

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.01 (Windows NT 5.1; U; de)

direkter Download von GoogleEarth-Karten mit 
Kalibrierungsinformationen

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3028&group_id=2211


From admin at berlios.de  Mon Jan  8 18:27:49 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 8 Jan 2007 18:27:49 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3028] MovingMap: Download von GoogleEarth
Message-ID: <200701081727.l08HRnOG008491@unicorn.berlios.de>

Feature Request #3028, was updated on 2007-Jan-08 18:27
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3028&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Download von GoogleEarth

By: pfeffer
Date: 2007-Jan-08 18:27

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.01 (Windows NT 5.1; U; de)

direkter Download von GoogleEarth-Karten mit 
Kalibrierungsinformationen

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3028&group_id=2211


From admin at berlios.de  Tue Jan  9 01:58:09 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 01:58:09 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3031] Doppelklick in der Cacheliste
Message-ID: <200701090058.l090w9hk026298@unicorn.berlios.de>

Feature Request #3031, was updated on 2007-Jan-09 01:58
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Doppelklick in der Cacheliste 

By: pfeffer
Date: 2007-Jan-09 01:58

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

siehe: http://www.geoclub.de/ftopic13405.html
beim Doppelklick in der Cacheliste sollte ein Browser
ge?ffnet werden, der eine Offline-Version der
Cache-Beschreibung (am besten mit Logs) anzeigt.
Wenn das starten des Browsers nicht klappt, sollte
automatisch als Fallback das CacheBeschreibungsPanel
ge?ffnet werden.

Mit Rechtsklick sollte weiterhin ein Zugriff auf die
online-Version des Caches m?glich sein, um schnell Logs
eintragen zu k?nnen.


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211


From pfeffer at mail.berlios.de  Tue Jan  9 03:17:59 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 9 Jan 2007 03:17:59 +0100
Subject: [Cachewolf-svn] r368 - trunk/src/CacheWolf
Message-ID: <200701090217.l092HxxL024605@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-09 03:17:55 +0100 (Tue, 09 Jan 2007)
New Revision: 368

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
[ Feature Request #3031 ] Doppelklick in der Cacheliste (nur teilweise: wenn Browserstart nicht geklappt hat, Descption-Panel ?\195?\182ffnen)
kleiner Bug-fix in MovingMap

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-09 02:17:55 UTC (rev 368)
@@ -446,10 +446,10 @@
 		// In moving map mode
 		if (mmp != null && runMovingMap ) { // neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
 			if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
+				mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
 				Vm.debug("ShowLastAddedPoint: voher");
 				mmp.ShowLastAddedPoint(currTrack);
 				Vm.debug("ShowLastAddedPoint: nachher");
-				mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
 				mmp.setGpsStatus(MovingMap.gotFix);
 			}
 			if ((fix == 0) && (gpsPosition.getSats()== 0)) {
@@ -615,7 +615,7 @@
 						}
 					}
 				}
-				mmp.exec();
+				mmp.myExec();
 			} 
 			// create new waypoint with current GPS-position
 			if (ev.target == btnSave){

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-09 02:17:55 UTC (rev 368)
@@ -59,7 +59,7 @@
 		
 		c = this.addCard(gotoP = new GotoPanel(pref, profile, this, detP), "Goto", null);
 		c.iconize(new Image("goto.gif"),true);
-		tbP.setGotoPanel(gotoP);
+		tbP.setPanels(gotoP, this);
 		
 		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205,"Solver"), null);
 		c.iconize(new Image("solver.gif"),true);
@@ -158,12 +158,7 @@
 				  detP.setDetails(ch, this,pref, profile);
 			  }
 			  if(this.getSelectedItem() == 2) { // Description Panel
-				  MyLocale.setSIPOff();
-				  descP.setText(ch);
-				  if(detP.dirty_newOrDelete) {
-					  tbP.refreshTable();
-					  detP.dirty_newOrDelete = false;
-				  }
+				  openDesciptionPanel(ch);
 			  }
 			  if(this.getSelectedItem() == 3) { // Picture Panel
 				  MyLocale.setSIPOff();
@@ -220,4 +215,13 @@
 			////Vm.debug(Convert.toString(w));
 		}
 		*/
+	public void openDesciptionPanel(CacheHolder chi) {
+		MyLocale.setSIPOff();
+		descP.setText(chi);
+		if(detP.dirty_newOrDelete) {
+			tbP.refreshTable();
+			detP.dirty_newOrDelete = false;
+		}
+	}
 }
+

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-09 02:17:55 UTC (rev 368)
@@ -35,10 +35,10 @@
 	
 	AniImage ButtonImageChooseMap = new AniImage("choose_map.gif"); 
 	AniImage ButtonImageGpsOn = new AniImage("snap2gps.gif"); 
-	AniImage arrowUp = new AniImage("arrow_up.png");
+	/*AniImage arrowUp = new AniImage("arrow_up.png");
 	AniImage arrowDown = new AniImage("arrow_down.png");
 	AniImage arrowLeft = new AniImage("arrow_left.png");
-	AniImage arrowRight = new AniImage("arrow_right.png");
+	AniImage arrowRight = new AniImage("arrow_right.png"); */
 	AniImage posCircle = new AniImage("position_green.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
@@ -64,7 +64,7 @@
 		ButtonImageChooseMap.properties = AniImage.AlwaysOnTop;
 		ButtonImageGpsOn.setLocation(pref.myAppWidth-25, 10);
 		ButtonImageGpsOn.properties = AniImage.AlwaysOnTop;
-		arrowUp.setLocation(pref.myAppWidth/2, 10);
+/*		arrowUp.setLocation(pref.myAppWidth/2, 10);
 		arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
 		arrowLeft.setLocation(10, pref.myAppHeight/2+7);
 		arrowRight.setLocation(pref.myAppWidth-25, pref.myAppHeight/2+7);
@@ -76,7 +76,7 @@
 		mmp.addImage(arrowDown);
 		mmp.addImage(arrowLeft);
 		mmp.addImage(arrowRight);
-		mmp.addImage(ButtonImageChooseMap);
+*/		mmp.addImage(ButtonImageChooseMap);
 		mmp.addImage(ButtonImageGpsOn);
 		posCircle.properties = AniImage.AlwaysOnTop;
 		loadMaps();
@@ -124,7 +124,10 @@
 		inf.close(0);
 		Vm.showWait(false);
 	}
-
+	public final FormFrame myExec() {
+		addOverlaySet(); // neccessary to draw points which were added when the MovingMap was not running, so that these pixels are not stored in the not-immediately-drawing-work-around
+		return exec();
+	}
 	public void addTrack(Track tr) {
 		if (tr == null) return;
 		if (tracks == null) tracks = new Vector();
@@ -460,12 +463,13 @@
 		}
 		//Vm.debug("mapx = " + mapx);
 		//Vm.debug("mapy = " + mapy);
-		//if (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1) {
+		if (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1) {
 			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
 			updateSymbolPositions();
 			if (updateOverlay && TrackOverlays != null) updateOverlayPos();
 		//}
 		mmp.repaintNow(); // TODO test if the "if" above can be used
+		}
 		//Vm.debug("update only position");			
 	}
 	/**
@@ -696,10 +700,10 @@
 			} 
 			mm.SnapToGps();
 		}
-		if (which == mm.arrowRight)	{	moveMap(-10,0);	}
+		/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}
 		if (which == mm.arrowDown)	{	moveMap(0,-10);	}
-		if (which == mm.arrowUp)	{	moveMap(0,+10);	}
+		if (which == mm.arrowUp)	{	moveMap(0,+10);	} */
 	}
 }
 

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-09 02:17:55 UTC (rev 368)
@@ -20,6 +20,7 @@
 	Preferences pref;
 	Vector cacheDB;
 	GotoPanel myGotoPanel;
+	MainTab myMaintab;
 	StatusBar statBar;
 	
 	public TablePanel(Preferences p, Profile profile, StatusBar statBar){
@@ -61,8 +62,9 @@
 		tc.setTableModel(myMod);
 	}
 	
-	public void setGotoPanel(GotoPanel gp) {
+	public void setPanels(GotoPanel gp, MainTab mt) {
 		myGotoPanel = gp;
+		myMaintab = mt;
 	}
 	
 	public int getSelectedCache(){

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-09 02:17:55 UTC (rev 368)
@@ -15,6 +15,7 @@
 	public Vector db;
 	public Preferences pref;
 	public TablePanel tbp;
+	public MainTab mainTabs;
 	
 	public void penRightReleased(Point p){
 		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
@@ -115,15 +116,19 @@
 		try{
 			//String cmd = "\""+pref.browser+ "\"" + " \"http://www.geocaching.com/seek/cache_details.aspx?wp="+ch.wayPoint+"&Submit6=Find&log=y\"";
 			ch.readCache(profile.dataDir);
+		}catch(IOException ex){	(new MessageBox("Error", "Cannot read cache data\n"+ex.toString()+"\n in cache: "+ch.wayPoint,MessageBox.OKB)).execute(); }
+		try {
 			String cmd = "\""+pref.browser+ "\" " + ch.URL;
 			//String cmd = "\""+pref.browser+ ".exe\"" + " www.aragorn.de";
 			//Vm.debug(cmd);
-			//ewe.sys.Process p = 
+			//ewe.sys.Process p =
+			
 			Vm.exec(cmd);
 			//p.waitFor();
-		}catch(IOException ex){
-			(new MessageBox("Error", "Cannot start browser!\n"+ex.toString()+"\nThe are two possible reasons:\n * path to internet browser in \npreferences not correct\n * An bug in ewe VM, please be \npatient for an update",MessageBox.OKB)).execute();
-			Vm.debug("Cannot start browser! " +ex.toString());
+		} catch (IOException ex) {
+			Vm.debug("Cannot start browser - opening description panel instead (" +ex.toString()+")");
+			//(new MessageBox("Error", "Cannot start browser!\n"+ex.toString()+"\nThe are two possible reasons:\n * path to internet browser in \npreferences not correct\n * An bug in ewe VM, please be \npatient for an update",MessageBox.OKB)).execute();
+			tbp.myMaintab.select(tbp.myMaintab.descP);
 		}
 	}
 }



From admin at berlios.de  Tue Jan  9 03:19:33 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 03:19:33 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3031] Doppelklick in der Cacheliste
Message-ID: <200701090219.l092JXFN013253@unicorn.berlios.de>

Feature Request #3031, was updated on 2007-Jan-09 01:58
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Doppelklick in der Cacheliste 

By: pfeffer
Date: 2007-Jan-09 03:19

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

mit SVN 368: Wenn Browserstart nicht klappt, dann wird
BeschreibungsPanel ge?ffnet.

F?r Offline-Browser-Anzeige f?hle ich micht nicht zust?ndig,
kenne mich mit den Exportern nicht aus.

Gru?,
  Pfeffer.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-09 01:58

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

siehe: http://www.geoclub.de/ftopic13405.html
beim Doppelklick in der Cacheliste sollte ein Browser
ge?ffnet werden, der eine Offline-Version der
Cache-Beschreibung (am besten mit Logs) anzeigt.
Wenn das starten des Browsers nicht klappt, sollte
automatisch als Fallback das CacheBeschreibungsPanel
ge?ffnet werden.

Mit Rechtsklick sollte weiterhin ein Zugriff auf die
online-Version des Caches m?glich sein, um schnell Logs
eintragen zu k?nnen.


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211


From admin at berlios.de  Tue Jan  9 03:25:40 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 03:25:40 +0100 (CET)
Subject: [Bug #8313] Pfeile auf Goto-Panel übermalt alles
Message-ID: <200701090225.l092PedR013505@unicorn.berlios.de>

Bug #8313, was updated on 2006-Aug-07 22:35
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: pfeffer
Assigned to : pfeffer
Summary: Pfeile auf Goto-Panel ?bermalt alles

Details: die Pfeile aus dem Goto-Panel ?bermalen andere Dialoge, (z.B. Preferenzen), wenn GPS-Empfang eingeschaltet ist.

Follow-Ups:

Date: 2006-Sep-22 09:26
By: pfeffer

Comment:
ja, ok, das w?re eine M?glichkeit. Ich h?tte allerdings gedacht, dass das eigentlich ein Problem des Fenster-Management ist? - Dass wir vielleicht blo? den falschen draw-Befehl verwenden, der einfach unabh?ngig vom Fenster-Managemant mahlt?
Kennt sich da jemand aus?
-------------------------------------------------------

Date: 2006-Sep-22 08:53
By: bilbowolf

Comment:
Hier m?ssen wir sicherstellen, da? der Goto sich schlafen legt, wenn man aus dem Tab herausspringt.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=8313&group_id=2211


From admin at berlios.de  Tue Jan  9 03:52:00 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 03:52:00 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2987] /maps Verzeichnis
Message-ID: <200701090252.l092q0Wf015034@unicorn.berlios.de>

Feature Request #2987, was updated on 2006-Dec-21 17:39
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: /maps Verzeichnis

By: pfeffer
Date: 2007-Jan-09 03:52

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

---
Das Maps Verzeichnis ist
mapsDir = Global.getProfile().dataDir+"maps";
---
Sehe ich das richtig, dass sich demnach das maps-Verzeichnis
je nach Profil unterschiedlich w?re?
Das soll nicht sein, es sollen immer alle kalibrierten
Karten einer Sorte (GoogleEarth = Sorte 1, TK50 = Sorte 2)
zur Verf?gung stehen. Es wird ja immer automatisch die
richtige ausgew?hlt. Deswegen habe ich:
---
mapsPath = Global.getPref().baseDir+"maps/";
---
eingesetzt.
sp?ter will ich es so haben: unter maps soll es beliebig
viele Verzeichnisse geben (zb GoogleEarth und TK50) und man
soll per Klick in der MovingMap ein anderes
Kartenverzeichnis w?hlen k?nnen, um zwischen den
verschiedenen Karten hin- und her schalten zu k?nnen.
Vielleicht lege ich dazu am besten gleich die Karten in 
mapsPath = Global.getPref().baseDir+"maps/standard";
so, habe ich jetz so gemacht.

Gru?,
  Pfeffer.		

----------------------------------------------------------------------

By: salzkammergut
Date: 2007-Jan-08 12:38

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Das Maps Verzeichnis ist

mapsDir = Global.getProfile().dataDir+"maps";

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211


From pfeffer at mail.berlios.de  Tue Jan  9 03:54:17 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 9 Jan 2007 03:54:17 +0100
Subject: [Cachewolf-svn] r369 - trunk/src/CacheWolf
Message-ID: <200701090254.l092sHJR028310@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-09 03:54:15 +0100 (Tue, 09 Jan 2007)
New Revision: 369

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
[ Feature Request #2987 ] /maps Verzeichnis ist jetzt: Pref.baseDir+"maps/standard/"

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-09 02:17:55 UTC (rev 368)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-09 02:54:15 UTC (rev 369)
@@ -94,7 +94,7 @@
 		maps = new Vector();
 		String dateien[];
 		String mapsPath = new String();
-		mapsPath = File.getProgramDirectory() + "/maps/";
+		mapsPath = Global.getPref().baseDir+"maps/standard";
 		File files = new File(mapsPath);
 		Extractor ext;
 		String rawFileName = new String();



From admin at berlios.de  Tue Jan  9 03:58:10 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 03:58:10 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2987] /maps Verzeichnis
Message-ID: <200701090258.l092wARM015235@unicorn.berlios.de>

Feature Request #2987, was updated on 2006-Dec-21 17:39
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: /maps Verzeichnis

By: pfeffer
Date: 2007-Jan-09 03:58

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Mir f?llt gerade auf: 
vielleicht bin ich einem Missverst?ndnis erlegen.
bisher sind in dem Verzeichnis Prg-Dir/maps/ die
_kalibrierten_ Karten. Dieses Verzeichnis habe ich jetz ins
Basis-Daten-Verz verlegt.

Aber hier waren evtl. die Karten gemeint, die beim
Cache-Download mit herunter geladen werden k?nnen?
Diese Funktion wird ja ?berfl?ssig, wenn BilboWolf das
automatische Herunterladen von kalibrierten Karten (von
GoogleEarth) implementiert hat.

BilboWolf, wie sieht es damit aus?

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-09 03:52

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

---
Das Maps Verzeichnis ist
mapsDir = Global.getProfile().dataDir+"maps";
---
Sehe ich das richtig, dass sich demnach das maps-Verzeichnis
je nach Profil unterschiedlich w?re?
Das soll nicht sein, es sollen immer alle kalibrierten
Karten einer Sorte (GoogleEarth = Sorte 1, TK50 = Sorte 2)
zur Verf?gung stehen. Es wird ja immer automatisch die
richtige ausgew?hlt. Deswegen habe ich:
---
mapsPath = Global.getPref().baseDir+"maps/";
---
eingesetzt.
sp?ter will ich es so haben: unter maps soll es beliebig
viele Verzeichnisse geben (zb GoogleEarth und TK50) und man
soll per Klick in der MovingMap ein anderes
Kartenverzeichnis w?hlen k?nnen, um zwischen den
verschiedenen Karten hin- und her schalten zu k?nnen.
Vielleicht lege ich dazu am besten gleich die Karten in 
mapsPath = Global.getPref().baseDir+"maps/standard";
so, habe ich jetz so gemacht.

Gru?,
  Pfeffer.		

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211


From admin at berlios.de  Tue Jan  9 13:03:27 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 13:03:27 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3032] Hint verschieben in Beschreibung
	als But
Message-ID: <200701091203.l09C3RsM001196@unicorn.berlios.de>

Feature Request #3032, was updated on 2007-Jan-09 13:03
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3032&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Hint verschieben in Beschreibung als But

By: pfeffer
Date: 2007-Jan-09 13:03

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

siehe: http://www.geoclub.de/
viewtopic.php?p=209832#209832

Ich bin daf?r, den verschl?sselten Hint (deutsch: 
Tipp) als Button, der eine Messagebox ?ffnet, in der 
Cachebeschreibung zwichen die Button +/- zu 
machen. Dadurch bekommt man auf der Seite mit 
den Logs mehr Platz. 
Die MessageBox sollte den hint zun?chst 
verschl?sselt anzeigen und erst bei einem Klick auf 
"entschl?sseln" entschl?sseln.

Gru?,
  Pfeffer.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3032&group_id=2211


From admin at berlios.de  Tue Jan  9 13:38:22 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 13:38:22 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3032] Hint verschieben in Beschreibung
	als But
Message-ID: <200701091238.l09CcMlF003715@unicorn.berlios.de>

Feature Request #3032, was updated on 2007-Jan-09 13:03
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3032&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Hint verschieben in Beschreibung als But

By: salzkammergut
Date: 2007-Jan-09 13:38

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Ich habe vor Kurzem den Balken zwischen Hint und Logs
verschiebbar gemacht. Dadurch kann die Buttonreihe ganz nach
oben geschoben werden um Platz f?r mehr Logs zu machen.

Reicht das ?

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-09 13:03

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

siehe: http://www.geoclub.de/
viewtopic.php?p=209832#209832

Ich bin daf?r, den verschl?sselten Hint (deutsch: 
Tipp) als Button, der eine Messagebox ?ffnet, in der 
Cachebeschreibung zwichen die Button +/- zu 
machen. Dadurch bekommt man auf der Seite mit 
den Logs mehr Platz. 
Die MessageBox sollte den hint zun?chst 
verschl?sselt anzeigen und erst bei einem Klick auf 
"entschl?sseln" entschl?sseln.

Gru?,
  Pfeffer.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3032&group_id=2211


From admin at berlios.de  Tue Jan  9 13:40:42 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 13:40:42 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2987] /maps Verzeichnis
Message-ID: <200701091240.l09CegTK006401@unicorn.berlios.de>

Feature Request #2987, was updated on 2006-Dec-21 17:39
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: /maps Verzeichnis

By: salzkammergut
Date: 2007-Jan-09 13:40

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Du hast nat?rlich recht, Pfeffer. Ich bin kurz einer
geistigen Umnachtung erlegen als ich schrieb
   Global.getProfile().dataDir
Habe (wie Du richtig erkannt hast)
   Global.getPref().baseDir
gemeint.

Gr??e
salzkammergut


----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-09 03:58

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Mir f?llt gerade auf: 
vielleicht bin ich einem Missverst?ndnis erlegen.
bisher sind in dem Verzeichnis Prg-Dir/maps/ die
_kalibrierten_ Karten. Dieses Verzeichnis habe ich jetz ins
Basis-Daten-Verz verlegt.

Aber hier waren evtl. die Karten gemeint, die beim
Cache-Download mit herunter geladen werden k?nnen?
Diese Funktion wird ja ?berfl?ssig, wenn BilboWolf das
automatische Herunterladen von kalibrierten Karten (von
GoogleEarth) implementiert hat.

BilboWolf, wie sieht es damit aus?

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211


From admin at berlios.de  Tue Jan  9 20:02:37 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 20:02:37 +0100 (CET)
Subject: [Feature #2886] Markieren zugehörender Caches
Message-ID: <200701091902.l09J2bhd006717@unicorn.berlios.de>

Feature Request #2886, was updated on 2006-Nov-18 13:17
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2886&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Markieren zugeh?render Caches

By: bilbowolf
Date: 2006-Nov-18 13:17

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Siehe: 002534

Dieses FR betrifft zwei Sachen:

1) Markieren eines wegpunktes, und alle, die 
dazug?hren werden dann ebenfalls markiert,

3) Wenn ein Cache als gefunden markiert wird, 
werden alle, zugeh?rigen Caches ebenfalls als 
gefunden markiert.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2886&group_id=2211


From admin at berlios.de  Tue Jan  9 20:04:06 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 20:04:06 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #1971] Destinator Export
Message-ID: <200701091904.l09J46eS008745@unicorn.berlios.de>

Feature Request #1971, was updated on 2006-Mar-16 21:15
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1971&group_id=2211

Category: None
Status: Closed
Priority: 5
Summary: Destinator Export

By: kalli
Date: 2007-Jan-09 20:04

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

Erledigt ?ber TPL-Export

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Mar-16 21:15

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.1) Gecko/20060111 Firefox/1.5.0.1

Mit diesem export soll es m?glich sein direkt auf dem
PPC eine, bzw. je nach Cachesorte eine Favoritendatie
f?r den Destinator zu erzeugen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1971&group_id=2211


From bilbowolf at mail.berlios.de  Tue Jan  9 21:57:42 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 9 Jan 2007 21:57:42 +0100
Subject: [Cachewolf-svn] r370 - trunk/resources
Message-ID: <200701092057.l09KvgIv021449@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-09 21:57:41 +0100 (Tue, 09 Jan 2007)
New Revision: 370

Added:
   trunk/resources/kml.tpl
Log:
kml export template (tpl)

Added: trunk/resources/kml.tpl
===================================================================
--- trunk/resources/kml.tpl	2007-01-09 02:54:15 UTC (rev 369)
+++ trunk/resources/kml.tpl	2007-01-09 20:57:41 UTC (rev 370)
@@ -0,0 +1,19 @@
+<tmpl_par name="newline" value="CRLF">
+<?xml version="1.0" encoding="UTF-8"?>
+<kml xmlns="http://earth.google.com/kml/2.1">
+
+<Document>
+  <name>Geocaching</name>
+  <description><![CDATA[Geocaching mit CacheWolf]]></description>
+<tmpl_loop cache_index>
+ <Placemark><br/>
+   <description><tmpl_var name=NAME></description><br/>
+   <name><tmpl_var name=NAME></name><br/>
+   <Point><br/>
+     <coordinates><tmpl_var name=LON>,<tmpl_var name=LAT>,0</coordinates><br/>
+   </Point><br/>
+ </Placemark><br/>
+</tmpl_loop>
+</Document>
+</kml>
+



From bilbowolf at mail.berlios.de  Tue Jan  9 22:36:12 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 9 Jan 2007 22:36:12 +0100
Subject: [Cachewolf-svn] r371 - trunk/src/CacheWolf
Message-ID: <200701092136.l09LaCU9027626@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-09 22:36:10 +0100 (Tue, 09 Jan 2007)
New Revision: 371

Modified:
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/Reducer.java
   trunk/src/CacheWolf/SafeXML.java
Log:
Etwas aufger?\195?\164umt (replace mit STRreplace.replace ersetzt)

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-09 20:57:41 UTC (rev 370)
+++ trunk/src/CacheWolf/Parser.java	2007-01-09 21:36:10 UTC (rev 371)
@@ -118,27 +118,6 @@
 		MessageStack.add(str);
 	}
 	
-	/* Replace all instances of a String in a String.
-	 *   @param  s  String to alter.
-	 *   @param  f  String to look for.
-	 *   @param  r  String to replace it with, or null to just remove it.
-	 */ 
-	public String replace( String s, String f, String r )
-	{
-	   if (s == null)  return s;
-	   if (f == null)  return s;
-	   if (r == null)  r = "";
-	
-	   int index01 = s.indexOf( f );
-	   while (index01 != -1)
-	   {
-	      s = s.substring(0,index01) + r + s.substring(index01+f.length());
-	      index01 += r.length();
-	      index01 = s.indexOf( f, index01 );
-	   }
-	   return s;
-	}
-	
 	private void parseCommand(){
 		boolean foundCommand = false;
 		////Vm.debug("In command");
@@ -196,8 +175,8 @@
 				if(runFlag) result = (String)symbolTable.get(thisToken.token);
 				if(result != null){
 					result.trim();
-					result = replace(result, ".0", "");
-					result = replace(result, ",0", "");
+					result = STRreplace.replace(result, ".0", "");
+					result = STRreplace.replace(result, ",0", "");
 					emit_buffer = emit_buffer + result;
 				} else {
 					err("# Error: Variable " +thisToken.token+ " not defined");
@@ -223,8 +202,8 @@
 				}
 				String stra = a.toString();
 				stra.trim();
-				stra = replace(stra, ",0", "");
-				stra = replace(stra, ".0", "");
+				stra = STRreplace.replace(stra, ",0", "");
+				stra = STRreplace.replace(stra, ".0", "");
 				emit_buffer = emit_buffer + stra;
 				
 			}

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-09 20:57:41 UTC (rev 370)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-09 21:36:10 UTC (rev 371)
@@ -72,7 +72,7 @@
 	public SerialPortOptions mySPO = new SerialPortOptions();
 	public boolean forwardGPS = false;
 	public String forwardGpsHost = new String();
-	public int fontSize = 14;
+	public int fontSize = 12;
 	// Helper variables for XML parser 
 	private StringBuffer collectElement=null; 
 	private String lastName; // The string to the last XML that was processed

Modified: trunk/src/CacheWolf/Reducer.java
===================================================================
--- trunk/src/CacheWolf/Reducer.java	2007-01-09 20:57:41 UTC (rev 370)
+++ trunk/src/CacheWolf/Reducer.java	2007-01-09 21:36:10 UTC (rev 371)
@@ -39,39 +39,18 @@
 	
 	private static String removeVow(String str){
 		String dummy = str.substring(1);
-		dummy = replace(dummy,"a", "");
-		dummy = replace(dummy,"e", "");
-		dummy = replace(dummy,"i", "");
-		dummy = replace(dummy,"o", "");
-		dummy = replace(dummy,"u", "");
-		dummy = replace(dummy,"A", "");
-		dummy = replace(dummy,"E", "");
-		dummy = replace(dummy,"I", "");
-		dummy = replace(dummy,"O", "");
-		dummy = replace(dummy,"U", "");
-		dummy = replace(dummy,",","");
+		dummy = STRreplace.replace(dummy,"a", "");
+		dummy = STRreplace.replace(dummy,"e", "");
+		dummy = STRreplace.replace(dummy,"i", "");
+		dummy = STRreplace.replace(dummy,"o", "");
+		dummy = STRreplace.replace(dummy,"u", "");
+		dummy = STRreplace.replace(dummy,"A", "");
+		dummy = STRreplace.replace(dummy,"E", "");
+		dummy = STRreplace.replace(dummy,"I", "");
+		dummy = STRreplace.replace(dummy,"O", "");
+		dummy = STRreplace.replace(dummy,"U", "");
+		dummy = STRreplace.replace(dummy,",","");
 		dummy = str.substring(0,1) + dummy;
 		return dummy;
 	}
-	
-	/** Replace all instances of a String in a String.
-		 *   @param  s  String to alter.
-		 *   @param  f  String to look for.
-		 *   @param  r  String to replace it with, or null to just remove it.
-		 */ 
-		private static String replace( String s, String f, String r )
-		{
-		   if (s == null)  return s;
-		   if (f == null)  return s;
-		   if (r == null)  r = "";
-		
-		   int index01 = s.indexOf( f );
-		   while (index01 != -1)
-		   {
-			  s = s.substring(0,index01) + r + s.substring(index01+f.length());
-			  index01 += r.length();
-			  index01 = s.indexOf( f, index01 );
-		   }
-		   return s;
-		}
 }

Modified: trunk/src/CacheWolf/SafeXML.java
===================================================================
--- trunk/src/CacheWolf/SafeXML.java	2007-01-09 20:57:41 UTC (rev 370)
+++ trunk/src/CacheWolf/SafeXML.java	2007-01-09 21:36:10 UTC (rev 371)
@@ -388,13 +388,13 @@
 	public static String cleanGPX(String str){
 		String dummy = new String();
 		
-		dummy = replace(str, "&","&amp;");
-		dummy = replace(dummy, "<", "&lt;");
-		dummy = replace(dummy, ">", "&gt;");
+		dummy = STRreplace.replace(str, "&","&amp;");
+		dummy = STRreplace.replace(dummy, "<", "&lt;");
+		dummy = STRreplace.replace(dummy, ">", "&gt;");
 		//dummy = replace(dummy, "&nbsp;", "&amp;nbsp;");
-		dummy = replace(dummy, "\"", "&quot;");
-		dummy = replace(dummy, "'","&apos;");
-		dummy = replace(dummy, "]]>","]] >");
+		dummy = STRreplace.replace(dummy, "\"", "&quot;");
+		dummy = STRreplace.replace(dummy, "'","&apos;");
+		dummy = STRreplace.replace(dummy, "]]>","]] >");
 
 		return dummy;
 	}
@@ -429,25 +429,4 @@
 	
 		return dummy;
 	}*/
-	
-	/* Replace all instances of a String in a String.
-		 *   @param  s  String to alter.
-		 *   @param  f  String to look for.
-		 *   @param  r  String to replace it with, or null to just remove it.
-		 */ 
-		public static String replace( String s, String f, String r )
-		{
-		   if (s == null)  return s;
-		   if (f == null)  return s;
-		   if (r == null)  r = "";
-		
-		   int index01 = s.indexOf( f );
-		   while (index01 != -1)
-		   {
-			  s = s.substring(0,index01) + r + s.substring(index01+f.length());
-			  index01 += r.length();
-			  index01 = s.indexOf( f, index01 );
-		   }
-		   return s;
-		}
 }



From bilbowolf at mail.berlios.de  Tue Jan  9 22:39:03 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 9 Jan 2007 22:39:03 +0100
Subject: [Cachewolf-svn] r372 - trunk/src/CacheWolf
Message-ID: <200701092139.l09Ld3Of027912@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-09 22:39:02 +0100 (Tue, 09 Jan 2007)
New Revision: 372

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
weiteres "replace" aufr?\195?\164umen.

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-09 21:36:10 UTC (rev 371)
+++ trunk/src/CacheWolf/Profile.java	2007-01-09 21:39:02 UTC (rev 372)
@@ -147,9 +147,9 @@
 					ch.noFindLogs = Convert.toInt(ex.findNext());
 					ch.ocCacheID = ex.findNext();
 					// remove "/>
-					ch.ocCacheID = SafeXML.replace(ch.ocCacheID,"\"/>", null);
+					ch.ocCacheID = STRreplace.replace(ch.ocCacheID,"\"/>", null);
 					// remove additional " if present
-					ch.ocCacheID = SafeXML.replace(ch.ocCacheID,"\"", null);
+					ch.ocCacheID = STRreplace.replace(ch.ocCacheID,"\"", null);
 					cacheDB.add(ch);
 				} else if (text.indexOf("<CENTRE")>=0) { // lat=  lon=
 					int start=text.indexOf("lat=\"")+5;



From bilbowolf at mail.berlios.de  Tue Jan  9 22:59:30 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 9 Jan 2007 22:59:30 +0100
Subject: [Cachewolf-svn] r373 - trunk/src/CacheWolf
Message-ID: <200701092159.l09LxUw2031701@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-09 22:59:28 +0100 (Tue, 09 Jan 2007)
New Revision: 373

Removed:
   trunk/src/CacheWolf/MyXMLBuilder.java
Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/Profile.java
Log:
MyXMLBuilder entfernt / Erste Gedanken, Filtereinstellungen je profil speichern zu k?\195?\182nnen.

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-09 21:39:02 UTC (rev 372)
+++ trunk/src/CacheWolf/Filter.java	2007-01-09 21:59:28 UTC (rev 373)
@@ -10,6 +10,10 @@
 *	The class that uses this filter must set the different public variables.
 */
 public class Filter{
+	
+	// Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
+	
+	
 	public static final int SMALLER = -1;
 	public static final int GREATER = 1;
 	public static final int FOUND = 2;

Deleted: trunk/src/CacheWolf/MyXMLBuilder.java
===================================================================
--- trunk/src/CacheWolf/MyXMLBuilder.java	2007-01-09 21:39:02 UTC (rev 372)
+++ trunk/src/CacheWolf/MyXMLBuilder.java	2007-01-09 21:59:28 UTC (rev 373)
@@ -1,128 +0,0 @@
-package CacheWolf;
-
-import ewesoft.xml.*;
-import ewesoft.xml.sax.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.util.*;
-import ewe.data.PropertyList;
-
-/**
-*	Class to parse the index.xml file. The methods are rather straight forward.
-*	This class could probably be substituted by an Extractor class.
-*   index.xml is saved by class CacheReaderWriter.
-*/
-public class MyXMLBuilder extends MinML {
-	
-	Vector cacheDB;
-	CacheHolder holder;
-	public XMLElement document;
-	//private XMLElement current;
-	//private String currentText = new String();
-	private String path = new String();
-	static protected final int NAME 	= 0;
-	static protected final int OWNER 	= 1;
-	static protected final int LATLON 	= 2;
-	static protected final int HIDDEN 	= 3;
-	static protected final int WAYP 	= 4;
-	static protected final int STATUS 	= 5;
-	static protected final int TYPE 	= 6;
-	static protected final int DIF 		= 7;
-	static protected final int TERRAIN 	= 8;
-	static protected final int DIRTY 	= 9;
-	static protected final int SIZE 	= 10;
-	static protected final int ONLINE 	= 11;
-	static protected final int ARCHIVED = 12;
-	static protected final int HAS_BUG 	= 13;
-	static protected final int BLACK 	= 14;
-	static protected final int OWNED 	= 15;
-	static protected final int FOUND 	= 16;
-	static protected final int IS_NEW 	= 17;
-	static protected final int IS_LOG_UPDATE = 18;
-	static protected final int IS_UPDATE = 19;
-	static protected final int IS_HTML 	= 20;
-	static protected final int DNFLOGS 	= 21;
-	static protected final int OCCACHEID = 22;
-	
-	
-	public MyXMLBuilder(Vector DB, String p)
-	{
-		cacheDB = DB;
-		path = p;
-	}
-	
-	public void doIt(){
-
-		try{
-			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(path + "index.xml"));
-			parse(r);
-			r.close();
-			
-		}catch(Exception e){
-			//Vm.debug(e.toString());
-		}
-	}
-	public void startElement(String name, AttributeList atts){
-		if(name.equals("CACHE")){
-			holder = new CacheHolder();
-			holder.CacheName = atts.getValue(NAME);
-			holder.CacheOwner = atts.getValue(OWNER);
-			holder.LatLon = atts.getValue(LATLON);
-			holder.DateHidden = atts.getValue(HIDDEN);
-			holder.wayPoint = atts.getValue(WAYP);
-			holder.CacheStatus = atts.getValue(STATUS);
-			holder.type = atts.getValue(TYPE);
-			holder.hard = atts.getValue(DIF);
-			holder.terrain = atts.getValue(TERRAIN);
-			holder.dirty = atts.getValue(DIRTY);
-			holder.CacheSize = atts.getValue(SIZE);
-			  
-			holder.is_available = (atts.getValue(ONLINE).equals("true") ? true : false);
-			holder.is_archived = (atts.getValue(ARCHIVED).equals("true") ? true : false);
-			holder.has_bug = (atts.getValue(HAS_BUG).equals("true") ? true : false);
-			holder.is_black = (atts.getValue(BLACK).equals("true") ? true : false);
-			holder.is_owned = (atts.getValue(OWNED).equals("true") ? true : false);
-			holder.is_found = (atts.getValue(FOUND).equals("true") ? true : false);
-			holder.is_new = (atts.getValue(IS_NEW).equals("true") ? true : false);
-			holder.is_log_update = (atts.getValue(IS_LOG_UPDATE).equals("true") ? true : false);
-			holder.is_update = (atts.getValue(IS_UPDATE).equals("true") ? true : false);
-			  // for backwards compatibility set value to true, if it is not in the file
-			holder.is_HTML = (atts.getValue(IS_HTML).equals("false") ? false : true);
-			holder.noFindLogs = Convert.toInt(atts.getValue(DNFLOGS));
-			holder.ocCacheID = atts.getValue(OCCACHEID);
-		}
-
-/*		for (int i = 0; i < atts.getLength(); i++) {
-		  if(atts.getName(i).equals("name")) holder.CacheName = atts.getValue(i);
-		  if(atts.getName(i).equals("owner")) holder.CacheOwner = atts.getValue(i);
-		  if(atts.getName(i).equals("latlon")) holder.LatLon = atts.getValue(i);
-		  if(atts.getName(i).equals("hidden")) holder.DateHidden = atts.getValue(i);
-		  if(atts.getName(i).equals("wayp")) holder.wayPoint = atts.getValue(i);
-		  if(atts.getName(i).equals("status")) holder.CacheStatus = atts.getValue(i);
-		  if(atts.getName(i).equals("type")) holder.type = atts.getValue(i);
-		  if(atts.getName(i).equals("dif")) holder.hard = atts.getValue(i);
-		  if(atts.getName(i).equals("terrain")) holder.terrain = atts.getValue(i);
-		  if(atts.getName(i).equals("dirty")) holder.dirty = atts.getValue(i);
-		  if(atts.getName(i).equals("size")) holder.CacheSize = atts.getValue(i);
-		  
-		  if(atts.getName(i).equals("online")) holder.is_available = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("archived")) holder.is_archived = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("has_bug")) holder.has_bug = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("black")) holder.is_black = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("owned")) holder.is_owned = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("found")) holder.is_found = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("is_new")) holder.is_new = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("is_log_update")) holder.is_log_update = (atts.getValue(i).equals("true") ? true : false);
-		  if(atts.getName(i).equals("is_update")) holder.is_update = (atts.getValue(i).equals("true") ? true : false);
-		  // for backwards compatibility set value to true, if it is not in the file
-		  if(atts.getName(i).equals("is_HTML")) holder.is_HTML = (atts.getValue(i).equals("false") ? false : true);
-		  if(atts.getName(i).equals("DNFLOGS")) holder.noFindLogs = Convert.toInt(atts.getValue(i));
-		  if(atts.getName(i).equals("ocCacheID")) holder.ocCacheID = atts.getValue(i);
-		}
-*/	}
-	
-	public void endElement(String name){
-		if(name.equals("CACHE"))	cacheDB.add(holder);
-	}
-	
-}

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-09 21:39:02 UTC (rev 372)
+++ trunk/src/CacheWolf/Profile.java	2007-01-09 21:59:28 UTC (rev 373)
@@ -57,7 +57,7 @@
 	
 	/**
 	*	Method to save the index.xml file that holds the total information
-	*	on available caches in the database. The database in nothing else
+	*	on available caches in the database. The database is nothing else
 	*	than the collection of caches in a directory.
 	*   
 	*   Not sure whether we need to keep 'pref' in method signature. May eventually remove it. 
@@ -86,6 +86,9 @@
 			if(distOC == null || distOC.endsWith("null") || distOC.equals("")){
 				distOC = "0";
 			}
+			
+			// Bilbowolf: detfile.print("    <FILTER ....
+			
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);



From bilbowolf at mail.berlios.de  Tue Jan  9 23:12:13 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 9 Jan 2007 23:12:13 +0100
Subject: [Cachewolf-svn] r374 - trunk/src/CacheWolf
Message-ID: <200701092212.l09MCDPe001723@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-09 23:12:11 +0100 (Tue, 09 Jan 2007)
New Revision: 374

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
Log:
Feature Request #2226 Filter f?\195?\188r Earth und MegaEvent umgesetzt.

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-09 21:59:28 UTC (rev 373)
+++ trunk/src/CacheWolf/Filter.java	2007-01-09 22:12:11 UTC (rev 374)
@@ -18,8 +18,7 @@
 	public static final int GREATER = 1;
 	public static final int FOUND = 2;
 	public static final int NOTFOUND = 3;
-	
-	
+
 	public static final int TRADITIONAL = 1;
 	public static final int MULTI = 2;
 	public static final int VIRTUAL = 4;
@@ -29,6 +28,9 @@
 	public static final int MYSTERY = 64;
 	public static final int LOCLESS = 128;
 	public static final int ADDIWPT = 256;
+	public static final int MEGA = 512;
+	public static final int EARTH = 1024;
+	
 	// End of type declares
 	public static final int N = 1;
 	public static final int NNE = 2;
@@ -236,6 +238,8 @@
 			if(ch.type.equals("11")) cacheTypePattern |= WEBCAM;
 			if(ch.type.equals("12")) cacheTypePattern |= LOCLESS;
 			if (CacheType.isAddiWpt(ch.type)) cacheTypePattern |= ADDIWPT;
+			if(ch.type.equals("137"))cacheTypePattern |= EARTH;
+			if(ch.type.equals("453"))cacheTypePattern |= MEGA;
 			
 			cacheRosePattern = 0;
 			if(ch.bearing.equals("NW")) cacheRosePattern |= NW;

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-01-09 21:59:28 UTC (rev 373)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-01-09 22:12:11 UTC (rev 374)
@@ -15,7 +15,7 @@
 	mButton btCancel, btApply,btRoute,btArea;
 	
 	mChoice distChc, difChc, terrChc, lastChc;
-	mCheckBox foundChk, tradChk, virtualChk, eventChk;
+	mCheckBox foundChk, tradChk, virtualChk, eventChk, earthChk, megaChk;
 	mCheckBox ownedChk, multiChk, letterChk, webcamChk, mysteryChk,addiWptChk, loclessChk;
 	mInput distIn, difIn, terrIn, lastIn, foundIn;
 	Vector cacheDB;
@@ -66,6 +66,8 @@
 		content.addLast(ownedChk = new mCheckBox((String)lr.get(707,"Owned")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		CellPanel ctype = new CellPanel();
+		
+		ctype.addLast(new mLabel("__________"));
 		ctype.addNext(tradChk = new mCheckBox("Traditonal"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		ctype.addNext(multiChk = new mCheckBox("Multi"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		ctype.addLast(virtualChk = new mCheckBox("Virtual"), CellConstants.DONTSTRETCH, CellConstants.FILL);
@@ -75,9 +77,12 @@
 		ctype.addLast(webcamChk = new mCheckBox("Webcam"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		ctype.addNext(mysteryChk = new mCheckBox("Mystery"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		ctype.addNext(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		ctype.addNext(earthChk = new mCheckBox("Earth"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		ctype.addLast(loclessChk = new mCheckBox("Locationless"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
+		ctype.addNext(megaChk = new mCheckBox("Mega-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		ctype.addLast(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		ctype.addLast(new mLabel("__________"));
 		content.addLast(ctype, CellConstants.STRETCH,CellConstants.FILL);
 		
 		CellPanel roseP = new CellPanel();
@@ -166,6 +171,8 @@
 				if(mysteryChk.getState()) typeMatchPattern |= Filter.MYSTERY;
 				if(loclessChk.getState()) typeMatchPattern |= Filter.LOCLESS;
 				if(addiWptChk.getState()) typeMatchPattern |= Filter.ADDIWPT;
+				if(earthChk.getState()) typeMatchPattern |= Filter.EARTH;
+				if(megaChk.getState()) typeMatchPattern |= Filter.MEGA;
 				flt.typeMatchPattern = typeMatchPattern;
 				int roseMatchPattern = 0;
 				if(N.getState()) roseMatchPattern |= Filter.N;



From admin at berlios.de  Tue Jan  9 23:12:30 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 9 Jan 2007 23:12:30 +0100 (CET)
Subject: [Feature #2226] Filter für Earthcache und Megaevent
Message-ID: <200701092212.l09MCUkn016516@unicorn.berlios.de>

Feature Request #2226, was updated on 2006-May-23 19:19
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2226&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Filter f?r Earthcache und Megaevent

By: bilbowolf
Date: 2007-Jan-09 23:12

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Mit rev 374 implementiert

----------------------------------------------------------------------

By: kalli
Date: 2006-May-23 19:19

Message:
Logged In: YES 
user_id=24621
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; de) Opera 8.50

Earthcaches k?nnen nicht gefiltert werden, siehe 
http://www.geoclub.de/ftopic9243.html

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2226&group_id=2211


From admin at berlios.de  Wed Jan 10 00:09:38 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 10 Jan 2007 00:09:38 +0100 (CET)
Subject: [Bug #7351] Export und zähler
Message-ID: <200701092309.l09N9cne018956@unicorn.berlios.de>

Bug #7351, was updated on 2006-May-02 07:14
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: bilbowolf
Assigned to : kalli
Summary: Export und z?hler

Details: Beim export wird immer die cacheDB Gr?sse angezeigt und nicht die Gr??e der gefilterten Datens?tze. Ist nicht ganz logisch.

Follow-Ups:

Date: 2007-Jan-10 00:09
By: kalli

Comment:
In Absprache mit Bilbowolf ?bernommen
-------------------------------------------------------

Date: 2006-Aug-05 11:44
By: kalli

Comment:
Hier k?nnte man vieleicht die Anzeige nehmen, die beim TPL-Export eingebaut wurde.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=7351&group_id=2211


From kalli at mail.berlios.de  Wed Jan 10 00:32:04 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Wed, 10 Jan 2007 00:32:04 +0100
Subject: [Cachewolf-svn] r375 - trunk/src/CacheWolf
Message-ID: <200701092332.l09NW4fo015416@sheep.berlios.de>

Author: kalli
Date: 2007-01-10 00:32:01 +0100 (Wed, 10 Jan 2007)
New Revision: 375

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
Gespiderte Addi wpts werden abgespeichert.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-01-09 22:12:11 UTC (rev 374)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-09 23:32:01 UTC (rev 375)
@@ -457,6 +457,7 @@
 				//Vm.debug(descRex.stringMatched(1));
 				
 				cacheDB.add(cx);
+				cx.saveCacheDetails(profile.dataDir);
 				cx = new CacheHolder();
 				
 				rowBlock = exRowBlock.findNext();



From pfeffer at mail.berlios.de  Wed Jan 10 19:57:55 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 10 Jan 2007 19:57:55 +0100
Subject: [Cachewolf-svn] r376 - trunk/src/CacheWolf
Message-ID: <200701101857.l0AIvtVL007236@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-10 19:57:52 +0100 (Wed, 10 Jan 2007)
New Revision: 376

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
[ Bug #8313 ] Pfeile auf Goto-Panel ?\195?\188bermalt alles

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-09 23:32:01 UTC (rev 375)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-10 18:57:52 UTC (rev 376)
@@ -154,17 +154,17 @@
 	SerialThread serThread;
 	UpdateThread tickerThread;
 
-	ImageControl ic; 
+	ImageControl icRose;
+	GotoRose compassRose;
 
-	static Color RED = new Color(255,0,0);
-	static Color YELLOW = new Color(255,255,0);
-	static Color GREEN = new Color(0,255,0);
-	static Color BLUE = new Color(0,255,255);
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,255,255);
 
-	static Font BOLD = new Font("Arial", Font.BOLD, 14);
+	final static Font BOLD = new Font("Arial", Font.BOLD, 14);
 
-	int centerX, centerY;
-
+	GotoRose rose;
 	int ticker = 0;
 
 	boolean mapsLoaded = false;
@@ -215,11 +215,9 @@
 		CoordsP.addLast(btnGoto = new mButton(toPoint.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 
 		//Rose for bearing
-		Image img = new Image("rose.png");
-		ic = new ImageControl(img);
-		centerY = img.getHeight() / 2;
-		centerX = img.getWidth() / 2;
-		roseP.addLast(ic,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		compassRose = new GotoRose("rose.png");
+		icRose = new ImageControl(compassRose);
+		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
 
 		//Goto
 		//things from GPS
@@ -307,46 +305,8 @@
 //		}	
 	}
 
-	/**
-	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
-	 */
 
-	private void drawArrows(Control ctrl,double moveDir, double destDir, double sunAziumt){
-		Graphics g = ctrl.getGraphics();
-
-		if (g != null) {
-			ctrl.repaintNow();
-			// draw only valid arrows
-			if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, RED);
-			if (destDir < 360 && destDir > -360) drawArrow(g, destDir, BLUE);
-			if (sunAziumt < 360 && sunAziumt > -360) drawArrow(g, sunAziumt, YELLOW);
-			g.free();
-		}
-
-	}
-
 	/**
-	 * draw single arrow 
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
-	 */
-	private void drawArrow(Graphics g, double angle, Color col) {
-		double angleRad;
-		int x, y;
-
-		angleRad = angle * java.lang.Math.PI / 180;
-		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
-		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
-		g.setPen(new Pen(col,Pen.SOLID,3));
-		g.drawLine(centerX,centerY,x,y);
-
-	}
-
-	/**
 	 * set the coords of the destination  
 	 * @param dest destination
 	 */ 
@@ -420,7 +380,7 @@
 				lblDist.setText(dist.toString(3,0,0) + " m");
 			}
 
-			drawArrows(ic,bearMov.value,bearWayP.value, sunAzimut.value);
+			compassRose.setDirections((float)bearMov.value,(float)bearWayP.value, (float)sunAzimut.value);
 
 			// Set background to signal quality
 			lblSats.backGround = GREEN;
@@ -636,3 +596,70 @@
 		super.onEvent(ev);
 	}
 }
+
+/** class for displaying the compass rose
+ * including goto, sun and moving direction
+ */
+class GotoRose extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+	
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,255,255);
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public GotoRose(String fn){
+		super(fn);
+	}
+	
+	public void setDirections(float gd, float sd, float md ) {
+		gotoDir = gd;
+		sunDir = sd;
+		moveDir = md;
+		refresh();
+	}
+	
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+	
+	public void doDraw(Graphics g,int options) {
+		super.doDraw(g, options);
+		drawArrows(g);
+	}
+
+	private void drawArrows(Graphics g){
+		if (g != null) {
+			// draw only valid arrows
+			if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, RED);
+			if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, BLUE);
+			if (sunDir < 360 && sunDir> -360) drawArrow(g, sunDir, YELLOW);
+		}
+	}
+
+	/**
+	 * draw single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void drawArrow(Graphics g, float angle, Color col) {
+		float angleRad;
+		int x, y, centerX = location.width/2, centerY = location.height/2;
+
+		angleRad = angle * (float)java.lang.Math.PI / 180;
+		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
+		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(centerX,centerY,x,y);
+	}
+}



From admin at berlios.de  Wed Jan 10 19:58:32 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 10 Jan 2007 19:58:32 +0100 (CET)
Subject: [Bug #8313] Pfeile auf Goto-Panel übermalt alles
Message-ID: <200701101858.l0AIwWXY027266@unicorn.berlios.de>

Bug #8313, was updated on 2006-Aug-07 22:35
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: pfeffer
Assigned to : albsucher
Summary: Pfeile auf Goto-Panel ?bermalt alles

Details: die Pfeile aus dem Goto-Panel ?bermalen andere Dialoge, (z.B. Preferenzen), wenn GPS-Empfang eingeschaltet ist.

Follow-Ups:

Date: 2007-Jan-10 19:58
By: pfeffer

Comment:
erledigt mit SVN-Nummer 376
-------------------------------------------------------

Date: 2006-Sep-22 09:26
By: pfeffer

Comment:
ja, ok, das w?re eine M?glichkeit. Ich h?tte allerdings gedacht, dass das eigentlich ein Problem des Fenster-Management ist? - Dass wir vielleicht blo? den falschen draw-Befehl verwenden, der einfach unabh?ngig vom Fenster-Managemant mahlt?
Kennt sich da jemand aus?
-------------------------------------------------------

Date: 2006-Sep-22 08:53
By: bilbowolf

Comment:
Hier m?ssen wir sicherstellen, da? der Goto sich schlafen legt, wenn man aus dem Tab herausspringt.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=8313&group_id=2211


From admin at berlios.de  Wed Jan 10 20:00:01 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 10 Jan 2007 20:00:01 +0100 (CET)
Subject: [Bug #8313] Pfeile auf Goto-Panel übermalt alles
Message-ID: <200701101900.l0AJ01S0027574@unicorn.berlios.de>

Bug #8313, was updated on 2006-Aug-07 22:35
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: pfeffer
Assigned to : albsucher
Summary: Pfeile auf Goto-Panel ?bermalt alles

Details: die Pfeile aus dem Goto-Panel ?bermalen andere Dialoge, (z.B. Preferenzen), wenn GPS-Empfang eingeschaltet ist.

Follow-Ups:

Date: 2007-Jan-10 20:00
By: pfeffer

Comment:
erledigt mit SVN-Nummer 376. Die Kompassrose hat nun eine eigene Klasse.
-------------------------------------------------------

Date: 2006-Sep-22 09:26
By: pfeffer

Comment:
ja, ok, das w?re eine M?glichkeit. Ich h?tte allerdings gedacht, dass das eigentlich ein Problem des Fenster-Management ist? - Dass wir vielleicht blo? den falschen draw-Befehl verwenden, der einfach unabh?ngig vom Fenster-Managemant mahlt?
Kennt sich da jemand aus?
-------------------------------------------------------

Date: 2006-Sep-22 08:53
By: bilbowolf

Comment:
Hier m?ssen wir sicherstellen, da? der Goto sich schlafen legt, wenn man aus dem Tab herausspringt.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=8313&group_id=2211


From pfeffer at mail.berlios.de  Wed Jan 10 21:52:27 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 10 Jan 2007 21:52:27 +0100
Subject: [Cachewolf-svn] r377 - trunk/src/CacheWolf
Message-ID: <200701102052.l0AKqRK4015913@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-10 21:52:24 +0100 (Wed, 10 Jan 2007)
New Revision: 377

Modified:
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
fixed:[ Bug #9134 ] Download von OC: could not write to file

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-01-10 18:57:52 UTC (rev 376)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-01-10 20:52:24 UTC (rev 377)
@@ -165,7 +165,8 @@
 			Vm.debug("Parse error: " + state + " " + holder.wayPoint);
 			e.printStackTrace();
 		}catch (Exception e){ // here schould be used the correct exepion
-			finalMessage=MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.wayPoint;
+			if (holder != null)	finalMessage=MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.wayPoint;
+			else finalMessage=MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: <unkown>";
 			success = false;
 			Vm.debug("Parse error: " + state + " " + holder.wayPoint);
 			e.printStackTrace();
@@ -546,38 +547,37 @@
 		
 	}
 	
-	private String fetch(String address, String fileName ) throws IOException
+	private String fetch(String addr, String fileName ) throws IOException
 	   	{
+			final int maxRedirections = 5;
 			//Vm.debug(address);
-			String redirect;
-
-			HttpConnection conn, fileConn;
-			
-			if(pref.myproxy.length() > 0){
-				conn = new HttpConnection(pref.myproxy, Convert.parseInt(pref.myproxyport), address);
-				Vm.debug("Proxy here: " + address);
-			} else {
-				conn = new HttpConnection(address);
+			HttpConnection conn = null;
+			Socket sock = null;
+			int i=-1;
+			String address = new String(addr);
+			while (address != null && i <= maxRedirections ) { // allow max 5 redirections (http 302 location)
+				i++;
+				if(pref.myproxy.length() > 0){
+					conn = new HttpConnection(pref.myproxy, Convert.parseInt(pref.myproxyport), address);
+					Vm.debug("Proxy here: " + address);
+				} else {
+					conn = new HttpConnection(address);
+				}
+				conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
+				conn.setRequestorProperty("Connection", "close");
+				conn.documentIsEncoded = true;
+				sock = conn.connect();
+				address = conn.getRedirectTo();
+				if (address != null){
+					if (holder != null) fileName = holder.wayPoint + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
+					else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
+				}
 			}
-			conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-			conn.setRequestorProperty("Connection", "close");
-			conn.documentIsEncoded = true;
-			Socket sock = conn.connect();
-			redirect = conn.getRedirectTo();
-			if (redirect != null){
-				//Vm.debug("Redirect: " + redirect);
-				fileConn = conn.getRedirectedConnection(redirect);
-			}
-			else {
-				fileConn = conn;
-			}
-			sock = fileConn.connect();
-			ByteArray daten = fileConn.readData(sock);
+			if (i > maxRedirections) throw new IOException("too many http redirections while trying to fetch: "+addr + " only "+maxRedirections+" are allowed");
+			//Vm.debug("Redirect: " + redirect);
+			ByteArray daten = conn.readData(sock);
 			
 			//save file
-			if (redirect != null){
-				fileName = redirect.substring(redirect.lastIndexOf("/")+1);
-			}
 			//Vm.debug("Save: " + myPref.mydatadir + fileName);
 			//Vm.debug("Daten: " + daten.length);
 			BufferedOutputStream outp =  new BufferedOutputStream(new FileOutputStream(profile.dataDir + fileName));



From admin at berlios.de  Wed Jan 10 21:57:40 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 10 Jan 2007 21:57:40 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9134] Download von OC: could not write to file
Message-ID: <200701102057.l0AKveP9016457@unicorn.berlios.de>

Bug #9134, was updated on 2006-Oct-15 19:40
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 5
Submitted by: pfeffer
Assigned to : pfeffer
Summary: Download von OC: could not write to file

Details: Warning:
Ignoring IOException: Could not write to file!
while downlaoding picture:OC085D_102236.jpg
from URL:http://www.opencaching.de/images/statpics/statpic102236.jpg
in cache: OC085D

normalerweise kommt dieser Fehler bei Dateinamen, die nicht erzeugt werden k?nne, beispielsweise, weil sie ein "?" einhalten (kommt bei Hit-Countern vor).

Ich muss mal sehen, ob dieser Fehler reproduzierbar ist.

Gru?,
   Pfeffer.

Follow-Ups:

Date: 2007-Jan-10 21:57
By: pfeffer

Comment:
behoben mit SVN 377.
Grund war, dass fetch() nur eine redirection erlaubt hatte. jetzt gehen 5 (einzustellen mit maxRedirections).

Dabei habe ich vermutlich noch ein Problem mit Proxies behoben: soweit ich das aus dem Code erkennen kann, ging der redirect-request nicht mehr ?ber den Proxy. Kann das aber nicht testen, weil ich nicht hinter einem Proxy sitze. -> hatte nicht mal irgendjemand von Problemen mit Proxy berichtet?

Vor ein paar Tagen hatte ich schon das Problem mit dem "?" behoben, indem ich es ?ber die neue Funktion Common.clearForFilename durch "_" ersetze.

Gru?,
  Pfeffer.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9134&group_id=2211


From admin at berlios.de  Wed Jan 10 23:35:37 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 10 Jan 2007 23:35:37 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9836] Koordinaten beim Spidern von addi wpts
Message-ID: <200701102235.l0AMZbQm021022@unicorn.berlios.de>

Bug #9836, was updated on 2006-Dec-28 18:50
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: kalli
Assigned to : albsucher
Summary: Koordinaten beim Spidern von addi wpts

Details: siehe http://www.geoclub.de/ftopic13172.html.


Follow-Ups:

Date: 2007-Jan-10 23:35
By: pfeffer

Comment:
bei mir gibt's bei GCMZE (hat 1 addiWP) beim ersten spidern keine Probleme. Wenn ich aber per rechtsklickt auf dem Haupt WP aktualisiere, kommt:
----
java.lang.NullPointerException
	at CacheWolf.SpiderGC.spiderSingle(SpiderGC.java:155)
---
Gru?,
   Pfeffer.
-------------------------------------------------------

Date: 2006-Dec-28 19:50
By: kalli

Comment:
Kann nur durch Spidern getestet werden. Da Albsucher die addi wpts so liebt, habe ich es mal ihm zum Testen zugewiesen :-)
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9836&group_id=2211


From admin at berlios.de  Wed Jan 10 23:39:00 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 10 Jan 2007 23:39:00 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9930] SpiderGC: <Enter> im Passworteingabe
Message-ID: <200701102239.l0AMd0lc021122@unicorn.berlios.de>

Bug #9930, was updated on 2007-Jan-10 23:39
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: pfeffer
Assigned to : pfeffer
Summary: SpiderGC: <Enter> im Passworteingabe

Details: beim SpiderGC <Enter> im Passworteingabe bewirkte abbruch, jetzt sind <enter> und <ESC> f?r die Richtigen Buttons aktiviert

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9930&group_id=2211


From pfeffer at mail.berlios.de  Wed Jan 10 23:52:46 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 10 Jan 2007 23:52:46 +0100
Subject: [Cachewolf-svn] r378 - trunk/src/CacheWolf
Message-ID: <200701102252.l0AMqki9025350@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-10 23:52:43 +0100 (Wed, 10 Jan 2007)
New Revision: 378

Modified:
   trunk/src/CacheWolf/Extractor.java
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
Log:
[ Bug #9930 ] SpiderGC: <Enter> im Passworteingabe
neue Fehlermeldung, wenn versucht wurde per rechtsklick einen Opencaching-cache zu aktuelisieren


Modified: trunk/src/CacheWolf/Extractor.java
===================================================================
--- trunk/src/CacheWolf/Extractor.java	2007-01-10 20:52:24 UTC (rev 377)
+++ trunk/src/CacheWolf/Extractor.java	2007-01-10 22:52:43 UTC (rev 378)
@@ -49,7 +49,7 @@
 		* that is being searched through.
 		*/
 		public boolean endOfSearch(){
-			if(startOffset >= searchText.length()) return true;
+			if(searchText == null || startOffset >= searchText.length()) return true;
 			else return false;
 		}
 		
@@ -59,6 +59,7 @@
 		*	is returned til it's end.
 		*/
 		public String findNext(){
+			if (searchText == null) return new String(); //maby null should 
 			int idxStart = searchText.indexOf(start,startOffset);
 			int idxEnd = searchText.indexOf(end, idxStart+start.length());
 			////Vm.debug("Start: " + Convert.toString(idxStart) + " End: " + Convert.toString(idxEnd));

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-01-10 20:52:24 UTC (rev 377)
+++ trunk/src/CacheWolf/InfoBox.java	2007-01-10 22:52:43 UTC (rev 378)
@@ -39,7 +39,10 @@
 			this.addNext(mL, CellConstants.STRETCH, CellConstants.FILL);
 			this.addLast(feedback, CellConstants.STRETCH, CellConstants.FILL);
 		}
+		mC.setHotKey(0, IKeys.ESCAPE);
 		this.addNext(mC, CellConstants.STRETCH, CellConstants.FILL);
+		mB.setHotKey(0, IKeys.ACTION);
+		mB.setHotKey(0, IKeys.ENTER);
 		this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
 	}
 	

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-01-10 20:52:24 UTC (rev 377)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-01-10 22:52:43 UTC (rev 378)
@@ -49,8 +49,13 @@
 			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
 		}
 
-		this.addNext(cancelB = new mButton(MyLocale.getMsg(1604,"Cancel")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(okB = new mButton(MyLocale.getMsg(1605,"OK")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okB = new mButton(MyLocale.getMsg(1605,"OK"));
+		okB.setHotKey(0, IKeys.ACTION);
+		okB.setHotKey(0, IKeys.ENTER);
+		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 	}
 	public void onEvent(Event ev){
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-01-10 20:52:24 UTC (rev 377)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-10 22:52:43 UTC (rev 378)
@@ -65,7 +65,7 @@
 		} else return code;
 		infB.close(0);
 		infB = new InfoBox("Status", "Logging in...");
-		infB.show();
+		infB.exec();
 		try{
 			pref.log("Fetching login page");
 			start = fetch("http://www.geocaching.com/login/Default.aspx");

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-10 20:52:24 UTC (rev 377)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-10 22:52:43 UTC (rev 378)
@@ -71,15 +71,22 @@
 			SpiderGC spider = new SpiderGC(pref, profile);
 			Vm.showWait(true);
 			spider.login();
-			//TODO pr?fen, ob es sich um ein gc oder oc cache handelt. Aber wie?
+			boolean alreadySaid = false;
 			for(int i = 0; i <	db.size(); i++){
 				ch = (CacheHolder)db.get(i);
 				if(ch.is_Checked == true) {
-					spider.spiderSingle(i);
+					if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC"))
+							|| (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC")) ) 
+					{
+						spider.spiderSingle(i);
+					} else if (!alreadySaid) {
+						alreadySaid = true;
+						(new MessageBox("Information","Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
+					}
 				}
 			}
+			tbp.refreshTable();
 			Vm.showWait(false);
-			tbp.refreshTable();
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1019,"Center"))){
 			CacheHolder thisCache = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());



From admin at berlios.de  Thu Jan 11 00:45:34 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 11 Jan 2007 00:45:34 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9930] SpiderGC: <Enter> im Passworteingabe
Message-ID: <200701102345.l0ANjYT6023934@unicorn.berlios.de>

Bug #9930, was updated on 2007-Jan-10 23:39
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: pfeffer
Assigned to : pfeffer
Summary: SpiderGC: <Enter> im Passworteingabe

Details: beim SpiderGC <Enter> im Passworteingabe bewirkte abbruch, jetzt sind <enter> und <ESC> f?r die Richtigen Buttons aktiviert

Follow-Ups:

Date: 2007-Jan-11 00:45
By: pfeffer

Comment:
erledigt mit svn: 378
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9930&group_id=2211


From pfeffer at mail.berlios.de  Thu Jan 11 00:47:06 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 11 Jan 2007 00:47:06 +0100
Subject: [Cachewolf-svn] r379 - trunk/src/CacheWolf
Message-ID: <200701102347.l0ANl64l030226@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-11 00:47:02 +0100 (Thu, 11 Jan 2007)
New Revision: 379

Modified:
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
erldeigt:  Feature Request #3031 ] Doppelklick in der Cacheliste

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-10 22:52:43 UTC (rev 378)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-10 23:47:02 UTC (rev 379)
@@ -50,7 +50,18 @@
 */		
 		addLast(new ScrollBarPanel(tc = new myTableControl()));
 		if (statBar!=null) addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		Menu m = new Menu(new String[]{MyLocale.getMsg(1010,"Goto"),MyLocale.getMsg(1019,"Center"),"-",MyLocale.getMsg(1011,"Filter"),MyLocale.getMsg(1012,"Delete"),MyLocale.getMsg(1014,"Update"),"-",MyLocale.getMsg(1015,"Select all"),MyLocale.getMsg(1016,"De-select all")},MyLocale.getMsg(1013,"With selection"));
+		Menu m = new Menu(new String[]{
+				MyLocale.getMsg(1021,"Open desription"),
+				MyLocale.getMsg(1010,"Goto"),
+				MyLocale.getMsg(1019,"enter"),
+				MyLocale.getMsg(1020,"open in $browser online"),
+				"-",
+				MyLocale.getMsg(1011,"Filter"),
+				MyLocale.getMsg(1012,"Delete"),
+				MyLocale.getMsg(1014,"Update"),
+				"-",
+				MyLocale.getMsg(1015,"Select all"),
+				MyLocale.getMsg(1016,"De-select all")},MyLocale.getMsg(1013,"With selection"));
 		tc.setMenu(m);
 		tc.profile=profile;
 		tc.db = cacheDB;

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-10 22:52:43 UTC (rev 378)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-10 23:47:02 UTC (rev 379)
@@ -102,40 +102,45 @@
 		}
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1010,"Goto"))){
-//			Point a = new Point();
-	//		a = this.getSelectedCell(a);
-		//	if(!(a == null)) ch = (CacheHolder)tbp.cacheDB.get(a.y);
 			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
-			
 			tbp.myGotoPanel.setDestination((ch.LatLon));
-//this.getSelectedCell(((Menu)selectedItem).curPoint)..LatLon
 		}
+		if (selectedItem.toString().equalsIgnoreCase(MyLocale.getMsg(1020,"Open online in Browser"))){
+			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
+			try{
+				ch.readCache(profile.dataDir);
+			}catch(IOException ex){	(new MessageBox("Error", "Cannot read cache data\n"+ex.toString()+"\n in cache: "+ch.wayPoint,MessageBox.OKB)).execute(); }
+			try {
+				String cmd = "\""+pref.browser+ "\" " + ch.URL;
+				Vm.exec(cmd);
+			} catch (IOException ex) {
+				(new MessageBox("Error", "Cannot start browser!\n"+ex.toString()+"\nThe are two possible reasons:\n * path to internet browser in \npreferences not correct\n * An bug in ewe VM, please be \npatient for an update",MessageBox.OKB)).execute();
+			}
+		}
+		if (selectedItem.toString().equalsIgnoreCase(MyLocale.getMsg(1021,"Open description"))){
+			openCacheDesc();
+		}
 
 	}
 	
-	public void  penDoubleClicked(Point where) {
-		Point a = new Point();
-		Point dest = new Point();
-		a = getSelectedCell(dest);
-		CacheHolder ch;
+	void openCacheDesc() {
+//		Point a = new Point();
+		//	Point dest = new Point();
+			//a = getSelectedCell(dest);
+			CacheHolder ch;
+			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
 
-		ch = (CacheHolder)db.get(a.y);
-		try{
-			//String cmd = "\""+pref.browser+ "\"" + " \"http://www.geocaching.com/seek/cache_details.aspx?wp="+ch.wayPoint+"&Submit6=Find&log=y\"";
-			ch.readCache(profile.dataDir);
-		}catch(IOException ex){	(new MessageBox("Error", "Cannot read cache data\n"+ex.toString()+"\n in cache: "+ch.wayPoint,MessageBox.OKB)).execute(); }
-		try {
-			String cmd = "\""+pref.browser+ "\" " + ch.URL;
-			//String cmd = "\""+pref.browser+ ".exe\"" + " www.aragorn.de";
-			//Vm.debug(cmd);
-			//ewe.sys.Process p =
-			
-			Vm.exec(cmd);
-			//p.waitFor();
-		} catch (IOException ex) {
-			Vm.debug("Cannot start browser - opening description panel instead (" +ex.toString()+")");
-			//(new MessageBox("Error", "Cannot start browser!\n"+ex.toString()+"\nThe are two possible reasons:\n * path to internet browser in \npreferences not correct\n * An bug in ewe VM, please be \npatient for an update",MessageBox.OKB)).execute();
+		//	ch = (CacheHolder)db.get(a.y);
+			try{
+				ch.readCache(profile.dataDir);
+			}catch(IOException ex){	
+				(new MessageBox("Error", "Cannot read cache data\n"+ex.toString()+"\n in cache: "+ch.wayPoint,MessageBox.OKB)).execute(); 
+			}
 			tbp.myMaintab.select(tbp.myMaintab.descP);
-		}
+		
 	}
+	
+	public void  penDoubleClicked(Point where) {
+		openCacheDesc();
+	}
 }



From admin at berlios.de  Thu Jan 11 00:48:49 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 11 Jan 2007 00:48:49 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3031] Doppelklick in der Cacheliste
Message-ID: <200701102348.l0ANmnwq024006@unicorn.berlios.de>

Feature Request #3031, was updated on 2007-Jan-09 01:58
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Doppelklick in der Cacheliste 

By: pfeffer
Date: 2007-Jan-11 00:48

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

erldigt gem??t absprache im ersten Posting verlinken Forum
mit SVN: 379

Gru?,
  Pfeffer.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-09 03:19

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

mit SVN 368: Wenn Browserstart nicht klappt, dann wird
BeschreibungsPanel ge?ffnet.

F?r Offline-Browser-Anzeige f?hle ich micht nicht zust?ndig,
kenne mich mit den Exportern nicht aus.

Gru?,
  Pfeffer.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211


From admin at berlios.de  Thu Jan 11 05:14:39 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 11 Jan 2007 05:14:39 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2987] /maps Verzeichnis
Message-ID: <200701110414.l0B4EdD4026474@unicorn.berlios.de>

Feature Request #2987, was updated on 2006-Dec-21 17:39
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: /maps Verzeichnis

By: pfeffer
Date: 2007-Jan-11 05:14

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

so, jetzt kann man durch klick auf die gelben Streifen links
oben in der Ecke der MovingMap ein vom Standardverzeichnis
abweichendes w?hlen. (SVN: 380)
Zweck: ein Verzeichnis f?r GoogleEarth-Karten, ein anderes
f?r Karten aus TK50 der Landesvermessungs?mter o.?.

Gru?,
  Pfeffer.

----------------------------------------------------------------------

By: salzkammergut
Date: 2007-Jan-09 13:40

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Du hast nat?rlich recht, Pfeffer. Ich bin kurz einer
geistigen Umnachtung erlegen als ich schrieb
   Global.getProfile().dataDir
Habe (wie Du richtig erkannt hast)
   Global.getPref().baseDir
gemeint.

Gr??e
salzkammergut


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211


From admin at berlios.de  Thu Jan 11 12:14:30 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 11 Jan 2007 02:14:30 -0900 (AKST)
Subject: [Cachewolf-svn] [Feature #3039] Export TomTom OV2
Message-ID: <200701111114.l0BBEULt008048@unicorn.berlios.de>

Feature Request #3039, was updated on 2007-Jan-11 02:14
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3039&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Export TomTom OV2

By: cw-tester
Date: 2007-Jan-11 02:14

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

im Moment werden die Caches in Kategorien
(GC-Multi;GC-Traditional etc.) exportiert. Da ich ?fter
mehrere Zielorte entsprechend der Profile(bzw. einer
Selektion davon)  auf meinem PDA speichere, habe ich
mit der momentanen L?sung ein Problem.
Es sollte hier die M?glichkeit geben einen Dateinamen
vorzugeben.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3039&group_id=2211


From pfeffer at mail.berlios.de  Thu Jan 11 05:13:19 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 11 Jan 2007 05:13:19 +0100
Subject: [Cachewolf-svn] r380 - in trunk: resources src/CacheWolf
Message-ID: <200701110413.l0B4DJoW022562@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-11 05:13:15 +0100 (Thu, 11 Jan 2007)
New Revision: 380

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/myTableControl.java
Log:
realisiert: [ Feature Request #2987 ] /maps Verzeichnis
kleinere Fehler in MovingMap behoben

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-10 23:47:02 UTC (rev 379)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-11 04:13:15 UTC (rev 380)
@@ -170,14 +170,16 @@
 		1007=Status
 		1008=Entf
 		1009=Peil
-		1010=Gehe zu
-		1011=Filter
-		1012=L%f6schen
+		1010=Gehe zu diesem
+		1011=Nichtmarkierte ausfiltern
+		1012=Markierte l%f6schen
 		1013=Auswahl
-		1014=Aktualisieren
+		1014=Markierte aktualisieren
 		1015=Alle w%e4hlen
 		1016=Alle abw%e4hlen
-		1019=Zentrum
+		1019=Diesen als Zentrum setzen
+		1020=Im Browser online %f6ffnen
+		1021=Beschreibung %f6ffnen
 		1100=Profile
 		1101=Profil 1
 		1102=Profil 2
@@ -252,6 +254,7 @@
 		4109=Lade Karten...
 		4110=Lade
 		4111=Koordinaten m%fcssen in dem Format N XX XX,XXX E XXX XX,XXX eingegeben werden
+		4200=Kartenverzeichnis w%e4hlen
 		4500=Ges:
 		4501=Gez:
 		4502=Gef:
@@ -422,14 +425,16 @@
 		1007=Status
 		1008=Dist
 		1009=Bear
-		1010=Goto
-		1011=Filter
-		1012=Delete
+		1010=Goto this one
+		1011=filter out non-selected
+		1012=Delete selected
 		1013=With selection
-		1014=Update
+		1014=Update cache data
 		1015=Select all
-		1016=De-select all
-		1019=Center
+		1016=Deselect all
+		1019=Set this as center
+		1020=Open online in Browser
+		1021=Open cache description
 		1100=Profiles
 		1101=Profile 1
 		1102=Profile 2
@@ -503,6 +508,7 @@
 		4109=Loading maps...
 		4110=loading
 		4111=Coordinates must be entered in the format N XX XX.XXX E XXX XX.XXX
+		4200=Choose map directory
 		{..}
 	{..}
 {..}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-10 23:47:02 UTC (rev 379)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-11 04:13:15 UTC (rev 380)
@@ -5,19 +5,20 @@
 import ewe.io.File;
 import ewe.io.IOException;
 import ewe.sys.*;
+import ewe.filechooser.FileChooser;
 import ewe.fx.*;
 import ewe.util.Vector;
 
 /**
-*	Class to handle a moving map.
-*/
+ *	Class to handle a moving map.
+ */
 public class MovingMap extends Form {
 	final static int gotFix = 4; //green
 	final static int lostFix = 3; //yellow
 	final static int noGPSData = 2; // red
 	final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
 	final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
-	
+
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
@@ -32,7 +33,7 @@
 	AniImage statusImageHaveSignal = new AniImage("position_green.png");
 	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
 	AniImage statusImageNoGps = new AniImage("position_red.png");
-	
+
 	AniImage ButtonImageChooseMap = new AniImage("choose_map.gif"); 
 	AniImage ButtonImageGpsOn = new AniImage("snap2gps.gif"); 
 	/*AniImage arrowUp = new AniImage("arrow_up.png");
@@ -42,12 +43,13 @@
 	AniImage posCircle = new AniImage("position_green.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
-	
+
 	boolean ignoreGps = false;
 	boolean ignoreGpsStatutsChanges = false;
 	boolean autoSelectMap = true;
 	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
-	
+	CWPoint lastUpatePosition = new CWPoint();
+
 	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
 		this.cacheDB = cacheDB;
 		gotoPanel = gP;
@@ -64,7 +66,7 @@
 		ButtonImageChooseMap.properties = AniImage.AlwaysOnTop;
 		ButtonImageGpsOn.setLocation(pref.myAppWidth-25, 10);
 		ButtonImageGpsOn.properties = AniImage.AlwaysOnTop;
-/*		arrowUp.setLocation(pref.myAppWidth/2, 10);
+		/*		arrowUp.setLocation(pref.myAppWidth/2, 10);
 		arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
 		arrowLeft.setLocation(10, pref.myAppHeight/2+7);
 		arrowRight.setLocation(pref.myAppWidth-25, pref.myAppHeight/2+7);
@@ -76,25 +78,24 @@
 		mmp.addImage(arrowDown);
 		mmp.addImage(arrowLeft);
 		mmp.addImage(arrowRight);
-*/		mmp.addImage(ButtonImageChooseMap);
-		mmp.addImage(ButtonImageGpsOn);
-		posCircle.properties = AniImage.AlwaysOnTop;
-		loadMaps();
+		 */		mmp.addImage(ButtonImageChooseMap);
+		 mmp.addImage(ButtonImageGpsOn);
+		 posCircle.properties = AniImage.AlwaysOnTop;
+		 loadMaps(Global.getPref().baseDir+"maps/standard/");
 	}
 
 	/**
 	 * loads the list of maps
 	 *
 	 */
-	public void loadMaps(){
+	public void loadMaps(String mapsPath){
 		Vm.showWait(true);
 		resetCenterOfMap();
 		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
 		inf.exec();
-		maps = new Vector();
+		maps = new Vector(); // forget already loaded maps
+		//if (mmp.mapImage != null) 
 		String dateien[];
-		String mapsPath = new String();
-		mapsPath = Global.getPref().baseDir+"maps/standard";
 		File files = new File(mapsPath);
 		Extractor ext;
 		String rawFileName = new String();
@@ -124,6 +125,12 @@
 		inf.close(0);
 		Vm.showWait(false);
 	}
+
+	public void forceMapLoad() {
+		forceMapLoad = true;
+		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec);
+	}
+
 	public final FormFrame myExec() {
 		addOverlaySet(); // neccessary to draw points which were added when the MovingMap was not running, so that these pixels are not stored in the not-immediately-drawing-work-around
 		return exec();
@@ -135,7 +142,7 @@
 		tracks.add(tr);
 		addOverlaySet();
 	}
-	
+
 	public void addTracks(Track[] trs) {
 		if (trs==null || trs.length == 0) return;
 		for (int i=0; i<trs.length; i++) {
@@ -143,22 +150,22 @@
 		}
 		addOverlaySet();
 	}
-	
+
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
 	 * 
 	 * add tracks with addtrack(track) before
 	 */
-	
+
 	public void addOverlaySet() {
-		if (tracks == null) return; // no tracks
+		//if (tracks == null) return; // no tracks
 		if (TrackOverlays != null) {
 			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
 		}
 		addMissingOverlays();
 	}
-	
 
+
 	public void addMissingOverlays() {
 		Point upperleft = getMapXYPosition();
 		int ww = pref.myAppWidth;
@@ -170,7 +177,7 @@
 				i = yi*3+xi;
 				if (TrackOverlays[i]==null) { 
 					TrackOverlays[i]= new TrackOverlay(currentMap.calcLatLon(-upperleft.x+(xi-1)*ww, -upperleft.y+(yi-1)*wh), ww, wh, currentMap); 
-					TrackOverlays[i].setLocation(0, 0);
+					TrackOverlays[i].move(0, 0);
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -179,7 +186,7 @@
 		}
 		updateOverlayOnlyPos();
 	}
-	
+
 	private void destroyOverlay(int ov) {
 		if (TrackOverlays[ov] == null) return; 
 		mmp.removeImage(TrackOverlays[ov]);
@@ -277,7 +284,7 @@
 									}else
 										for (int i=0; i<TrackOverlays.length; i++) {destroyOverlay(i);} // this happens if a position jump occured
 								}}}}}}} // close all IFs
-			Vm.debug("Overlayrearanged"+TrackOverlays.toString());
+		Vm.debug("Overlayrearanged"+TrackOverlays.toString());
 	}
 
 	public void ShowLastAddedPoint(Track tr) {
@@ -292,561 +299,622 @@
 		//	Point upperleft = getMapXYPosition();
 		Point posOnScreen;
 		posOnScreen = getXYinMap(TrackOverlays[4].topLeft.latDec, TrackOverlays[4].topLeft.lonDec);
-		int ww = pref.myAppWidth;
-		int wh = pref.myAppHeight;
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
 		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
 		for (int yi=0; yi<3; yi++) {
 			for (int xi=0; xi<3; xi++) {
-		//		if( (TrackOverlays[yi*3+xi].properties & AniImage.HasChanged) != 0) TrackOverlays[yi*3+xi].draw.r
-				TrackOverlays[yi*3+xi].move(posOnScreen.x+(xi-1)*ww, posOnScreen.y+(yi-1)*wh);
+				if (posOnScreen.x +ww >=0 && posOnScreen.x <= ww && posOnScreen.y + wh >=0 && posOnScreen.y <= wh)
+				{
+					TrackOverlays[yi*3+xi].properties &= ~mImage.IsInvisible;
+					TrackOverlays[yi*3+xi].move(posOnScreen.x+(xi-1)*ww, posOnScreen.y+(yi-1)*wh);
+				} else {
+					TrackOverlays[yi*3+xi].properties |= mImage.IsInvisible;
+					TrackOverlays[yi*3+xi].move(30, 30);
+				}
 			}
 		}
 	}
-	
-	public void updateOverlayPos() {
-		if (TrackOverlays == null) return;
-		updateOverlayOnlyPos();
-		if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
-				TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
-			rearangeOverlays();
-			addMissingOverlays();
-			// updateOverlayOnlyPos(); is called from addMissingOverlays 
+
+		public void updateOverlayPos() {
+			if (TrackOverlays == null) return;
+			updateOverlayOnlyPos();
+			if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
+					TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
+				rearangeOverlays();
+				addMissingOverlays();
+				// updateOverlayOnlyPos(); is called from addMissingOverlays 
+			}
 		}
-	}
 
-	private int getBestMap(double lat, double lon) { // finds the map which is next (center of the map) to the gps-position / could be a good idea to seachr only maps which show the current position (use InBound)
-		// maps, gotoPanel.gpsPosition.latDec != 0, gotoPanel.gpsPosition
-		MapInfoObject mi = new MapInfoObject();
-		MapInfoObject bestMap = new MapInfoObject();
-		double minDistLat = 1000000000000000000000000000000000000000000000.0;
-		double minDistLon = 1000000000000000000000000000000000000000000000.0;
-		boolean latNearer, lonNearer;
-		int minDistMap = -1;
-		boolean better = false;
-		for (int i=0; i<maps.size() ;i++) {
-			better = false;
-			mi=(MapInfoObject)maps.get(i);
-			latNearer=java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
-			lonNearer=java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
-			if ( latNearer && lonNearer) better = true;
-			if ( !better && (latNearer || lonNearer )) { 
-				if ( mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
-					}
-			if (better) {
-				minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
-				minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
-				minDistMap = i;
-				bestMap = mi;
-				// Vm.debug("better"+ i);
+		private int getBestMap(double lat, double lon) { // finds the map which is next (center of the map) to the gps-position / could be a good idea to seachr only maps which show the current position (use InBound)
+			// maps, gotoPanel.gpsPosition.latDec != 0, gotoPanel.gpsPosition
+			MapInfoObject mi = new MapInfoObject();
+			MapInfoObject bestMap = new MapInfoObject();
+			double minDistLat = 1000000000000000000000000000000000000000000000.0;
+			double minDistLon = 1000000000000000000000000000000000000000000000.0;
+			boolean latNearer, lonNearer;
+			int minDistMap = -1;
+			boolean better = false;
+			for (int i=0; i<maps.size() ;i++) {
+				better = false;
+				mi=(MapInfoObject)maps.get(i);
+				latNearer=java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+				lonNearer=java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+				if ( latNearer && lonNearer) better = true;
+				if ( !better && (latNearer || lonNearer )) { 
+					if ( mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+				}
+				if (better) {
+					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+					minDistMap = i;
+					bestMap = mi;
+					// Vm.debug("better"+ i);
+				}
 			}
+			//	tmp = secBestMap.center.getDistance(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.lonDec)/secBestMap.sizeKm; // quasi second return value 
+			return minDistMap ;
 		}
-	//	tmp = secBestMap.center.getDistance(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.lonDec)/secBestMap.sizeKm; // quasi second return value 
-		return minDistMap ;
-	}
-	
-	
-	
-	public void resetCenterOfMap() {
-		posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-		posCircleY = pref.myAppHeight/2;
-		posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
-	}
 
-	/**
-	 * get upper left corner of map on window
-	 * returns the same as mmp.mapImage.getLocation(mapPos);
-	 * but also works if mmp == null and is used to move the map to the correct point
-	 * @return
-	 */
-	public Point getMapXYPosition() {
-		Point mapPos = new Point(); 
-		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-		//else {
+
+
+		public void resetCenterOfMap() {
+			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight/2;
+			posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
+		}
+
+		/**
+		 * get upper left corner of map on window
+		 * returns the same as mmp.mapImage.getLocation(mapPos);
+		 * but also works if mmp == null and is used to move the map to the correct point
+		 * @return
+		 */
+		public Point getMapXYPosition() {
+			Point mapPos = new Point(); 
+			//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+			//else {
 			Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
 			mapPos.x = posCircleX - mapposint.x;
 			mapPos.y = posCircleY - mapposint.y;
-		//}
-		return mapPos;
-	}
+			//}
+			return mapPos;
+		}
 
-	public Point getXYinMap(double lat, double lon){
-		Point coords = new Point();
-		Point mapPos = new Point();
-		coords = currentMap.calcMapXY(lat, lon);
-		mapPos = getMapXYPosition();
-	//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
-		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
-	}
-	
-	public void updateSymbolPositions() {
-		if (symbols == null) return;
-		Point pOnScreen;
-		MapSymbol symb;
-		for (int i=symbols.size()-1; i>=0; i--) {
-			symb = (MapSymbol)symbols.get(i);
-			pOnScreen = getXYinMap(symb.lat, symb.lon);
-			symb.pic.setLocation(pOnScreen.x-symb.pic.getWidth()/2, pOnScreen.y-symb.pic.getHeight()/2);
+		public Point getXYinMap(double lat, double lon){
+			Point coords = currentMap.calcMapXY(lat, lon);
+			Point mapPos = getMapXYPosition();
+			//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
+			return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 		}
-	}
-	
-	public void addSymbol(String name, String filename, double lat, double lon) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
-		ms.loadImage();
-		Point pOnScreen=getXYinMap(lat, lon);
-		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
-		symbols.add(ms);
-		mmp.addImage(ms.pic);
-	}
-	public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, " ", lat, lon);
-		ms.pic = imSymb;
-		ms.pic.properties = AniImage.AlwaysOnTop;
-		Point pOnScreen=getXYinMap(lat, lon);
-		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
-		symbols.add(ms);
-		mmp.addImage(ms.pic);
-	}
-	
-	public void setGotoPosition(double lat, double lon) {
-		removeMapSymbol("goto");
-		addSymbol("goto", "goto_map.png", lat, lon); 
-	}
-	
-	public CWPoint getGotoPos(){
-		int symbNr;
-		symbNr = findMapSymbol("goto");
-		if (symbNr == -1) return null;
-		MapSymbol ms = (MapSymbol) symbols.get(symbNr);
-		return new CWPoint(ms.lat, ms.lon);
-	}
-	
-	public void removeAllMapSymbolsButGoto(){
-		for (int i=symbols.size()-1; i>=0; i--) {
-			if (((MapSymbol)symbols.get(i)).name != "goto") removeMapSymbol(i);
+
+		public void updateSymbolPositions() {
+			if (symbols == null) return;
+			Point pOnScreen;
+			MapSymbol symb;
+			Dimension ws = mmp.getSize(null);
+			int ww = ws.width;
+			int wh = ws.height;
+			int w, h;
+			for (int i=symbols.size()-1; i>=0; i--) {
+				symb = (MapSymbol)symbols.get(i);
+				pOnScreen = getXYinMap(symb.lat, symb.lon);
+				w=symb.pic.getWidth();
+				h=symb.pic.getHeight();
+				if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
+				{
+					symb.pic.properties &= ~mImage.IsInvisible;
+					symb.pic.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+				}
+				else 
+				{symb.pic.properties |= mImage.IsInvisible;
+				symb.pic.move(30, 30);
+				}
+				//symb.pic.move(ww+1, wh+1);
+			}
 		}
-	}
-	
-	public void removeMapSymbol(String name) {
-		int symbNr = findMapSymbol(name);
-		if (symbNr != -1) removeMapSymbol(symbNr);
-	}
 
-	public void removeMapSymbol(int SymNr) {
-		mmp.removeImage(((MapSymbol)symbols.get(SymNr)).pic);
-		symbols.removeElementAt(SymNr);
-	}
+		public void addSymbol(String name, String filename, double lat, double lon) {
+			if (symbols==null) symbols=new Vector();
+			MapSymbol ms = new MapSymbol(name, filename, lat, lon);
+			ms.loadImage();
+			Point pOnScreen=getXYinMap(lat, lon);
+			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+			symbols.add(ms);
+			mmp.addImage(ms.pic);
+		}
+		public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
+			if (symbols==null) symbols=new Vector();
+			MapSymbol ms = new MapSymbol(name, " ", lat, lon);
+			ms.pic = imSymb;
+			ms.pic.properties = AniImage.AlwaysOnTop;
+			Point pOnScreen=getXYinMap(lat, lon);
+			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+			symbols.add(ms);
+			mmp.addImage(ms.pic);
+		}
 
-	public int findMapSymbol(String name) {
-		if (symbols == null) return -1;
-		MapSymbol ms;
-		for (int i = 0; i < symbols.size(); i++) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == name) return i;
+		public void setGotoPosition(double lat, double lon) {
+			removeMapSymbol("goto");
+			addSymbol("goto", "goto_map.png", lat, lon); 
 		}
-		return -1;
-	}
 
-	/**
-	* Move the map so that the posCircle is at lat/lon
-	* 
-	* @param lat && lon == -361 -> ignore lat/lon, set map position to upperleft corner of window 
-	*/
-	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
-		Point mapPos = new Point(0,0);
-		Point oldMapPos = getMapXYPosition();
-		if (lat != -361.0 || lon != -361.0) {
-			posCircleLat = lat;
-			posCircleLon = lon;
-			mapPos = getMapXYPosition();
+		public CWPoint getGotoPos(){
+			int symbNr;
+			symbNr = findMapSymbol("goto");
+			if (symbNr == -1) return null;
+			MapSymbol ms = (MapSymbol) symbols.get(symbNr);
+			return new CWPoint(ms.lat, ms.lon);
 		}
-		//Vm.debug("mapx = " + mapx);
-		//Vm.debug("mapy = " + mapy);
-		if (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1) {
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
-			updateSymbolPositions();
-			if (updateOverlay && TrackOverlays != null) updateOverlayPos();
-		//}
-		mmp.repaintNow(); // TODO test if the "if" above can be used
+
+		public void removeAllMapSymbolsButGoto(){
+			for (int i=symbols.size()-1; i>=0; i--) {
+				if (((MapSymbol)symbols.get(i)).name != "goto") removeMapSymbol(i);
+			}
 		}
-		//Vm.debug("update only position");			
-	}
-	/**
-	* Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
-	*/
-	public void updatePosition(double lat, double lon){
-		if(!ignoreGps){
-			updateOnlyPosition(lat, lon, true);
-			if (autoSelectMap) {
-				Point mapPos = getMapXYPosition();
-				if (forceMapLoad || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
-					|| 	mmp.mapImage == null )) 	{
-					forceMapLoad = false;
-					//Vm.debug("Screen not completly covered by map");
-					if (java.lang.Math.abs(lastCompareX-mapPos.x) > MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > MyLocale.getScreenHeight()/10) {
-						// more then 1/10 of screen moved since last time we tried to find a better map
-						lastCompareX = mapPos.x;
-						lastCompareY = mapPos.y;
-//						Vm.debug("look for a bettermap");
-						int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -> may be it would be better to call it with the coos of the center of the window?, nein, es k?nnte st?ren, wenn man manuell die Karte bewegt und er st?ndig ne neue l?d... bleibt erstmal so
-						MapInfoObject newmap ;
-						newmap = (MapInfoObject) maps.get(newMapN);
-						if (!(currentMap.mapName == newmap.mapName)) {
-							setMap(newmap, lat, lon);
-//							Vm.debug("better map found");
-							// use new map
+
+		public void removeMapSymbol(String name) {
+			int symbNr = findMapSymbol(name);
+			if (symbNr != -1) removeMapSymbol(symbNr);
+		}
+
+		public void removeMapSymbol(int SymNr) {
+			mmp.removeImage(((MapSymbol)symbols.get(SymNr)).pic);
+			symbols.removeElementAt(SymNr);
+		}
+
+		public int findMapSymbol(String name) {
+			if (symbols == null) return -1;
+			MapSymbol ms;
+			for (int i = 0; i < symbols.size(); i++) {
+				ms= (MapSymbol)symbols.get(i);
+				if (ms.name == name) return i;
+			}
+			return -1;
+		}
+
+		/**
+		 * Move the map so that the posCircle is at lat/lon
+		 * 
+		 * @param lat && lon == -361 -> ignore lat/lon, set map position to upperleft corner of window 
+		 */
+		public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
+			Point mapPos = new Point(0,0);
+			Point oldMapPos = getMapXYPosition();
+			if (lat != -361.0 || lon != -361.0) {
+				posCircleLat = lat;
+				posCircleLon = lon;
+				mapPos = getMapXYPosition();
+			}
+			//Vm.debug("mapx = " + mapx);
+			//Vm.debug("mapy = " + mapy);
+			if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
+				if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
+				updateSymbolPositions();
+				if (updateOverlay && TrackOverlays != null) updateOverlayPos();
+				//}
+				mmp.repaintNow(); // TODO test if the "if" above can be used
+			}
+			//Vm.debug("update only position");			
+		}
+		/**
+		 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+		 */
+		public void updatePosition(double lat, double lon){
+			lastUpatePosition.latDec=lat;
+			lastUpatePosition.lonDec=lon;
+			if(!ignoreGps || forceMapLoad){
+				updateOnlyPosition(lat, lon, true);
+				if (autoSelectMap || forceMapLoad) {
+					Point mapPos = getMapXYPosition();
+					if (forceMapLoad || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
+							|| 	mmp.mapImage == null )) 	{
+						//Vm.debug("Screen not completly covered by map");
+						if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > MyLocale.getScreenHeight()/10)) {
+							// more then 1/10 of screen moved since last time we tried to find a better map
+							lastCompareX = mapPos.x;
+							lastCompareY = mapPos.y;
+//							Vm.debug("look for a bettermap");
+							int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -> may be it would be better to call it with the coos of the center of the window?, nein, es k?nnte st?ren, wenn man manuell die Karte bewegt und er st?ndig ne neue l?d... bleibt erstmal so
+							MapInfoObject newmap ;
+							newmap = (MapInfoObject) maps.get(newMapN);
+							if (!(currentMap.mapName == newmap.mapName)) {
+								setMap(newmap, lat, lon);
+								Vm.debug("better map found");
+								// use new map
+							}
+							forceMapLoad = false;
 						}
 					}
 				}
 			}
 		}
-	}
 
-	public void setGpsStatus (int status) {
-		if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
-		GpsStatus = status;
-		ignoreGps = false;
-		switch (status) {
-		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		public void setGpsStatus (int status) {
+			if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+			GpsStatus = status;
+			ignoreGps = false;
+			switch (status) {
+			case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+			case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
+			case lostFix:   { posCircle.change(statusImageNoSignal); break; }
+			case noGPSData: { posCircle.change(statusImageNoGps); break; }
+			}
+			posCircle.refreshNow();
 		}
-		posCircle.refreshNow();
-	}
-	
-	public void SnapToGps() {
-		resetCenterOfMap();
-		ignoreGps = false;
-		ignoreGpsStatutsChanges = false;
-		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-		lastCompareY = Integer.MAX_VALUE;
-		autoSelectMap = true;
-		forceMapLoad = true;
-//		updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
-	}
 
-	/** sets and displays the map
-	 * 
-	 * @param newmap
-	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
-	 * @param lon -361: don't adust to lat/lon
-	 */
-	public void setMap(MapInfoObject newmap, double lat, double lon) {
-		if (newmap.mapName == currentMap.mapName) {
-			updateOnlyPosition(lat, lon, true); 
-			return;
-		}
-		Vm.showWait(true);
-		boolean saveIgnoreStatus;
-		saveIgnoreStatus = ignoreGps;
-		ignoreGps = true;  // make updatePosition ignore calls during loading new map
-		InfoBox inf;
-		inf = new InfoBox("Info", "Loading map...");
-		inf.show();
-		try {
-			this.currentMap = newmap; 
-			this.title = currentMap.mapName;
-//transXlat
-			
+		public void SnapToGps() {
+			resetCenterOfMap();
+			ignoreGps = false;
+			ignoreGpsStatutsChanges = false;
 			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 			lastCompareY = Integer.MAX_VALUE;
-			if (! (mmp.mapImage == null) ) {
-				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
-				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null;
-				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
-				Vm.getUsedMemory(true); // calls the garbage collection
+			autoSelectMap = true;
+			forceMapLoad = true;
+//			updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
+		}
+
+		/** sets and displays the map
+		 * 
+		 * @param newmap
+		 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
+		 * @param lon -361: don't adust to lat/lon
+		 */
+		public void setMap(MapInfoObject newmap, double lat, double lon) {
+			if (newmap.mapName == currentMap.mapName) {
+				updateOnlyPosition(lat, lon, true); 
+				return;
+			}
+			Vm.showWait(true);
+			boolean saveIgnoreStatus;
+			saveIgnoreStatus = ignoreGps;
+			ignoreGps = true;  // make updatePosition ignore calls during loading new map
+			InfoBox inf;
+			inf = new InfoBox("Info", "Loading map...");
+			inf.show();
+			try {
+				this.currentMap = newmap; 
+				this.title = currentMap.mapName;
+//				transXlat
+
+				lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+				lastCompareY = Integer.MAX_VALUE;
+				if (! (mmp.mapImage == null) ) {
+					//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+					mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null;
+					//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+					Vm.getUsedMemory(true); // calls the garbage collection
 				} // give memory free before loading the new map to avoid out of memory error  
-			if (currentMap.fileName.length()>0) mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
-			else mmp.mapImage = new AniImage();
-			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable; 
-			mmp.mapImage.move(0,0);
-			mmp.addImage(mmp.mapImage);
-			mmp.images.moveToBack(mmp.mapImage);
-			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
-			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
-			Vm.showWait(false);
-			ignoreGps = saveIgnoreStatus;
-		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
-			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
-				mmp.mapImage.free();
-				mmp.mapImage = null;
+				if (currentMap.fileName.length()>0) mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new AniImage();
+				mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable; 
+				mmp.mapImage.move(0,0);
+				mmp.addImage(mmp.mapImage);
+				mmp.images.moveToBack(mmp.mapImage);
+				addOverlaySet();
+				forceMapLoad = true; // forces updateOnlyPosition to redraw
+				updateOnlyPosition(lat, lon, false);
+				forceMapLoad = false;
+				inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
+				Vm.showWait(false);
+				ignoreGps = saveIgnoreStatus;
+			} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
+				if (mmp.mapImage != null) {
+					mmp.removeImage(mmp.mapImage); 
+					mmp.mapImage.free();
+					mmp.mapImage = null;
+				}
+				addOverlaySet();
+				updateOnlyPosition(lat, lon, false);
+				inf.close(0);
+				Vm.showWait(false);
+				(new MessageBox("Error", "Could not load map: "+ newmap.fileName, MessageBox.OKB)).execute();
+				ignoreGps = saveIgnoreStatus;
+			} catch (OutOfMemoryError e) {
+				if (mmp.mapImage != null) {
+					mmp.removeImage(mmp.mapImage); 
+					mmp.mapImage.free();
+					mmp.mapImage = null;
+				}
+				addOverlaySet();
+				updateOnlyPosition(lat, lon, false);
+				inf.close(0);
+				Vm.showWait(false);
+				(new MessageBox("Error", "Not enough memory to load map: "+ newmap.fileName+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+				ignoreGps = saveIgnoreStatus;
+			}catch (SystemResourceException e) {
+				if (mmp.mapImage != null) {
+					mmp.removeImage(mmp.mapImage); 
+					mmp.mapImage.free();
+					mmp.mapImage = null;
+				}
+				addOverlaySet();
+				updateOnlyPosition(lat, lon, false);
+				inf.close(0);
+				Vm.showWait(false);
+				(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.fileName+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+				ignoreGps = saveIgnoreStatus;
 			}
-			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
-			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox("Error", "Could not load map: "+ newmap.fileName, MessageBox.OKB)).execute();
-			ignoreGps = saveIgnoreStatus;
-		} catch (OutOfMemoryError e) {
-			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
-				mmp.mapImage.free();
-				mmp.mapImage = null;
+		}
+
+
+		public void onEvent(Event ev){
+			if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
+				gotoPanel.runMovingMap = false;
 			}
-			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
-			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox("Error", "Not enough memory to load map: "+ newmap.fileName+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-			ignoreGps = saveIgnoreStatus;
-		}catch (SystemResourceException e) {
-			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
-				mmp.mapImage.free();
-				mmp.mapImage = null;
-			}
-			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
-			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.fileName+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-			ignoreGps = saveIgnoreStatus;
+			super.onEvent(ev);
 		}
 	}
-	
-	
-	public void onEvent(Event ev){
-		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
-			gotoPanel.runMovingMap = false;
+
+	/**
+	 *	Class to display the map bitmap and to select another bitmap to display.
+	 */
+	class MovingMapPanel extends InteractivePanel implements EventListener {
+		Menu mapsMenu;
+		MovingMap mm;
+		AniImage mapImage;
+		Point saveMapLoc = null;
+		boolean saveGpsIgnoreStatus;
+		public MovingMapPanel(MovingMap f){
+			this.mm = f;
+			//this.autoMoveToTop = false;
 		}
-		super.onEvent(ev);
-	}
-}
+		public boolean imageBeginDragged(AniImage which,Point pos) {
+			if (! (which == mapImage || which instanceof TrackOverlay) ) return false;
+			saveGpsIgnoreStatus = mm.ignoreGps; 
+			mm.ignoreGps = true;
+			saveMapLoc = mapImage.getLocation(null);
+			return super.imageBeginDragged(mapImage, pos);
+		}
 
-/**
-*	Class to display the map bitmap and to select another bitmap to display.
-*/
-class MovingMapPanel extends InteractivePanel{
-	MovingMap mm;
-	AniImage mapImage;
-	Point saveMapLoc = null;
-	boolean saveGpsIgnoreStatus;
-	public MovingMapPanel(MovingMap f){
-		this.mm = f;
-		//this.autoMoveToTop = false;
-	}
-	public boolean imageBeginDragged(AniImage which,Point pos) {
-		if (! (which == mapImage || which instanceof TrackOverlay) ) return false;
-		saveGpsIgnoreStatus = mm.ignoreGps; 
-		mm.ignoreGps = true;
-		saveMapLoc = mapImage.getLocation(null);
-		return super.imageBeginDragged(mapImage, pos);
+		public boolean imageNotDragged(ImageDragContext dc,Point pos){
+			boolean ret = super.imageNotDragged(dc, pos);
+			mapMoved(mapImage.location.x - saveMapLoc.x, mapImage.location.y - saveMapLoc.y);
+			mm.ignoreGps = saveGpsIgnoreStatus;
+			return ret;
+
 		}
+		public void moveMap(int diffX, int diffY) {
+			Point p = new Point();
+			if (mapImage!= null) {
+				p = mapImage.getLocation(null);
+				mapImage.move(p.x+diffX,p.y+diffY);
+			}
+			mapMoved(diffX, diffY);
+		}
 
-	public boolean imageNotDragged(ImageDragContext dc,Point pos){
-		boolean ret = super.imageNotDragged(dc, pos);
-		mapMoved(mapImage.location.x - saveMapLoc.x, mapImage.location.y - saveMapLoc.y);
-		mm.ignoreGps = saveGpsIgnoreStatus;
-		return ret;
-	 
-	}
-	public void moveMap(int diffX, int diffY) {
-		Point p = new Point();
-		if (mapImage!= null) {
-			p = mapImage.getLocation(null);
-			mapImage.move(p.x+diffX,p.y+diffY);
+		public void mapMoved(int diffX, int diffY){
+			Point p = mm.posCircle.getLocation(null);
+			mm.posCircle.move(p.x+diffX, p.y+diffY);
+			mm.posCircleX = mm.posCircleX+diffX;
+			mm.posCircleY = mm.posCircleY+diffY;
+			mm.updateSymbolPositions();
+			mm.updateOverlayPos();
+			this.repaintNow();
+
 		}
-		mapMoved(diffX, diffY);
-	}
-	
-	public void mapMoved(int diffX, int diffY){
-		Point p = mm.posCircle.getLocation(null);
-		mm.posCircle.move(p.x+diffX, p.y+diffY);
-		mm.posCircleX = mm.posCircleX+diffX;
-		mm.posCircleY = mm.posCircleY+diffY;
-		mm.updateSymbolPositions();
-		mm.updateOverlayPos();
-		this.repaintNow();
-		
-	}
-	public void chooseMap() {
-		CWPoint gpspos;
-		if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
-		else gpspos = null;
-		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
-		if(l.execute() == FormBase.IDOK){
-//			Vm.debug("Trying map: " + l.selectedMap.fileName);
-			mm.autoSelectMap = false;
-			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.fileName.length()==0) {
-				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
-				mm.ignoreGpsStatutsChanges = false;
-			} else {
-				mm.ignoreGpsStatutsChanges = false;
-				mm.setGpsStatus(MovingMap.noGPS);
-				mm.ignoreGpsStatutsChanges = true;
-				mm.setMap(l.selectedMap, -361, -361); // don't adjust Image to lat/lon
-//				Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-	//			double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
-				mm.posCircleX = 0; // place map to the upper left corner of windows
-				mm.posCircleY = 0;
-				mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+		public void chooseMap() {
+			CWPoint gpspos;
+			if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
+			else gpspos = null;
+			ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
+			if(l.execute() == FormBase.IDOK){
+//				Vm.debug("Trying map: " + l.selectedMap.fileName);
+				mm.autoSelectMap = false;
+				if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.fileName.length()==0) {
+					mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
+					mm.ignoreGpsStatutsChanges = false;
+				} else {
+					mm.ignoreGpsStatutsChanges = false;
+					mm.setGpsStatus(MovingMap.noGPS);
+					mm.ignoreGpsStatutsChanges = true;
+					mm.setMap(l.selectedMap, -361, -361); // don't adjust Image to lat/lon
+//					Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+					//			double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+					mm.posCircleX = 0; // place map to the upper left corner of windows
+					mm.posCircleY = 0;
+					mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+				}
 			}
 		}
-	}
-	
-	/**
-	*	Method to react to user.
-	*/
-	public void imageClicked(AniImage which, Point pos){
-		if (which == mm.ButtonImageChooseMap){ chooseMap();	}
-		if (which == mm.ButtonImageGpsOn) {
-			if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
-				mm.gotoPanel.startGps();
-				mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
-			} 
-			mm.SnapToGps();
-		}
-		/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
+
+		/**
+		 *	Method to react to user.
+		 */
+		public void imageClicked(AniImage which, Point pos){
+			if (which == mm.ButtonImageChooseMap){ 
+				mapsMenu = new Menu(new String[]{"Select a map manually", "Change map directory"}, "map choice");
+				//m.set(Menu., status)
+				mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
+			}
+			//chooseMap();	
+			if (which == mm.ButtonImageGpsOn) {
+				if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
+					mm.gotoPanel.startGps();
+					mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
+				} 
+				mm.SnapToGps();
+			}
+
+			/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}
 		if (which == mm.arrowDown)	{	moveMap(0,-10);	}
 		if (which == mm.arrowUp)	{	moveMap(0,+10);	} */
+		}
+		public void onEvent(Event ev){
+			//if (ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) mapsMenu.close();
+			if (ev instanceof ControlEvent ) { 
+				if (ev.target == mapsMenu && ev.type == MenuEvent.SELECTED ) {
+					if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close();
+					if (mapsMenu.getSelectedItem() != null) {
+						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Select a map manually") )
+						{ 
+							mapsMenu.close();
+							chooseMap();
+						}
+						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Change map directory") )
+						{
+							mapsMenu.close();
+							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+"/maps");
+							fc.addMask("*.wfl");
+							fc.setTitle((String)MyLocale.getMsg(4200,"Select map directory:"));
+							if(fc.execute() != FileChooser.IDCANCEL){
+								mm.loadMaps(fc.getChosen().toString()+"/");
+								mm.addOverlaySet();
+								mm.forceMapLoad();
+							}
+						}
+					}
+				}
+
+
+			}
+			super.onEvent(ev);
+		}
 	}
-}
 
-/**
-*	Class to display maps to choose from
-*/
-class ListBox extends Form{
-	public MapInfoObject selectedMap = new MapInfoObject();
-	mButton cancelButton, okButton;
-	mList list = new mList(4,1,false);
-	public boolean selected = false;
-	Vector maps;
-	
-	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos){
-		this.title = "Maps";
-		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
-		this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
-		this.maps = maps;
-		MapInfoObject map;
-		ScrollBarPanel scb;
-		boolean[] inList = new boolean[maps.size()];
-		if (gotopos != null && Gps != null) {
-			list.addItem("--- Karten von akt. Position und Ziel ---");
-			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
+
+	/**
+	 *	Class to display maps to choose from
+	 */
+	class ListBox extends Form{
+		public MapInfoObject selectedMap = new MapInfoObject();
+		mButton cancelButton, okButton;
+		mList list = new mList(4,1,false);
+		public boolean selected = false;
+		Vector maps;
+
+		public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos){
+			this.title = "Maps";
+			// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+			this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
+			this.maps = maps;
+			MapInfoObject map;
+			ScrollBarPanel scb;
+			boolean[] inList = new boolean[maps.size()];
+			if (gotopos != null && Gps != null) {
+				list.addItem("--- Karten von akt. Position und Ziel ---");
+				for(int i = 0; i<maps.size();i++){
+					map = new MapInfoObject();
+					map = (MapInfoObject)maps.get(i);
+					if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
 					{
-					list.addItem(i + ": " + map.mapName);
-					inList[i] = true;
+						list.addItem(i + ": " + map.mapName);
+						inList[i] = true;
 					} else inList[i] = false;
+				}
 			}
-		}
-		if (Gps != null) {
-			list.addItem("--- Karten der aktuellen Position ---");
-			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
+			if (Gps != null) {
+				list.addItem("--- Karten der aktuellen Position ---");
+				for(int i = 0; i<maps.size();i++){
+					map = new MapInfoObject();
+					map = (MapInfoObject)maps.get(i);
+					if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
 					{
-					list.addItem(i + ": " + map.mapName);
-					inList[i] = true;
+						list.addItem(i + ": " + map.mapName);
+						inList[i] = true;
 					}
+				}
 			}
-		}
-		if (gotopos != null) {
-			list.addItem("--- Karten des Ziels ---");
+			if (gotopos != null) {
+				list.addItem("--- Karten des Ziels ---");
+				for(int i = 0; i<maps.size();i++){
+					map = new MapInfoObject();
+					map = (MapInfoObject)maps.get(i);
+					if(map.inBound(gotopos)) {
+						list.addItem(i + ": " + map.mapName);
+						inList[i] = true;
+					}
+				}
+			}
+			list.addItem("--- andere Karten ---");
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if(map.inBound(gotopos)) {
-					list.addItem(i + ": " + map.mapName);
-					inList[i] = true;
-				}
+				if(!inList[i]) list.addItem(i + ": " + map.mapName);
 			}
+
+			this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+			cancelButton = new mButton("Cancel");
+			cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
+			this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+			okButton = new mButton("Select");
+			okButton.setHotKey(0, KeyEvent.getActionKey(true));
+			this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
 		}
-		list.addItem("--- andere Karten ---");
-		for(int i = 0; i<maps.size();i++){
-			map = new MapInfoObject();
-			map = (MapInfoObject)maps.get(i);
-			if(!inList[i]) list.addItem(i + ": " + map.mapName);
+		private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
+			String testitem = new String();
+			int testitemnr;
+			for (int i=0; i<list.countListItems(); i++) {
+				try { 
+					testitem = ((MenuItem)list.items.get(i)).label;
+					testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
+					if ( testitemnr == mapNr) return true;
+				} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain ":"
+				catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain ":"
+			}
+			return false;
 		}
-		
-		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
-		cancelButton = new mButton("Cancel");
-		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
-		okButton = new mButton("Select");
-		okButton.setHotKey(0, KeyEvent.getActionKey(true));
-		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
-		okButton.setHotKey(0, KeyEvent.getActionKey(true));
-	}
-	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
-		String testitem = new String();
-		int testitemnr;
-		for (int i=0; i<list.countListItems(); i++) {
-			try { 
-				testitem = ((MenuItem)list.items.get(i)).label;
-				testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
-				if ( testitemnr == mapNr) return true;
-			} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain ":"
-			catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain ":"
+
+
+		public int myExecute() {
+			if (this.maps.size()==1) {
+				//this.selectedMap = 1;
+				this.selectedMap = (MapInfoObject) maps.get(0);
+				return FormBase.IDOK;
+			}
+			return execute();
 		}
-		return false;
-	}
 
-	
-	public int myExecute() {
-		if (this.maps.size()==1) {
-			//this.selectedMap = 1;
-			this.selectedMap = (MapInfoObject) maps.get(0);
-			return FormBase.IDOK;
-		}
-		return execute();
-	}
-	
-	
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelButton){
-				selectedMap = null;
-				selected = false;
-				this.close(FormBase.IDCANCEL);
-			}
-			if (ev.target == okButton){
-				try {
+
+		public void onEvent(Event ev){
+			if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+				if (ev.target == cancelButton){
 					selectedMap = null;
-					int mapNum = 0;
-					String it = new String();
-					it = list.getText();
-					if (it != ""){
-						it = it.substring(0,it.indexOf(':'));
-						mapNum = Convert.toInt(it);
-						//	Vm.debug("Kartennummer: " + mapNum);
-						selectedMap = (MapInfoObject)maps.get(mapNum);
-						selected = true;
-						this.close(FormBase.IDOK);
-					}
-					else {
-						selected = false;
-						this.close(FormBase.IDCANCEL);
-					}
-				}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+					selected = false;
+					this.close(FormBase.IDCANCEL);
+				}
+				if (ev.target == okButton){
+					try {
+						selectedMap = null;
+						int mapNum = 0;
+						String it = new String();
+						it = list.getText();
+						if (it != ""){
+							it = it.substring(0,it.indexOf(':'));
+							mapNum = Convert.toInt(it);
+							//	Vm.debug("Kartennummer: " + mapNum);
+							selectedMap = (MapInfoObject)maps.get(mapNum);
+							selected = true;
+							this.close(FormBase.IDOK);
+						}
+						else {
+							selected = false;
+							this.close(FormBase.IDCANCEL);
+						}
+					}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+				}
 			}
+			super.onEvent(ev);
 		}
-		super.onEvent(ev);
 	}
-}
 
-class MapSymbol {
-	String name;
-	String filename;
-	double lat, lon;
-	AniImage pic;
-	public MapSymbol(String namei, String filenamei, double lati, double loni) {
-		name = namei;
-		filename = filenamei;
-		lat = lati;
-		lon = loni;
+	class MapSymbol {
+		String name;
+		String filename;
+		double lat, lon;
+		AniImage pic;
+		public MapSymbol(String namei, String filenamei, double lati, double loni) {
+			name = namei;
+			filename = filenamei;
+			lat = lati;
+			lon = loni;
+		}
+		public void loadImage(){
+			pic = new AniImage(filename);
+			pic.properties = AniImage.AlwaysOnTop;
+		}
 	}
-	public void loadImage(){
-		pic = new AniImage(filename);
-		pic.properties = AniImage.AlwaysOnTop;
-	}
-}
 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-10 23:47:02 UTC (rev 379)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-11 04:13:15 UTC (rev 380)
@@ -57,6 +57,7 @@
 			tbp.refreshTable();
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1012,"Delete"))){
+			if ((new MessageBox("Warnung", "Alle mit H?ckchen markierten Caches l?schen?", MessageBox.YESB | MessageBox.NOB)).execute() != Form.IDYES) return;
 			for(int i = 0; i <	db.size(); i++){
 				ch = (CacheHolder)db.get(i);
 				if(ch.is_Checked == true) {
@@ -98,6 +99,7 @@
 				pref.curCentrePt.set(cp);
 				TablePanel.updateBearingDistance(db, pref);
 				tbp.refreshTable();
+				(new MessageBox("Info", "Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet", MessageBox.OKB)).execute();
 			}
 		}
 		



From admin at berlios.de  Thu Jan 11 20:48:40 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 11 Jan 2007 20:48:40 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3039] Export TomTom OV2
Message-ID: <200701111948.l0BJmeO2016963@unicorn.berlios.de>

Feature Request #3039, was updated on 2007-Jan-11 12:14
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3039&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Export TomTom OV2

By: kalli
Date: 2007-Jan-11 20:48

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

Der FR beisst sich ein wenig mit dem Wunsch von 
Albsucher, dass zu den Caches auch die richtigen Icons 
angezeigt werden, hierf?r werden die einzelnen Dateien 
ben?tigt. Ich greif mir mal den FR und schaue, ob man 
bei dem Auswahldialog f?r das Vezeichnis irgendetwas 
machen kann, um zu sagen, dass alles in eine Datei 
geschrieben werden soll. Alternativ k?nnte man so 
etwas nat?rlich auch in den Pr?ferenzen einstellen. Ich 
stelle die Frage mal im CW-Forum.

----------------------------------------------------------------------

By: cw-tester
Date: 2007-Jan-11 12:14

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

im Moment werden die Caches in Kategorien
(GC-Multi;GC-Traditional etc.) exportiert. Da ich ?fter
mehrere Zielorte entsprechend der Profile(bzw. einer
Selektion davon)  auf meinem PDA speichere, habe ich
mit der momentanen L?sung ein Problem.
Es sollte hier die M?glichkeit geben einen Dateinamen
vorzugeben.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3039&group_id=2211


From pfeffer at mail.berlios.de  Fri Jan 12 15:53:52 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 12 Jan 2007 15:53:52 +0100
Subject: [Cachewolf-svn] r381 - trunk/src/CacheWolf
Message-ID: <200701121453.l0CErqun004176@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-12 15:53:46 +0100 (Fri, 12 Jan 2007)
New Revision: 381

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MovingMap.java
Log:
[ Feature Request #2928 ] Sonnenrichtung in MovingMap anzeigen
OutOfHeapSpace und kleinere Bugs in MovingMap besietigt
Neues Menue in MovingMap: ausblenden der Map und Map-Dir w?\195?\164hlen

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-12 14:53:46 UTC (rev 381)
@@ -380,8 +380,8 @@
 				lblDist.setText(dist.toString(3,0,0) + " m");
 			}
 
-			compassRose.setDirections((float)bearMov.value,(float)bearWayP.value, (float)sunAzimut.value);
-
+			compassRose.setDirections((float)bearWayP.value, (float)sunAzimut.value, (float)bearMov.value);
+			
 			// Set background to signal quality
 			lblSats.backGround = GREEN;
 		}
@@ -406,6 +406,7 @@
 		// In moving map mode
 		if (mmp != null && runMovingMap ) { // neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
 			if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
+				mmp.directionArrows.setDirections(-361 /*(float)bearWayP.value*/, (float)sunAzimut.value, -361 /*(float)bearMov.value*/);
 				mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
 				Vm.debug("ShowLastAddedPoint: voher");
 				mmp.ShowLastAddedPoint(currTrack);
@@ -554,7 +555,9 @@
 			//Start moving map
 			if (ev.target == btnMap){
 				runMovingMap = true;
+				boolean runbefore=false;
 				if (mmp == null) mmp = new MovingMap(pref, this, cacheDB); // this also loads the list of maps
+				else runbefore = true;
 				if (serThread == null || !serThread.isAlive() ) {
 					// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
 					mmp.ignoreGps = false;
@@ -562,7 +565,9 @@
 					mmp.ignoreGps = true;
 				}
 				if (currTrack != null) mmp.addTrack(currTrack);
+				if (runbefore) mmp.addOverlaySet(); // draw new trackpoints but only do so if OverlaySet needs to be updated, otherwise it is anyway newly created
 				mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
+				// update cache symbols in map
 				if (mainT.tbP.myMod.cacheSelectionChanged) {
 					mainT.tbP.myMod.cacheSelectionChanged = false;
 					mmp.removeAllMapSymbolsButGoto();
@@ -656,7 +661,7 @@
 		float angleRad;
 		int x, y, centerX = location.width/2, centerY = location.height/2;
 
-		angleRad = angle * (float)java.lang.Math.PI / 180;
+		angleRad = (angle) * (float)java.lang.Math.PI / 180;
 		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
 		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
 		g.setPen(new Pen(col,Pen.SOLID,3));

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-12 14:53:46 UTC (rev 381)
@@ -31,6 +31,7 @@
 	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
+	public float rotationRad; // contains the rotation of the map == north direction in rad
 	public String fileNameWFL = new String();
 	public String fileName = new String();
 	public String mapName = new String();
@@ -120,11 +121,22 @@
 	center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
 	sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
 	
+	//calculate reverse affine
 	double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
 	transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
 	transLonX = -affine[2]/nenner;
 	transLatY = -affine[1]/nenner;
 	transLonY = affine[0]/nenner;
+	
+	// calculate north direction
+	float scaleX = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
+ //	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
+	float rotationX2x=(float)transLonX*scaleX;
+	float rotationX2y=(float)transLonY*scaleX;
+	//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
+	//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
+	rotationRad = (float)java.lang.Math.atan(rotationX2y);
+	if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad; 
 }
 	
 	

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-12 14:53:46 UTC (rev 381)
@@ -18,7 +18,8 @@
 	final static int noGPSData = 2; // red
 	final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
 	final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
-
+	
+	public MapSymbol gotoPos = null;
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
@@ -30,6 +31,7 @@
 	TrackOverlay[] TrackOverlays;
 	Vector tracks;
 	MapInfoObject currentMap;
+	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal = new AniImage("position_green.png");
 	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
 	AniImage statusImageNoGps = new AniImage("position_red.png");
@@ -49,6 +51,8 @@
 	boolean autoSelectMap = true;
 	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
 	CWPoint lastUpatePosition = new CWPoint();
+	boolean mapHidden = false;
+	boolean noMapsAvailable;
 
 	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
 		this.cacheDB = cacheDB;
@@ -66,6 +70,9 @@
 		ButtonImageChooseMap.properties = AniImage.AlwaysOnTop;
 		ButtonImageGpsOn.setLocation(pref.myAppWidth-25, 10);
 		ButtonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		directionArrows.properties = AniImage.AlwaysOnTop;
+		directionArrows.setLocation(Global.getPref().myAppWidth/2-directionArrows.getWidth()/2, 10);
+		mmp.addImage(directionArrows);
 		/*		arrowUp.setLocation(pref.myAppWidth/2, 10);
 		arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
 		arrowLeft.setLocation(10, pref.myAppHeight/2+7);
@@ -78,10 +85,11 @@
 		mmp.addImage(arrowDown);
 		mmp.addImage(arrowLeft);
 		mmp.addImage(arrowRight);
-		 */		mmp.addImage(ButtonImageChooseMap);
-		 mmp.addImage(ButtonImageGpsOn);
-		 posCircle.properties = AniImage.AlwaysOnTop;
-		 loadMaps(Global.getPref().baseDir+"maps/standard/");
+		 */		
+		mmp.addImage(ButtonImageChooseMap);
+		mmp.addImage(ButtonImageGpsOn);
+		posCircle.properties = AniImage.AlwaysOnTop;
+		loadMaps(Global.getPref().baseDir+"maps/standard/");
 	}
 
 	/**
@@ -111,7 +119,10 @@
 			}catch(IOException ex){ } // TODO etwas genauer auch Fehlermeldung ausgeben? Bei vorhandenen .wfl-Datei mit ung?ltigen Werten Fehler ausgeben oder wie jetz einfach ignorieren?
 		}
 		if (maps.isEmpty())
+			{
 			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung"), MessageBox.OKB)).execute();
+			noMapsAvailable = true;
+			} else noMapsAvailable = false;
 		tempMIO = new MapInfoObject(1.0);
 		maps.add(tempMIO);
 		tempMIO = new MapInfoObject(5.0);
@@ -132,7 +143,7 @@
 	}
 
 	public final FormFrame myExec() {
-		addOverlaySet(); // neccessary to draw points which were added when the MovingMap was not running, so that these pixels are not stored in the not-immediately-drawing-work-around
+		//addOverlaySet(); // neccessary to draw points which were added when the MovingMap was not running, so that these pixels are not stored in the not-immediately-drawing-work-around
 		return exec();
 	}
 	public void addTrack(Track tr) {
@@ -158,7 +169,7 @@
 	 */
 
 	public void addOverlaySet() {
-		//if (tracks == null) return; // no tracks
+		if (tracks == null) return; // no tracks
 		if (TrackOverlays != null) {
 			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
 		}
@@ -177,6 +188,7 @@
 				i = yi*3+xi;
 				if (TrackOverlays[i]==null) { 
 					TrackOverlays[i]= new TrackOverlay(currentMap.calcLatLon(-upperleft.x+(xi-1)*ww, -upperleft.y+(yi-1)*wh), ww, wh, currentMap); 
+					TrackOverlays[i].properties |= mImage.IsInvisible;
 					TrackOverlays[i].move(0, 0);
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
@@ -363,8 +375,28 @@
 		public void resetCenterOfMap() {
 			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
 			posCircleY = pref.myAppHeight/2;
+			posCircle.properties &= ~AniImage.IsInvisible;
 			posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
 		}
+		
+		public void mapMoved(int diffX, int diffY) {
+			int w = posCircle.getWidth();
+			int h = posCircle.getHeight();
+			int npx = posCircleX-w/2+diffX; 
+			int npy = posCircleY-h/2+diffY;
+			if (npx+w >= 0 && npx <= this.width && npy+h >= 0 && npy < this.height)	
+				{
+				posCircle.properties &= ~AniImage.IsInvisible;
+				posCircle.move(npx, npy);
+				} else {
+					posCircle.properties |= AniImage.IsInvisible;
+					posCircle.move(0,0);
+				}
+			posCircleX = posCircleX+diffX;
+			posCircleY = posCircleY+diffY;
+			updateSymbolPositions();
+			updateOverlayPos();
+		}
 
 		/**
 		 * get upper left corner of map on window
@@ -416,7 +448,7 @@
 			}
 		}
 
-		public void addSymbol(String name, String filename, double lat, double lon) {
+		public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
 			if (symbols==null) symbols=new Vector();
 			MapSymbol ms = new MapSymbol(name, filename, lat, lon);
 			ms.loadImage();
@@ -424,6 +456,7 @@
 			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
 			symbols.add(ms);
 			mmp.addImage(ms.pic);
+			return ms;
 		}
 		public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
 			if (symbols==null) symbols=new Vector();
@@ -438,15 +471,11 @@
 
 		public void setGotoPosition(double lat, double lon) {
 			removeMapSymbol("goto");
-			addSymbol("goto", "goto_map.png", lat, lon); 
+			gotoPos=addSymbol("goto", "goto_map.png", lat, lon);
 		}
 
 		public CWPoint getGotoPos(){
-			int symbNr;
-			symbNr = findMapSymbol("goto");
-			if (symbNr == -1) return null;
-			MapSymbol ms = (MapSymbol) symbols.get(symbNr);
-			return new CWPoint(ms.lat, ms.lon);
+			return new CWPoint(gotoPos.lat, gotoPos.lon);
 		}
 
 		public void removeAllMapSymbolsButGoto(){
@@ -553,6 +582,7 @@
 			lastCompareY = Integer.MAX_VALUE;
 			autoSelectMap = true;
 			forceMapLoad = true;
+			showMap();
 //			updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
 		}
 
@@ -589,7 +619,8 @@
 				} // give memory free before loading the new map to avoid out of memory error  
 				if (currentMap.fileName.length()>0) mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
 				else mmp.mapImage = new AniImage();
-				mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable; 
+				mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
+				if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
 				mmp.mapImage.move(0,0);
 				mmp.addImage(mmp.mapImage);
 				mmp.images.moveToBack(mmp.mapImage);
@@ -597,6 +628,7 @@
 				forceMapLoad = true; // forces updateOnlyPosition to redraw
 				updateOnlyPosition(lat, lon, false);
 				forceMapLoad = false;
+				directionArrows.setMap(currentMap);
 				inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
 				Vm.showWait(false);
 				ignoreGps = saveIgnoreStatus;
@@ -638,6 +670,20 @@
 				ignoreGps = saveIgnoreStatus;
 			}
 		}
+		
+		public void hideMap() {
+			if (mmp != null && mmp.mapImage != null)
+				mmp.mapImage.properties |= AniImage.IsInvisible;
+			mapHidden = true;
+			repaintNow();
+		}
+		
+		public void showMap() {
+			if (mmp != null && mmp.mapImage != null)
+				mmp.mapImage.properties &= ~AniImage.IsInvisible;
+			mapHidden = false;
+			repaintNow();
+		}
 
 
 		public void onEvent(Event ev){
@@ -659,19 +705,18 @@
 		boolean saveGpsIgnoreStatus;
 		public MovingMapPanel(MovingMap f){
 			this.mm = f;
-			//this.autoMoveToTop = false;
 		}
 		public boolean imageBeginDragged(AniImage which,Point pos) {
-			if (! (which == mapImage || which instanceof TrackOverlay) ) return false;
+			if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
 			saveGpsIgnoreStatus = mm.ignoreGps; 
 			mm.ignoreGps = true;
-			saveMapLoc = mapImage.getLocation(null);
+			saveMapLoc = pos;
 			return super.imageBeginDragged(mapImage, pos);
 		}
 
 		public boolean imageNotDragged(ImageDragContext dc,Point pos){
 			boolean ret = super.imageNotDragged(dc, pos);
-			mapMoved(mapImage.location.x - saveMapLoc.x, mapImage.location.y - saveMapLoc.y);
+			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 			mm.ignoreGps = saveGpsIgnoreStatus;
 			return ret;
 
@@ -686,15 +731,19 @@
 		}
 
 		public void mapMoved(int diffX, int diffY){
-			Point p = mm.posCircle.getLocation(null);
-			mm.posCircle.move(p.x+diffX, p.y+diffY);
-			mm.posCircleX = mm.posCircleX+diffX;
-			mm.posCircleY = mm.posCircleY+diffY;
-			mm.updateSymbolPositions();
-			mm.updateOverlayPos();
+			mm.mapMoved(diffX, diffY);
 			this.repaintNow();
-
 		}
+		
+		public void doPaint(Graphics g,Rect area) {
+			super.doPaint(g, area);
+			if (mm.gotoPos != null) {
+			Point dest = mm.getXYinMap(mm.gotoPos.lat, mm.gotoPos.lon);
+			g.setPen(new Pen(Color.MediumBlue, Pen.SOLID, 3));
+			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
+			}
+		}
+		
 		public void chooseMap() {
 			CWPoint gpspos;
 			if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
@@ -724,12 +773,16 @@
 		 *	Method to react to user.
 		 */
 		public void imageClicked(AniImage which, Point pos){
-			if (which == mm.ButtonImageChooseMap){ 
-				mapsMenu = new Menu(new String[]{"Select a map manually", "Change map directory"}, "map choice");
+			if (which == mm.ButtonImageChooseMap){
+				mapsMenu = new Menu(new String[]{"Select a map manually$s", "Change map directory$c"}, "map choice");
+				if (!mm.noMapsAvailable) 
+				{
+					if (mm.mapHidden) mapsMenu.addItem("show map");
+					else mapsMenu.addItem("hide map");
+				}
 				//m.set(Menu., status)
 				mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
 			}
-			//chooseMap();	
 			if (which == mm.ButtonImageGpsOn) {
 				if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
 					mm.gotoPanel.startGps();
@@ -744,7 +797,7 @@
 		if (which == mm.arrowUp)	{	moveMap(0,+10);	} */
 		}
 		public void onEvent(Event ev){
-			//if (ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) mapsMenu.close();
+			if (mapsMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) mapsMenu.close();
 			if (ev instanceof ControlEvent ) { 
 				if (ev.target == mapsMenu && ev.type == MenuEvent.SELECTED ) {
 					if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close();
@@ -766,10 +819,21 @@
 								mm.forceMapLoad();
 							}
 						}
+						//dont show map
+						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("hide map") )
+						{
+							mapsMenu.close();
+							mm.hideMap();
+						}
+						// show map
+						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("show map") )
+						{
+							mapsMenu.close();
+							mm.showMap();
+						}
+
 					}
 				}
-
-
 			}
 			super.onEvent(ev);
 		}
@@ -918,3 +982,105 @@
 		}
 	}
 
+	class ArrowsOnMap extends AniImage {
+		float gotoDir = -361;
+		float sunDir = -361;
+		float moveDir = -361;
+		
+		int minY;
+		Graphics draw;
+		private MapInfoObject map=null;
+		public boolean dirsChanged = true;
+		
+		final static Color RED = new Color(255,0,0);
+		final static Color YELLOW = new Color(255,255,0);
+		final static Color GREEN = new Color(0,255,0);
+		final static Color BLUE = new Color(0,255,255);
+		/**
+		 * @param gd goto direction
+		 * @param sd sun direction
+		 * @param md moving direction
+		 */
+		public ArrowsOnMap(){
+			super();
+			newImage();
+		//	setDirections(90, 180, -90);
+		}
+		
+		public void newImage() {
+			setImage(new Image(80,80), Color.White);
+			draw = new Graphics(image);
+		}
+		public void setMap(MapInfoObject m) {
+			map = m;
+		}
+
+		public void setDirections(float gd, float sd, float md ) {
+			if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+					|| java.lang.Math.abs(sunDir - sd) > 1
+					|| java.lang.Math.abs(moveDir - md) > 1)
+			{
+				dirsChanged = true;
+				gotoDir = gd;
+				sunDir = sd;
+				moveDir = md;
+				refresh();
+			}
+		}
+
+		/**
+		 * draw arrows for the directions of movement and destination waypoint
+		 * @param ctrl the control to paint on
+		 * @param moveDir degrees of movement
+		 * @param destDir degrees of destination waypoint
+		 */
+
+		public void doDraw(Graphics g,int options) {
+			if (map == null) return;
+			if (!dirsChanged) {
+				g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+				return;
+			}
+			dirsChanged = false;
+			//super.doDraw(g, options);
+			draw.setColor(Color.White);
+			draw.fillRect(0, 0, location.width, location.height);
+			minY = Integer.MAX_VALUE;
+			drawArrows(draw);
+			draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+		}
+
+		private void drawArrows(Graphics g){
+			
+			if (g != null) {
+				// draw only valid arrows
+				if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, RED);
+				if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, BLUE);
+				if (sunDir < 360 && sunDir> -360) drawArrow(g, sunDir, YELLOW);
+				drawArrow(g, 0, Color.DarkBlue); // north direction
+			}
+		}
+
+		/**
+		 * draw single arrow 
+		 * @param g handle for drawing
+		 * @param angle angle of arrow
+		 * @param col color of arrow
+		 */
+		private void drawArrow(Graphics g, float angle, Color col) {
+			float angleRad;
+			int x, y, centerX = location.width/2, centerY = location.height/2;
+
+			angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+			x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
+			y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
+		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		//	g.drawLine(centerX,centerY,x,y);
+			g.setPen(new Pen(col,Pen.SOLID,3));
+			g.drawLine(centerX,centerY,x,y);
+			if (y < minY) minY = y;
+			if (centerY < minY) minY = centerY;
+		}
+	}
+



From admin at berlios.de  Fri Jan 12 15:54:43 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 15:54:43 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2928] Sonnenrichtung in MovingMap anzeigen
Message-ID: <200701121454.l0CEshTP002008@unicorn.berlios.de>

Feature Request #2928, was updated on 2006-Dec-03 16:35
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2928&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Sonnenrichtung in MovingMap anzeigen

By: pfeffer
Date: 2007-Jan-12 15:54

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigtr mit SVN 381. Auch die Nordrichtung wird 
(dunkelblau) angezeigt.

----------------------------------------------------------------------

By: pfeffer
Date: 2006-Dec-03 16:35

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

Sonnenrichtung in MovingMap anzeigen durch kleines am
Rand entland wanderndes Sonnensymbol

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2928&group_id=2211


From admin at berlios.de  Fri Jan 12 15:55:56 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 15:55:56 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3042] MovinMap Verbindungslinie GPS - Goto
Message-ID: <200701121455.l0CEtuEF002080@unicorn.berlios.de>

Feature Request #3042, was updated on 2007-Jan-12 15:55
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3042&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovinMap Verbindungslinie GPS - Goto

By: pfeffer
Date: 2007-Jan-12 15:55

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovinMap: Verbindungslinie zwischen GPS-Position 
und Goto-Position

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3042&group_id=2211


From admin at berlios.de  Fri Jan 12 15:57:06 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 15:57:06 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3042] MovinMap Verbindungslinie GPS - Goto
Message-ID: <200701121457.l0CEv6QP002139@unicorn.berlios.de>

Feature Request #3042, was updated on 2007-Jan-12 15:55
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3042&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovinMap Verbindungslinie GPS - Goto

By: pfeffer
Date: 2007-Jan-12 15:57

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 15:55

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovinMap: Verbindungslinie zwischen GPS-Position 
und Goto-Position

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3042&group_id=2211


From admin at berlios.de  Fri Jan 12 15:59:51 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 15:59:51 +0100 (CET)
Subject: [Feature #3043] MovingMap: Kartenverzeichnis wählen
Message-ID: <200701121459.l0CExpsg002326@unicorn.berlios.de>

Feature Request #3043, was updated on 2007-Jan-12 15:59
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: Kartenverzeichnis w?hlen

By: pfeffer
Date: 2007-Jan-12 15:59

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: Kartenverzeichnis w?hlen: m?glich 
?ber Klick auf die gelben streifen oben links in der 
Moving map.

Beachte: das Verzeichnis f?r die kalibrierten Karte 
habe ich verlegt.
Es ist nun:
<Daten-Verzeichnis>/maps/standard

bisher unter <programm-verzeichnis>/maps 
abgelegte Karten m?ssen per Hand dort hin 
verschoben werden.

Gru?, 

  Pfeffer

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211


From admin at berlios.de  Fri Jan 12 16:00:41 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 16:00:41 +0100 (CET)
Subject: [Feature #3043] MovingMap: Kartenverzeichnis wählen
Message-ID: <200701121500.l0CF0ft2002394@unicorn.berlios.de>

Feature Request #3043, was updated on 2007-Jan-12 15:59
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: Kartenverzeichnis w?hlen

By: pfeffer
Date: 2007-Jan-12 16:00

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 15:59

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: Kartenverzeichnis w?hlen: m?glich 
?ber Klick auf die gelben streifen oben links in der 
Moving map.

Beachte: das Verzeichnis f?r die kalibrierten Karte 
habe ich verlegt.
Es ist nun:
<Daten-Verzeichnis>/maps/standard

bisher unter <programm-verzeichnis>/maps 
abgelegte Karten m?ssen per Hand dort hin 
verschoben werden.

Gru?, 

  Pfeffer

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211


From admin at berlios.de  Fri Jan 12 16:01:16 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 16:01:16 +0100 (CET)
Subject: [Feature #3043] MovingMap: Kartenverzeichnis wählen
Message-ID: <200701121501.l0CF1Gtt002428@unicorn.berlios.de>

Feature Request #3043, was updated on 2007-Jan-12 15:59
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: Kartenverzeichnis w?hlen

By: pfeffer
Date: 2007-Jan-12 16:01

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 15:59

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: Kartenverzeichnis w?hlen: m?glich 
?ber Klick auf die gelben streifen oben links in der 
Moving map.

Beachte: das Verzeichnis f?r die kalibrierten Karte 
habe ich verlegt.
Es ist nun:
<Daten-Verzeichnis>/maps/standard

bisher unter <programm-verzeichnis>/maps 
abgelegte Karten m?ssen per Hand dort hin 
verschoben werden.

Gru?, 

  Pfeffer

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211


From admin at berlios.de  Fri Jan 12 16:05:33 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 16:05:33 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3044] MavingMap: Karte ausblenden
Message-ID: <200701121505.l0CF5X8e002654@unicorn.berlios.de>

Feature Request #3044, was updated on 2007-Jan-12 16:05
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3044&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MavingMap: Karte ausblenden

By: pfeffer
Date: 2007-Jan-12 16:05

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

Damit man die in der MovingMap angezeigten 
Caches besser sehen kann, kann man die Karte 
ausblenden

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3044&group_id=2211


From admin at berlios.de  Fri Jan 12 16:05:55 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 16:05:55 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3045] MavingMap: Karte ausblenden
Message-ID: <200701121505.l0CF5tce002700@unicorn.berlios.de>

Feature Request #3045, was updated on 2007-Jan-12 16:05
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MavingMap: Karte ausblenden

By: pfeffer
Date: 2007-Jan-12 16:05

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

Damit man die in der MovingMap angezeigten 
Caches besser sehen kann, kann man die Karte 
ausblenden

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211


From admin at berlios.de  Fri Jan 12 16:06:17 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 12 Jan 2007 16:06:17 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3045] MavingMap: Karte ausblenden
Message-ID: <200701121506.l0CF6Heh002719@unicorn.berlios.de>

Feature Request #3045, was updated on 2007-Jan-12 16:05
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MavingMap: Karte ausblenden

By: pfeffer
Date: 2007-Jan-12 16:06

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 16:05

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

Damit man die in der MovingMap angezeigten 
Caches besser sehen kann, kann man die Karte 
ausblenden

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211


From admin at berlios.de  Sat Jan 13 14:22:29 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 13 Jan 2007 14:22:29 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3046] MovingMap: Zommen
Message-ID: <200701131322.l0DDMT2N029643@unicorn.berlios.de>

Feature Request #3046, was updated on 2007-Jan-13 14:22
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: Zommen

By: pfeffer
Date: 2007-Jan-13 14:22

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: Zommen
Wenn man von links (oben) nach rechts (unten) 
den Zoombereich ausw?hlt wird reingezoomt, 
wenn man von rechts (oben) nach links (unten) den 
Zoombereich w?hlt, wird herausgezoomt.


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211


From pfeffer at mail.berlios.de  Sat Jan 13 14:27:32 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 13 Jan 2007 14:27:32 +0100
Subject: [Cachewolf-svn] r382 - in trunk: resources src/CacheWolf
Message-ID: <200701131327.l0DDRWd9008376@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-13 14:27:26 +0100 (Sat, 13 Jan 2007)
New Revision: 382

Added:
   trunk/resources/lupe.png
Modified:
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MovingMap.java
Log:
funktioniert, allerdings sind noch kleinere Verbesserungen vorgesehen (Platzierung, Gr?\195?\182?\195?\159e der vergr?\195?\182?\195?\159erten Karte)[ Feature Request #3046 ] MovingMap: Zommen


Added: trunk/resources/lupe.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/lupe.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-12 14:53:46 UTC (rev 381)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-13 13:27:26 UTC (rev 382)
@@ -8,8 +8,6 @@
 import ewe.io.IOException;
 import ewe.io.PrintWriter;
 import ewe.sys.*;
-import ewe.ui.MessageBox;
-import ewe.ui.SplittablePanel;
 
 /**
  * @author r
@@ -31,26 +29,29 @@
 	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
+	public float zoomFactor = 1;
+	public Point shift = new Point (0,0);
+	public CWPoint OrigUpperLeft; // this is only valid after zooming 
 	public float rotationRad; // contains the rotation of the map == north direction in rad
 	public String fileNameWFL = new String();
 	public String fileName = new String();
 	public String mapName = new String();
 	//private Character digSep = new Character(' ');
 	private String digSep = new String();
-/*
- * loads an .wfl file
- * throws FileNotFoundException and IOException (data out of range)
- * @maps Path to .wfl file
- * @thisMap filename of .wfl file without ".wfl"
- * @DigSep "." or ","
- */	
-	
+	/*
+	 * loads an .wfl file
+	 * throws FileNotFoundException and IOException (data out of range)
+	 * @maps Path to .wfl file
+	 * @thisMap filename of .wfl file without ".wfl"
+	 * @DigSep "." or ","
+	 */	
+
 	public MapInfoObject() {
 		digSep = MyLocale.getDigSeparator();
 		//double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
 		//if(testA == 4.5) digSep = ","; else digSep = ".";
 	}
-	
+
 	/*
 	 * constructes an MapInfoObject without an associated map
 	 * but with 1 Pixel = scale meters
@@ -70,7 +71,7 @@
 		lowlon = 1; //right
 		doCalculations();
 	}
-	
+
 	/**
 	 * Method to load a .wfl-file
 	 * @throws IOException when there was a problem reading .wfl-file
@@ -109,6 +110,7 @@
 		} catch (NullPointerException e) { // in.readline liefert null zur?ck, wenn keine Daten mehr vorhanden sind
 			throw (new IOException("not enough lines in file "+mapsPath + thisMap + ".wfl"));
 		}
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
 		doCalculations();
 	}
 
@@ -116,35 +118,35 @@
 	 * calculates center, diagonal size of the map and inverse to affine transformation
 	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
-	
+
 	private void doCalculations() throws ArithmeticException {
-	center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
-	sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
-	
-	//calculate reverse affine
-	double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
-	transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
-	transLonX = -affine[2]/nenner;
-	transLatY = -affine[1]/nenner;
-	transLonY = affine[0]/nenner;
-	
-	// calculate north direction
-	float scaleX = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
- //	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
-	float rotationX2x=(float)transLonX*scaleX;
-	float rotationX2y=(float)transLonY*scaleX;
-	//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
-	//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
-	rotationRad = (float)java.lang.Math.atan(rotationX2y);
-	if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad; 
-}
-	
-	
+		center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
+		sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
+
+		//calculate reverse affine
+		double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
+		transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
+		transLonX = -affine[2]/nenner;
+		transLatY = -affine[1]/nenner;
+		transLonY = affine[0]/nenner;
+
+		// calculate north direction
+		float scaleX = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
+		//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
+		float rotationX2x=(float)transLonX*scaleX;
+		float rotationX2y=(float)transLonY*scaleX;
+		//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
+		//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
+		rotationRad = (float)java.lang.Math.atan(rotationX2y);
+		if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad; 
+	}
+
+
 	/**
-	*	Method to save a world file (.wfl)
-	* @throws IOException when there was a problem writing .wfl-file
-	* @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
-	*/
+	 *	Method to save a world file (.wfl)
+	 * @throws IOException when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
+	 */
 	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
 		if (affine[0]==0 && affine[1]==0 && affine[2]==0 && affine[3]==0 && 
 				affine[4]==0 && affine[5]==0 ) throw (new IllegalArgumentException("map not calibrated"));
@@ -175,11 +177,39 @@
 		Vm.debug("Left: " + affine[5]);
 		Vm.debug("Right: " + lowlon);
 		Vm.debug("Test: " + pos.lonDec);
-		*/
+		 */
 		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
 		return isInBound;
 	}
-	
+
+	/**
+	 * zoom in / out
+	 * @param zf zf > 1 == zoom in, zoom is relative to last zoom
+	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * @param diffY
+	 */
+	public void zoom(float zf, int diffX, int diffY) {
+
+		// restore original values to calculate corret shift (upperleft)
+		affine[4] = OrigUpperLeft.latDec;
+		affine[5] = OrigUpperLeft.lonDec;
+		affine[0] = affine[0] * zoomFactor; 
+		affine[1] = affine[1] * zoomFactor; 
+		affine[2] = affine[2] * zoomFactor;
+		affine[3] = affine[3] * zoomFactor;
+		CWPoint upperleft = calcLatLon(diffX, diffY);
+		affine[4] = upperleft.latDec;
+		affine[5] = upperleft.lonDec;
+		affine[0] = affine[0] / zf / zoomFactor; 
+		affine[1] = affine[1] / zf / zoomFactor; 
+		affine[2] = affine[2] / zf / zoomFactor; 
+		affine[3] = affine[3] / zf / zoomFactor; 
+		zoomFactor = zf * zoomFactor ;
+		shift.x = diffX;
+		shift.y = diffY;
+		doCalculations(); // TODO lowlat neu berechnen?
+	}
+
 	public boolean inBound(CWGPSPoint pos){
 		boolean isInBound = false;
 		/*
@@ -190,7 +220,7 @@
 		Vm.debug("Left: " + affine[5]);
 		Vm.debug("Right: " + lowlon); // lowlon should be left?!
 		Vm.debug("Test: " + pos.lonDec);
-		*/
+		 */
 		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
 		return isInBound;
 	}
@@ -200,12 +230,12 @@
 		return isInBound;
 	}
 	/**
-	* Method to calculate bitmap x,y of the current map using
-	* lat and lon target coordinates. There ist no garanty that
-	* the returned coordinates are inside of the map. They can be negative.
-	* @param lat
-	* @param lon
-	*/
+	 * Method to calculate bitmap x,y of the current map using
+	 * lat and lon target coordinates. There ist no garanty that
+	 * the returned coordinates are inside of the map. They can be negative.
+	 * @param lat
+	 * @param lon
+	 */
 	public Point calcMapXY(double lat, double lon){
 		Point coords = new Point();
 		double b[] = new double[2];
@@ -218,11 +248,18 @@
 		//Vm.debug("mapX=mapx2: "+mapx+"="+mapx2+"; mapy=mapy2: "+mapy+"="+mapy2);
 		return coords;
 	}
+
+	/**
+	 * gives back lat/lon from x, y in map
+	 * @param x
+	 * @param y
+	 * @return
+	 */
 	public CWPoint calcLatLon(int x, int y) {
-		 CWPoint ll = new CWPoint();
-		 ll.latDec = (double)x * affine[0] + (double)y * affine[2] + affine[4];
-		 ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + affine[5];
-		 return ll;
+		CWPoint ll = new CWPoint();
+		ll.latDec = (double)x * affine[0] + (double)y * affine[2] + affine[4];
+		ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + affine[5];
+		return ll;
 	}
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-12 14:53:46 UTC (rev 381)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-13 13:27:26 UTC (rev 382)
@@ -31,13 +31,15 @@
 	TrackOverlay[] TrackOverlays;
 	Vector tracks;
 	MapInfoObject currentMap;
+	AniImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal = new AniImage("position_green.png");
 	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
 	AniImage statusImageNoGps = new AniImage("position_red.png");
 
 	AniImage ButtonImageChooseMap = new AniImage("choose_map.gif"); 
-	AniImage ButtonImageGpsOn = new AniImage("snap2gps.gif"); 
+	AniImage ButtonImageGpsOn = new AniImage("snap2gps.gif");
+	AniImage ButtonImageLens = new AniImage("lupe.png");
 	/*AniImage arrowUp = new AniImage("arrow_up.png");
 	AniImage arrowDown = new AniImage("arrow_down.png");
 	AniImage arrowLeft = new AniImage("arrow_left.png");
@@ -53,6 +55,7 @@
 	CWPoint lastUpatePosition = new CWPoint();
 	boolean mapHidden = false;
 	boolean noMapsAvailable;
+	boolean zoomingMode = false;
 
 	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
 		this.cacheDB = cacheDB;
@@ -73,6 +76,9 @@
 		directionArrows.properties = AniImage.AlwaysOnTop;
 		directionArrows.setLocation(Global.getPref().myAppWidth/2-directionArrows.getWidth()/2, 10);
 		mmp.addImage(directionArrows);
+		ButtonImageLens.setLocation(Global.getPref().myAppWidth - ButtonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - ButtonImageLens.getHeight()/2 );
+		ButtonImageLens.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(ButtonImageLens);
 		/*		arrowUp.setLocation(pref.myAppWidth/2, 10);
 		arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
 		arrowLeft.setLocation(10, pref.myAppHeight/2+7);
@@ -421,7 +427,12 @@
 			//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
 			return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 		}
-
+		
+		public CWPoint ScreenXY2LatLon (int x, int y){
+			Point mapPos = getMapXYPosition();
+			return currentMap.calcLatLon(x-mapPos.x, y-mapPos.y);
+		}
+		
 		public void updateSymbolPositions() {
 			if (symbols == null) return;
 			Point pOnScreen;
@@ -613,12 +624,14 @@
 				lastCompareY = Integer.MAX_VALUE;
 				if (! (mmp.mapImage == null) ) {
 					//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
-					mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null;
+					mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+
 					//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
 					Vm.getUsedMemory(true); // calls the garbage collection
 				} // give memory free before loading the new map to avoid out of memory error  
 				if (currentMap.fileName.length()>0) mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
 				else mmp.mapImage = new AniImage();
+				mapImage1to1 = mmp.mapImage;
 				mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
 				if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
 				mmp.mapImage.move(0,0);
@@ -636,7 +649,7 @@
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage); 
 					mmp.mapImage.free();
-					mmp.mapImage = null;
+					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 				}
 				addOverlaySet();
 				updateOnlyPosition(lat, lon, false);
@@ -648,7 +661,7 @@
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage); 
 					mmp.mapImage.free();
-					mmp.mapImage = null;
+					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 				}
 				addOverlaySet();
 				updateOnlyPosition(lat, lon, false);
@@ -660,7 +673,7 @@
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage); 
 					mmp.mapImage.free();
-					mmp.mapImage = null;
+					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 				}
 				addOverlaySet();
 				updateOnlyPosition(lat, lon, false);
@@ -684,8 +697,70 @@
 			mapHidden = false;
 			repaintNow();
 		}
+		
+		public void setZoomingMode() {
+			zoomingMode = true;
+		}
+		
+		/**
+		 * zommes in if w>0 and out if w<0
+		 * @param firstclickpoint
+		 * @param w
+		 * @param h
+		 */
+		public void zoom(Point firstclickpoint, int w, int h) {
+			Vm.showWait(true);
+			int newImageWidth = 1000;
+			int newImageHeight= 1000;
+			CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y+h/2);
+			float zoomFactor;
+			if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
+			else		zoomFactor = java.lang.Math.abs((float)w / (float)this.width);
+			
+			// calculate rect in unzoomed image in a wya that the center of the new image is the center of selected area 
+			newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
+			newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
+			Point mappos = getMapXYPosition();
+			int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth/2);
+			int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight/2);
+			Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+				{
+				if (newImageRect.x < 0) newImageRect.x = 0;
+				if (newImageRect.y < 0) newImageRect.y = 0;
+ 				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) newImageRect.width = mapImage1to1.getWidth()-1;
+				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) newImageRect.height= mapImage1to1.getHeight()-1;
+				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) newImageRect.x = 0;
+				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) newImageRect.y = 0;
+				int saveprop = mmp.mapImage.properties;
+				AniImage tmp = mmp.mapImage;
+				mmp.removeImage(mmp.mapImage);
+				try {
+					Vm.getUsedMemory(true);
+					tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor*currentMap.zoomFactor), (int)(newImageRect.height*zoomFactor*currentMap.zoomFactor), newImageRect, 0));
+					mmp.mapImage.free();
+					currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+				} catch (OutOfMemoryError e) {Vm.debug(e.toString());}
+				Vm.getUsedMemory(true);
+				mmp.mapImage = tmp; // use old image in case of OutOfMemoryError
+				mmp.mapImage.properties = saveprop;
+				mmp.addImage(mmp.mapImage);
+				mmp.images.moveToBack(mmp.mapImage);
+				}
+			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+			{
+				mappos = getMapXYPosition();
+				mmp.mapImage.move(mappos.x,mappos.y);
+			}
+			//updatePosition(center.latDec, center.lonDec);
+			addOverlaySet();
+			updateSymbolPositions();
+			this.repaintNow();
+			Vm.showWait(false);
+			//CWPoint test = ScreenXY2LatLon(0, 0);
+		}
+		
 
-
 		public void onEvent(Event ev){
 			if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
 				gotoPanel.runMovingMap = false;
@@ -703,17 +778,55 @@
 		AniImage mapImage;
 		Point saveMapLoc = null;
 		boolean saveGpsIgnoreStatus;
+		boolean paintingZoomArea;
+		int lastZoomWidth , lastZoomHeight;
 		public MovingMapPanel(MovingMap f){
 			this.mm = f;
 		}
 		public boolean imageBeginDragged(AniImage which,Point pos) {
+			if (mm.zoomingMode == true) {
+				saveMapLoc = pos;
+				return false;
+			}
 			if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
 			saveGpsIgnoreStatus = mm.ignoreGps; 
 			mm.ignoreGps = true;
 			saveMapLoc = pos;
 			return super.imageBeginDragged(mapImage, pos);
 		}
+		
+/*		public boolean imageDragged(ImageDragContext dc,Point where) {
+			if (mm.zoomingMode == false) return super.imageDragged(dc, where);
+			dc.
+			void updateArea(DragContext dc,boolean doImage,boolean update)
+//			-------------------------------------------------------------------
+			{
+				if (imagePos == null) imagePos = new Point().set(dc.prevPoint.x,dc.prevPoint.y);
+				if (update) getUpdateArea(imagePos,dc.curPoint,null,null,imagePos);
+				Graphics g = ib.get(updateArea.width,updateArea.height,true);
+				g.setColor(new Color(0xff,0,0));
+				g.fillRect(0,0,updateArea.width,updateArea.height);
+				g.translate(-updateArea.x,-updateArea.y);
+				if (copied == null){
+					window.repaintNow(g,updateArea);
+					if (doImage) image.draw(g,imagePos.x-cx+wx,imagePos.y-cy+wy,0);
 
+				}else{
+					g.drawImage(copied,0,0);
+					if (doImage) image.draw(g,imagePos.x-cx+wx,imagePos.y-cy+wy,0);
+				}
+				if (relativeImagePos == null) relativeImagePos = new Point();
+				relativeImagePos.set(imagePos.x-cx,imagePos.y-cy);
+				wg.drawImage(ib.image,updateArea.x,updateArea.y);
+				wg.flush();
+				g.translate(updateArea.x,updateArea.y);
+				if (clearPendingDrags) dc.clearPendingDrags();
+			}
+
+		}
+		*/
+		
+
 		public boolean imageNotDragged(ImageDragContext dc,Point pos){
 			boolean ret = super.imageNotDragged(dc, pos);
 			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
@@ -721,6 +834,39 @@
 			return ret;
 
 		}
+		
+		public void onPenEvent(PenEvent ev) {
+			if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+				saveMapLoc = new Point (ev.x, ev.y);
+				paintingZoomArea = true;
+				mm.zoomingMode = true;
+			}
+			if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
+				paintingZoomArea = false;
+				mm.zoomingMode = false;
+				mm.zoom(saveMapLoc, lastZoomWidth, lastZoomHeight);
+			}
+			
+			if (mm.zoomingMode && paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+				int left, top;
+				Graphics dr = this.getGraphics();
+				if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
+				else left = saveMapLoc.x;
+				if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+				else top = saveMapLoc.y;
+				this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)));
+				dr.setColor(Color.LightGreen);
+				lastZoomWidth = ev.x - saveMapLoc.x;
+				lastZoomHeight =  ev.y - saveMapLoc.y;
+				if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
+				else left = saveMapLoc.x;
+				if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+				else top = saveMapLoc.y;
+				dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth) , java.lang.Math.abs(lastZoomHeight), 2);
+			}
+			super.onPenEvent(ev);
+		}
+		
 		public void moveMap(int diffX, int diffY) {
 			Point p = new Point();
 			if (mapImage!= null) {
@@ -790,6 +936,9 @@
 				} 
 				mm.SnapToGps();
 			}
+			if (which == mm.ButtonImageLens) {
+				mm.setZoomingMode();
+			}
 
 			/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}



From admin at berlios.de  Sat Jan 13 14:35:32 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 13 Jan 2007 14:35:32 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3046] MovingMap: Zommen
Message-ID: <200701131335.l0DDZW6U016036@unicorn.berlios.de>

Feature Request #3046, was updated on 2007-Jan-13 14:22
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: Zommen

By: pfeffer
Date: 2007-Jan-13 14:35

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

das wesentliche ist mit SVN 382 erledigt.
Verbesserungen sind noch vorgesehen  bei der 
Verschiebung des Ausschnitts sowohl auf dem 
Bildschirm alsauch bei der Beschneidung des Bildes beim 
zoomen.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-13 14:22

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: Zommen
Wenn man von links (oben) nach rechts (unten) 
den Zoombereich ausw?hlt wird reingezoomt, 
wenn man von rechts (oben) nach links (unten) den 
Zoombereich w?hlt, wird herausgezoomt.


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211


From bilbowolf at mail.berlios.de  Sat Jan 13 19:35:30 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 13 Jan 2007 19:35:30 +0100
Subject: [Cachewolf-svn] r383 - in trunk: resources src/CacheWolf
Message-ID: <200701131835.l0DIZUk4013760@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-13 19:35:20 +0100 (Sat, 13 Jan 2007)
New Revision: 383

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CacheWolf.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/myTableModel.java
Log:


Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-13 18:35:20 UTC (rev 383)
@@ -54,6 +54,7 @@
 		158=Version pr%fcfen
 		159=Filter
 		160=Selektierte
+		161=Zeige Blacklist
 		200=Details
 		201=Beschreibung
 		202=Bilder
@@ -309,6 +310,7 @@
 		157=System
 		158=Version Check
 		159=Filter
+		161=Show Blacklist
 		200=Details
 		201=Description
 		202=Images

Modified: trunk/src/CacheWolf/CacheWolf.java
===================================================================
--- trunk/src/CacheWolf/CacheWolf.java	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/src/CacheWolf/CacheWolf.java	2007-01-13 18:35:20 UTC (rev 383)
@@ -248,9 +248,10 @@
 			}
 		}
 		Form mainF = new MainForm();
+		Device.preventIdleState(true);
 		mainF.execute();
+		Device.preventIdleState(false);
 		
-		
 		//Form mainF = new MainForm();
 		//mainF.execute();
 		ewe.sys.Vm.exit(0);

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-13 18:35:20 UTC (rev 383)
@@ -23,7 +23,7 @@
 	mChoice wayType = new mChoice(new String[]{"Custom", "Traditional", "Multi", "Virtual", "Letterbox", "Event", "Mega Event", "Mystery", "Webcam", "Locationless", "CITO", "Earthcache", "Parking", "Stage", "Question", "Final","Trailhead","Reference"},0);
 	mChoice waySize = new mChoice(new String[]{"", "Micro", "Small", "Regular", "Large","Other","Very Large","None"},0);
 	mComboBox wayStatus = new mComboBox(new String[]{"", MyLocale.getMsg(313,"Flag 1"), MyLocale.getMsg(314,"Flag 2"), MyLocale.getMsg(315,"Flag 3"), MyLocale.getMsg(316,"Flag 4"), MyLocale.getMsg(317,"Search"), MyLocale.getMsg(318,"Found"), MyLocale.getMsg(319,"Not Found"), MyLocale.getMsg(320,"Owner")},0);
-	mButton btCrWp, showBug, showMap, addDateTime, btnGoto, addPicture;
+	mButton btCrWp, showBug, showMap, addDateTime, btnGoto, addPicture, btnBlack;
 	Vector cacheDB;
 	CacheHolder thisCache;
 	CellPanel toolP = new CellPanel();
@@ -33,9 +33,12 @@
 	public boolean dirty_delete = false;
 	public boolean dirty_status = false;
 	boolean newWp = false;
+	public boolean blackStatus = false;
 	MainTab mainT;
 	Preferences pref; // Test
 	Profile profile;
+	mImage mIsBlack;
+	mImage mNoBlack;
 	
 	public DetailsPanel(){
 		//String welcomeMessage = MyLocale.getMsg(1,"how about that?");
@@ -46,15 +49,19 @@
 		mImage mI2 = new mImage("globe_small.gif");
 		mImage mI3 = new mImage("date_time.png");
 		mImage mI4 = new mImage("images.gif");
+		mNoBlack = new mImage("no_black.png");
+		mIsBlack = new mImage("is_black.png");
 		showBug = new mButton((IImage)mI);
 		showMap = new mButton((IImage)mI2);
 		addDateTime = new mButton((IImage)mI3);
 		addPicture = new mButton((IImage)mI4);
+		btnBlack = new mButton((IImage)mNoBlack);
 		toolP.addNext(showBug,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		showBug.modify(Control.Disabled,0);
 		toolP.addNext(showMap,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		toolP.addNext(addDateTime,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		toolP.addLast(addPicture,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		toolP.addNext(addPicture,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		toolP.addLast(btnBlack,CellConstants.DONTSTRETCH, CellConstants.WEST);
 			
 		//showMap.modify(Control.Disabled,0);
 		this.addLast(toolP,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(3,1));;
@@ -119,6 +126,12 @@
 		wayStatus.setText(ch.CacheStatus);
 		wayNotes.setText(ch.CacheNotes);
 		wayType.setInt(transType(ch.type));
+		if(ch.is_black){
+			btnBlack.image = mIsBlack;
+		} else {
+			btnBlack.image = mNoBlack;
+		}
+		btnBlack.repaintNow();
 		if(ch.has_bug == true) {
 			showBug.modify(Control.Disabled,1);
 		} else {
@@ -322,6 +335,18 @@
 			if (ev.target == addPicture){
 				thisCache.addUserImage(profile);
 			}
+			if(ev.target == btnBlack){
+				if(thisCache.is_black) {
+					thisCache.is_black = false;
+					btnBlack.image = mNoBlack;
+				}
+				else {
+					thisCache.is_black = true;
+					btnBlack.image = mIsBlack;
+				}
+				blackStatus = thisCache.is_black;
+				btnBlack.repaintNow();
+			}
 			if (ev.target == btCrWp){
 				if(btCrWp.getText().equals(MyLocale.getMsg(312,"Save"))){
 					saveWpt();

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/src/CacheWolf/Filter.java	2007-01-13 18:35:20 UTC (rev 383)
@@ -203,6 +203,22 @@
 	}
 	
 	/**
+	 * Filters the cachelist for those caches marked is_black == true.
+	 * Only caches matching are then displayed in the table
+	 * @param cacheDB
+	 */
+	public void showBlacklist(Vector cacheDB){
+		CacheHolder ch;
+		for(int i = 0; i < cacheDB.size(); i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.is_filtered = true;
+			Vm.debug(ch.CacheName + ": " +ch.is_black);
+			if(ch.is_black == true) ch.is_filtered = false; 
+			cacheDB.set(i,ch);
+		}
+	}
+	
+	/**
 	*	Apply the filter. Caches that match a criteria are flagged
 	*	is_filtered = true. The table model is responsible for displaying or
 	*	not displaying a cache that is filtered.

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-13 18:35:20 UTC (rev 383)
@@ -53,7 +53,7 @@
 			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
 				ewe.sys.Vm.exit(0); // User MUST select or create a profile
 			InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
-			infB.show();
+			infB.exec();
 			infB.waitUntilPainted(1000);
 			profile.readIndex();
 			infB.close(0);

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-13 18:35:20 UTC (rev 383)
@@ -25,7 +25,7 @@
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTomASC, exportMSARCSV;
 	private MenuItem exportOZI, exportKML, exportTomTomOVL, exportTPL;
-	private MenuItem filtCreate, filtClear, filtInvert, filtSelected;
+	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack;
 	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
 	private MenuItem orgCopy, orgMove, orgDelete;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditProfile;
@@ -104,12 +104,13 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create the "Filter" pulldown menu
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterMenuItems=new MenuItem[5];
+		MenuItem[] filterMenuItems=new MenuItem[6];
 		filterMenuItems[0] = filtCreate  = new MenuItem(MyLocale.getMsg(114,"Create")); 
 		filterMenuItems[1] = filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")); 
 		filterMenuItems[2] = filtClear   = new MenuItem(MyLocale.getMsg(116,"Clear"));
-		filterMenuItems[3] = new MenuItem("-");
-		filterMenuItems[4] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
+		filterMenuItems[3] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
+		filterMenuItems[4] = new MenuItem("-");
+		filterMenuItems[5] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
 		
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
@@ -264,6 +265,11 @@
 				flt.invertFilter(cacheDB);
 				tbp.refreshTable();
 			}
+			if(mev.selectedItem == filtBlack){
+				Filter flt = new Filter();
+				flt.showBlacklist(cacheDB);
+				tbp.refreshTable();
+			}
 			if(mev.selectedItem == exportGPS){
 				Vm.showWait(true);
 				PCX5Exporter pcx = new PCX5Exporter(pref, profile);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-13 18:35:20 UTC (rev 383)
@@ -114,6 +114,7 @@
 					  ch = (CacheHolder)cDB.get(tbP.getSelectedCache());
 					  ch.CacheStatus = detP.wayStatus.getText();
 					  ch.is_found = ch.CacheStatus.equals(MyLocale.getMsg(318,"Found"));
+					  ch.is_black = detP.blackStatus;
 					  ch.wayPoint = detP.wayPoint.getText();
 					  ch.CacheName = detP.wayName.getText();
 					  ch.LatLon = new CWPoint(detP.btnWayLoc.getText(),CWPoint.CW).toString();

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-13 13:27:26 UTC (rev 382)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-13 18:35:20 UTC (rev 383)
@@ -142,12 +142,12 @@
 		// - filtered caches are moved to the end
 		for (int i=0; i<cacheDB.size(); i++){
 			ch = (CacheHolder) cacheDB.get(i);
-			if (ch.is_filtered) {
+			if (ch.is_filtered || ch.is_black) {
 				filteredDB.add(ch);
 			} else {
 				if (ch.isAddiWpt()){
 					// check if main wpt is filtered
-					if (ch.mainCache.is_filtered) sortDB.add(ch);
+					if(ch.mainCache != null) if (ch.mainCache.is_filtered) sortDB.add(ch);
 				} else {
 					sortDB.add(ch);
 					if (ch.hasAddiWpt()){
@@ -239,7 +239,7 @@
 					CacheHolder ch = (CacheHolder)cacheDB.get(row);
 					//Vm.debug(String.valueOf(row));
 					//Vm.debug(String.valueOf(cols[col]));
-					if(ch.is_filtered == false){
+					if(ch.is_filtered == false && ch.is_black == false){
 						try{
 							if(colName[col].equals(nmCheck)) {
 /* Replaced mCheckBox with two images: One showing the unticked box, one showing the ticked box



From bilbowolf at mail.berlios.de  Sat Jan 13 19:36:00 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 13 Jan 2007 19:36:00 +0100
Subject: [Cachewolf-svn] r384 - trunk/resources
Message-ID: <200701131836.l0DIa0bK013778@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-13 19:35:57 +0100 (Sat, 13 Jan 2007)
New Revision: 384

Added:
   trunk/resources/is_black.png
   trunk/resources/no_black.png
Log:


Added: trunk/resources/is_black.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/is_black.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/no_black.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/no_black.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From salzkammergut at mail.berlios.de  Sat Jan 13 20:51:31 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 13 Jan 2007 20:51:31 +0100
Subject: [Cachewolf-svn] r385 - trunk/src/CacheWolf
Message-ID: <200701131951.l0DJpV3k018810@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-13 20:51:23 +0100 (Sat, 13 Jan 2007)
New Revision: 385

Modified:
   trunk/src/CacheWolf/Global.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Vorbereitung fuer goto Befehl im neuen Solver
getCacheIndex von myTableModel in Profile verschoben

Modified: trunk/src/CacheWolf/Global.java
===================================================================
--- trunk/src/CacheWolf/Global.java	2007-01-13 18:35:57 UTC (rev 384)
+++ trunk/src/CacheWolf/Global.java	2007-01-13 19:51:23 UTC (rev 385)
@@ -16,6 +16,7 @@
 	  static public Profile getProfile() {
 		  return profile;
 	  }
-
+      // A bit of a hack to allow access from one panel to another
+	  static public MainTab mainTab;
 }
 

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-13 18:35:57 UTC (rev 384)
+++ trunk/src/CacheWolf/Profile.java	2007-01-13 19:51:23 UTC (rev 385)
@@ -181,6 +181,18 @@
 		}
 	}
 	
+	public int getCacheIndex(String wp){
+		int retval = -1;
+		CacheHolder ch;
+		for(int i = 0; i<cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.wayPoint.equals(wp)){
+				return i;
+			}
+		}
+		return retval;
+	}
+
 	public String toString() {
 		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
 		     last_sync_opencaching+"\ndistOC="+distOC;

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-13 18:35:57 UTC (rev 384)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-13 19:51:23 UTC (rev 385)
@@ -332,7 +332,7 @@
 					cacheDB.sort(new MyComparer(colName[cell.x]), sortAsc);
 					updateRows();
 					if(!(a == null)){
-						int rownum = getCacheIndex(ch.wayPoint);
+						int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
 						if(rownum >= 0){
 							tcControl.scrollToVisible(rownum, 0);
 							tcControl.clearSelectedCells(new Vector());
@@ -353,7 +353,7 @@
 					cacheDB.sort(new DistComparer(), sortAsc);
 					updateRows();
 					if(!(a == null)){
-						int rownum = getCacheIndex(ch.wayPoint);
+						int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
 						if(rownum >= 0){
 							tcControl.scrollToVisible(rownum, 0);
 							tcControl.clearSelectedCells(new Vector());
@@ -372,15 +372,4 @@
 		return retval;
 	}
 	
-	private int getCacheIndex(String wp){
-		int retval = -1;
-		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.wayPoint.equals(wp)){
-				return i;
-			}
-		}
-		return retval;
-	}
 }



From admin at berlios.de  Sat Jan 13 21:12:08 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 13 Jan 2007 21:12:08 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2987] /maps Verzeichnis
Message-ID: <200701132012.l0DKC8or016950@unicorn.berlios.de>

Feature Request #2987, was updated on 2006-Dec-21 17:39
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: /maps Verzeichnis

By: mik77
Date: 2007-Jan-13 21:12

Message:
Logged In: YES 
user_id=34677
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de-AT; rv:1.8.1) Gecko/20061101 SeaMonkey/1.1b Mnenhy/0.7.4.10002

Es gibt noch ein paar weitere Stellen, an denen das
Karten-Verzeichnis angepasst werden m?sste. Z.B. bei Import.
bei einer Suche nach "maps/" finde ich noch drei weitere
Stellen.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-11 05:14

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

so, jetzt kann man durch klick auf die gelben Streifen links
oben in der Ecke der MovingMap ein vom Standardverzeichnis
abweichendes w?hlen. (SVN: 380)
Zweck: ein Verzeichnis f?r GoogleEarth-Karten, ein anderes
f?r Karten aus TK50 der Landesvermessungs?mter o.?.

Gru?,
  Pfeffer.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2987&group_id=2211


From bilbowolf at mail.berlios.de  Sat Jan 13 23:08:00 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 13 Jan 2007 23:08:00 +0100
Subject: [Cachewolf-svn] r386 - trunk/src/CacheWolf
Message-ID: <200701132208.l0DM80Lw030005@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-13 23:07:59 +0100 (Sat, 13 Jan 2007)
New Revision: 386

Modified:
   trunk/src/CacheWolf/MainForm.java
Log:


Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-13 19:51:23 UTC (rev 385)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-13 22:07:59 UTC (rev 386)
@@ -66,7 +66,8 @@
 		
 		if(pref.fixSIP == true){
 			if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
-				Vm.setSIP(Vm.SIP_LEAVE_BUTTON|Vm.SIP_ON);
+				//Vm.setSIP(Vm.SIP_LEAVE_BUTTON|Vm.SIP_ON);
+				Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
 			}
 		} else Vm.setSIP(0);
 		//Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);



From pfeffer at mail.berlios.de  Sun Jan 14 06:09:26 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 14 Jan 2007 06:09:26 +0100
Subject: [Cachewolf-svn] r388 - trunk/src/CacheWolf
Message-ID: <200701140509.l0E59QFs000676@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-14 06:09:23 +0100 (Sun, 14 Jan 2007)
New Revision: 388

Modified:
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
kleiner Bug im TrackOverlay behoben
beim zoom wird jetzt an die richtige Stelle die Karte verschoben
Memory-managemant etwas verbessert

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-13 23:18:06 UTC (rev 387)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-14 05:09:23 UTC (rev 388)
@@ -175,16 +175,20 @@
 	 */
 
 	public void addOverlaySet() {
+		destroyOverlaySet();
 		if (tracks == null) return; // no tracks
+		addMissingOverlays();
+	}
+	
+	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
 			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
 		}
-		addMissingOverlays();
 	}
 
 
 	public void addMissingOverlays() {
-		Point upperleft = getMapXYPosition();
+		Point upperleft = getMapPositionOnScreen();
 		int ww = pref.myAppWidth;
 		int wh = pref.myAppHeight;
 		int i;
@@ -313,10 +317,10 @@
 	}
 
 	public void updateOverlayOnlyPos() {
-		if (TrackOverlays == null) return;
+		if (TrackOverlays == null || TrackOverlays[4] == null) return;
 		//	Point upperleft = getMapXYPosition();
 		Point posOnScreen;
-		posOnScreen = getXYinMap(TrackOverlays[4].topLeft.latDec, TrackOverlays[4].topLeft.lonDec);
+		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft.latDec, TrackOverlays[4].topLeft.lonDec);
 		Dimension ws = mmp.getSize(null);
 		int ww = ws.width;
 		int wh = ws.height;
@@ -385,6 +389,18 @@
 			posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
 		}
 		
+		public void setCenterOfScreen (CWPoint c) {
+			moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c);
+		}
+		
+		public void moveScreenXYtoLatLon(Point s, CWPoint c) {
+			Point mappos = getMapPositionOnScreen();
+			Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
+			if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+			mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
+			
+		}
+		
 		public void mapMoved(int diffX, int diffY) {
 			int w = posCircle.getWidth();
 			int h = posCircle.getHeight();
@@ -410,7 +426,7 @@
 		 * but also works if mmp == null and is used to move the map to the correct point
 		 * @return
 		 */
-		public Point getMapXYPosition() {
+		public Point getMapPositionOnScreen() {
 			Point mapPos = new Point(); 
 			//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
 			//else {
@@ -421,16 +437,16 @@
 			return mapPos;
 		}
 
-		public Point getXYinMap(double lat, double lon){
+		public Point getXYonScreen(double lat, double lon){
 			Point coords = currentMap.calcMapXY(lat, lon);
-			Point mapPos = getMapXYPosition();
+			Point mapPos = getMapPositionOnScreen();
 			//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
 			return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 		}
 		
 		public CWPoint ScreenXY2LatLon (int x, int y){
-			Point mapPos = getMapXYPosition();
-			return currentMap.calcLatLon(x-mapPos.x, y-mapPos.y);
+			Point mapPos = getMapPositionOnScreen();
+			return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
 		}
 		
 		public void updateSymbolPositions() {
@@ -443,7 +459,7 @@
 			int w, h;
 			for (int i=symbols.size()-1; i>=0; i--) {
 				symb = (MapSymbol)symbols.get(i);
-				pOnScreen = getXYinMap(symb.lat, symb.lon);
+				pOnScreen = getXYonScreen(symb.lat, symb.lon);
 				w=symb.pic.getWidth();
 				h=symb.pic.getHeight();
 				if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
@@ -463,7 +479,7 @@
 			if (symbols==null) symbols=new Vector();
 			MapSymbol ms = new MapSymbol(name, filename, lat, lon);
 			ms.loadImage();
-			Point pOnScreen=getXYinMap(lat, lon);
+			Point pOnScreen=getXYonScreen(lat, lon);
 			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
 			symbols.add(ms);
 			mmp.addImage(ms.pic);
@@ -474,7 +490,7 @@
 			MapSymbol ms = new MapSymbol(name, " ", lat, lon);
 			ms.pic = imSymb;
 			ms.pic.properties = AniImage.AlwaysOnTop;
-			Point pOnScreen=getXYinMap(lat, lon);
+			Point pOnScreen=getXYonScreen(lat, lon);
 			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
 			symbols.add(ms);
 			mmp.addImage(ms.pic);
@@ -522,11 +538,11 @@
 		 */
 		public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
 			Point mapPos = new Point(0,0);
-			Point oldMapPos = getMapXYPosition();
+			Point oldMapPos = getMapPositionOnScreen();
 			if (lat != -361.0 || lon != -361.0) {
 				posCircleLat = lat;
 				posCircleLon = lon;
-				mapPos = getMapXYPosition();
+				mapPos = getMapPositionOnScreen();
 			}
 			//Vm.debug("mapx = " + mapx);
 			//Vm.debug("mapy = " + mapy);
@@ -548,7 +564,7 @@
 			if(!ignoreGps || forceMapLoad){
 				updateOnlyPosition(lat, lon, true);
 				if (autoSelectMap || forceMapLoad) {
-					Point mapPos = getMapXYPosition();
+					Point mapPos = getMapPositionOnScreen();
 					if (forceMapLoad || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
 							|| 	mmp.mapImage == null )) 	{
 						//Vm.debug("Screen not completly covered by map");
@@ -710,35 +726,58 @@
 		 */
 		public void zoom(Point firstclickpoint, int w, int h) {
 			Vm.showWait(true);
-			int newImageWidth = 1000;
-			int newImageHeight= 1000;
+			int newImageWidth = this.width * 2; // (maximal) size of the zoomed image 
+			int newImageHeight= this.height * 2;
 			CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y+h/2);
 			float zoomFactor;
 			if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
-			else		zoomFactor = java.lang.Math.abs((float)w / (float)this.width);
-			
-			// calculate rect in unzoomed image in a wya that the center of the new image is the center of selected area 
+			else {
+				w = java.lang.Math.abs(w);
+				firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+				zoomFactor = (float)w / (float)this.width;
+			}
+			if (h < 0) {
+				h = java.lang.Math.abs(h);
+				firstclickpoint.y = firstclickpoint.y - h;
+			}
+			// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
 			newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 			newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
-			Point mappos = getMapXYPosition();
-			int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth/2);
-			int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight/2);
+			Point mappos = getMapPositionOnScreen();
+			int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+			int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
 			Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
 			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
 				{
-				if (newImageRect.x < 0) newImageRect.x = 0;
-				if (newImageRect.y < 0) newImageRect.y = 0;
- 				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) newImageRect.width = mapImage1to1.getWidth()-1;
-				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) newImageRect.height= mapImage1to1.getHeight()-1;
-				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) newImageRect.x = 0;
-				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) newImageRect.y = 0;
+				// try to avoid overlapping by shifting
+				if (newImageRect.x < 0) 
+					newImageRect.x = 0; // align left if left overlapping
+				if (newImageRect.y < 0) 
+					newImageRect.y = 0;
+ 				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+ 					newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+					newImageRect.y = mapImage1to1.getHeight()- newImageWidth;
+				// crop if after shifting still overlapping
+				if (newImageRect.x < 0) 
+					newImageRect.x = 0;
+				if (newImageRect.y < 0) 
+					newImageRect.y = 0;
+ 				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+ 					newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+					newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+
 				int saveprop = mmp.mapImage.properties;
-				AniImage tmp = mmp.mapImage;
+				AniImage tmp = null; // = mmp.mapImage;
 				mmp.removeImage(mmp.mapImage);
+				if (mmp.mapImage != mapImage1to1) {
+					mmp.mapImage .free();
+					mmp.mapImage = null;
+				} else tmp = mapImage1to1;
+				Vm.getUsedMemory(true);
 				try {
-					Vm.getUsedMemory(true);
 					tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor*currentMap.zoomFactor), (int)(newImageRect.height*zoomFactor*currentMap.zoomFactor), newImageRect, 0));
-					mmp.mapImage.free();
 					currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 				} catch (OutOfMemoryError e) {Vm.debug(e.toString());}
 				Vm.getUsedMemory(true);
@@ -749,12 +788,14 @@
 				}
 			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
 			{
-				mappos = getMapXYPosition();
+				mappos = getMapPositionOnScreen();
 				mmp.mapImage.move(mappos.x,mappos.y);
 			}
 			//updatePosition(center.latDec, center.lonDec);
+			destroyOverlaySet();
+			setCenterOfScreen(center);
 			addOverlaySet();
-			updateSymbolPositions();
+			//updateSymbolPositions();
 			this.repaintNow();
 			Vm.showWait(false);
 			//CWPoint test = ScreenXY2LatLon(0, 0);
@@ -884,7 +925,7 @@
 		public void doPaint(Graphics g,Rect area) {
 			super.doPaint(g, area);
 			if (mm.gotoPos != null) {
-			Point dest = mm.getXYinMap(mm.gotoPos.lat, mm.gotoPos.lon);
+			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
 			g.setPen(new Pen(Color.MediumBlue, Pen.SOLID, 3));
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
 			}

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-01-13 23:18:06 UTC (rev 387)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-01-14 05:09:23 UTC (rev 388)
@@ -116,9 +116,12 @@
 	}
 
 	public void addPixelIfNeccessary(int x, int y, Color f){
-		int ll =(numPixels<50 ? 0 : numPixels-50); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
-		for (int i=numPixels-1; i>=ll; i--) {
-			if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) return; 
+		if (trackPixels != null) {
+			int ll =(numPixels<50 ? 0 : numPixels-50); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
+			for (int i=numPixels-1; i>=ll; i--) {
+				if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) 
+					{ return; } 
+			}
 		}
 		addPixel(x, y, f);
 	}



From salzkammergut at mail.berlios.de  Sun Jan 14 00:18:24 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 00:18:24 +0100
Subject: [Cachewolf-svn] r387 - trunk/src/CacheWolf
Message-ID: <200701132318.l0DNIOkg002600@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 00:18:06 +0100 (Sun, 14 Jan 2007)
New Revision: 387

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/SolverPanel.java
   trunk/src/CacheWolf/TokenObj.java
   trunk/src/CacheWolf/Tokenizer.java
Log:
Neuer Solver (Infos in Parser.java)
(noch ohne deutsche Fehlermeldungen)

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-13 22:07:59 UTC (rev 386)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-13 23:18:06 UTC (rev 387)
@@ -30,6 +30,7 @@
 	MainMenu mnuMain;
 	
 	public MainTab(MainMenu mainMenu,StatusBar statBar){
+		Global.mainTab=this;
 		mnuMain=mainMenu;
 		pref = Global.getPref();
 		profile=Global.getProfile();

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-13 22:07:59 UTC (rev 386)
+++ trunk/src/CacheWolf/Parser.java	2007-01-13 23:18:06 UTC (rev 387)
@@ -1,601 +1,702 @@
-/*
-A parser that parses and interprets the following grammer:
-program -> command | assign
-command -> 	   show(var) | 
-		   (*) show(expr) |
-		   ( ) project(varN,varE,deg,distance,varNN,varNE) |
-		   (*)  "...text..."
-assign -> 	string = expr | 
-		( ) string = distance(N,E,N,E) | 
-		( ) string = bearing(N,E,N,E) | 
-		( ) string = coord([N|S|E|W DD MM SS] | [N|S|E|W DD MM.mmm] | [N|S|E|W DD.ddd]) // North,East = "+" South,West = "-"
-		( ) string = coordUTM(???) |
-		( ) string = convert2UTM(var) |
-		( ) string = convert2Deg(var)
-expr -> expr + term | 
-		expr - term | 
-		term
-term -> term * factor | 
-		term / factor | 
-		factor
-factor -> number | 
-		  string | 
-		  ( expr ) | 
-		  (*) sqrt ( expr ) | 
-		  (*) ^ expr |
-		  (*) cos() |
-		  (*) sin() |
-		  (*) tan() |
-		  (*) acos() |
-		  (*) asin() |
-		  (*) atan() |
+/* A parser that parses the following grammar:
+  EBNF Meta-Symbols: 
+    {xx}        xx can occur any number of times incl 0
+    [xx]        xx or empty
+    |           or
+    "x"         x is terminal symbol
+
+command -> if |
+           simplecommand
+
+simplecommand -> "stop" | "st" | 
+		   assign
+           stringexp | 
+
+if -> "IF" stringexpr compop stringexpr "THEN" simplecommand { ";" simplecommand } "ENDIF"          // Nested IF's not allowed
+
+compop -> "=" | "<" | ">" | "<=" | "==" | ">=" | "<>" | "!=" | "><"
+
+assign -> ident = [ stringexpr ]
+
+stringexp -> (string | expr ) {string | tailexp }
+
+expr -> ["+" | "-"] tailexp [ formatstring ]
+
+tailexp -> term { ("+" | "-") term } 
 		 
+term -> factor { ("*" | "/") factor }
+
+factor -> expfactor { "^" expfactor }
+
+expfactor -> ident | 
+          number | 
+          "(" stringexpr ")" |
+          function "(" stringexpr { "," stringexpr }")"
+          
+function -> "sin" | "cos" | "tan" | "asin" | "acos" | "atan" | "goto" | "project" | "show"  | "crosstotal" | 
+            "rot13" | "len" | "mid"         
+
+ident -> valid identifier
+number -> valid number
+
+
 */
+
 package CacheWolf;
 
 import ewe.util.*;
 import ewe.sys.*;
+import java.lang.Double;
 
 /**
-*	The wolf language parser. This class needs thorough documentation!
+*	The wolf language parser. New version - January 2007
+*   
+*   New features:
+*   - Improved error handling
+*   - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
+*   - Variables can store strings or doubles
+*   - Global variables (starting with $) are remembered across multiple calls to parser
+*   - Global variables are initialised with "", local variables result in error if used before setting value
+*   - IF statement added
+*   - Many new functions (encode,format,goto,len,mid,substring,ucase,lcase,val,sval,reverse,project)
+*   - less typing
+*   	- Function aliases
+*   	- Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
+*   	- show no longer needed
+*   	- Command terminator ; no longer compulsory (only between multiple commands on same line)
+*   - New functions can easily be added
+*   - Can select whether variable names are case sensitive
+*   
+*   To add a new function:
+*     1) Add its name and alias and allowed number of args to array functions
+*     2) Add a new private method in the "functions" section
+*     3) Add call to private method in executeFunction 
+*   @author salzkammergut January 2007
 */ 
 public class Parser{
 
+	private class fnType { 
+		public String funcName;
+		public String alias;
+		public int nargs;  // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+		fnType(String funcName, String alias, int nargs) {
+			this.funcName=funcName; this.alias=alias; this.nargs=nargs;
+		}
+		boolean nargsValid(int testNargs){
+			return ((1<<testNargs)&this.nargs)!=0;
+		}
+	}
+    fnType[] functions=new fnType[]{ // in alphabetical order
+    	new fnType("acos","acos",2),
+    	new fnType("asin","asin",2),
+    	new fnType("atan","atan",2),
+    	new fnType("cos","cos",2),
+    	new fnType("crosstotal","ct",2),
+    	new fnType("ct","ct",2),
+    	new fnType("encode","encode",8),
+    	new fnType("format","format",6),
+    	new fnType("goto","goto",6),
+    	new fnType("ic","ic",3),
+    	new fnType("ignorecase","ic",3),
+    	new fnType("lcase","lc",2),
+    	new fnType("len","len",2),
+    	new fnType("length","len",2),
+    	new fnType("mid","mid",12),
+    	new fnType("project","project",8),
+    	new fnType("quersumme","ct",2),
+//    	new fnType("requiresemicolon","rs",3),
+    	new fnType("reverse","reverse",2),
+    	new fnType("rot13","rot13",2),
+//    	new fnType("rs","rs",3),
+    	new fnType("show","show",2),
+    	new fnType("sin","sin",2),
+    	new fnType("substring","substring",12),
+    	new fnType("sval","sval",2),
+    	new fnType("tolowercase","lc",2),
+    	new fnType("touppercase","uc",2),
+    	new fnType("tan","tan",2),
+    	new fnType("ucase","uc",2),
+    	new fnType("val","val",2)
+    	};
 	private static int scanpos = 0;
-	Vector TokenStack = new Vector();
-	Vector CalcStack = new Vector();
-	Vector MessageStack = new Vector();
+	CWPoint cwPt=new CWPoint();
+	Vector calcStack=new Vector();
 	Hashtable symbolTable = new Hashtable(50);
 	TokenObj thisToken = new TokenObj();
-	boolean runFlag = true;
-	String emit_buffer = new String();
+	Vector tokenStack;
+	Vector messageStack;
 	
 	public Parser(){
-		
 	}
 
-	public Parser(Vector tck){
-		TokenStack = tck;
+///////////////////////////////////////////
+//  Utility functions
+///////////////////////////////////////////
+	
+	/* All errors are handled via function 'err'. Rather than creating many different Exceptions,
+	 * only the standard Exception is used. err raises this exception and thereby causes the stack to be
+	 * unwound until 'parse' eventually catches the exception and returns to SolverPanel, which displays
+	 * the messageStack containing the error message.
+	 */
+	
+	/** 
+     * Add an error message to the message stack and raise an Exception.
+    */
+	private void err(String str) throws Exception {
+    	messageStack.add("Error on line: " + thisToken.line + " position: " + thisToken.position);
+    	messageStack.add(str);
+    	throw new Exception("Error "+str);
+    }
+    
+    /** Clears the symbol table of all non-global symbols (those not starting with $) */
+    private void clearLocalSymbols() {
+    	Iterator it=symbolTable.entries();
+    	while (it.hasNext()) {
+    		if (((String)((ewe.util.Map.MapEntry) it.next()).getKey()).startsWith("$")) 
+    			symbolTable.remove(it);
+    	}
+    }
+    
+	private boolean isVariable(String varName) {
+		return varName.startsWith("$") ||  // Global variables exist per default 
+		       symbolTable.containsKey(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
 	}
-
-	public void setTockenStack(Vector tck){
-		TokenStack = new Vector();
-		CalcStack = new Vector();
-		MessageStack = new Vector();
-		symbolTable = new Hashtable(50);
-		thisToken = new TokenObj();
-		scanpos = 0;
-		runFlag = true;
-		TokenStack = tck;
-	}
 	
-	public void testSymbolTable(){
-		symbolTable.put("A", "12");
-		symbolTable.put("B", "13");
-		symbolTable.put("C", "14");
+	private boolean isInteger(double d) {
+		return java.lang.Math.ceil(d)==d && java.lang.Math.floor(d)==d;
 	}
 	
-	public void parse(){
-		try{
-		  parseprogram();
-		}catch(Exception ex){
-			////Vm.debug(ex.toString());
+    private boolean isValidCoord(String coord) {
+    	cwPt.set(coord);
+    	return cwPt.isValid();
+    }
+    
+	private Object getVariable(String varName) throws Exception {
+		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+		if(result == null) {
+			// If it is a global variable, add it with a default value
+			if (varName.startsWith("$")) {
+				result="";
+				symbolTable.put(varName,"");
+			} else
+				err ("Variable not defined: "+varName);
 		}
+		return result;
 	}
 	
-	public Vector getMessages(){
-		return MessageStack;
+	private Double getNumber(String str) throws Exception {
+		java.lang.Double ret=null;
+		try {
+			if (Global.getPref().digSeparator.equals(","))	str = str.replace('.', ',');
+			ret=new java.lang.Double(java.lang.Double.parseDouble(str));
+		} catch (NumberFormatException e) {
+			err("Not a valid number: " + str);
+		}
+		return ret;
 	}
 	
-	private void getToken(){
-		if(scanpos < TokenStack.size() && runFlag == true){
-			thisToken = (TokenObj)TokenStack.get(scanpos);
-			////Vm.debug(thisToken.token);
-			scanpos++;
-		}
-	}
-		
-	private boolean match(String str){
-		getToken();
-		////Vm.debug("Matching: " + str + " with " +thisToken.token);
-		if(thisToken.token.equals(str)){
-			////Vm.debug("Match ok!");
-			return true;
+	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
+	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
+		double num;
+		if (calcStack.get(calcStack.size()-1) instanceof String) {
+			if (((String)calcStack.get(calcStack.size()-1)).equals(""))
+				num=defaultForEmptyString;
+			else	
+				num = getNumber((String)calcStack.get(calcStack.size()-1)).doubleValue();
 		} else {
-			if(str.equals(";")) str = ";";
-			////Vm.debug("Error");
-			err("# Error: expected " + str + " on line: " + thisToken.line + " position: " + thisToken.position);
-			return false;
+			num = ((java.lang.Double)calcStack.get(calcStack.size()-1)).doubleValue();
 		}
+		calcStack.removeElementAt(calcStack.size()-1);
+		return num;	
 	}
 	
-	private void err(String str){
-		emit(str);
-		runFlag = false;
+	private String popCalcStackAsString() {
+		String s;
+		if (calcStack.get(calcStack.size()-1) instanceof Double) {
+			s = ((java.lang.Double)calcStack.get(calcStack.size()-1)).toString();
+			if (Global.getPref().digSeparator==",") s.replace(',','.'); // always show numbers with decimal point
+			if (s.endsWith(".0")) s=s.substring(0,s.length()-2);
+		} else
+			s = (String)calcStack.get(calcStack.size()-1);
+		calcStack.removeElementAt(calcStack.size()-1);
+		return s;	
 	}
 	
-	private void emit(String str){
-		MessageStack.add(str);
+	private void getToken() throws Exception {
+		if(scanpos < tokenStack.size()){
+			thisToken = (TokenObj)tokenStack.get(scanpos);
+			//Vm.debug(thisToken.token);
+			scanpos++;
+		} else err("Unexpected end of source");
 	}
+
+	private void getNextTokenOtherThanSemi() throws Exception {
+		do {
+			getToken();
+		} while (thisToken.token.equals(";"));	
+	}
+
+	private void skipPastEndif() throws Exception {
+		while(scanpos < tokenStack.size()){
+			thisToken = (TokenObj)tokenStack.get(scanpos);
+			scanpos++;
+			if (thisToken.tt==TokenObj.TT_ENDIF) {
+				getToken();
+				return;
+			}
+		}
+		err("Missing ENDIF");
+	}
+	private TokenObj lookAheadToken() {
+		return (TokenObj)tokenStack.get(scanpos);
+	}
 	
-	private void parseCommand(){
-		boolean foundCommand = false;
-		////Vm.debug("In command");
-		getToken();
-//Vm.debug(thisToken.token);
-		if(thisToken.token.equals("project")){
-			foundCommand = true;
-			if(runFlag) match("(");
-			
-			if(runFlag) match(")");
+	private boolean checkNextSymIs(String str) throws Exception {
+		if(thisToken.token.toUpperCase().equals(str)){
+			return true;
+		} else {
+			err("Expected " + str + "  Found: "+thisToken.token);
+			return false; //Dummy as err does not return
 		}
-		if(thisToken.token.equals("st")){
-			foundCommand = true;
-			runFlag = false;
+	}
+
+	private fnType getFunctionDefinition(String str) throws Exception {
+    	fnType fnd=null;
+    	for (int i=functions.length-1; i>=0; i--) {
+    		if (functions[i].funcName.startsWith(str)) {
+    			if (fnd!=null) err("Ambiguous function name: "+str);
+    			fnd=functions[i];
+    		}
+    	}
+    	if (fnd==null) err("Unknown function: "+str);
+    	return fnd;
+    }
+
+///////////////////////////////////////////
+//  FUNCTIONS
+///////////////////////////////////////////
+    
+    private double funcCrossTotal(double a) {
+		// Cross total = Quersumme berechnen
+		String aString = Convert.toString(a); // 
+		// bei 1.8e2 nur 1.8 verwenden 
+		if (aString.toLowerCase().indexOf("e") > 0) aString = aString.substring(0, aString.toLowerCase().indexOf("e"));
+		a=0;
+		for (int i=0; i<aString.length(); i++) {
+		 a += Convert.toDouble(Convert.toString(aString.charAt(i)));	
 		}
-		if(thisToken.token.equals("stop")){
-			foundCommand = true;
-			runFlag = false;
-		}
-		if(thisToken.token.equals("rot")){
-			foundCommand=true;
-			if(runFlag) match("13");
-			if(runFlag) match("(");
-			if(runFlag) match("\"");
-			getToken(); // Empty why
+   	    return a;
+    }
+    
+    /**
+     * Encode a string by replacing all characters in a string with their corresponding characters in
+     * another string
+     * @throws Exception
+     */
+    private String funcEncode() throws Exception {
+    	String newChars=popCalcStackAsString();
+    	String oldChars=popCalcStackAsString();
+    	if (newChars.length()!=oldChars.length()) err("Replacement characters strings must be of equal length");
+    	String s=popCalcStackAsString();
+    	String encodedStr="";
+    	for (int i=0; i<s.length(); i++) {
+    		int pos;
+    		if ((pos=oldChars.indexOf(s.charAt(i)))!=-1) {
+    			encodedStr+=newChars.charAt(pos);
+    		} else 
+    			encodedStr+=s.charAt(i);
+    	}
+    	 return encodedStr;
+    }
+    
+    /** Format a valid coordinate 
+     *  If called with one args, format the argument on the stack to CW standard
+     *  The optional second argument is one of these strings "UTM","DMS","DD","DMM" or "CW"
+     * @param nargs 1 or 2 args
+     */
+    private String funcFormat(int nargs) throws Exception {
+    	String fmtStr="";
+    	if (nargs==2)fmtStr=popCalcStackAsString().toLowerCase();
+    	String coord=popCalcStackAsString();
+		if (!isValidCoord(coord)) err("Invalid coordinate: "+coord);
+    	cwPt.set(coord);
+    	int fmt=CWPoint.CW;
+    	if (fmtStr.equals("dd")) fmt=CWPoint.DD;
+    	else if (fmtStr.equals("dmm")) fmt=CWPoint.DMM;
+    	else if (fmtStr.equals("dms")) fmt=CWPoint.DMS;
+    	else if (fmtStr.equals("utm")) fmt=CWPoint.UTM;
+    	else if (!fmtStr.equals("cw")) err("Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM");
+    	return cwPt.toString(fmt);
+    }
+    
+    /** Implements a goto command goto(coordinate,optionalWaypointName).
+     */
+    private void funcGoto(int nargs) throws Exception {
+    	GotoPanel gotoP=Global.mainTab.gotoP;
+		String waypointName=null;
+        if (nargs==2) waypointName=popCalcStackAsString();  
+		String coord=popCalcStackAsString();
+		if (!isValidCoord(coord)) err("Invalid coordinate: "+coord);
+		// Don't want to switch to goto panel, just set the values
+		gotoP.toPoint.set(coord);
+		gotoP.btnGoto.setText(gotoP.toPoint.toString(gotoP.currFormat));
+		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
+    		int i=Global.getProfile().getCacheIndex(waypointName);
+    		if (i<0) err("Goto: Waypoint does not exist: "+waypointName);
+    		cwPt.set(coord);
+    		((CacheHolder)Global.getProfile().cacheDB.get(i)).LatLon=cwPt.toString(CWPoint.CW);
+    	}
+    }
+    
+    private void funcIgnoreVariableCase(int nargs) throws Exception {
+    	if (nargs==0) 
+    		calcStack.add(""+Global.getPref().solverIgnoreCase);
+    	else {
+    		Global.getPref().solverIgnoreCase=(popCalcStackAsNumber(0)!=0)?true:false;
+    	}
+    }
+    
+    private String funcMid(int nargs) throws Exception {
+    	if (nargs==2) {
+        	double start=popCalcStackAsNumber(0);
+    		String s=popCalcStackAsString();
+    		if (!isInteger(start)) err("mid: Integer argument expected");
+    		if (start<1 || start>s.length()) err("mid: Argument out of range");
+    		return s.substring((int)start-1);
+    	} else {
+        	double len=popCalcStackAsNumber(0);
+        	double start=popCalcStackAsNumber(0);
+    		String s=popCalcStackAsString();
+    		if (!isInteger(start) || !isInteger(len)) err("mid: Integer argument expected");
+    		int end=(int)(start+len-1);
+    		if (start>s.length() || start<1 || end>s.length()) err("mid: Argument out of range");
+    		return s.substring((int)start-1,end);
+    	}
+    }
+    
+    /** Project a waypoint at some angle and some distance */
+    private String funcProject() throws Exception {
+    	double distance=popCalcStackAsNumber(0);
+    	if (distance<0) err("Cannot project a negative distance");
+    	double degrees=popCalcStackAsNumber(0);
+    	if (degrees<0 || degrees>360) err("Projection degrees must be in interval [0;360]");
+    	String coord=popCalcStackAsString();
+		if (!isValidCoord(coord)) err("Invalid coordinate: "+coord);
+    	cwPt.set(coord);
+    	return cwPt.project(degrees,distance/1000.0).toString();
+    }
+
+    private String funcReverse(String s) {
+    	String res="";
+    	for (int i=s.length()-1; i>=0; i--) res+=s.charAt(i);
+    	return res;
+    }
+    
+    /*   private void funcRequireSemicolon(int nargs) throws Exception {
+	if (nargs==0) 
+		calcStack.add(""+Global.getPref().solverRequireSemicolon);
+	else {
+		Global.getPref().solverRequireSemicolon=(popCalcStackAsNumber(0)!=0)?true:false;
+	}
+}
+*/    
+    private String funcSubstring(int nargs) throws Exception {
+    	if (nargs==2) {
+        	double start=popCalcStackAsNumber(0);
+    		String s=popCalcStackAsString();
+    		if (!isInteger(start)) err("substring: Integer argument expected");
+    		if (start<0 || start>s.length()) err("substring: Argument out of range");
+    		return s.substring((int)start);
+    	} else {
+        	double end=popCalcStackAsNumber(0);
+        	double start=popCalcStackAsNumber(0);
+    		String s=popCalcStackAsString();
+    		if (!isInteger(start) || !isInteger(end)) err("substring: Integer argument expected");
+    		if (start<0 || start>s.length() || start>end || end>s.length()) err("substring: Argument out of range");
+    		return s.substring((int)start,(int)end);
+    	}
+    }
+    
+    private String funcSval(String s) {
+       	s=s.toLowerCase();
+    	String res="";
+       	for (int i=0; i<s.length(); i++) {
+    		int pos="abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i));
+    		if (pos>=0) 
+    			res+=(res==""?"":" ")+MyLocale.formatLong(pos+1,"00");
+    	}
+    	return res;
+    }
+    
+    private double funcVal(String s) {
+    	s=s.toLowerCase();
+    	int sum=0;
+    	for (int i=0; i<s.length(); i++) {
+    		sum+="abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i))+1;
+    	}
+    	return sum;
+    }
+    
+///////////////////////////////////////////
+//  PARSER
+///////////////////////////////////////////
+   
+    
+    /** The following methods implement a recursive descent parser.
+     * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
+     * a valid token.
+     */
+ 
+	private void parseCommand()  throws Exception {
+		while(scanpos < tokenStack.size()) {
 			getToken();
-//ewe.sys.Vm.debug(thisToken.token);	
-			emit_buffer = emit_buffer + Common.rot13(thisToken.token);
-			getToken();
-			if(runFlag) match(")");
-			getToken();
-			if(thisToken.token.equals(";")) {
-				////Vm.debug("In thing: " + emit_buffer);
-				emit(emit_buffer);
-				emit_buffer = "# ";
-			} else scanpos--;
-			////Vm.debug("!" + ")");
+			if (thisToken.token.equals(";")) continue;  // skip an empty command
+			if (thisToken.tt==TokenObj.TT_IF) 
+				parseIf();
+			else 
+				parseSimpleCommand();
+			checkNextSymIs(";");
+			while (calcStack.size()>0) messageStack.add(popCalcStackAsString());
 		}
+	}
 
-		if(thisToken.token.equals("show")){
-			foundCommand = true;
-			////Vm.debug("Got a show");
-			////Vm.sleep(1500);
-			if(runFlag) match("(");
-			String result = new String();
-			getToken(); // gettin the '(';
-			// do a lookahead for a ')'
-			getToken();
-			////Vm.debug("-->: " + thisToken.token);
-			if(thisToken.token.equals(")")){ // ok we have a variable
-				//reset to old position
-				scanpos--;
-				scanpos--;
-				getToken();
-				if(runFlag) result = (String)symbolTable.get(thisToken.token);
-				if(result != null){
-					result.trim();
-					result = STRreplace.replace(result, ".0", "");
-					result = STRreplace.replace(result, ",0", "");
-					emit_buffer = emit_buffer + result;
-				} else {
-					err("# Error: Variable " +thisToken.token+ " not defined");
-				}
-				
-			} else { // not a variable, we should have an expression
-				////Vm.debug("Going to parse expression!");
-				
-				scanpos--;
-				scanpos--;
-				////Vm.debug("**" + thisToken.token);
-				////Vm.debug("runflag: " + Convert.toString(runFlag));
-				//////Vm.sleep(500);
-				////Vm.debug("in the show and parsexpr");
-				////Vm.sleep(1500);
-				if(runFlag) parseExpr();
-				
-				
-				java.lang.Double a = new java.lang.Double(0);
-				if(runFlag) {
-					a = (java.lang.Double)(CalcStack.get(CalcStack.size()-1));
-					CalcStack.removeElementAt(CalcStack.size()-1);
-				}
-				String stra = a.toString();
-				stra.trim();
-				stra = STRreplace.replace(stra, ",0", "");
-				stra = STRreplace.replace(stra, ".0", "");
-				emit_buffer = emit_buffer + stra;
-				
+	private void parseSimpleCommand() throws Exception{
+		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception("STOP");  // Terminate without error message
+		if (thisToken.tt==TokenObj.TT_VARIABLE && lookAheadToken().tt==TokenObj.TT_EQ) 
+			parseAssign();
+		else 
+			parseStringExp();		
+	}
+	
+	private void parseIf() throws Exception{
+		int compOp;
+		boolean compRes=false;
+		getToken();
+		parseStringExp();
+		compOp=thisToken.tt;
+		if (compOp<TokenObj.TT_LT || compOp>TokenObj.TT_NE) err("Comparison operator expected");
+		getToken();
+		parseStringExp();
+		checkNextSymIs("THEN");
+		getNextTokenOtherThanSemi();
+		// If the first expression is a string, compare as string.
+		if (calcStack.get(calcStack.size()-2) instanceof String) {
+			String b=popCalcStackAsString();
+			String a=popCalcStackAsString();
+			switch (compOp) {
+				case TokenObj.TT_EQ: compRes=a.equals(b); break;
+				case TokenObj.TT_NE: compRes=!a.equals(b); break;
+				case TokenObj.TT_LT: compRes=a.compareTo(b)<0; break;
+				case TokenObj.TT_GT: compRes=a.compareTo(b)>0; break;
+				case TokenObj.TT_LE: compRes=a.compareTo(b)<=0; break;
+				case TokenObj.TT_GE: compRes=a.compareTo(b)>=0; break;
 			}
-			if(runFlag) match(")");
-			getToken();
-			if(thisToken.token.equals(";")){
-				////Vm.debug("In show: " + emit_buffer);
-				emit(emit_buffer);
-				emit_buffer = "# ";
-				scanpos--;
-				match(";");
-			} else scanpos--;
+		} else { // First expression is a number, compare as numbers
+			double b=popCalcStackAsNumber(0);
+			double a=popCalcStackAsNumber(0);
+			switch (compOp) {
+				case TokenObj.TT_EQ: compRes=a==b; break;
+				case TokenObj.TT_NE: compRes=a!=b; break;
+				case TokenObj.TT_LT: compRes=a<b; break;
+				case TokenObj.TT_GT: compRes=a>b; break;
+				case TokenObj.TT_LE: compRes=a<=b; break;
+				case TokenObj.TT_GE: compRes=a>=b; break;
+			}
 		}
-		if(thisToken.token.equals("\"") && foundCommand == false){
-			foundCommand = true;
-			getToken();
-			while(!thisToken.token.equals("\"")){
-				emit_buffer = emit_buffer + thisToken.token;
-				getToken();
+		if (compRes) { // comparison resulted in TRUE
+			if (thisToken.tt!=TokenObj.TT_ENDIF) {
+				parseSimpleCommand();
+				while (thisToken.token.equals(";")) {
+					getNextTokenOtherThanSemi(); // Now we have either an ENDIF or the start of a simpleexpression
+					if (thisToken.tt==TokenObj.TT_ENDIF) break;
+					parseSimpleCommand();
+				}
+				checkNextSymIs("ENDIF");
 			}
 			getToken();
-			if(thisToken.token.equals(";")) {
-				////Vm.debug("In thing: " + emit_buffer);
-				emit(emit_buffer);
-				emit_buffer = "# ";
-			} else scanpos--;
-		}
-		if(foundCommand == false) scanpos--;
-	}	
+		} else // comparison failed
+			skipPastEndif();
+	}
 	
-	public boolean IsAlpha(String c){
-		//check for reserved words
-		if(c.equals("show")) c = "-1";
-		if(c.equals("st")) c = "-1";
-		if(c.equals("stop")) c = "-1";
-		if(c.equals("rot")) c = "-1";
-		c = c.toUpperCase();
-		char ch = c.charAt(0);
-		if("ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(ch) != -1) return true;
-		else return false;
+	private void parseAssign() throws Exception  {
+		String varName=new String(thisToken.token);
+		getToken(); //=
+		getToken();
+		// Assigns of the format A=; are ignored so that they can stay as placeholders and 
+		// we can fill the data progressively during a multicache
+		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(";")) return;
+		parseStringExp();
+		symbolTable.put(varName, popCalcStackAsString());
 	}
 	
-	public boolean IsDigit(String c){
-		//java.lang.Double test;
-		boolean code = false;
-		try {
-			//Vm.debug(""+c);
-			//Vm.sleep(500);
-			//test = java.lang.Double.valueOf(c);
-			Convert.parseDouble(c);
-			code = true;
-		} catch (NumberFormatException e){
-			////Vm.debug("Throwing an exeption");
-			//////Vm.sleep(500);
-			code = false;
+	private void parseStringExp()throws Exception {
+		if (thisToken.tt==TokenObj.TT_STRING) {
+			calcStack.add(thisToken.token);
+			getToken();
+		} else {
+			parseExp();
 		}
-		return code;
+		//calcStack.add(popCalcStackAsString());
+		while (thisToken.tt==TokenObj.TT_STRING || 
+			   thisToken.tt==TokenObj.TT_NUMBER || 
+			   thisToken.tt==TokenObj.TT_VARIABLE ||
+			   thisToken.tt==TokenObj.TT_SYMBOL && thisToken.token.equals("(")) {
+			if (thisToken.tt==TokenObj.TT_STRING) {
+				calcStack.add(thisToken.token);
+				getToken();
+			} else {
+				parseTailExp('+');
+			}
+			String b=popCalcStackAsString();
+			String a=popCalcStackAsString();
+			calcStack.add(a+b);
+		}
 	}
 	
-	private void parseAssign(){
-		////Vm.debug("In assign");
-		java.lang.Double a = new java.lang.Double(0);
-		boolean foundAssign = false;
-		getToken();
-		if(IsAlpha(thisToken.token)){
-			foundAssign = true;
-			String thisVar = new String();
-			thisVar = thisToken.token;
-			////Vm.debug("pos: " + scanpos);
-			if(runFlag) match("=");
+	private void parseExp()throws Exception {
+		char unaryOp='+';
+		if (thisToken.token.equals("+") || thisToken.token.equals("-") ) {
+			unaryOp=thisToken.token.charAt(0);
 			getToken();
-				scanpos--; // because of the getToken above!
-				if(runFlag) parseExpr();
-				if(runFlag){
-					//Vm.debug("This should be the crack!");
-					//Vm.sleep(1500);
-					a = (java.lang.Double)(CalcStack.get(CalcStack.size()-1));
-					CalcStack.removeElementAt(CalcStack.size()-1);
-				}
-				//Vm.debug("This should be a: " + a);
-				symbolTable.put(thisVar, a.toString());
-			//}
-			if(runFlag) match(";");
 		}
-		if(foundAssign == false) scanpos--;
+		parseTailExp(unaryOp);
 	}
-	
-	private void parseExpr(){
-		//Vm.debug("in parseexpr");
-		////Vm.sleep(1500);
-		boolean foundExpr = false;
-		boolean doit = true;
+
+	private void parseTailExp(char unaryOp)throws Exception {
 		parseTerm();
-		////Vm.debug("Back from term");
-		//////Vm.sleep(500);
-		while(doit){
+		if (unaryOp=='-') { // Unary minus, negate the first term
+			calcStack.add(new java.lang.Double(-popCalcStackAsNumber(0)));
+		}
+		while (thisToken.token.equals("+") || thisToken.token.equals("-") ) {
+			char op=thisToken.token.charAt(0);
 			getToken();
-			doit = false;	
-			foundExpr = false;
-			/*
-			for(int i = 0; i< CalcStack.size(); i++){
-					////Vm.debug("Calcstack: " + CalcStack.get(i));
-				}*/
-			if(thisToken.token.equals("+")){
-				foundExpr = true;
-				parseTerm();
-				java.lang.Double a = new java.lang.Double(0);
-				java.lang.Double b = new java.lang.Double(0);
-				double c;
-				//Vm.debug("We are here!");
-				////Vm.sleep(1500);
-				a = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				//Vm.debug("first var: " + a.toString());
-				////Vm.sleep(1500);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				b = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				//Vm.debug("second var: " + b.toString());
-				////Vm.sleep(1500);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				c = a.doubleValue() + b.doubleValue();
-				//Vm.debug("A:: " + c);
-				//Vm.sleep(1500);
-				CalcStack.add(new java.lang.Double(c));
-				//Vm.debug("!" + "+");
-				//Vm.sleep(1500);
-				doit = true;
-				
-			}
-			if(thisToken.token.equals("-") && foundExpr == false){
-				foundExpr = true;
-				parseTerm();
-				java.lang.Double a = new java.lang.Double(0);
-				java.lang.Double b = new java.lang.Double(0);
-				double c;
-				b = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				a = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				c = a.doubleValue() - b.doubleValue();
-				//Vm.debug("B:: " + c);
-				//Vm.sleep(1500);
-				CalcStack.add(new java.lang.Double(c));
-				doit = true;
-			}
+			parseTerm();
+			double b=popCalcStackAsNumber(0);
+			double a=popCalcStackAsNumber(0);
+			if (op=='+')
+				calcStack.add(new java.lang.Double(a+b));
+			else
+				calcStack.add(new java.lang.Double(a-b));
 		}
-		if(foundExpr == false) scanpos--;
-	}	
+		// If expression is followed by a formatstring, format it
+		if (thisToken.tt==TokenObj.TT_FORMATSTR) {
+			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0),thisToken.token).replace(',','.'));
+			getToken();
+		}
+	}
 	
-	private void parseTerm(){
-		//Vm.debug("In parseterm");
-		////Vm.sleep(1500);
-		boolean foundTerm = false;
-		boolean doit = true;
+	private void parseTerm() throws Exception{
 		parseFactor();
-		//Vm.debug("Back from factor");
-		//Vm.sleep(500);
-		while(doit){
-			doit = false;
-			foundTerm = false;
+		while (thisToken.token.equals("*") || thisToken.token.equals("/") ) {
+			char op=thisToken.token.charAt(0);
 			getToken();
-			if(thisToken.token.equals("*")){
-				foundTerm = true;
-				parseFactor();
-				java.lang.Double a = new java.lang.Double(0);
-				java.lang.Double b = new java.lang.Double(0);
-				double c;
-				a = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				b = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				c = a.doubleValue() * b.doubleValue();
-				//Vm.debug("D:: " + c);
-				//Vm.sleep(1500);
-				CalcStack.add(new java.lang.Double(c));
-				////Vm.debug("!" + "*");
-				doit = true;
-			}
-			if(thisToken.token.equals("/") && foundTerm == false){
-				foundTerm = true;
-				parseFactor();
-				java.lang.Double a = new java.lang.Double(0);
-				java.lang.Double b = new java.lang.Double(0);
-				double c;
-				b = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				a = (java.lang.Double)CalcStack.get(CalcStack.size()-1);
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				c = a.doubleValue() / b.doubleValue();
-				//Vm.debug("D:: " + c);
-				//Vm.sleep(1500);
-				CalcStack.add(new java.lang.Double(c));
-				////Vm.debug("!" + "/");
-				doit = true;
-			}
-			if(thisToken.token.equals("^") && foundTerm == false){
-				foundTerm = true;
-				parseFactor();
-				double a,b,c;
-				b = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-				CalcStack.removeElementAt(CalcStack.size()-1);
-				c = java.lang.Math.pow(a,b);
-				//Vm.debug("E:: " + c);
-				//Vm.sleep(1500);
-				CalcStack.add(new java.lang.Double(c));
-				////Vm.debug("!" + "/");
-				doit = true;
-			}
+			parseFactor();
+			double b=popCalcStackAsNumber(1);
+			double a=popCalcStackAsNumber(1);
+			if (op=='*')
+				calcStack.add(new java.lang.Double(a*b));
+			else
+				if (b==0.0) 
+					err("Division by 0");
+				else 
+					calcStack.add(new java.lang.Double(a/b));
 		}
-		if(foundTerm == false) scanpos--;
 	}
 	
-	private void parseFactor(){
-		//Vm.debug("In parsefactor");
-		boolean foundFactor = false;
-		getToken();
-		//Vm.debug("**" + thisToken.token);
-		////Vm.sleep(1500);
-		if(thisToken.token.equals("sqrt")){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			a = java.lang.Math.sqrt(a);
-			//Vm.debug("F:: " + a);
-			//Vm.sleep(1500);
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
+	private void parseFactor() throws Exception{
+		parseExpFactor();
+		while (thisToken.token.equals("^")) {
+			getToken();
+			parseExpFactor();
+			double exp=popCalcStackAsNumber(0);
+			double base=popCalcStackAsNumber(0);
+			calcStack.add(new java.lang.Double(java.lang.Math.pow(base,exp)));
 		}
-		if(thisToken.token.equals("cos") && foundFactor == false){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			a = java.lang.Math.cos(a);
-			//Vm.debug("G:: " + a);
-			//Vm.sleep(1500);
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
-		}
-		if(thisToken.token.equals("sin") && foundFactor == false){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			a = java.lang.Math.sin(a);
-			//Vm.debug("H:: " + a);
-			//Vm.sleep(1500);
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
-		}
-		if(thisToken.token.equals("tan") && foundFactor == false){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			a = java.lang.Math.tan(a);
-			//Vm.debug("i:: " + a);
-			//Vm.sleep(1500);
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
-		}		
-		if(thisToken.token.equals("asin") && foundFactor == false){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			a = java.lang.Math.asin(a);
-			//Vm.debug("J:: " + a);
-			//Vm.sleep(1500);
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
-		}
-		if(thisToken.token.equals("acos") && foundFactor == false){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			a = java.lang.Math.acos(a);
-			//Vm.debug("K:: " + a);
-			//Vm.sleep(1500);
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
-		}
-		if(thisToken.token.equals("atan") && foundFactor == false){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			a = java.lang.Math.atan(a);
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
-		}
+	}
 
-		if(thisToken.token.equals("crosstotal") && foundFactor == false){
-			foundFactor = true;
-			if(runFlag) match("(");
-			parseExpr();
-			double a;
-			a = ((java.lang.Double)CalcStack.get(CalcStack.size()-1)).doubleValue();
-			CalcStack.removeElementAt(CalcStack.size()-1);
-			// Cross total = Quersumme berechnen
-			String aString = Convert.toString(a); // 
-			// bei 1.8e2 nur 1.8 verwenden 
-			if (aString.toLowerCase().indexOf("e") > 0) aString = aString.substring(0, aString.toLowerCase().indexOf("e"));
-			a=0;
-			for (int i=0; i<aString.length(); i++) {
-			 a += Convert.toDouble(Convert.toString(aString.charAt(i)));	
-			}
-			CalcStack.add(new java.lang.Double(a));
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
+	private void parseExpFactor() throws Exception {
+		fnType funcDef;
+		if (thisToken.tt==TokenObj.TT_VARIABLE) {
+			if (isVariable(thisToken.token))
+				calcStack.add(getVariable(thisToken.token));
+			else if (!lookAheadToken().token.equals("(")) err("Variable not set: "+thisToken.token);
+			else {// Must be a function definition
+				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
+				parseFunction(funcDef);
+			} 
+		} else if (thisToken.tt==TokenObj.TT_NUMBER) {
+			calcStack.add(getNumber(thisToken.token));
+		} else if (thisToken.tt==TokenObj.TT_STRING) {
+			calcStack.add(thisToken.token);
+		} else if (thisToken.token.equals("(")) {
+			getToken();
+			parseStringExp();
+			checkNextSymIs(")");
 		}
-		
-		if(thisToken.token.equals("(") && foundFactor == false){
-			foundFactor = true;
-			parseExpr();
-			if(runFlag) match(")");
-			////Vm.debug("!" + ")");
-		}
-		if(IsAlpha(thisToken.token) && foundFactor == false){
-			String result = new String();
-			foundFactor = true;
-			result = (String)symbolTable.get(thisToken.token);
-			if(result != null){
-				try {
-					java.lang.Double test;
-					//result = replace(result, ".", ",");
-					////Vm.debug("testing var" + result);
-					////Vm.sleep(1500);
-					test = java.lang.Double.valueOf(result);
-					////Vm.debug("going to add var" + result);
-					////Vm.sleep(1500);
-					//Vm.debug("l:: " + test);
-					//Vm.sleep(1500);
-					CalcStack.add(test);
-					//Vm.debug("test good");
-					//Vm.sleep(1500);
-				} catch (NumberFormatException e){}
-			} else {
-				err("# Error: Variable " +thisToken.token+ " not defined");
+		else err("Unexpected character(s): "+thisToken.token);
+		getToken();
+	}
+	
+	private void parseFunction(fnType funcDef) throws Exception {
+		String funcName=new String(thisToken.token);
+        int nargs=0;
+		getToken();
+		checkNextSymIs("(");
+		getToken();
+		if (!thisToken.token.equals(")")) { // at least one argument
+			parseStringExp();
+			nargs=1;
+			while (thisToken.token.equals(",")) {
+				if (nargs==4) err("Too many arguments for function "+funcName);
+				getToken();
+				parseStringExp(); 
+				nargs++;
 			}
-			
+			checkNextSymIs(")");
 		}
-		////Vm.debug("going to test if digit?");
-		////Vm.sleep(1500);
-		if(IsDigit(thisToken.token) && foundFactor == false){
-			java.lang.Double test;
-			try {
-				////Vm.debug("testing isdigit: " +thisToken.token);
-				////Vm.sleep(1500);
-				test = java.lang.Double.valueOf(thisToken.token);
-				//Vm.debug("m:: " + test);
-				//Vm.sleep(1500);
-				CalcStack.add(test);
-			} catch (NumberFormatException e){}
-			foundFactor = true;
-		}
-		if(foundFactor == false) err("# Error: Expected a number,variable or function function on line: " + thisToken.line + " position: " + thisToken.position);
-		//Vm.debug("And out of parsfactor...");
-		//Vm.sleep(500);
+		//getToken(); done in parseFactor
+		executeFunction(funcName,nargs,funcDef);
 	}
-		
-	private void parseprogram(){
-		emit_buffer = "# ";
-		while(scanpos < TokenStack.size() && runFlag == true){
-			////Vm.debug("In PP: " + scanpos);
-			if(runFlag) parseCommand();
-			if(runFlag) parseAssign();
-			if(scanpos == TokenStack.size()-1) runFlag = false;
+	
+	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
+		if (!funcDef.nargsValid(nargs)) err("Invalid number of arguments");
+	         if (funcDef.alias.equals("asin")) calcStack.add(new java.lang.Double(java.lang.Math.asin(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(java.lang.Math.acos(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("atan")) calcStack.add(new java.lang.Double(java.lang.Math.atan(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("encode")) calcStack.add(funcEncode());
+	    else if (funcDef.alias.equals("format")) calcStack.add(funcFormat(nargs));
+	    else if (funcDef.alias.equals("goto")) funcGoto(nargs);
+	    else if (funcDef.alias.equals("ic")) funcIgnoreVariableCase(nargs);
+	    else if (funcDef.alias.equals("lc")) calcStack.add(popCalcStackAsString().toLowerCase());
+	    else if (funcDef.alias.equals("len")) calcStack.add(new Double(popCalcStackAsString().length()));
+	    else if (funcDef.alias.equals("mid")) calcStack.add(funcMid(nargs));
+	    else if (funcDef.alias.equals("project")) calcStack.add(funcProject());     
+	    else if (funcDef.alias.equals("reverse")) calcStack.add(funcReverse(popCalcStackAsString()));
+	    else if (funcDef.alias.equals("rot13")) calcStack.add(Common.rot13(popCalcStackAsString()));
+//	    else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);
+	    else if (funcDef.alias.equals("show"));
+	    else if (funcDef.alias.equals("sin")) calcStack.add(new java.lang.Double(java.lang.Math.sin(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("substring")) calcStack.add(funcSubstring(nargs)); 
+	    else if (funcDef.alias.equals("sval")) calcStack.add(funcSval(popCalcStackAsString()));
+	    else if (funcDef.alias.equals("tan")) calcStack.add(new java.lang.Double(java.lang.Math.tan(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("uc")) calcStack.add(popCalcStackAsString().toUpperCase());
+	    else if (funcDef.alias.equals("val")) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
+	    else err("Function not yet implemented: "+funcName);
+	}
+	
+	public void parse(Vector tck, Vector msgStack){
+		calcStack.clear();
+		clearLocalSymbols();
+		tokenStack = tck;
+		messageStack = msgStack;
+		scanpos = 0;
+		try{
+			parseCommand();
+		}catch(Exception ex){
+			//Vm.debug(ex.toString());
 		}
 	}
+	
 }

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-13 22:07:59 UTC (rev 386)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-13 23:18:06 UTC (rev 387)
@@ -41,6 +41,7 @@
 	/** The path to the browser */
 	public String browser = new String();
 	public boolean showDeletedImages=true; /* Used in ImagePanel */
+	public boolean solverIgnoreCase=false;
 		
 	public int myAppHeight = 0;
 	public int myAppWidth = 0;
@@ -363,6 +364,9 @@
 		if (name.equals("hintlogpanel")) {
 			logsPerPage = Convert.parseInt(atts.getValue("logsperpage"));
 		}
+		if (name.equals("solver")) {
+			solverIgnoreCase=Boolean.valueOf(atts.getValue("ignorevariablecase")).booleanValue();
+		}
 	}
 
 	public void characters( char ch[], int start, int length )
@@ -433,6 +437,7 @@
 			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\"/>\n");
 			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>\n");
 			outp.print("    <hintlogpanel logsperpage=\""+logsPerPage+"\"/>\n");
+			outp.print("    <solver ignorevariablecase=\""+solverIgnoreCase+"\"/>\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			// Obsolete data kept for backward compatibility
 			//outp.print("	<syncOC date = \"" + last_sync_opencaching + "\" dist = \"" + distOC +  "\"/>\n");

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2007-01-13 22:07:59 UTC (rev 386)
+++ trunk/src/CacheWolf/SolverPanel.java	2007-01-13 23:18:06 UTC (rev 387)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+
 import ewe.ui.*;
 import ewe.io.*;
 import ewe.filechooser.FileChooser;
@@ -21,6 +22,9 @@
 	Profile profile;
 	String currFile;
 	CacheHolder currCh;
+	Tokenizer tokenizer = new Tokenizer();
+	Parser parser = new Parser();
+	Vector msgFIFO = new Vector();
 	
 	
 	public SolverPanel (Preferences p, Profile prof){
@@ -34,30 +38,20 @@
 		this.addLast(btnSaveAs= new mButton("SaveAs"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 	}
 	
-	public void setCh(CacheHolder ch){
-		currCh = ch;
+	public void setCh(CacheHolder ch) {
+		currCh=ch;
 	}
-	
+
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if(ev.target == mBtSolve){
-				Tokenizer tk = new Tokenizer();
-				Parser myP = new Parser();
-				String src = new String();
-				src = mText.getText();
-				src = src + "\n";
-				if (pref.digSeparator.equals(","))	src = src.replace('.', ',');
-				else src = src.replace(',', '.');
-				tk.setSource(src);
-				tk.TokenIt();
-				myP.setTockenStack(tk.getStack());
-				//Vm.debug("Going inot parsing");
-				myP.parse();
-				Vector msg = new Vector();
-				msg = myP.getMessages();
+				msgFIFO.clear();
+				String src = mText.getText()+"\n";
+				tokenizer.tokenizeSource(src, msgFIFO); // Tokenizer sets message if an error occurred
+				if (msgFIFO.size()==0) parser.parse(tokenizer.TokenStack, msgFIFO);
 				String msgStr = new String();
-				for(int i = 0; i < msg.size(); i++){
-					msgStr = msgStr + msg.get(i) + "\n";
+				for(int i = 0; i < msgFIFO.size(); i++){
+					msgStr = msgStr + "# "+msgFIFO.get(i) + "\n";
 				}
 				src = src +"#----Output----------\n"+ msgStr + "#----------------------";
 				mText.setText(src);

Modified: trunk/src/CacheWolf/TokenObj.java
===================================================================
--- trunk/src/CacheWolf/TokenObj.java	2007-01-13 22:07:59 UTC (rev 386)
+++ trunk/src/CacheWolf/TokenObj.java	2007-01-13 23:18:06 UTC (rev 387)
@@ -1,11 +1,33 @@
 package CacheWolf;
 
+
+
 /**
 *	Class to hold a token object.
 *	@see Tokenizer
 *	@see Parser
 */
 public class TokenObj{
+	/** Token types */
+	public static final int TT_VARIABLE=0;
+	public static final int TT_STRING=1;
+	public static final int TT_NUMBER=2;
+	public static final int TT_SYMBOL=3;
+	public static final int TT_FORMATSTR=4;
+	public static final int TT_IF=5;
+	public static final int TT_THEN=6;
+	public static final int TT_ENDIF=7;
+	public static final int TT_STOP=8;
+	public static final int TT_OPENBRACKET=9;
+	public static final int TT_CLOSEBRACKET=10;
+	public static final int TT_LT=20;   // Don't change the sequence from LT to NT 
+	public static final int TT_GT=21;
+	public static final int TT_LE=22;
+	public static final int TT_GE=23;
+	public static final int TT_EQ=24;
+	public static final int TT_NE=25;
+	
+	int tt; // Tokentype
 	String token;
 	int line, position;
 }

Modified: trunk/src/CacheWolf/Tokenizer.java
===================================================================
--- trunk/src/CacheWolf/Tokenizer.java	2007-01-13 22:07:59 UTC (rev 386)
+++ trunk/src/CacheWolf/Tokenizer.java	2007-01-13 23:18:06 UTC (rev 387)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+
 import ewe.util.*;
 
 /**
@@ -9,152 +10,217 @@
 */
 public class Tokenizer{
 
-	String mySource = new String();
-	char Look;
-	int SourcePointer = 0;
-	String CurrentStream = new String();
+	/** Normally only a semicolon (;) can be used to separate commands. If this variable is set to true,
+	 * newlines also terminate a command. If a newline is preceded with a backslash (=line continuation character),
+	 * the newline does not terminate the command even if this variable is true.
+	 */
+	public boolean newLineIsSeparator=true;
+	/** instructions to tokenize */
+	String mySource;
+	/** source character */
+	char look;
+	/** pointer to next character to read */
+	int sourcePointer = 0;
+	/** (partial) token */
+	String currentStream;
 	Vector TokenStack = new Vector();
-	int CurrentLine, CurrentPos;
+	/** position of token */
+	int currentLine, currentPos;
 	TokenObj thisToken;
+	Vector messageStack;
 	
-	public Vector getStack(){
-		/*TokenObj to = new TokenObj();
-		
-		for(int i = 0; i < TokenStack.size(); i++){
-			to = (TokenObj)TokenStack.get(i);
-			//Vm.debug("Tock: " + to.token);
-		}
-		*/
-		return TokenStack;
-	}
-	
 	public Tokenizer(){
 	}
 
-	public void setSource(String src){
-		mySource = src;
-		mySource = mySource + "\n";
-		SourcePointer = 0;
-		TokenStack = new Vector();
-		//System.out.println("Source set to: " + mySource);
+    private void err(String str) throws Exception {
+    	messageStack.add("Error on line: " + currentLine + " position: " + currentPos);
+    	messageStack.add(str);
+    	throw new Exception("Error "+str);
+    }
+
+	private boolean isAlpha(char c){
+		return  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".indexOf(c)!=-1;
 	}
 	
-	private boolean IsAlpha(char c){
-		String t = new String();
-		t = t + c;
-		t = t.toUpperCase();
-		if("ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(t) != -1) return true;
-		else return false;
+	private boolean isDigit(char c){
+		return "0123456789".indexOf(c)!=-1;
 	}
 	
-	private boolean IsDigit(char c){
-		String t = new String();
-		t = t + c;
-		t = t.toUpperCase();
-		if("0123456789.,".indexOf(t) != -1) return true;
-		else return false;
+	private boolean isSymbol(char c){
+		return "!<>(){}*/,;^+-=".indexOf(look)!=-1;
 	}
-	
+
 	private boolean getChar(){
-		Look = mySource.charAt(SourcePointer);
-		SourcePointer++;
-		if(SourcePointer >= mySource.length()) return true; // final reached
-		else return false;
+		if(sourcePointer >= mySource.length()) return false; 
+		look = mySource.charAt(sourcePointer++);
+		currentPos++;
+		return true;
 	}
 	
-	private boolean IsSymbol(char c){
-		boolean retval = false;
-		if(c == '+') retval = true;
-		if(c == '-') retval = true;
-		if(c == '=') retval = true;
-		return retval;
+	private char lookAhead() {
+		if(sourcePointer >= mySource.length())
+			return '\n';
+		else
+			return mySource.charAt(sourcePointer);
 	}
 	
-	private void emit(){
-		//System.out.println(CurrentStream);
+	private void backUp() {
+		sourcePointer--;
+		currentPos--;
+	}
+	
+	/** Create a new token object and remember the place where it started. 
+	 *  String tokens could span several lines, so we need to remember the starting line and position.
+	 */
+	private void startToken() {
 		thisToken = new TokenObj();
-		thisToken.token = CurrentStream;
-		thisToken.line = CurrentLine;
-		thisToken.position = CurrentPos;
+		thisToken.line = currentLine;
+		thisToken.position = currentPos;
+	}
+	
+	/** Add the previously started token to the token stack */
+	private void emitToken(int tt){
+//		ewe.sys.Vm.debug(currentStream);
+		thisToken.token = currentStream;
+		thisToken.tt=tt;
 		TokenStack.add(thisToken);
-		CurrentStream = "";
+		currentStream = "";
 	}
 
 	private void streamAlphas(){
-		
-		while(getChar() == false){
-			CurrentPos++;
-			if(IsAlpha(Look) == false) break;
-			else CurrentStream += Look;
+		startToken();
+		while(getChar()){
+			if(isAlpha(look) || isDigit(look)) 
+				currentStream += look;
+			else 
+				break;
 		} 
-		SourcePointer--;
-		CurrentPos--;
-		Look = ' ';
+		String s=currentStream.toUpperCase();
+		if (s.equals("STOP") || s.equals("ST"))
+			emitToken(TokenObj.TT_STOP);
+		if (s.equals("IF"))
+			emitToken(TokenObj.TT_IF);
+		else if (s.equals("THEN"))
+			emitToken(TokenObj.TT_THEN);
+		else if (s.equals("ENDIF") || s.equals("FI"))
+			{ currentStream="ENDIF"; emitToken(TokenObj.TT_ENDIF); }
+		else
+			emitToken(TokenObj.TT_VARIABLE);
+		// We have read one character too far, so back off
+		backUp();
 	}
 	
 	private void streamDigits(){
-		while(getChar() == false){
-			CurrentPos++;
-			if(IsDigit(Look) == false) break;
-			CurrentStream += Look;
+		boolean foundDecSep=false; // To check that only one decimal point is allowed in a number
+		startToken();
+		while(getChar()){
+			if(isDigit(look) || (look=='.' && !foundDecSep)) {
+				currentStream += look;
+				if (look=='.') foundDecSep=true;
+			} else
+				break;
 		}
-		SourcePointer--;
-		CurrentPos--;
-		Look = ' ';
+		emitToken(TokenObj.TT_NUMBER);
+		// We have read one character too far, so back off
+		backUp();
 	}
 	
-	private void streamSymbols(){
-		while(getChar() == false){
-			CurrentPos++;
-			if(IsSymbol(Look) == false) break;
-			CurrentStream += Look;
+	private void streamString() throws Exception {
+		startToken();
+		currentStream="";
+		do {
+			while(getChar() && look != '\"'){
+				currentStream += look;
+				// Need to count newlines inside a string spanning multiple lines so that we don't loose track
+				if (look=='\n') {
+					currentLine++;
+					currentPos=0;
+				}
+			}
+			if (lookAhead()=='"') 
+				currentStream+="\""; // Two " following each other are replaced by "
+		} while (currentStream.endsWith("\""));
+		if (look!='"') {
+			// Restore start position of string for correct indication of error
+			currentLine=thisToken.line;
+			currentPos=thisToken.position;
+			err("Unterminated string");
 		}
-		SourcePointer--;
-		CurrentPos--;
-		Look = ' ';
+		emitToken(TokenObj.TT_STRING);
+		
 	}
+	
+	private void streamSymbol() {
+		startToken(); 
+		// Check for == != <= >= <> >< 
+		if (look=='=' || look=='!' || look=='<' || look=='>') {
+			getChar();
+			currentStream+=look;
+			if (currentStream.equals("=="))  { emitToken(TokenObj.TT_EQ); return;}
+			if (currentStream.equals("!=") || currentStream.equals("><") || currentStream.equals("<>")) 
+											{ emitToken(TokenObj.TT_NE); ; return;}
+			if (currentStream.equals("<=")) { emitToken(TokenObj.TT_LE); return; }
+			if (currentStream.equals(">=")) { emitToken(TokenObj.TT_GE); return; }
+			backUp(); // Not a valid comparison symbol, forget the last character
+			currentStream=currentStream.substring(0,1);
+			if (currentStream.equals("=")) emitToken(TokenObj.TT_EQ);
+			else if (currentStream.equals("<")) emitToken(TokenObj.TT_LT);
+			else if (currentStream.equals(">")) emitToken(TokenObj.TT_LT);
+			else emitToken(TokenObj.TT_SYMBOL);
+		} else
+			emitToken(TokenObj.TT_SYMBOL); 		
+	}
 
-	private void streamString(){
-		while(getChar() == false && Look != '\"'){
-			CurrentPos++;
-			CurrentStream += Look;
+	/** Eat up all characters until next newline as we are in a comment */
+	private void eatUpComment() {
+		while (getChar() && look !='\n');
+		currentStream=";"; // Insert a dummy ;
+		startToken(); 
+		emitToken(TokenObj.TT_SYMBOL);
+		currentStream="";
+		currentLine++;
+		currentPos=0;
+	}
+
+	private void formatString() throws Exception {
+		currentStream="";
+		startToken();
+		while (getChar() && look!=':') {
+			currentStream += look;
+			if (look!='.' && look!='0' && look!='#') err("Invalid format character");
 		}
+		emitToken(TokenObj.TT_FORMATSTR);
 	}
 	
-	public void TokenIt(){
-		boolean inComment = false;
-		CurrentLine = 1;
-		CurrentPos = 0;
-		while(getChar() == false){
-			CurrentStream += Look;
-			CurrentPos++;
-			if(inComment == false){	
-				if(IsAlpha(Look)) {streamAlphas();emit();}
-				if(IsDigit(Look)) {streamDigits();emit();}
-				if(Look == ')') emit();
-				if(Look == '(') emit();
-				if(Look == '{') emit();
-				if(Look == '}') emit();
-				if(Look == '*') emit();
-				if(Look == '/') emit();
-				if(Look == ';') emit();
-				if(Look == '\"') emit();
-				if(Look == '^') emit();
-				if(Look == '+') {streamSymbols();emit();}
-				if(Look == '-') {streamSymbols();emit();}
-				if(Look == '=') {streamSymbols();emit();}
-				if(Look == ' ') {CurrentStream = "";}
-				if(Look == '\"') {
-					emit();
-					streamString();
-					emit();
-					CurrentStream += Look;
-					emit();
-					Look = ' ';
+	public void tokenizeSource(String src, Vector msg){
+		mySource = src+"\n";
+		sourcePointer = 0;
+		TokenStack.clear();
+		messageStack=msg;
+		currentLine = 1;
+		currentPos = 0;
+		currentStream="";
+		try {
+			while(getChar()){
+				if (look==' ') continue;
+				currentStream += look;
+				if(isAlpha(look) || look=='$') streamAlphas();
+				else if(isDigit(look)) streamDigits();
+				else if(isSymbol(look)) streamSymbol();
+				else if(look == '\"') streamString();  
+				else if(look == '\n') {
+					if (newLineIsSeparator && !currentStream.equals("\\\n") && !currentStream.equals("_\n")) { 
+						currentStream=";";
+						startToken();
+						emitToken(TokenObj.TT_SYMBOL);
+					}
+					currentStream = ""; currentLine++; currentPos=0; 
 				}
+				else if(look == '#') eatUpComment();	// Ignore characters until EOL
+				else if(look == ':') formatString();
+				else if (newLineIsSeparator && (look=='\\' || look=='_')) ;
+				else err("Invalid character"); 
 			}
-			if(Look == '\n') {CurrentStream = "";CurrentPos = 0; CurrentLine++; inComment = false;}
-			if(Look == '#') {inComment = true;}			
-		}
+		} catch (Exception e) {}
 	}
 }



From salzkammergut at mail.berlios.de  Sun Jan 14 11:24:49 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 11:24:49 +0100
Subject: [Cachewolf-svn] r389 - trunk/src/CacheWolf
Message-ID: <200701141024.l0EAOn9k032446@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 11:24:43 +0100 (Sun, 14 Jan 2007)
New Revision: 389

Modified:
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Tokenizer.java
Log:
Solver: Neue Funktionen
(instr,replace,count)

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 05:09:23 UTC (rev 388)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 10:24:43 UTC (rev 389)
@@ -58,7 +58,7 @@
 *   - Global variables (starting with $) are remembered across multiple calls to parser
 *   - Global variables are initialised with "", local variables result in error if used before setting value
 *   - IF statement added
-*   - Many new functions (encode,format,goto,len,mid,substring,ucase,lcase,val,sval,reverse,project)
+*   - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
 *   - less typing
 *   	- Function aliases
 *   	- Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
@@ -76,9 +76,10 @@
 public class Parser{
 
 	private class fnType { 
-		public String funcName;
-		public String alias;
-		public int nargs;  // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+		public String funcName; 	 // the function name in the user input
+		public String alias;         // the funcName is mapped to this alias
+		public int nargs;            // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+									 // i.e. 1<<nargs ORed together
 		fnType(String funcName, String alias, int nargs) {
 			this.funcName=funcName; this.alias=alias; this.nargs=nargs;
 		}
@@ -91,6 +92,7 @@
     	new fnType("asin","asin",2),
     	new fnType("atan","atan",2),
     	new fnType("cos","cos",2),
+    	new fnType("count","count",4),
     	new fnType("crosstotal","ct",2),
     	new fnType("ct","ct",2),
     	new fnType("encode","encode",8),
@@ -98,13 +100,14 @@
     	new fnType("goto","goto",6),
     	new fnType("ic","ic",3),
     	new fnType("ignorecase","ic",3),
+    	new fnType("instr","instr",12),
     	new fnType("lcase","lc",2),
-    	new fnType("len","len",2),
     	new fnType("length","len",2),
     	new fnType("mid","mid",12),
     	new fnType("project","project",8),
     	new fnType("quersumme","ct",2),
 //    	new fnType("requiresemicolon","rs",3),
+    	new fnType("replace","replace",8),
     	new fnType("reverse","reverse",2),
     	new fnType("rot13","rot13",2),
 //    	new fnType("rs","rs",3),
@@ -213,8 +216,7 @@
 	private String popCalcStackAsString() {
 		String s;
 		if (calcStack.get(calcStack.size()-1) instanceof Double) {
-			s = ((java.lang.Double)calcStack.get(calcStack.size()-1)).toString();
-			if (Global.getPref().digSeparator==",") s.replace(',','.'); // always show numbers with decimal point
+			s = ((java.lang.Double)calcStack.get(calcStack.size()-1)).toString().replace(',','.'); // always show numbers with decimal point;
 			if (s.endsWith(".0")) s=s.substring(0,s.length()-2);
 		} else
 			s = (String)calcStack.get(calcStack.size()-1);
@@ -276,6 +278,30 @@
 //  FUNCTIONS
 ///////////////////////////////////////////
     
+    private int funcCountChar(String s, char c) {
+    	int count=0;
+    	for (int i=0; i<s.length(); i++)
+    		if (s.charAt(i)==c) count++;
+    	return count;
+    }
+    
+    /** count(string1,string2) 
+     * */
+    private void funcCount()throws Exception {
+       	String s2=popCalcStackAsString();
+    	String s1=popCalcStackAsString();
+    	if (s2.length()==0) err("Cannot count empty string");
+    	if (s2.length()==1) {
+    		calcStack.add(new Double(funcCountChar(s1,s2.charAt(0))));
+    	} else {
+    		String res="";
+    		for(int i=0; i<s2.length(); i++) {
+    			res+=s2.charAt(i)+"="+funcCountChar(s1,s2.charAt(i))+" ";
+    		}
+    		calcStack.add(res);
+    	}
+    }
+    
     private double funcCrossTotal(double a) {
 		// Cross total = Quersumme berechnen
 		String aString = Convert.toString(a); // 
@@ -356,6 +382,24 @@
     	}
     }
     
+    /** VB instr function 
+     * instr([start],string1,string2)
+     * */
+    private int funcInstr(int nargs) throws Exception {
+    	String s2=popCalcStackAsString();
+    	String s1=popCalcStackAsString();
+    	int start=1;
+    	if (nargs==3) start=(int) popCalcStackAsNumber(1);
+    	if (start>s1.length()) err("instr: Start position not in string");
+    	if(s2.equals("")) {
+    		if (s1.equals("")) 
+    			return 0;
+    		else
+    			return 1;
+    	}
+    	return s1.indexOf(s2,start-1)+1;
+    }
+
     private String funcMid(int nargs) throws Exception {
     	if (nargs==2) {
         	double start=popCalcStackAsNumber(0);
@@ -386,6 +430,14 @@
     	return cwPt.project(degrees,distance/1000.0).toString();
     }
 
+    private String funcReplace() throws Exception {
+    	String replaceWith=popCalcStackAsString();
+    	String whatToReplace=popCalcStackAsString();
+    	String s=popCalcStackAsString();
+        if (whatToReplace.equals("") || replaceWith.equals("")) return s;
+        return STRreplace.replace(s,whatToReplace,replaceWith);
+    }
+    
     private String funcReverse(String s) {
     	String res="";
     	for (int i=s.length()-1; i>=0; i--) res+=s.charAt(i);
@@ -664,15 +716,18 @@
 	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(java.lang.Math.acos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("atan")) calcStack.add(new java.lang.Double(java.lang.Math.atan(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("count")) funcCount();
 	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("encode")) calcStack.add(funcEncode());
 	    else if (funcDef.alias.equals("format")) calcStack.add(funcFormat(nargs));
 	    else if (funcDef.alias.equals("goto")) funcGoto(nargs);
 	    else if (funcDef.alias.equals("ic")) funcIgnoreVariableCase(nargs);
+	    else if (funcDef.alias.equals("instr")) calcStack.add(new Double(funcInstr(nargs)));
 	    else if (funcDef.alias.equals("lc")) calcStack.add(popCalcStackAsString().toLowerCase());
 	    else if (funcDef.alias.equals("len")) calcStack.add(new Double(popCalcStackAsString().length()));
 	    else if (funcDef.alias.equals("mid")) calcStack.add(funcMid(nargs));
 	    else if (funcDef.alias.equals("project")) calcStack.add(funcProject());     
+	    else if (funcDef.alias.equals("replace")) calcStack.add(funcReplace());
 	    else if (funcDef.alias.equals("reverse")) calcStack.add(funcReverse(popCalcStackAsString()));
 	    else if (funcDef.alias.equals("rot13")) calcStack.add(Common.rot13(popCalcStackAsString()));
 //	    else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);

Modified: trunk/src/CacheWolf/Tokenizer.java
===================================================================
--- trunk/src/CacheWolf/Tokenizer.java	2007-01-14 05:09:23 UTC (rev 388)
+++ trunk/src/CacheWolf/Tokenizer.java	2007-01-14 10:24:43 UTC (rev 389)
@@ -98,7 +98,7 @@
 		String s=currentStream.toUpperCase();
 		if (s.equals("STOP") || s.equals("ST"))
 			emitToken(TokenObj.TT_STOP);
-		if (s.equals("IF"))
+		else if (s.equals("IF"))
 			emitToken(TokenObj.TT_IF);
 		else if (s.equals("THEN"))
 			emitToken(TokenObj.TT_THEN);
@@ -130,7 +130,11 @@
 		currentStream="";
 		do {
 			while(getChar() && look != '\"'){
-				currentStream += look;
+				if (look=='\\') {
+					if (!getChar()) break;
+					if (look=='n') currentStream += "\n";
+					else currentStream += look;
+				} else currentStream += look;
 				// Need to count newlines inside a string spanning multiple lines so that we don't loose track
 				if (look=='\n') {
 					currentLine++;



From salzkammergut at mail.berlios.de  Sun Jan 14 13:59:38 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 13:59:38 +0100
Subject: [Cachewolf-svn] r390 - trunk/src/CacheWolf
Message-ID: <200701141259.l0ECxcqh020459@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 13:59:35 +0100 (Sun, 14 Jan 2007)
New Revision: 390

Modified:
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/SolverPanel.java
Log:
Neues SolverPanel mit split screen
Loeschen der unteren Haelfte mit cls() oder Kontextmenue

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 10:24:43 UTC (rev 389)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 12:59:35 UTC (rev 390)
@@ -91,6 +91,8 @@
     	new fnType("acos","acos",2),
     	new fnType("asin","asin",2),
     	new fnType("atan","atan",2),
+    	new fnType("cls","cls",1),
+    	new fnType("clearscreen","cls",1),
     	new fnType("cos","cos",2),
     	new fnType("count","count",4),
     	new fnType("crosstotal","ct",2),
@@ -278,7 +280,13 @@
 //  FUNCTIONS
 ///////////////////////////////////////////
     
-    private int funcCountChar(String s, char c) {
+	/** Clear Screen */
+	private void funcCls() {
+		// OutputPanel is private, so need to cast to base class
+		((ewe.ui.mTextPad) Global.mainTab.solverP.mOutput).setText("");
+	}
+	
+	private int funcCountChar(String s, char c) {
     	int count=0;
     	for (int i=0; i<s.length(); i++)
     		if (s.charAt(i)==c) count++;
@@ -374,6 +382,7 @@
     	}
     }
     
+    /** Display or change the case sensitivity of variable names */
     private void funcIgnoreVariableCase(int nargs) throws Exception {
     	if (nargs==0) 
     		calcStack.add(""+Global.getPref().solverIgnoreCase);
@@ -400,6 +409,7 @@
     	return s1.indexOf(s2,start-1)+1;
     }
 
+    /** MID function as in Basic */
     private String funcMid(int nargs) throws Exception {
     	if (nargs==2) {
         	double start=popCalcStackAsNumber(0);
@@ -430,6 +440,7 @@
     	return cwPt.project(degrees,distance/1000.0).toString();
     }
 
+    /** Replace all occurrences of a string with another string */
     private String funcReplace() throws Exception {
     	String replaceWith=popCalcStackAsString();
     	String whatToReplace=popCalcStackAsString();
@@ -438,6 +449,7 @@
         return STRreplace.replace(s,whatToReplace,replaceWith);
     }
     
+    /** Reverse a string */
     private String funcReverse(String s) {
     	String res="";
     	for (int i=s.length()-1; i>=0; i--) res+=s.charAt(i);
@@ -451,7 +463,8 @@
 		Global.getPref().solverRequireSemicolon=(popCalcStackAsNumber(0)!=0)?true:false;
 	}
 }
-*/    
+*/  
+    /** Java-like substring */
     private String funcSubstring(int nargs) throws Exception {
     	if (nargs==2) {
         	double start=popCalcStackAsNumber(0);
@@ -469,6 +482,7 @@
     	}
     }
     
+    /** Replace each character by its number A=1, B=2 etc. and put result into a string */
     private String funcSval(String s) {
        	s=s.toLowerCase();
     	String res="";
@@ -480,6 +494,7 @@
     	return res;
     }
     
+    /** Replace each character by its number A=1, B=2 etc. and sum them */
     private double funcVal(String s) {
     	s=s.toLowerCase();
     	int sum=0;
@@ -715,6 +730,7 @@
 	         if (funcDef.alias.equals("asin")) calcStack.add(new java.lang.Double(java.lang.Math.asin(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(java.lang.Math.acos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("atan")) calcStack.add(new java.lang.Double(java.lang.Math.atan(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("cls")) funcCls();
 	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("count")) funcCount();
 	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(popCalcStackAsNumber(0))));

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2007-01-14 10:24:43 UTC (rev 389)
+++ trunk/src/CacheWolf/SolverPanel.java	2007-01-14 12:59:35 UTC (rev 390)
@@ -18,6 +18,7 @@
 	mButton mBtSolve;
 	mButton btnLoad, btnSave, btnSaveAs;
 	mTextPad mText;
+	OutputPanel mOutput;
 	Preferences pref;
 	Profile profile;
 	String currFile;
@@ -25,17 +26,49 @@
 	Tokenizer tokenizer = new Tokenizer();
 	Parser parser = new Parser();
 	Vector msgFIFO = new Vector();
+	Menu mnuContext;
+	private class OutputPanel extends mTextPad {
+		MenuItem mnuClr;
+		OutputPanel() {
+			this.modify(Control.NotEditable,0);
+			//this.modifiers=this.modifiers|WantHoldDown; 
+			setMenu(mnuContext=getClipboardMenu(new Menu(new MenuItem[]{ mnuClr=new MenuItem("Clear output") },"")));
+		} 
+		public void penRightReleased(Point p){
+			setMenu(mnuContext);
+			doShowMenu(p); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		}
+		public void penHeld(Point p){
+			setMenu(mnuContext);
+			doShowMenu(p);
+		}
+		public void popupMenuEvent(Object selectedItem){
+			if (selectedItem==mnuClr) 
+				this.setText("");
+			else 
+				super.popupMenuEvent(selectedItem);
+		}
+	}
 	
+	CellPanel programPanel, outputPanel;
 	
 	public SolverPanel (Preferences p, Profile prof){
 		pref = p;
 		profile = prof;
-		ScrollBarPanel sbp = new ScrollBarPanel(mText = new mTextPad());
-		this.addLast(sbp);
-		this.addNext(mBtSolve= new mButton("Solve!"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		this.addNext(btnLoad= new mButton("Load"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		this.addNext(btnSave= new mButton("Save"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		this.addLast(btnSaveAs= new mButton("SaveAs"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+
+		programPanel = split.getNextPanel();
+		outputPanel = split.getNextPanel();
+		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
+
+		programPanel.addLast(new ScrollBarPanel(mText = new mTextPad()));
+		programPanel.addNext(mBtSolve= new mButton("Solve!"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addNext(btnLoad= new mButton("Load"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addNext(btnSave= new mButton("Save"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addLast(btnSaveAs= new mButton("SaveAs"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		outputPanel.addLast(new ScrollBarPanel(mOutput = new OutputPanel()));
+
+		this.addLast(split);
 	}
 	
 	public void setCh(CacheHolder ch) {
@@ -46,15 +79,13 @@
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if(ev.target == mBtSolve){
 				msgFIFO.clear();
-				String src = mText.getText()+"\n";
-				tokenizer.tokenizeSource(src, msgFIFO); // Tokenizer sets message if an error occurred
+				tokenizer.tokenizeSource(mText.getText(), msgFIFO); // Tokenizer sets message if an error occurred
 				if (msgFIFO.size()==0) parser.parse(tokenizer.TokenStack, msgFIFO);
-				String msgStr = new String();
+				String msgStr = "";
 				for(int i = 0; i < msgFIFO.size(); i++){
-					msgStr = msgStr + "# "+msgFIFO.get(i) + "\n";
+					msgStr = msgStr + msgFIFO.get(i) + "\n";
 				}
-				src = src +"#----Output----------\n"+ msgStr + "#----------------------";
-				mText.setText(src);
+				mOutput.appendText(msgStr,true);
 			}
 			if(ev.target == btnLoad){
 				FileChooser fc = new FileChooser(FileChooser.OPEN, profile.dataDir);



From salzkammergut at mail.berlios.de  Sun Jan 14 15:54:05 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 15:54:05 +0100
Subject: [Cachewolf-svn] r391 - trunk/src/CacheWolf
Message-ID: <200701141454.l0EEs5C5000483@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 15:53:57 +0100 (Sun, 14 Jan 2007)
New Revision: 391

Modified:
   trunk/src/CacheWolf/Tokenizer.java
Log:
Bugfix fuer Strings mit ""

Modified: trunk/src/CacheWolf/Tokenizer.java
===================================================================
--- trunk/src/CacheWolf/Tokenizer.java	2007-01-14 12:59:35 UTC (rev 390)
+++ trunk/src/CacheWolf/Tokenizer.java	2007-01-14 14:53:57 UTC (rev 391)
@@ -51,7 +51,10 @@
 	}
 
 	private boolean getChar(){
-		if(sourcePointer >= mySource.length()) return false; 
+		if(sourcePointer >= mySource.length()) {
+			look='\n';
+			return false; 
+		}
 		look = mySource.charAt(sourcePointer++);
 		currentPos++;
 		return true;
@@ -128,22 +131,23 @@
 	private void streamString() throws Exception {
 		startToken();
 		currentStream="";
-		do {
-			while(getChar() && look != '\"'){
-				if (look=='\\') {
-					if (!getChar()) break;
-					if (look=='n') currentStream += "\n";
-					else currentStream += look;
-				} else currentStream += look;
-				// Need to count newlines inside a string spanning multiple lines so that we don't loose track
-				if (look=='\n') {
-					currentLine++;
-					currentPos=0;
-				}
+		while(getChar()){ // collect chars until next "
+			if (look=='"') {
+				if (lookAhead()!='"') break;  // " not followed by " => End of string
+				// Two " following each other are replaced by " 
+				currentStream+="\""; 
+				getChar();
+			} else if (look=='\\') {
+				if (!getChar()) break;
+				if (look=='n') currentStream += "\n";
+				else currentStream += look;
+			} else currentStream += look;
+			// Need to count newlines inside a string spanning multiple lines so that we don't loose track
+			if (look=='\n') {
+				currentLine++;
+				currentPos=0;
 			}
-			if (lookAhead()=='"') 
-				currentStream+="\""; // Two " following each other are replaced by "
-		} while (currentStream.endsWith("\""));
+		} // EOT or look=="
 		if (look!='"') {
 			// Restore start position of string for correct indication of error
 			currentLine=thisToken.line;



From salzkammergut at mail.berlios.de  Sun Jan 14 16:37:47 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 16:37:47 +0100
Subject: [Cachewolf-svn] r392 - trunk/src/CacheWolf
Message-ID: <200701141537.l0EFblZc003670@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 16:37:45 +0100 (Sun, 14 Jan 2007)
New Revision: 392

Modified:
   trunk/src/CacheWolf/Parser.java
Log:


Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 14:53:57 UTC (rev 391)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 15:37:45 UTC (rev 392)
@@ -266,6 +266,7 @@
 
 	private fnType getFunctionDefinition(String str) throws Exception {
     	fnType fnd=null;
+    	str=str.toLowerCase();
     	for (int i=functions.length-1; i>=0; i--) {
     		if (functions[i].funcName.startsWith(str)) {
     			if (fnd!=null) err("Ambiguous function name: "+str);



From pfeffer at mail.berlios.de  Sun Jan 14 17:01:29 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 14 Jan 2007 17:01:29 +0100
Subject: [Cachewolf-svn] r393 - trunk/src/CacheWolf
Message-ID: <200701141601.l0EG1TjN005063@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-14 17:01:23 +0100 (Sun, 14 Jan 2007)
New Revision: 393

Modified:
   trunk/src/CacheWolf/CWPoint.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/TrackPoint.java
   trunk/src/CacheWolf/myTableControl.java
Log:
zeige nur g?\195?\188ltige Koordinateauf GotoPanel
parse goto(String) per regEx
wenn weder gps-pos noch goto-pos valid, positionire das Zentrum in MovingMap in die Mitte des Screens

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-01-14 15:37:45 UTC (rev 392)
+++ trunk/src/CacheWolf/CWPoint.java	2007-01-14 16:01:23 UTC (rev 393)
@@ -47,7 +47,7 @@
 	 */
 	
 	public CWPoint() {
-		super(0,0);
+		super(-361,-361); // construct with unvalid == unset lat/lon 
 		this.utmValid = false;
 		
 	}
@@ -79,7 +79,7 @@
 	 * @param format only CWPoint.CW or CWPoint.REGEX is supported
 	 */
 	public CWPoint(String coord, int format) {
-		super(0,0);
+		super(-361,-361);
 		set(coord, format);
 	}
 
@@ -169,30 +169,29 @@
 
 		if (coord!=null) {
 			switch (format){
-				case CW: 	ParseLatLon pll = new ParseLatLon (coord);
-							try {
-								pll.parse();
-								this.latDec = pll.lat2;
-								this.lonDec = pll.lon2;
-							} catch (Exception e) {
-								this.latDec = 0;
-								this.lonDec = 0;
-							}
-							break;
-		
-				case REGEX: set(coord);
-							break;
-		
-				default: 	this.latDec = 0; this.lonDec = 0;
+			case CW: 	ParseLatLon pll = new ParseLatLon (coord);
+				try {
+					pll.parse();
+					this.latDec = pll.lat2;
+					this.lonDec = pll.lon2;
+				} catch (Exception e) {
+					this.latDec = 91;
+					this.lonDec = 361;
+					break;
+				}
+			case REGEX: set(coord);
+			break;
+
+			default: 	this.latDec = 91; this.lonDec = 361;
 			}
-		} else {
-			this.latDec = 0; this.lonDec = 0;
+		} else { 
+			this.latDec = 91; this.lonDec = 361;
 		}
 		this.utmValid = false;
 	}
-	
 
 
+
 	/**
 	 * set lat and lon by parsing coordinates with regular expression 
 	 * @param coord  String of type N 49? 33.167 E 011? 21.608
@@ -218,8 +217,8 @@
 									")|(?:" +
 									"([0-9]{1,2}[C-HJ-PQ-X])\\s*[EeOo]?\\s*([0-9]{1,7})\\s+[Nn]?\\s*([0-9]{1,7})" +
 									")"); 
-				this.latDec = 0;
-				this.lonDec = 0;
+				this.latDec = -91; // return unset / unvalid values if parsing was not successfull
+				this.lonDec = -361;
 				rex.search(coord);
 				if (rex.stringMatched(1)!= null) { // Std format
 					// Handle "E" oder "O" for longitiude
@@ -241,7 +240,7 @@
 					set(rex.stringMatched(17),rex.stringMatched(19),rex.stringMatched(18)); //parse sequence is E N, but set needs N E
 				}
 				//else Vm.debug("CWPoint: "+coord+" could not be parsed");
-				makeValid();
+				//makeValid(); // TODO was solld as hier?
 			}	/**
 	 * set lat and lon 
 	 * @param strLatNS "N" or "S"
@@ -268,9 +267,9 @@
 						this.lonDec = Math.abs(Common.parseDouble(strLonDeg)) + Math.abs((Common.parseDouble(strLonMin)/60))+Math.abs((Common.parseDouble(strLonSec)/3600));
 						break;
 			
-			default: 	this.latDec = 0; this.lonDec = 0;
+			default: 	this.latDec = 91; this.lonDec = 361;
 		}
-		makeValid();
+		//makeValid();
 		// To avoid changing sign twice if we have something like W -34.2345
 		if (strLatNS.trim().equals("S") && this.latDec>0) this.latDec *= -1;
 		if (strLonEW.trim().equals("W") && this.lonDec>0) this.lonDec *= -1;
@@ -281,7 +280,8 @@
 	 * Returns true if the coordinates are valid
 	 */
 	public boolean isValid() {
-		return latDec!=0 || lonDec!=0;  // Not a very good way, but will have to do for now
+		return 	latDec <= 90.0 && latDec >= -90.0 &&
+				lonDec <= 360 && lonDec >= -360;
 	}
 	
 	/**
@@ -309,10 +309,12 @@
 		utm.northing = (float) Common.parseDouble(strNorthing);
 		utm.easting = (float) Common.parseDouble(strEasting);
 		
-		ll = utm.toLatLonPoint();
-		this.utmValid = true;
-		this.latDec = ll.getLatitude();
-		this.lonDec = ll.getLongitude();
+		ll = utm.toLatLonPoint(); // returns null if unvalit UTM-coordinates
+		if (ll != null) { 
+			this.utmValid = true;
+			this.latDec = ll.getLatitude();
+			this.lonDec = ll.getLongitude();
+		} else {this.latDec = 91; this.lonDec = 361; }
 	}
 
 	/**
@@ -466,9 +468,10 @@
 	/**
 	 * Method to calculate the bearing of a waypoint
 	 * @param dest waypoint
-	 * @return  bearing of waypoint
+	 * @return  bearing of waypoint 361 if this or dest is not valid
 	 */	
 	public double getBearing(CWPoint dest){
+		if (!this.isValid() || dest == null || !dest.isValid()) return 361;
 		float az;
 		LatLonPoint src = new LatLonPoint(this.latDec, this.lonDec);
 		
@@ -548,7 +551,7 @@
 	 * @return  string representation of CWPoint 
 	 */	
 	public String toString(int format){
-		
+		if (!isValid()) return "not set";
 		switch (format) {
 		case DD:	return getNSLetter() + " " + STRreplace.replace(getLatDeg(format),"-","") + "? "
 						+  getEWLetter() + " " + STRreplace.replace(getLonDeg(format),"-","")+ "?";

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-14 15:37:45 UTC (rev 392)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-14 16:01:23 UTC (rev 393)
@@ -212,7 +212,7 @@
 		CoordsP.addLast(lblPosition = new mLabel(gpsPosition.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblDST.backGround = BLUE;
-		CoordsP.addLast(btnGoto = new mButton(toPoint.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 
 		//Rose for bearing
 		compassRose = new GotoRose("rose.png");
@@ -312,27 +312,58 @@
 	 */ 
 	public void setDestination(CWPoint dest){
 		toPoint.set(dest);
-		btnGoto.setText(toPoint.toString(currFormat));
-		mainT.select(this);
+		if (!toPoint.isValid()) (new MessageBox("Error", "coordinates are out of range: \n"+"latitude: "+toPoint.latDec+"\n longditue: "+toPoint.lonDec, MessageBox.OKB)).execute();
+		btnGoto.setText(getGotoBtnText());
+		updateDistance();
 	}
+	
+	public void setDestination(String LatLon) {
+		toPoint.set(LatLon);
+		setDestination(toPoint);
+	}
 
 	/**
-	 * set the coords of the destination  
+	 * set the coords of the destination and switch to gotoPanel  
 	 * @param LatLon destination
 	 */ 
-	public void setDestination(String LatLon) {
+	public void setDestinationAndSwitch(String LatLon) {
 		toPoint.set(LatLon,CWPoint.CW);
-		btnGoto.setText(toPoint.toString(currFormat));
+		setDestination(toPoint);
 		mainT.select(this);
 	}
+	
+	/**
+	 * updates distance and bearing
+	 *
+	 */
+	
+	public void updateDistance() {
+		//update distance
+		Double tmp = new Double();
+		if (gpsPosition.isValid() && toPoint.isValid() ) {
+			tmp.set(gpsPosition.getDistance(toPoint));
+			if (tmp.value >= 1){
+				lblDist.setText(MyLocale.formatDouble(tmp,"0.000")+ " km");
+			}
+			else {
+				tmp.set(tmp.value * 1000);
+				lblDist.setText(tmp.toString(3,0,0) + " m");
+			}
+		}
+		else lblDist.setText("--- km");
+		// update goto-bearing
+		tmp.set(gpsPosition.getBearing(toPoint));
+		if (tmp.value <= 360) 
+			lblBearWayP.setText(tmp.toString(0,0,0) + " Grad");
+		else lblBearWayP.setText("---" + " Grad");
+		compassRose.setWaypointDirection((float)tmp.value);
+	}
 
 	/**
 	 * method which is called if a timer is set up  
 	 */ 
 	public void ticked() {
 		Double bearMov = new Double();
-		Double bearWayP = new Double();
-		Double dist = new Double();
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		Vm.debug("ticked: voher");
@@ -367,21 +398,8 @@
 
 			bearMov.set(gpsPosition.getBear());
 			lblBearMov.setText(bearMov.toString(0,0,0) + " Grad");
-			bearWayP.set(gpsPosition.getBearing(toPoint));
-			lblBearWayP.setText(bearWayP.toString(0,0,0) + " Grad");
-
-			dist.set(gpsPosition.getDistance(toPoint));
-
-			if (dist.value >= 1){
-				lblDist.setText(MyLocale.formatDouble(dist,"0.000")+ " km");
-			}
-			else {
-				dist.set(dist.value * 1000);
-				lblDist.setText(dist.toString(3,0,0) + " m");
-			}
-
-			compassRose.setDirections((float)bearWayP.value, (float)sunAzimut.value, (float)bearMov.value);
-			
+			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value);
+			updateDistance();
 			// Set background to signal quality
 			lblSats.backGround = GREEN;
 		}
@@ -522,8 +540,12 @@
 		}
 		currTrack = new Track(RED);
 	}
+	
+	private String getGotoBtnText() {
+		if (toPoint == null) return "not set";
+		else return toPoint.toString(currFormat);
+	}
 
-
 	/**
 	 * Eventhandler
 	 */
@@ -535,7 +557,7 @@
 			if (ev.target == chkFormat){
 				currFormat = chkFormat.getSelectedIndex();
 				lblPosition.setText(gpsPosition.toString(currFormat));
-				btnGoto.setText(toPoint.toString(currFormat));
+				btnGoto.setText(getGotoBtnText());
 			}
 
 			// start/stop GPS connection
@@ -561,12 +583,14 @@
 				if (serThread == null || !serThread.isAlive() ) {
 					// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
 					mmp.ignoreGps = false;
-					mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
+					if (toPoint.isValid())	mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
+					else mmp.updatePosition(Global.getPref().curCentrePt.latDec, Global.getPref().curCentrePt.lonDec); // if not goto-point defined move map to centere point
 					mmp.ignoreGps = true;
 				}
 				if (currTrack != null) mmp.addTrack(currTrack);
 				if (runbefore) mmp.addOverlaySet(); // draw new trackpoints but only do so if OverlaySet needs to be updated, otherwise it is anyway newly created
-				mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
+				if (toPoint.isValid()) mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
+				else mmp.removeGotoPosition();
 				// update cache symbols in map
 				if (mainT.tbP.myMod.cacheSelectionChanged) {
 					mainT.tbP.myMod.cacheSelectionChanged = false;
@@ -591,11 +615,10 @@
 			// change destination waypoint
 			if (ev.target == btnGoto){
 				CoordsScreen cs = new CoordsScreen();
-				cs.setFields(toPoint, currFormat);
-				if (cs.execute()== CoordsScreen.IDOK){
-					toPoint = cs.getCoords();
-					btnGoto.setText(toPoint.toString(currFormat));
-				}
+				if (toPoint.isValid())	cs.setFields(toPoint, currFormat);
+				else cs.setFields(new CWPoint(0,0), currFormat);
+				if (cs.execute() == CoordsScreen.IDOK)
+					setDestination(cs.getCoords());
 			}
 		}
 		super.onEvent(ev);
@@ -623,8 +646,11 @@
 		super(fn);
 	}
 	
-	public void setDirections(float gd, float sd, float md ) {
-		gotoDir = gd;
+	public void setWaypointDirection(float wd) {
+		gotoDir = wd;
+	}
+	
+	public void setSunMoveDirections(float sd, float md ) {
 		sunDir = sd;
 		moveDir = md;
 		refresh();

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-14 15:37:45 UTC (rev 392)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-14 16:01:23 UTC (rev 393)
@@ -87,7 +87,7 @@
 	}
 	
 	public void gotoPoint(String LatLon) {
-		gotoP.setDestination(LatLon);
+		gotoP.setDestinationAndSwitch(LatLon);
 	}
 	
 	public void onEvent(Event ev)

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-14 15:37:45 UTC (rev 392)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-14 16:01:23 UTC (rev 393)
@@ -497,9 +497,13 @@
 		}
 
 		public void setGotoPosition(double lat, double lon) {
-			removeMapSymbol("goto");
+			removeGotoPosition();
 			gotoPos=addSymbol("goto", "goto_map.png", lat, lon);
 		}
+		
+		public void removeGotoPosition() {
+			removeMapSymbol("goto");
+		}
 
 		public CWPoint getGotoPos(){
 			return new CWPoint(gotoPos.lat, gotoPos.lon);
@@ -724,7 +728,7 @@
 		 * @param w
 		 * @param h
 		 */
-		public void zoom(Point firstclickpoint, int w, int h) {
+		public void zoomScreenRect(Point firstclickpoint, int w, int h) {
 			Vm.showWait(true);
 			int newImageWidth = this.width * 2; // (maximal) size of the zoomed image 
 			int newImageHeight= this.height * 2;
@@ -748,14 +752,14 @@
 			int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
 			Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
 			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-				{
+			{
 				// try to avoid overlapping by shifting
 				if (newImageRect.x < 0) 
 					newImageRect.x = 0; // align left if left overlapping
 				if (newImageRect.y < 0) 
 					newImageRect.y = 0;
- 				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
- 					newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+					newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
 				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
 					newImageRect.y = mapImage1to1.getHeight()- newImageWidth;
 				// crop if after shifting still overlapping
@@ -763,42 +767,48 @@
 					newImageRect.x = 0;
 				if (newImageRect.y < 0) 
 					newImageRect.y = 0;
- 				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
- 					newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+					newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
 				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
 					newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+			}
+			zoomUnscaled(zoomFactor, newImageRect, center);
+		}
 
-				int saveprop = mmp.mapImage.properties;
-				AniImage tmp = null; // = mmp.mapImage;
-				mmp.removeImage(mmp.mapImage);
-				if (mmp.mapImage != mapImage1to1) {
-					mmp.mapImage .free();
-					mmp.mapImage = null;
-				} else tmp = mapImage1to1;
-				Vm.getUsedMemory(true);
-				try {
-					tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor*currentMap.zoomFactor), (int)(newImageRect.height*zoomFactor*currentMap.zoomFactor), newImageRect, 0));
-					currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-				} catch (OutOfMemoryError e) {Vm.debug(e.toString());}
-				Vm.getUsedMemory(true);
-				mmp.mapImage = tmp; // use old image in case of OutOfMemoryError
-				mmp.mapImage.properties = saveprop;
-				mmp.addImage(mmp.mapImage);
-				mmp.images.moveToBack(mmp.mapImage);
-				}
+/**
+ * do the actual scaling
+ * @param zoomFactor
+ * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+ * @param center
+ */		
+		public void zoomUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+			int saveprop = mmp.mapImage.properties;
+			AniImage tmp = null; // = mmp.mapImage;
+			mmp.removeImage(mmp.mapImage);
+			if (mmp.mapImage != mapImage1to1) {
+				mmp.mapImage .free();
+				mmp.mapImage = null;
+			} else tmp = mapImage1to1;
+			Vm.getUsedMemory(true);
+			try {
+				tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor*currentMap.zoomFactor), (int)(newImageRect.height*zoomFactor*currentMap.zoomFactor), newImageRect, 0));
+				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+			} catch (OutOfMemoryError e) {(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();}
+			Vm.getUsedMemory(true);
+			mmp.mapImage = tmp; // use old image in case of OutOfMemoryError
+			mmp.mapImage.properties = saveprop;
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
 			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
 			{
-				mappos = getMapPositionOnScreen();
+				Point mappos = getMapPositionOnScreen();
 				mmp.mapImage.move(mappos.x,mappos.y);
 			}
-			//updatePosition(center.latDec, center.lonDec);
 			destroyOverlaySet();
 			setCenterOfScreen(center);
 			addOverlaySet();
-			//updateSymbolPositions();
 			this.repaintNow();
 			Vm.showWait(false);
-			//CWPoint test = ScreenXY2LatLon(0, 0);
 		}
 		
 
@@ -885,7 +895,7 @@
 			if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
 				paintingZoomArea = false;
 				mm.zoomingMode = false;
-				mm.zoom(saveMapLoc, lastZoomWidth, lastZoomHeight);
+				mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 			}
 			
 			if (mm.zoomingMode && paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 15:37:45 UTC (rev 392)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 16:01:23 UTC (rev 393)
@@ -373,8 +373,7 @@
 		String coord=popCalcStackAsString();
 		if (!isValidCoord(coord)) err("Invalid coordinate: "+coord);
 		// Don't want to switch to goto panel, just set the values
-		gotoP.toPoint.set(coord);
-		gotoP.btnGoto.setText(gotoP.toPoint.toString(gotoP.currFormat));
+		gotoP.setDestination(coord);
 		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
     		int i=Global.getProfile().getCacheIndex(waypointName);
     		if (i<0) err("Goto: Waypoint does not exist: "+waypointName);

Modified: trunk/src/CacheWolf/TrackPoint.java
===================================================================
--- trunk/src/CacheWolf/TrackPoint.java	2007-01-14 15:37:45 UTC (rev 392)
+++ trunk/src/CacheWolf/TrackPoint.java	2007-01-14 16:01:23 UTC (rev 393)
@@ -19,8 +19,8 @@
 	double lonDec;
 	
 	public TrackPoint(){
-		latDec = 0;
-		lonDec = 0;
+		latDec = -91;
+		lonDec = -361;
 	}
 	
 	public TrackPoint(TrackPoint t) {

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-14 15:37:45 UTC (rev 392)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-14 16:01:23 UTC (rev 393)
@@ -105,7 +105,7 @@
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1010,"Goto"))){
 			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
-			tbp.myGotoPanel.setDestination((ch.LatLon));
+			tbp.myGotoPanel.setDestinationAndSwitch((ch.LatLon));
 		}
 		if (selectedItem.toString().equalsIgnoreCase(MyLocale.getMsg(1020,"Open online in Browser"))){
 			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());



From salzkammergut at mail.berlios.de  Sun Jan 14 17:32:57 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 17:32:57 +0100
Subject: [Cachewolf-svn] r394 - trunk/src/CacheWolf
Message-ID: <200701141632.l0EGWvtb007681@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 17:32:55 +0100 (Sun, 14 Jan 2007)
New Revision: 394

Modified:
   trunk/src/CacheWolf/Parser.java
Log:
abs Funktion
(@Pfeffer: Der Goto wurde bereits mit Regex geparst)

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 16:01:23 UTC (rev 393)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 16:32:55 UTC (rev 394)
@@ -88,6 +88,7 @@
 		}
 	}
     fnType[] functions=new fnType[]{ // in alphabetical order
+    	new fnType("abs","abs",2),	
     	new fnType("acos","acos",2),
     	new fnType("asin","asin",2),
     	new fnType("atan","atan",2),
@@ -728,6 +729,7 @@
 	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
 		if (!funcDef.nargsValid(nargs)) err("Invalid number of arguments");
 	         if (funcDef.alias.equals("asin")) calcStack.add(new java.lang.Double(java.lang.Math.asin(popCalcStackAsNumber(0))));
+	 	else if (funcDef.alias.equals("abs")) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(java.lang.Math.acos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("atan")) calcStack.add(new java.lang.Double(java.lang.Math.atan(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("cls")) funcCls();



From salzkammergut at mail.berlios.de  Sun Jan 14 18:43:29 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 18:43:29 +0100
Subject: [Cachewolf-svn] r395 - in trunk: resources src/CacheWolf
Message-ID: <200701141743.l0EHhTtC008248@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 18:43:24 +0100 (Sun, 14 Jan 2007)
New Revision: 395

Modified:
   trunk/resources/wolflang.html
   trunk/src/CacheWolf/Parser.java
Log:
Solver: HTML help update, sqrt added

Modified: trunk/resources/wolflang.html
===================================================================
--- trunk/resources/wolflang.html	2007-01-14 16:32:55 UTC (rev 394)
+++ trunk/resources/wolflang.html	2007-01-14 17:43:24 UTC (rev 395)
@@ -1,20 +1,26 @@
-<font face="Tahoma" size = "2">WolfLanguage Commands:<br>
-each command is terminated<br>
-with a ";".<br>
+<font face="Tahoma" size = "2"><b>WolfLanguage Commands:</b><br>
+Chars after # until end of line are ignored<br>
+Multiple commands per line separated by ;<br>
+<i>Example: stop</i>   # ends execution<br>
+<i>Example: cls()</i>   # clears output screen<br>
 <br>
 <b><u>Basic Operations</u></b><br>
  Assignment:<br>
- var = value;<br>
-<i> Example: a = 2;</i><br>
+ var = value<br>
+<i> Example: a = 2</i><br>
+<i> Example: $a = 2; b="abc"</i><br>
+$a is global variable.<br>
 <br>
-<b><u>Math</u></b><br>
+<u><b> Showing values</b></u><br>
+ "some text" " more text":<br>
+<i> Example: "N 34 12." a " :the " rot13("gnetrg")</i>
  +, -, *, /, (, ):<br>
-<i> Example: a = 1 / 2 + 34 - 8 * 12;<br>
- or a = (1 / b + 34 - b) * 12;</i><br>
+<i> Example: a = 1 / 2 + 34 - 8 * 12<br>
+ or a = (1 / b + 34 - b) * 12</i><br>
 <br>
 <b><u>Root, Power</u></b><br>
- srqt(), ^:<br>
-<i> Example: a = sqrt(2) ^ 5;</i><br>
+ sqrt(), ^:<br>
+<i> Example: a = sqrt(2) ^ 5</i><br>
 <br>
 <b><u>Trigonometric functions</u></b><br>
  cos(), sin(), tan(),<br>
@@ -22,8 +28,26 @@
 <i> Example: a = cos(1);<br>
  or a = atan(b);</i><br>
 <br>
-<b><u>Text</u></b><br>
-rot13()<br><br>
-<u><b> Showing values</b></u><br>
- show(), "some text" show() "more text":<br>
-<i> Example: "N 34 12." show(a) " :the " rot13("gnetrg");</i></font>
\ No newline at end of file
+<b><u>Text functions</u></b>[s is a string]<br>
+length(s)<br>
+mid(s,startpos,length)<br> 
+instr(s,searchStr)<br>
+instr(startpos,s,searchstr)<br>
+ucase(s)<br>
+lcase(s)<br>
+replace(s,searchStr,ReplaceStr)<br>
+reverse(s)<br>
+encode(s,s1,s2)<br>
+count(s,whatStr)<br>
+val(s)<i> # A=1, B=2, ... Z=26;  Add all</i><br>
+sval(s)<i> # A=1, B=2, ... Z=26</i><br>
+rot13(s)<br><br>
+<b><u>Coordinate</u></b><br>
+format(coordinate,fmt) <br>
+  <i>where fmt="CW" or "UTM" or "DMS" or "DD"</i><br>
+project(coordinate,angle,distance)<br>
+goto(coordinate)<br>
+goto(coordinate,waypointname)<br><br>
+<b><u>IF THEN ENDIF</u></b><br>
+IF condition THEN statement; statement .... ENDIF<br><br>
+</font>

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 16:32:55 UTC (rev 394)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 17:43:24 UTC (rev 395)
@@ -116,6 +116,7 @@
 //    	new fnType("rs","rs",3),
     	new fnType("show","show",2),
     	new fnType("sin","sin",2),
+    	new fnType("sqrt","sqrt",2),
     	new fnType("substring","substring",12),
     	new fnType("sval","sval",2),
     	new fnType("tolowercase","lc",2),
@@ -465,6 +466,13 @@
 	}
 }
 */  
+    
+    private double funcSqrt() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	if (a<0) err("Cannot calculate square root of a negative number");
+    	return java.lang.Math.sqrt(a);
+    }
+    
     /** Java-like substring */
     private String funcSubstring(int nargs) throws Exception {
     	if (nargs==2) {
@@ -751,6 +759,7 @@
 //	    else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);
 	    else if (funcDef.alias.equals("show"));
 	    else if (funcDef.alias.equals("sin")) calcStack.add(new java.lang.Double(java.lang.Math.sin(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("sqrt")) calcStack.add(new java.lang.Double(funcSqrt())); 
 	    else if (funcDef.alias.equals("substring")) calcStack.add(funcSubstring(nargs)); 
 	    else if (funcDef.alias.equals("sval")) calcStack.add(funcSval(popCalcStackAsString()));
 	    else if (funcDef.alias.equals("tan")) calcStack.add(new java.lang.Double(java.lang.Math.tan(popCalcStackAsNumber(0))));



From admin at berlios.de  Sun Jan 14 19:34:17 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 14 Jan 2007 19:34:17 +0100 (CET)
Subject: [Feature #3053] Leistungsfähigerer Solver
Message-ID: <200701141834.l0EIYHdC029754@unicorn.berlios.de>

Feature Request #3053, was updated on 2007-Jan-14 19:34
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Leistungsf?higerer Solver

By: salzkammergut
Date: 2007-Jan-14 19:34

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Nur zur Erinnerung f?r 0.9n: Neuer Solver eingestellt.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211


From admin at berlios.de  Sun Jan 14 19:34:41 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 14 Jan 2007 19:34:41 +0100 (CET)
Subject: [Feature #3053] Leistungsfähigerer Solver
Message-ID: <200701141834.l0EIYf95000338@unicorn.berlios.de>

Feature Request #3053, was updated on 2007-Jan-14 19:34
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Leistungsf?higerer Solver

By: salzkammergut
Date: 2007-Jan-14 19:34

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Nur zur Erinnerung f?r 0.9n: Neuer Solver eingestellt.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211


From admin at berlios.de  Sun Jan 14 19:34:51 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 14 Jan 2007 19:34:51 +0100 (CET)
Subject: [Feature #3053] Leistungsfähigerer Solver
Message-ID: <200701141834.l0EIYpbT000613@unicorn.berlios.de>

Feature Request #3053, was updated on 2007-Jan-14 19:34
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Leistungsf?higerer Solver

By: salzkammergut
Date: 2007-Jan-14 19:34

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Nur zur Erinnerung f?r 0.9n: Neuer Solver eingestellt.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211


From admin at berlios.de  Sun Jan 14 19:36:25 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 14 Jan 2007 09:36:25 -0900 (AKST)
Subject: [Cachewolf-svn] [Bug #9979] Spider arbeitet fehlerhaft
Message-ID: <200701141836.l0EIaPDm002841@unicorn.berlios.de>

Bug #9979, was updated on 2007-Jan-14 09:36
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: cw-tester
Assigned to : none
Summary: Spider arbeitet fehlerhaft

Details: Sowohl bei OC als auch GC wird fehlerhaft gespidert.
Der eingegebene Radius wird nicht eingehalten. Als Ergebnis wirden mehr Caches gespidert als gew?nscht.
Dar?ber hinaus werden einige Add-WP mit den Koordinaten N 00? 00.000 E 00? 00.000. Eine Systematik kann ich nicht erkennen.

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9979&group_id=2211


From admin at berlios.de  Sun Jan 14 19:37:23 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 14 Jan 2007 19:37:23 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9801] solver
Message-ID: <200701141837.l0EIbNNC004207@unicorn.berlios.de>

Bug #9801, was updated on 2006-Dec-22 13:22
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : salzkammergut
Summary: solver

Details: der solver reagiert recht empfindlich auf "tippfehler"
-------------------------
2a=;
=> Absturz
-------------------------
a=";
=> unhandled exception
-------------------------
a=2;
"bla show(a);
=> unhandled exception
-------------------------


Follow-Ups:

Date: 2007-Jan-14 19:37
By: salzkammergut

Comment:
Mit neuem Solver behoben
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9801&group_id=2211


From salzkammergut at mail.berlios.de  Sun Jan 14 19:53:35 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 19:53:35 +0100
Subject: [Cachewolf-svn] r396 - trunk/src/CacheWolf
Message-ID: <200701141853.l0EIrZrt028726@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 19:53:28 +0100 (Sun, 14 Jan 2007)
New Revision: 396

Modified:
   trunk/src/CacheWolf/Parser.java
Log:
Update crosstotal

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 17:43:24 UTC (rev 395)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 18:53:28 UTC (rev 396)
@@ -96,7 +96,7 @@
     	new fnType("clearscreen","cls",1),
     	new fnType("cos","cos",2),
     	new fnType("count","count",4),
-    	new fnType("crosstotal","ct",2),
+    	new fnType("crosstotal","ct",6),
     	new fnType("ct","ct",2),
     	new fnType("encode","encode",8),
     	new fnType("format","format",6),
@@ -108,7 +108,7 @@
     	new fnType("length","len",2),
     	new fnType("mid","mid",12),
     	new fnType("project","project",8),
-    	new fnType("quersumme","ct",2),
+    	new fnType("quersumme","ct",6),
 //    	new fnType("requiresemicolon","rs",3),
     	new fnType("replace","replace",8),
     	new fnType("reverse","reverse",2),
@@ -313,16 +313,22 @@
     	}
     }
     
-    private double funcCrossTotal(double a) {
-		// Cross total = Quersumme berechnen
-		String aString = Convert.toString(a); // 
-		// bei 1.8e2 nur 1.8 verwenden 
-		if (aString.toLowerCase().indexOf("e") > 0) aString = aString.substring(0, aString.toLowerCase().indexOf("e"));
-		a=0;
-		for (int i=0; i<aString.length(); i++) {
-		 a += Convert.toDouble(Convert.toString(aString.charAt(i)));	
-		}
-   	    return a;
+    private double funcCrossTotal(int nargs) throws Exception {
+    	int cycles=1;
+		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
+		double a=java.lang.Math.abs(popCalcStackAsNumber(0));
+		if (cycles<0) cycles=1;
+    	if (cycles>5) cycles=5;
+    	while (a>10 && cycles-->0) {
+	    	// Cross total = Quersumme berechnen
+			String aString = Convert.toString(a); // 
+			// bei 1.8e2 nur 1.8 verwenden 
+			if (aString.toLowerCase().indexOf("e") > 0) aString = aString.substring(0, aString.toLowerCase().indexOf("e"));
+			a=0;
+			for (int i=0; i<aString.length(); i++) {
+			 a += Convert.toDouble(Convert.toString(aString.charAt(i)));	
+			}
+    	}return a;
     }
     
     /**
@@ -743,7 +749,7 @@
 	    else if (funcDef.alias.equals("cls")) funcCls();
 	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("count")) funcCount();
-	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
 	    else if (funcDef.alias.equals("encode")) calcStack.add(funcEncode());
 	    else if (funcDef.alias.equals("format")) calcStack.add(funcFormat(nargs));
 	    else if (funcDef.alias.equals("goto")) funcGoto(nargs);



From admin at berlios.de  Sun Jan 14 20:00:00 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 14 Jan 2007 10:00:00 -0900 (AKST)
Subject: [Bug #9980] Kontextmenü Alle wählen/ alle abwählen
Message-ID: <200701141900.l0EJ00hg006759@unicorn.berlios.de>

Bug #9980, was updated on 2007-Jan-14 10:00
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: cw-tester
Assigned to : none
Summary: Kontextmen? Alle w?hlen/ alle abw?hlen

Details: wenn ich in der Listansicht eine Anzahl Caches mittels der suchenfunktion selektiert habe und dann ?ber das Kontextmen? 'alle w?hlen' anklicke werden alle Caches markiert. Auch die nicht mehr sichbaren. Wenn ich nun die markierten l?sche, sind alle weg. Ob das selbe Ergebnis auch f?r das vorherige Filtern gilt, kann ich erst sagen, wenn diese Funktion wieder geht.

Auf jeden Fall ist das ein unerw?nschtes Ergebnis. Alle Befehle sollten nur auf die in der Liste sichtbaren Caches angewendet werden.


For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9980&group_id=2211


From salzkammergut at mail.berlios.de  Sun Jan 14 20:47:53 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Jan 2007 20:47:53 +0100
Subject: [Cachewolf-svn] r397 - in trunk: resources src/CacheWolf
Message-ID: <200701141947.l0EJlrT2000968@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-14 20:47:46 +0100 (Sun, 14 Jan 2007)
New Revision: 397

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Tokenizer.java
Log:
Solver: Internationalisierung

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-14 18:53:28 UTC (rev 396)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-14 19:47:46 UTC (rev 397)
@@ -239,6 +239,39 @@
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
 		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp?ter erneut versuchen\n Status:
+		1700=Fehler in Zeile: 
+		1701=Spalte: 
+		1702=Variable nicht definiert: 
+		1703=Keine erlaubte Zahl: 
+		1704=Unerwartetes Ende des Pogrammes
+		1705=Fehlendes ENDIF
+		1706=Erwartet: 
+		1707=Gefunden: 
+		1708=Uneindeutiger Funktionsname: 
+		1709=Unbekannte Funktion: 
+		1710=Kann leere Zeichenkette nicht z?hlen
+		1711=Ersatzzeichenketten m%fcssen gleiche L%e4nge haben
+		1712=Unzul?ssige Koordinate: 
+		1713=Falsches Koordinatenformat. Erlaubt sind CW/DD/DMM/DMS/UTM
+		1714=Goto: Wegpunkt existiert nicht: 
+		1715=instr: Startposition nicht in Zeichenkette
+		1716=mid: Ganzzahliger Parameter erwartet
+		1717=mid: Parameter ausserhalb des erlaubten Bereichs
+		1718=Kann keine negative Distanz projizieren
+		1719=Winkel muss im Bereich [0;360] sein
+		1720=Kann die Wurzel einer negativen Zahl nicht berechnen
+		1721=substring: Ganzzahliger Parameter erwartet
+		1722=substring: Parameter ausserhalb des erlaubten Bereichs
+		1723=Vergleichsoperator erwartet
+		1724=Variable hat keinen Wert: 
+		1725=Unerwartete(s) Zeichen: 
+		1726=Funktion hat zu viele Argumente 
+		1727=Funktion hat falsche Anzahl von Argumenten
+		1728=Funktion noch nicht implementiert: 
+		1729=Division durch 0
+		1730=Fehlendes " am Ende der Zeichenkette
+		1731=Unerlaubtes Formatierungzeichen
+		1732=Unerlaubtes Zeichen		
 		2000=GPX Export
 		2001=von
 		3000=Schlie%dfen
@@ -495,6 +528,39 @@
 		1619=: could not download image from URL:+
 		1620=downloading embedded images:+
 		1621=Error while interpreting data\n from Opencaching.de,\nThis is most probaly a bug at Opencaching.de\nRetry later\n Status:
+		1700=Error on line: 
+		1701= position: 
+		1702=Variable not defined: 
+		1703=Not a valid number: 
+		1704=Unexpected end of source
+		1705=Missing ENDIF
+		1706=Expected 
+		1707=Found: 
+		1708=Ambiguous function name: 
+		1709=Unknown function: 
+		1710=Cannot count empty string
+		1711=Replacement characters strings must be of equal length
+		1712=Invalid coordinate: 
+		1713=Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM
+		1714=Goto: Waypoint does not exist: 
+		1715=instr: Start position not in string
+		1716=mid: Integer argument expected
+		1717=mid: Argument out of range
+		1718=Cannot project a negative distance
+		1719=Projection degrees must be in interval [0;360]
+		1720=Cannot calculate square root of a negative number
+		1721=substring: Integer argument expected
+		1722=substring: Argument out of range
+		1723=Comparison operator expected
+		1724=Variable not set: 
+		1725=Unexpected character(s): 
+		1726=Too many arguments for function 
+		1727=Invalid number of arguments
+		1728=Function not yet implemented: 
+		1729=Division by 0
+		1730=Unterminated string
+		1731=Invalid format character
+		1732=Invalid character		
 		2000=GPX Export
 		2001=of
 		3000=Close

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-14 18:53:28 UTC (rev 396)
+++ trunk/src/CacheWolf/Parser.java	2007-01-14 19:47:46 UTC (rev 397)
@@ -150,7 +150,7 @@
      * Add an error message to the message stack and raise an Exception.
     */
 	private void err(String str) throws Exception {
-    	messageStack.add("Error on line: " + thisToken.line + " position: " + thisToken.position);
+    	messageStack.add(MyLocale.getMsg(1700,"Error on line: ") + thisToken.line + "  "+MyLocale.getMsg(1701,"position: ") + thisToken.position);
     	messageStack.add(str);
     	throw new Exception("Error "+str);
     }
@@ -186,7 +186,7 @@
 				result="";
 				symbolTable.put(varName,"");
 			} else
-				err ("Variable not defined: "+varName);
+				err (MyLocale.getMsg(1702,"Variable not defined: ")+varName);
 		}
 		return result;
 	}
@@ -197,7 +197,7 @@
 			if (Global.getPref().digSeparator.equals(","))	str = str.replace('.', ',');
 			ret=new java.lang.Double(java.lang.Double.parseDouble(str));
 		} catch (NumberFormatException e) {
-			err("Not a valid number: " + str);
+			err(MyLocale.getMsg(1703,"Not a valid number: ") + str);
 		}
 		return ret;
 	}
@@ -233,7 +233,7 @@
 			thisToken = (TokenObj)tokenStack.get(scanpos);
 			//Vm.debug(thisToken.token);
 			scanpos++;
-		} else err("Unexpected end of source");
+		} else err(MyLocale.getMsg(1704,"Unexpected end of source"));
 	}
 
 	private void getNextTokenOtherThanSemi() throws Exception {
@@ -251,7 +251,7 @@
 				return;
 			}
 		}
-		err("Missing ENDIF");
+		err(MyLocale.getMsg(1705,"Missing ENDIF"));
 	}
 	private TokenObj lookAheadToken() {
 		return (TokenObj)tokenStack.get(scanpos);
@@ -261,7 +261,7 @@
 		if(thisToken.token.toUpperCase().equals(str)){
 			return true;
 		} else {
-			err("Expected " + str + "  Found: "+thisToken.token);
+			err(MyLocale.getMsg(1706,"Expected ") + str + "  "+MyLocale.getMsg(1707,"Found: ")+thisToken.token);
 			return false; //Dummy as err does not return
 		}
 	}
@@ -271,11 +271,11 @@
     	str=str.toLowerCase();
     	for (int i=functions.length-1; i>=0; i--) {
     		if (functions[i].funcName.startsWith(str)) {
-    			if (fnd!=null) err("Ambiguous function name: "+str);
+    			if (fnd!=null) err(MyLocale.getMsg(1708,"Ambiguous function name: ")+str);
     			fnd=functions[i];
     		}
     	}
-    	if (fnd==null) err("Unknown function: "+str);
+    	if (fnd==null) err(MyLocale.getMsg(1709,"Unknown function: ")+str);
     	return fnd;
     }
 
@@ -301,7 +301,7 @@
     private void funcCount()throws Exception {
        	String s2=popCalcStackAsString();
     	String s1=popCalcStackAsString();
-    	if (s2.length()==0) err("Cannot count empty string");
+    	if (s2.length()==0) err(MyLocale.getMsg(1710,"Cannot count empty string"));
     	if (s2.length()==1) {
     		calcStack.add(new Double(funcCountChar(s1,s2.charAt(0))));
     	} else {
@@ -339,7 +339,7 @@
     private String funcEncode() throws Exception {
     	String newChars=popCalcStackAsString();
     	String oldChars=popCalcStackAsString();
-    	if (newChars.length()!=oldChars.length()) err("Replacement characters strings must be of equal length");
+    	if (newChars.length()!=oldChars.length()) err(MyLocale.getMsg(1711,"Replacement characters strings must be of equal length"));
     	String s=popCalcStackAsString();
     	String encodedStr="";
     	for (int i=0; i<s.length(); i++) {
@@ -361,14 +361,14 @@
     	String fmtStr="";
     	if (nargs==2)fmtStr=popCalcStackAsString().toLowerCase();
     	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err("Invalid coordinate: "+coord);
+		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
     	cwPt.set(coord);
     	int fmt=CWPoint.CW;
     	if (fmtStr.equals("dd")) fmt=CWPoint.DD;
     	else if (fmtStr.equals("dmm")) fmt=CWPoint.DMM;
     	else if (fmtStr.equals("dms")) fmt=CWPoint.DMS;
     	else if (fmtStr.equals("utm")) fmt=CWPoint.UTM;
-    	else if (!fmtStr.equals("cw")) err("Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM");
+    	else if (!fmtStr.equals("cw")) err(MyLocale.getMsg(1713,"Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM"));
     	return cwPt.toString(fmt);
     }
     
@@ -379,12 +379,12 @@
 		String waypointName=null;
         if (nargs==2) waypointName=popCalcStackAsString();  
 		String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err("Invalid coordinate: "+coord);
+		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
 		// Don't want to switch to goto panel, just set the values
 		gotoP.setDestination(coord);
 		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
     		int i=Global.getProfile().getCacheIndex(waypointName);
-    		if (i<0) err("Goto: Waypoint does not exist: "+waypointName);
+    		if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
     		cwPt.set(coord);
     		((CacheHolder)Global.getProfile().cacheDB.get(i)).LatLon=cwPt.toString(CWPoint.CW);
     	}
@@ -407,7 +407,7 @@
     	String s1=popCalcStackAsString();
     	int start=1;
     	if (nargs==3) start=(int) popCalcStackAsNumber(1);
-    	if (start>s1.length()) err("instr: Start position not in string");
+    	if (start>s1.length()) err(MyLocale.getMsg(1715,"instr: Start position not in string"));
     	if(s2.equals("")) {
     		if (s1.equals("")) 
     			return 0;
@@ -422,16 +422,16 @@
     	if (nargs==2) {
         	double start=popCalcStackAsNumber(0);
     		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err("mid: Integer argument expected");
-    		if (start<1 || start>s.length()) err("mid: Argument out of range");
+    		if (!isInteger(start)) err(MyLocale.getMsg(1716,"mid: Integer argument expected"));
+    		if (start<1 || start>s.length()) err(MyLocale.getMsg(1717,"mid: Argument out of range"));
     		return s.substring((int)start-1);
     	} else {
         	double len=popCalcStackAsNumber(0);
         	double start=popCalcStackAsNumber(0);
     		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(len)) err("mid: Integer argument expected");
+    		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,"mid: Integer argument expected"));
     		int end=(int)(start+len-1);
-    		if (start>s.length() || start<1 || end>s.length()) err("mid: Argument out of range");
+    		if (start>s.length() || start<1 || end>s.length()) err(MyLocale.getMsg(1717,"mid: Argument out of range"));
     		return s.substring((int)start-1,end);
     	}
     }
@@ -439,11 +439,11 @@
     /** Project a waypoint at some angle and some distance */
     private String funcProject() throws Exception {
     	double distance=popCalcStackAsNumber(0);
-    	if (distance<0) err("Cannot project a negative distance");
+    	if (distance<0) err(MyLocale.getMsg(1718,"Cannot project a negative distance"));
     	double degrees=popCalcStackAsNumber(0);
-    	if (degrees<0 || degrees>360) err("Projection degrees must be in interval [0;360]");
+    	if (degrees<0 || degrees>360) err(MyLocale.getMsg(1719,"Projection degrees must be in interval [0;360]"));
     	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err("Invalid coordinate: "+coord);
+		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
     	cwPt.set(coord);
     	return cwPt.project(degrees,distance/1000.0).toString();
     }
@@ -475,7 +475,7 @@
     
     private double funcSqrt() throws Exception {
     	double a=popCalcStackAsNumber(0);
-    	if (a<0) err("Cannot calculate square root of a negative number");
+    	if (a<0) err(MyLocale.getMsg(1720,"Cannot calculate square root of a negative number"));
     	return java.lang.Math.sqrt(a);
     }
     
@@ -484,15 +484,15 @@
     	if (nargs==2) {
         	double start=popCalcStackAsNumber(0);
     		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err("substring: Integer argument expected");
-    		if (start<0 || start>s.length()) err("substring: Argument out of range");
+    		if (!isInteger(start)) err(MyLocale.getMsg(1721,"substring: Integer argument expected"));
+    		if (start<0 || start>s.length()) err(MyLocale.getMsg(1722,"substring: Argument out of range"));
     		return s.substring((int)start);
     	} else {
         	double end=popCalcStackAsNumber(0);
         	double start=popCalcStackAsNumber(0);
     		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(end)) err("substring: Integer argument expected");
-    		if (start<0 || start>s.length() || start>end || end>s.length()) err("substring: Argument out of range");
+    		if (!isInteger(start) || !isInteger(end)) err(MyLocale.getMsg(1721,"substring: Integer argument expected"));
+    		if (start<0 || start>s.length() || start>end || end>s.length()) err(MyLocale.getMsg(1722,"substring: Argument out of range"));
     		return s.substring((int)start,(int)end);
     	}
     }
@@ -556,7 +556,7 @@
 		getToken();
 		parseStringExp();
 		compOp=thisToken.tt;
-		if (compOp<TokenObj.TT_LT || compOp>TokenObj.TT_NE) err("Comparison operator expected");
+		if (compOp<TokenObj.TT_LT || compOp>TokenObj.TT_NE) err(MyLocale.getMsg(1723,"Comparison operator expected"));
 		getToken();
 		parseStringExp();
 		checkNextSymIs("THEN");
@@ -679,7 +679,7 @@
 				calcStack.add(new java.lang.Double(a*b));
 			else
 				if (b==0.0) 
-					err("Division by 0");
+					err(MyLocale.getMsg(1729,"Division by 0"));
 				else 
 					calcStack.add(new java.lang.Double(a/b));
 		}
@@ -701,7 +701,7 @@
 		if (thisToken.tt==TokenObj.TT_VARIABLE) {
 			if (isVariable(thisToken.token))
 				calcStack.add(getVariable(thisToken.token));
-			else if (!lookAheadToken().token.equals("(")) err("Variable not set: "+thisToken.token);
+			else if (!lookAheadToken().token.equals("(")) err(MyLocale.getMsg(1724,"Variable not set: ")+thisToken.token);
 			else {// Must be a function definition
 				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
 				parseFunction(funcDef);
@@ -715,7 +715,7 @@
 			parseStringExp();
 			checkNextSymIs(")");
 		}
-		else err("Unexpected character(s): "+thisToken.token);
+		else err(MyLocale.getMsg(1725,"Unexpected character(s): ")+thisToken.token);
 		getToken();
 	}
 	
@@ -729,7 +729,7 @@
 			parseStringExp();
 			nargs=1;
 			while (thisToken.token.equals(",")) {
-				if (nargs==4) err("Too many arguments for function "+funcName);
+				if (nargs==4) err(MyLocale.getMsg(1726,"Too many arguments for function ")+funcName);
 				getToken();
 				parseStringExp(); 
 				nargs++;
@@ -741,7 +741,7 @@
 	}
 	
 	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
-		if (!funcDef.nargsValid(nargs)) err("Invalid number of arguments");
+		if (!funcDef.nargsValid(nargs)) err(MyLocale.getMsg(1727,"Invalid number of arguments"));
 	         if (funcDef.alias.equals("asin")) calcStack.add(new java.lang.Double(java.lang.Math.asin(popCalcStackAsNumber(0))));
 	 	else if (funcDef.alias.equals("abs")) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(java.lang.Math.acos(popCalcStackAsNumber(0))));
@@ -771,7 +771,7 @@
 	    else if (funcDef.alias.equals("tan")) calcStack.add(new java.lang.Double(java.lang.Math.tan(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("uc")) calcStack.add(popCalcStackAsString().toUpperCase());
 	    else if (funcDef.alias.equals("val")) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
-	    else err("Function not yet implemented: "+funcName);
+	    else err(MyLocale.getMsg(1728,"Function not yet implemented: ")+funcName);
 	}
 	
 	public void parse(Vector tck, Vector msgStack){

Modified: trunk/src/CacheWolf/Tokenizer.java
===================================================================
--- trunk/src/CacheWolf/Tokenizer.java	2007-01-14 18:53:28 UTC (rev 396)
+++ trunk/src/CacheWolf/Tokenizer.java	2007-01-14 19:47:46 UTC (rev 397)
@@ -33,7 +33,7 @@
 	}
 
     private void err(String str) throws Exception {
-    	messageStack.add("Error on line: " + currentLine + " position: " + currentPos);
+    	messageStack.add(MyLocale.getMsg(1700,"Error on line: ") + currentLine + "  "+MyLocale.getMsg(1701," position: ") + currentPos);
     	messageStack.add(str);
     	throw new Exception("Error "+str);
     }
@@ -152,7 +152,7 @@
 			// Restore start position of string for correct indication of error
 			currentLine=thisToken.line;
 			currentPos=thisToken.position;
-			err("Unterminated string");
+			err(MyLocale.getMsg(1730,"Unterminated string"));
 		}
 		emitToken(TokenObj.TT_STRING);
 		
@@ -195,7 +195,7 @@
 		startToken();
 		while (getChar() && look!=':') {
 			currentStream += look;
-			if (look!='.' && look!='0' && look!='#') err("Invalid format character");
+			if (look!='.' && look!='0' && look!='#') err(MyLocale.getMsg(1731,"Invalid format character"));
 		}
 		emitToken(TokenObj.TT_FORMATSTR);
 	}
@@ -227,7 +227,7 @@
 				else if(look == '#') eatUpComment();	// Ignore characters until EOL
 				else if(look == ':') formatString();
 				else if (newLineIsSeparator && (look=='\\' || look=='_')) ;
-				else err("Invalid character"); 
+				else err(MyLocale.getMsg(1732,"Invalid character")); 
 			}
 		} catch (Exception e) {}
 	}



From pfeffer at mail.berlios.de  Mon Jan 15 05:09:26 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 15 Jan 2007 05:09:26 +0100
Subject: [Cachewolf-svn] r398 - in trunk: resources src/CacheWolf
Message-ID: <200701150409.l0F49QIq015325@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-15 05:09:21 +0100 (Mon, 15 Jan 2007)
New Revision: 398

Added:
   trunk/resources/zoom1to1.png
Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
MovingMap: zoomen duerfte damit erstmal abgeschlossen sein: kleine Bugs behoben, Code etwas besser geordnet, Button 1:1 hinzugefuegt
Titel-Leiste in Moving-Map entfernt
Messagebox "Lade Cachliste" beim Start von CachWolf erscheint jetzt sofort und geht erst, wenn das Hauptfenster erscheint

Added: trunk/resources/zoom1to1.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/zoom1to1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-14 19:47:46 UTC (rev 397)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-15 04:09:21 UTC (rev 398)
@@ -426,9 +426,7 @@
 			if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
 				mmp.directionArrows.setDirections(-361 /*(float)bearWayP.value*/, (float)sunAzimut.value, -361 /*(float)bearMov.value*/);
 				mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
-				Vm.debug("ShowLastAddedPoint: voher");
 				mmp.ShowLastAddedPoint(currTrack);
-				Vm.debug("ShowLastAddedPoint: nachher");
 				mmp.setGpsStatus(MovingMap.gotFix);
 			}
 			if ((fix == 0) && (gpsPosition.getSats()== 0)) {

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-14 19:47:46 UTC (rev 397)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-15 04:09:21 UTC (rev 398)
@@ -46,18 +46,16 @@
 			this.setPreferredSize(800, 600);
 		this.resizeOnSIP = true;
 		// Load CacheList
-		
+		InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
+		infB.exec();
+//		infB.waitUntilPainted(1000);
 		try{
 			pref.readPrefFile();
 			addGuiFont();
 			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
 				ewe.sys.Vm.exit(0); // User MUST select or create a profile
-			InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
-			infB.exec();
-			infB.waitUntilPainted(1000);
-			profile.readIndex();
-			infB.close(0);
 			Vm.showWait(true);
+			profile.readIndex();
 			pref.curCentrePt.set(profile.centre);
 			TablePanel.updateBearingDistance(profile.cacheDB,pref);
 		} catch (Exception e){
@@ -82,6 +80,7 @@
 			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
 		mMenu.setTablePanel(mTab.getTablePanel());
+		infB.close(0);
 		Vm.showWait(false);
 	}
 

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-14 19:47:46 UTC (rev 397)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-15 04:09:21 UTC (rev 398)
@@ -69,6 +69,7 @@
 		affine[5]=0; //left
 		lowlat = 0; //buttom
 		lowlon = 1; //right
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
 		doCalculations();
 	}
 
@@ -184,12 +185,11 @@
 
 	/**
 	 * zoom in / out
-	 * @param zf zf > 1 == zoom in, zoom is relative to last zoom
+	 * @param zf zf > 1 == zoom in, zoom is relative to original unscaled image
 	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
 	 * @param diffY
 	 */
 	public void zoom(float zf, int diffX, int diffY) {
-
 		// restore original values to calculate corret shift (upperleft)
 		affine[4] = OrigUpperLeft.latDec;
 		affine[5] = OrigUpperLeft.lonDec;
@@ -200,11 +200,11 @@
 		CWPoint upperleft = calcLatLon(diffX, diffY);
 		affine[4] = upperleft.latDec;
 		affine[5] = upperleft.lonDec;
-		affine[0] = affine[0] / zf / zoomFactor; 
-		affine[1] = affine[1] / zf / zoomFactor; 
-		affine[2] = affine[2] / zf / zoomFactor; 
-		affine[3] = affine[3] / zf / zoomFactor; 
-		zoomFactor = zf * zoomFactor ;
+		affine[0] = affine[0] / zf ; 
+		affine[1] = affine[1] / zf ; 
+		affine[2] = affine[2] / zf ; 
+		affine[3] = affine[3] / zf ; 
+		zoomFactor = zf ;
 		shift.x = diffX;
 		shift.y = diffY;
 		doCalculations(); // TODO lowlat neu berechnen?

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-14 19:47:46 UTC (rev 397)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-15 04:09:21 UTC (rev 398)
@@ -31,15 +31,17 @@
 	TrackOverlay[] TrackOverlays;
 	Vector tracks;
 	MapInfoObject currentMap;
+	
 	AniImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal = new AniImage("position_green.png");
 	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
 	AniImage statusImageNoGps = new AniImage("position_red.png");
-
-	AniImage ButtonImageChooseMap = new AniImage("choose_map.gif"); 
-	AniImage ButtonImageGpsOn = new AniImage("snap2gps.gif");
-	AniImage ButtonImageLens = new AniImage("lupe.png");
+	AniImage bottonImageClose;
+	AniImage bottonImageChooseMap = new AniImage("choose_map.gif"); 
+	AniImage buttonImageGpsOn = new AniImage("snap2gps.gif");
+	AniImage buttonImageLens = new AniImage("lupe.png");
+	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
 	/*AniImage arrowUp = new AniImage("arrow_up.png");
 	AniImage arrowDown = new AniImage("arrow_down.png");
 	AniImage arrowLeft = new AniImage("arrow_left.png");
@@ -59,26 +61,41 @@
 
 	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
 		this.cacheDB = cacheDB;
-		gotoPanel = gP;
+		this.gotoPanel = gP;
 		this.pref = pref;
+		this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
+		this.windowFlagsToClear = Window.FLAG_HAS_TITLE | Window.BDR_NOBORDER;
+		this.hasTopBar = false;
+		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		this.title = "Moving Map";
 		this.backGround = Color.Black;
-		currentMap = new MapInfoObject();
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
-		mmp.addImage(posCircle);
-		setGpsStatus(noGPS);
-		ButtonImageChooseMap.setLocation(10,10);
-		ButtonImageChooseMap.properties = AniImage.AlwaysOnTop;
-		ButtonImageGpsOn.setLocation(pref.myAppWidth-25, 10);
-		ButtonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
+		bottonImageClose = new AniImage(new Image(closeX.getWidth(), closeX.getHeight()));
+		Graphics tmp = new Graphics(bottonImageClose.image);
+		tmp.setColor(255, 255, 255);
+		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
+		closeX.doDraw(tmp, 0);
+		bottonImageClose.properties |= AniImage.AlwaysOnTop;
+		bottonImageClose.setLocation(Global.getPref().myAppWidth - bottonImageClose.getWidth()- 5, 5);
+		mmp.addImage(bottonImageClose);
+		buttonImageGpsOn.setLocation(pref.myAppWidth - bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 10);
+		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageGpsOn);
+		bottonImageChooseMap.setLocation(10,10);
+		bottonImageChooseMap.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(bottonImageChooseMap);
 		directionArrows.properties = AniImage.AlwaysOnTop;
 		directionArrows.setLocation(Global.getPref().myAppWidth/2-directionArrows.getWidth()/2, 10);
 		mmp.addImage(directionArrows);
-		ButtonImageLens.setLocation(Global.getPref().myAppWidth - ButtonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - ButtonImageLens.getHeight()/2 );
-		ButtonImageLens.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(ButtonImageLens);
+		buttonImageLens.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageLens);
+		buttonImageZoom1to1.setLocation(Global.getPref().myAppWidth - buttonImageZoom1to1.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
+		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageZoom1to1);
 		/*		arrowUp.setLocation(pref.myAppWidth/2, 10);
 		arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
 		arrowLeft.setLocation(10, pref.myAppHeight/2+7);
@@ -92,9 +109,10 @@
 		mmp.addImage(arrowLeft);
 		mmp.addImage(arrowRight);
 		 */		
-		mmp.addImage(ButtonImageChooseMap);
-		mmp.addImage(ButtonImageGpsOn);
+		currentMap = new MapInfoObject();
+		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(posCircle);
 		loadMaps(Global.getPref().baseDir+"maps/standard/");
 	}
 
@@ -150,6 +168,7 @@
 
 	public final FormFrame myExec() {
 		//addOverlaySet(); // neccessary to draw points which were added when the MovingMap was not running, so that these pixels are not stored in the not-immediately-drawing-work-around
+		// doShowExec(null,null,true,Gui.NEW_WINDOW & ~Form.PageHigher);
 		return exec();
 	}
 	public void addTrack(Track tr) {
@@ -202,7 +221,7 @@
 					TrackOverlays[i].move(0, 0);
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
-					mmp.addImage(TrackOverlays[i]);
+				//	mmp.addImage(TrackOverlays[i]);
 				}
 			}
 		}
@@ -329,9 +348,11 @@
 			for (int xi=0; xi<3; xi++) {
 				if (posOnScreen.x +ww >=0 && posOnScreen.x <= ww && posOnScreen.y + wh >=0 && posOnScreen.y <= wh)
 				{
+					if ((TrackOverlays[yi*3+xi].properties & mImage.IsInvisible) > 0) mmp.addImage(TrackOverlays[yi*3+xi]);
 					TrackOverlays[yi*3+xi].properties &= ~mImage.IsInvisible;
 					TrackOverlays[yi*3+xi].move(posOnScreen.x+(xi-1)*ww, posOnScreen.y+(yi-1)*wh);
 				} else {
+					if ((TrackOverlays[yi*3+xi].properties & mImage.IsInvisible) == 0) mmp.removeImage(TrackOverlays[yi*3+xi]);
 					TrackOverlays[yi*3+xi].properties |= mImage.IsInvisible;
 					TrackOverlays[yi*3+xi].move(30, 30);
 				}
@@ -340,7 +361,7 @@
 	}
 
 		public void updateOverlayPos() {
-			if (TrackOverlays == null) return;
+			if (TrackOverlays == null || TrackOverlays[4] == null) return;
 			updateOverlayOnlyPos();
 			if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
 					TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
@@ -506,14 +527,18 @@
 		}
 
 		public CWPoint getGotoPos(){
+			if (gotoPos == null) return null;
 			return new CWPoint(gotoPos.lat, gotoPos.lon);
 		}
 
 		public void removeAllMapSymbolsButGoto(){
-			for (int i=symbols.size()-1; i>=0; i--) {
+			if (symbols == null) return;
+			symbols.removeAllElements();
+			symbols.add(gotoPos);
+/*			for (int i=symbols.size()-1; i>=0; i--) {
 				if (((MapSymbol)symbols.get(i)).name != "goto") removeMapSymbol(i);
 			}
-		}
+	*/	}
 
 		public void removeMapSymbol(String name) {
 			int symbNr = findMapSymbol(name);
@@ -729,10 +754,9 @@
 		 * @param h
 		 */
 		public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-			Vm.showWait(true);
-			int newImageWidth = this.width * 2; // (maximal) size of the zoomed image 
-			int newImageHeight= this.height * 2;
-			CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y+h/2);
+			int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
+			int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
+			CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
 			float zoomFactor;
 			if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
 			else {
@@ -761,7 +785,7 @@
 				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
 					newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
 				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
-					newImageRect.y = mapImage1to1.getHeight()- newImageWidth;
+					newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
 				// crop if after shifting still overlapping
 				if (newImageRect.x < 0) 
 					newImageRect.x = 0;
@@ -772,46 +796,64 @@
 				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
 					newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
 			}
-			zoomUnscaled(zoomFactor, newImageRect, center);
+			zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
 		}
 
+		public void zoom1to1() {
+			CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+			zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		}
+		
 /**
  * do the actual scaling
- * @param zoomFactor
+ * @param zoomFactor relative to original image
  * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
  * @param center
  */		
-		public void zoomUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
-			int saveprop = mmp.mapImage.properties;
-			AniImage tmp = null; // = mmp.mapImage;
-			mmp.removeImage(mmp.mapImage);
-			if (mmp.mapImage != mapImage1to1) {
-				mmp.mapImage .free();
-				mmp.mapImage = null;
-			} else tmp = mapImage1to1;
+		public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+			Vm.showWait(true);
+			boolean savegpsstatus = ignoreGps;
+			if (mapImage1to1 != null) {
+				ignoreGps = true; // avoid multi-thread problems
+				int saveprop = AniImage.IsMoveable;
+				AniImage tmp = null; // = mmp.mapImage;
+				if (mmp.mapImage != null) {
+					saveprop = mmp.mapImage.properties;
+					mmp.removeImage(mmp.mapImage);
+					if (mmp.mapImage != mapImage1to1) {
+						mmp.mapImage .free();
+						mmp.mapImage = null;
+					} else tmp = mapImage1to1;
+				}
+				Vm.getUsedMemory(true);
+				try {
+					tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+					currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+				} catch (OutOfMemoryError e) {
+					(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();}
+				Vm.getUsedMemory(true);
+				mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+				mmp.mapImage.properties = saveprop;
+				mmp.addImage(mmp.mapImage);
+				mmp.images.moveToBack(mmp.mapImage);
+				if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+				{
+					Point mappos = getMapPositionOnScreen();
+					mmp.mapImage.move(mappos.x,mappos.y);
+				}
+			} else // no map image loaded 
+				{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+
+			destroyOverlaySet();
 			Vm.getUsedMemory(true);
-			try {
-				tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor*currentMap.zoomFactor), (int)(newImageRect.height*zoomFactor*currentMap.zoomFactor), newImageRect, 0));
-				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-			} catch (OutOfMemoryError e) {(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();}
-			Vm.getUsedMemory(true);
-			mmp.mapImage = tmp; // use old image in case of OutOfMemoryError
-			mmp.mapImage.properties = saveprop;
-			mmp.addImage(mmp.mapImage);
-			mmp.images.moveToBack(mmp.mapImage);
-			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-			{
-				Point mappos = getMapPositionOnScreen();
-				mmp.mapImage.move(mappos.x,mappos.y);
-			}
-			destroyOverlaySet();
 			setCenterOfScreen(center);
 			addOverlaySet();
 			this.repaintNow();
 			Vm.showWait(false);
+			ignoreGps = savegpsstatus;
 		}
-		
 
+
 		public void onEvent(Event ev){
 			if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
 				gotoPanel.runMovingMap = false;
@@ -830,6 +872,7 @@
 		Point saveMapLoc = null;
 		boolean saveGpsIgnoreStatus;
 		boolean paintingZoomArea;
+		ImageList saveImageList = null;
 		int lastZoomWidth , lastZoomHeight;
 		public MovingMapPanel(MovingMap f){
 			this.mm = f;
@@ -837,53 +880,24 @@
 		public boolean imageBeginDragged(AniImage which,Point pos) {
 			if (mm.zoomingMode == true) {
 				saveMapLoc = pos;
+				mm.ignoreGps = true;
 				return false;
 			}
 			if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
 			saveGpsIgnoreStatus = mm.ignoreGps; 
 			mm.ignoreGps = true;
 			saveMapLoc = pos;
+			bringMapToTop();
 			return super.imageBeginDragged(mapImage, pos);
 		}
 		
-/*		public boolean imageDragged(ImageDragContext dc,Point where) {
-			if (mm.zoomingMode == false) return super.imageDragged(dc, where);
-			dc.
-			void updateArea(DragContext dc,boolean doImage,boolean update)
-//			-------------------------------------------------------------------
-			{
-				if (imagePos == null) imagePos = new Point().set(dc.prevPoint.x,dc.prevPoint.y);
-				if (update) getUpdateArea(imagePos,dc.curPoint,null,null,imagePos);
-				Graphics g = ib.get(updateArea.width,updateArea.height,true);
-				g.setColor(new Color(0xff,0,0));
-				g.fillRect(0,0,updateArea.width,updateArea.height);
-				g.translate(-updateArea.x,-updateArea.y);
-				if (copied == null){
-					window.repaintNow(g,updateArea);
-					if (doImage) image.draw(g,imagePos.x-cx+wx,imagePos.y-cy+wy,0);
-
-				}else{
-					g.drawImage(copied,0,0);
-					if (doImage) image.draw(g,imagePos.x-cx+wx,imagePos.y-cy+wy,0);
-				}
-				if (relativeImagePos == null) relativeImagePos = new Point();
-				relativeImagePos.set(imagePos.x-cx,imagePos.y-cy);
-				wg.drawImage(ib.image,updateArea.x,updateArea.y);
-				wg.flush();
-				g.translate(updateArea.x,updateArea.y);
-				if (clearPendingDrags) dc.clearPendingDrags();
-			}
-
-		}
-		*/
-		
-
 		public boolean imageNotDragged(ImageDragContext dc,Point pos){
 			boolean ret = super.imageNotDragged(dc, pos);
 			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 			mm.ignoreGps = saveGpsIgnoreStatus;
+			bringMaptoBack();
+			this.repaintNow();
 			return ret;
-
 		}
 		
 		public void onPenEvent(PenEvent ev) {
@@ -895,6 +909,10 @@
 			if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
 				paintingZoomArea = false;
 				mm.zoomingMode = false;
+				if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
+					repaintNow();
+					return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+				}
 				mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 			}
 			
@@ -918,6 +936,23 @@
 			super.onPenEvent(ev);
 		}
 		
+		private void bringMapToTop() {
+			if (mapImage == null || (mapImage.properties & AniImage.IsInvisible) > 0 ) return;
+			saveImageList = new ImageList();
+			saveImageList.copyFrom(images);
+			images.removeAllElements();
+			//images.remove(mapImage);
+			//mapImage.properties |= AniImage.AlwaysOnTop;
+			images.add(mapImage);
+		}
+		private void bringMaptoBack() {
+			//mapImage.properties &= ~AniImage.AlwaysOnTop;
+			//images.moveToBack(mapImage);
+			if (saveImageList == null) return;
+			images=saveImageList;
+			saveImageList = null;
+		}
+		
 		public void moveMap(int diffX, int diffY) {
 			Point p = new Point();
 			if (mapImage!= null) {
@@ -970,7 +1005,7 @@
 		 *	Method to react to user.
 		 */
 		public void imageClicked(AniImage which, Point pos){
-			if (which == mm.ButtonImageChooseMap){
+			if (which == mm.bottonImageChooseMap){
 				mapsMenu = new Menu(new String[]{"Select a map manually$s", "Change map directory$c"}, "map choice");
 				if (!mm.noMapsAvailable) 
 				{
@@ -980,17 +1015,25 @@
 				//m.set(Menu., status)
 				mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
 			}
-			if (which == mm.ButtonImageGpsOn) {
+			if (which == mm.buttonImageGpsOn) {
 				if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
 					mm.gotoPanel.startGps();
 					mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
 				} 
 				mm.SnapToGps();
 			}
-			if (which == mm.ButtonImageLens) {
+			if (which == mm.buttonImageLens) {
 				mm.setZoomingMode();
 			}
-
+			if (which == mm.buttonImageZoom1to1) {
+				mm.zoom1to1();
+			}
+			if (which == mm.bottonImageClose) {
+				WindowEvent tmp = new WindowEvent();
+				tmp.type = WindowEvent.CLOSE;
+				mm.postEvent(tmp);
+			}
+				
 			/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}
 		if (which == mm.arrowDown)	{	moveMap(0,-10);	}

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-01-14 19:47:46 UTC (rev 397)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-01-15 04:09:21 UTC (rev 398)
@@ -24,6 +24,7 @@
 	public Point trackPixels[] = null;
 	public Color trackPixelsColor[] = null;
 	public int numPixels = 0;
+	final static int maxPixelsInCache = 500;
 	final static Color transparentColor = Color.White;
 	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
 		topLeft = new TrackPoint(topLefti);
@@ -109,7 +110,7 @@
 	}
 
 	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
-		if (trackPixels==null) { trackPixels = new Point[500]; trackPixelsColor = new Color[500]; } 
+		if (trackPixels==null) { trackPixels = new Point[maxPixelsInCache]; trackPixelsColor = new Color[maxPixelsInCache]; } 
 		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
 		trackPixelsColor[numPixels] = f.getCopy();
 		numPixels++;



From bilbowolf at mail.berlios.de  Mon Jan 15 14:28:59 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Mon, 15 Jan 2007 14:28:59 +0100
Subject: [Cachewolf-svn] r399 - trunk/src/CacheWolf
Message-ID: <200701151328.l0FDSxFx008716@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-15 14:28:54 +0100 (Mon, 15 Jan 2007)
New Revision: 399

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/Profile.java
Log:
Arbeiten am Filter

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-15 04:09:21 UTC (rev 398)
+++ trunk/src/CacheWolf/Filter.java	2007-01-15 13:28:54 UTC (rev 399)
@@ -11,9 +11,6 @@
 */
 public class Filter{
 	
-	// Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
-	
-	
 	public static final int SMALLER = -1;
 	public static final int GREATER = 1;
 	public static final int FOUND = 2;

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-01-15 04:09:21 UTC (rev 398)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-01-15 13:28:54 UTC (rev 399)
@@ -60,28 +60,43 @@
 		content.addLast(foundIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		content.addNext(archivedChk = new mCheckBox((String)lr.get(710,"Archived")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		archivedChk.state = (Global.getProfile().filterVar.charAt(0) == '1' ? true : false);
 		content.addLast(notAvailableChk = new mCheckBox((String)lr.get(711,"Not available")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		notAvailableChk.state = (Global.getProfile().filterVar.charAt(1) == '1' ? true : false);
 		
 		content.addNext(foundChk = new mCheckBox((String)lr.get(703,"Found")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		foundChk.state = (Global.getProfile().filterVar.charAt(2) == '1' ? true : false);
 		content.addLast(ownedChk = new mCheckBox((String)lr.get(707,"Owned")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		ownedChk.state = (Global.getProfile().filterVar.charAt(3) == '1' ? true : false);
 		
 		CellPanel ctype = new CellPanel();
 		
 		ctype.addLast(new mLabel("__________"));
 		ctype.addNext(tradChk = new mCheckBox("Traditonal"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		tradChk.state = (Global.getProfile().filterType.charAt(0) == '1' ? true : false);
 		ctype.addNext(multiChk = new mCheckBox("Multi"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		multiChk.state = (Global.getProfile().filterType.charAt(1) == '1' ? true : false);
 		ctype.addLast(virtualChk = new mCheckBox("Virtual"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		virtualChk.state = (Global.getProfile().filterType.charAt(2) == '1' ? true : false);
 		
 		ctype.addNext(letterChk = new mCheckBox("Letterbox"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		letterChk.state = (Global.getProfile().filterType.charAt(3) == '1' ? true : false);
 		ctype.addNext(eventChk = new mCheckBox("Event"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		eventChk.state = (Global.getProfile().filterType.charAt(4) == '1' ? true : false);
 		ctype.addLast(webcamChk = new mCheckBox("Webcam"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		webcamChk.state = (Global.getProfile().filterType.charAt(5) == '1' ? true : false);
 		
 		ctype.addNext(mysteryChk = new mCheckBox("Mystery"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		mysteryChk.state = (Global.getProfile().filterType.charAt(6) == '1' ? true : false);
 		ctype.addNext(earthChk = new mCheckBox("Earth"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		earthChk.state = (Global.getProfile().filterType.charAt(7) == '1' ? true : false);
 		ctype.addLast(loclessChk = new mCheckBox("Locationless"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		loclessChk.state = (Global.getProfile().filterType.charAt(8) == '1' ? true : false);
 		
 		ctype.addNext(megaChk = new mCheckBox("Mega-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		megaChk.state = (Global.getProfile().filterType.charAt(9) == '1' ? true : false);
 		ctype.addLast(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		addiWptChk.state = (Global.getProfile().filterType.charAt(10) == '1' ? true : false);
 		ctype.addLast(new mLabel("__________"));
 		content.addLast(ctype, CellConstants.STRETCH,CellConstants.FILL);
 		
@@ -90,27 +105,42 @@
 		//ImageControl ic = new ImageControl(img);
 		//mLabel ic = new mLabel("");
 		roseP.addNext(NW = new mCheckBox("NW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		NW.state = (Global.getProfile().filterRose.charAt(0) == '1' ? true : false);
 		roseP.addNext(NNW = new mCheckBox("NNW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		NNW.state = (Global.getProfile().filterRose.charAt(1) == '1' ? true : false);
 		roseP.addNext(N = new mCheckBox("N"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		N.state = (Global.getProfile().filterRose.charAt(2) == '1' ? true : false);
 		roseP.addLast(NNE = new mCheckBox("NNE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		NNE.state = (Global.getProfile().filterRose.charAt(3) == '1' ? true : false);
 		
 		roseP.addNext(NE = new mCheckBox("NE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		NE.state = (Global.getProfile().filterRose.charAt(4) == '1' ? true : false);
 		roseP.addNext(WNW = new mCheckBox("WNW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		WNW.state = (Global.getProfile().filterRose.charAt(5) == '1' ? true : false);
 		roseP.addNext(ENE = new mCheckBox("ENE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		ENE.state = (Global.getProfile().filterRose.charAt(6) == '1' ? true : false);
 		roseP.addLast(W = new mCheckBox("W "),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		W.state = (Global.getProfile().filterRose.charAt(7) == '1' ? true : false);
 		
 		roseP.addNext(E = new mCheckBox("E "),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		E.state = (Global.getProfile().filterRose.charAt(8) == '1' ? true : false);
 		roseP.addNext(WSW = new mCheckBox("WSW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		WSW.state = (Global.getProfile().filterRose.charAt(9) == '1' ? true : false);
 		roseP.addNext(ESE = new mCheckBox("ESE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		ESE.state = (Global.getProfile().filterRose.charAt(10) == '1' ? true : false);
 		roseP.addLast(SW = new mCheckBox("SW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		SW.state = (Global.getProfile().filterRose.charAt(11) == '1' ? true : false);
 		
 		roseP.addNext(SSW = new mCheckBox("SSW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		SSW.state = (Global.getProfile().filterRose.charAt(12) == '1' ? true : false);
 		roseP.addNext(S = new mCheckBox("S"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		S.state = (Global.getProfile().filterRose.charAt(13) == '1' ? true : false);
 		roseP.addNext(SSE = new mCheckBox("SSE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		SSE.state = (Global.getProfile().filterRose.charAt(14) == '1' ? true : false);
 		roseP.addLast(SE = new mCheckBox("SE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		SE.state = (Global.getProfile().filterRose.charAt(15) == '1' ? true : false);
 		
 		content.addLast(roseP, CellConstants.STRETCH,CellConstants.FILL);
-		
 		CellPanel btPanel = new CellPanel();
 		btPanel.addNext(btCancel = new mButton((String)lr.get(708,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
 		btPanel.addNext(btApply = new mButton((String)lr.get(709,"Apply")),CellConstants.STRETCH, CellConstants.FILL);

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-15 04:09:21 UTC (rev 398)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-15 13:28:54 UTC (rev 399)
@@ -48,7 +48,7 @@
 		// Load CacheList
 		InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
 		infB.exec();
-//		infB.waitUntilPainted(1000);
+		infB.waitUntilPainted(1000);
 		try{
 			pref.readPrefFile();
 			addGuiFont();

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-15 04:09:21 UTC (rev 398)
+++ trunk/src/CacheWolf/Profile.java	2007-01-15 13:28:54 UTC (rev 399)
@@ -34,6 +34,10 @@
 	/** Distance for opencaching caches */
 	public String distOC = new String();
 	
+	public String filterType = new String("11111111110");
+	public String filterRose = new String("1111111111111111");
+	//filter settings for archived ... owner (section) in filterscreen
+	public String filterVar = new String("0000");
 	//TODO Add the current filter settings here so that they are restored when the profile is reloaded
 	//TODO Add other settings, such as max. number of logs to spider
 	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
@@ -166,6 +170,8 @@
 					last_sync_opencaching=text.substring(start,text.indexOf("\"",start));
 					start=text.indexOf("dist = \"")+8;
 					distOC=text.substring(start,text.indexOf("\"",start));
+				} else if (text.indexOf("<FILTER")>=0){
+//					 Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}
 			in.close();



From bilbowolf at mail.berlios.de  Mon Jan 15 14:32:07 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Mon, 15 Jan 2007 14:32:07 +0100
Subject: [Cachewolf-svn] r400 - trunk/src/CacheWolf
Message-ID: <200701151332.l0FDW7dX009280@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-15 14:32:03 +0100 (Mon, 15 Jan 2007)
New Revision: 400

Modified:
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/Version.java
Log:
Der PPC sollte sich jetzt nicht mehr von alleine ausschalten

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-15 13:28:54 UTC (rev 399)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-15 13:32:03 UTC (rev 400)
@@ -66,6 +66,7 @@
 			if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
 				//Vm.setSIP(Vm.SIP_LEAVE_BUTTON|Vm.SIP_ON);
 				Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
+				Device.preventIdleState(true);
 			}
 		} else Vm.setSIP(0);
 		//Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-01-15 13:28:54 UTC (rev 399)
+++ trunk/src/CacheWolf/Version.java	2007-01-15 13:32:03 UTC (rev 400)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " BE ";
-	static final String VER_SVN ="$LastChangedRevision$"; //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From admin at berlios.de  Mon Jan 15 21:19:50 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 15 Jan 2007 21:19:50 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #1964] Blacklist
Message-ID: <200701152019.l0FKJo3A022900@unicorn.berlios.de>

Feature Request #1964, was updated on 2006-Mar-16 00:49
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1964&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Blacklist

By: bilbowolf
Date: 2007-Jan-15 21:19

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

in der BE 400 enthalten

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Mar-16 00:49

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; IE Autoconfiguration; .NET CLR 1.1.4322)

Eine blacklist blendet die caches aus, die man 
einfach nicht mehr sehen m?chte.

Es sollte aber die M?glichkeit geben, die Blacklist 
bearbeiten zu k?nnen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1964&group_id=2211


From admin at berlios.de  Mon Jan 15 21:20:03 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 15 Jan 2007 21:20:03 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #1964] Blacklist
Message-ID: <200701152020.l0FKK3p1022915@unicorn.berlios.de>

Feature Request #1964, was updated on 2006-Mar-16 00:49
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1964&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Blacklist

By: bilbowolf
Date: 2007-Jan-15 21:20

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

in der BE 400 enthalten

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Mar-16 00:49

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; IE Autoconfiguration; .NET CLR 1.1.4322)

Eine blacklist blendet die caches aus, die man 
einfach nicht mehr sehen m?chte.

Es sollte aber die M?glichkeit geben, die Blacklist 
bearbeiten zu k?nnen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1964&group_id=2211


From admin at berlios.de  Mon Jan 15 21:20:31 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 15 Jan 2007 21:20:31 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #1964] Blacklist
Message-ID: <200701152020.l0FKKVHB022957@unicorn.berlios.de>

Feature Request #1964, was updated on 2006-Mar-16 00:49
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1964&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Blacklist

By: bilbowolf
Date: 2006-Mar-16 00:49

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; IE Autoconfiguration; .NET CLR 1.1.4322)

Eine blacklist blendet die caches aus, die man 
einfach nicht mehr sehen m?chte.

Es sollte aber die M?glichkeit geben, die Blacklist 
bearbeiten zu k?nnen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1964&group_id=2211


From admin at berlios.de  Mon Jan 15 21:42:11 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 15 Jan 2007 21:42:11 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9979] Spider arbeitet fehlerhaft
Message-ID: <200701152042.l0FKgBSG024947@unicorn.berlios.de>

Bug #9979, was updated on 2007-Jan-14 19:36
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: cw-tester
Assigned to : none
Summary: Spider arbeitet fehlerhaft

Details: Sowohl bei OC als auch GC wird fehlerhaft gespidert.
Der eingegebene Radius wird nicht eingehalten. Als Ergebnis wirden mehr Caches gespidert als gew?nscht.
Dar?ber hinaus werden einige Add-WP mit den Koordinaten N 00? 00.000 E 00? 00.000. Eine Systematik kann ich nicht erkennen.

Follow-Ups:

Date: 2007-Jan-15 21:42
By: bilbowolf

Comment:
Dass einige Addi WP mit "0" Koord angezeigt werden ist einfach. Diese haben einfach keine Koordinaten...

Oder habe ich was falsch verstanden.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9979&group_id=2211


From admin at berlios.de  Mon Jan 15 21:43:56 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 15 Jan 2007 21:43:56 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3054] Notizen per Button anzeigen
Message-ID: <200701152043.l0FKhu3e025081@unicorn.berlios.de>

Feature Request #3054, was updated on 2007-Jan-15 21:43
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3054&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Notizen per Button anzeigen

By: bilbowolf
Date: 2007-Jan-15 21:43

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

und aus der Detailbeschreibung entfernen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3054&group_id=2211


From bilbowolf at mail.berlios.de  Mon Jan 15 22:22:16 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Mon, 15 Jan 2007 22:22:16 +0100
Subject: [Cachewolf-svn] r401 - trunk/src/CacheWolf
Message-ID: <200701152122.l0FLMGcN003562@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-15 22:22:03 +0100 (Mon, 15 Jan 2007)
New Revision: 401

Added:
   trunk/src/CacheWolf/NotesScreen.java
Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainTab.java
Log:
notizen in ein seperates fenster gebracht!

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-15 13:32:03 UTC (rev 400)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-15 21:22:03 UTC (rev 401)
@@ -18,12 +18,12 @@
 	mInput wayHidden = new mInput();
 	mInput wayOwner = new mInput();
 	//mInput wayStatus = new mInput();
-	mTextPad wayNotes = new mTextPad();
+	
 	mButton btnDelete,btnCenter;
 	mChoice wayType = new mChoice(new String[]{"Custom", "Traditional", "Multi", "Virtual", "Letterbox", "Event", "Mega Event", "Mystery", "Webcam", "Locationless", "CITO", "Earthcache", "Parking", "Stage", "Question", "Final","Trailhead","Reference"},0);
 	mChoice waySize = new mChoice(new String[]{"", "Micro", "Small", "Regular", "Large","Other","Very Large","None"},0);
 	mComboBox wayStatus = new mComboBox(new String[]{"", MyLocale.getMsg(313,"Flag 1"), MyLocale.getMsg(314,"Flag 2"), MyLocale.getMsg(315,"Flag 3"), MyLocale.getMsg(316,"Flag 4"), MyLocale.getMsg(317,"Search"), MyLocale.getMsg(318,"Found"), MyLocale.getMsg(319,"Not Found"), MyLocale.getMsg(320,"Owner")},0);
-	mButton btCrWp, showBug, showMap, addDateTime, btnGoto, addPicture, btnBlack;
+	mButton btCrWp, showBug, showMap, btnGoto, addPicture, btnBlack, btNotes;
 	Vector cacheDB;
 	CacheHolder thisCache;
 	CellPanel toolP = new CellPanel();
@@ -47,19 +47,18 @@
 		toolP.addNext(btnGoto = new mButton("Goto"),CellConstants.DONTSTRETCH, CellConstants.WEST);
 		mImage mI = new mImage("bug.gif");
 		mImage mI2 = new mImage("globe_small.gif");
-		mImage mI3 = new mImage("date_time.png");
+		
 		mImage mI4 = new mImage("images.gif");
 		mNoBlack = new mImage("no_black.png");
 		mIsBlack = new mImage("is_black.png");
 		showBug = new mButton((IImage)mI);
 		showMap = new mButton((IImage)mI2);
-		addDateTime = new mButton((IImage)mI3);
+		
 		addPicture = new mButton((IImage)mI4);
 		btnBlack = new mButton((IImage)mNoBlack);
 		toolP.addNext(showBug,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		showBug.modify(Control.Disabled,0);
 		toolP.addNext(showMap,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		toolP.addNext(addDateTime,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		toolP.addNext(addPicture,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		toolP.addLast(btnBlack,CellConstants.DONTSTRETCH, CellConstants.WEST);
 			
@@ -89,13 +88,12 @@
 		this.addNext(new mLabel(MyLocale.getMsg(307,"Status:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		this.addLast(wayStatus.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
-		this.addNext(new mLabel(MyLocale.getMsg(308,"Notes:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		btNotes = new mButton("Notes");
+		this.addLast(btNotes.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		//this.addNext(new mLabel(MyLocale.getMsg(308,"Notes:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//this.addLast(btnCenter = new mButton(MyLocale.getMsg(309,"Make Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 //		this.addLast(btnDelete = new mButton(MyLocale.getMsg(310,"Delete")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-
-		ScrollBarPanel sbp = new ScrollBarPanel(wayNotes);
-		//this.addLast(sbp, this.STRETCH, this.FILL);
-		this.addLast(sbp.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		
 	}
 	
 	/**
@@ -124,7 +122,7 @@
 		wayHidden.setText(ch.DateHidden);
 		wayOwner.setText(ch.CacheOwner);
 		wayStatus.setText(ch.CacheStatus);
-		wayNotes.setText(ch.CacheNotes);
+		
 		wayType.setInt(transType(ch.type));
 		if(ch.is_black){
 			btnBlack.image = mIsBlack;
@@ -253,7 +251,6 @@
 		thisCache.DateHidden = wayHidden.getText();
 		thisCache.CacheOwner = wayOwner.getText();
 		thisCache.CacheStatus = wayStatus.getText();
-		thisCache.CacheNotes = wayNotes.getText();
 		thisCache.type = transSelect(wayType.getInt());
 		//cacheDB.add(ch);
 		
@@ -270,26 +267,18 @@
 	*/
 	public void onEvent(Event ev){
 		/**
-		*	User changed status or notes.
+		*	User changed status.
 		*/
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.FOCUS_OUT){
-			if(ev.target == wayNotes){
-				if(wayNotes.getText().length() > 0){
-					////Vm.debug("Saving!!!");
-					thisCache.CacheNotes = wayNotes.getText();
-					thisCache.saveCacheDetails( profile.dataDir);
-				}
-			}
-			if(ev.target != wayNotes){
-				dirty_status = true;
-			}
-		}
 		/**
 		*	User wishes to either delete a cache or to set the cache as
 		*	a center location.<br>
 		*	Also possible: the user created a custom waypoint.
 		*/
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if(ev.target == btNotes){
+				NotesScreen nsc = new NotesScreen(thisCache, profile);
+				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
+			}
 			if (ev.target == btnDelete){
 				//Vm.debug(thisCache.CacheName);
 //TODO This does not work. e.g. if we do a sort we get an indexOutOfBounds exception
@@ -320,18 +309,7 @@
 					mainT.updateBearDist();
 				}
 			}
-			if (ev.target == addDateTime){
-				String note = wayNotes.getText();
-				Time dtm = new Time();
-				dtm.getTime();
-				dtm.setFormat("E dd.MM.yyyy '/' H:m");
-				if(note.length() > 0)	note = note + "\n" + dtm.toString();
-				else 	note = note + dtm.toString();
-				note = note + "\n";
-				wayNotes.setText(note);
-				thisCache.CacheNotes = wayNotes.getText();
-				thisCache.saveCacheDetails(profile.dataDir);
-			}
+			
 			if (ev.target == addPicture){
 				thisCache.addUserImage(profile);
 			}
@@ -360,7 +338,6 @@
 					wayHidden.setText("");
 					wayOwner.setText("");
 					wayStatus.setText("");
-					wayNotes.setText("");
 					wayType.setInt(0);
 					waySize.setInt(7);
 					thisCache.wayPoint = wayPoint.getText();

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-15 13:32:03 UTC (rev 400)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-15 21:22:03 UTC (rev 401)
@@ -122,7 +122,7 @@
 					  ch.DateHidden = detP.wayHidden.getText();
 					  ch.CacheOwner = detP.wayOwner.getText();
 					  if(pref.myAlias.equals(ch.CacheOwner)) ch.is_owned = true;
-					  ch.CacheNotes = detP.wayNotes.getText();
+					  
 					  ch.type = detP.transSelect(detP.wayType.getInt());
 					  // set status also on addi wpts
 					  if (ch.hasAddiWpt()){

Added: trunk/src/CacheWolf/NotesScreen.java
===================================================================
--- trunk/src/CacheWolf/NotesScreen.java	2007-01-15 13:32:03 UTC (rev 400)
+++ trunk/src/CacheWolf/NotesScreen.java	2007-01-15 21:22:03 UTC (rev 401)
@@ -0,0 +1,58 @@
+package CacheWolf;
+import ewe.ui.*;
+import ewe.io.*;
+import ewe.graphics.*;
+import ewe.fx.*;
+import ewe.util.*;
+import ewe.sys.*;
+import ewe.filechooser.*;
+
+/**
+*	This class displays a form to show and edit notes for a cache.
+*	Class ID=
+*/
+public class NotesScreen extends Form{
+	mTextPad wayNotes = new mTextPad();
+	CacheHolder thisCache = new CacheHolder();
+	mButton addDateTime, btSave;
+	Profile profile;
+	
+	public NotesScreen(CacheHolder ch, Profile profile){
+		this.title = "Notes";
+		this.setPreferredSize(Global.getPref().myAppWidth, Global.getPref().myAppHeight);
+		thisCache = ch;
+		this.profile = profile;
+		mImage mI3 = new mImage("date_time.png");
+		addDateTime = new mButton((IImage)mI3);
+		CellPanel cp = new CellPanel();
+		btSave = new mButton("Save");
+		cp.addNext(addDateTime);
+		cp.addLast(btSave);
+		ScrollBarPanel sbp = new ScrollBarPanel(wayNotes);
+		wayNotes.setText(thisCache.CacheNotes);
+		//this.addLast(sbp, this.STRETCH, this.FILL);
+		this.addLast(sbp.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		this.addLast(cp);
+	}
+	
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == addDateTime){
+				String note = wayNotes.getText();
+				Time dtm = new Time();
+				dtm.getTime();
+				dtm.setFormat("E dd.MM.yyyy '/' H:m");
+				if(note.length() > 0)	note = note + "\n" + dtm.toString();
+				else 	note = note + dtm.toString();
+				note = note + "\n";
+				wayNotes.setText(note);
+			}
+			if(ev.target == btSave){
+				thisCache.CacheNotes = wayNotes.getText();
+				thisCache.saveCacheDetails( profile.dataDir);
+				this.close(0);
+			}
+		}
+		super.onEvent(ev);
+	}
+}



From admin at berlios.de  Tue Jan 16 22:48:55 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 16 Jan 2007 22:48:55 +0100 (CET)
Subject: [Feature #3059] TPL-Datei für Express Logger
Message-ID: <200701162148.l0GLmtse010174@unicorn.berlios.de>

Feature Request #3059, was updated on 2007-Jan-16 22:48
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3059&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: TPL-Datei f?r Express Logger

By: kalli
Date: 2007-Jan-16 22:48

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

siehe http://www.geoclub.de/ftopic13554.html

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3059&group_id=2211


From admin at berlios.de  Tue Jan 16 22:49:13 2007
From: admin at berlios.de (admin at berlios.de)
Date: Tue, 16 Jan 2007 22:49:13 +0100 (CET)
Subject: [Feature #3059] TPL-Datei für Express Logger
Message-ID: <200701162149.l0GLnDHa010424@unicorn.berlios.de>

Feature Request #3059, was updated on 2007-Jan-16 22:48
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3059&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: TPL-Datei f?r Express Logger

By: kalli
Date: 2007-Jan-16 22:48

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

siehe http://www.geoclub.de/ftopic13554.html

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3059&group_id=2211


From admin at berlios.de  Thu Jan 18 09:56:30 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 18 Jan 2007 09:56:30 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10043] be 401 Map.java
Message-ID: <200701180856.l0I8uUWH006392@unicorn.berlios.de>

Bug #10043, was updated on 2007-Jan-18 09:56
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: be 401 Map.java

Details: > GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180

360?

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10043&group_id=2211


From bilbowolf at mail.berlios.de  Thu Jan 18 22:18:17 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Thu, 18 Jan 2007 22:18:17 +0100
Subject: [Cachewolf-svn] r402 - trunk/src/CacheWolf
Message-ID: <200701182118.l0ILIHp5001910@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-18 22:18:14 +0100 (Thu, 18 Jan 2007)
New Revision: 402

Modified:
   trunk/src/CacheWolf/FilterScreen.java
Log:
Weitere arbeiten am Filter

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-01-15 21:22:03 UTC (rev 401)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-01-18 21:18:14 UTC (rev 402)
@@ -190,6 +190,9 @@
 				flt.by = foundIn.getText();
 				flt.notAvailable = notAvailableChk.getState();
 				flt.archived = archivedChk.getState();
+				String filterType = new String();
+				String filterVar = new String();
+				String filterRose = new String();
 				
 				int typeMatchPattern = 0;
 				if(tradChk.getState()) typeMatchPattern |= Filter.TRADITIONAL;
@@ -204,6 +207,19 @@
 				if(earthChk.getState()) typeMatchPattern |= Filter.EARTH;
 				if(megaChk.getState()) typeMatchPattern |= Filter.MEGA;
 				flt.typeMatchPattern = typeMatchPattern;
+				filterType = 	(tradChk.getState() == true ? "1" : "0") +
+								(multiChk.getState() == true ? "1" : "0") +
+								(virtualChk.getState() == true ? "1" : "0") +
+								(letterChk.getState() == true ? "1" : "0") +
+								(eventChk.getState() == true ? "1" : "0")+ 
+								(webcamChk.getState() == true ? "1" : "0")+
+								(multiChk.getState() == true ? "1" : "0") +
+								(mysteryChk.getState() == true ? "1" : "0")+
+								(earthChk.getState() == true ? "1" : "0")+
+								(loclessChk.getState() == true ? "1" : "0")+
+								(megaChk.getState() == true ? "1" : "0")+
+								(addiWptChk.getState() == true ? "1" : "0");
+				
 				int roseMatchPattern = 0;
 				if(N.getState()) roseMatchPattern |= Filter.N;
 				if(NNE.getState()) roseMatchPattern |= Filter.NNE;
@@ -222,6 +238,8 @@
 				if(NNW.getState()) roseMatchPattern |= Filter.NNW;
 				if(S.getState()) roseMatchPattern |= Filter.S;
 				flt.roseMatchPattern = roseMatchPattern;
+				filterRose = "";
+				
 				if(distChc.selectedIndex == 1) flt.distdirec = Filter.SMALLER;
 				else flt.distdirec = Filter.GREATER;
 				if(difChc.selectedIndex == 1) flt.diffdirec = Filter.SMALLER;



From admin at berlios.de  Fri Jan 19 03:05:51 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 03:05:51 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3045] MavingMap: Karte ausblenden
Message-ID: <200701190205.l0J25pYm013904@unicorn.berlios.de>

Feature Request #3045, was updated on 2007-Jan-12 16:05
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MavingMap: Karte ausblenden

By: pfeffer
Date: 2007-Jan-19 03:05

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

ist schon in BE 400 drin, bitte testen.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 16:06

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211


From admin at berlios.de  Fri Jan 19 03:07:52 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 03:07:52 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3046] MovingMap: Zommen
Message-ID: <200701190207.l0J27qZH013986@unicorn.berlios.de>

Feature Request #3046, was updated on 2007-Jan-13 14:22
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: MovingMap: Zommen

By: pfeffer
Date: 2007-Jan-19 03:07

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

ist erldeigt, irgendwann kurz vor SVN 403

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-13 14:35

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

das wesentliche ist mit SVN 382 erledigt.
Verbesserungen sind noch vorgesehen  bei der 
Verschiebung des Ausschnitts sowohl auf dem 
Bildschirm alsauch bei der Beschneidung des Bildes beim 
zoomen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211


From admin at berlios.de  Fri Jan 19 03:09:40 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 03:09:40 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3062] MovingMap: Kartendownload von
	Expedia
Message-ID: <200701190209.l0J29eNl014073@unicorn.berlios.de>

Feature Request #3062, was updated on 2007-Jan-19 03:09
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3062&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Kartendownload von Expedia

By: pfeffer
Date: 2007-Jan-19 03:09

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: automatischer Kartendownload von 
Expedia

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3062&group_id=2211


From pfeffer at mail.berlios.de  Fri Jan 19 03:25:46 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 19 Jan 2007 03:25:46 +0100
Subject: [Cachewolf-svn] r403 - in trunk: resources src/CacheWolf
Message-ID: <200701190225.l0J2PkxQ004407@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-19 03:25:29 +0100 (Fri, 19 Jan 2007)
New Revision: 403

Added:
   trunk/src/CacheWolf/MapLoaderGui.java
Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MapLoader.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
funktioniert, aber aus den Importern muss der Kartendownload noch entfernt werden: [ Feature Request #3062 ] MovingMap: Kartendownload von Expedia
Ich habe der Cacheholder-Klasse einen Member CWPoint pos spendiert. pos wird gesetzt von updatebearing, wenn es null war. - Sollte vielleicht noch direkt in den Einleseprozess verlagert werden? 
<ctrl-a> makiert alle Caches in der Listenansicht

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-19 02:25:29 UTC (rev 403)
@@ -55,6 +55,7 @@
 		159=Filter
 		160=Selektierte
 		161=Zeige Blacklist
+		162=kalibrierte herunterladen
 		200=Details
 		201=Beschreibung
 		202=Bilder
@@ -100,7 +101,7 @@
 		600=Pr%e4ferenzen
 		601=Dein Alias:
 		602=Heimatkoordinaten:
-		603=Profilverzeichnis
+		603=Verzeichnis f%dcr Profile
 		604=Suchen
 		605=Tabellenspalten:
 		606=Schwierigkeit
@@ -239,6 +240,8 @@
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
 		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp?ter erneut versuchen\n Status:
+		1700=Georeferenzierte Karten herunterladen
+		1701=Kacheln herunterladen
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 
@@ -344,6 +347,7 @@
 		158=Version Check
 		159=Filter
 		161=Show Blacklist
+		162=Download calibrated
 		200=Details
 		201=Description
 		202=Images
@@ -528,6 +532,8 @@
 		1619=: could not download image from URL:+
 		1620=downloading embedded images:+
 		1621=Error while interpreting data\n from Opencaching.de,\nThis is most probaly a bug at Opencaching.de\nRetry later\n Status:
+		1700=Download georeferenced maps
+		1701=Download tiles
 		1700=Error on line: 
 		1701= position: 
 		1702=Variable not defined: 

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -23,6 +23,7 @@
   public String CacheName = new String();
   public String CacheOwner = new String();
   public String LatLon = new String();
+  public CWPoint pos = null;
   public String DateHidden = new String();
   public String LastUpdate = new String();
   public String Hints = new String();

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -247,7 +247,8 @@
 		//CacheHolder ch = new CacheHolder();
 		thisCache.wayPoint = wayPoint.getText();
 		thisCache.CacheName = wayName.getText();
-		thisCache.LatLon = new CWPoint(btnWayLoc.getText(),CWPoint.REGEX).toString();
+		thisCache.pos = new CWPoint(btnWayLoc.getText(),CWPoint.REGEX);
+		thisCache.LatLon = thisCache.pos.toString();
 		thisCache.DateHidden = wayHidden.getText();
 		thisCache.CacheOwner = wayOwner.getText();
 		thisCache.CacheStatus = wayStatus.getText();

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -273,7 +273,7 @@
 							if(getMaps){
 								ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 								pll.parse();
-								MapLoader mpl = new MapLoader(pll.getLatDeg(),pll.getLonDeg(), pref.myproxy, pref.myproxyport);
+								MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 								mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
 								mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 							}

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -593,12 +593,13 @@
 				if (mainT.tbP.myMod.cacheSelectionChanged) {
 					mainT.tbP.myMod.cacheSelectionChanged = false;
 					mmp.removeAllMapSymbolsButGoto();
+					CacheHolder ch;
 					for (int i=cacheDB.size()-1; i>=0; i--) {
-						CacheHolder ch = (CacheHolder) cacheDB.get(i);
+						ch = (CacheHolder) cacheDB.get(i);
 						if (ch.is_Checked) {
-							CWPoint tmpll = new CWPoint(ch.LatLon);
+							//CWPoint tmpll = new CWPoint(ch.LatLon);
 							int ct = Convert.parseInt(ch.type);
-							mmp.addSymbol(ch.CacheName, new AniImage(myTableModel.cacheImages[ct]), tmpll.latDec, tmpll.lonDec);
+							mmp.addSymbol(ch.CacheName, new AniImage(myTableModel.cacheImages[ct]), ch.pos.latDec, ch.pos.lonDec);
 						}
 					}
 				}

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/InfoBox.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -11,8 +11,8 @@
 	mButton mB = new mButton("OK");
 	mButton mC = new mButton("Cancel");
 	mInput feedback = new mInput();
-	public static int CHECKBOX = 1;
-	public static int INPUT = 2;
+	public final static int CHECKBOX = 1;
+	public final static int INPUT = 2;
 	private int type = 0;
 		
 	public InfoBox(String title, String info){

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -20,7 +20,7 @@
 */
 public class MainMenu extends MenuBar {
 	private MenuItem profiles, preferences,loadcaches,loadOC,savenexit,savenoxit,exit,search,searchClr;
-	private MenuItem kalibmap,importmap;
+	private MenuItem downloadmap, kalibmap, importmap;
 	private MenuItem spider, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTomASC, exportMSARCSV;
@@ -70,9 +70,10 @@
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for maps, part of "Application" menu below
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mapMenuItems = new MenuItem[2];
-		mapMenuItems[0] = importmap = new MenuItem(MyLocale.getMsg(150,"Import"));
-		mapMenuItems[1] = kalibmap = new MenuItem(MyLocale.getMsg(151,"Calibrate"));
+		MenuItem[] mapMenuItems = new MenuItem[3];
+		mapMenuItems[0] = downloadmap = new MenuItem(MyLocale.getMsg(162,"Download calibrated"));
+		mapMenuItems[1] = importmap = new MenuItem(MyLocale.getMsg(150,"Import"));
+		mapMenuItems[2] = kalibmap = new MenuItem(MyLocale.getMsg(151,"Calibrate"));
 		Menu mapsMenu = new Menu(mapMenuItems, null);
 
 		// Now we start with the horizontal menu bar "Application", "Search", "Filter", "Organize", "About"
@@ -421,6 +422,10 @@
 				tbp.saveColWith(pref);
 				ewe.sys.Vm.exit(0);
 			}
+			if(mev.selectedItem == downloadmap){
+				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
+				mLG.exec(); // .execute doesn't work because the tcp-socket uses another thread which cannot be startet if here .execute() is used!
+			}
 			if(mev.selectedItem == kalibmap){
 				SelectMap sM = new SelectMap();
 				sM.execute();

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/Map.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -39,7 +39,7 @@
 	*/
 	public Map(Preferences pref){
 		this.pref = pref;
-		mapsPath = File.getProgramDirectory() + "/maps/";
+		mapsPath = File.getProgramDirectory() + "/maps/"; // TODO veraltet
 	}
 	
 	/**
@@ -70,7 +70,7 @@
 		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		thisMap = mapToLoad;
-		mapsPath = File.getProgramDirectory() + "/maps/";
+		mapsPath = File.getProgramDirectory() + "/maps/"; // TDO veraltet
 		try {
 			wfl.loadwfl(mapsPath, thisMap);
 		}catch(FileNotFoundException ex){

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -5,6 +5,7 @@
 import ewe.io.FileReader;
 import ewe.io.FileWriter;
 import ewe.io.FilenameFilter;
+import ewe.io.File;
 import ewe.io.IOException;
 import ewe.io.PrintWriter;
 import ewe.sys.*;
@@ -56,13 +57,13 @@
 	 * constructes an MapInfoObject without an associated map
 	 * but with 1 Pixel = scale meters
 	 */
-	public MapInfoObject(double scale) {
+	public MapInfoObject(double scale, double lat) {
 		digSep = MyLocale.getDigSeparator();
 		mapName="empty 1 Pixel = "+scale+"meters";
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
 		double pixel2deg = meters2deg * scale;
 		affine[0]=0; //x2lat
-		affine[1]=pixel2deg; //x2lon
+		affine[1]=pixel2deg / java.lang.Math.cos(lat); //x2lon
 		affine[2]=-pixel2deg; //y2lat
 		affine[3]=0; //y2lon
 		affine[4]=1; //top
@@ -74,6 +75,52 @@
 	}
 
 	/**
+	 * constructs an MapInfoObject with an associated map
+	 * with 1 Pixel = scale meters, center and width, hight in pixels
+	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 */
+	public MapInfoObject(double scale, CWPoint center, int width, int hight, String name) {
+		digSep = MyLocale.getDigSeparator();
+		mapName = name+".wfl";
+
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scale;
+		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deghorizontal; //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=center.latDec + hight / 2 *pixel2deg; //top
+		affine[5]=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		lowlat = center.latDec - hight / 2 *pixel2deg; //buttom
+		lowlon = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		fileNameWFL = name;
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+	
+
+	/** 
+	 * @return the filename of the associated map image, "" if no file is associated, null if associated file could not be found
+	 */
+	public String getImageFilename() {
+		if (fileName == null || fileName.length() > 0) return fileName;
+		if (fileNameWFL.length() == 0) return "";
+		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf("."));
+		File tmp;
+		String[] t = {".png", ".gif", ".jpg", ".bmp"};
+		int i;
+		for (i = 0; i<t.length; i++) {
+			tmp = new File(n+t[i]);
+			if (tmp.exists()) break;
+		}
+		
+		if (i >=t.length) fileName = null;
+		else fileName = n+t[i];
+		return fileName;
+	}
+	
+	/**
 	 * Method to load a .wfl-file
 	 * @throws IOException when there was a problem reading .wfl-file
 	 * @throws IOException when lat/lon were out of range
@@ -99,7 +146,7 @@
 			lowlon = Convert.toDouble(line);
 
 			fileNameWFL = mapsPath + thisMap + ".wfl";
-			fileName = mapsPath + thisMap + ".png";
+			fileName = ""; //mapsPath + thisMap + ".png";
 			mapName = thisMap;
 			in.close();
 			if(affine[4] > 90 || affine[4] < -90 || affine[5] < -180 || affine[5] > 360 ||
@@ -145,6 +192,8 @@
 
 	/**
 	 *	Method to save a world file (.wfl)
+	 * @param mapsPath without "/" at the end
+	 * @param mapFileName without file extension
 	 * @throws IOException when there was a problem writing .wfl-file
 	 * @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
 	 */
@@ -163,7 +212,7 @@
 		if (digSep.equals(",")) towrite=towrite.replace(',', '.');
 		outp.print(towrite);
 		outp.close();
-		this.fileName = mapsPath + "/" + mapFileName + ".png";
+		this.fileName = ""; // this will be set in getImageFilenam //mapsPath + "/" + mapFileName + ".png";
 		this.fileNameWFL = mapsPath + "/" + mapFileName + ".wfl";
 		this.mapName = mapFileName;
 	}

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/MapLoader.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -5,6 +5,7 @@
 import ewe.fx.*;
 import ewe.util.*;
 import ewe.sys.*;
+import ewe.sys.Double;
 import ewe.net.*;
 
 /**
@@ -17,39 +18,148 @@
 // http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
 
 
-public class MapLoader{
+public class MapLoader {
 	String proxy = new String();
 	String port = new String();
-	String lat = new String();
-	String lon = new String();
-	String zone = new String();
-	public MapLoader(String lt, String ln, String prxy, String prt){
+	InfoBox progressInfobox;
+	
+	final static float downloadMapScaleFactorExpedia_east = 3950;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL; 
+
+	int numMapsY;
+	int numMapsX;
+	double latinc;
+	double loninc;
+	CWPoint topleft;
+	CWPoint buttomright;
+	Point tilesSize;
+	int tileScale;
+
+	public MapLoader(String prxy, String prt){
 		port = prt;
 		proxy = prxy;
-		lat = lt;
-		lon = ln;
-		zone = "EUR0407";
-		try{
-			if(Convert.parseDouble(ln) <= -10) zone = "USA0409";
-		}catch(Exception ex){
-			ln = ln.replace('.',',');
-			//Vm.debug("Nach ?nderung: " +ln);
-			if(Convert.parseDouble(ln) <= -10) zone = "USA0409";
+		progressInfobox = null;
+	}
+	
+	/**
+	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl 
+	 * in path
+	 * @param center center of all tiles
+	 * @param radius in meters
+	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size in pixels
+	 * @param overlapping 1.2 means 20% overlapping
+	 * @param path without "/" at the end
+	 * 
+	 */
+	public void setTiles (CWPoint center, float radius, int scale, Point size, float overlapping) {
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixels =  radius * 2 / EXPEDIA_METERS_PER_PIXEL / scale;
+		numMapsY = (int) java.lang.Math.ceil(pixels * overlapping / (float)size.y);
+		numMapsX = (int) java.lang.Math.ceil(pixels * overlapping / (float)size.x);
+		latinc =  -(radius * 2 / metersPerLat) / (float)numMapsY; // = lat difference from buttom to top / number of tiles
+		loninc = ( radius * 2 / metersPerLat / java.lang.Math.cos(center.latDec/180*java.lang.Math.PI) ) / numMapsX;
+		topleft = new CWPoint(center.latDec - latinc * numMapsY / 2, center.lonDec - loninc * numMapsX /2);
+		buttomright = new CWPoint(center.latDec + latinc * numMapsY / 2, center.lonDec + loninc * numMapsX /2);
+		this.tilesSize = new Point();
+		this.tilesSize.set(size);
+		this.tileScale = scale;
+	}
+	
+	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, float overlapping) {
+		//if (toplefti.latDec <= buttomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above buttom right");
+		topleft = new CWPoint(toplefti);
+		buttomright = new CWPoint(buttomrighti);
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
+		double metersY = (topleft.latDec - buttomright.latDec) * metersPerLat; 
+		double pixelsY =  metersY / EXPEDIA_METERS_PER_PIXEL / scale;
+		double metersX = -(topleft.lonDec - buttomright.lonDec) * metersPerLon ; 
+		double pixelsX =  metersX / EXPEDIA_METERS_PER_PIXEL / scale;
+		numMapsY = (int) java.lang.Math.ceil(pixelsY * overlapping / (float)size.y);
+		numMapsX = (int) java.lang.Math.ceil(pixelsX * overlapping / (float)size.x);
+		latinc = -(topleft.latDec - buttomright.latDec)/ (double)numMapsY; // = lat difference from buttom to top / number of tiles
+		loninc = -(topleft.lonDec - buttomright.lonDec)/ (double)numMapsX;
+		this.tilesSize = new Point();
+		this.tilesSize.set(size);
+		this.tileScale = scale;
+	}
+
+	public void downlaodTiles(String tilesPath) {
+		int row = 0, col;
+		for (double lat = topleft.latDec; lat >= buttomright.latDec; lat += latinc) {
+			row++;
+			col = 1;
+			for (double lon = topleft.lonDec; lon <= buttomright.lonDec; lon += loninc) {
+				if (progressInfobox != null)
+					progressInfobox.setInfo("Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile row: "+row+" / "+numMapsY+" coloumn "+ col + "/"+numMapsX);
+				col++;
+				downloadMap(lat, lon, tileScale, tilesSize.x, tilesSize.y, tilesPath);
+			}
 		}
 	}
 	
-	public void loadTo(String datei, String alti){
+	public void loadTo(String a, String b) {
+		//loadTo(a, b, "50.74", "7.095");
+	}
+
+	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+		progressInfobox = progrssInfoboxi;
+	}
+	/**
+	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * @param center
+	 * @param distance in meters
+	 */
+	public static int getExpediaAlti(CWPoint center, float distance, Point size) {
+		int scaleLatO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.y));
+		int scaleLonO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.x));
+		int scaleO = (scaleLatO < scaleLonO ? scaleLonO : scaleLatO);
+		//loadTo((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2, scaleO, size.x, size.y, path+"/expedia_alti"+scaleO+"_lat"+latD.toString()+"_lon"+lonD.toString());
+		return scaleO;
+	}
+	
+	public static String createExpediaFilename(double lat, double lon, int alti) {
+		Double latD = new Double(), lonD = new Double();
+		latD.decimalPlaces = 4;
+		lonD.decimalPlaces = 4;
+		latD.set(lat);
+		lonD.set(lon);
+		return "expedia_alti"+alti+"_lat"+latD.toString()+"_lon"+lonD.toString()+".gif";
+	}
+	
+	public void downloadMap(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String path){
+		loadTo(lat, lon, alti, PixelWidth, PixelHeight, path+"/"+createExpediaFilename(lat, lon, alti));
+	}
+
+	public void loadTo(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String datei){
 		HttpConnection connImg, conn2;
 		Socket sockImg, sock2;
 		InputStream is;
 		FileOutputStream fos;
 		ByteArray daten;
 		String quelle = new String();
-		
+		String zone;
+		if (lon <= -10) zone = "USA0409";
+		else zone = "EUR0809";
+
+		/*
+		 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode 
+		 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&ID=3XNsF.&CenP={0,number,#.########},{1,number,#.########}&Lang=EUR0809&Alti={2,number,#}&Size={3,number,#},{4,number,#}&Offs=0.000000,0.000000\&BCheck=1
+		 * download.map.url.expedia_east.title=Url of Expedia Europe
+		 * download.map.scale_factor.expedia_east=3950
+		 */
+		Double latD = new Double();
+		latD.decimalPlaces = 8;
+		latD.set(lat);
+		Double lonD = new Double();
+		lonD.decimalPlaces = 8;
+		lonD.set(lon);
 		quelle = "http://www.expedia.de/pub/agent.dll?qscr=mrdt";
 		quelle = quelle + "&ID=3kQaz.";
-		quelle = quelle + "&CenP=" + lat + "," + lon;
-		quelle = quelle + "&Alti="+alti+"&Lang="+zone+"&Size=500,500&Offs=0,0&MapS=0&Pins=|" + lat + "," + lon + "|5|";
+		quelle = quelle + "&CenP=" + latD.toString() + "," + lonD.toString();
+		quelle = quelle + "&Alti="+Convert.toString(alti)+"&Lang="+zone+"&Size="+Convert.toString(PixelWidth)+","+Convert.toString(PixelHeight)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString() + "," + lonD.toString() + "|5|";
 		//Vm.debug(lat + "," + lon);
 		if(proxy.length()>0){
 			connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
@@ -86,8 +196,18 @@
 				sock2.close();
 			}
 			//Vm.debug("done");
-		}catch(Exception ex){
-			//Vm.debug("Problem loading map: " + ex.toString());
+		}catch(IOException e){
+			(new MessageBox("Error", "Error while downloading or saving map:\n"+e.getMessage(), MessageBox.OKB)).exec();
 		}
+		File dateiF = new File(datei); // change!!!
+		String tmp = dateiF.getName(); // contains the name and the extension
+		String name = tmp.substring(0, tmp.lastIndexOf("."));
+		float metersPerPixel = (float) (alti)*EXPEDIA_METERS_PER_PIXEL;
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, new CWPoint(lat,lon),  PixelWidth, PixelHeight, dateiF.getPath()+"/"+name);
+		try {
+		cal.saveWFL(dateiF.getDrivePath(), name);
+		} catch (IOException e) {
+			(new MessageBox("Error", "Error saving calibration file:\n"+e.getMessage(), MessageBox.OKB)).exec();
+		}
 	}
-}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -0,0 +1,283 @@
+package CacheWolf;
+
+import ewe.io.File;
+import ewe.sys.Convert;
+import ewe.sys.Vm;
+import ewe.ui.*;
+import ewe.util.Vector;
+
+/**
+ * @author pfeffer
+ * This Class is the Dialog for Download calibrated from expedia.com
+ * is called from 
+ */
+
+public class MapLoaderGui extends Form {
+	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
+	Preferences pref;
+	mTabbedPanel mTab = new mTabbedPanel();
+	CellPanel pnlTiles = new CellPanel();
+	CellPanel pnlPerCache = new CellPanel();
+
+	final String descString = "Download georeferenced maps from expedia.com";
+	mCheckBox forCachesChkBox = new mCheckBox("for");
+	mChoice forSelectedChkBox = new mChoice(new String[] {"all", "selected"}, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {"all", "selected"}, 1);
+	mLabel cachesLbl = new mLabel("caches");
+	mInput distanceInput;
+	mLabel distLbl;
+	mLabel km = new mLabel("km");
+	mLabel coosLbl;
+	mButton coosBtn;
+	mLabel scaleLbl = new mLabel("Approx. m per pixel:");
+	mInput scaleInput = new mInput ("3");
+	mInput scaleInputPerCache = new mInput ("3");
+	mLabel overlappingLbl = new mLabel("overlapping in %");
+	mInput overlappingInput = new mInput("20");
+	mCheckBox overviewChkBox = new mCheckBox("download an overview map");
+	mCheckBox overviewChkBoxPerCache = new mCheckBox("download an overview map");
+
+	Vector cacheDB;
+	CWPoint topleft, buttomright;
+	CWPoint center;
+	boolean perCache;
+	boolean onlySelected;
+	float radius;
+	float scale;
+	float overlapping;
+	boolean overviewmap;
+	int numCaches;
+
+	public MapLoaderGui(Vector cacheDBi) {
+		super();
+		cacheDB = cacheDBi;
+		this.title = MyLocale.getMsg(1700, "Download georeferenced maps"); 
+		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
+		center = new CWPoint(pref.curCentrePt);
+		// tiles panel
+		MessageArea desc = new MessageArea(descString);
+		desc.modifyAll(mTextPad.NotEditable | mTextPad.DisplayOnly | mTextPad.NoFocus, mTextPad.TakesKeyFocus);
+		desc.borderStyle = mTextPad.BDR_NOBORDER;
+		pnlTiles.addLast(desc);
+		pnlTiles.addNext(forCachesChkBox);
+		pnlTiles.addNext(forSelectedChkBox);
+		pnlTiles.addLast(cachesLbl);
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1702,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		distanceInput = new mInput();
+		int tmp = Convert.toInt((Global.getProfile().distOC));
+		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
+		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(km);
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1703, "around the center: ")));
+		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
+		pnlTiles.addNext(scaleLbl);
+		scaleInput.setText("3");
+		this.focusFirst();
+		pnlTiles.addLast(scaleInput);
+		//	pnlTiles.addLast(resolutionLbl);
+		pnlTiles.addNext(overlappingLbl);
+		pnlTiles.addLast(overlappingInput);
+		overviewChkBox.setState(true);
+		pnlTiles.addLast(overviewChkBox);
+		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBtiles.setHotKey(0, IKeys.ACTION);
+		okBtiles.setHotKey(0, IKeys.ENTER);
+		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		updateForCachesState();
+		mTab.addCard(pnlTiles, MyLocale.getMsg(1704, "Tiles"), MyLocale.getMsg(1704, "Tiles"));
+
+		// per cache panel
+		pnlPerCache.addLast(new MessageArea(descString));
+		pnlPerCache.addNext(new mLabel("Download one map for"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(new mLabel("caches"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(new mLabel("Approx. m per pixel"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
+		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		okBPerCache = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBPerCache.setHotKey(0, IKeys.ACTION);
+		okBPerCache.setHotKey(0, IKeys.ENTER);
+		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+
+		mTab.addCard(pnlPerCache, MyLocale.getMsg(1705, "Per cache"), MyLocale.getMsg(1705, "Per Cache"));
+		this.addLast(mTab);
+	}
+	public String getMapsDir() {
+		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length());
+		String mapsDir = Global.getPref().baseDir + "/maps/expedia/" + subdir;
+		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
+			if (new File(mapsDir).mkdir() == false) // dir creation failed?
+			{(new MessageBox("Error", "Error: cannot create maps directory: \n"+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
+			return null;
+			}
+		}
+		return mapsDir;
+	}
+	public void downloadTiles() {
+		String mapsDir = getMapsDir();
+		if (mapsDir == null) return;
+		InfoBox progressBox = new InfoBox("Downloading georeferenced maps", "Downloading georeferenced maps\n from www.expedia.com");
+		progressBox.setPreferredSize(230, 150);
+		progressBox.exec();
+		Vm.showWait(true);
+		ewe.fx.Point size = new ewe.fx.Point(700,700); // Size of the downloaded maps
+		MapLoader ml = new MapLoader(Global.getPref().myproxy, Global.getPref().myproxyport);
+		if (forCachesChkBox.getState() || perCache) {
+			calcDownloadRect(); // calculate map boundaries from cacheDB
+			if (topleft == null) {
+				(new MessageBox("Error", "No Caches are seleted", MessageBox.OKB)).execute();
+				Vm.showWait(false);
+				progressBox.close(0);
+				return;
+			}
+			ml.setTiles(topleft, buttomright, (int)scale, size, 1+ overlapping /100);
+			// calculate radius and center for overview map
+			center = new CWPoint((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2);
+			double radiuslat = (new CWPoint(center.latDec, buttomright.lonDec)).getDistance(buttomright);
+			double radiuslon = (new CWPoint(buttomright.latDec, center.lonDec)).getDistance(buttomright);
+			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
+		} else 
+		{ // calculate from center point an radius
+			ml.setTiles(center, radius, (int)scale, size, 1+ overlapping/100);
+		}
+		if (overviewmap) {
+			progressBox.setInfo("downloading overview map"); 
+			int expediaAlti = MapLoader.getExpediaAlti(center, radius * 1000, size);
+			ml.downloadMap(center.latDec, center.lonDec, expediaAlti, size.x, size.y, mapsDir);
+		}
+		if (!perCache){  // download tiles
+			ml.setProgressInfoBox(progressBox);
+			ml.downlaodTiles(mapsDir);
+		} else { // per cache
+			CacheHolder ch; 
+			CWPoint tmpca=new CWPoint();
+			int numdownloaded = 0;
+			for (int i=cacheDB.size()-1; i >= 0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (!this.onlySelected || ch.is_Checked) {
+					if (ch.pos == null) { // this can not happen
+						tmpca.set(ch.LatLon);
+						ch.pos = new CWPoint(tmpca);
+					}
+					if (ch.pos.isValid()) {
+						numdownloaded++;
+						progressBox.setInfo("Downloading map from expedia.de\n"+numdownloaded+" / "+numCaches+"\n for cache:\n"+ch.CacheName);
+						ml.downloadMap(ch.pos.latDec, ch.pos.lonDec, (int)scale, size.x, size.y, mapsDir);
+					}
+				}
+			}
+		}
+		Vm.showWait(false);
+		ml.setProgressInfoBox(null);
+		progressBox.close(0);
+		(new MessageBox("Expedia maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
+	}
+
+	public void calcDownloadRect() {
+		CacheHolder ch;
+		topleft = null;
+		buttomright = null;
+		CWPoint tmpca = new CWPoint();
+		numCaches = 0;
+		for (int i=cacheDB.size()-1; i >= 0; i--) {
+			ch = (CacheHolder) cacheDB.get(i);
+			if (!onlySelected || ch.is_Checked) {
+				if (ch.pos == null) { // this can not happen
+					tmpca.set(ch.LatLon);
+					ch.pos = new CWPoint(tmpca);
+				}
+				if (ch.pos.isValid()) {
+					if (topleft == null) topleft = new CWPoint(ch.pos);
+					if (buttomright == null) buttomright = new CWPoint(ch.pos);
+					if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
+					if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
+					if (buttomright.latDec > ch.pos.latDec) buttomright.latDec = ch.pos.latDec;
+					if (buttomright.lonDec < ch.pos.lonDec) buttomright.lonDec = ch.pos.lonDec;
+					numCaches++;
+				}
+			}
+		}
+	}
+
+	private void updateForCachesState() {
+		int a, b;
+		if (forCachesChkBox.getState()) {
+			// create map rectangle from caches
+			a = 0;
+			b = Control.Disabled;
+		}
+		else { // use center and distance input
+			a = Control.Disabled;
+			b = 0;
+		}
+		forSelectedChkBox.modify(a, b);
+		cachesLbl.modify(a, b);
+		distanceInput.modify(b, a);
+		distLbl.modify(b, a);
+		coosBtn.modify(b, a);
+		coosLbl.modify(b, a);
+		km.modify(b,a);
+		repaintNow();
+
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB || ev.target == cancelBPerCache){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okBtiles || ev.target == okBPerCache){
+				if (ev.target == okBtiles) { // get tiles
+					perCache = false;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBox.getState();
+					radius = Convert.toFloat(distanceInput.getText());
+					scale = Convert.toFloat(scaleInput.getText());
+					overlapping = Convert.toFloat(overlappingInput.getText());
+					if (!forCachesChkBox.getState()) {
+						if (radius <= 0) { 
+							(new MessageBox("Error", "'radius' must be graeter than null", MessageBox.OKB)).execute();
+							return;
+						}
+						if (overlapping < 1 || overlapping > 99) { 
+							(new MessageBox("Error", "'overlapping' must between 1 and 99 ", MessageBox.OKB)).execute();
+							return;
+						}
+					}
+				} else { // per cache
+					perCache = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBoxPerCache.getState();
+					scale = Convert.toFloat(scaleInputPerCache.getText());
+				}
+				if (scale < 1 || scale != java.lang.Math.floor(scale)) {
+					(new MessageBox("Error", "'Approx. meter pro pixel' must be greater than 0 and must not contain a point", MessageBox.OKB)).execute();
+					return;
+				}
+			}
+			this.close(Form.IDOK); 
+			this.downloadTiles();
+		}
+		if (ev.target == coosBtn) {
+			CoordsScreen cs = new CoordsScreen();
+			cs.setFields(center, CWPoint.CW);
+			if (cs.execute() != CoordsScreen.IDCANCEL) {
+				center = cs.getCoords();
+				coosBtn.setText(center.toString());
+			}
+		}
+		if (ev.target == forCachesChkBox) {
+			updateForCachesState();
+		}
+		super.onEvent(ev);
+	}
+}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -31,6 +31,7 @@
 	TrackOverlay[] TrackOverlays;
 	Vector tracks;
 	MapInfoObject currentMap;
+	String mapPath;
 	
 	AniImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
@@ -58,6 +59,7 @@
 	boolean mapHidden = false;
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
+	boolean mapsloaded = false;
 
 	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
 		this.cacheDB = cacheDB;
@@ -70,6 +72,7 @@
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		this.title = "Moving Map";
 		this.backGround = Color.Black;
+		this.mapPath = Global.getPref().baseDir+"maps/expedia/";
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
@@ -81,7 +84,7 @@
 		bottonImageClose.properties |= AniImage.AlwaysOnTop;
 		bottonImageClose.setLocation(Global.getPref().myAppWidth - bottonImageClose.getWidth()- 5, 5);
 		mmp.addImage(bottonImageClose);
-		buttonImageGpsOn.setLocation(pref.myAppWidth - bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 10);
+		buttonImageGpsOn.setLocation(pref.myAppWidth - bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
 		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageGpsOn);
 		bottonImageChooseMap.setLocation(10,10);
@@ -113,14 +116,15 @@
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(posCircle);
-		loadMaps(Global.getPref().baseDir+"maps/standard/");
+		//loadMaps(Global.getPref().baseDir+"maps/standard/");
 	}
 
 	/**
 	 * loads the list of maps
 	 *
 	 */
-	public void loadMaps(String mapsPath){
+	public void loadMaps(String mapsPath, double lat){
+		this.mapPath = mapsPath;
 		Vm.showWait(true);
 		resetCenterOfMap();
 		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
@@ -129,36 +133,46 @@
 		//if (mmp.mapImage != null) 
 		String dateien[];
 		File files = new File(mapsPath);
-		Extractor ext;
 		String rawFileName = new String();
-		dateien = files.list("*.png", File.LIST_FILES_ONLY);
+		String[] dirstmp = files.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_DIRECTORIES_ONLY);
+		Vector dirs = new Vector(dirstmp);
+		dirs.add("."); // include the mapsPath itself
 		MapInfoObject tempMIO;
-		for(int i = 0; i < dateien.length;i++){
-			ext = new Extractor(dateien[i], "", ".", 0, true);
-			rawFileName = ext.findNext();
-			try {
-				tempMIO = new MapInfoObject();
-				tempMIO.loadwfl(mapsPath, rawFileName);
-				maps.add(tempMIO);
-			}catch(IOException ex){ } // TODO etwas genauer auch Fehlermeldung ausgeben? Bei vorhandenen .wfl-Datei mit ung?ltigen Werten Fehler ausgeben oder wie jetz einfach ignorieren?
+		MessageBox f = null;
+		for (int j = dirs.size()-1; j >= 0; j--) {
+			files = new File(mapsPath+"/"+dirs.get(j));
+			dateien = files.list("*.wfl", File.LIST_FILES_ONLY);
+			for(int i = 0; i < dateien.length;i++){
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
+				try {
+					tempMIO = new MapInfoObject();
+					tempMIO.loadwfl(mapsPath+dirs.get(j)+"/", rawFileName);
+					maps.add(tempMIO);
+				}catch(IOException ex){ 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				}catch(ArithmeticException ex){ // affine contain not allowed values 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				} 
+			}
 		}
 		if (maps.isEmpty())
-			{
+		{
 			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung"), MessageBox.OKB)).execute();
 			noMapsAvailable = true;
-			} else noMapsAvailable = false;
-		tempMIO = new MapInfoObject(1.0);
+		} else noMapsAvailable = false;
+		tempMIO = new MapInfoObject(1.0, lat);
 		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(5.0);
+		tempMIO = new MapInfoObject(5.0, lat);
 		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(50.0);
+		tempMIO = new MapInfoObject(50.0, lat);
 		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(250.0);
+		tempMIO = new MapInfoObject(250.0, lat);
 		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(1000.0);
+		tempMIO = new MapInfoObject(1000.0, lat);
 		maps.add(tempMIO);
 		inf.close(0);
 		Vm.showWait(false);
+		this.mapsloaded = true;
 	}
 
 	public void forceMapLoad() {
@@ -534,7 +548,7 @@
 		public void removeAllMapSymbolsButGoto(){
 			if (symbols == null) return;
 			symbols.removeAllElements();
-			symbols.add(gotoPos);
+			if (gotoPos != null) symbols.add(gotoPos);
 /*			for (int i=symbols.size()-1; i>=0; i--) {
 				if (((MapSymbol)symbols.get(i)).name != "goto") removeMapSymbol(i);
 			}
@@ -588,6 +602,7 @@
 		 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
 		 */
 		public void updatePosition(double lat, double lon){
+			if (!mapsloaded) loadMaps(mapPath, lat);
 			lastUpatePosition.latDec=lat;
 			lastUpatePosition.lonDec=lon;
 			if(!ignoreGps || forceMapLoad){
@@ -673,9 +688,15 @@
 
 					//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
 					Vm.getUsedMemory(true); // calls the garbage collection
-				} // give memory free before loading the new map to avoid out of memory error  
-				if (currentMap.fileName.length()>0) mmp.mapImage = new AniImage(currentMap.fileName); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
-				else mmp.mapImage = new AniImage();
+				} // give memory free before loading the new map to avoid out of memory error
+				if (currentMap.getImageFilename() == null ) {
+					mmp.mapImage = new AniImage();
+					(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
+				}
+				else { 
+					if (currentMap.getImageFilename().length()>0) mmp.mapImage = new AniImage(currentMap.getImageFilename()); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+					else mmp.mapImage = new AniImage();
+				}
 				mapImage1to1 = mmp.mapImage;
 				mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
 				if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
@@ -700,7 +721,7 @@
 				updateOnlyPosition(lat, lon, false);
 				inf.close(0);
 				Vm.showWait(false);
-				(new MessageBox("Error", "Could not load map: "+ newmap.fileName, MessageBox.OKB)).execute();
+				(new MessageBox("Error", "Could not load map: "+ newmap.getImageFilename(), MessageBox.OKB)).execute();
 				ignoreGps = saveIgnoreStatus;
 			} catch (OutOfMemoryError e) {
 				if (mmp.mapImage != null) {
@@ -712,7 +733,7 @@
 				updateOnlyPosition(lat, lon, false);
 				inf.close(0);
 				Vm.showWait(false);
-				(new MessageBox("Error", "Not enough memory to load map: "+ newmap.fileName+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+				(new MessageBox("Error", "Not enough memory to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
 				ignoreGps = saveIgnoreStatus;
 			}catch (SystemResourceException e) {
 				if (mmp.mapImage != null) {
@@ -724,7 +745,7 @@
 				updateOnlyPosition(lat, lon, false);
 				inf.close(0);
 				Vm.showWait(false);
-				(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.fileName+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+				(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
 				ignoreGps = saveIgnoreStatus;
 			}
 		}
@@ -984,14 +1005,15 @@
 			if(l.execute() == FormBase.IDOK){
 //				Vm.debug("Trying map: " + l.selectedMap.fileName);
 				mm.autoSelectMap = false;
-				if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.fileName.length()==0) {
+				if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
 					mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
 					mm.ignoreGpsStatutsChanges = false;
 				} else {
 					mm.ignoreGpsStatutsChanges = false;
 					mm.setGpsStatus(MovingMap.noGPS);
 					mm.ignoreGpsStatutsChanges = true;
-					mm.setMap(l.selectedMap, -361, -361); // don't adjust Image to lat/lon
+					mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
+					mm.setCenterOfScreen(l.selectedMap.center);
 //					Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
 					//			double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
 					mm.posCircleX = 0; // place map to the upper left corner of windows
@@ -1057,7 +1079,7 @@
 							fc.addMask("*.wfl");
 							fc.setTitle((String)MyLocale.getMsg(4200,"Select map directory:"));
 							if(fc.execute() != FileChooser.IDCANCEL){
-								mm.loadMaps(fc.getChosen().toString()+"/");
+								mm.loadMaps(fc.getChosen().toString()+"/", mm.posCircleLat);
 								mm.addOverlaySet();
 								mm.forceMapLoad();
 							}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -342,13 +342,20 @@
 				
 				ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 				pll.parse();
-				MapLoader mpl = new MapLoader(pll.getLatDeg(),pll.getLonDeg(), pref.myproxy, pref.myproxyport);
+				MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 				// MapLoader tests itself if the file already exists and doesnt download if so.
-				String filename = profile.dataDir + "/" + holder.wayPoint + "_map.gif";
+				String filename = Global.getPref().baseDir + "/maps/expedia/" + holder.wayPoint + "_map.gif";
+				if (!(new File(filename).getParentFile().isDirectory())) { // dir exists? 
+					if (new File(filename).getParentFile().mkdir() == false) // dir creation failed?
+					{ pref.downloadMapsOC = false;
+					(new MessageBox("Warning", "Ignoring error (stopping to download maps):\n cannot create maps directory: \n"+new File(filename).getParentFile(), MessageBox.OKB)).exec(); 
+					}
+				}
 				if (!fileExits(filename)){
 					inf.setInfo(MyLocale.getMsg(1609,"Importing Cache:")+" " + numCacheImported + "\n"+MyLocale.getMsg(1610,"Downloading missing map")+" 1");
 					mpl.loadTo(filename, "3"); }
-				filename = profile.dataDir + "/" + holder.wayPoint + "_map_2.gif";
+				//filename = profile.dataDir + "/" + holder.wayPoint + "_map_2.gif";
+				filename = Global.getPref().baseDir + "/maps/expedia/" + holder.wayPoint + "_map_2.gif";
 				if (!fileExits(filename)){
 					inf.setInfo(MyLocale.getMsg(1609,"Importing Cache: ")+" " + numCacheImported + "\n"+MyLocale.getMsg(1610,"Downloading missing map")+" 2");
 					mpl.loadTo(filename, "10"); }

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -407,7 +407,7 @@
 		if(holder.LatLon.length() > 4){
 			ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 			pll.parse();
-			MapLoader mpl = new MapLoader(pll.getLatDeg(),pll.getLonDeg(), pref.myproxy, pref.myproxyport);
+			MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 			mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
 			mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 		}

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -139,7 +139,10 @@
 		while(--anz >= 0){
 			ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 			if(ch.LatLon.length()>4){
-				toPoint.set(ch.LatLon, CWPoint.CW); // Fast parse with traditional parse algorithm
+				if (ch.pos == null) { // only calculate once
+					toPoint.set(ch.LatLon, CWPoint.CW); // Fast parse with traditional parse algorithm
+					ch.pos = new CWPoint(toPoint);
+				} else toPoint = ch.pos;
 				ch.kilom = fromPoint.getDistance(toPoint);
 				ch.degrees = fromPoint.getBearing(toPoint);
 				ch.bearing = CWPoint.getDirection(ch.degrees);

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-18 21:18:14 UTC (rev 402)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-19 02:25:29 UTC (rev 403)
@@ -21,13 +21,22 @@
 		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 	}
 	public void penHeld(Point p){
-		menuState.doShowMenu(p,true,null);
+		menuState.doShowMenu(p,true,null); 
 	}
 	
-	public void popupMenuEvent(Object selectedItem){
-		CacheHolder ch;
+	public void onKeyEvent(KeyEvent ev) {
+		if (ev.type == KeyEvent.KEY_PRESS && ev.target == this){
+			if ( (ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 'a'-'a'+1){ // <ctrl-a> gives 1, <ctrl-b> == 2
+				// select all on <ctrl-a>
+				selectAll();
+				ev.consumed = true;
+			}
+		}
+		super.onKeyEvent(ev);
+	}
 		
-		if (selectedItem.toString().equals(MyLocale.getMsg(1015,"Select all"))){
+		public void selectAll() {
+			CacheHolder ch;
 			for(int i = 0; i <	db.size(); i++){
 				ch = (CacheHolder)db.get(i);
 				ch.is_Checked = true;
@@ -36,7 +45,15 @@
 			tbp.myMod.cacheSelectionChanged = true;
 			tbp.refreshTable();
 		}
+	
+	
+	public void popupMenuEvent(Object selectedItem){
+		CacheHolder ch;
 		
+		if (selectedItem.toString().equals(MyLocale.getMsg(1015,"Select all"))){
+			selectAll();
+		}
+		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1016,"De-select all"))){
 			for(int i = 0; i <	db.size(); i++){
 				ch = (CacheHolder)db.get(i);



From pfeffer at mail.berlios.de  Fri Jan 19 04:15:21 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 19 Jan 2007 04:15:21 +0100
Subject: [Cachewolf-svn] r404 - trunk/src/CacheWolf
Message-ID: <200701190315.l0J3FLol012415@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-19 04:15:17 +0100 (Fri, 19 Jan 2007)
New Revision: 404

Modified:
   trunk/src/CacheWolf/MapLoaderGui.java
Log:
2 kleine Fehler beim Kartendownload behoben

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-19 02:25:29 UTC (rev 403)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-19 03:15:17 UTC (rev 404)
@@ -145,7 +145,7 @@
 			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
 		} else 
 		{ // calculate from center point an radius
-			ml.setTiles(center, radius, (int)scale, size, 1+ overlapping/100);
+			ml.setTiles(center, radius * 1000, (int)scale, size, 1+ overlapping/100);
 		}
 		if (overviewmap) {
 			progressBox.setInfo("downloading overview map"); 
@@ -263,21 +263,21 @@
 					(new MessageBox("Error", "'Approx. meter pro pixel' must be greater than 0 and must not contain a point", MessageBox.OKB)).execute();
 					return;
 				}
+				this.close(Form.IDOK); 
+				this.downloadTiles();
 			}
-			this.close(Form.IDOK); 
-			this.downloadTiles();
-		}
-		if (ev.target == coosBtn) {
-			CoordsScreen cs = new CoordsScreen();
-			cs.setFields(center, CWPoint.CW);
-			if (cs.execute() != CoordsScreen.IDCANCEL) {
-				center = cs.getCoords();
-				coosBtn.setText(center.toString());
+			if (ev.target == coosBtn) {
+				CoordsScreen cs = new CoordsScreen();
+				cs.setFields(center, CWPoint.CW);
+				if (cs.execute() != CoordsScreen.IDCANCEL) {
+					center = cs.getCoords();
+					coosBtn.setText(center.toString());
+				}
 			}
-		}
-		if (ev.target == forCachesChkBox) {
-			updateForCachesState();
-		}
+			if (ev.target == forCachesChkBox) {
+				updateForCachesState();
+			}
+		} // if controllEvent...
 		super.onEvent(ev);
 	}
 }



From bilbowolf at mail.berlios.de  Fri Jan 19 13:14:04 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Fri, 19 Jan 2007 13:14:04 +0100
Subject: [Cachewolf-svn] r405 - trunk/src/CacheWolf
Message-ID: <200701191214.l0JCE4SL005182@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-19 13:14:00 +0100 (Fri, 19 Jan 2007)
New Revision: 405

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
&f=1 beim spider entfernt

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-01-19 03:15:17 UTC (rev 404)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-01-19 12:14:00 UTC (rev 405)
@@ -230,7 +230,7 @@
 		//Get first page
 		try{
 			pref.log("Fetching first list page: http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD) + "&f=1");
-			start = fetch("http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD) + "&f=1");
+			start = fetch("http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
 			pref.log("First page: " + start);
 		}catch(Exception ex){
 			pref.log("Error fetching first list page");



From admin at berlios.de  Fri Jan 19 17:38:00 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 17:38:00 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10043] be 401 Map.java
Message-ID: <200701191638.l0JGc0x0012260@unicorn.berlios.de>

Bug #10043, was updated on 2007-Jan-18 09:56
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Works For Me
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: be 401 Map.java

Details: > GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180

360?

Follow-Ups:

Date: 2007-Jan-19 17:38
By: pfeffer

Comment:
jou, ich find 360 ok. Ist zwar nicht ?blich, aber warum sollte man es verbieten?.

Gru?,
  Pfeffer.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10043&group_id=2211


From admin at berlios.de  Fri Jan 19 17:39:37 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 17:39:37 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9930] SpiderGC: <Enter> im Passworteingabe
Message-ID: <200701191639.l0JGdbWb014228@unicorn.berlios.de>

Bug #9930, was updated on 2007-Jan-10 23:39
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: pfeffer
Assigned to : cw-tester
Summary: SpiderGC: <Enter> im Passworteingabe

Details: beim SpiderGC <Enter> im Passworteingabe bewirkte abbruch, jetzt sind <enter> und <ESC> f?r die Richtigen Buttons aktiviert

Follow-Ups:

Date: 2007-Jan-11 00:45
By: pfeffer

Comment:
erledigt mit svn: 378
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9930&group_id=2211


From admin at berlios.de  Fri Jan 19 17:40:52 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 17:40:52 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9134] Download von OC: could not write to file
Message-ID: <200701191640.l0JGeqOM015667@unicorn.berlios.de>

Bug #9134, was updated on 2006-Oct-15 19:40
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: pfeffer
Assigned to : albsucher
Summary: Download von OC: could not write to file

Details: Warning:
Ignoring IOException: Could not write to file!
while downlaoding picture:OC085D_102236.jpg
from URL:http://www.opencaching.de/images/statpics/statpic102236.jpg
in cache: OC085D

normalerweise kommt dieser Fehler bei Dateinamen, die nicht erzeugt werden k?nne, beispielsweise, weil sie ein "?" einhalten (kommt bei Hit-Countern vor).

Ich muss mal sehen, ob dieser Fehler reproduzierbar ist.

Gru?,
   Pfeffer.

Follow-Ups:

Date: 2007-Jan-10 21:57
By: pfeffer

Comment:
behoben mit SVN 377.
Grund war, dass fetch() nur eine redirection erlaubt hatte. jetzt gehen 5 (einzustellen mit maxRedirections).

Dabei habe ich vermutlich noch ein Problem mit Proxies behoben: soweit ich das aus dem Code erkennen kann, ging der redirect-request nicht mehr ?ber den Proxy. Kann das aber nicht testen, weil ich nicht hinter einem Proxy sitze. -> hatte nicht mal irgendjemand von Problemen mit Proxy berichtet?

Vor ein paar Tagen hatte ich schon das Problem mit dem "?" behoben, indem ich es ?ber die neue Funktion Common.clearForFilename durch "_" ersetze.

Gru?,
  Pfeffer.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9134&group_id=2211


From admin at berlios.de  Fri Jan 19 17:43:01 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 17:43:01 +0100 (CET)
Subject: [Bug #10069] MovingMap: Import läuft ins falsche (alte) Verzeichnis
Message-ID: <200701191643.l0JGh1wZ016957@unicorn.berlios.de>

Bug #10069, was updated on 2007-Jan-19 17:43
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: None
Priority: 7
Submitted by: pfeffer
Assigned to : pfeffer
Summary: MovingMap: Import l?uft ins falsche (alte) Verzeichnis

Details: siehe http://www.geoclub.de/ftopic13608-20.html

Gru?,
  Pfeffer.

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10069&group_id=2211


From admin at berlios.de  Fri Jan 19 19:00:11 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 19 Jan 2007 19:00:11 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10043] be 401 Map.java
Message-ID: <200701191800.l0JI0B1B029019@unicorn.berlios.de>

Bug #10043, was updated on 2007-Jan-18 09:56
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Works For Me
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: be 401 Map.java

Details: > GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180

360?

Follow-Ups:

Date: 2007-Jan-19 19:00
By: greiol

Comment:
:-)
also wenn es danach geht, verstehe ich nicht weshalb ?berhaupt gepr?ft wird, aber das kann man nat?rlich halten wie ein dachdecker.
-------------------------------------------------------

Date: 2007-Jan-19 17:38
By: pfeffer

Comment:
jou, ich find 360 ok. Ist zwar nicht ?blich, aber warum sollte man es verbieten?.

Gru?,
  Pfeffer.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10043&group_id=2211


From kalli at mail.berlios.de  Fri Jan 19 20:13:46 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 19 Jan 2007 20:13:46 +0100
Subject: [Cachewolf-svn] r406 - in trunk: . resources src src/CacheWolf
	src/exp
Message-ID: <200701191913.l0JJDkQQ017842@sheep.berlios.de>

Author: kalli
Date: 2007-01-19 20:13:11 +0100 (Fri, 19 Jan 2007)
New Revision: 406

Added:
   trunk/resources/POIIcons.zip
   trunk/src/exp/
   trunk/src/exp/ASCExporter.java
   trunk/src/exp/Exporter.java
   trunk/src/exp/GPXExporter.java
   trunk/src/exp/HTMLExporter.java
   trunk/src/exp/KMLExporter.java
   trunk/src/exp/MSARCSVExporter.java
   trunk/src/exp/OVLExporter.java
   trunk/src/exp/OziExporter.java
   trunk/src/exp/PCX5Exporter.java
   trunk/src/exp/TPLExporter.java
   trunk/src/exp/TomTomExporter.java
   trunk/src/exp/TomTomExporterScreen.java
Removed:
   trunk/src/CacheWolf/ASCExporter.java
   trunk/src/CacheWolf/CacheReaderWriter.java
   trunk/src/CacheWolf/GPXExporter.java
   trunk/src/CacheWolf/HTMLExporter.java
   trunk/src/CacheWolf/KMLExporter.java
   trunk/src/CacheWolf/LOCReader.java
   trunk/src/CacheWolf/MSARCSVExporter.java
   trunk/src/CacheWolf/OVLExporter.java
   trunk/src/CacheWolf/OziExporter.java
   trunk/src/CacheWolf/PCX5Exporter.java
   trunk/src/CacheWolf/TPLExporter.java
   trunk/src/CacheWolf/TomTomASCExporter.java
   trunk/src/CacheWolf/TomTomOV2Exporter.java
Modified:
   trunk/compile.bat
   trunk/compile.sh
   trunk/cwberlios.jnf
   trunk/getRes.sh
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CWPoint.java
   trunk/src/CacheWolf/MainMenu.java
Log:
Exporter umgebaut, neues Package exp
Feature 3039: Prefix und Icons fuer TomTomExport

Modified: trunk/compile.bat
===================================================================
--- trunk/compile.bat	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/compile.bat	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,2 +1,3 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
-javac -cp ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java 
\ No newline at end of file
+if not exist bin\exp mkdir bin\exp
+javac -cp ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/exp/*.java 
\ No newline at end of file

Modified: trunk/compile.sh
===================================================================
--- trunk/compile.sh	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/compile.sh	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,2 +1,2 @@
 #!/bin/bash
-javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn  ./src/CacheWolf/*.java
+javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn  ./src/CacheWolf/*.java ./src/exp/*.java

Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/cwberlios.jnf	2007-01-19 19:13:11 UTC (rev 406)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubd!
 irectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=(Def!
 ault)
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ew!
 esoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%2!
 53Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26inst!
 all%3Dti
tle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=(Default)

Modified: trunk/getRes.sh
===================================================================
--- trunk/getRes.sh	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/getRes.sh	2007-01-19 19:13:11 UTC (rev 406)
@@ -7,6 +7,6 @@
 rm ./work/*.ico
 # get ressources
 cp resources/*.* work
-mv work/cachewolf.Languages.cfg work/_config
+mv work/cachewolf.Languages.cfg work/_config/cachewolf.Languages.cfg
 
 

Added: trunk/resources/POIIcons.zip
===================================================================
(Binary files differ)


Property changes on: trunk/resources/POIIcons.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-19 19:13:11 UTC (rev 406)
@@ -6,7 +6,7 @@
 		102=nach TOP50 ASCII
 		103=nach GPX
 		104=nach ASC
-		105=nach TomTom ASC
+		105=nach TomTom
 		106=nach MS AutoRoute CSV
 		107=Export
 		108=Pr%e4ferenzen
@@ -303,7 +303,7 @@
 		102=to TOP50 ASCII
 		103=to GPX
 		104=to ASC
-		105=to TomTom ASC
+		105=to TomTom
 		106=to MS AutoRoute CSV
 		107=Export
 		108=Preferences

Deleted: trunk/src/CacheWolf/ASCExporter.java
===================================================================
--- trunk/src/CacheWolf/ASCExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/ASCExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,54 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export cache database to an ASCII (CSV!) file.
-*   This file can be used by I2C's POI Converter to generate
-*   POIs for different routing programmes, especially for
-*	Destinator ;-) !
-*/
-public class ASCExporter{
-	//TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public ASCExporter(Preferences p,Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = prof.cacheDB;
-	}
-	
-	public void doIt(){
-		String str;
-		String dummy;
-		CacheHolder holder;
-		ParseLatLon pll;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle("Select target file:");
-		fc.addMask("*.csv");
-		fc.defaultExtension="csv";
-		if(fc.execute() != FileChooser.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false && holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon, ".");
-						pll.parse();
-						dummy = holder.CacheName;
-						dummy = dummy.replace(',', ' ');
-						str = dummy+","+dummy+","+ pll.getLonDeg()+"," + pll.getLatDeg()+",,,,";
-						outp.print(str+"\r\n");
-					}//if
-				}//for
-				outp.close();
-			}catch (Exception e){
-				ewe.sys.Vm.debug("Problem writing to ASC file! "+e.toString());
-			}//try
-		} //if else {
-		}
-	}

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/CWPoint.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -25,12 +25,12 @@
 	MGRSPoint utm = new MGRSPoint();
 	boolean utmValid = false;
 
-	static protected final int DD = 0;
-	static protected final int DMM = 1;
-	static protected final int DMS = 2;
-	static protected final int UTM = 3;
-	static protected final int CW = 4;
-	static protected final int REGEX = 5;
+	public static final int DD = 0;
+	public static final int DMM = 1;
+	public static final int DMS = 2;
+	public static final int UTM = 3;
+	public static final int CW = 4;
+	public static final int REGEX = 5;
 	
 	/**
 	 * Create CWPoint by using lat and lon 

Deleted: trunk/src/CacheWolf/CacheReaderWriter.java
===================================================================
--- trunk/src/CacheWolf/CacheReaderWriter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/CacheReaderWriter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,14 +0,0 @@
-package CacheWolf;
-
-import ewe.util.*;
-import ewe.io.*;
-import ewe.sys.*;
-
-/**
- * REDUNDANT CLASS - DELETE 
- * Methods moved to classes @see CacheHolder and @see Profile
-*/
-public class CacheReaderWriter {
-	
-}
-

Deleted: trunk/src/CacheWolf/GPXExporter.java
===================================================================
--- trunk/src/CacheWolf/GPXExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/GPXExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,119 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.ui.*;
-import ewe.util.*;
-/**
-*	Class to export the cache database to a GPX file with gc.com
-*	extensions.<br>
-*	Export of logs is not that nice. The cause is that CacheWolf does not spider
-*	logs individually, rather all logs as a single entity.
-*	ClassID = 2000
-*/
-public class GPXExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	ProgressBarForm pbf = new ProgressBarForm();
-	
-	public GPXExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(int variant){
-		CacheHolder ch;
-		String cwd= File.getProgramDirectory();
-		File saveTo = new File(cwd + "/temp.gpx");
-		if(variant == 1) {
-			FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-			fc.setTitle("Select target file:");
-			if(fc.execute() != FormBase.IDCANCEL) saveTo = fc.getChosenFile();
-		}
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-			outp.print("<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n");
-			outp.print("<gpx xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"1.0\" creator=\"Groundspeak Pocket Query\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0 http://www.groundspeak.com/cache/1/0/cache.xsd\" xmlns=\"http://www.topografix.com/GPX/1/0\">\r\n");
-			outp.print("  <desc>Geocache file generated by CacheWolf</desc>\r\n");
-			outp.print("  <author>CacheWolf</author>\r\n");
-			outp.print("  <email>test at test.com</email>\r\n");
-			Time tim = new Time();
-			tim = tim.setFormat("yyyy-MM-dd");
-			tim = tim.setToCurrentTime();
-			outp.print(" <time>"+tim.toString()+"T00:00:00.0000000-07:00</time>\r\n");
-			ParseLatLon pll;
-			String msg;
-			for(int i = 0; i<cacheDB.size(); i++){
-				if (i%5 == 0){
-					msg = "Export " + Convert.toString(i) + " of " + Convert.toString(cacheDB.size());
-					pbf.display("GPX Export",msg,null);
-				}
-				ch=(CacheHolder)cacheDB.get(i);
-				if(ch.is_black == false && ch.is_filtered == false){
-					//KHF read cachedata only if needed 
-					ch.readCache(profile.dataDir);
-					pll = new ParseLatLon(ch.LatLon, ".");
-					pll.parse();
-					outp.print("  <wpt lat=\""+pll.getLatDeg()+"\" lon=\""+pll.getLonDeg()+"\">\r\n");
-					if (ch.DateHidden.length()> 0){
-						tim.parse(ch.DateHidden, "M/d/y");
-					}
-					else {
-						tim.setText("2000-01-01");
-					}
-					outp.print("    <time>"+tim.toString()+"T00:00:00.0000000-07:00</time>\r\n");
-					outp.print("    <name>"+ch.wayPoint+"</name>\r\n");
-					outp.print("    <desc>"+SafeXML.cleanGPX(ch.CacheName)+" by "+SafeXML.cleanGPX(ch.CacheOwner)+"</desc>\r\n");
-					outp.print("    <url>http://www.geocaching.com/seek/cache_details.aspx?wp="+ch.wayPoint+"&amp;Submit6=Find</url>\r\n");
-					outp.print("    <urlname>"+SafeXML.cleanGPX(ch.CacheName)+" by "+SafeXML.cleanGPX(ch.CacheOwner)+"</urlname>\r\n");
-					outp.print("    <sym>Geocache</sym>\r\n");
-					outp.print("    <type>Geocache|"+CacheType.transType(ch.type)+"</type>\r\n");
-					//outp.print("    <type>Geocache|Geocache</type>\r\n");
-					String dummyAvailable = ch.is_available ? "True":"False";
-					String dummyArchived = ch.is_archived ? "True":"False";
-					outp.print("    <groundspeak:cache available=\""+ dummyAvailable + "\" archived=\"" + dummyArchived+ "\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">\r\n");
-					outp.print("      <groundspeak:name>"+SafeXML.cleanGPX(ch.CacheName)+"</groundspeak:name>\r\n");
-					outp.print("      <groundspeak:placed_by>"+SafeXML.cleanGPX(ch.CacheOwner)+"</groundspeak:placed_by>\r\n");
-					outp.print("      <groundspeak:owner>"+SafeXML.cleanGPX(ch.CacheOwner)+"</groundspeak:owner>\r\n");
-					outp.print("      <groundspeak:type>"+CacheType.transType(ch.type)+"</groundspeak:type>\r\n");
-					outp.print("      <groundspeak:container>"+ch.CacheSize+"</groundspeak:container>\r\n");
-					//KHF use '.' instead of ','
-					outp.print("      <groundspeak:difficulty>"+ch.hard.replace(',','.')+"</groundspeak:difficulty>\r\n");
-					outp.print("      <groundspeak:terrain>"+ch.terrain.replace(',','.')+"</groundspeak:terrain>\r\n");
-					String dummyHTML = ch.is_HTML ? "True":"False";
-					outp.print("      <groundspeak:long_description html=\"" + dummyHTML + "\">\r\n");
-					outp.print("      "+SafeXML.cleanGPX(ch.LongDescription));
-					outp.print("      \n</groundspeak:long_description>\r\n");
-					outp.print("	  <groundspeak:encoded_hints>"+SafeXML.cleanGPX(Common.rot13(ch.Hints))+"</groundspeak:encoded_hints>\r\n");
-					outp.print("      <groundspeak:logs>\r\n");
-					/*
-					for(int j = 0; j<holder.CacheLogs.size(); j++){
-						outp.print("	    <groundspeak:log>\r\n");
-						outp.print("            <groundspeak:date>");
-						outp.print("T08:00:00</groundspeak:date>\r\n");
-						outp.print("<groundspeak:finder>");
-						outp.print("</groundspeak:finder>");
-						outp.print("		<groundspeak:text encoded=\"False\">\r\n");
-						outp.print("		</groundspeak:text>\r\n");
-						outp.print("	    </groundspeak:log>\r\n");
-					}
-					*/
-					outp.print("      </groundspeak:logs>\r\n");
-					outp.print("      <groundspeak:travelbugs />\r\n");
-					outp.print("    </groundspeak:cache>\r\n");
-					outp.print("  </wpt>\r\n");
-				} // if holder ==
-			}//for
-			pbf.clear();
-			outp.print("</gpx>");
-			outp.close();
-		}catch(Exception e){
-			Vm.debug("Problem writing to GPX file");
-			e.printStackTrace();
-		}//try
-	}
-}

Deleted: trunk/src/CacheWolf/HTMLExporter.java
===================================================================
--- trunk/src/CacheWolf/HTMLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/HTMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,371 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.ui.*;
-import ewe.filechooser.*;
-import HTML.*;
-
-/**
-*	Class to export cache information to individual HTML files.<br>
-*	It uses the HTML package to parse template files. This makes the export
-*	very flexible; enabling the user to customise the HTML files according
-*	to thier liking.
-*/
-public class HTMLExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	String [] template_init_index = {
-	 		"filename",  "index.tpl",
-	 		"case_sensitive", "true",
-	 		"max_includes",   "5"
-	 		//,"debug", "true"
-	 	};
-	String [] template_init_page = {
-	 		"filename",  "page.tpl",
-	 		"case_sensitive", "true",
-	 		"max_includes",   "5"
-	 	};
-	public HTMLExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-//		ProgressBarForm pbf = new ProgressBarForm();
-		CacheHolder holder = new CacheHolder();
-		//need directory only!!!!
-		String dummy = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
-		fc.setTitle("Select target directory:");
-		String targetDir;
-		if(fc.execute() != FileChooser.IDCANCEL){
-			targetDir = fc.getChosen() + "/";
-			Vector cache_index = new Vector();
-			Vector cacheImg = new Vector();
-			Vector logImg = new Vector();
-			Vector mapImg = new Vector();
-			Vector usrImg = new Vector();
-			
-
-			Hashtable varParams;
-			Hashtable imgParams;
-			Hashtable logImgParams;
-			Hashtable usrImgParams;
-			Hashtable mapImgParams;
-
-			//Generate index page
-			int counter = 0;
-			for(int i = 0; i<cacheDB.size();i++){
-				holder = (CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false && holder.is_filtered == false) counter++;
-			}
-			for(int i = 0; i<counter;i++){
-				if (i%5 == 0){
-					ProgressBarForm.display("Exporting...", "Exporting " + Convert.toString(i) + " of " + counter, null);
-				}
-				holder = (CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false && holder.is_filtered == false){
-					//KHF read cachedata only if needed
-					try{
-						holder.readCache( profile.dataDir);
-					}catch(Exception e){
-						//Vm.debug("Problem reading cache page");
-					}
-					varParams = new Hashtable();
-					varParams.put("TYPE", CacheType.transType(holder.type));
-					varParams.put("SIZE", holder.CacheSize);
-					varParams.put("WAYPOINT", holder.wayPoint);
-					varParams.put("NAME", holder.CacheName);
-					varParams.put("OWNER", holder.CacheOwner);
-					varParams.put("DIFFICULTY", holder.hard);
-					varParams.put("TERRAIN", holder.terrain);
-					varParams.put("DISTANCE", holder.distance);
-					varParams.put("BEARING", holder.bearing);
-					varParams.put("LATLON", holder.LatLon);
-					varParams.put("STATUS", holder.CacheStatus);
-					cache_index.add(varParams);
-					//We can generate the individual page here!
-					try{
-						Template page_tpl = new Template(template_init_page);
-						page_tpl.setParam("TYPE", CacheType.transType(holder.type));
-						page_tpl.setParam("SIZE", holder.CacheSize);
-						page_tpl.setParam("WAYPOINT", holder.wayPoint);
-						page_tpl.setParam("NAME", holder.CacheName);
-						page_tpl.setParam("OWNER", holder.CacheOwner);
-						page_tpl.setParam("DIFFICULTY", holder.hard);
-						page_tpl.setParam("TERRAIN", holder.terrain);
-						page_tpl.setParam("DISTANCE", holder.distance);
-						page_tpl.setParam("BEARING", holder.bearing);
-						page_tpl.setParam("LATLON", holder.LatLon);
-						page_tpl.setParam("STATUS", holder.CacheStatus);
-						if (holder.is_HTML)
-							page_tpl.setParam("DESCRIPTION", holder.LongDescription);
-						else {
-							String dummyText = new String();
-							dummyText = STRreplace.replace(holder.LongDescription, "\n", "<br>");
-							page_tpl.setParam("DESCRIPTION",dummyText);
-							
-						}
-						page_tpl.setParam("HINTS", holder.Hints);
-						page_tpl.setParam("DECRYPTEDHINTS", Common.rot13(holder.Hints));
-						dummy = new String();
-						for(int j = 0; j<holder.CacheLogs.size(); j++){
-							dummy = dummy + (String)holder.CacheLogs.get(j)+"<br>";
-						}
-						page_tpl.setParam("LOGS", dummy);
-						page_tpl.setParam("NOTES", STRreplace.replace(holder.CacheNotes, "\n","<br>"));
-						// Cache Images
-						cacheImg.clear();
-						for(int j = 0; j<holder.Images.size(); j++){
-							imgParams = new Hashtable();
-							String imgFile = new String((String)holder.Images.get(j));
-							imgParams.put("FILE", imgFile);
-							if (j < holder.ImagesText.size())
-								imgParams.put("TEXT",(String)holder.ImagesText.get(j));
-							else
-								imgParams.put("TEXT",imgFile);
-							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
-							cacheImg.add(imgParams);
-						}
-						page_tpl.setParam("cacheImg", cacheImg);
-						// Log images
-						logImg.clear();
-						for(int j = 0; j<holder.LogImages.size(); j++){
-							logImgParams = new Hashtable();
-							String logImgFile = new String((String)holder.LogImages.get(j));
-							logImgParams.put("FILE", logImgFile);
-							if (j < holder.LogImagesText.size())
-								logImgParams.put("TEXT",(String)holder.LogImagesText.get(j));
-							else
-								logImgParams.put("TEXT",logImgFile);
-							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
-							logImg.add(logImgParams);
-						}
-						page_tpl.setParam("logImg", logImg);
-						// User images
-						usrImg.clear();
-						for(int j = 0; j<holder.UserImages.size(); j++){
-							usrImgParams = new Hashtable();
-							String usrImgFile = new String((String)holder.UserImages.get(j));
-							usrImgParams.put("FILE", usrImgFile);
-							if (j < holder.UserImagesText.size())
-								usrImgParams.put("TEXT",(String)holder.UserImagesText.get(j));
-							else
-								usrImgParams.put("TEXT",usrImgFile);
-							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
-							usrImg.add(usrImgParams);
-						}
-						page_tpl.setParam("userImg", usrImg);
-
-						// Map images
-						mapImg.clear();
-						mapImgParams = new Hashtable();
-						String mapImgFile = new String((String)holder.wayPoint + "_map.gif");
-						// check if map file exists
-						File test = new File(profile.dataDir + mapImgFile);
-						if (test.exists()) {
-							mapImgParams.put("FILE", mapImgFile);
-							mapImgParams.put("TEXT",mapImgFile);
-							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
-							mapImg.add(mapImgParams);
-							
-							mapImgParams = new Hashtable();
-							mapImgFile = (String)holder.wayPoint + "_map_2.gif";
-							mapImgParams.put("FILE", mapImgFile);
-							mapImgParams.put("TEXT",mapImgFile);
-							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
-							mapImg.add(mapImgParams);
-	
-							page_tpl.setParam("mapImg", mapImg);
-						}
-
-						
-						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.wayPoint+".html")));
-						pagefile.print(page_tpl.output());
-						pagefile.close();
-					}catch(Exception e){
-						Vm.debug("Problem writing waypoint html file");
-					}
-				}//if is black, filtered
-			}
-			try{
-				Template tpl = new Template(template_init_index);
-				tpl.setParam("cache_index", cache_index);
-				PrintWriter detfile; 
-				detfile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + "/index.html")));
-				detfile.print(tpl.output());
-				detfile.close();
-				// sort by waypoint
-				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_wp.html", "WAYPOINT");
-				// sort by name
-				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_alpha.html", "NAME", false);
-				// sort by type
-				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_type.html", "TYPE", true);
-				// sort by size
-				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_size.html", "SIZE", true);
-				// sort by distance
-				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_dist.html", "DISTANCE", 10.0);
-			}catch(Exception e){
-				Vm.debug("Problem writing HTML files\n");
-				e.printStackTrace();
-			}//try
-			
-		}//if
-		ProgressBarForm.clear();
-	}
-	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field){
-		Vector navi_index;
-		PrintWriter detfile; 
-		
-		list.sort(new HTMLComparer(field),false);
-		try {
-			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
-			detfile.print(tmpl.output());
-			detfile.close();
-		} catch (IOException e) {
-			Vm.debug("Problem writing HTML files\n");
-			e.printStackTrace();
-		}
-	}
-
-	
-	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, boolean fullCompare){
-		Vector navi_index;
-		PrintWriter detfile; 
-		
-		list.sort(new HTMLComparer(field),false);
-		navi_index = addAnchorString(list,field, fullCompare);
-		if (navi_index != null){
-			tmpl.setParam("navi_index",navi_index);
-		}
-		try {
-			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
-			detfile.print(tmpl.output());
-			detfile.close();
-		} catch (IOException e) {
-			Vm.debug("Problem writing HTML files\n");
-			e.printStackTrace();
-		}
-	}
-	
-	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, double diff){
-		Vector navi_index;
-		PrintWriter detfile; 
-		
-		list.sort(new HTMLComparer(field),false);
-		navi_index = addAnchorString(list,field, diff);
-		if (navi_index != null){
-			tmpl.setParam("navi_index",navi_index);
-		}
-		try {
-			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
-			detfile.print(tmpl.output());
-			detfile.close();
-		} catch (IOException e) {
-			Vm.debug("Problem writing HTML files\n");
-			e.printStackTrace();
-		}
-		
-	}
-
-
-	private Vector addAnchorString(Vector list, String field, boolean fullCompare){
-		Vector topIndex = new Vector();
-		Hashtable topIndexParms, currEntry;
-		String lastValue, currValue;
-		
-		if (list.size() == 0) return null;
-		
-		currEntry = (Hashtable) list.get(0);
-		lastValue = (String) currEntry.get(field);
-		if (lastValue == null || lastValue.length() == 0) lastValue = "  ";
-		lastValue = lastValue.toUpperCase();
-		
-		for (int i=1; i<list.size(); i++){
-			currEntry = (Hashtable) list.get(i);
-			currValue = (String) currEntry.get(field);
-			currValue = currValue.toUpperCase();
-			if (currValue == null || currValue == "") continue;
-			try {
-				if (fullCompare) {
-					if (lastValue.compareTo(currValue)!= 0){
-						// Values for navigation line 
-						topIndexParms = new Hashtable();
-						topIndexParms.put("HREF", Convert.toString(i));
-						topIndexParms.put("TEXT", currValue);
-						topIndex.add(topIndexParms);
-						// add anchor entry to list
-						currEntry.put("ANCHORNAME", Convert.toString(i));
-						currEntry.put("ANCHORTEXT", currValue);
-					}
-					else {
-						// clear value from previous run
-						currEntry.put("ANCHORNAME", "");
-						currEntry.put("ANCHORTEXT", "");
-					}
-				}
-				else {
-					if (lastValue.charAt(0)!= currValue.charAt(0)){
-						// Values for navigation line 
-						topIndexParms = new Hashtable();
-						topIndexParms.put("HREF", Convert.toString(i));
-						topIndexParms.put("TEXT", currValue.charAt(0)+ " ");
-						topIndex.add(topIndexParms);
-						// add anchor entry to list
-						currEntry.put("ANCHORNAME", Convert.toString(i));
-						currEntry.put("ANCHORTEXT", currValue.charAt(0)+ " ");
-					}
-					else {
-						// clear value from previous run
-						currEntry.put("ANCHORNAME", "");
-						currEntry.put("ANCHORTEXT", "");
-					}
-				}
-				list.set(i,currEntry);
-				lastValue = currValue;
-			} catch (Exception e){
-				continue;
-			}
-		}
-		return topIndex;
-	}
-	private Vector addAnchorString(Vector list, String field, double diff){
-		Vector topIndex = new Vector();
-		Hashtable topIndexParms, currEntry;
-		double lastValue, currValue;
-		
-		if (list.size() == 0) return null;
-		
-		currEntry = (Hashtable) list.get(0);
-		lastValue = Common.parseDouble((String) currEntry.get(field)) + diff;
-		
-		for (int i=1; i<list.size(); i++){
-			currEntry = (Hashtable) list.get(i);
-			currValue = Common.parseDouble((String) currEntry.get(field));
-			if (currValue >= lastValue ){
-				// Values for navigation line 
-				topIndexParms = new Hashtable();
-				topIndexParms.put("HREF", Convert.toString(i));
-				topIndexParms.put("TEXT", Convert.toString(lastValue));
-				topIndex.add(topIndexParms);
-				// add anchor entry to list
-				currEntry.put("ANCHORNAME", Convert.toString(i));
-				currEntry.put("ANCHORTEXT", Convert.toString(lastValue));
-				lastValue = currValue + diff;
-			}
-			else {
-				// clear value from previous run
-				currEntry.put("ANCHORNAME", "");
-				currEntry.put("ANCHORTEXT", "");
-			}
-			list.set(i,currEntry);
-		}
-		return topIndex;
-	}
-
-	
-}

Deleted: trunk/src/CacheWolf/KMLExporter.java
===================================================================
--- trunk/src/CacheWolf/KMLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/KMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,68 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an KML-File
-*	which can be read by Google Earth   
-*   
-*/
-public class KMLExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public KMLExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle("Select target file:");
-		if(fc.execute() != fc.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//Create Header for KML-File
-				outp.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
-				outp.println("<kml xmlns=\"http://earth.google.com/kml/2.0\">");
-				outp.println("<Folder>");
-				outp.println("<name>CacheWolf</name>");
-				outp.println("<open>1</open>");
-				//loop through database
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false && holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon,".");
-						pll.parse();
-						outp.println("   <Placemark>");
-						outp.println("      <description>http://www.geocaching.com/seek/cache_details.aspx?wp="+holder.wayPoint+"</description>");
-						outp.println("      <name>"+ holder.wayPoint + " - " + SafeXML.clean(holder.CacheName) +"</name>");
-						outp.println("      <LookAt>");
-						outp.println("         <latitude>" + pll.getLatDeg() + "</latitude>");
-						outp.println("         <longitude>" + pll.getLonDeg() + "</longitude>");
-						outp.println("         <range>10000</range><tilt>0</tilt><heading>0</heading>");
-						outp.println("      </LookAt>");
-						outp.println("      <Point>");
-						outp.println("         <coordinates>"  + pll.getLonDeg() + "," + pll.getLatDeg() + "</coordinates>");
-						outp.println("      </Point>");
-						outp.println("   </Placemark>");
-					}//if holder...
-				}//for ... i < cacheDB ...			
-				// footer
-				outp.println("</Folder>");
-				outp.println("</kml>");
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug("Error writing to OVL file!");
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/LOCReader.java
===================================================================
--- trunk/src/CacheWolf/LOCReader.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/LOCReader.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,52 +0,0 @@
-package CacheWolf;
-import ewe.filechooser.*;
-import ewe.io.*;
-import ewe.util.*;
-import ewe.sys.*;
-
-/**
-*	This class analyses the gc.com loc filesa and extracts the cache waypoint 
-*	names. When run it offers the user a file chooser screen from which the user
-*	defines the directory the loc files are stored in. It searches the directory
-*	for the loc files and extractes the data from each loc file.	
-*/
-public class LOCReader{
-	private String dir = new String();
-	
-	public LOCReader(String d){
-		dir = d;
-	}
-	
-	public Vector doIt(){
-		Vector data = new Vector();
-		//need directory only!!!!
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, dir);
-		fc.setTitle("Select source directory:");
-		String sourceDir; 
-		String text = new String();
-		String dummy = new String();
-		if(fc.execute() != fc.IDCANCEL){
-			sourceDir = fc.getChosen();
-			//identify all loc files
-			File path = new File(sourceDir);
-			FileReader in;
-			Extractor ex;
-			String[] files = path.list("*.loc", FileBase.LIST_DONT_SORT);
-			for(int i = 0; i<files.length;i++){
-				try{
-					in = new FileReader(sourceDir + "/" + files[i]);
-					text = in.readAll();
-				}catch(Exception e){
-					//Vm.debug("Problem reading LOC file");
-				}
-				ex = new Extractor(text, "<name id=\"", "\">", 0, true);
-				dummy = ex.findNext();
-				while(ex.endOfSearch() == false){
-					data.add(dummy);
-					dummy = ex.findNext();
-				}
-			} //for
-		}//if execute
-		return data;
-	}
-}

Deleted: trunk/src/CacheWolf/MSARCSVExporter.java
===================================================================
--- trunk/src/CacheWolf/MSARCSVExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/MSARCSVExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,68 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an CSV File
-*	which can bei easy importet bei MS AutoRoute (testet with AR 2001 German)   
-*   Format of the file:
-*   Name;Breitengrad;L?ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink
-*   
-*/
-public class MSARCSVExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public MSARCSVExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle("Select target file:");
-		if(fc.execute() != FileChooser.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//Create Header for German Version
-				outp.println("Name;Breitengrad;L?ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink\r");
-				//loop through database
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false && holder.is_filtered == false){
-						try{
-							holder.readCache(profile.dataDir); // Need this for URL
-						}catch(Exception e){
-							//Vm.debug("Problem reading cache page");
-						}
-						pll = new ParseLatLon(holder.LatLon, ".");
-						pll.parse();
-						outp.print("\"" + holder.wayPoint + " - " + holder.CacheName + "\";");
-						outp.print(pll.getLatDeg().replace('.',',') + ";");
-						outp.print(pll.getLonDeg().replace('.',',') + ";");
-						outp.print("\"" + CacheType.transType(holder.type) + "\";");
-						outp.print("\"" + holder.CacheSize + "\";");
-						outp.print("\"" + holder.wayPoint + "\";");
-						outp.print("\"" + holder.DateHidden + "\";");
-						outp.print("\"" + holder.URL + "\"\r\n");
-						symCounter++;
-					}//if holder...
-				}//for ... i < cacheDB ...			
-				// overlay section
-				
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug("Error writing to OVL file!");
-			}
-		} // if execute
-	}
-}

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -8,6 +8,7 @@
 //import ewe.util.*;
 import ewe.io.*;
 import ewe.filechooser.*;
+import exp.*;
 
 /**
 *	This class creates the menu for cachewolf. It is also responsible
@@ -23,8 +24,8 @@
 	private MenuItem downloadmap, kalibmap, importmap;
 	private MenuItem spider, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
-	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTomASC, exportMSARCSV;
-	private MenuItem exportOZI, exportKML, exportTomTomOVL, exportTPL;
+	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTom, exportMSARCSV;
+	private MenuItem exportOZI, exportKML, exportTPL;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack;
 	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
 	private MenuItem orgCopy, orgMove, orgDelete;
@@ -48,14 +49,14 @@
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of "Application" menu below
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] exitems = new MenuItem[13];
+		MenuItem[] exitems = new MenuItem[12];
 		//Vm.debug("Hi in MainMenu "+lr);
 		exitems[0] = exporthtml = new MenuItem(MyLocale.getMsg(100,"to HTML"));
 		exitems[1] = exportpcx5 = new MenuItem(MyLocale.getMsg(101,"to PCX5 Mapsource"));
 		exitems[2] = exporttop50 = new MenuItem(MyLocale.getMsg(102,"to TOP50 ASCII"));
 		exitems[3] = exportGPX = new MenuItem(MyLocale.getMsg(103,"to GPX"));
 		exitems[4] = exportASC = new MenuItem(MyLocale.getMsg(104,"to ASC"));
-		exitems[5] = exportTomTomASC = new MenuItem(MyLocale.getMsg(105,"to TomTom ASC"));
+		exitems[5] = exportTomTom = new MenuItem(MyLocale.getMsg(105,"to TomTom"));
 		exitems[6] = exportMSARCSV = new MenuItem(MyLocale.getMsg(106,"to MS AutoRoute CSV"));
 		exitems[7] = exportGPS = new MenuItem(MyLocale.getMsg(122,"to GPS"));
 		if(!(new File(cwd + "/gpsbabel.exe")).exists()) exitems[7].modifiers = MenuItem.Disabled;
@@ -63,8 +64,7 @@
 		if(!(new File(cwd + "/cmconvert/cmconvert.exe")).exists()) exitems[8].modifiers = MenuItem.Disabled;
 		exitems[9] = exportOZI = new MenuItem(MyLocale.getMsg(124,"to OZI"));
 		exitems[10] = exportKML = new MenuItem(MyLocale.getMsg(125,"to Google Earth"));
-		exitems[11] = exportTomTomOVL = new MenuItem(MyLocale.getMsg(126,"to TomTom OV2"));
-		exitems[12] = exportTPL = new MenuItem(MyLocale.getMsg(128,"via Template"));
+		exitems[11] = exportTPL = new MenuItem(MyLocale.getMsg(128,"via Template"));
 		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107,"Export"));
 
 		///////////////////////////////////////////////////////////////////////
@@ -275,23 +275,21 @@
 				Vm.showWait(true);
 				PCX5Exporter pcx = new PCX5Exporter(pref, profile);
 				pcx.doIt(PCX5Exporter.MODE_AUTO);
-				ProgressBarForm pbf = new ProgressBarForm();
-				pbf.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
+				ProgressBarForm.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
 				String cwd = File.getProgramDirectory() + "/temp.pcx";
 				try{
 					ewe.sys.Process p = Vm.exec("gpsbabel -s -i pcx -f "+ cwd +" -o garmin -F " + pref.garminConn +":");
 					Vm.debug("gpsbabel -s -i pcx -f "+ cwd +" -o garmin -F " + pref.garminConn +":");
 					p.waitFor();
 				}catch(IOException ioex){};
-				pbf.clear();
+				ProgressBarForm.clear();
 				Vm.showWait(false);
 			}
 			if(mev.selectedItem == exportCacheMate){
 				Vm.showWait(true);
 				GPXExporter htm = new GPXExporter( pref, profile);
 				htm.doIt(0);
-				ProgressBarForm pbf = new ProgressBarForm();
-				pbf.display("CMCONVERT", MyLocale.getMsg(952,"Converting..."), null);
+				ProgressBarForm.display("CMCONVERT", MyLocale.getMsg(952,"Converting..."), null);
 				String cwd = new String();
 				cwd = File.getProgramDirectory() + "/temp.gpx";
 				// add surrounding "
@@ -303,7 +301,7 @@
 				}catch(IOException ioex){
 					//Vm.debug("Scheint ein Problem zu geben");
 				};
-				pbf.clear();
+				ProgressBarForm.clear();
 				Vm.showWait(false);
 			}
 			if(mev.selectedItem == filtClear){
@@ -343,9 +341,9 @@
 				ASCExporter asc = new ASCExporter(pref,profile);
 				asc.doIt();
 			}
-			if(mev.selectedItem == exportTomTomASC){
-				TomTomASCExporter asc = new TomTomASCExporter(pref, profile);
-				asc.doIt();
+			if(mev.selectedItem == exportTomTom){
+				TomTomExporter tt = new TomTomExporter();
+				tt.doIt();
 			}
 			if(mev.selectedItem == exportMSARCSV){
 				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
@@ -363,10 +361,6 @@
 				OziExporter ozi = new OziExporter( pref, profile);
 				ozi.doIt();
 			}
-			if(mev.selectedItem == exportTomTomOVL){
-				TomTomOV2Exporter tomovl = new TomTomOV2Exporter( pref, profile);
-				tomovl.doIt();
-			}
 			if(mev.selectedItem == exportKML){
 				KMLExporter kml = new KMLExporter( pref, profile);
 				kml.doIt();

Deleted: trunk/src/CacheWolf/OVLExporter.java
===================================================================
--- trunk/src/CacheWolf/OVLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/OVLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,89 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an ascii overlay file for
-*	the TOP50 map products (mainly available in german speaking countries).
-*/
-public class OVLExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences myPreferences;
-	Profile profile;
-	
-	public OVLExporter(Preferences p, Profile prof){
-		myPreferences = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 1;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle("Select target file:");
-		if(fc.execute() != FileChooser.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//symbols section, loop through database
-				//a circle and text per cache is created
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false && holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon,".");
-						pll.parse();
-						//the circle!
-						outp.print("[Symbol "+Convert.toString(symCounter)+"]\r\n");
-						outp.print("Typ=6\r\n");
-						outp.print("Width=15\r\n");
-						outp.print("Height=15\r\n");
-						outp.print("Col=1\r\n");
-						outp.print("Zoom=1\r\n");
-						outp.print("Size=2\r\n");
-						outp.print("Area=2\r\n");
-						outp.print("XKoord="+pll.getLonDeg()+"\r\n");
-						outp.print("YKoord="+pll.getLatDeg()+"\r\n");
-						symCounter++;
-						//the text
-						outp.print("[Symbol "+Convert.toString(symCounter)+"]\r\n");
-						outp.print("Typ=2\r\n");
-						outp.print("Col=1\r\n");
-						outp.print("Zoom=1\r\n");
-						outp.print("Size=2\r\n");
-						outp.print("Area=2\r\n");
-						outp.print("Font=3\r\n");
-						outp.print("Dir=1\r\n");
-						outp.print("XKoord="+Convert.toString(pll.lon2+0.002).replace(',', '.')+"\r\n");
-						outp.print("YKoord="+Convert.toString(pll.lat2+0.001).replace(',', '.')+"\r\n");
-						outp.print("Text="+holder.wayPoint+"\r\n");
-						symCounter++;
-					}//if holder...
-				}//for ... i < cacheDB ...			
-				// overlay section
-				outp.print("[Overlay]\r\n");
-				outp.print("Symbols="+Convert.toString(symCounter-1)+"\r\n");
-				// maplage section
-				outp.print("[MapLage]\r\n");
-				outp.print("MapName=Gesamtes Bundesgebiet (D1000)\r\n");
-				outp.print("DimmFc=100\r\n");
-				outp.print("ZoomFc=100\r\n");
-				outp.print("CenterLat="+myPreferences.curCentrePt.getLatDeg(CWPoint.CW)+".00\r\n");
-				outp.print("CenterLong="+myPreferences.curCentrePt.getLonDeg(CWPoint.CW)+".00\r\n");
-				outp.print("RefColor=255\r\n");
-				outp.print("RefRad=58\r\n");
-				outp.print("RefLine=6\r\n");
-				outp.print("RefOn=0\r\n");
-				outp.print("\r\n");
-				
-				outp.close();
-			}catch(Exception e){
-				Vm.debug("Error writing to OVL file! "+e.toString());
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/OziExporter.java
===================================================================
--- trunk/src/CacheWolf/OziExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/OziExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,112 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an TomTom ASC File
-*   Format of the file:
-*   Lon,Lat,"Description"
-*   
-*   Example for one entry:
-*	8.635,50.386,"Adlerhorst"
-*/
-public class OziExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public OziExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = prof.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle("Select target file:");
-		if(fc.execute() != fc.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//header
-				outp.println("OziExplorer CE Waypoint File Version 1.2");
-				outp.println("WGS 84");
-				outp.println("Reserved 2");
-				outp.println("Reserved 3");
-				//loop through database
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false && holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon,".");
-						pll.parse();
-						// Field 1 : Number - this is the location in the array (max 1000), must be unique, 
-						// usually start at 1 and increment. Can be set to -1 (minus 1) and the number will be auto generated.
-						outp.print("-1,");
-						// Field 2 : Name - the waypoint name, use the correct length name to suit the GPS type.
-						outp.print(holder.wayPoint + ",");
-						// Field 3 : Latitude - decimal degrees.
-						outp.print(pll.getLatDeg()+",");
-						// Field 4 : Longitude - decimal degrees.
-						outp.print(pll.getLonDeg()+",");
-						// Field 5 : Date - see Date Format below, if blank a preset date will be used
-						outp.print(",");
-						// Field 6 : Symbol - 0 to number of symbols in GPS
-						outp.print("0,");
-						// Field 7 : Status - always set to 1
-						outp.print("1,");
-						// Field 8 : Map Display Format
-						outp.print("0,");
-						// Field 9 : Foreground Color (RGB value)
-						outp.print("0,");
-						// Field 10 : Background Color (RGB value)
-						outp.print("16777215,");
-						// Field 11 : Description (max 40), no commas
-						if (holder.CacheName.length() <= 40){
-							outp.print(holder.CacheName + ",");
-						}
-						else {
-							outp.print(holder.CacheName.substring(0,40) + ",");
-						}
-						// Field 12 : Pointer Direction
-						outp.print("0,");
-						// Field 13 : Garmin Display Format
-						outp.print("0,");
-						// Field 14 : Proximity Distance - 0 is off any other number is valid
-						outp.print("0,");
-						// Field 15 : Altitude - in feet (-777 if not valid)
-						outp.print("-777,");
-						// Field 16 : Font Size - in points
-						outp.print("8,");
-						// Field 17 : Font Style - 0 is normal, 1 is bold.
-						outp.print("1,");
-						// Field 18 : Symbol Size - 17 is normal size
-						outp.print("17,");
-						// Field 19 : Proximity Symbol Position
-						outp.print("0,");
-						// Field 20 : Proximity Time
-						outp.print("  10.0,");
-					    // Field 21 : Proximity or Route or Both
-						outp.print("2,");
-						// Field 22 : File Attachment Name
-						outp.print(",");
-						// Field 23 : Proximity File Attachment Name
-						outp.print(",");
-						// Field 24 : Proximity Symbol Name
-						outp.println(" ");
-					}//if holder...
-				}//for ... i < cacheDB ...			
-				// overlay section
-				
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug("Error writing to OZI file!");
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/PCX5Exporter.java
===================================================================
--- trunk/src/CacheWolf/PCX5Exporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/PCX5Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,104 +0,0 @@
-package CacheWolf;
-import ewe.filechooser.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.util.*;
-
-/**
-*	Class to export the cache database into an ascii file that may be imported
-*	ba Mapsource (c) by Garmin.
-*/
-public class PCX5Exporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-
-	public static int MODE_AUTO = 0;
-	public static int MODE_ASK = 1;
-	
-	public PCX5Exporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-
-	
-	public void doIt(int mode){
-		CacheHolder holder = new CacheHolder();
-		String saveStr = new String();
-		String latlonstr = new String();
-		String dummy = new String();
-		String cwd = new String();
-		cwd = File.getProgramDirectory();
-		File saveTo = new File(cwd + "/temp.pcx");
-		if(mode == MODE_ASK) {
-			FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-			fc.setTitle("Select target file:");
-			if(fc.execute() != fc.IDCANCEL) saveTo = fc.getChosenFile();
-		}
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-			outp.print("H  SOFTWARE NAME & VERSION\n");
-			outp.print("I  PCX5 2.09\n");
-			outp.print("\n");
-			outp.print("H  R DATUM                IDX DA            DF            DX            DY            DZ\n");
-			outp.print("M  G WGS 84               121 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00\n");
-			outp.print("\n");
-			outp.print("H  COORDINATE SYSTEM\n");
-			outp.print("U  LAT LON DM\n");
-			outp.print("\n");
-			outp.print("H  IDNT   LATITUDE  LONGITUDE      DATE      TIME     ALT   DESCRIPTION                              PROXIMITY     SYMBOL ;waypts\r\n");
-			
-			for(int i = 0; i<cacheDB.size(); i++){
-				holder=(CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false && holder.is_filtered == false){
-					  //Vm.debug(Convert.toString(i));
-					  //dummy = holder.CacheName;
-					  //dummy = replace(dummy, ",", "");
-					  //dummy = Reducer.convert(dummy, true, 6);
-					  saveStr = "W  " + holder.wayPoint + " ";
-					  latlonstr = replace(holder.LatLon, "?", " ");
-					  latlonstr = replace(latlonstr, " ", "");
-					  latlonstr = replace(latlonstr, "E", " E");
-					  latlonstr = replace(latlonstr, "W", " W");
-					  saveStr = saveStr + latlonstr + "     ";
-					  latlonstr = holder.CacheName;
-					  // has 42 characters
-					  while(latlonstr.length() < 41){
-						  latlonstr = latlonstr + " ";
-					  }
-					  if(latlonstr.length() > 41){
-						  latlonstr = latlonstr.substring(0,40);
-					  }
-					  saveStr = saveStr + "01-JAN-04 01:00:00 -0000 " + latlonstr + " 0.000000e+000  ";
-					  if(holder.is_found){
-						saveStr = saveStr +"8256\r\n";
-					  } else {
-						saveStr = saveStr +"8255\r\n";
-					  }
-					  outp.print(saveStr);
-				  } //if
-				} // for
-				outp.close();
-		} catch (Exception e){
-			//Vm.debug("Problem exporting to pcx5 file");
-		}
-	} //end of method
-		
-	private String replace( String s, String f, String r )
-	{
-	   if (s == null)  return s;
-	   if (f == null)  return s;
-	   if (r == null)  r = "";
-	
-	   int index01 = s.indexOf( f );
-	   while (index01 != -1)
-	   {
-		  s = s.substring(0,index01) + r + s.substring(index01+f.length());
-		  index01 += r.length();
-		  index01 = s.indexOf( f, index01 );
-	   }
-	   return s;
-	}
-}

Deleted: trunk/src/CacheWolf/TPLExporter.java
===================================================================
--- trunk/src/CacheWolf/TPLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/TPLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,226 +0,0 @@
-/*
-    CacheWolf is a software for PocketPC, Win and Linux that 
-    enables paperless caching. 
-    It supports the sites geocaching.com and opencaching.de
-    
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-		kalli at users.berlios.de
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
-
-package CacheWolf;
-
-import HTML.Template;
-import ewe.filechooser.FileChooser;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.ProgressBarForm;
-import ewe.util.*;
-import com.stevesoft.ewe_pat.*;
-
-/**
- * @author Kalle
- * class to export cachedata using a template
- */
-class TplFilter implements HTML.Tmpl.Filter
-{
-	private int type=SCALAR;
-	private String newLine="\n";
-	TextCodec codec = new AsciiCodec();
-	String badChars;
-	String decSep = ".";
-	
-
-	public TplFilter(){
-		codec = new AsciiCodec(AsciiCodec.STRIP_CR);
-		return;
-	}
-	
-	public int format() {
-		return this.type;
-	}
-	
-	public String parse(String t) {
-		//Vm.debug(t);
-		Regex rex, rex1;
-		String param, value;
-		// Filter newlines 
-		rex = new Regex("(?m)\n$","");
-		t = rex.replaceAll(t);
-
-		// Filter comments <#-- and -->
-		rex = new Regex("<#--.*-->","");
-		t = rex.replaceAll(t);
-
-		// replace <br> or <br /> with newline
-		rex = new Regex("<br.*>","");
-		rex.search(t);
-		if (rex.didMatch()){
-			t = rex.replaceAll(t);
-			t += newLine;
-		}
-		
-		// search for parameters
-		rex = new Regex("(?i)<tmpl_par.*>");
-		rex.search(t);
-		if (rex.didMatch()){
-			// get parameter
-			rex1 = new Regex("(?i)name=\"(.*)\"\\svalue=\"(.*)\"[?\\s>]");
-			rex1.search(t);
-			param = rex1.stringMatched(1);
-			value = rex1.stringMatched(2);
-			//Vm.debug("param=" + param + "\nvalue=" + value);
-			//clear t, because we allow only one parameter per line
-			t = "";
-			
-			// get the values
-			if (param.equals("charset")) {
-				if (value.equals("ASCII")) codec = new AsciiCodec();
-				if (value.equals("UTF8")) codec = new JavaUtf8Codec();
-			}
-			if (param.equals("badchars")) {
-				badChars = value;
-			}
-			if (param.equals("newline")){
-				newLine = "";
-				if (value.indexOf("CR") >= 0) newLine += "\r";
-				if (value.indexOf("LF") >= 0) newLine += "\n";
-			}
-			if (param.equals("decsep")) {
-				decSep = value;
-			}
-
-
-		}
-		return t;
-	}
-		
-	
-	public String [] parse(String [] t) {
-		throw new UnsupportedOperationException();
-	}
-}
- 
-
-public class TPLExporter {
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	String tplFile;
-
-	public TPLExporter(Preferences p, Profile prof, String tpl){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-		tplFile = tpl;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ProgressBarForm pbf = new ProgressBarForm();
-		ewe.sys.Handle h = new ewe.sys.Handle();
-		Vector cache_index = new Vector();
-		Hashtable varParams;
-		TplFilter myFilter;
-
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle("Select target file:");
-		if(fc.execute() == FileChooser.IDCANCEL) return;
-		File saveTo = fc.getChosenFile();
-		
-		int counter = 0;
-		for(int i = 0; i<cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false && holder.is_filtered == false) counter++;
-		}
-		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
-		pbf.exec();
-		
-		Hashtable args = new Hashtable();
-		myFilter = new TplFilter();
-		//args.put("debug", "true");
-		args.put("filename", tplFile);
-		args.put("case_sensitive", "true");
-		args.put("loop_context_vars", Boolean.TRUE);
-		args.put("max_includes", new Integer(5));
-		args.put("filter", myFilter);
-		try {
-			Template tpl = new Template(args);
-
-			for(int i = 0; i<counter;i++){
-				holder = (CacheHolder)cacheDB.get(i);
-				h.progress = (float)i/(float)counter;
-				h.changed();
-				if(holder.is_black == false && holder.is_filtered == false){
-					try{
-						holder.readCache(profile.dataDir);
-					}catch(Exception e){
-						Vm.debug("Problem reading cache page");
-					}
-					try {
-						CWPoint point = new CWPoint(holder.LatLon, CWPoint.CW);
-						Regex dec = new Regex("[,.]",myFilter.decSep);
-						varParams = new Hashtable();
-						varParams.put("TYPE", CacheType.transType(holder.type));
-						varParams.put("SHORTTYPE", CacheType.transType(holder.type).substring(0,1));
-						varParams.put("SIZE", holder.CacheSize);
-						varParams.put("SHORTSIZE", holder.CacheSize.substring(0,1));
-						varParams.put("WAYPOINT", holder.wayPoint);
-						if (myFilter.badChars != null) {
-							Regex rex = new Regex("["+myFilter.badChars+"]","");
-							varParams.put("NAME", rex.replaceAll(holder.CacheName));
-						}
-						else {
-							varParams.put("NAME", holder.CacheName);
-						}
-						varParams.put("OWNER", holder.CacheOwner);
-						varParams.put("DIFFICULTY", dec.replaceAll(holder.hard));
-						varParams.put("TERRAIN", dec.replaceAll(holder.terrain));
-						varParams.put("DISTANCE", dec.replaceAll(holder.distance));
-						varParams.put("BEARING", holder.bearing);
-						varParams.put("LATLON", holder.LatLon);
-						varParams.put("LAT", dec.replaceAll(point.getLatDeg(CWPoint.DD)));
-						varParams.put("LON", dec.replaceAll(point.getLonDeg(CWPoint.DD)));
-						varParams.put("STATUS", holder.CacheStatus);
-						varParams.put("DATE", holder.DateHidden);
-						varParams.put("URL", holder.URL);
-						cache_index.add(varParams);
-					}catch(Exception e){
-						Vm.debug("Problem getting Parameter, Cache: " + holder.wayPoint);
-						e.printStackTrace();
-					}
-				}
-			}
-
-			tpl.setParam("cache_index", cache_index);
-			PrintWriter detfile; 
-			FileWriter fw = new FileWriter(saveTo);
-			fw.codec = myFilter.codec;
-			detfile = new PrintWriter(new BufferedWriter(fw));
-			tpl.printTo(detfile);
-			//detfile.print(tpl.output());
-			detfile.close();
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-		pbf.exit(0);
-	}
-
-
-}

Deleted: trunk/src/CacheWolf/TomTomASCExporter.java
===================================================================
--- trunk/src/CacheWolf/TomTomASCExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/TomTomASCExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,57 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an TomTom ASC File
-*   Format of the file:
-*   Lon,Lat,"Description"
-*   
-*   Example for one entry:
-*	8.635,50.386,"Adlerhorst"
-*/
-public class TomTomASCExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public TomTomASCExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle("Select target file:");
-		if(fc.execute() != fc.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//loop through database
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false && holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon, ".");
-						pll.parse();
-						outp.print(pll.getLonDeg()+",");
-						outp.print(pll.getLatDeg()+",");
-						outp.println("\"" + holder.CacheName.replace(',',' ') + "\"\r");
-						symCounter++;
-					}//if holder...
-				}//for ... i < cacheDB ...			
-				// overlay section
-				
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug("Error writing to OVL file!");
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/TomTomOV2Exporter.java
===================================================================
--- trunk/src/CacheWolf/TomTomOV2Exporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/TomTomOV2Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,134 +0,0 @@
-package CacheWolf;
-import ewe.ui.mChoice;
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-
-/**
-*
-*	Class to export the cache database (index) to an TomTom OV2 File
-*
-**/
-public class TomTomOV2Exporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public TomTomOV2Exporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		double latlon;
-		int a,b,c,d,data;
-		RandomAccessFile outp;
-		File dfile; 
-		String[] wayType = {"Custom", "Traditional", "Multi", "Virtual", "Letterbox", "Event", "Mega Event", "Mystery", "Webcam", "Locationless", "CITO", "Earthcache", "Parking", "Stage", "Question", "Final","Trailhead","Reference"};
-		String ctype = "";
-		//need directory only!!!!
-		String dummy = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
-		fc.setTitle("Select Tomtom Map directory:");
-		String targetDir;
-		if(fc.execute() != fc.IDCANCEL){
-			targetDir = fc.getChosen();
-			try{
-				//loop through type
-				for(int j = 0; j <= 15; j++){
-					switch (j){
-						case 0: ctype = "0"; break;
-						case 1: ctype = "2"; break;
-						case 2: ctype = "3"; break;
-						case 3: ctype = "4"; break;
-						case 4: ctype = "5"; break;
-						case 5: ctype = "6"; break;
-						case 6: ctype = "453"; break;
-						case 7: ctype = "8"; break;
-						case 8: ctype = "11"; break;
-						case 9: ctype = "12"; break;
-						case 10: ctype = "13"; break;
-						case 11: ctype = "137"; break;
-						case 12: ctype = "50";break;
-						case 13: ctype = "51";break;
-						case 14: ctype = "52";break;
-						case 15: ctype = "53";break;
-						case 16: ctype = "54";break;
-						case 17: ctype = "55";break;
-					} 
-					dfile = new File(targetDir + "/GC-" + wayType[j] + ".ov2");
-					dfile.delete();
-					outp =  new RandomAccessFile(targetDir + "/GC-" + wayType[j] + ".ov2","rw");
-					//loop through database
-					for(int i = 0; i<cacheDB.size(); i++){
-						holder=(CacheHolder)cacheDB.get(i);
-						if( ctype.equals(holder.type) && holder.is_black == false && holder.is_filtered == false){
-							pll = new ParseLatLon(holder.LatLon);
-							pll.parse();
-							d = 2;
-							outp.writeByte((byte)d);
-							data = holder.wayPoint.length()+holder.CacheName.length()+holder.CacheOwner.length()+holder.hard.length()+holder.terrain.length()+holder.CacheSize.length()+27;
-							d = 0;
-							c = data / 65536;
-							b = (data - c *65536) / 256;
-							a = (data - c * 65536 - b * 256);
-							outp.writeByte((byte)a);
-							outp.writeByte((byte)b);
-							outp.writeByte((byte)c);
-							outp.writeByte((byte)d);
-							latlon = Float.valueOf(pll.getLonDeg()).floatValue();
-							latlon *=100000;
-							data = (int) latlon;
-							d = 0;
-							c = data / 65536;
-							b = (data - c *65536) / 256;
-							a = (data - c * 65536 - b * 256);
-							outp.writeByte((byte)a);
-							outp.writeByte((byte)b);
-							outp.writeByte((byte)c);
-							outp.writeByte((byte)d);
-							latlon = Float.valueOf(pll.getLatDeg()).floatValue();
-							latlon *=100000;
-							data = (int) latlon;
-							d = 0;
-							c = data / 65536;
-							b = (data - c *65536) / 256;
-							a = (data - c * 65536 - b * 256);
-							outp.writeByte((byte)a);
-							outp.writeByte((byte)b);
-							outp.writeByte((byte)c);
-							outp.writeByte((byte)d);
-							outp.writeBytes(holder.wayPoint);
-							outp.writeBytes(" - ");
-							outp.writeBytes(holder.CacheName);
-							outp.writeBytes(" by ");
-							outp.writeBytes(holder.CacheOwner);
-							//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
-							//Hier wieder einf?gen
-							//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
-							//wider um 1 erh?hen
-							outp.writeBytes("- ");             
-							outp.writeBytes(holder.hard);
-							outp.writeBytes("/");
-							outp.writeBytes(holder.terrain);
-							outp.writeBytes(" - ");
-							outp.writeBytes(holder.CacheSize);
-							outp.writeByte((byte)d);
-							symCounter++;
-						}//if holder...
-					}//for ... i < cacheDB ...			
-					// overlay section
-					outp.close();
-				}
-			}catch(Exception e){
-				//Vm.debug("Error writing to OVL file!");
-			}
-		} // if execute
-	}
-}

Copied: trunk/src/exp/ASCExporter.java (from rev 367, trunk/src/CacheWolf/ASCExporter.java)
===================================================================
--- trunk/src/CacheWolf/ASCExporter.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/exp/ASCExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,37 @@
+package exp;
+import CacheWolf.*;
+
+/**
+*	Class to export cache database to an ASCII (CSV!) file.
+*   This file can be used by I2C's POI Converter to generate
+*   POIs for different routing programmes, especially for
+*	Destinator ;-) !
+*/
+public class ASCExporter extends Exporter{
+	
+	public ASCExporter(){
+		super();
+		this.setMask("*.csv");
+		this.setHowManyParams(LAT_LON);
+	}
+	
+	public ASCExporter(Preferences p,Profile prof){
+		this();
+	}
+	
+	public String record (CacheHolder holder, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(100);
+		String dummy;
+		dummy = holder.CacheName;
+		dummy = dummy.replace(',', ' ');
+		strBuf.append(dummy);
+		strBuf.append(",");
+		strBuf.append(dummy);
+		strBuf.append(",");
+		strBuf.append(lon);
+		strBuf.append(",");
+		strBuf.append(lat);
+		strBuf.append(",,,,\r\n");
+		return strBuf.toString();
+	}
+}

Added: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/exp/Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,185 @@
+package exp;
+
+import CacheWolf.*;
+import CacheWolf.CWPoint;
+import ewe.sys.*;
+import ewe.filechooser.FileChooser;
+import ewe.io.BufferedWriter;
+import ewe.io.File;
+import ewe.io.FileWriter;
+import ewe.io.PrintWriter;
+import ewe.ui.ProgressBarForm;
+import ewe.util.*;
+
+/**
+ * @author Kalle
+ * Base class for exporter, handles basic things like selecting
+ * outputfile, display a counter etc.
+ * 
+ */
+public class Exporter {
+	final static int TMP_FILE = 0;
+	final static int ASK_FILE = 1;
+	
+	final static int NO_PARAMS 	= 0;
+	final static int LAT_LON 	= 1;
+	final static int COUNT 		= 2;
+	
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String mask = "*.*";
+	String tmpFileName;
+	char decimalSeparator='.';
+	boolean needCacheDetails = false;
+	int howManyParams = 0;
+	
+	public Exporter() {
+		profile = Global.getProfile();
+		pref = Global.getPref();
+		cacheDB = profile.cacheDB;
+		howManyParams = LAT_LON;
+	}
+	
+	public void doIt(){
+		this.doIt(ASK_FILE);
+	}
+
+	
+	public void doIt(int variant){
+		File outFile;
+		String str;
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		CWPoint coords = new CWPoint();
+
+
+		if (variant == ASK_FILE) {
+			outFile = getOutputFile();
+			if (outFile == null) return;
+		} else {
+			outFile = new File(tmpFileName);
+		}
+
+		pbf.showMainTask = false;
+		pbf.setTask(h,"Exporting ...");
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for(int i = 0; i<cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false && holder.is_filtered == false) counter++;
+		}
+
+		try{
+			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			str = this.header();
+			if (str != null) outp.print(str);
+			for(int i = 0; i<cacheDB.size(); i++){
+				holder=(CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false && holder.is_filtered == false){
+					expCount++;
+					h.progress = (float)expCount/(float)counter;
+					h.changed();
+					if (needCacheDetails) holder.readCache(profile.dataDir);
+					switch (this.howManyParams) {
+					case NO_PARAMS: 
+						str = record(holder);
+						break;
+					case LAT_LON:	
+						coords.set(holder.LatLon, CWPoint.CW);
+						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+						             		 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						break;
+					case LAT_LON|COUNT: 
+						coords.set(holder.LatLon, CWPoint.CW);
+						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+											 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+											 i);
+						break;
+					default:
+						str = null;
+						break;
+					}
+					if (str != null) outp.print(str);
+				}//if
+			}//for
+			switch (this.howManyParams & COUNT) {
+			case NO_PARAMS: 
+				str = trailer();
+				break;
+			case COUNT:
+				str = trailer(counter);
+				break;
+			default:
+				str = null;
+				break;
+			}
+			if (str != null) outp.print(str);
+			outp.close();
+			pbf.exit(0);
+		}catch (Exception e){
+			Vm.debug("Problem writing to file! "+e.toString());
+		}//try
+	}
+	
+	public void setMask(String mask){
+		this.mask = mask;
+	}
+	
+	public void setDecimalSeparator (char sep){
+		this.decimalSeparator = sep;
+	}
+	
+	public void setNeedCacheDetails(boolean how){
+		this.needCacheDetails = how;
+	}
+	
+	public void setHowManyParams(int paramBits){
+		this.howManyParams = paramBits;
+	}
+	
+	public void setTmpFileName(String fName){
+		this.tmpFileName = fName;
+	}
+
+	
+	public File getOutputFile (){
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle("Select target file:");
+		fc.addMask(mask);
+		if(fc.execute() != FileChooser.IDCANCEL){
+			return  fc.getChosenFile();
+		} else {
+			return null;
+		}
+	}
+		
+	public String header () {
+		return null;
+	}
+	
+	public String record(CacheHolder ch){
+		return null;
+	}
+
+	public String record(CacheHolder ch, String lat, String lon){
+		return null;
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon, int count){
+		return null;
+	}
+	
+	public String trailer(){
+		return null;
+	}
+	
+	public String trailer(int total){
+		return null;
+	}
+
+
+}

Copied: trunk/src/exp/GPXExporter.java (from rev 367, trunk/src/CacheWolf/GPXExporter.java)
===================================================================
--- trunk/src/CacheWolf/GPXExporter.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/exp/GPXExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,97 @@
+package exp;
+import ewe.sys.*;
+import ewe.io.File;
+import CacheWolf.*;
+/**
+*	Class to export the cache database to a GPX file with gc.com
+*	extensions.<br>
+*	Export of logs is not that nice. The cause is that CacheWolf does not spider
+*	logs individually, rather all logs as a single entity.
+*	ClassID = 2000
+*/
+public class GPXExporter extends Exporter{
+	
+	public GPXExporter(){
+		super();
+		this.setMask("*.gpx");
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+		this.setTmpFileName(File.getProgramDirectory() + "/temp.gpx");
+	}
+	
+	public GPXExporter(Preferences p, Profile prof){
+		super();
+		this.setMask("*.gpx");
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+		this.setTmpFileName(File.getProgramDirectory() + "/temp.gpx");
+	}
+	
+	public String header() {
+		StringBuffer strBuf = new StringBuffer(200);
+		Time tim = new Time();
+		
+		strBuf.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n");
+		strBuf.append("<gpx xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"1.0\" creator=\"Groundspeak Pocket Query\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0 http://www.groundspeak.com/cache/1/0/cache.xsd\" xmlns=\"http://www.topografix.com/GPX/1/0\">\r\n");
+		strBuf.append("  <desc>Geocache file generated by CacheWolf</desc>\r\n");
+		strBuf.append("  <author>CacheWolf</author>\r\n");
+		strBuf.append("  <email>test at test.com</email>\r\n");
+		tim = tim.setFormat("yyyy-MM-dd");
+		tim = tim.setToCurrentTime();
+		strBuf.append(" <time>"+tim.toString()+"T00:00:00.0000000-07:00</time>\r\n");
+
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon) {
+		StringBuffer strBuf = new StringBuffer(1000);
+		Time tim = new Time();
+
+		try{
+			strBuf.append("  <wpt lat=\""+lat+"\" lon=\""+lon+"\">\r\n");
+			if (ch.DateHidden.length()> 0){
+				tim.parse(ch.DateHidden, "M/d/y");
+			}
+			else {
+				tim.setText("2000-01-01");
+			}
+			strBuf.append("    <time>"+tim.toString()+"T00:00:00.0000000-07:00</time>\r\n");
+			strBuf.append("    <name>"+ch.wayPoint+"</name>\r\n");
+			strBuf.append("    <desc>"+SafeXML.cleanGPX(ch.CacheName)+" by "+SafeXML.cleanGPX(ch.CacheOwner)+"</desc>\r\n");
+			strBuf.append("    <url>http://www.geocaching.com/seek/cache_details.aspx?wp="+ch.wayPoint+"&amp;Submit6=Find</url>\r\n");
+			strBuf.append("    <urlname>"+SafeXML.cleanGPX(ch.CacheName)+" by "+SafeXML.cleanGPX(ch.CacheOwner)+"</urlname>\r\n");
+			strBuf.append("    <sym>Geocache</sym>\r\n");
+			strBuf.append("    <type>Geocache|"+CacheType.transType(ch.type)+"</type>\r\n");
+			String dummyAvailable = ch.is_available ? "True":"False";
+			String dummyArchived = ch.is_archived ? "True":"False";
+			strBuf.append("    <groundspeak:cache available=\""+ dummyAvailable + "\" archived=\"" + dummyArchived+ "\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">\r\n");
+			strBuf.append("      <groundspeak:name>"+SafeXML.cleanGPX(ch.CacheName)+"</groundspeak:name>\r\n");
+			strBuf.append("      <groundspeak:placed_by>"+SafeXML.cleanGPX(ch.CacheOwner)+"</groundspeak:placed_by>\r\n");
+			strBuf.append("      <groundspeak:owner>"+SafeXML.cleanGPX(ch.CacheOwner)+"</groundspeak:owner>\r\n");
+			strBuf.append("      <groundspeak:type>"+CacheType.transType(ch.type)+"</groundspeak:type>\r\n");
+			strBuf.append("      <groundspeak:container>"+ch.CacheSize+"</groundspeak:container>\r\n");
+			strBuf.append("      <groundspeak:difficulty>"+ch.hard.replace(',','.')+"</groundspeak:difficulty>\r\n");
+			strBuf.append("      <groundspeak:terrain>"+ch.terrain.replace(',','.')+"</groundspeak:terrain>\r\n");
+			String dummyHTML = ch.is_HTML ? "True":"False";
+			strBuf.append("      <groundspeak:long_description html=\"" + dummyHTML + "\">\r\n");
+			strBuf.append("      "+SafeXML.cleanGPX(ch.LongDescription));
+			strBuf.append("      \n</groundspeak:long_description>\r\n");
+			strBuf.append("	  <groundspeak:encoded_hints>"+SafeXML.cleanGPX(Common.rot13(ch.Hints))+"</groundspeak:encoded_hints>\r\n");
+			strBuf.append("      <groundspeak:logs>\r\n");
+			strBuf.append("      </groundspeak:logs>\r\n");
+			strBuf.append("      <groundspeak:travelbugs />\r\n");
+			strBuf.append("    </groundspeak:cache>\r\n");
+			strBuf.append("  </wpt>\r\n");
+		}catch(Exception e){
+			e.printStackTrace();
+			return null;
+		}//try
+
+		return strBuf.toString();
+	}
+	
+	public String trailer() {
+		return "</gpx>";
+	}
+	
+}

Copied: trunk/src/exp/HTMLExporter.java (from rev 374, trunk/src/CacheWolf/HTMLExporter.java)
===================================================================
--- trunk/src/CacheWolf/HTMLExporter.java	2007-01-09 22:12:11 UTC (rev 374)
+++ trunk/src/exp/HTMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,379 @@
+package exp;
+import CacheWolf.*;
+import ewe.util.*;
+import ewe.sys.*;
+import ewe.io.*;
+import ewe.ui.*;
+import ewe.filechooser.*;
+import HTML.*;
+
+/**
+*	Class to export cache information to individual HTML files.<br>
+*	It uses the HTML package to parse template files. This makes the export
+*	very flexible; enabling the user to customise the HTML files according
+*	to thier liking.
+*/
+public class HTMLExporter{
+//	TODO Exportanzahl anpassen: Bug: 7351
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String [] template_init_index = {
+	 		"filename",  "index.tpl",
+	 		"case_sensitive", "true",
+	 		"max_includes",   "5"
+	 		//,"debug", "true"
+	 	};
+	String [] template_init_page = {
+	 		"filename",  "page.tpl",
+	 		"case_sensitive", "true",
+	 		"max_includes",   "5"
+	 	};
+	public HTMLExporter(Preferences p, Profile prof){
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+	}
+	
+	public void doIt(){
+		CacheHolder holder = new CacheHolder();
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		//need directory only!!!!
+		String dummy = new String();
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
+		fc.setTitle("Select target directory:");
+		String targetDir;
+		if(fc.execute() != FileChooser.IDCANCEL){
+			targetDir = fc.getChosen() + "/";
+			Vector cache_index = new Vector();
+			Vector cacheImg = new Vector();
+			Vector logImg = new Vector();
+			Vector mapImg = new Vector();
+			Vector usrImg = new Vector();
+			
+
+			Hashtable varParams;
+			Hashtable imgParams;
+			Hashtable logImgParams;
+			Hashtable usrImgParams;
+			Hashtable mapImgParams;
+
+			//Generate index page
+			int counter = 0;
+			for(int i = 0; i<cacheDB.size();i++){
+				holder = (CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false && holder.is_filtered == false) counter++;
+			}
+			
+			pbf.showMainTask = false;
+			pbf.setTask(h,"Exporting ...");
+			pbf.exec();
+
+			for(int i = 0; i<counter;i++){
+				h.progress = (float)(i+1)/(float)counter;
+				h.changed();
+
+				holder = (CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false && holder.is_filtered == false){
+					//KHF read cachedata only if needed
+					try{
+						holder.readCache( profile.dataDir);
+					}catch(Exception e){
+						//Vm.debug("Problem reading cache page");
+					}
+					varParams = new Hashtable();
+					varParams.put("TYPE", CacheType.transType(holder.type));
+					varParams.put("SIZE", holder.CacheSize);
+					varParams.put("WAYPOINT", holder.wayPoint);
+					varParams.put("NAME", holder.CacheName);
+					varParams.put("OWNER", holder.CacheOwner);
+					varParams.put("DIFFICULTY", holder.hard);
+					varParams.put("TERRAIN", holder.terrain);
+					varParams.put("DISTANCE", holder.distance);
+					varParams.put("BEARING", holder.bearing);
+					varParams.put("LATLON", holder.LatLon);
+					varParams.put("STATUS", holder.CacheStatus);
+					cache_index.add(varParams);
+					//We can generate the individual page here!
+					try{
+						Template page_tpl = new Template(template_init_page);
+						page_tpl.setParam("TYPE", CacheType.transType(holder.type));
+						page_tpl.setParam("SIZE", holder.CacheSize);
+						page_tpl.setParam("WAYPOINT", holder.wayPoint);
+						page_tpl.setParam("NAME", holder.CacheName);
+						page_tpl.setParam("OWNER", holder.CacheOwner);
+						page_tpl.setParam("DIFFICULTY", holder.hard);
+						page_tpl.setParam("TERRAIN", holder.terrain);
+						page_tpl.setParam("DISTANCE", holder.distance);
+						page_tpl.setParam("BEARING", holder.bearing);
+						page_tpl.setParam("LATLON", holder.LatLon);
+						page_tpl.setParam("STATUS", holder.CacheStatus);
+						if (holder.is_HTML)
+							page_tpl.setParam("DESCRIPTION", holder.LongDescription);
+						else {
+							String dummyText = new String();
+							dummyText = STRreplace.replace(holder.LongDescription, "\n", "<br>");
+							page_tpl.setParam("DESCRIPTION",dummyText);
+							
+						}
+						page_tpl.setParam("HINTS", holder.Hints);
+						page_tpl.setParam("DECRYPTEDHINTS", Common.rot13(holder.Hints));
+						dummy = new String();
+						for(int j = 0; j<holder.CacheLogs.size(); j++){
+							dummy = dummy + (String)holder.CacheLogs.get(j)+"<br>";
+						}
+						page_tpl.setParam("LOGS", dummy);
+						page_tpl.setParam("NOTES", STRreplace.replace(holder.CacheNotes, "\n","<br>"));
+						// Cache Images
+						cacheImg.clear();
+						for(int j = 0; j<holder.Images.size(); j++){
+							imgParams = new Hashtable();
+							String imgFile = new String((String)holder.Images.get(j));
+							imgParams.put("FILE", imgFile);
+							if (j < holder.ImagesText.size())
+								imgParams.put("TEXT",(String)holder.ImagesText.get(j));
+							else
+								imgParams.put("TEXT",imgFile);
+							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
+							cacheImg.add(imgParams);
+						}
+						page_tpl.setParam("cacheImg", cacheImg);
+						// Log images
+						logImg.clear();
+						for(int j = 0; j<holder.LogImages.size(); j++){
+							logImgParams = new Hashtable();
+							String logImgFile = new String((String)holder.LogImages.get(j));
+							logImgParams.put("FILE", logImgFile);
+							if (j < holder.LogImagesText.size())
+								logImgParams.put("TEXT",(String)holder.LogImagesText.get(j));
+							else
+								logImgParams.put("TEXT",logImgFile);
+							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
+							logImg.add(logImgParams);
+						}
+						page_tpl.setParam("logImg", logImg);
+						// User images
+						usrImg.clear();
+						for(int j = 0; j<holder.UserImages.size(); j++){
+							usrImgParams = new Hashtable();
+							String usrImgFile = new String((String)holder.UserImages.get(j));
+							usrImgParams.put("FILE", usrImgFile);
+							if (j < holder.UserImagesText.size())
+								usrImgParams.put("TEXT",(String)holder.UserImagesText.get(j));
+							else
+								usrImgParams.put("TEXT",usrImgFile);
+							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
+							usrImg.add(usrImgParams);
+						}
+						page_tpl.setParam("userImg", usrImg);
+
+						// Map images
+						mapImg.clear();
+						mapImgParams = new Hashtable();
+						String mapImgFile = new String((String)holder.wayPoint + "_map.gif");
+						// check if map file exists
+						File test = new File(profile.dataDir + mapImgFile);
+						if (test.exists()) {
+							mapImgParams.put("FILE", mapImgFile);
+							mapImgParams.put("TEXT",mapImgFile);
+							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+							mapImg.add(mapImgParams);
+							
+							mapImgParams = new Hashtable();
+							mapImgFile = (String)holder.wayPoint + "_map_2.gif";
+							mapImgParams.put("FILE", mapImgFile);
+							mapImgParams.put("TEXT",mapImgFile);
+							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+							mapImg.add(mapImgParams);
+	
+							page_tpl.setParam("mapImg", mapImg);
+						}
+
+						
+						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.wayPoint+".html")));
+						pagefile.print(page_tpl.output());
+						pagefile.close();
+					}catch(Exception e){
+						Vm.debug("Problem writing waypoint html file");
+					}
+				}//if is black, filtered
+			}
+			try{
+				Template tpl = new Template(template_init_index);
+				tpl.setParam("cache_index", cache_index);
+				PrintWriter detfile; 
+				detfile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + "/index.html")));
+				detfile.print(tpl.output());
+				detfile.close();
+				// sort by waypoint
+				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_wp.html", "WAYPOINT");
+				// sort by name
+				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_alpha.html", "NAME", false);
+				// sort by type
+				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_type.html", "TYPE", true);
+				// sort by size
+				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_size.html", "SIZE", true);
+				// sort by distance
+				sortAndPrintIndex(tpl, cache_index,targetDir + "/index_dist.html", "DISTANCE", 10.0);
+			}catch(Exception e){
+				Vm.debug("Problem writing HTML files\n");
+				e.printStackTrace();
+			}//try
+			
+		}//if
+		pbf.exit(0);
+	}
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		list.sort(new HTMLComparer(field),false);
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug("Problem writing HTML files\n");
+			e.printStackTrace();
+		}
+	}
+
+	
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, boolean fullCompare){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		list.sort(new HTMLComparer(field),false);
+		navi_index = addAnchorString(list,field, fullCompare);
+		if (navi_index != null){
+			tmpl.setParam("navi_index",navi_index);
+		}
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug("Problem writing HTML files\n");
+			e.printStackTrace();
+		}
+	}
+	
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, double diff){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		list.sort(new HTMLComparer(field),false);
+		navi_index = addAnchorString(list,field, diff);
+		if (navi_index != null){
+			tmpl.setParam("navi_index",navi_index);
+		}
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug("Problem writing HTML files\n");
+			e.printStackTrace();
+		}
+		
+	}
+
+
+	private Vector addAnchorString(Vector list, String field, boolean fullCompare){
+		Vector topIndex = new Vector();
+		Hashtable topIndexParms, currEntry;
+		String lastValue, currValue;
+		
+		if (list.size() == 0) return null;
+		
+		currEntry = (Hashtable) list.get(0);
+		lastValue = (String) currEntry.get(field);
+		if (lastValue == null || lastValue.length() == 0) lastValue = "  ";
+		lastValue = lastValue.toUpperCase();
+		
+		for (int i=1; i<list.size(); i++){
+			currEntry = (Hashtable) list.get(i);
+			currValue = (String) currEntry.get(field);
+			currValue = currValue.toUpperCase();
+			if (currValue == null || currValue == "") continue;
+			try {
+				if (fullCompare) {
+					if (lastValue.compareTo(currValue)!= 0){
+						// Values for navigation line 
+						topIndexParms = new Hashtable();
+						topIndexParms.put("HREF", Convert.toString(i));
+						topIndexParms.put("TEXT", currValue);
+						topIndex.add(topIndexParms);
+						// add anchor entry to list
+						currEntry.put("ANCHORNAME", Convert.toString(i));
+						currEntry.put("ANCHORTEXT", currValue);
+					}
+					else {
+						// clear value from previous run
+						currEntry.put("ANCHORNAME", "");
+						currEntry.put("ANCHORTEXT", "");
+					}
+				}
+				else {
+					if (lastValue.charAt(0)!= currValue.charAt(0)){
+						// Values for navigation line 
+						topIndexParms = new Hashtable();
+						topIndexParms.put("HREF", Convert.toString(i));
+						topIndexParms.put("TEXT", currValue.charAt(0)+ " ");
+						topIndex.add(topIndexParms);
+						// add anchor entry to list
+						currEntry.put("ANCHORNAME", Convert.toString(i));
+						currEntry.put("ANCHORTEXT", currValue.charAt(0)+ " ");
+					}
+					else {
+						// clear value from previous run
+						currEntry.put("ANCHORNAME", "");
+						currEntry.put("ANCHORTEXT", "");
+					}
+				}
+				list.set(i,currEntry);
+				lastValue = currValue;
+			} catch (Exception e){
+				continue;
+			}
+		}
+		return topIndex;
+	}
+	private Vector addAnchorString(Vector list, String field, double diff){
+		Vector topIndex = new Vector();
+		Hashtable topIndexParms, currEntry;
+		double lastValue, currValue;
+		
+		if (list.size() == 0) return null;
+		
+		currEntry = (Hashtable) list.get(0);
+		lastValue = Common.parseDouble((String) currEntry.get(field)) + diff;
+		
+		for (int i=1; i<list.size(); i++){
+			currEntry = (Hashtable) list.get(i);
+			currValue = Common.parseDouble((String) currEntry.get(field));
+			if (currValue >= lastValue ){
+				// Values for navigation line 
+				topIndexParms = new Hashtable();
+				topIndexParms.put("HREF", Convert.toString(i));
+				topIndexParms.put("TEXT", Convert.toString(lastValue));
+				topIndex.add(topIndexParms);
+				// add anchor entry to list
+				currEntry.put("ANCHORNAME", Convert.toString(i));
+				currEntry.put("ANCHORTEXT", Convert.toString(lastValue));
+				lastValue = currValue + diff;
+			}
+			else {
+				// clear value from previous run
+				currEntry.put("ANCHORNAME", "");
+				currEntry.put("ANCHORTEXT", "");
+			}
+			list.set(i,currEntry);
+		}
+		return topIndex;
+	}
+
+	
+}

Copied: trunk/src/exp/KMLExporter.java (from rev 374, trunk/src/CacheWolf/KMLExporter.java)
===================================================================
--- trunk/src/CacheWolf/KMLExporter.java	2007-01-09 22:12:11 UTC (rev 374)
+++ trunk/src/exp/KMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,107 @@
+package exp;
+import CacheWolf.*;
+
+/**
+*	Class to export the cache database (index) to an KML-File
+*	which can be read by Google Earth   
+*   
+*/
+public class KMLExporter extends Exporter {
+
+	public KMLExporter(){
+		super();
+		this.setMask("*.kml");
+		this.setHowManyParams(LAT_LON);
+	}
+
+	
+	public KMLExporter(Preferences p, Profile prof){
+			super();
+			this.setMask("*.kml");
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+				
+		strBuf.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
+		strBuf.append("<kml xmlns=\"http://earth.google.com/kml/2.0\">");
+		strBuf.append("<Folder>");
+		strBuf.append("<name>CacheWolf</name>");
+		strBuf.append("<open>1</open>");
+
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(200);
+		
+		strBuf.append("   <Placemark>\r\n");
+		strBuf.append("      <description>http://www.geocaching.com/seek/cache_details.aspx?wp="+ch.wayPoint+"</description>\r\n");
+		strBuf.append("      <name>"+ ch.wayPoint + " - " + SafeXML.clean(ch.CacheName) +"</name>\r\n");
+		strBuf.append("      <LookAt>\r\n");
+		strBuf.append("         <latitude>" + lat + "</latitude>\r\n");
+		strBuf.append("         <longitude>" + lon + "</longitude>\r\n");
+		strBuf.append("         <range>10000</range><tilt>0</tilt><heading>0</heading>\r\n");
+		strBuf.append("      </LookAt>\r\n");
+		strBuf.append("      <Point>\r\n");
+		strBuf.append("         <coordinates>"  + lon + "," + lat + "</coordinates>\r\n");
+		strBuf.append("      </Point>\r\n");
+		strBuf.append("   </Placemark>\r\n");
+
+		return strBuf.toString();
+	}
+	
+	public String trailer(){
+		StringBuffer strBuf = new StringBuffer(50);
+
+		strBuf.append("</Folder>");
+		strBuf.append("</kml>");
+
+		return strBuf.toString();
+	}
+	
+/*	public void doIt(){
+		CacheHolder holder;
+		ParseLatLon pll;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle("Select target file:");
+		if(fc.execute() != fc.IDCANCEL){
+			File saveTo = fc.getChosenFile();
+			try{
+				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
+				//Create Header for KML-File
+				outp.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
+				outp.println("<kml xmlns=\"http://earth.google.com/kml/2.0\">");
+				outp.println("<Folder>");
+				outp.println("<name>CacheWolf</name>");
+				outp.println("<open>1</open>");
+				//loop through database
+				for(int i = 0; i<cacheDB.size(); i++){
+					holder=(CacheHolder)cacheDB.get(i);
+					if(holder.is_black == false && holder.is_filtered == false){
+						pll = new ParseLatLon(holder.LatLon,".");
+						pll.parse();
+						outp.println("   <Placemark>");
+						outp.println("      <description>http://www.geocaching.com/seek/cache_details.aspx?wp="+holder.wayPoint+"</description>");
+						outp.println("      <name>"+ holder.wayPoint + " - " + SafeXML.clean(holder.CacheName) +"</name>");
+						outp.println("      <LookAt>");
+						outp.println("         <latitude>" + pll.getLatDeg() + "</latitude>");
+						outp.println("         <longitude>" + pll.getLonDeg() + "</longitude>");
+						outp.println("         <range>10000</range><tilt>0</tilt><heading>0</heading>");
+						outp.println("      </LookAt>");
+						outp.println("      <Point>");
+						outp.println("         <coordinates>"  + pll.getLonDeg() + "," + pll.getLatDeg() + "</coordinates>");
+						outp.println("      </Point>");
+						outp.println("   </Placemark>");
+					}//if holder...
+				}//for ... i < cacheDB ...			
+				// footer
+				outp.println("</Folder>");
+				outp.println("</kml>");
+				outp.close();
+			}catch(Exception e){
+				//Vm.debug("Error writing to OVL file!");
+			}
+		} // if execute
+	}
+*/}

Copied: trunk/src/exp/MSARCSVExporter.java (from rev 376, trunk/src/CacheWolf/MSARCSVExporter.java)
===================================================================
--- trunk/src/CacheWolf/MSARCSVExporter.java	2007-01-10 18:57:52 UTC (rev 376)
+++ trunk/src/exp/MSARCSVExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,37 @@
+package exp;
+
+import CacheWolf.*;
+
+/**
+ * Class to export the cache database (index) to an CSV File which can bei easy
+ * importet bei MS AutoRoute (testet with AR 2001 German) Format of the file:
+ * Name;Breitengrad;L?ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink
+ * 
+ */
+public class MSARCSVExporter extends Exporter {
+
+	public MSARCSVExporter(Preferences p, Profile prof) {
+		super();
+		this.setMask("*.csv");
+		this.setDecimalSeparator(',');
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+	}
+
+	public String header() {
+		return "Name;Breitengrad;L\u00E4ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink\r";
+	}
+
+	public String record(CacheHolder ch, String lat, String lon) {
+		StringBuffer str = new StringBuffer(200);
+		str.append("\"" + ch.wayPoint + " - " + ch.CacheName + "\";");
+		str.append(lat + ";" + lon +";");
+		str.append("\"" + CacheType.transType(ch.type)+ "\";");
+		str.append("\"" + ch.CacheSize + "\";");
+		str.append("\"" + ch.wayPoint + "\";");
+		str.append("\"" + ch.DateHidden + "\";");
+		str.append("\"" + ch.URL + "\"\r\n");
+
+		return str.toString();
+	}
+}

Copied: trunk/src/exp/OVLExporter.java (from rev 380, trunk/src/CacheWolf/OVLExporter.java)
===================================================================
--- trunk/src/CacheWolf/OVLExporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/OVLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,137 @@
+package exp;
+import CacheWolf.*;
+import ewe.sys.*;
+
+/**
+*	Class to export the cache database (index) to an ascii overlay file for
+*	the TOP50 map products (mainly available in german speaking countries).
+*/
+public class OVLExporter extends Exporter{
+	
+	public OVLExporter(Preferences p, Profile prof){
+		super();
+		this.setMask("*.ovl");
+		this.setHowManyParams(LAT_LON|COUNT);
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon, int counter){
+		StringBuffer str = new StringBuffer(200);
+		double tmp;
+		str.append("[Symbol "+Convert.toString(2*counter + 1)+"]\r\n");
+		str.append("Typ=6\r\n");
+		str.append("Width=15\r\n");
+		str.append("Height=15\r\n");
+		str.append("Col=1\r\n");
+		str.append("Zoom=1\r\n");
+		str.append("Size=2\r\n");
+		str.append("Area=2\r\n");
+		str.append("XKoord="+lon+"\r\n");
+		str.append("YKoord="+lat+"\r\n");
+		//the text
+		str.append("[Symbol "+Convert.toString(2*counter + 2)+"]\r\n");
+		str.append("Typ=2\r\n");
+		str.append("Col=1\r\n");
+		str.append("Zoom=1\r\n");
+		str.append("Size=2\r\n");
+		str.append("Area=2\r\n");
+		str.append("Font=3\r\n");
+		str.append("Dir=1\r\n");
+		tmp = Common.parseDouble(lon);
+		tmp += 0.002;
+		str.append("XKoord="+Convert.toString(tmp).replace(',', '.')+"\r\n");
+		tmp = Common.parseDouble(lat);
+		tmp += 0.002;
+		str.append("YKoord="+Convert.toString(tmp).replace(',', '.')+"\r\n");
+		str.append("Text="+ch.wayPoint+"\r\n");
+
+		return str.toString();
+	}
+	
+	public String trailer(int counter){
+		StringBuffer str = new StringBuffer(200);
+
+		str.append("[Overlay]\r\n");
+		str.append("Symbols="+Convert.toString(counter*2)+"\r\n");
+		// maplage section
+		str.append("[MapLage]\r\n");
+		str.append("MapName=Gesamtes Bundesgebiet (D1000)\r\n");
+		str.append("DimmFc=100\r\n");
+		str.append("ZoomFc=100\r\n");
+		str.append("CenterLat="+pref.curCentrePt.getLatDeg(CWPoint.CW)+".00\r\n");
+		str.append("CenterLong="+pref.curCentrePt.getLonDeg(CWPoint.CW)+".00\r\n");
+		str.append("RefColor=255\r\n");
+		str.append("RefRad=58\r\n");
+		str.append("RefLine=6\r\n");
+		str.append("RefOn=0\r\n");
+		str.append("\r\n");
+		return str.toString();
+	}
+
+	
+/*	public void doIt(){
+		CacheHolder holder;
+		ParseLatLon pll;
+		int symCounter = 1;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle("Select target file:");
+		if(fc.execute() != FileChooser.IDCANCEL){
+			File saveTo = fc.getChosenFile();
+			try{
+				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
+				//symbols section, loop through database
+				//a circle and text per cache is created
+				for(int i = 0; i<cacheDB.size(); i++){
+					holder=(CacheHolder)cacheDB.get(i);
+					if(holder.is_black == false && holder.is_filtered == false){
+						pll = new ParseLatLon(holder.LatLon,".");
+						pll.parse();
+						//the circle!
+						outp.print("[Symbol "+Convert.toString(symCounter)+"]\r\n");
+						outp.print("Typ=6\r\n");
+						outp.print("Width=15\r\n");
+						outp.print("Height=15\r\n");
+						outp.print("Col=1\r\n");
+						outp.print("Zoom=1\r\n");
+						outp.print("Size=2\r\n");
+						outp.print("Area=2\r\n");
+						outp.print("XKoord="+pll.getLonDeg()+"\r\n");
+						outp.print("YKoord="+pll.getLatDeg()+"\r\n");
+						symCounter++;
+						//the text
+						outp.print("[Symbol "+Convert.toString(symCounter)+"]\r\n");
+						outp.print("Typ=2\r\n");
+						outp.print("Col=1\r\n");
+						outp.print("Zoom=1\r\n");
+						outp.print("Size=2\r\n");
+						outp.print("Area=2\r\n");
+						outp.print("Font=3\r\n");
+						outp.print("Dir=1\r\n");
+						outp.print("XKoord="+Convert.toString(pll.lon2+0.002).replace(',', '.')+"\r\n");
+						outp.print("YKoord="+Convert.toString(pll.lat2+0.001).replace(',', '.')+"\r\n");
+						outp.print("Text="+holder.wayPoint+"\r\n");
+						symCounter++;
+					}//if holder...
+				}//for ... i < cacheDB ...			
+				// overlay section
+				outp.print("[Overlay]\r\n");
+				outp.print("Symbols="+Convert.toString(symCounter-1)+"\r\n");
+				// maplage section
+				outp.print("[MapLage]\r\n");
+				outp.print("MapName=Gesamtes Bundesgebiet (D1000)\r\n");
+				outp.print("DimmFc=100\r\n");
+				outp.print("ZoomFc=100\r\n");
+				outp.print("CenterLat="+myPreferences.curCentrePt.getLatDeg(CWPoint.CW)+".00\r\n");
+				outp.print("CenterLong="+myPreferences.curCentrePt.getLonDeg(CWPoint.CW)+".00\r\n");
+				outp.print("RefColor=255\r\n");
+				outp.print("RefRad=58\r\n");
+				outp.print("RefLine=6\r\n");
+				outp.print("RefOn=0\r\n");
+				outp.print("\r\n");
+				
+				outp.close();
+			}catch(Exception e){
+				Vm.debug("Error writing to OVL file! "+e.toString());
+			}
+		} // if execute
+	}
+*/}

Copied: trunk/src/exp/OziExporter.java (from rev 380, trunk/src/CacheWolf/OziExporter.java)
===================================================================
--- trunk/src/CacheWolf/OziExporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/OziExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,86 @@
+package exp;
+import CacheWolf.*;
+
+/**
+*	Class to export the cache database (index) to an OziExplorer File
+*/
+public class OziExporter extends Exporter{
+	
+	public OziExporter(Preferences p, Profile prof){
+		super();
+		this.setHowManyParams(LAT_LON);
+		this.setMask("*.wpt");
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+		
+		strBuf.append("OziExplorer CE Waypoint File Version 1.2\r\n");
+		strBuf.append("WGS 84\r\n");
+		strBuf.append("Reserved 2\r\n");
+		strBuf.append("Reserved 3\r\n");
+
+		return strBuf.toString();
+	}
+
+	public String record(CacheHolder ch, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(200);
+
+		// Field 1 : Number - this is the location in the array (max 1000), must be unique, 
+		// usually start at 1 and increment. Can be set to -1 (minus 1) and the number will be auto generated.
+		strBuf.append("-1,");
+		// Field 2 : Name - the waypoint name, use the correct length name to suit the GPS type.
+		strBuf.append(ch.wayPoint + ",");
+		// Field 3 : Latitude - decimal degrees.
+		strBuf.append(lat+",");
+		// Field 4 : Longitude - decimal degrees.
+		strBuf.append(lon+",");
+		// Field 5 : Date - see Date Format below, if blank a preset date will be used
+		strBuf.append(",");
+		// Field 6 : Symbol - 0 to number of symbols in GPS
+		strBuf.append("0,");
+		// Field 7 : Status - always set to 1
+		strBuf.append("1,");
+		// Field 8 : Map Display Format
+		strBuf.append("0,");
+		// Field 9 : Foreground Color (RGB value)
+		strBuf.append("0,");
+		// Field 10 : Background Color (RGB value)
+		strBuf.append("16777215,");
+		// Field 11 : Description (max 40), no commas
+		if (ch.CacheName.length() <= 40){
+			strBuf.append(ch.CacheName + ",");
+		}
+		else {
+			strBuf.append(ch.CacheName.substring(0,40) + ",");
+		}
+		// Field 12 : Pointer Direction
+		strBuf.append("0,");
+		// Field 13 : Garmin Display Format
+		strBuf.append("0,");
+		// Field 14 : Proximity Distance - 0 is off any other number is valid
+		strBuf.append("0,");
+		// Field 15 : Altitude - in feet (-777 if not valid)
+		strBuf.append("-777,");
+		// Field 16 : Font Size - in points
+		strBuf.append("8,");
+		// Field 17 : Font Style - 0 is normal, 1 is bold.
+		strBuf.append("1,");
+		// Field 18 : Symbol Size - 17 is normal size
+		strBuf.append("17,");
+		// Field 19 : Proximity Symbol Position
+		strBuf.append("0,");
+		// Field 20 : Proximity Time
+		strBuf.append("  10.0,");
+	    // Field 21 : Proximity or Route or Both
+		strBuf.append("2,");
+		// Field 22 : File Attachment Name
+		strBuf.append(",");
+		// Field 23 : Proximity File Attachment Name
+		strBuf.append(",");
+		// Field 24 : Proximity Symbol Name
+		strBuf.append(" \r\n");
+
+		return strBuf.toString();
+	}
+}

Copied: trunk/src/exp/PCX5Exporter.java (from rev 380, trunk/src/CacheWolf/PCX5Exporter.java)
===================================================================
--- trunk/src/CacheWolf/PCX5Exporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/PCX5Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,65 @@
+package exp;
+import CacheWolf.*;
+import ewe.io.File;
+
+/**
+*	Class to export the cache database into an ascii file that may be imported
+*	ba Mapsource (c) by Garmin.
+*/
+public class PCX5Exporter extends Exporter{
+	public static int MODE_AUTO = TMP_FILE;
+	public static int MODE_ASK = ASK_FILE;
+	
+	public PCX5Exporter(Preferences p, Profile prof){
+		super();
+		this.setMask("*.wpt");
+		this.setTmpFileName(File.getProgramDirectory() + "/temp.pcx");
+		this.setHowManyParams(NO_PARAMS);
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+
+		strBuf.append("H  SOFTWARE NAME & VERSION\n");
+		strBuf.append("I  PCX5 2.09\n");
+		strBuf.append("\n");
+		strBuf.append("H  R DATUM                IDX DA            DF            DX            DY            DZ\n");
+		strBuf.append("M  G WGS 84               121 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00\n");
+		strBuf.append("\n");
+		strBuf.append("H  COORDINATE SYSTEM\n");
+		strBuf.append("U  LAT LON DM\n");
+		strBuf.append("\n");
+		strBuf.append("H  IDNT   LATITUDE  LONGITUDE      DATE      TIME     ALT   DESCRIPTION                              PROXIMITY     SYMBOL ;waypts\r\n");
+		
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolder ch){
+		StringBuffer strBuf = new StringBuffer(200);
+		String latlonstr, dummy;
+
+		  strBuf.append("W  " + ch.wayPoint + " ");
+		  latlonstr = STRreplace.replace(ch.LatLon, "?", " ");
+		  latlonstr = STRreplace.replace(latlonstr, " ", "");
+		  latlonstr = STRreplace.replace(latlonstr, "E", " E");
+		  latlonstr = STRreplace.replace(latlonstr, "W", " W");
+		  strBuf.append(latlonstr + "     ");
+		  strBuf.append("01-JAN-04 01:00:00 -0000 ");
+		  // has 42 characters
+		  dummy = ch.CacheName;
+		  if (dummy.length() < 40){
+			  strBuf.append(dummy);
+			  int i = 40 - dummy.length();
+			  for (; i > 0; i--){
+				  strBuf.append(' ');
+			  }
+		  } else {
+			  strBuf.append(dummy.substring(0,40));
+		  }
+		  strBuf.append(" 0.000000e+000 ");
+		  if(ch.is_found) strBuf.append("  8256\r\n");
+		  else  		  strBuf.append("  8255\r\n");
+		return strBuf.toString();
+	}
+	
+}

Copied: trunk/src/exp/TPLExporter.java (from rev 380, trunk/src/CacheWolf/TPLExporter.java)
===================================================================
--- trunk/src/CacheWolf/TPLExporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/TPLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,234 @@
+/*
+    CacheWolf is a software for PocketPC, Win and Linux that 
+    enables paperless caching. 
+    It supports the sites geocaching.com and opencaching.de
+    
+    Copyright (C) 2006  CacheWolf development team
+    See http://developer.berlios.de/projects/cachewolf/
+    for more information.
+    Contact: 	bilbowolf at users.berlios.de
+		kalli at users.berlios.de
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+
+package exp;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheType;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import CacheWolf.STRreplace;
+import HTML.Template;
+import ewe.filechooser.FileChooser;
+import ewe.io.*;
+import ewe.sys.*;
+import ewe.ui.*;
+import ewe.util.*;
+import com.stevesoft.ewe_pat.*;
+
+/**
+ * @author Kalle
+ * class to export cachedata using a template
+ */
+class TplFilter implements HTML.Tmpl.Filter
+{
+	private int type=SCALAR;
+	private String newLine="\n";
+	TextCodec codec = new AsciiCodec();
+	String badChars;
+	String decSep = ".";
+	
+
+	public TplFilter(){
+		codec = new AsciiCodec(AsciiCodec.STRIP_CR);
+		return;
+	}
+	
+	public int format() {
+		return this.type;
+	}
+	
+	public String parse(String t) {
+		//Vm.debug(t);
+		Regex rex, rex1;
+		String param, value;
+		// Filter newlines 
+		rex = new Regex("(?m)\n$","");
+		t = rex.replaceAll(t);
+
+		// Filter comments <#-- and -->
+		rex = new Regex("<#--.*-->","");
+		t = rex.replaceAll(t);
+
+		// replace <br> or <br /> with newline
+		rex = new Regex("<br.*>","");
+		rex.search(t);
+		if (rex.didMatch()){
+			t = rex.replaceAll(t);
+			t += newLine;
+		}
+		
+		// search for parameters
+		rex = new Regex("(?i)<tmpl_par.*>");
+		rex.search(t);
+		if (rex.didMatch()){
+			// get parameter
+			rex1 = new Regex("(?i)name=\"(.*)\"\\svalue=\"(.*)\"[?\\s>]");
+			rex1.search(t);
+			param = rex1.stringMatched(1);
+			value = rex1.stringMatched(2);
+			//Vm.debug("param=" + param + "\nvalue=" + value);
+			//clear t, because we allow only one parameter per line
+			t = "";
+			
+			// get the values
+			if (param.equals("charset")) {
+				if (value.equals("ASCII")) codec = new AsciiCodec();
+				if (value.equals("UTF8")) codec = new JavaUtf8Codec();
+			}
+			if (param.equals("badchars")) {
+				badChars = value;
+			}
+			if (param.equals("newline")){
+				newLine = "";
+				if (value.indexOf("CR") >= 0) newLine += "\r";
+				if (value.indexOf("LF") >= 0) newLine += "\n";
+			}
+			if (param.equals("decsep")) {
+				decSep = value;
+			}
+
+
+		}
+		return t;
+	}
+		
+	
+	public String [] parse(String [] t) {
+		throw new UnsupportedOperationException();
+	}
+}
+ 
+
+public class TPLExporter {
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String tplFile;
+
+	public TPLExporter(Preferences p, Profile prof, String tpl){
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+		tplFile = tpl;
+	}
+	
+	public void doIt(){
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		ewe.sys.Handle h = new ewe.sys.Handle();
+		Vector cache_index = new Vector();
+		Hashtable varParams;
+		TplFilter myFilter;
+
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle("Select target file:");
+		if(fc.execute() == FileChooser.IDCANCEL) return;
+		File saveTo = fc.getChosenFile();
+		
+		int counter = 0;
+		for(int i = 0; i<cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false && holder.is_filtered == false) counter++;
+		}
+		pbf.showMainTask = false;
+		pbf.setTask(h,"Exporting ...");
+		pbf.exec();
+		
+		Hashtable args = new Hashtable();
+		myFilter = new TplFilter();
+		//args.put("debug", "true");
+		args.put("filename", tplFile);
+		args.put("case_sensitive", "true");
+		args.put("loop_context_vars", Boolean.TRUE);
+		args.put("max_includes", new Integer(5));
+		args.put("filter", myFilter);
+		try {
+			Template tpl = new Template(args);
+
+			for(int i = 0; i<counter;i++){
+				holder = (CacheHolder)cacheDB.get(i);
+				h.progress = (float)i/(float)counter;
+				h.changed();
+				if(holder.is_black == false && holder.is_filtered == false){
+					try{
+						holder.readCache(profile.dataDir);
+					}catch(Exception e){
+						Vm.debug("Problem reading cache page");
+					}
+					try {
+						CWPoint point = new CWPoint(holder.LatLon, CWPoint.CW);
+						Regex dec = new Regex("[,.]",myFilter.decSep);
+						varParams = new Hashtable();
+						varParams.put("TYPE", CacheType.transType(holder.type));
+						varParams.put("SHORTTYPE", CacheType.transType(holder.type).substring(0,1));
+						varParams.put("SIZE", holder.CacheSize);
+						varParams.put("SHORTSIZE", holder.CacheSize.substring(0,1));
+						varParams.put("WAYPOINT", holder.wayPoint);
+						if (myFilter.badChars != null) {
+							Regex rex = new Regex("["+myFilter.badChars+"]","");
+							varParams.put("NAME", rex.replaceAll(holder.CacheName));
+						}
+						else {
+							varParams.put("NAME", holder.CacheName);
+						}
+						varParams.put("OWNER", holder.CacheOwner);
+						varParams.put("DIFFICULTY", dec.replaceAll(holder.hard));
+						varParams.put("TERRAIN", dec.replaceAll(holder.terrain));
+						varParams.put("DISTANCE", dec.replaceAll(holder.distance));
+						varParams.put("BEARING", holder.bearing);
+						varParams.put("LATLON", holder.LatLon);
+						varParams.put("LAT", dec.replaceAll(point.getLatDeg(CWPoint.DD)));
+						varParams.put("LON", dec.replaceAll(point.getLonDeg(CWPoint.DD)));
+						varParams.put("STATUS", holder.CacheStatus);
+						varParams.put("DATE", holder.DateHidden);
+						varParams.put("URL", holder.URL);
+						varParams.put("NOTES", holder.CacheNotes);
+						varParams.put("DESCRIPTION", holder.LongDescription);
+						cache_index.add(varParams);
+					}catch(Exception e){
+						Vm.debug("Problem getting Parameter, Cache: " + holder.wayPoint);
+						e.printStackTrace();
+					}
+				}
+			}
+
+			tpl.setParam("cache_index", cache_index);
+			PrintWriter detfile; 
+			FileWriter fw = new FileWriter(saveTo);
+			fw.codec = myFilter.codec;
+			detfile = new PrintWriter(new BufferedWriter(fw));
+			tpl.printTo(detfile);
+			//detfile.print(tpl.output());
+			detfile.close();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		pbf.exit(0);
+	}
+
+
+}

Added: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/exp/TomTomExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,281 @@
+package exp;
+
+
+import CacheWolf.*;
+import ewe.ui.*;
+import ewe.util.*;
+import ewe.util.zip.*;
+import ewe.filechooser.FileChooser;
+import ewe.io.*;
+import ewe.sys.*;
+
+public class TomTomExporter {
+	public final static int TT_ASC = 0;
+	public final static int TT_OV2 = 1;
+	public final static int TT_WPT_TEXT = 0;
+	public final static int TT_WPT_NUM = 1;
+
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+
+	
+	String[][] wayType = {{"Custom","0"},{"Traditional","2"},
+						{"Multi","3"}, {"Virtual","4"},
+						{"Letterbox","5"},{"Event","6"},
+						{"Mega Event","453"}, {"Mystery","8"},
+						{"Webcam","11"},{"Locationless","12"},
+						{"CITO","13"},{"Earthcache","137"},
+						{"Parking","50"},{"Stage","51"},
+						{"Question","52"},{"Final","53"},
+						{"Trailhead","54"},{"Reference","55"}};
+
+	
+	public TomTomExporter() {
+		profile = Global.getProfile();
+		pref = Global.getPref();
+		cacheDB = profile.cacheDB;
+	}
+	
+	public void doIt(){
+		String fileName, dirName, prefix;
+		int fileFormat;
+
+		TomTomExporterScreen infoScreen = new TomTomExporterScreen("TomTomExport");
+		if (infoScreen.execute() == Form.IDCANCEL) return;
+		fileFormat = infoScreen.getFormat();
+		
+		if (infoScreen.oneFilePerType()==true){
+			FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
+			fc.setTitle("Select target dir:");
+			if(fc.execute() == FileChooser.IDCANCEL) return;
+			dirName = fc.getChosen();
+			prefix = infoScreen.getPrefix();
+			writeOneFilePerType(fileFormat, dirName, prefix);
+		} else{
+			FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+			fc.setTitle("Select target file:");
+	
+			if (fileFormat == TT_ASC) fc.addMask("*.asc");
+			else fc.addMask("*.ov2");
+			
+			if(fc.execute() == FileChooser.IDCANCEL) return;
+			fileName = fc.getChosen();
+			writeSingleFile(fileFormat, fileName);
+		}
+	}
+	
+	public void writeOneFilePerType(int format, String dirName, String prefix){
+		RandomAccessFile out = null;
+		File dfile;
+		String ext, fileName = null;
+
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		int currExp, counter;
+		CWPoint coords = new CWPoint();
+		
+		pbf.showMainTask = false;
+		pbf.setTask(h,"Exporting ...");
+		pbf.exec();
+		
+		currExp = 0;
+		counter = 0;
+		for(int i = 0; i<cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false && holder.is_filtered == false) counter++;
+		}
+		
+		ext = format==TT_ASC?".asc":".ov2";
+		try{
+			//loop through type
+			for(int j = 0; j < wayType.length; j++){
+				fileName = dirName + "/" + prefix + wayType[j][TT_WPT_TEXT]+ ext;
+				dfile = new File(fileName);
+				dfile.delete();
+				out =  new RandomAccessFile(fileName,"rw");
+				for(int i = 0; i<cacheDB.size(); i++){
+					holder=(CacheHolder)cacheDB.get(i);
+					if(holder.type.equals(wayType[j][TT_WPT_NUM]) && holder.is_black == false && holder.is_filtered == false){
+						currExp++;
+						h.progress = (float)currExp/(float)counter;
+						h.changed();
+						coords.set(holder.LatLon, CWPoint.CW);
+						if (format == TT_ASC){
+							writeRecordASCII(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+						} else {
+							writeRecordBinary(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+						}
+					}//if
+				}//for cacheDB
+				out.close();
+				// check for empty files and delete them
+				dfile = new File(fileName);
+				if (dfile.length()==0) {
+					dfile.delete();
+				} else {
+					copyIcon(j, dirName + "/" + prefix + wayType[j][TT_WPT_TEXT]); 
+				}
+			}//for wayType
+			pbf.exit(0);
+		} catch (IOException e){
+			Vm.debug("Problem creating file! " + fileName);
+			e.printStackTrace();
+		}//try
+		
+	}
+	
+	public void writeSingleFile(int format, String fileName){
+		RandomAccessFile out = null;
+		File dfile;
+
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		CWPoint coords = new CWPoint();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h,"Exporting ...");
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for(int i = 0; i<cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false && holder.is_filtered == false) counter++;
+		}
+
+		try{
+			dfile = new File(fileName);
+			dfile.delete();
+			out =  new RandomAccessFile(fileName,"rw");
+			for(int i = 0; i<cacheDB.size(); i++){
+				holder=(CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false && holder.is_filtered == false){
+					expCount++;
+					h.progress = (float)expCount/(float)counter;
+					h.changed();
+					coords.set(holder.LatLon, CWPoint.CW);
+					if (format == TT_ASC){
+						writeRecordASCII(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+					} else {
+						writeRecordBinary(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+					}
+				}//if
+			}//for
+			out.close();
+			copyIcon(0, fileName.substring(0,fileName.indexOf(".")));
+			pbf.exit(0);
+		}catch (Exception e){
+			Vm.debug("Problem writing to file! " + fileName);
+			e.printStackTrace();
+		}//try
+	}
+	
+	
+	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+		try {
+			outp.writeBytes(lon);
+			outp.writeBytes(",");
+			outp.writeBytes(lat);
+			outp.writeBytes(",");
+			outp.writeBytes("\"" + ch.CacheName.replace(',',' ') + "\"\r\n");
+		} catch (IOException e) {
+			Vm.debug("Error writing to file");
+			e.printStackTrace();
+		}
+		return;
+	}
+
+	
+	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+		int d,data;
+		double latlon;
+		
+		try {
+			d = 2;
+			outp.writeByte((byte)d);
+			data = ch.wayPoint.length()+ch.CacheName.length()+ch.CacheOwner.length()+ch.hard.length()+ch.terrain.length()+ch.CacheSize.length()+27;
+			writeIntBinary(outp, data);
+			latlon = Common.parseDouble(lon);
+			latlon *=100000;
+			writeIntBinary(outp, (int) latlon);
+			latlon = Common.parseDouble(lat);;
+			latlon *=100000;
+			writeIntBinary(outp, (int) latlon);
+			outp.writeBytes(ch.wayPoint);
+			outp.writeBytes(" - ");
+			outp.writeBytes(ch.CacheName);
+			outp.writeBytes(" by ");
+			outp.writeBytes(ch.CacheOwner);
+			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
+			//Hier wieder einf?gen
+			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
+			//wider um 1 erh?hen
+			outp.writeBytes("- ");             
+			outp.writeBytes(ch.hard);
+			outp.writeBytes("/");
+			outp.writeBytes(ch.terrain);
+			outp.writeBytes(" - ");
+			outp.writeBytes(ch.CacheSize);
+			d = 0;
+			outp.writeByte((byte)d);
+		} catch (IOException e) {
+			Vm.debug("Error writing to file");
+			e.printStackTrace();
+		}
+
+		return;
+	}
+
+	public void writeIntBinary(RandomAccessFile outp, int data){
+		int a,b,c,d;
+		d = 0;
+		c = data / 65536;
+		b = (data - c *65536) / 256;
+		a = (data - c * 65536 - b * 256);
+
+		try {
+			outp.writeByte((byte)a);
+			outp.writeByte((byte)b);
+			outp.writeByte((byte)c);
+			outp.writeByte((byte)d);
+		} catch (IOException e) {
+			Vm.debug("Error writing to file");
+			e.printStackTrace();
+		}
+		return;
+	}
+	
+	public void copyIcon(int intWayType, String filename){
+		try {
+			ZipFile zif = new ZipFile (File.getProgramDirectory() + "/POIIcons.zip");
+			ZipEntry zipEnt;
+			int len;
+			String entName; 
+			
+			entName = "TomTomIcons/"+ "GC-" + wayType[intWayType][TT_WPT_TEXT] + ".bmp";
+			zipEnt = zif.getEntry(entName);
+			if (zipEnt == null) return;
+			
+		    byte[] buff = new byte[ (int) zipEnt.getSize() ];
+		    InputStream  fis = zif.getInputStream(zipEnt);
+		    FileOutputStream fos = new FileOutputStream( filename + ".bmp");
+		    while( 0 < (len = fis.read( buff )) )
+		      fos.write( buff, 0, len );
+		    fos.flush();
+		    fos.close();
+		    fis.close();
+		} catch (ZipException e) {
+			Vm.debug("Problem copying Icon" + "GC-" + wayType[intWayType][TT_WPT_TEXT] + ".bmp" );
+			e.printStackTrace();
+		} catch (IOException e) {
+			Vm.debug("Problem copying Icon" + "GC-" + wayType[intWayType][TT_WPT_TEXT] + ".bmp" );
+			e.printStackTrace();
+		}
+
+		
+	}
+	
+}

Added: trunk/src/exp/TomTomExporterScreen.java
===================================================================
--- trunk/src/exp/TomTomExporterScreen.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/exp/TomTomExporterScreen.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,81 @@
+package exp;
+
+import CacheWolf.MyLocale;
+import ewe.ui.*;
+
+public class TomTomExporterScreen extends Form {
+	mButton cancelB, okB;
+	mCheckBox chkASC, chkOV2, chkOneFilePerType;
+	CheckBoxGroup chkGroupFormat;
+	mInput inpPrefix;
+	
+	public TomTomExporterScreen(String title){
+		super();
+		this.title = title;
+
+		// checkboxgroup for fileformat
+		chkGroupFormat = new CheckBoxGroup();
+		chkASC = new mCheckBox(".asc");
+		chkASC.setGroup(chkGroupFormat);
+		chkOV2 = new mCheckBox(".ov2");
+		chkOV2.setGroup(chkGroupFormat);
+		chkGroupFormat.selectIndex(TomTomExporter.TT_OV2);
+		
+		this.addLast(new mLabel("Fileformat"));
+		this.addNext(chkASC);
+		this.addLast(chkOV2);
+		
+		// checkbox for one file for all or one file per cachetype
+		chkOneFilePerType = new mCheckBox("Eine Datei pro Cachetyp");
+		chkOneFilePerType.setState(true);
+		this.addLast(chkOneFilePerType);
+		
+		//prefix for files, if one file per cachetype
+		inpPrefix = new mInput("GC-");
+		activateInpPrefix();
+		this.addLast(inpPrefix);
+		
+		// cancel and ok Button
+		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		this.addNext(cancelB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		okB = new mButton(MyLocale.getMsg(1605,"OK"));
+		okB.setHotKey(0, IKeys.ACTION);
+		okB.setHotKey(0, IKeys.ENTER);
+		this.addLast(okB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+	}
+	
+	public int getFormat() {
+		return chkGroupFormat.getSelectedIndex();
+	}
+	
+	public boolean oneFilePerType(){
+		return chkOneFilePerType.getState();
+	}
+	
+	public String getPrefix(){
+		return inpPrefix.getText();
+	}
+	
+	private void activateInpPrefix(){
+		if (chkOneFilePerType.getState()) inpPrefix.modify(0, ControlConstants.Disabled);
+		else inpPrefix.modify(ControlConstants.Disabled,0);
+		inpPrefix.repaintNow();
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okB){
+				this.close(Form.IDOK);
+			}
+			if (ev.target == chkOneFilePerType){
+				activateInpPrefix(); 
+			}
+		}
+		super.onEvent(ev);
+	}
+
+}



From admin at berlios.de  Sat Jan 20 06:39:35 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 20 Jan 2007 06:39:35 +0100 (CET)
Subject: [Bug #10069] MovingMap: Import läuft ins falsche (alte) Verzeichnis
Message-ID: <200701200539.l0K5dZot011782@unicorn.berlios.de>

Bug #10069, was updated on 2007-Jan-19 17:43
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 7
Submitted by: pfeffer
Assigned to : mik77
Summary: MovingMap: Import l?uft ins falsche (alte) Verzeichnis

Details: siehe http://www.geoclub.de/ftopic13608-20.html

Gru?,
  Pfeffer.

Follow-Ups:

Date: 2007-Jan-20 06:39
By: pfeffer

Comment:
ich hab's so gemacht:
Wenn sich im neuen Verzeichnis (<Profile-Verz>/maps/standard) kalibrierte Karten befinden, werden diese verwendet.
Falls das nicht der Fall ist:
wenn sich im alten Verzeichnis noch Karten befinden, wird nachgefragt, ob sie ins neue Verzeichnis verschoben werden sollen, falls nein, werden sie von der alten Position geladen.
SVN 406:
Wenn es keine selbst importierten Karten gibt, dann werden die von expedia herunter geladenen verwendet, d.h. <Profile-Verz>/maps/expedia

Bitte testen,
  Gru?,
    Pfeffer.

-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10069&group_id=2211


From admin at berlios.de  Sat Jan 20 06:41:51 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 20 Jan 2007 06:41:51 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2932] auch .bmp und jpg als kalibrierte
	Karte
Message-ID: <200701200541.l0K5fpOf015194@unicorn.berlios.de>

Feature Request #2932, was updated on 2006-Dec-04 03:01
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2932&group_id=2211

Category: 0.9n
Status: Open
Priority: 5
Summary: auch .bmp und jpg als kalibrierte Karte 

By: pfeffer
Date: 2007-Jan-20 06:41

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

SVN 406:
.png, .jpg, .gif und .bmp werden akzeptiert.

----------------------------------------------------------------------

By: pfeffer
Date: 2006-Dec-18 12:37

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

und auch .gif

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2932&group_id=2211


From pfeffer at mail.berlios.de  Sat Jan 20 06:46:28 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 20 Jan 2007 06:46:28 +0100
Subject: [Cachewolf-svn] r407 - in trunk: resources src/CacheWolf
Message-ID: <200701200546.l0K5kSP4014883@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-20 06:46:20 +0100 (Sat, 20 Jan 2007)
New Revision: 407

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Common.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/SelectMap.java
Log:
fixed: [ Bug #10069 ] MovingMap: Import l?\195?\164uft ins falsche (alte) Verzeichnis
erledigt: [ Feature Request #2932 ] auch .bmp und jpg als kalibrierte Karte
Konflikt von Nummern des Solvers mit der MovingMap in Languages.cfg beseitig (danke an Salzkammergut fuer den Hinweis!)

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-20 05:46:20 UTC (rev 407)
@@ -240,8 +240,6 @@
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
 		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp?ter erneut versuchen\n Status:
-		1700=Georeferenzierte Karten herunterladen
-		1701=Kacheln herunterladen
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 
@@ -275,6 +273,8 @@
 		1730=Fehlendes " am Ende der Zeichenkette
 		1731=Unerlaubtes Formatierungzeichen
 		1732=Unerlaubtes Zeichen		
+		1800=Georeferenzierte Karten herunterladen
+		1801=Kacheln herunterladen
 		2000=GPX Export
 		2001=von
 		3000=Schlie%dfen
@@ -532,8 +532,6 @@
 		1619=: could not download image from URL:+
 		1620=downloading embedded images:+
 		1621=Error while interpreting data\n from Opencaching.de,\nThis is most probaly a bug at Opencaching.de\nRetry later\n Status:
-		1700=Download georeferenced maps
-		1701=Download tiles
 		1700=Error on line: 
 		1701= position: 
 		1702=Variable not defined: 
@@ -567,6 +565,8 @@
 		1730=Unterminated string
 		1731=Invalid format character
 		1732=Invalid character		
+		1800=Download georeferenced maps
+		1801=Download tiles
 		2000=GPX Export
 		2001=of
 		3000=Close

Modified: trunk/src/CacheWolf/Common.java
===================================================================
--- trunk/src/CacheWolf/Common.java	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/src/CacheWolf/Common.java	2007-01-20 05:46:20 UTC (rev 407)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import ewe.io.File;
 import ewe.sys.Convert;
 
 public final class Common {
@@ -103,10 +104,28 @@
 		strBuf.append(strHex);
 		return strBuf.toString();
 	}
+	
 	public static String ClearForFileName(String str) {
 		String ret = str.replace('?', '_');
 		return ret;
 	}
-
-
+	
+	/**
+	 * finds the correct (existing) extension to an image filename
+	 * @param filename without extension
+	 * @return filename with extension 
+	 */
+	static public String getImageName(String name) {
+		String fileName;
+		File tmp;
+		String[] t = {".png", ".gif", ".jpg", ".bmp"};
+		int i;
+		for (i = 0; i<t.length; i++) {
+			tmp = new File(name+t[i]);
+			if (tmp.exists()) break;
+		}
+		if (i >=t.length) fileName = null;
+		else fileName = name+t[i];
+		return fileName;
+	}
 }

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/src/CacheWolf/Map.java	2007-01-20 05:46:20 UTC (rev 407)
@@ -18,8 +18,6 @@
 */
 public class Map extends Form {
 	Preferences pref;
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
 	String mapsPath = new String();
 	String thisMap = new String();
 	public String selectedMap = new String();
@@ -27,8 +25,6 @@
 	mLabel infLabel = new mLabel("                          ");
 	Vector GCPs = new Vector();
 	MapInfoObject wfl = new MapInfoObject();
-//	double[] affine = {0,0,0,0,0,0};
-//	double bottomlon, bottomlat = 0; // die werden im Moment nicht verwendet, nur berechnet nicht eingelesen von .wfl-datei und auch nie benutzt
 	mButton infButton;
 	ScrollBarPanel scp;
 	AniImage mapImg;
@@ -39,7 +35,7 @@
 	*/
 	public Map(Preferences pref){
 		this.pref = pref;
-		mapsPath = File.getProgramDirectory() + "/maps/"; // TODO veraltet
+		mapsPath = pref.getMapManuallySavePath()+"/"; //File.getProgramDirectory() + "/maps/"; // TODO veraltet
 	}
 	
 	/**
@@ -64,25 +60,25 @@
 	*/
 	public Map(Preferences pref, String mapToLoad, boolean worldfileexists){
 		this.pref = pref;
-		this.title = (String)lr.get(4106,"Calibrate map:") + " " + mapToLoad;
+		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
 		this.resizable = true;
 		this.moveable = true;
 		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		thisMap = mapToLoad;
-		mapsPath = File.getProgramDirectory() + "/maps/"; // TDO veraltet
+		mapsPath = pref.getMapManuallySavePath()+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
 		try {
 			wfl.loadwfl(mapsPath, thisMap);
 		}catch(FileNotFoundException ex){
 			Vm.debug("Cannot load world file!");
 		}catch (IOException ex) { // is thrown if lat/lon out of range
-			MessageBox tmpMB=new MessageBox((String)lr.get(312, "Error"), ex.getMessage(), MessageBox.OKB);
+			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
 			tmpMB.execute();
 			Vm.debug("Cannot load world file!");
 		}
 		mapInteractivePanel pane = new mapInteractivePanel(this);
 		scp = new ScrollBarPanel(pane);
-		Image img = new Image(mapsPath + thisMap + ".png");
+		Image img = new Image(Common.getImageName(mapsPath + thisMap));
 		PixelBuffer pB = new PixelBuffer(img);
 		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
 		mapImg = new AniImage(pB.toDrawableImage());
@@ -90,12 +86,12 @@
 		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
 		imageWidth = mapImg.getWidth();
 		imageHeight = mapImg.getHeight();
-		this.addLast(scp.getScrollablePanel(), this.STRETCH, this.FILL);
+		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		infPanel = new CellPanel();
-		infPanel.addNext(infLabel,this.STRETCH, this.FILL);
-		infButton = new mButton((String)lr.get(4107,"Done!"));
-		infPanel.addLast(infButton,this.DONTSTRETCH, this.FILL);
-		this.addLast(infPanel, this.DONTSTRETCH, this.FILL);
+		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
+		infButton = new mButton(MyLocale.getMsg(4107,"Done!"));
+		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
 		//scp.repaintNow();
 		//this.repaintNow();
 	}
@@ -193,12 +189,11 @@
 	*	It will use these files to automatically georeference the files during import.
 	*/
 	public boolean importMap(){
-		Extractor ext;
 		String rawFileName = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, File.getProgramDirectory());
-		fc.addMask("*.png");
-		fc.setTitle((String)lr.get(4100,"Select Directory:"));
-		if(fc.execute() != fc.IDCANCEL){
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
+		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
+		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
+		if(fc.execute() != FormBase.IDCANCEL){
 			File inDir = fc.getChosenFile();
 			File dir = new File(mapsPath);
 			File mapFile;
@@ -211,7 +206,8 @@
 				//at the same time try to find associated .map files!
 				//These are georeference files targeted for OziExplorer.
 				//So lets check if we have more than 1 png file:
-				String[] files;
+				Vector files;
+				String [] filestemp;
 				String line = new String();
 				InputStream in;
 				OutputStream out;
@@ -219,17 +215,27 @@
 				byte[] buf;
 				int len;
 				String[] parts;
-				files = inDir.list("*.png", File.LIST_FILES_ONLY);
-				InfoBox inf = new InfoBox("Info", (String)lr.get(4109,"Loading maps...")); 
+				filestemp = inDir.list("*.png", File.LIST_FILES_ONLY);
+				files = new Vector(filestemp);
+				filestemp = inDir.list("*.jpg", File.LIST_FILES_ONLY);
+				files.addAll(filestemp);
+				filestemp = inDir.list("*.gif", File.LIST_FILES_ONLY);
+				files.addAll(filestemp);
+				filestemp = inDir.list("*.bmp", File.LIST_FILES_ONLY);
+				files.addAll(filestemp);
+				
+				InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n")); 
 				Vm.showWait(true);
-				inf.show();
-				for(int i = 0; i<files.length;i++){
-					inf.setInfo((String)lr.get(4110,"Loading:")+ " " + files[i]);
+				inf.exec();
+				String currfile = null;
+				for(int i = files.size() -1 ; i >= 0;i--){
+					currfile = (String) files.get(i);
+					inf.setInfo(MyLocale.getMsg(4110,"Loading:\n")+ " " + currfile);
 					//Copy the file
 					//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
 					//Vm.debug("to: " + mapsPath + files[i]);
-					in = new FileInputStream(inDir.getFullPath() + "/" +files[i]);
-					out = new FileOutputStream(mapsPath + files[i]);
+					in = new FileInputStream(inDir.getFullPath() + "/" +currfile);
+					out = new FileOutputStream(mapsPath + currfile);
 					buf = new byte[1024];
 					while ((len = in.read(buf)) > 0) {
 					    out.write(buf, 0, len);
@@ -239,8 +245,7 @@
 					// here catch IOException
 					
 					//Check for a .map file
-					ext = new Extractor(files[i], "", ".", 0, true);
-					rawFileName = ext.findNext();
+					rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
 					mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
 					if(mapFile.exists()){
 						GCPoint gcp1 = new GCPoint();
@@ -366,10 +371,10 @@
 						retry = false;
 						wfl.saveWFL(mapsPath, thisMap);
 					} catch (IOException e) {
-						MessageBox tmpMB = new MessageBox((String)lr.get(321, "Error"), (String)lr.get(321, "Error writing file ") + e.getMessage()+(String)lr.get(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
 						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
 					}catch (IllegalArgumentException e) {
-						MessageBox tmpMB = new MessageBox((String)lr.get(144, "Warning"), (String)lr.get(325, "Map not calibrated")+(String)lr.get(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(325, "Map not calibrated")+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
 						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
 					}
 				}

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-20 05:46:20 UTC (rev 407)
@@ -107,17 +107,7 @@
 		if (fileName == null || fileName.length() > 0) return fileName;
 		if (fileNameWFL.length() == 0) return "";
 		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf("."));
-		File tmp;
-		String[] t = {".png", ".gif", ".jpg", ".bmp"};
-		int i;
-		for (i = 0; i<t.length; i++) {
-			tmp = new File(n+t[i]);
-			if (tmp.exists()) break;
-		}
-		
-		if (i >=t.length) fileName = null;
-		else fileName = n+t[i];
-		return fileName;
+		return Common.getImageName(n);
 	}
 	
 	/**

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-20 05:46:20 UTC (rev 407)
@@ -51,7 +51,7 @@
 	public MapLoaderGui(Vector cacheDBi) {
 		super();
 		cacheDB = cacheDBi;
-		this.title = MyLocale.getMsg(1700, "Download georeferenced maps"); 
+		this.title = MyLocale.getMsg(1800, "Download georeferenced maps"); 
 		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
 		center = new CWPoint(pref.curCentrePt);
 		// tiles panel
@@ -62,13 +62,13 @@
 		pnlTiles.addNext(forCachesChkBox);
 		pnlTiles.addNext(forSelectedChkBox);
 		pnlTiles.addLast(cachesLbl);
-		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1702,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1802,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		distanceInput = new mInput();
 		int tmp = Convert.toInt((Global.getProfile().distOC));
 		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
 		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1703, "around the center: ")));
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1803, "around the center: ")));
 		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
 		pnlTiles.addNext(scaleLbl);
 		scaleInput.setText("3");
@@ -87,7 +87,7 @@
 		okBtiles.setHotKey(0, IKeys.ENTER);
 		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		updateForCachesState();
-		mTab.addCard(pnlTiles, MyLocale.getMsg(1704, "Tiles"), MyLocale.getMsg(1704, "Tiles"));
+		mTab.addCard(pnlTiles, MyLocale.getMsg(1804, "Tiles"), MyLocale.getMsg(1804, "Tiles"));
 
 		// per cache panel
 		pnlPerCache.addLast(new MessageArea(descString));
@@ -106,7 +106,7 @@
 		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
 
 
-		mTab.addCard(pnlPerCache, MyLocale.getMsg(1705, "Per cache"), MyLocale.getMsg(1705, "Per Cache"));
+		mTab.addCard(pnlPerCache, MyLocale.getMsg(1805, "Per cache"), MyLocale.getMsg(1805, "Per Cache"));
 		this.addLast(mTab);
 	}
 	public String getMapsDir() {

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-20 05:46:20 UTC (rev 407)
@@ -72,7 +72,7 @@
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		this.title = "Moving Map";
 		this.backGround = Color.Black;
-		this.mapPath = Global.getPref().baseDir+"maps/expedia/";
+		this.mapPath = Global.getPref().getMapLoadPath()+"/";
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-20 05:46:20 UTC (rev 407)
@@ -8,19 +8,19 @@
 import ewe.filechooser.*;
 
 /**
-*	A class to hold the preferences that were loaded upon start up of CacheWolf.
-*	This class is also capable of parsing the prefs.xml file as well as
-*	saving the current settings of preferences.
-*/
+ *	A class to hold the preferences that were loaded upon start up of CacheWolf.
+ *	This class is also capable of parsing the prefs.xml file as well as
+ *	saving the current settings of preferences.
+ */
 public class Preferences extends MinML{
-	
+
 	public int tablePrefs[] = {1,1,1,1,1,1,1,1,1,1,1,1};
 	public int tableWidth[] = {20,20,20,20,65,135,135,100,60,50,50,50};
-	
+
 	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
 	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
 	static protected final int PROFILE_SELECTOR_ONOROFF=2;
-	
+
 	/** The currently used centre point, can be different from the profile's centrepoint. This is used
 	 *  for spidering */
 	public CWPoint curCentrePt=new CWPoint();
@@ -42,12 +42,12 @@
 	public String browser = new String();
 	public boolean showDeletedImages=true; /* Used in ImagePanel */
 	public boolean solverIgnoreCase=false;
-		
+
 	public int myAppHeight = 0;
 	public int myAppWidth = 0;
 	//public int nLogs = 5;
 	public boolean dirty = false;
-	
+
 	public int currProfile = 0;
 	public String profiles[] = new String[4];
 	public String profdirs[] = new String[4];
@@ -67,37 +67,39 @@
 	public boolean downloadMapsOC = true;
 	public boolean downloadmissingOC = false;
 	public boolean fixSIP = false;
-	
+
 	public String digSeparator = new String();
 	public boolean debug = false;
 	public SerialPortOptions mySPO = new SerialPortOptions();
 	public boolean forwardGPS = false;
 	public String forwardGpsHost = new String();
 	public int fontSize = 12;
+
+	public String mapsPath = new String("/maps/standard");
 	// Helper variables for XML parser 
 	private StringBuffer collectElement=null; 
 	private String lastName; // The string to the last XML that was processed
-	
+
 	private final String LOGFILENAME="log.txt";
 	// The following declarations may eventually be moved to a separate class
 	/** The actual directory of a profile, for new profiles this is a direct child of baseDir */
 	//TODO Find all references amd move to profile.dataDir
 	//public String mydatadir = new String();  //Redundant ??
 	/** The centre as read from the profile */
-	
-    /**
-     * Singleton pattern - return reference to Preferences
-     * @return Singleton Preferences object
-     */
-	
+
+	/**
+	 * Singleton pattern - return reference to Preferences
+	 * @return Singleton Preferences object
+	 */
+
 	public static Preferences getPrefObject() {
-      if (_reference == null)
-          // it's ok, we can call this constructor
-          _reference = new Preferences();
-      return _reference;
-    }
+		if (_reference == null)
+			// it's ok, we can call this constructor
+			_reference = new Preferences();
+		return _reference;
+	}
 
-    private static Preferences _reference;
+	private static Preferences _reference;
 
 	/**
 	 * Constructor is private for a singleton object
@@ -114,19 +116,92 @@
 		File logFile = new File(LOGFILENAME);
 		if (logFile.length()>60000) logInit();
 	}
-	
+
 	/**
-	* Returns true if coordinates have been set.
-	* Does not validate! if coordinates are real.
-	*/
+	 * gets the path to the calibrated maps
+	 * it first tries if there are manually imported maps
+	 * in <baseDir>/maps/standard then it tries 
+	 * the legacy dir: <program-dir>/maps
+	 * In case in both locations are no .wfl-files
+	 * it returns  <baseDir>/maps/expedia - the place where
+	 * the automatically downloaded maps are placed.
+	 * 
+	 * Later the maps-path shall be saved in the preferences
+	 */
+	public String getMapLoadPath() {
+		// here could also a list of map-types displayed...
+		// standard dir
+		File t = new File(getMapManuallySavePath());
+		String[] f = t.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_FILES_ONLY);
+		if (f != null && f.length > 0) return  baseDir + mapsPath;
+		f = t.list("*.wfl", File.LIST_DIRECTORIES_ONLY | File.LIST_ALWAYS_INCLUDE_DIRECTORIES);
+		if (f != null && f.length > 0) { // see if in a subdir of <baseDir>/maps/standard are .wfl files
+			String[] f2;
+			for (int i = 0; i< f.length; i++) {
+				t.set(null, getMapManuallySavePath()+"/"+f[i]);
+				f2 = t.list("*.wfl", File.LIST_FILES_ONLY);
+				if (f2 != null && f2.length > 0) return  getMapManuallySavePath();
+			}
+		}
+		// lagacy dir 
+		t.set(null, File.getProgramDirectory() + "/maps");
+		f = t.list("*.wfl", File.LIST_FILES_ONLY);
+		if (f != null && f.length > 0) {
+			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", MessageBox.YESB | MessageBox.NOB);
+			if (inf.execute() == MessageBox.IDYES) {
+				String sp = getMapManuallySavePath();
+				File spF = new File(sp);
+				if (!spF.exists()) spF.mkdirs();
+				String image;
+				String lagacypath = File.getProgramDirectory() + "/maps/";
+				for (int i=0; i<f.length; i++) {
+					t.set(null, lagacypath+f[i]);
+					spF.set(null, sp+"/"+f[i]);
+					t.move(spF);
+					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(".")));
+					t.set(null, image);
+					spF.set(null, sp+"/"+t.getFileExt());
+					t.move(spF);
+				}
+				t.set(null, lagacypath);
+				t.delete();
+				return sp;
+			}
+			else return  File.getProgramDirectory() + "/maps";
+		}
+		// expedia dir
+		return getMapExpediaPath(); 
+	}
+
+	/**
+	 * 
+	 * @return the path where manually imported maps should be stored
+	 * this should be adjustable in preferences...
+	 */
+	public String getMapManuallySavePath() {
+		return baseDir + mapsPath;
+	}
+
+	/**
+	 * to this path the automatically downloaded maps are saved
+	 */
+	public String getMapExpediaPath() {
+		return baseDir + "/maps/expedia";
+	}
+
+
+	/**
+	 * Returns true if coordinates have been set.
+	 * Does not validate! if coordinates are real.
+	 */
 	public boolean existCenter(){
-		return curCentrePt.latDec!=0.0 && curCentrePt.lonDec!=0.0; 
+		return curCentrePt.latDec!=0.0 && curCentrePt.lonDec!=0.0; // TODO: use cusCentrePt.isValid() 
 	}
-	
+
 	/**
-	* Method to open and parse the pref.xml file. Results are stored in the
-	* public variables of this class.
-	*/
+	 * Method to open and parse the pref.xml file. Results are stored in the
+	 * public variables of this class.
+	 */
 	public void readPrefFile(){
 		try{
 			String datei = File.getProgramDirectory() + "/" + "pref.xml";
@@ -141,14 +216,14 @@
 				Vm.debug(e.toString());
 		}
 	}
-	
+
 	/**
 	 * Open Profile selector screen 
 	 * @param prof
 	 * @param showProfileSelector
 	 * @return True if a profile was selected
 	 */
-	
+
 	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
 		// If datadir is empty, ask for one
 		if (baseDir.length()==0) {
@@ -161,14 +236,14 @@
 		if (!baseDir.endsWith("/")) baseDir+="/";
 		//Vm.showWait(false);
 		if((showProfileSelector==PROFILE_SELECTOR_FORCED_ON) || 
-		   (showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
-		   ProfilesForm f = new ProfilesForm(baseDir,profiles,lastProfile,hasNewButton);
-		   int code = f.execute();
-		   // If no profile chosen (includes a new one), terminate
-		   if (code==-1) return false; // Cancel pressed
-		   prof.clearProfile();
-		   curCentrePt.set(0,0); // No centre yet
-		   lastProfile=f.newSelectedProfile;
+				(showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
+			ProfilesForm f = new ProfilesForm(baseDir,profiles,lastProfile,hasNewButton);
+			int code = f.execute();
+			// If no profile chosen (includes a new one), terminate
+			if (code==-1) return false; // Cancel pressed
+			prof.clearProfile();
+			curCentrePt.set(0,0); // No centre yet
+			lastProfile=f.newSelectedProfile;
 		} 
 		prof.name=lastProfile;
 		currProfile=-1;
@@ -182,9 +257,9 @@
 		}
 		savePreferences();
 		return true;
-		
+
 	}
-	
+
 	/**
 	 * Open an old Profile (stored in preferences)
 	 * @param i 0-3 for profiles 1-4
@@ -206,13 +281,13 @@
 		prof.centre.set(lats[i]+" "+longs[i]);
 		prof.dataDir=profdirs[i];
 	}
-	
 
-	
-	
+
+
+
 	/**
-	* Method that gets called when a new element has been identified in pref.xml
-	*/
+	 * Method that gets called when a new element has been identified in pref.xml
+	 */
 	public void startElement(String name, AttributeList atts){
 		//Vm.debug("name = "+name);
 		lastName=name;
@@ -276,10 +351,10 @@
 			collectElement=new StringBuffer(50);
 			if (atts.getValue("autoreload").equals("true")) autoReloadLastProfile=true;
 		}
-		
+
 		//if(name.equals("datadir")) {
-			//mydatadir = atts.getValue("dir");
-			//profile.dataDir=mydatadir;
+		//mydatadir = atts.getValue("dir");
+		//profile.dataDir=mydatadir;
 		//}
 		if(name.equals("basedir")) {
 			baseDir = atts.getValue("dir");
@@ -288,7 +363,7 @@
 			downloadPicsOC = Boolean.valueOf(atts.getValue("downloadPics")).booleanValue();
 			downloadMapsOC = Boolean.valueOf(atts.getValue("downloadMaps")).booleanValue();
 			downloadmissingOC = Boolean.valueOf(atts.getValue("downloadmissing")).booleanValue();
-			
+
 		}
 		if(name.equals("proxy")) {
 			myproxy = atts.getValue("prx");
@@ -297,7 +372,7 @@
 		if (name.equals("garmin")) {
 			garminConn=atts.getValue("connection");
 		}
-		
+
 		if(name.equals("tableType")){ 
 			tablePrefs[1] = Convert.parseInt(atts.getValue("active"));
 			tmp = atts.getValue("width");
@@ -375,21 +450,21 @@
 			collectElement.append(ch,start,length); // Collect the name of the last profile
 		}
 	}	
-	
+
 	/**
-	* Method that gets called when the end of an element has been identified in pref.xml
-	*/
+	 * Method that gets called when the end of an element has been identified in pref.xml
+	 */
 	public void endElement(String tag){
 		if (tag.equals("lastprofile")) {
 			if (collectElement!=null) lastProfile=collectElement.toString();
 		}
 		collectElement=null;
 	}
-	
 
+
 	/**
-	* Method to save current preferences in the pref.xml file
-	*/
+	 * Method to save current preferences in the pref.xml file
+	 */
 	public void savePreferences(){
 		String datei = File.getProgramDirectory() + "/" + "pref.xml";
 		datei = datei.replace('\\', '/');
@@ -410,25 +485,25 @@
 			outp.print("	<proxy prx = \""+ myproxy+"\" prt = \""+ myproxyport + "\"/>\n");
 			outp.print("	<port portname = \""+ mySPO.portName +"\" baud = \""+ mySPO.baudRate+"\"/>\n");
 			outp.print("	<portforward active= \""+ Convert.toString(forwardGPS)+"\" destinationHost = \""+ forwardGpsHost+"\"/>\n");
-						outp.print("	<tableType active = \"1\" width = \""+Convert.toString(tableWidth[1])+"\"/>\n");
+			outp.print("	<tableType active = \"1\" width = \""+Convert.toString(tableWidth[1])+"\"/>\n");
 			outp.print("	<tableD active = \""+Convert.toString(tablePrefs[2])+ "\"" +
-					               " width = \""+Convert.toString(tableWidth[2])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[2])+"\"/>\n");
 			outp.print("	<tableT active = \""+Convert.toString(tablePrefs[3])+ "\"" +
-								   " width = \""+Convert.toString(tableWidth[3])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[3])+"\"/>\n");
 			outp.print("	<tableWay active = \"1\" width = \""+Convert.toString(tableWidth[4])+"\"/>\n");
 			outp.print("	<tableName active = \"1\" width = \""+Convert.toString(tableWidth[5])+"\"/>\n");
 			outp.print("	<tableLoc active = \""+Convert.toString(tablePrefs[6])+ "\"" +
-					   				 " width = \""+Convert.toString(tableWidth[6])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[6])+"\"/>\n");
 			outp.print("	<tableOwn active = \""+Convert.toString(tablePrefs[7])+ "\"" +
-					   				 " width = \""+Convert.toString(tableWidth[7])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[7])+"\"/>\n");
 			outp.print("	<tableHide active = \""+Convert.toString(tablePrefs[8])+ "\"" +
-					   				  " width = \""+Convert.toString(tableWidth[8])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[8])+"\"/>\n");
 			outp.print("	<tableStat active = \""+Convert.toString(tablePrefs[9])+ "\"" +
-					   				  " width = \""+Convert.toString(tableWidth[9])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[9])+"\"/>\n");
 			outp.print("	<tableDist active = \""+Convert.toString(tablePrefs[10])+ "\"" +
-					   				  " width = \""+Convert.toString(tableWidth[10])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[10])+"\"/>\n");
 			outp.print("	<tableBear active = \""+Convert.toString(tablePrefs[11])+ "\"" +
-					   				  " width = \""+Convert.toString(tableWidth[11])+"\"/>\n");
+					" width = \""+Convert.toString(tableWidth[11])+"\"/>\n");
 			outp.print("    <font size =\""+fontSize+"\"/>\n");
 			outp.print("	<browser name = \""+browser+"\"/>\n");
 			outp.print("    <fixedsip state = \""+fixSIP+"\"/>\n");
@@ -452,9 +527,9 @@
 		} catch (Exception e) {
 			Vm.debug("Problem saving: " +datei);
 			Vm.debug("Error: " +e.toString());
-    		}
+		}
 	}
-	
+
 	/**
 	 * Method to log messages to a file called log.txt
 	 * It will always append to an existing file.
@@ -476,7 +551,7 @@
 			strout.close();
 		}
 	}
-	
+
 	/**
 	 * Method to delete an existing log file. Something like a "reset".
 	 * Should be used "from time to time" to make sure the log file does not grow

Modified: trunk/src/CacheWolf/SelectMap.java
===================================================================
--- trunk/src/CacheWolf/SelectMap.java	2007-01-19 19:13:11 UTC (rev 406)
+++ trunk/src/CacheWolf/SelectMap.java	2007-01-20 05:46:20 UTC (rev 407)
@@ -24,16 +24,16 @@
 	public boolean worldfileexists = false;
 	
 	public SelectMap(){
-		mapsPath = File.getProgramDirectory() + "/maps/";
+		mapsPath = Global.getPref().getMapManuallySavePath()+"/"; //  File.getProgramDirectory() + "/maps/";
 		top = new ScrollBarPanel(CMaps);
 		bot = new ScrollBarPanel(nonCMaps);
 		this.title = (String)lr.get(4101,"Maps");
-		this.addLast(new mLabel((String)lr.get(4102,"Calibrated Maps")), this.STRETCH, this.FILL);
-		this.addLast(top, this.STRETCH, this.FILL);
-		this.addLast(new mLabel((String)lr.get(4103,"Non Calibrated Maps")), this.STRETCH, this.FILL);
-		this.addLast(bot, this.STRETCH, this.FILL);
-		this.addNext(mBCancel = new mButton((String)lr.get(4104,"Cancel")),this.STRETCH, this.FILL);
-		this.addLast(mBLoad = new mButton((String)lr.get(4105,"Open")),this.STRETCH, this.FILL);
+		this.addLast(new mLabel((String)lr.get(4102,"Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(top, CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new mLabel((String)lr.get(4103,"Non Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(bot, CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(mBCancel = new mButton((String)lr.get(4104,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(mBLoad = new mButton((String)lr.get(4105,"Open")),CellConstants.STRETCH, CellConstants.FILL);
 		InfoBox inf = new InfoBox("Info", (String)lr.get(4109,"Loading maps...")); 
 		inf.show();
 		try{



From kalli at mail.berlios.de  Sat Jan 20 09:18:55 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sat, 20 Jan 2007 09:18:55 +0100
Subject: [Cachewolf-svn] r408 - trunk/src/exp
Message-ID: <200701200818.l0K8ItSj022712@sheep.berlios.de>

Author: kalli
Date: 2007-01-20 09:18:53 +0100 (Sat, 20 Jan 2007)
New Revision: 408

Modified:
   trunk/src/exp/Exporter.java
Log:
Kommentiert

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2007-01-20 05:46:20 UTC (rev 407)
+++ trunk/src/exp/Exporter.java	2007-01-20 08:18:53 UTC (rev 408)
@@ -15,12 +15,18 @@
  * @author Kalle
  * Base class for exporter, handles basic things like selecting
  * outputfile, display a counter etc.
- * 
+ * A new Exporter must only override the header(), record() and 
+ * trailer() methods. The member howManyParams must be set to identify
+ * which ethod should be called  
  */
+
 public class Exporter {
+	// starts with no ui for file selection
 	final static int TMP_FILE = 0;
+	// brings up a screen to select a file
 	final static int ASK_FILE = 1;
 	
+	// selection, which method should be called
 	final static int NO_PARAMS 	= 0;
 	final static int LAT_LON 	= 1;
 	final static int COUNT 		= 2;
@@ -28,10 +34,16 @@
 	Vector cacheDB;
 	Preferences pref;
 	Profile profile;
+	// mask in file chooser
 	String mask = "*.*";
+	// file name, if no file chooser is used
 	String tmpFileName;
+	// decimal separator for lat- and lon-String
 	char decimalSeparator='.';
+	// if  true, the complete cache details are read
+	// before a call to the record method is made 
 	boolean needCacheDetails = false;
+	// selection, which method should be called
 	int howManyParams = 0;
 	
 	public Exporter() {
@@ -45,7 +57,11 @@
 		this.doIt(ASK_FILE);
 	}
 
-	
+	/**
+	 * Does the most work for exporting data
+	 * @param variant 0, if no filechooser
+	 *                1, if filechooser
+	 */
 	public void doIt(int variant){
 		File outFile;
 		String str;
@@ -124,28 +140,47 @@
 			Vm.debug("Problem writing to file! "+e.toString());
 		}//try
 	}
-	
+	/**
+	 * sets mask for filechooser
+	 * @param mask 
+	 */
 	public void setMask(String mask){
 		this.mask = mask;
 	}
-	
+	/**
+	 * sets decimal separator for lat/lon-string
+	 * @param sep
+	 */
 	public void setDecimalSeparator (char sep){
 		this.decimalSeparator = sep;
 	}
-	
+	/**
+	 *  sets needCacheDetails
+	 * @param how
+	 */
 	public void setNeedCacheDetails(boolean how){
 		this.needCacheDetails = how;
 	}
 	
+	/**
+	 * sets howManyParams
+	 * @param paramBits
+	 */
 	public void setHowManyParams(int paramBits){
 		this.howManyParams = paramBits;
 	}
-	
+	/**
+	 * sets tmpFileName
+	 * @param fName
+	 */
 	public void setTmpFileName(String fName){
 		this.tmpFileName = fName;
 	}
 
-	
+	/**
+	 * uses a filechooser to get the name of the export file
+	 * @return
+	 */
 	public File getOutputFile (){
 		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
 		fc.setTitle("Select target file:");
@@ -156,27 +191,57 @@
 			return null;
 		}
 	}
-		
+	/**
+	 * this method can be overided by an exporter class
+	 * @return formated header data
+	 */	
 	public String header () {
 		return null;
 	}
-	
+
+	/**
+	 * this method can be overided by an exporter class
+	 * @param ch	cachedata
+	 * @return formated cache data
+	 */	
 	public String record(CacheHolder ch){
 		return null;
 	}
 
+	/**
+	 * this method can be overided by an exporter class
+	 * @param ch	cachedata
+	 * @param lat	
+	 * @param lon
+	 * @return formated cache data
+	 */
 	public String record(CacheHolder ch, String lat, String lon){
 		return null;
 	}
-	
+	/**
+	 * this method can be overided by an exporter class
+	 * @param ch	cachedata
+	 * @param lat	
+	 * @param lon
+	 * @param count of actual record
+	 * @return formated cache data
+	 */
 	public String record(CacheHolder ch, String lat, String lon, int count){
 		return null;
 	}
 	
+	/**
+	 * this method can be overided by an exporter class
+	 * @return formated trailer data
+	 */	
 	public String trailer(){
 		return null;
 	}
-	
+	/**
+	 * this method can be overided by an exporter class
+	 * @param total count of exported caches
+	 * @return
+	 */
 	public String trailer(int total){
 		return null;
 	}



From admin at berlios.de  Sat Jan 20 12:50:04 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 20 Jan 2007 12:50:04 +0100 (CET)
Subject: [Feature #3053] Leistungsfähigerer Solver
Message-ID: <200701201150.l0KBo44l028387@unicorn.berlios.de>

Feature Request #3053, was updated on 2007-Jan-14 19:34
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211

Category: None
Status: Closed
Priority: 5
Summary: Leistungsf?higerer Solver

By: salzkammergut
Date: 2007-Jan-14 19:34

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Nur zur Erinnerung f?r 0.9n: Neuer Solver eingestellt.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3053&group_id=2211


From admin at berlios.de  Sat Jan 20 13:02:10 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 20 Jan 2007 13:02:10 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9801] solver
Message-ID: <200701201202.l0KC2Aqx010263@unicorn.berlios.de>

Bug #9801, was updated on 2006-Dec-22 13:22
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Closed
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: greiol
Assigned to : salzkammergut
Summary: solver

Details: der solver reagiert recht empfindlich auf "tippfehler"
-------------------------
2a=;
=> Absturz
-------------------------
a=";
=> unhandled exception
-------------------------
a=2;
"bla show(a);
=> unhandled exception
-------------------------


For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9801&group_id=2211


From pfeffer at mail.berlios.de  Sat Jan 20 15:31:16 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 20 Jan 2007 15:31:16 +0100
Subject: [Cachewolf-svn] r409 - trunk/src/CacheWolf
Message-ID: <200701201431.l0KEVGFF000486@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-20 15:31:12 +0100 (Sat, 20 Jan 2007)
New Revision: 409

Modified:
   trunk/src/CacheWolf/MapLoader.java
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/Preferences.java
Log:
Expedia-Map-Loader:
* funktioniert jetzt auch mit der deutschen Locale
* ignoriert caches mit lat/lon = 0/0
* mkdir funktioniert jetzt auch, wenn gleichzeitig mehrere Unterverzeichnisse angelegt werden m?\195?\188ssen

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-01-20 08:18:53 UTC (rev 408)
+++ trunk/src/CacheWolf/MapLoader.java	2007-01-20 14:31:12 UTC (rev 409)
@@ -158,8 +158,8 @@
 		lonD.set(lon);
 		quelle = "http://www.expedia.de/pub/agent.dll?qscr=mrdt";
 		quelle = quelle + "&ID=3kQaz.";
-		quelle = quelle + "&CenP=" + latD.toString() + "," + lonD.toString();
-		quelle = quelle + "&Alti="+Convert.toString(alti)+"&Lang="+zone+"&Size="+Convert.toString(PixelWidth)+","+Convert.toString(PixelHeight)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString() + "," + lonD.toString() + "|5|";
+		quelle = quelle + "&CenP=" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.');
+		quelle = quelle + "&Alti="+Convert.toString(alti)+"&Lang="+zone+"&Size="+Convert.toString(PixelWidth)+","+Convert.toString(PixelHeight)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
 		//Vm.debug(lat + "," + lon);
 		if(proxy.length()>0){
 			connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-20 08:18:53 UTC (rev 408)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-20 14:31:12 UTC (rev 409)
@@ -110,15 +110,7 @@
 		this.addLast(mTab);
 	}
 	public String getMapsDir() {
-		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length());
-		String mapsDir = Global.getPref().baseDir + "/maps/expedia/" + subdir;
-		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
-			if (new File(mapsDir).mkdir() == false) // dir creation failed?
-			{(new MessageBox("Error", "Error: cannot create maps directory: \n"+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
-			return null;
-			}
-		}
-		return mapsDir;
+		return Global.getPref().getMapExpediaPath();
 	}
 	public void downloadTiles() {
 		String mapsDir = getMapsDir();
@@ -193,7 +185,7 @@
 					tmpca.set(ch.LatLon);
 					ch.pos = new CWPoint(tmpca);
 				}
-				if (ch.pos.isValid()) {
+				if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0 ){ // TODO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
 					if (topleft == null) topleft = new CWPoint(ch.pos);
 					if (buttomright == null) buttomright = new CWPoint(ch.pos);
 					if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-20 08:18:53 UTC (rev 408)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-20 14:31:12 UTC (rev 409)
@@ -186,7 +186,15 @@
 	 * to this path the automatically downloaded maps are saved
 	 */
 	public String getMapExpediaPath() {
-		return baseDir + "/maps/expedia";
+		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length());
+		String mapsDir = Global.getPref().baseDir + "/maps/expedia/" + subdir;
+		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
+			if (new File(mapsDir).mkdirs() == false) // dir creation failed?
+			{(new MessageBox("Error", "Error: cannot create maps directory: \n"+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
+			return null;
+			}
+		}
+		return mapsDir;
 	}
 
 



From salzkammergut at mail.berlios.de  Sat Jan 20 16:48:14 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 20 Jan 2007 16:48:14 +0100
Subject: [Cachewolf-svn] r410 - trunk/src/CacheWolf
Message-ID: <200701201548.l0KFmEnt004493@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-20 16:48:03 +0100 (Sat, 20 Jan 2007)
New Revision: 410

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
Log:
Am Anfang weniger Platz fuer den Hint, mehr fuer die Logs

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-01-20 14:31:12 UTC (rev 409)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-01-20 15:48:03 UTC (rev 410)
@@ -23,11 +23,10 @@
 	mButton prevBt = new mButton("<<");
 	public HintLogPanel(){
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
-
 		CellPanel hintpane = split.getNextPanel();
 		CellPanel logpane = split.getNextPanel();
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
-		
+		hintpane.setCell(INITIALLY_PREFERRED_SIZE);
 		ScrollBarPanel sbphint = new ScrollBarPanel(hint);
 		hintpane.addLast(sbphint,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
 		sbphint.setMinimumSize(0,0);
@@ -36,13 +35,12 @@
 		decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
 		hintpane.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
 		
-		ScrollBarPanel sbplog = new ScrollBarPanel(logs, ScrollBarPanel.NeverShowHorizontalScrollers);
+		ScrollBarPanel sbplog = new ScrollBarPanel((ScrollClient)logs, ScrollBarPanel.NeverShowHorizontalScrollers);
 		logpane.addLast(sbplog,CellConstants.STRETCH, CellConstants.FILL);
 		hint.modify(Control.NotEditable,0);
 		this.addLast(split);
 	}
 	
-	
 	public void setText(CacheHolder cache){
 		this.cache = cache;
 		if(!cache.Hints.equals("null")) hint.setText(cache.Hints);
@@ -70,7 +68,6 @@
 		logs.setHtml(dummy.toString());
 		Vm.showWait(false);
 	}
-	
 	/**
 	* Method that handles user input on this panel.
 	* It handles decryption of hints and navigation through



From salzkammergut at mail.berlios.de  Sat Jan 20 18:22:18 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 20 Jan 2007 18:22:18 +0100
Subject: [Cachewolf-svn] r411 - trunk/src/CacheWolf
Message-ID: <200701201722.l0KHMIh9009381@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-20 18:22:06 +0100 (Sat, 20 Jan 2007)
New Revision: 411

Modified:
   trunk/src/CacheWolf/ParseLatLon.java
Log:
Optimierter Parser fuer Koordinaten im CW Format

Modified: trunk/src/CacheWolf/ParseLatLon.java
===================================================================
--- trunk/src/CacheWolf/ParseLatLon.java	2007-01-20 15:48:03 UTC (rev 410)
+++ trunk/src/CacheWolf/ParseLatLon.java	2007-01-20 17:22:06 UTC (rev 411)
@@ -1,31 +1,16 @@
 package CacheWolf;
-import com.stevesoft.ewe_pat.Regex;
 
 import ewe.sys.*;
 import ewe.sys.Double;
 
 /**
 *	This class parses a string representation of longitude and latitude.
-*	The result is a double vlaue representing longitude and another representing
+*	The result is a double value representing longitude and another representing
 *	latitude (DD.dddd)
-*	It should be extended to convert to and from UTM... but that is future
-*	functionality.
 */
 public class ParseLatLon {
 	
 	String latlon;	
-	String br2 = new String(); 
-	String lg2 = new String();
-	String br2_buf = new String(); 
-	String lg2_buf = new String();
-	String br3_buf = new String(); 
-	String lg3_buf = new String();
-	String br2NS = new String();
-	String lg2WE = new String();
-	public static final int NS = 1;
-	public static final int WE = -1;
-		
-	private String trenner = new String();
 	/**
 	*	After a calling the method parse()
 	*	this variable holds the double value of latitude
@@ -36,13 +21,16 @@
 	*	this variable holds the double value of longitude
 	*/
 	public double lon2;
-	
+
+	private char digSep;
+
 	/**
 	*	Constructor to parse a lat lon string like:
 	*	N 49 33.167 E 011 21.608
 	*/
 	public ParseLatLon (String ll){
 		latlon = ll;
+		digSep=Global.getPref().digSeparator.charAt(0);
 	}
 	
 	/**
@@ -51,141 +39,52 @@
 	*	Additionally you may pass the decimal symbol, i.e. "." or ","
 	*/
 	public ParseLatLon (String ll, String tr){
-		trenner = tr;
 		latlon = ll;
+		digSep=Global.getPref().digSeparator.charAt(0);
 	}
 	
+	private int start;
+	private int end;
+	
+	/** Get the next non-blank part of the latlon String */
+	String getNext() {
+        start=end;
+		while (latlon.charAt(start)==' ')start++; // skip blanks
+        end=start;
+        while (latlon.charAt(end)!=' ') end++; // collect non-blanks
+		return latlon.substring(start,end);
+	}
+	
 	/**
 	* Parse a string that contains lat lon into it's lat and lon doubles. Class
 	* variable latlon must have been set befor you call this method.
 	*/
 	public void parse() throws NumberFormatException {
-		latlon=STRreplace.replace(latlon, ",", ".");
-	
-		/* diese routine steht in map.java - gefaellt mir (pfeffer) irgendwie besser :-) - Aber vielleicht ist sie langsamer
-		Regex rex = new Regex("(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})");
+		if (digSep==',') 
+			latlon = latlon.replace('.', ',')+" ";
+		else
+			latlon = latlon.replace(',', '.')+" ";
 		try {
-			rex.search(latlon);
-			if(rex.didMatch()){
-				double lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
-				double lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-				if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = lat * -1;
-				if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = lon * -1;	
-			} else throw new NumberFormatException("Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM");
-		*/
-		try {
-		int counter = 0;
-		Extractor ex = new Extractor(" " + latlon, " ", " ", 0, true);
-		br2 = new String(); 
-		lg2 = new String();
-		br2_buf = new String(); 
-		lg2_buf = new String();
-		br3_buf = new String(); 
-		lg3_buf = new String();
-		br2NS = new String();
-		lg2WE = new String();
-		while(ex.endOfSearch() != true){
-			if(counter == 0) br2NS = ex.findNext();
-			if(counter == 1) br2 = ex.findNext();
-			if(counter == 2) br2_buf = ex.findNext();
-			if(counter == 3) lg2WE = ex.findNext();
-			if(counter == 4) lg2 = ex.findNext();
-			if(counter == 5) lg2_buf = ex.findNext();
-			counter++;
-			if(counter >= 10) break;
-		}
-		
-		
-		/*
-		//Vm.debug(lg2 + " / " +br2);
-		lg2_buf = lg2_buf.replace('.',',');
-		br2_buf = br2_buf.replace('.',',');
-		try{
-			lon2 = Convert.parseDouble(lg2) + Convert.parseDouble(lg2_buf)/60;
-			lat2 = Convert.parseDouble(br2) + Convert.parseDouble(br2_buf)/60;
-		}catch(NumberFormatException nfex){
-			lg2_buf = lg2_buf.replace(',','.');
-			br2_buf = br2_buf.replace(',','.');
-			try{
-				lon2 = Convert.parseDouble(lg2) + Convert.parseDouble(lg2_buf)/60;
-				lat2 = Convert.parseDouble(br2) + Convert.parseDouble(br2_buf)/60;
-			}catch(NumberFormatException nfex2){
-				//Vm.debug(nfex2.toString());
+			end=0;
+			String latNS=getNext();
+			String latDeg=getNext();
+			String latMin=getNext();
+			String lonEW=getNext();
+			String lonDeg=getNext();
+			String lonMin=getNext();
+			if (lonDeg.endsWith("?")){
+				lonDeg = lonDeg.substring(0,lonDeg.length()-1); // remove ?
 			}
+			if (latDeg.endsWith("?")){
+				latDeg = latDeg.substring(0,latDeg.length()-1);// remove ?
+			}
+			lat2 = Convert.parseDouble(latDeg) + Convert.parseDouble(latMin)/60.0;
+			if(latNS.charAt(0)=='S') lat2= -lat2 ;
+			lon2 = Convert.parseDouble(lonDeg) + Convert.parseDouble(lonMin)/60.0;
+			if(lonEW.charAt(0)=='W') lon2 = -lon2;
+		} catch (Exception e) { 
+			throw new NumberFormatException("Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"); 
 		}
-		*/
-		lg3_buf = lg2_buf.substring(lg2_buf.indexOf(".")+1); // copy from '.'
-		lg2_buf = lg2_buf.substring(0,lg2_buf.indexOf(".")); // copy until '.' // TODO handle IndexOutOfBoundsException
-		if (lg2.indexOf("?") > 0){
-			lg2 = lg2.substring(0,lg2.length()-1); // remove ?
-		}
-		
-		br3_buf = br2_buf.substring(br2_buf.indexOf(".")+1); // copy from '.'
-		br2_buf = br2_buf.substring(0,br2_buf.indexOf(".")); // copy until '.'
-		if (br2.indexOf("?")>0){
-			br2 = br2.substring(0,br2.length()-1);// remove ?
-		}
-		
-		lat2 = Convert.toDouble(br2) + Convert.toDouble(br2_buf)/60 + Convert.toDouble(br3_buf)/60000;
-		if(br2NS.trim().equals("S")) lat2 *= -1 ;
-		lon2 = Convert.toDouble(lg2) + Convert.toDouble(lg2_buf)/60 + Convert.toDouble(lg3_buf)/60000;
-		if(lg2WE.trim().equals("W")) lon2 *= -1;
-		} catch (IndexOutOfBoundsException e) { throw new NumberFormatException("Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"); }
 
 	}
-	
-	/**
-	* Returns a string representation of lat. Method parse() must be called
-	* before!
-	*/
-	public String getLatDeg(){
-		Double lat = new Double();
-		lat.set(lat2);
-		if(trenner.equals("."))	return lat.toString(0,5,Double.FREE_DECIMAL|Double.AT_LEAST_ONE_DECIMAL).replace(',','.');
-		else return lat.toString(0,5,Double.FREE_DECIMAL|Double.AT_LEAST_ONE_DECIMAL);
-	}
-	
-	/**
-	* Returns a string representation of lon. Method parse() must be called
-	* before!
-	*/ 
-	public String getLonDeg(){
-		Double lon = new Double();
-		lon.set(lon2);
-		if(trenner.equals(".")) return lon.toString(0,5,Double.FREE_DECIMAL|Double.AT_LEAST_ONE_DECIMAL).replace(',','.');
-		else return lon.toString(0,5,Double.FREE_DECIMAL|Double.AT_LEAST_ONE_DECIMAL);
-	}
-	
-	/**
-	*	Returns a string representation of deg in DD MM.mmm
-	*	Setting latorlon = 1 returns N|S
-	*	Setting latorlon = -1 returns E|W
-	*	Setting latorlon = 0 returns the sign of deg.
-	*/
-	public String DegToDM(double deg, int latorlon){
-		String retval = new String();
-		int D = 0;
-		double DM = 0;
-		int sign = 0;
-		
-		if(deg < 0) sign = -1;
-		else sign = 1;
-		if(deg < 0) deg = deg * -1;
-		D = (int)java.lang.Math.abs(deg);
-		DM = (deg - D) * 60;
-		
-		if(D<10) retval = "0" + D + " " + DM;
-		else retval = D + " " + DM;
-		
-		if(latorlon == 1 && sign > 0) retval = "N " + retval;
-		if(latorlon == 1 && sign < 0) retval = "S " + retval;
-		if(latorlon == -1 && sign > 0) retval = "W " + retval;
-		if(latorlon == -1 && sign < 0) retval = "E " + retval;
-		if(latorlon == 0 && sign > 0) retval = retval;
-		if(latorlon == 0 && sign < 0) retval = "-" + retval;
-		retval = retval.replace('.', trenner.charAt(0));
-		retval = retval.replace(',', trenner.charAt(0));
-		retval = retval.substring(0,10);
-		return retval;
-	}
 }



From mik77 at mail.berlios.de  Sat Jan 20 19:00:32 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 20 Jan 2007 19:00:32 +0100
Subject: [Cachewolf-svn] r412 - trunk
Message-ID: <200701201800.l0KI0WWK027810@sheep.berlios.de>

Author: mik77
Date: 2007-01-20 19:00:27 +0100 (Sat, 20 Jan 2007)
New Revision: 412

Modified:
   trunk/cwberlios.jnf
Log:
command line Parameter f?\195?\188r mehr Speicher
-> kein Out of memory error mehr in moving map

Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-01-20 17:22:06 UTC (rev 411)
+++ trunk/cwberlios.jnf	2007-01-20 18:00:27 UTC (rev 412)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ew!
 esoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%2!
 53Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26inst!
 all%3Dti
tle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=(Default)
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253De!
 xp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useR!
 esources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%2!
 53D/Xmx%
252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=(Default)



From mik77 at mail.berlios.de  Sat Jan 20 21:44:40 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 20 Jan 2007 21:44:40 +0100
Subject: [Cachewolf-svn] r413 - trunk/resources
Message-ID: <200701202044.l0KKieGX032018@sheep.berlios.de>

Author: mik77
Date: 2007-01-20 21:44:38 +0100 (Sat, 20 Jan 2007)
New Revision: 413

Modified:
   trunk/resources/snap2gps.gif
Log:
kleinere Anpassungen an snap2gps.gif

Modified: trunk/resources/snap2gps.gif
===================================================================
(Binary files differ)



From pfeffer at mail.berlios.de  Sat Jan 20 22:15:42 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 20 Jan 2007 22:15:42 +0100
Subject: [Cachewolf-svn] r414 - in trunk: resources src/CacheWolf
Message-ID: <200701202115.l0KLFglE002331@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-20 22:15:30 +0100 (Sat, 20 Jan 2007)
New Revision: 414

Added:
   trunk/resources/lupe_activated.png
Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Lupe wird gr?\195?\188n, wenn man drauf klickt
MovingMap: rechts-klick bzw. lange dr?\195?\188cken ?\195?\182ffnet Kontext menue (mit bisher 1 Eintrag: gehe zu)

Added: trunk/resources/lupe_activated.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/lupe_activated.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-20 20:44:38 UTC (rev 413)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-20 21:15:30 UTC (rev 414)
@@ -314,6 +314,10 @@
 		toPoint.set(dest);
 		if (!toPoint.isValid()) (new MessageBox("Error", "coordinates are out of range: \n"+"latitude: "+toPoint.latDec+"\n longditue: "+toPoint.lonDec, MessageBox.OKB)).execute();
 		btnGoto.setText(getGotoBtnText());
+		if (mmp != null) { 
+			mmp.setGotoPosition(dest.latDec, dest.lonDec);
+			mmp.repaintNow();
+		}
 		updateDistance();
 	}
 	
@@ -609,6 +613,7 @@
 			if (ev.target == btnSave){
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = gpsPosition.toString();
+				ch.pos = new CWPoint(gpsPosition);
 				detP.newWaypoint(ch,mainT, pref, profile);
 			}
 			// change destination waypoint

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-20 20:44:38 UTC (rev 413)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-20 21:15:30 UTC (rev 414)
@@ -18,7 +18,7 @@
 	final static int noGPSData = 2; // red
 	final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
 	final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
-	
+
 	public MapSymbol gotoPos = null;
 	public int GpsStatus;
 	Preferences pref;
@@ -32,7 +32,7 @@
 	Vector tracks;
 	MapInfoObject currentMap;
 	String mapPath;
-	
+
 	AniImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal = new AniImage("position_green.png");
@@ -42,6 +42,7 @@
 	AniImage bottonImageChooseMap = new AniImage("choose_map.gif"); 
 	AniImage buttonImageGpsOn = new AniImage("snap2gps.gif");
 	AniImage buttonImageLens = new AniImage("lupe.png");
+	AniImage buttonImageLensActivated = new AniImage("lupe_activated.png");
 	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
 	/*AniImage arrowUp = new AniImage("arrow_up.png");
 	AniImage arrowDown = new AniImage("arrow_down.png");
@@ -95,6 +96,8 @@
 		mmp.addImage(directionArrows);
 		buttonImageLens.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
 		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivated.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageLens);
 		buttonImageZoom1to1.setLocation(Global.getPref().myAppWidth - buttonImageZoom1to1.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
@@ -177,7 +180,7 @@
 
 	public void forceMapLoad() {
 		forceMapLoad = true;
-		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec);
+		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec); // this sets forceMapLoad to false after loading a map
 	}
 
 	public final FormFrame myExec() {
@@ -212,7 +215,7 @@
 		if (tracks == null) return; // no tracks
 		addMissingOverlays();
 	}
-	
+
 	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
 			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
@@ -235,7 +238,7 @@
 					TrackOverlays[i].move(0, 0);
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
-				//	mmp.addImage(TrackOverlays[i]);
+					//	mmp.addImage(TrackOverlays[i]);
 				}
 			}
 		}
@@ -374,705 +377,764 @@
 		}
 	}
 
-		public void updateOverlayPos() {
-			if (TrackOverlays == null || TrackOverlays[4] == null) return;
-			updateOverlayOnlyPos();
-			if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
-					TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
-				rearangeOverlays();
-				addMissingOverlays();
-				// updateOverlayOnlyPos(); is called from addMissingOverlays 
-			}
+	public void updateOverlayPos() {
+		if (TrackOverlays == null || TrackOverlays[4] == null) return;
+		updateOverlayOnlyPos();
+		if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
+				TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
+			rearangeOverlays();
+			addMissingOverlays();
+			// updateOverlayOnlyPos(); is called from addMissingOverlays 
 		}
+	}
 
-		private int getBestMap(double lat, double lon) { // finds the map which is next (center of the map) to the gps-position / could be a good idea to seachr only maps which show the current position (use InBound)
-			// maps, gotoPanel.gpsPosition.latDec != 0, gotoPanel.gpsPosition
-			MapInfoObject mi = new MapInfoObject();
-			MapInfoObject bestMap = new MapInfoObject();
-			double minDistLat = 1000000000000000000000000000000000000000000000.0;
-			double minDistLon = 1000000000000000000000000000000000000000000000.0;
-			boolean latNearer, lonNearer;
-			int minDistMap = -1;
-			boolean better = false;
-			for (int i=0; i<maps.size() ;i++) {
-				better = false;
-				mi=(MapInfoObject)maps.get(i);
-				latNearer=java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
-				lonNearer=java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
-				if ( latNearer && lonNearer) better = true;
-				if ( !better && (latNearer || lonNearer )) { 
-					if ( mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
-				}
-				if (better) {
-					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
-					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
-					minDistMap = i;
-					bestMap = mi;
-					// Vm.debug("better"+ i);
-				}
+	/**
+	 * find the best map for lat/lon in the list of maps
+	 * currently the best map is the one, whose center is nearest to
+	 * lat/lon
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	private int getBestMap(double lat, double lon) { // finds the map which is next (center of the map) to the gps-position / could be a good idea to seachr only maps which show the current position (use InBound)
+		// maps, gotoPanel.gpsPosition.latDec != 0, gotoPanel.gpsPosition
+		MapInfoObject mi = new MapInfoObject();
+		MapInfoObject bestMap = new MapInfoObject();
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		int minDistMap = -1;
+		boolean better = false;
+		for (int i=0; i<maps.size() ;i++) {
+			better = false;
+			mi=(MapInfoObject)maps.get(i);
+			latNearer=java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+			lonNearer=java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+			if ( latNearer && lonNearer) better = true;
+			if ( !better && (latNearer || lonNearer )) { 
+				if ( mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
 			}
-			//	tmp = secBestMap.center.getDistance(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.lonDec)/secBestMap.sizeKm; // quasi second return value 
-			return minDistMap ;
+			if (better) {
+				minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+				minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+				minDistMap = i;
+				bestMap = mi;
+				// Vm.debug("better"+ i);
+			}
 		}
+		//	tmp = secBestMap.center.getDistance(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.lonDec)/secBestMap.sizeKm; // quasi second return value 
+		return minDistMap ;
+	}
 
 
+	/**
+	 * move posCircle to the Center of the Screen
+	 *
+	 */
+	public void resetCenterOfMap() {
+		posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+		posCircleY = pref.myAppHeight/2;
+		posCircle.properties &= ~AniImage.IsInvisible;
+		posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
+	}
 
-		public void resetCenterOfMap() {
-			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-			posCircleY = pref.myAppHeight/2;
+	public void movePosCircleToLatLon(CWPoint p) {
+		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p);
+	}
+
+	public void setCenterOfScreen (CWPoint c) {
+		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c);
+	}
+
+	public void moveScreenXYtoLatLon(Point s, CWPoint c) {
+		Point mappos = getMapPositionOnScreen();
+		Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
+		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
+
+	}
+
+	public void mapMoved(int diffX, int diffY) {
+		int w = posCircle.getWidth();
+		int h = posCircle.getHeight();
+		int npx = posCircleX-w/2+diffX; 
+		int npy = posCircleY-h/2+diffY;
+		if (npx+w >= 0 && npx <= this.width && npy+h >= 0 && npy < this.height)	
+		{
 			posCircle.properties &= ~AniImage.IsInvisible;
-			posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
+			posCircle.move(npx, npy);
+		} else {
+			posCircle.properties |= AniImage.IsInvisible;
+			posCircle.move(0,0);
 		}
-		
-		public void setCenterOfScreen (CWPoint c) {
-			moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c);
-		}
-		
-		public void moveScreenXYtoLatLon(Point s, CWPoint c) {
-			Point mappos = getMapPositionOnScreen();
-			Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
-			if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
-			mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-			
-		}
-		
-		public void mapMoved(int diffX, int diffY) {
-			int w = posCircle.getWidth();
-			int h = posCircle.getHeight();
-			int npx = posCircleX-w/2+diffX; 
-			int npy = posCircleY-h/2+diffY;
-			if (npx+w >= 0 && npx <= this.width && npy+h >= 0 && npy < this.height)	
-				{
-				posCircle.properties &= ~AniImage.IsInvisible;
-				posCircle.move(npx, npy);
-				} else {
-					posCircle.properties |= AniImage.IsInvisible;
-					posCircle.move(0,0);
-				}
-			posCircleX = posCircleX+diffX;
-			posCircleY = posCircleY+diffY;
-			updateSymbolPositions();
-			updateOverlayPos();
-		}
+		posCircleX = posCircleX+diffX;
+		posCircleY = posCircleY+diffY;
+		updateSymbolPositions();
+		updateOverlayPos();
+	}
 
-		/**
-		 * get upper left corner of map on window
-		 * returns the same as mmp.mapImage.getLocation(mapPos);
-		 * but also works if mmp == null and is used to move the map to the correct point
-		 * @return
-		 */
-		public Point getMapPositionOnScreen() {
-			Point mapPos = new Point(); 
-			//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-			//else {
-			Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
-			mapPos.x = posCircleX - mapposint.x;
-			mapPos.y = posCircleY - mapposint.y;
-			//}
-			return mapPos;
-		}
+	/**
+	 * get upper left corner of map on window
+	 * this is called when the map needs to be moved / the position of the map is wanted
+	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos);
+	 * but also works if mmp == null and is used to move the map to the correct point
+	 * @return
+	 */
+	public Point getMapPositionOnScreen() {
+		Point mapPos = new Point(); 
+		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		//else {
+		Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
+		mapPos.x = posCircleX - mapposint.x;
+		mapPos.y = posCircleY - mapposint.y;
+		//}
+		return mapPos;
+	}
 
-		public Point getXYonScreen(double lat, double lon){
-			Point coords = currentMap.calcMapXY(lat, lon);
-			Point mapPos = getMapPositionOnScreen();
-			//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
-			return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
-		}
-		
-		public CWPoint ScreenXY2LatLon (int x, int y){
-			Point mapPos = getMapPositionOnScreen();
-			return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
-		}
-		
-		public void updateSymbolPositions() {
-			if (symbols == null) return;
-			Point pOnScreen;
-			MapSymbol symb;
-			Dimension ws = mmp.getSize(null);
-			int ww = ws.width;
-			int wh = ws.height;
-			int w, h;
-			for (int i=symbols.size()-1; i>=0; i--) {
-				symb = (MapSymbol)symbols.get(i);
-				pOnScreen = getXYonScreen(symb.lat, symb.lon);
-				w=symb.pic.getWidth();
-				h=symb.pic.getHeight();
-				if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
-				{
-					symb.pic.properties &= ~mImage.IsInvisible;
-					symb.pic.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
-				}
-				else 
-				{symb.pic.properties |= mImage.IsInvisible;
-				symb.pic.move(30, 30);
-				}
-				//symb.pic.move(ww+1, wh+1);
+	/**
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Point getXYonScreen(double lat, double lon){
+		Point coords = currentMap.calcMapXY(lat, lon);
+		Point mapPos = getMapPositionOnScreen();
+		//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
+		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
+	}
+
+	public CWPoint ScreenXY2LatLon (int x, int y){
+		Point mapPos = getMapPositionOnScreen();
+		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
+	}
+
+
+	public void updateSymbolPositions() {
+		if (symbols == null) return;
+		Point pOnScreen;
+		MapSymbol symb;
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
+		int w, h;
+		for (int i=symbols.size()-1; i>=0; i--) {
+			symb = (MapSymbol)symbols.get(i);
+			pOnScreen = getXYonScreen(symb.lat, symb.lon);
+			w=symb.pic.getWidth();
+			h=symb.pic.getHeight();
+			if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
+			{
+				symb.pic.properties &= ~mImage.IsInvisible;
+				symb.pic.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
 			}
+			else 
+			{symb.pic.properties |= mImage.IsInvisible;
+			symb.pic.move(30, 30);
+			}
+			//symb.pic.move(ww+1, wh+1);
 		}
+	}
 
-		public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
-			if (symbols==null) symbols=new Vector();
-			MapSymbol ms = new MapSymbol(name, filename, lat, lon);
-			ms.loadImage();
-			Point pOnScreen=getXYonScreen(lat, lon);
-			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
-			symbols.add(ms);
-			mmp.addImage(ms.pic);
-			return ms;
-		}
-		public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
-			if (symbols==null) symbols=new Vector();
-			MapSymbol ms = new MapSymbol(name, " ", lat, lon);
-			ms.pic = imSymb;
-			ms.pic.properties = AniImage.AlwaysOnTop;
-			Point pOnScreen=getXYonScreen(lat, lon);
-			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
-			symbols.add(ms);
-			mmp.addImage(ms.pic);
-		}
+	public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
+		ms.loadImage();
+		Point pOnScreen=getXYonScreen(lat, lon);
+		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms.pic);
+		return ms;
+	}
+	public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, " ", lat, lon);
+		ms.pic = imSymb;
+		ms.pic.properties = AniImage.AlwaysOnTop;
+		Point pOnScreen=getXYonScreen(lat, lon);
+		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms.pic);
+	}
 
-		public void setGotoPosition(double lat, double lon) {
-			removeGotoPosition();
-			gotoPos=addSymbol("goto", "goto_map.png", lat, lon);
-		}
-		
-		public void removeGotoPosition() {
-			removeMapSymbol("goto");
-		}
+	public void setGotoPosition(double lat, double lon) {
+		removeGotoPosition();
+		gotoPos=addSymbol("goto", "goto_map.png", lat, lon);
+	}
 
-		public CWPoint getGotoPos(){
-			if (gotoPos == null) return null;
-			return new CWPoint(gotoPos.lat, gotoPos.lon);
-		}
+	public void removeGotoPosition() {
+		removeMapSymbol("goto");
+	}
 
-		public void removeAllMapSymbolsButGoto(){
-			if (symbols == null) return;
-			symbols.removeAllElements();
-			if (gotoPos != null) symbols.add(gotoPos);
-/*			for (int i=symbols.size()-1; i>=0; i--) {
+	public CWPoint getGotoPos(){
+		if (gotoPos == null) return null;
+		return new CWPoint(gotoPos.lat, gotoPos.lon);
+	}
+
+	public void removeAllMapSymbolsButGoto(){
+		if (symbols == null) return;
+		symbols.removeAllElements();
+		if (gotoPos != null) symbols.add(gotoPos);
+		/*			for (int i=symbols.size()-1; i>=0; i--) {
 				if (((MapSymbol)symbols.get(i)).name != "goto") removeMapSymbol(i);
 			}
-	*/	}
+		 */	}
 
-		public void removeMapSymbol(String name) {
-			int symbNr = findMapSymbol(name);
-			if (symbNr != -1) removeMapSymbol(symbNr);
-		}
+	public void removeMapSymbol(String name) {
+		int symbNr = findMapSymbol(name);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
 
-		public void removeMapSymbol(int SymNr) {
-			mmp.removeImage(((MapSymbol)symbols.get(SymNr)).pic);
-			symbols.removeElementAt(SymNr);
-		}
+	public void removeMapSymbol(int SymNr) {
+		mmp.removeImage(((MapSymbol)symbols.get(SymNr)).pic);
+		symbols.removeElementAt(SymNr);
+	}
 
-		public int findMapSymbol(String name) {
-			if (symbols == null) return -1;
-			MapSymbol ms;
-			for (int i = 0; i < symbols.size(); i++) {
-				ms= (MapSymbol)symbols.get(i);
-				if (ms.name == name) return i;
-			}
-			return -1;
+	public int findMapSymbol(String name) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = 0; i < symbols.size(); i++) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.name == name) return i;
 		}
+		return -1;
+	}
 
-		/**
-		 * Move the map so that the posCircle is at lat/lon
-		 * 
-		 * @param lat && lon == -361 -> ignore lat/lon, set map position to upperleft corner of window 
-		 */
-		public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
-			Point mapPos = new Point(0,0);
-			Point oldMapPos = getMapPositionOnScreen();
-			if (lat != -361.0 || lon != -361.0) {
-				posCircleLat = lat;
-				posCircleLon = lon;
-				mapPos = getMapPositionOnScreen();
-			}
-			//Vm.debug("mapx = " + mapx);
-			//Vm.debug("mapy = " + mapy);
-			if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
-				if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
-				updateSymbolPositions();
-				if (updateOverlay && TrackOverlays != null) updateOverlayPos();
-				//}
-				mmp.repaintNow(); // TODO test if the "if" above can be used
-			}
-			//Vm.debug("update only position");			
+	/**
+	 * Move the map so that the posCircle is at lat/lon
+	 * 
+	 * @param lat && lon == -361 -> ignore lat/lon, set map position to upperleft corner of window 
+	 */
+	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
+
+		Point mapPos = new Point(0,0);
+		Point oldMapPos = getMapPositionOnScreen();
+		if (lat != -361.0 || lon != -361.0) {
+			posCircleLat = lat;
+			posCircleLon = lon;
+			mapPos = getMapPositionOnScreen();
 		}
-		/**
-		 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
-		 */
-		public void updatePosition(double lat, double lon){
-			if (!mapsloaded) loadMaps(mapPath, lat);
-			lastUpatePosition.latDec=lat;
-			lastUpatePosition.lonDec=lon;
-			if(!ignoreGps || forceMapLoad){
-				updateOnlyPosition(lat, lon, true);
-				if (autoSelectMap || forceMapLoad) {
-					Point mapPos = getMapPositionOnScreen();
-					if (forceMapLoad || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
-							|| 	mmp.mapImage == null )) 	{
-						//Vm.debug("Screen not completly covered by map");
-						if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > MyLocale.getScreenHeight()/10)) {
-							// more then 1/10 of screen moved since last time we tried to find a better map
-							lastCompareX = mapPos.x;
-							lastCompareY = mapPos.y;
-//							Vm.debug("look for a bettermap");
-							int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -> may be it would be better to call it with the coos of the center of the window?, nein, es k?nnte st?ren, wenn man manuell die Karte bewegt und er st?ndig ne neue l?d... bleibt erstmal so
-							MapInfoObject newmap ;
-							newmap = (MapInfoObject) maps.get(newMapN);
-							if (!(currentMap.mapName == newmap.mapName)) {
-								setMap(newmap, lat, lon);
-								Vm.debug("better map found");
-								// use new map
-							}
-							forceMapLoad = false;
+		//Vm.debug("mapx = " + mapx);
+		//Vm.debug("mapy = " + mapy);
+		if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
+			updateSymbolPositions();
+			if (updateOverlay && TrackOverlays != null) updateOverlayPos();
+			//}
+			mmp.repaintNow(); // TODO test if the "if" above can be used
+		}
+		//Vm.debug("update only position");			
+	}
+	/**
+	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 */
+	public void updatePosition(double lat, double lon){
+		if (!mapsloaded) loadMaps(mapPath, lat);
+		lastUpatePosition.latDec=lat;
+		lastUpatePosition.lonDec=lon;
+		if(!ignoreGps || forceMapLoad){
+			updateOnlyPosition(lat, lon, true);
+			if (autoSelectMap || forceMapLoad) {
+				Point mapPos = getMapPositionOnScreen();
+				if (forceMapLoad || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
+						|| 	mmp.mapImage == null )) 	{
+					//Vm.debug("Screen not completly covered by map");
+					if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > MyLocale.getScreenHeight()/10)) {
+						// more then 1/10 of screen moved since last time we tried to find a better map
+						lastCompareX = mapPos.x;
+						lastCompareY = mapPos.y;
+//						Vm.debug("look for a bettermap");
+						int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -> may be it would be better to call it with the coos of the center of the window?, nein, es k?nnte st?ren, wenn man manuell die Karte bewegt und er st?ndig ne neue l?d... bleibt erstmal so
+						MapInfoObject newmap ;
+						newmap = (MapInfoObject) maps.get(newMapN);
+						if (!(currentMap.mapName == newmap.mapName)) {
+							setMap(newmap, lat, lon);
+							Vm.debug("better map found");
+							// use new map
 						}
+						forceMapLoad = false;
 					}
 				}
 			}
 		}
+	}
 
-		public void setGpsStatus (int status) {
-			if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
-			GpsStatus = status;
-			ignoreGps = false;
-			switch (status) {
-			case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-			case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-			case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-			case noGPSData: { posCircle.change(statusImageNoGps); break; }
-			}
-			posCircle.refreshNow();
+	public void setGpsStatus (int status) {
+		if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		GpsStatus = status;
+		ignoreGps = false;
+		switch (status) {
+		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
+		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
+		case noGPSData: { posCircle.change(statusImageNoGps); break; }
 		}
+		posCircle.refreshNow();
+	}
 
-		public void SnapToGps() {
-			resetCenterOfMap();
-			ignoreGps = false;
-			ignoreGpsStatutsChanges = false;
+	public void SnapToGps() {
+		resetCenterOfMap();
+		ignoreGps = false;
+		ignoreGpsStatutsChanges = false;
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareY = Integer.MAX_VALUE;
+		autoSelectMap = true;
+		forceMapLoad = true;
+		showMap();
+//		updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
+	}
+
+	/** sets and displays the map
+	 * 
+	 * @param newmap
+	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
+	 * @param lon -361: don't adust to lat/lon
+	 */
+	public void setMap(MapInfoObject newmap, double lat, double lon) {
+		if (newmap.mapName == currentMap.mapName && !forceMapLoad) {
+			updateOnlyPosition(lat, lon, true); 
+			return;
+		}
+		Vm.showWait(true);
+		boolean saveIgnoreStatus;
+		saveIgnoreStatus = ignoreGps;
+		ignoreGps = true;  // make updatePosition ignore calls during loading new map
+		InfoBox inf;
+		inf = new InfoBox("Info", "Loading map...");
+		inf.show();
+		try {
+			this.currentMap = newmap; 
+			this.title = currentMap.mapName;
 			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 			lastCompareY = Integer.MAX_VALUE;
-			autoSelectMap = true;
-			forceMapLoad = true;
-			showMap();
-//			updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
-		}
+			if (! (mmp.mapImage == null) ) {
+				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 
-		/** sets and displays the map
-		 * 
-		 * @param newmap
-		 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
-		 * @param lon -361: don't adust to lat/lon
-		 */
-		public void setMap(MapInfoObject newmap, double lat, double lon) {
-			if (newmap.mapName == currentMap.mapName) {
-				updateOnlyPosition(lat, lon, true); 
-				return;
+				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+				Vm.getUsedMemory(true); // calls the garbage collection
+			} // give memory free before loading the new map to avoid out of memory error
+			if (currentMap.getImageFilename() == null ) {
+				mmp.mapImage = new AniImage();
+				(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
 			}
-			Vm.showWait(true);
-			boolean saveIgnoreStatus;
-			saveIgnoreStatus = ignoreGps;
-			ignoreGps = true;  // make updatePosition ignore calls during loading new map
-			InfoBox inf;
-			inf = new InfoBox("Info", "Loading map...");
-			inf.show();
-			try {
-				this.currentMap = newmap; 
-				this.title = currentMap.mapName;
-//				transXlat
+			else { 
+				if (currentMap.getImageFilename().length()>0) mmp.mapImage = new AniImage(currentMap.getImageFilename()); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new AniImage();
+			}
+			mapImage1to1 = mmp.mapImage;
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
+			if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
+			mmp.mapImage.move(0,0);
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			addOverlaySet();
+			forceMapLoad = true; // forces updateOnlyPosition to redraw
+			updateOnlyPosition(lat, lon, false);
+			forceMapLoad = false;
+			directionArrows.setMap(currentMap);
+			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
+			Vm.showWait(false);
+			ignoreGps = saveIgnoreStatus;
+		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Could not load map: "+ newmap.getImageFilename(), MessageBox.OKB)).execute();
+			ignoreGps = saveIgnoreStatus;
+		} catch (OutOfMemoryError e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Not enough memory to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+			ignoreGps = saveIgnoreStatus;
+		}catch (SystemResourceException e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+			ignoreGps = saveIgnoreStatus;
+		}
+	}
 
-				lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-				lastCompareY = Integer.MAX_VALUE;
-				if (! (mmp.mapImage == null) ) {
-					//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
-					mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+	public void hideMap() {
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.properties |= AniImage.IsInvisible;
+		mapHidden = true;
+		repaintNow();
+	}
 
-					//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
-					Vm.getUsedMemory(true); // calls the garbage collection
-				} // give memory free before loading the new map to avoid out of memory error
-				if (currentMap.getImageFilename() == null ) {
-					mmp.mapImage = new AniImage();
-					(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
-				}
-				else { 
-					if (currentMap.getImageFilename().length()>0) mmp.mapImage = new AniImage(currentMap.getImageFilename()); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
-					else mmp.mapImage = new AniImage();
-				}
-				mapImage1to1 = mmp.mapImage;
-				mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
-				if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
-				mmp.mapImage.move(0,0);
-				mmp.addImage(mmp.mapImage);
-				mmp.images.moveToBack(mmp.mapImage);
-				addOverlaySet();
-				forceMapLoad = true; // forces updateOnlyPosition to redraw
-				updateOnlyPosition(lat, lon, false);
-				forceMapLoad = false;
-				directionArrows.setMap(currentMap);
-				inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
-				Vm.showWait(false);
-				ignoreGps = saveIgnoreStatus;
-			} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
-				if (mmp.mapImage != null) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free();
-					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-				}
-				addOverlaySet();
-				updateOnlyPosition(lat, lon, false);
-				inf.close(0);
-				Vm.showWait(false);
-				(new MessageBox("Error", "Could not load map: "+ newmap.getImageFilename(), MessageBox.OKB)).execute();
-				ignoreGps = saveIgnoreStatus;
-			} catch (OutOfMemoryError e) {
-				if (mmp.mapImage != null) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free();
-					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-				}
-				addOverlaySet();
-				updateOnlyPosition(lat, lon, false);
-				inf.close(0);
-				Vm.showWait(false);
-				(new MessageBox("Error", "Not enough memory to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-				ignoreGps = saveIgnoreStatus;
-			}catch (SystemResourceException e) {
-				if (mmp.mapImage != null) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free();
-					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-				}
-				addOverlaySet();
-				updateOnlyPosition(lat, lon, false);
-				inf.close(0);
-				Vm.showWait(false);
-				(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-				ignoreGps = saveIgnoreStatus;
-			}
+	public void showMap() {
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.properties &= ~AniImage.IsInvisible;
+		mapHidden = false;
+		repaintNow();
+	}
+
+	public void setZoomingMode() {
+		mmp.removeImage(buttonImageLens);
+		mmp.addImage(buttonImageLensActivated);
+		repaintNow();
+		zoomingMode = true;
+	}
+
+	/**
+	 * zommes in if w>0 and out if w<0
+	 * @param firstclickpoint
+	 * @param w
+	 * @param h
+	 */
+	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
+		int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
+		int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
+		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		float zoomFactor;
+		if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
+		else {
+			w = java.lang.Math.abs(w);
+			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+			zoomFactor = (float)w / (float)this.width;
 		}
-		
-		public void hideMap() {
-			if (mmp != null && mmp.mapImage != null)
-				mmp.mapImage.properties |= AniImage.IsInvisible;
-			mapHidden = true;
-			repaintNow();
+		if (h < 0) {
+			h = java.lang.Math.abs(h);
+			firstclickpoint.y = firstclickpoint.y - h;
 		}
-		
-		public void showMap() {
-			if (mmp != null && mmp.mapImage != null)
-				mmp.mapImage.properties &= ~AniImage.IsInvisible;
-			mapHidden = false;
-			repaintNow();
+		// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
+		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
+		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
+		Point mappos = getMapPositionOnScreen();
+		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
+		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+		{
+			// try to avoid overlapping by shifting
+			if (newImageRect.x < 0) 
+				newImageRect.x = 0; // align left if left overlapping
+			if (newImageRect.y < 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+			// crop if after shifting still overlapping
+			if (newImageRect.x < 0) 
+				newImageRect.x = 0;
+			if (newImageRect.y < 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
 		}
-		
-		public void setZoomingMode() {
-			zoomingMode = true;
-		}
-		
-		/**
-		 * zommes in if w>0 and out if w<0
-		 * @param firstclickpoint
-		 * @param w
-		 * @param h
-		 */
-		public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-			int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
-			int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
-			CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
-			float zoomFactor;
-			if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
-			else {
-				w = java.lang.Math.abs(w);
-				firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
-				zoomFactor = (float)w / (float)this.width;
+		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+	}
+
+	public void zoom1to1() {
+		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+		zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+	}
+
+	/**
+	 * do the actual scaling
+	 * @param zoomFactor relative to original image
+	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * @param center
+	 */		
+	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+		Vm.showWait(true);
+		boolean savegpsstatus = ignoreGps;
+		if (mapImage1to1 != null) {
+			ignoreGps = true; // avoid multi-thread problems
+			int saveprop = AniImage.IsMoveable;
+			AniImage tmp = null; // = mmp.mapImage;
+			if (mmp.mapImage != null) {
+				saveprop = mmp.mapImage.properties;
+				mmp.removeImage(mmp.mapImage);
+				if (mmp.mapImage != mapImage1to1) {
+					mmp.mapImage .free();
+					mmp.mapImage = null;
+				} else tmp = mapImage1to1;
 			}
-			if (h < 0) {
-				h = java.lang.Math.abs(h);
-				firstclickpoint.y = firstclickpoint.y - h;
-			}
-			// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
-			newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
-			newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
-			Point mappos = getMapPositionOnScreen();
-			int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-			int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-			Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+			Vm.getUsedMemory(true);
+			try {
+				tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+			} catch (OutOfMemoryError e) {
+				(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();}
+			Vm.getUsedMemory(true);
+			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage.properties = saveprop;
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
 			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
 			{
-				// try to avoid overlapping by shifting
-				if (newImageRect.x < 0) 
-					newImageRect.x = 0; // align left if left overlapping
-				if (newImageRect.y < 0) 
-					newImageRect.y = 0;
-				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
-					newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
-				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
-					newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
-				// crop if after shifting still overlapping
-				if (newImageRect.x < 0) 
-					newImageRect.x = 0;
-				if (newImageRect.y < 0) 
-					newImageRect.y = 0;
-				if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
-					newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
-				if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
-					newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+				Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x,mappos.y);
 			}
-			zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+		} else // no map image loaded 
+		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+
+		destroyOverlaySet();
+		Vm.getUsedMemory(true); // call garbage collection
+		setCenterOfScreen(center);
+		addOverlaySet();
+		this.repaintNow();
+		Vm.showWait(false);
+		ignoreGps = savegpsstatus;
+	}
+
+
+	public void onEvent(Event ev){
+		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
+			gotoPanel.runMovingMap = false;
+		}  
+		if(ev instanceof KeyEvent && ev.target == this && ((KeyEvent)ev).key == IKeys.ESCAPE) {
+			this.close(0);
+			ev.consumed = true;
 		}
+		super.onEvent(ev);
+	}
+}
 
-		public void zoom1to1() {
-			CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-			zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		}
-		
 /**
- * do the actual scaling
- * @param zoomFactor relative to original image
- * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
- * @param center
- */		
-		public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
-			Vm.showWait(true);
-			boolean savegpsstatus = ignoreGps;
-			if (mapImage1to1 != null) {
-				ignoreGps = true; // avoid multi-thread problems
-				int saveprop = AniImage.IsMoveable;
-				AniImage tmp = null; // = mmp.mapImage;
-				if (mmp.mapImage != null) {
-					saveprop = mmp.mapImage.properties;
-					mmp.removeImage(mmp.mapImage);
-					if (mmp.mapImage != mapImage1to1) {
-						mmp.mapImage .free();
-						mmp.mapImage = null;
-					} else tmp = mapImage1to1;
-				}
-				Vm.getUsedMemory(true);
-				try {
-					tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
-					currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-				} catch (OutOfMemoryError e) {
-					(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();}
-				Vm.getUsedMemory(true);
-				mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
-				mmp.mapImage.properties = saveprop;
-				mmp.addImage(mmp.mapImage);
-				mmp.images.moveToBack(mmp.mapImage);
-				if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-				{
-					Point mappos = getMapPositionOnScreen();
-					mmp.mapImage.move(mappos.x,mappos.y);
-				}
-			} else // no map image loaded 
-				{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+ *	Class to display the map bitmap and to select another bitmap to display.
+ */
+class MovingMapPanel extends InteractivePanel implements EventListener {
+	Menu mapsMenu;
+	Menu kontextMenu;
+	MenuItem gotoMenuItem;
+	MovingMap mm;
+	AniImage mapImage;
+	Point saveMapLoc = null;
+	boolean saveGpsIgnoreStatus;
+	boolean paintingZoomArea;
+	ImageList saveImageList = null;
+	int lastZoomWidth , lastZoomHeight;
+	public MovingMapPanel(MovingMap f){
+		this.mm = f;
+		set(Control.WantHoldDown, true); // want to get simulated right-clicks
+		gotoMenuItem = new MenuItem("Goto here", 0, null);
 
-			destroyOverlaySet();
-			Vm.getUsedMemory(true);
-			setCenterOfScreen(center);
-			addOverlaySet();
-			this.repaintNow();
-			Vm.showWait(false);
-			ignoreGps = savegpsstatus;
-		}
+	}
 
-
-		public void onEvent(Event ev){
-			if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
-				gotoPanel.runMovingMap = false;
-			}
-			super.onEvent(ev);
+	public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (mm.zoomingMode == true) {
+			saveMapLoc = pos;
+			mm.ignoreGps = true;
+			return false;
 		}
+		if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
+		saveGpsIgnoreStatus = mm.ignoreGps; 
+		mm.ignoreGps = true;
+		saveMapLoc = pos;
+		bringMapToTop();
+		return super.imageBeginDragged(mapImage, pos);
 	}
 
-	/**
-	 *	Class to display the map bitmap and to select another bitmap to display.
-	 */
-	class MovingMapPanel extends InteractivePanel implements EventListener {
-		Menu mapsMenu;
-		MovingMap mm;
-		AniImage mapImage;
-		Point saveMapLoc = null;
-		boolean saveGpsIgnoreStatus;
-		boolean paintingZoomArea;
-		ImageList saveImageList = null;
-		int lastZoomWidth , lastZoomHeight;
-		public MovingMapPanel(MovingMap f){
-			this.mm = f;
+	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+		boolean ret = super.imageNotDragged(dc, pos);
+		mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		mm.ignoreGps = saveGpsIgnoreStatus;
+		bringMaptoBack();
+		this.repaintNow();
+		return ret;
+	}
+
+	public void onPenEvent(PenEvent ev) {
+		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
 		}
-		public boolean imageBeginDragged(AniImage which,Point pos) {
-			if (mm.zoomingMode == true) {
-				saveMapLoc = pos;
-				mm.ignoreGps = true;
-				return false;
-			}
-			if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
-			saveGpsIgnoreStatus = mm.ignoreGps; 
-			mm.ignoreGps = true;
-			saveMapLoc = pos;
-			bringMapToTop();
-			return super.imageBeginDragged(mapImage, pos);
+		if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
+			paintingZoomArea = true;
+			mm.zoomingMode = true;
 		}
-		
-		public boolean imageNotDragged(ImageDragContext dc,Point pos){
-			boolean ret = super.imageNotDragged(dc, pos);
-			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-			mm.ignoreGps = saveGpsIgnoreStatus;
-			bringMaptoBack();
-			this.repaintNow();
-			return ret;
+		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN && ev.modifiers == PenEvent.RIGHT_BUTTON) {
+			penHeld(new Point (ev.x, ev.y));
 		}
-		
-		public void onPenEvent(PenEvent ev) {
-			if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
-				saveMapLoc = new Point (ev.x, ev.y);
-				paintingZoomArea = true;
-				mm.zoomingMode = true;
+		if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
+			paintingZoomArea = false;
+			mm.zoomingMode = false;
+			removeImage(mm.buttonImageLensActivated);
+			addImage(mm.buttonImageLens);
+			if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
+				repaintNow();
+				return; // dont make to big zoom jumps - it is most probable not an intentional zoom
 			}
-			if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
-				paintingZoomArea = false;
-				mm.zoomingMode = false;
-				if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
-					repaintNow();
-					return; // dont make to big zoom jumps - it is most probable not an intentional zoom
-				}
-				mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
-			}
-			
-			if (mm.zoomingMode && paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
-				int left, top;
-				Graphics dr = this.getGraphics();
-				if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
-				else left = saveMapLoc.x;
-				if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-				else top = saveMapLoc.y;
-				this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)));
-				dr.setColor(Color.LightGreen);
-				lastZoomWidth = ev.x - saveMapLoc.x;
-				lastZoomHeight =  ev.y - saveMapLoc.y;
-				if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
-				else left = saveMapLoc.x;
-				if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-				else top = saveMapLoc.y;
-				dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth) , java.lang.Math.abs(lastZoomHeight), 2);
-			}
-			super.onPenEvent(ev);
+			mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 		}
-		
-		private void bringMapToTop() {
-			if (mapImage == null || (mapImage.properties & AniImage.IsInvisible) > 0 ) return;
-			saveImageList = new ImageList();
-			saveImageList.copyFrom(images);
-			images.removeAllElements();
-			//images.remove(mapImage);
-			//mapImage.properties |= AniImage.AlwaysOnTop;
-			images.add(mapImage);
+
+		if (mm.zoomingMode && paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+			int left, top;
+			Graphics dr = this.getGraphics();
+			if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)));
+			dr.setColor(Color.LightGreen);
+			lastZoomWidth = ev.x - saveMapLoc.x;
+			lastZoomHeight =  ev.y - saveMapLoc.y;
+			if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth) , java.lang.Math.abs(lastZoomHeight), 2);
 		}
-		private void bringMaptoBack() {
-			//mapImage.properties &= ~AniImage.AlwaysOnTop;
-			//images.moveToBack(mapImage);
-			if (saveImageList == null) return;
-			images=saveImageList;
-			saveImageList = null;
+		super.onPenEvent(ev);
+	}
+
+	private void bringMapToTop() {
+		if (mapImage == null || (mapImage.properties & AniImage.IsInvisible) > 0 ) return;
+		saveImageList = new ImageList();
+		saveImageList.copyFrom(images);
+		images.removeAllElements();
+		//images.remove(mapImage);
+		//mapImage.properties |= AniImage.AlwaysOnTop;
+		images.add(mapImage);
+	}
+	private void bringMaptoBack() {
+		//mapImage.properties &= ~AniImage.AlwaysOnTop;
+		//images.moveToBack(mapImage);
+		if (saveImageList == null) return;
+		images=saveImageList;
+		saveImageList = null;
+	}
+
+	public void moveMap(int diffX, int diffY) {
+		Point p = new Point();
+		if (mapImage!= null) {
+			p = mapImage.getLocation(null);
+			mapImage.move(p.x+diffX,p.y+diffY);
 		}
-		
-		public void moveMap(int diffX, int diffY) {
-			Point p = new Point();
-			if (mapImage!= null) {
-				p = mapImage.getLocation(null);
-				mapImage.move(p.x+diffX,p.y+diffY);
-			}
-			mapMoved(diffX, diffY);
-		}
+		mapMoved(diffX, diffY);
+	}
 
-		public void mapMoved(int diffX, int diffY){
-			mm.mapMoved(diffX, diffY);
-			this.repaintNow();
-		}
-		
-		public void doPaint(Graphics g,Rect area) {
-			super.doPaint(g, area);
-			if (mm.gotoPos != null) {
+	public void mapMoved(int diffX, int diffY){
+		mm.mapMoved(diffX, diffY);
+		this.repaintNow();
+	}
+
+	public void doPaint(Graphics g,Rect area) {
+		super.doPaint(g, area);
+		if (mm.gotoPos != null) {
 			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
 			g.setPen(new Pen(Color.MediumBlue, Pen.SOLID, 3));
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
+		}
+	}
+
+	public void chooseMap() {
+		CWPoint gpspos;
+		if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
+		else gpspos = null;
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
+		if(l.execute() == FormBase.IDOK){
+//			Vm.debug("Trying map: " + l.selectedMap.fileName);
+			mm.autoSelectMap = false;
+			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
+				mm.ignoreGpsStatutsChanges = false;
+			} else {
+				mm.ignoreGpsStatutsChanges = false;
+				mm.setGpsStatus(MovingMap.noGPS);
+				mm.ignoreGpsStatutsChanges = true;
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
+				mm.setCenterOfScreen(l.selectedMap.center);
+				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+				//mm.posCircleX = 0; // place map to the upper left corner of windows
+				//mm.posCircleY = 0;
+				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
 			}
 		}
-		
-		public void chooseMap() {
-			CWPoint gpspos;
-			if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
-			else gpspos = null;
-			ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
-			if(l.execute() == FormBase.IDOK){
-//				Vm.debug("Trying map: " + l.selectedMap.fileName);
-				mm.autoSelectMap = false;
-				if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
-					mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
-					mm.ignoreGpsStatutsChanges = false;
-				} else {
-					mm.ignoreGpsStatutsChanges = false;
-					mm.setGpsStatus(MovingMap.noGPS);
-					mm.ignoreGpsStatutsChanges = true;
-					mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
-					mm.setCenterOfScreen(l.selectedMap.center);
-//					Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-					//			double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
-					mm.posCircleX = 0; // place map to the upper left corner of windows
-					mm.posCircleY = 0;
-					mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
-				}
+	}
+
+	/**
+	 *	Method to react to user.
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		if (which == mm.bottonImageChooseMap){
+			mapsMenu = new Menu(new String[]{"Select a map manually$s", "Change map directory$c"}, "map choice");
+			if (!mm.noMapsAvailable) 
+			{
+				if (mm.mapHidden) mapsMenu.addItem("show map");
+				else mapsMenu.addItem("hide map");
 			}
+			//m.set(Menu., status)
+			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
 		}
+		if (which == mm.buttonImageGpsOn) {
+			if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
+				mm.gotoPanel.startGps();
+				mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
+			} 
+			mm.SnapToGps();
+		}
+		if (which == mm.buttonImageLens) {
+			mm.setZoomingMode();
+		}
+		if (which == mm.buttonImageZoom1to1) {
+			mm.zoom1to1();
+		}
+		if (which == mm.bottonImageClose) {
+			WindowEvent tmp = new WindowEvent();
+			tmp.type = WindowEvent.CLOSE;
+			mm.postEvent(tmp);
+		}
 
-		/**
-		 *	Method to react to user.
-		 */
-		public void imageClicked(AniImage which, Point pos){
-			if (which == mm.bottonImageChooseMap){
-				mapsMenu = new Menu(new String[]{"Select a map manually$s", "Change map directory$c"}, "map choice");
-				if (!mm.noMapsAvailable) 
-				{
-					if (mm.mapHidden) mapsMenu.addItem("show map");
-					else mapsMenu.addItem("hide map");
-				}
-				//m.set(Menu., status)
-				mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
-			}
-			if (which == mm.buttonImageGpsOn) {
-				if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
-					mm.gotoPanel.startGps();
-					mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
-				} 
-				mm.SnapToGps();
-			}
-			if (which == mm.buttonImageLens) {
-				mm.setZoomingMode();
-			}
-			if (which == mm.buttonImageZoom1to1) {
-				mm.zoom1to1();
-			}
-			if (which == mm.bottonImageClose) {
-				WindowEvent tmp = new WindowEvent();
-				tmp.type = WindowEvent.CLOSE;
-				mm.postEvent(tmp);
-			}
-				
-			/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
+		/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}
 		if (which == mm.arrowDown)	{	moveMap(0,-10);	}
 		if (which == mm.arrowUp)	{	moveMap(0,+10);	} */
+	}
+
+	public void penHeld(Point p){
+		//	if (!menuIsActive()) doMenu(p);
+		if (!mm.zoomingMode) // && ev instanceof PenEvent && (
+			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
+		{ //|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )){
+			kontextMenu = new Menu();
+			kontextMenu.addItem(gotoMenuItem);
+			kontextMenu.exec(this, new Point(p.x, p.y), this);
 		}
-		public void onEvent(Event ev){
-			if (mapsMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) mapsMenu.close();
-			if (ev instanceof ControlEvent ) { 
-				if (ev.target == mapsMenu && ev.type == MenuEvent.SELECTED ) {
-					if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close();
+	}
+
+	public void onEvent(Event ev){
+		if (mapsMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {mapsMenu.close(); mapsMenu = null;}
+		if (kontextMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {kontextMenu.close(); kontextMenu = null; }
+
+		if (ev instanceof MenuEvent) { 
+			if (ev.target == mapsMenu) {
+				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
+				if (ev.type == MenuEvent.SELECTED ) {
 					if (mapsMenu.getSelectedItem() != null) {
-						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Select a map manually") )
+						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Select a map manually") )
 						{ 
 							mapsMenu.close();
 							chooseMap();
 						}
-						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Change map directory") )
+						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Change map directory") )
 						{
 							mapsMenu.close();
 							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+"/maps");
@@ -1085,7 +1147,7 @@
 							}
 						}
 						//dont show map
-						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("hide map") )
+						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase("hide map") )
 						{
 							mapsMenu.close();
 							mm.hideMap();
@@ -1096,256 +1158,264 @@
 							mapsMenu.close();
 							mm.showMap();
 						}
-
 					}
 				}
-			}
-			super.onEvent(ev);
-		}
+			} // if (ev.target == mapsMenu)
+			if (ev.target == kontextMenu) {
+				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+					if (kontextMenu.getSelectedItem() == gotoMenuItem) {
+						kontextMenu.close();
+						mm.gotoPanel.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+					}
+				}
+			} // if (ev.target == kontextMenu)
+		} // if (ev instanceof ControlEvent ) 
+		super.onEvent(ev);
 	}
+}
 
 
-	/**
-	 *	Class to display maps to choose from
-	 */
-	class ListBox extends Form{
-		public MapInfoObject selectedMap = new MapInfoObject();
-		mButton cancelButton, okButton;
-		mList list = new mList(4,1,false);
-		public boolean selected = false;
-		Vector maps;
+/**
+ *	Class to display maps to choose from
+ */
+class ListBox extends Form{
+	public MapInfoObject selectedMap = new MapInfoObject();
+	mButton cancelButton, okButton;
+	mList list = new mList(4,1,false);
+	public boolean selected = false;
+	Vector maps;
 
-		public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos){
-			this.title = "Maps";
-			// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
-			this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
-			this.maps = maps;
-			MapInfoObject map;
-			ScrollBarPanel scb;
-			boolean[] inList = new boolean[maps.size()];
-			if (gotopos != null && Gps != null) {
-				list.addItem("--- Karten von akt. Position und Ziel ---");
-				for(int i = 0; i<maps.size();i++){
-					map = new MapInfoObject();
-					map = (MapInfoObject)maps.get(i);
-					if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
-					{
-						list.addItem(i + ": " + map.mapName);
-						inList[i] = true;
-					} else inList[i] = false;
-				}
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos){
+		this.title = "Maps";
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+		this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
+		this.maps = maps;
+		MapInfoObject map;
+		ScrollBarPanel scb;
+		boolean[] inList = new boolean[maps.size()];
+		if (gotopos != null && Gps != null) {
+			list.addItem("--- Karten von akt. Position und Ziel ---");
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
+				{
+					list.addItem(i + ": " + map.mapName);
+					inList[i] = true;
+				} else inList[i] = false;
 			}
-			if (Gps != null) {
-				list.addItem("--- Karten der aktuellen Position ---");
-				for(int i = 0; i<maps.size();i++){
-					map = new MapInfoObject();
-					map = (MapInfoObject)maps.get(i);
-					if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
-					{
-						list.addItem(i + ": " + map.mapName);
-						inList[i] = true;
-					}
+		}
+		if (Gps != null) {
+			list.addItem("--- Karten der aktuellen Position ---");
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
+				{
+					list.addItem(i + ": " + map.mapName);
+					inList[i] = true;
 				}
 			}
-			if (gotopos != null) {
-				list.addItem("--- Karten des Ziels ---");
-				for(int i = 0; i<maps.size();i++){
-					map = new MapInfoObject();
-					map = (MapInfoObject)maps.get(i);
-					if(map.inBound(gotopos)) {
-						list.addItem(i + ": " + map.mapName);
-						inList[i] = true;
-					}
-				}
-			}
-			list.addItem("--- andere Karten ---");
+		}
+		if (gotopos != null) {
+			list.addItem("--- Karten des Ziels ---");
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if(!inList[i]) list.addItem(i + ": " + map.mapName);
+				if(map.inBound(gotopos)) {
+					list.addItem(i + ": " + map.mapName);
+					inList[i] = true;
+				}
 			}
-
-			this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
-			cancelButton = new mButton("Cancel");
-			cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-			this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
-			okButton = new mButton("Select");
-			okButton.setHotKey(0, KeyEvent.getActionKey(true));
-			this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
 		}
-		private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
-			String testitem = new String();
-			int testitemnr;
-			for (int i=0; i<list.countListItems(); i++) {
-				try { 
-					testitem = ((MenuItem)list.items.get(i)).label;
-					testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
-					if ( testitemnr == mapNr) return true;
-				} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain ":"
-				catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain ":"
-			}
-			return false;
+		list.addItem("--- andere Karten ---");
+		for(int i = 0; i<maps.size();i++){
+			map = new MapInfoObject();
+			map = (MapInfoObject)maps.get(i);
+			if(!inList[i]) list.addItem(i + ": " + map.mapName);
 		}
 
+		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		cancelButton = new mButton("Cancel");
+		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
+		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton = new mButton("Select");
+		okButton.setHotKey(0, KeyEvent.getActionKey(true));
+		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+	}
+	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
+		String testitem = new String();
+		int testitemnr;
+		for (int i=0; i<list.countListItems(); i++) {
+			try { 
+				testitem = ((MenuItem)list.items.get(i)).label;
+				testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
+				if ( testitemnr == mapNr) return true;
+			} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain ":"
+			catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain ":"
+		}
+		return false;
+	}
 
-		public int myExecute() {
-			if (this.maps.size()==1) {
-				//this.selectedMap = 1;
-				this.selectedMap = (MapInfoObject) maps.get(0);
-				return FormBase.IDOK;
-			}
-			return execute();
+
+	public int myExecute() {
+		if (this.maps.size()==1) {
+			//this.selectedMap = 1;
+			this.selectedMap = (MapInfoObject) maps.get(0);
+			return FormBase.IDOK;
 		}
+		return execute();
+	}
 
 
-		public void onEvent(Event ev){
-			if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-				if (ev.target == cancelButton){
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelButton){
+				selectedMap = null;
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+			if (ev.target == okButton){
+				try {
 					selectedMap = null;
-					selected = false;
-					this.close(FormBase.IDCANCEL);
-				}
-				if (ev.target == okButton){
-					try {
-						selectedMap = null;
-						int mapNum = 0;
-						String it = new String();
-						it = list.getText();
-						if (it != ""){
-							it = it.substring(0,it.indexOf(':'));
-							mapNum = Convert.toInt(it);
-							//	Vm.debug("Kartennummer: " + mapNum);
-							selectedMap = (MapInfoObject)maps.get(mapNum);
-							selected = true;
-							this.close(FormBase.IDOK);
-						}
-						else {
-							selected = false;
-							this.close(FormBase.IDCANCEL);
-						}
-					}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
-				}
+					int mapNum = 0;
+					String it = new String();
+					it = list.getText();
+					if (it != ""){
+						it = it.substring(0,it.indexOf(':'));
+						mapNum = Convert.toInt(it);
+						//	Vm.debug("Kartennummer: " + mapNum);
+						selectedMap = (MapInfoObject)maps.get(mapNum);
+						selected = true;
+						this.close(FormBase.IDOK);
+					}
+					else {
+						selected = false;
+						this.close(FormBase.IDCANCEL);
+					}
+				}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
 			}
-			super.onEvent(ev);
 		}
+		super.onEvent(ev);
 	}
+}
 
-	class MapSymbol {
-		String name;
-		String filename;
-		double lat, lon;
-		AniImage pic;
-		public MapSymbol(String namei, String filenamei, double lati, double loni) {
-			name = namei;
-			filename = filenamei;
-			lat = lati;
-			lon = loni;
-		}
-		public void loadImage(){
-			pic = new AniImage(filename);
-			pic.properties = AniImage.AlwaysOnTop;
-		}
+class MapSymbol {
+	String name;
+	String filename;
+	double lat, lon;
+	AniImage pic;
+	public MapSymbol(String namei, String filenamei, double lati, double loni) {
+		name = namei;
+		filename = filenamei;
+		lat = lati;
+		lon = loni;
 	}
+	public void loadImage(){
+		pic = new AniImage(filename);
+		pic.properties = AniImage.AlwaysOnTop;
+	}
+}
 
-	class ArrowsOnMap extends AniImage {
-		float gotoDir = -361;
-		float sunDir = -361;
-		float moveDir = -361;
-		
-		int minY;
-		Graphics draw;
-		private MapInfoObject map=null;
-		public boolean dirsChanged = true;
-		
-		final static Color RED = new Color(255,0,0);
-		final static Color YELLOW = new Color(255,255,0);
-		final static Color GREEN = new Color(0,255,0);
-		final static Color BLUE = new Color(0,255,255);
-		/**
-		 * @param gd goto direction
-		 * @param sd sun direction
-		 * @param md moving direction
-		 */
-		public ArrowsOnMap(){
-			super();
-			newImage();
+class ArrowsOnMap extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+
+	int minY;
+	Graphics draw;
+	private MapInfoObject map=null;
+	public boolean dirsChanged = true;
+
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,255,255);
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public ArrowsOnMap(){
+		super();
+		newImage();
 		//	setDirections(90, 180, -90);
-		}
-		
-		public void newImage() {
-			setImage(new Image(80,80), Color.White);
-			draw = new Graphics(image);
-		}
-		public void setMap(MapInfoObject m) {
-			map = m;
-		}
+	}
 
-		public void setDirections(float gd, float sd, float md ) {
-			if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
-					|| java.lang.Math.abs(sunDir - sd) > 1
-					|| java.lang.Math.abs(moveDir - md) > 1)
-			{
-				dirsChanged = true;
-				gotoDir = gd;
-				sunDir = sd;
-				moveDir = md;
-				refresh();
-			}
+	public void newImage() {
+		setImage(new Image(80,80), Color.White);
+		draw = new Graphics(image);
+	}
+	public void setMap(MapInfoObject m) {
+		map = m;
+	}
+
+	public void setDirections(float gd, float sd, float md ) {
+		if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) > 1
+				|| java.lang.Math.abs(moveDir - md) > 1)
+		{
+			dirsChanged = true;
+			gotoDir = gd;
+			sunDir = sd;
+			moveDir = md;
+			refresh();
 		}
+	}
 
-		/**
-		 * draw arrows for the directions of movement and destination waypoint
-		 * @param ctrl the control to paint on
-		 * @param moveDir degrees of movement
-		 * @param destDir degrees of destination waypoint
-		 */
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
 
-		public void doDraw(Graphics g,int options) {
-			if (map == null) return;
-			if (!dirsChanged) {
-				g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-				return;
-			}
-			dirsChanged = false;
-			//super.doDraw(g, options);
-			draw.setColor(Color.White);
-			draw.fillRect(0, 0, location.width, location.height);
-			minY = Integer.MAX_VALUE;
-			drawArrows(draw);
-			draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+	public void doDraw(Graphics g,int options) {
+		if (map == null) return;
+		if (!dirsChanged) {
 			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+			return;
 		}
+		dirsChanged = false;
+		//super.doDraw(g, options);
+		draw.setColor(Color.White);
+		draw.fillRect(0, 0, location.width, location.height);
+		minY = Integer.MAX_VALUE;
+		drawArrows(draw);
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+	}
 
-		private void drawArrows(Graphics g){
-			
-			if (g != null) {
-				// draw only valid arrows
-				if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, RED);
-				if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, BLUE);
-				if (sunDir < 360 && sunDir> -360) drawArrow(g, sunDir, YELLOW);
-				drawArrow(g, 0, Color.DarkBlue); // north direction
-			}
+	private void drawArrows(Graphics g){
+
+		if (g != null) {
+			// draw only valid arrows
+			if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, RED);
+			if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, BLUE);
+			if (sunDir < 360 && sunDir> -360) drawArrow(g, sunDir, YELLOW);
+			drawArrow(g, 0, Color.DarkBlue); // north direction
 		}
+	}
 
-		/**
-		 * draw single arrow 
-		 * @param g handle for drawing
-		 * @param angle angle of arrow
-		 * @param col color of arrow
-		 */
-		private void drawArrow(Graphics g, float angle, Color col) {
-			float angleRad;
-			int x, y, centerX = location.width/2, centerY = location.height/2;
+	/**
+	 * draw single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void drawArrow(Graphics g, float angle, Color col) {
+		float angleRad;
+		int x, y, centerX = location.width/2, centerY = location.height/2;
 
-			angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
-			x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
-			y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
+		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
+		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
 		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
 		//	g.drawLine(centerX,centerY,x,y);
-			g.setPen(new Pen(col,Pen.SOLID,3));
-			g.drawLine(centerX,centerY,x,y);
-			if (y < minY) minY = y;
-			if (centerY < minY) minY = centerY;
-		}
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(centerX,centerY,x,y);
+		if (y < minY) minY = y;
+		if (centerY < minY) minY = centerY;
 	}
+}
 



From bilbowolf at mail.berlios.de  Sat Jan 20 22:24:51 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 20 Jan 2007 22:24:51 +0100
Subject: [Cachewolf-svn] r415 - in trunk: resources src/CacheWolf
Message-ID: <200701202124.l0KLOpX1003085@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-20 22:24:43 +0100 (Sat, 20 Jan 2007)
New Revision: 415

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/Profile.java
Log:
Filter auf positiv umgestellt und wird je profil gespeichert

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-20 21:15:30 UTC (rev 414)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-20 21:24:43 UTC (rev 415)
@@ -142,6 +142,7 @@
 		710=Archiviert
 		711=Nicht suchbar
 		712=Route Datei waehlen
+		713=Speicher Filter
 		800=Erstelle Liste
 		801=suche...
 		802=Caches identifiziert. Suche weiter...

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-20 21:15:30 UTC (rev 414)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-20 21:24:43 UTC (rev 415)
@@ -267,6 +267,9 @@
 	*	Method to react to a user input.
 	*/
 	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.FOCUS_OUT){
+			dirty_status = true;
+		}
 		/**
 		*	User changed status.
 		*/
@@ -276,17 +279,11 @@
 		*	Also possible: the user created a custom waypoint.
 		*/
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			
 			if(ev.target == btNotes){
 				NotesScreen nsc = new NotesScreen(thisCache, profile);
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
-			if (ev.target == btnDelete){
-				//Vm.debug(thisCache.CacheName);
-//TODO This does not work. e.g. if we do a sort we get an indexOutOfBounds exception
-// therefore temporarily disabled.  skg 20061226
-				//cacheDB.remove(thisCache);  
-				//dirty_newOrDelete = true;
-			}
 			if(ev.target == showMap){
 				try {
 					MapDetailForm mdf = new MapDetailForm(thisCache.wayPoint, pref, profile);

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-01-20 21:15:30 UTC (rev 414)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-01-20 21:24:43 UTC (rev 415)
@@ -213,7 +213,6 @@
 								(letterChk.getState() == true ? "1" : "0") +
 								(eventChk.getState() == true ? "1" : "0")+ 
 								(webcamChk.getState() == true ? "1" : "0")+
-								(multiChk.getState() == true ? "1" : "0") +
 								(mysteryChk.getState() == true ? "1" : "0")+
 								(earthChk.getState() == true ? "1" : "0")+
 								(loclessChk.getState() == true ? "1" : "0")+
@@ -238,8 +237,31 @@
 				if(NNW.getState()) roseMatchPattern |= Filter.NNW;
 				if(S.getState()) roseMatchPattern |= Filter.S;
 				flt.roseMatchPattern = roseMatchPattern;
-				filterRose = "";
-				
+				filterRose = (N.getState() == true ? "1":"0")+
+							 (NNE.getState() == true ? "1":"0")+
+							 (NE.getState() == true ? "1":"0")+
+							 (ENE.getState() == true ? "1":"0")+
+							 (E.getState() == true ? "1":"0")+
+							 (ESE.getState() == true ? "1":"0")+
+							 (SE.getState() == true ? "1":"0")+
+							 (SSE.getState() == true ? "1":"0")+
+							 (SSW.getState() == true ? "1":"0")+
+							 (SW.getState() == true ? "1":"0")+
+							 (WSW.getState() == true ? "1":"0")+
+							 (W.getState() == true ? "1":"0")+
+							 (WNW.getState() == true ? "1":"0")+
+							 (NW.getState() == true ? "1":"0")+
+							 (NNW.getState() == true ? "1":"0")+
+							 (S.getState() == true ? "1":"0");
+				Vm.showWait(true);
+				InfoBox infB = new InfoBox("Info",MyLocale.getMsg(713,"Saving filter"));
+				infB.exec();
+				Profile pfl = Global.getProfile();
+				pfl.filterRose = filterRose;
+				pfl.filterType = filterType;
+				pfl.saveIndex(Global.getPref());
+				infB.close(0);
+				Vm.showWait(false);
 				if(distChc.selectedIndex == 1) flt.distdirec = Filter.SMALLER;
 				else flt.distdirec = Filter.GREATER;
 				if(difChc.selectedIndex == 1) flt.diffdirec = Filter.SMALLER;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-20 21:15:30 UTC (rev 414)
+++ trunk/src/CacheWolf/Profile.java	2007-01-20 21:24:43 UTC (rev 415)
@@ -91,8 +91,7 @@
 				distOC = "0";
 			}
 			
-			// Bilbowolf: detfile.print("    <FILTER ....
-			
+			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+"\"/>\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
@@ -171,6 +170,11 @@
 					start=text.indexOf("dist = \"")+8;
 					distOC=text.substring(start,text.indexOf("\"",start));
 				} else if (text.indexOf("<FILTER")>=0){
+					ex.setSource(text);
+					filterRose = ex.findNext();
+					filterType = ex.findNext();
+					Vm.debug("F1:" +filterType);
+					Vm.debug("F2: "+filterRose);
 //					 Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}



From bilbowolf at mail.berlios.de  Sat Jan 20 22:36:06 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 20 Jan 2007 22:36:06 +0100
Subject: [Cachewolf-svn] r416 - trunk/src/CacheWolf
Message-ID: <200701202136.l0KLa6ko004244@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-20 22:36:00 +0100 (Sat, 20 Jan 2007)
New Revision: 416

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
debug entfernt

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-20 21:24:43 UTC (rev 415)
+++ trunk/src/CacheWolf/Profile.java	2007-01-20 21:36:00 UTC (rev 416)
@@ -173,8 +173,6 @@
 					ex.setSource(text);
 					filterRose = ex.findNext();
 					filterType = ex.findNext();
-					Vm.debug("F1:" +filterType);
-					Vm.debug("F2: "+filterRose);
 //					 Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}



From bilbowolf at mail.berlios.de  Sat Jan 20 22:37:03 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 20 Jan 2007 22:37:03 +0100
Subject: [Cachewolf-svn] r417 - trunk/src/CacheWolf
Message-ID: <200701202137.l0KLb3I7004301@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-20 22:36:52 +0100 (Sat, 20 Jan 2007)
New Revision: 417

Modified:
   trunk/src/CacheWolf/Version.java
Log:
Neue bleeding edge erstellt

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-01-20 21:36:00 UTC (rev 416)
+++ trunk/src/CacheWolf/Version.java	2007-01-20 21:36:52 UTC (rev 417)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " BE ";
-	static final String VER_SVN ="$LastChangedRevision$"; // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From admin at berlios.de  Sat Jan 20 23:18:37 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 20 Jan 2007 23:18:37 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2953] Filtereinstellungen speichern
Message-ID: <200701202218.l0KMIbZ9004184@unicorn.berlios.de>

Feature Request #2953, was updated on 2006-Dec-06 15:29
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2953&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Filtereinstellungen speichern

By: bilbowolf
Date: 2006-Dec-06 15:29

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; CIO CU; .NET CLR 1.0.3705; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1)

Die Filtereinstellungen sollten (je profil) 
gespeichert werden (pref.xml).

Beim Start von CW wird automatisch der Filter (f?r 
das Profil) angewendet.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2953&group_id=2211


From salzkammergut at mail.berlios.de  Sun Jan 21 00:03:18 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 00:03:18 +0100
Subject: [Cachewolf-svn] r418 - in trunk: resources src/CacheWolf
Message-ID: <200701202303.l0KN3Ima010123@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 00:03:13 +0100 (Sun, 21 Jan 2007)
New Revision: 418

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/SolverPanel.java
Log:
Update Solver. Keine weiteren Aenderungen mehr geplant.
Neue Funktionen, Direktbefehl

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-20 21:36:52 UTC (rev 417)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-20 23:03:13 UTC (rev 418)
@@ -240,7 +240,7 @@
 		1618=Ignoriere Fehler in Cache:+
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
-		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp?ter erneut versuchen\n Status:
+		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp%e4ter erneut versuchen\n Status:
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 
@@ -249,11 +249,11 @@
 		1705=Fehlendes ENDIF
 		1706=Erwartet: 
 		1707=Gefunden: 
-		1708=Uneindeutiger Funktionsname: 
+		1708=Funktionsname nicht eindeutig: 
 		1709=Unbekannte Funktion: 
 		1710=Kann leere Zeichenkette nicht z?hlen
 		1711=Ersatzzeichenketten m%fcssen gleiche L%e4nge haben
-		1712=Unzul?ssige Koordinate: 
+		1712=Unzul%e4ssige Koordinate: 
 		1713=Falsches Koordinatenformat. Erlaubt sind CW/DD/DMM/DMS/UTM
 		1714=Goto: Wegpunkt existiert nicht: 
 		1715=instr: Startposition nicht in Zeichenkette
@@ -262,8 +262,6 @@
 		1718=Kann keine negative Distanz projizieren
 		1719=Winkel muss im Bereich [0;360] sein
 		1720=Kann die Wurzel einer negativen Zahl nicht berechnen
-		1721=substring: Ganzzahliger Parameter erwartet
-		1722=substring: Parameter ausserhalb des erlaubten Bereichs
 		1723=Vergleichsoperator erwartet
 		1724=Variable hat keinen Wert: 
 		1725=Unerwartete(s) Zeichen: 
@@ -272,8 +270,9 @@
 		1728=Funktion noch nicht implementiert: 
 		1729=Division durch 0
 		1730=Fehlendes " am Ende der Zeichenkette
-		1731=Unerlaubtes Formatierungzeichen
-		1732=Unerlaubtes Zeichen		
+		1731=Nicht erlaubtes Formatierungzeichen
+		1732=Nicht erlaubtes Zeichen
+		1733=Befehl eingeben		
 		1800=Georeferenzierte Karten herunterladen
 		1801=Kacheln herunterladen
 		2000=GPX Export
@@ -554,8 +553,6 @@
 		1718=Cannot project a negative distance
 		1719=Projection degrees must be in interval [0;360]
 		1720=Cannot calculate square root of a negative number
-		1721=substring: Integer argument expected
-		1722=substring: Argument out of range
 		1723=Comparison operator expected
 		1724=Variable not set: 
 		1725=Unexpected character(s): 
@@ -565,7 +562,8 @@
 		1729=Division by 0
 		1730=Unterminated string
 		1731=Invalid format character
-		1732=Invalid character		
+		1732=Invalid character
+		1733=Input command		
 		1800=Download georeferenced maps
 		1801=Download tiles
 		2000=GPX Export

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-20 21:36:52 UTC (rev 417)
+++ trunk/src/CacheWolf/Parser.java	2007-01-20 23:03:13 UTC (rev 418)
@@ -92,13 +92,18 @@
     	new fnType("acos","acos",2),
     	new fnType("asin","asin",2),
     	new fnType("atan","atan",2),
+      	new fnType("bearing","bearing",4),
+    	new fnType("center","center",3),
     	new fnType("cls","cls",1),
     	new fnType("clearscreen","cls",1),
     	new fnType("cos","cos",2),
     	new fnType("count","count",4),
+     	new fnType("cp","cp",1),
     	new fnType("crosstotal","ct",6),
     	new fnType("ct","ct",2),
-    	new fnType("encode","encode",8),
+     	new fnType("curpos","cp",1),
+     	new fnType("distance","distance",2),
+     	new fnType("encode","encode",8),
     	new fnType("format","format",6),
     	new fnType("goto","goto",6),
     	new fnType("ic","ic",3),
@@ -107,24 +112,26 @@
     	new fnType("lcase","lc",2),
     	new fnType("length","len",2),
     	new fnType("mid","mid",12),
+     	new fnType("pc","pz",3),
+     	new fnType("profilecenter","pz",3),
+     	new fnType("profilzentrum","pz",3),
     	new fnType("project","project",8),
+     	new fnType("pz","pz",3),
     	new fnType("quersumme","ct",6),
-//    	new fnType("requiresemicolon","rs",3),
     	new fnType("replace","replace",8),
     	new fnType("reverse","reverse",2),
     	new fnType("rot13","rot13",2),
-//    	new fnType("rs","rs",3),
     	new fnType("show","show",2),
     	new fnType("sin","sin",2),
     	new fnType("sqrt","sqrt",2),
-    	new fnType("substring","substring",12),
     	new fnType("sval","sval",2),
     	new fnType("tolowercase","lc",2),
     	new fnType("touppercase","uc",2),
     	new fnType("tan","tan",2),
     	new fnType("ucase","uc",2),
-    	new fnType("val","val",2)
-    	};
+    	new fnType("val","val",2),
+     	new fnType("zentrum","center",3)
+     	    	};
 	private static int scanpos = 0;
 	CWPoint cwPt=new CWPoint();
 	Vector calcStack=new Vector();
@@ -152,10 +159,27 @@
 	private void err(String str) throws Exception {
     	messageStack.add(MyLocale.getMsg(1700,"Error on line: ") + thisToken.line + "  "+MyLocale.getMsg(1701,"position: ") + thisToken.position);
     	messageStack.add(str);
+    	// move cursor to error location
+    	Global.mainTab.solverP.mText.setSelectionRange(thisToken.position-1,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1);
     	throw new Exception("Error "+str);
     }
     
-    /** Clears the symbol table of all non-global symbols (those not starting with $) */
+    /** Shows global symbols */
+    private void showGlobals() throws Exception {
+    	Iterator it=symbolTable.entries();
+    	while (it.hasNext()) {
+    		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
+    		if (varName.startsWith("$")) {
+    			String value=(String) getVariable(varName);
+    			if (java.lang.Double.isNaN(toNumber(value)))
+    				messageStack.add(varName+" = \""+STRreplace.replace(value.toString(),"\"","\"\"")+"\"");
+    			else
+    				messageStack.add(varName+" = "+value);
+    		}
+    	}
+    }
+
+	/** Clears the symbol table of all non-global symbols (those not starting with $) */
     private void clearLocalSymbols() {
     	Iterator it=symbolTable.entries();
     	while (it.hasNext()) {
@@ -179,6 +203,18 @@
     }
     
 	private Object getVariable(String varName) throws Exception {
+		if (varName.startsWith("$")) { // Potential coordinate
+			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
+			if (idx!=-1) { // Found it!
+				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				// Check whether coordinates are valid
+				cwPt.set(ch.LatLon);
+				if (cwPt.isValid() ) 
+					return ch.LatLon;
+				else
+					return ""; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
+			}
+		}
 		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
 		if(result == null) {
 			// If it is a global variable, add it with a default value
@@ -191,17 +227,22 @@
 		return result;
 	}
 	
-	private Double getNumber(String str) throws Exception {
-		java.lang.Double ret=null;
+	private double toNumber(String str) {
 		try {
 			if (Global.getPref().digSeparator.equals(","))	str = str.replace('.', ',');
-			ret=new java.lang.Double(java.lang.Double.parseDouble(str));
+			 return java.lang.Double.parseDouble(str);
 		} catch (NumberFormatException e) {
-			err(MyLocale.getMsg(1703,"Not a valid number: ") + str);
+			 return java.lang.Double.NaN;
 		}
-		return ret;
 	}
 	
+	private Double getNumber(String str) throws Exception {
+		double ret=toNumber(str);
+		if (java.lang.Double.isNaN(ret))
+			err(MyLocale.getMsg(1703,"Not a valid number: ") + str);
+		return new java.lang.Double(ret);
+	}
+	
 	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
 	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
 		double num;
@@ -242,7 +283,7 @@
 		} while (thisToken.token.equals(";"));	
 	}
 
-	private void skipPastEndif() throws Exception {
+	private void skipPastEndif(TokenObj ifToken) throws Exception {
 		while(scanpos < tokenStack.size()){
 			thisToken = (TokenObj)tokenStack.get(scanpos);
 			scanpos++;
@@ -251,6 +292,7 @@
 				return;
 			}
 		}
+		thisToken=ifToken;
 		err(MyLocale.getMsg(1705,"Missing ENDIF"));
 	}
 	private TokenObj lookAheadToken() {
@@ -283,6 +325,17 @@
 //  FUNCTIONS
 ///////////////////////////////////////////
     
+	/** Get or set the current center */
+	private void funcCenter(int nargs) throws Exception {
+		if (nargs==0) {
+			calcStack.add(Global.getPref().curCentrePt.toString());
+		} else {
+	    	String coordA=popCalcStackAsString();
+			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+			Global.getPref().curCentrePt.set(coordA);
+		}
+	}
+	
 	/** Clear Screen */
 	private void funcCls() {
 		// OutputPanel is private, so need to cast to base class
@@ -310,9 +363,13 @@
     			res+=s2.charAt(i)+"="+funcCountChar(s1,s2.charAt(i))+" ";
     		}
     		calcStack.add(res);
-    	}
+    	} 
     }
     
+    private String funcCp(){
+    	return Global.mainTab.gotoP.gpsPosition.toString();
+    }
+    
     private double funcCrossTotal(int nargs) throws Exception {
     	int cycles=1;
 		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
@@ -331,6 +388,25 @@
     	}return a;
     }
     
+    /** Calculate distance between 2 points */
+    private double funcDistance() throws Exception {
+    	String coordB=popCalcStackAsString();
+    	String coordA=popCalcStackAsString();
+    	cwPt.set(coordA);
+		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
+    	return cwPt.getDistance(new CWPoint(coordB));
+    }
+    
+    /** Calculate brearing from one point to the next */
+    private double funcBearing() throws Exception {
+    	String coordB=popCalcStackAsString();
+    	String coordA=popCalcStackAsString();
+    	cwPt.set(coordA);
+		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
+    	return cwPt.getBearing(new CWPoint(coordB));
+    }
     /**
      * Encode a string by replacing all characters in a string with their corresponding characters in
      * another string
@@ -435,6 +511,17 @@
     		return s.substring((int)start-1,end);
     	}
     }
+ 
+	/** Get or set the profile center */
+	private void funcPz(int nargs) throws Exception {
+		if (nargs==0) {
+			calcStack.add(Global.getProfile().centre.toString());
+		} else {
+	    	String coordA=popCalcStackAsString();
+			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+			Global.getProfile().centre.set(coordA);
+		}
+	}
     
     /** Project a waypoint at some angle and some distance */
     private String funcProject() throws Exception {
@@ -464,39 +551,12 @@
     	return res;
     }
     
-    /*   private void funcRequireSemicolon(int nargs) throws Exception {
-	if (nargs==0) 
-		calcStack.add(""+Global.getPref().solverRequireSemicolon);
-	else {
-		Global.getPref().solverRequireSemicolon=(popCalcStackAsNumber(0)!=0)?true:false;
-	}
-}
-*/  
-    
     private double funcSqrt() throws Exception {
     	double a=popCalcStackAsNumber(0);
     	if (a<0) err(MyLocale.getMsg(1720,"Cannot calculate square root of a negative number"));
     	return java.lang.Math.sqrt(a);
     }
     
-    /** Java-like substring */
-    private String funcSubstring(int nargs) throws Exception {
-    	if (nargs==2) {
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err(MyLocale.getMsg(1721,"substring: Integer argument expected"));
-    		if (start<0 || start>s.length()) err(MyLocale.getMsg(1722,"substring: Argument out of range"));
-    		return s.substring((int)start);
-    	} else {
-        	double end=popCalcStackAsNumber(0);
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(end)) err(MyLocale.getMsg(1721,"substring: Integer argument expected"));
-    		if (start<0 || start>s.length() || start>end || end>s.length()) err(MyLocale.getMsg(1722,"substring: Argument out of range"));
-    		return s.substring((int)start,(int)end);
-    	}
-    }
-    
     /** Replace each character by its number A=1, B=2 etc. and put result into a string */
     private String funcSval(String s) {
        	s=s.toLowerCase();
@@ -544,7 +604,10 @@
 
 	private void parseSimpleCommand() throws Exception{
 		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception("STOP");  // Terminate without error message
-		if (thisToken.tt==TokenObj.TT_VARIABLE && lookAheadToken().tt==TokenObj.TT_EQ) 
+		if (thisToken.token.equals("$")) {
+			showGlobals();
+			getToken();
+		} else if (thisToken.tt==TokenObj.TT_VARIABLE && lookAheadToken().tt==TokenObj.TT_EQ) 
 			parseAssign();
 		else 
 			parseStringExp();		
@@ -553,6 +616,7 @@
 	private void parseIf() throws Exception{
 		int compOp;
 		boolean compRes=false;
+		TokenObj ifToken=thisToken;
 		getToken();
 		parseStringExp();
 		compOp=thisToken.tt;
@@ -597,7 +661,7 @@
 			}
 			getToken();
 		} else // comparison failed
-			skipPastEndif();
+			skipPastEndif(ifToken);
 	}
 	
 	private void parseAssign() throws Exception  {
@@ -608,6 +672,21 @@
 		// we can fill the data progressively during a multicache
 		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(";")) return;
 		parseStringExp();
+		if (varName.startsWith("$")) { // Potential coordinate
+			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
+			if (idx!=-1) { // Yes, is a coordinate
+				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				// Check whether new coordinates are valid
+				String coord=popCalcStackAsString();
+				cwPt.set(coord);
+				if (cwPt.isValid() || coord.equals("")) { // Can clear coord with empty string
+					ch.LatLon=cwPt.toString(CWPoint.CW);
+				    return;
+				} else
+					err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
+			}
+			// Name starts with $ but is not a waypoint, fall through and set it as global variable
+		}
 		symbolTable.put(varName, popCalcStackAsString());
 	}
 	
@@ -746,10 +825,14 @@
 	 	else if (funcDef.alias.equals("abs")) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(java.lang.Math.acos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("atan")) calcStack.add(new java.lang.Double(java.lang.Math.atan(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("bearing")) calcStack.add(new java.lang.Double(funcBearing()));
+	    else if (funcDef.alias.equals("center")) funcCenter(nargs);
 	    else if (funcDef.alias.equals("cls")) funcCls();
 	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("count")) funcCount();
+	    else if (funcDef.alias.equals("cp")) funcCp();     
 	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
+	    else if (funcDef.alias.equals("distance")) calcStack.add(new java.lang.Double(funcDistance()));
 	    else if (funcDef.alias.equals("encode")) calcStack.add(funcEncode());
 	    else if (funcDef.alias.equals("format")) calcStack.add(funcFormat(nargs));
 	    else if (funcDef.alias.equals("goto")) funcGoto(nargs);
@@ -759,6 +842,7 @@
 	    else if (funcDef.alias.equals("len")) calcStack.add(new Double(popCalcStackAsString().length()));
 	    else if (funcDef.alias.equals("mid")) calcStack.add(funcMid(nargs));
 	    else if (funcDef.alias.equals("project")) calcStack.add(funcProject());     
+	    else if (funcDef.alias.equals("pz")) funcPz(nargs);     
 	    else if (funcDef.alias.equals("replace")) calcStack.add(funcReplace());
 	    else if (funcDef.alias.equals("reverse")) calcStack.add(funcReverse(popCalcStackAsString()));
 	    else if (funcDef.alias.equals("rot13")) calcStack.add(Common.rot13(popCalcStackAsString()));
@@ -766,7 +850,6 @@
 	    else if (funcDef.alias.equals("show"));
 	    else if (funcDef.alias.equals("sin")) calcStack.add(new java.lang.Double(java.lang.Math.sin(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("sqrt")) calcStack.add(new java.lang.Double(funcSqrt())); 
-	    else if (funcDef.alias.equals("substring")) calcStack.add(funcSubstring(nargs)); 
 	    else if (funcDef.alias.equals("sval")) calcStack.add(funcSval(popCalcStackAsString()));
 	    else if (funcDef.alias.equals("tan")) calcStack.add(new java.lang.Double(java.lang.Math.tan(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("uc")) calcStack.add(popCalcStackAsString().toUpperCase());

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2007-01-20 21:36:52 UTC (rev 417)
+++ trunk/src/CacheWolf/SolverPanel.java	2007-01-20 23:03:13 UTC (rev 418)
@@ -49,7 +49,16 @@
 				super.popupMenuEvent(selectedItem);
 		}
 	}
-	
+	private class InputPanel extends mTextPad {
+
+		public void  penDoubleClicked(Point where) {
+			execDirectCommand();
+		}
+	}
+	private class InpScreen extends InputBox {
+		InpScreen(String title) {super(title); }
+		String getInput() { return getInputValue();}
+	}
 	CellPanel programPanel, outputPanel;
 	
 	public SolverPanel (Preferences p, Profile prof){
@@ -61,7 +70,7 @@
 		outputPanel = split.getNextPanel();
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
 
-		programPanel.addLast(new ScrollBarPanel(mText = new mTextPad()));
+		programPanel.addLast(new ScrollBarPanel(mText = new InputPanel()));
 		programPanel.addNext(mBtSolve= new mButton("Solve!"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		programPanel.addNext(btnLoad= new mButton("Load"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		programPanel.addNext(btnSave= new mButton("Save"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -75,17 +84,29 @@
 		currCh=ch;
 	}
 
+	private void execDirectCommand() {
+		InpScreen boxInp=new InpScreen(MyLocale.getMsg(1733,"Input command"));
+		boxInp.input(parent.getFrame(),"",100); //,MyLocale.getScreenWidth()*4/5);
+		String s=boxInp.getInput();
+		if (s.equals("")) return;
+		processCommand(s);
+	}
+	
+    private void processCommand(String s) {
+		msgFIFO.clear();
+		tokenizer.tokenizeSource(s, msgFIFO); // Tokenizer sets message if an error occurred
+		if (msgFIFO.size()==0) parser.parse(tokenizer.TokenStack, msgFIFO);
+		String msgStr = "";
+		for(int i = 0; i < msgFIFO.size(); i++){
+			msgStr = msgStr + msgFIFO.get(i) + "\n";
+		}
+		mOutput.appendText(msgStr,true);
+    }
+	
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if(ev.target == mBtSolve){
-				msgFIFO.clear();
-				tokenizer.tokenizeSource(mText.getText(), msgFIFO); // Tokenizer sets message if an error occurred
-				if (msgFIFO.size()==0) parser.parse(tokenizer.TokenStack, msgFIFO);
-				String msgStr = "";
-				for(int i = 0; i < msgFIFO.size(); i++){
-					msgStr = msgStr + msgFIFO.get(i) + "\n";
-				}
-				mOutput.appendText(msgStr,true);
+				processCommand(mText.getText());
 			}
 			if(ev.target == btnLoad){
 				FileChooser fc = new FileChooser(FileChooser.OPEN, profile.dataDir);
@@ -135,4 +156,5 @@
 			
 		}
 	}
+	
 }



From admin at berlios.de  Sun Jan 21 02:38:52 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:38:52 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3065] MovingMap: Anzeige von Zoom-Modus
Message-ID: <200701210138.l0L1cqOa022706@unicorn.berlios.de>

Feature Request #3065, was updated on 2007-Jan-21 02:38
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3065&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Anzeige von Zoom-Modus

By: mik77
Date: 2007-Jan-21 02:38

Message:
Logged In: YES 
user_id=34677
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de-AT; rv:1.8.1) Gecko/20061101 SeaMonkey/1.1b Mnenhy/0.7.4.10002

Die Lupe wird gr?n, wenn sie angeklickt wurde und man
sich im Zoom-Modus befindet.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3065&group_id=2211


From admin at berlios.de  Sun Jan 21 02:43:09 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:43:09 +0100 (CET)
Subject: [Feature #3066] MovingMap: Kontextmenü hinzufügen
Message-ID: <200701210143.l0L1h9Le027474@unicorn.berlios.de>

Feature Request #3066, was updated on 2007-Jan-21 02:43
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3066&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Kontextmen? hinzuf?gen

By: mik77
Date: 2007-Jan-21 02:43

Message:
Logged In: YES 
user_id=34677
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de-AT; rv:1.8.1) Gecko/20061101 SeaMonkey/1.1b Mnenhy/0.7.4.10002

Kontextmen? f?r die MovingMap.
Erster Eintrag: "Goto here"

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3066&group_id=2211


From admin at berlios.de  Sun Jan 21 02:49:28 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:49:28 +0100 (CET)
Subject: [Bug #10069] MovingMap: Import läuft ins falsche (alte) Verzeichnis
Message-ID: <200701210149.l0L1nSwB004445@unicorn.berlios.de>

Bug #10069, was updated on 2007-Jan-19 17:43
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Fixed
Bug Group: Ready to test
Priority: 7
Submitted by: pfeffer
Assigned to : mik77
Summary: MovingMap: Import l?uft ins falsche (alte) Verzeichnis

Details: siehe http://www.geoclub.de/ftopic13608-20.html

Gru?,
  Pfeffer.

Follow-Ups:

Date: 2007-Jan-20 06:39
By: pfeffer

Comment:
ich hab's so gemacht:
Wenn sich im neuen Verzeichnis (<Profile-Verz>/maps/standard) kalibrierte Karten befinden, werden diese verwendet.
Falls das nicht der Fall ist:
wenn sich im alten Verzeichnis noch Karten befinden, wird nachgefragt, ob sie ins neue Verzeichnis verschoben werden sollen, falls nein, werden sie von der alten Position geladen.
SVN 406:
Wenn es keine selbst importierten Karten gibt, dann werden die von expedia herunter geladenen verwendet, d.h. <Profile-Verz>/maps/expedia

Bitte testen,
  Gru?,
    Pfeffer.

-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10069&group_id=2211


From admin at berlios.de  Sun Jan 21 02:51:22 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:51:22 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2927] Track in MovinMap anzeigen
Message-ID: <200701210151.l0L1pMJc006882@unicorn.berlios.de>

Feature Request #2927, was updated on 2006-Dec-03 16:34
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2927&group_id=2211

Category: None
Status: Closed
Priority: 5
Summary: Track in MovinMap anzeigen

By: pfeffer
Date: 2007-Jan-08 03:20

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

dieses Problem habe ich nun gel?st. Bitte testen.
(geht jetzt auch, wenn man keine kalibrierte Karte hat!)

----------------------------------------------------------------------

By: pfeffer
Date: 2006-Dec-08 17:47

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

die Trackanzeige ist eigentlich fertig (mit SVN 282).
Allerdings gibt es ein wesentliches Problem: neue
Trackingpunkte werden nicht dragestellt, obwohl sie im
Programm gezeichnet werden. Erst das komplette Neuerstellen
des Overlays f?hrt zur Anzeige :-( (das kann man erreichen
in dem man den button "snap to GPS" dr?ckt)


die Methode ShowLastAddedPoint in MovingMap.java bringt in
der Ewe-Vm nicht das, was sie soll. Nach meinen Tests
funktioniert's hingegen in der Java-VM.

Irgendjemand ne Idee?

Gru?,
  Pfeffer.


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2927&group_id=2211


From admin at berlios.de  Sun Jan 21 02:54:58 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:54:58 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3065] MovingMap: Anzeige von Zoom-Modus
Message-ID: <200701210154.l0L1swE0011107@unicorn.berlios.de>

Feature Request #3065, was updated on 2007-Jan-21 02:38
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3065&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Anzeige von Zoom-Modus

By: mik77
Date: 2007-Jan-21 02:38

Message:
Logged In: YES 
user_id=34677
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de-AT; rv:1.8.1) Gecko/20061101 SeaMonkey/1.1b Mnenhy/0.7.4.10002

Die Lupe wird gr?n, wenn sie angeklickt wurde und man
sich im Zoom-Modus befindet.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3065&group_id=2211


From admin at berlios.de  Sun Jan 21 02:55:20 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:55:20 +0100 (CET)
Subject: [Feature #3066] MovingMap: Kontextmenü hinzufügen
Message-ID: <200701210155.l0L1tKKJ011523@unicorn.berlios.de>

Feature Request #3066, was updated on 2007-Jan-21 02:43
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3066&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Kontextmen? hinzuf?gen

By: mik77
Date: 2007-Jan-21 02:43

Message:
Logged In: YES 
user_id=34677
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de-AT; rv:1.8.1) Gecko/20061101 SeaMonkey/1.1b Mnenhy/0.7.4.10002

Kontextmen? f?r die MovingMap.
Erster Eintrag: "Goto here"

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3066&group_id=2211


From admin at berlios.de  Sun Jan 21 02:58:17 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:58:17 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3045] MavingMap: Karte ausblenden
Message-ID: <200701210158.l0L1wHtt014733@unicorn.berlios.de>

Feature Request #3045, was updated on 2007-Jan-12 16:05
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: MavingMap: Karte ausblenden

By: pfeffer
Date: 2007-Jan-19 03:05

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

ist schon in BE 400 drin, bitte testen.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 16:06

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3045&group_id=2211


From admin at berlios.de  Sun Jan 21 02:58:57 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 02:58:57 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3046] MovingMap: Zommen
Message-ID: <200701210158.l0L1wv6l015513@unicorn.berlios.de>

Feature Request #3046, was updated on 2007-Jan-13 14:22
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: MovingMap: Zommen

By: pfeffer
Date: 2007-Jan-19 03:07

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

ist erldeigt, irgendwann kurz vor SVN 403

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-13 14:35

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

das wesentliche ist mit SVN 382 erledigt.
Verbesserungen sind noch vorgesehen  bei der 
Verschiebung des Ausschnitts sowohl auf dem 
Bildschirm alsauch bei der Beschneidung des Bildes beim 
zoomen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3046&group_id=2211


From admin at berlios.de  Sun Jan 21 13:33:09 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 21 Jan 2007 13:33:09 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3062] MovingMap: Kartendownload von
	Expedia
Message-ID: <200701211233.l0LCX9Qi023082@unicorn.berlios.de>

Feature Request #3062, was updated on 2007-Jan-19 03:09
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3062&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: MovingMap: Kartendownload von Expedia

By: pfeffer
Date: 2007-Jan-19 03:09

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: automatischer Kartendownload von 
Expedia

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3062&group_id=2211


From kalli at mail.berlios.de  Sun Jan 21 13:51:27 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 21 Jan 2007 13:51:27 +0100
Subject: [Cachewolf-svn] r419 - trunk/src/CacheWolf
Message-ID: <200701211251.l0LCpRIi019968@sheep.berlios.de>

Author: kalli
Date: 2007-01-21 13:51:22 +0100 (Sun, 21 Jan 2007)
New Revision: 419

Modified:
   trunk/src/CacheWolf/Test.java
Log:
Tests f?\195?\188r Performance

Modified: trunk/src/CacheWolf/Test.java
===================================================================
--- trunk/src/CacheWolf/Test.java	2007-01-20 23:03:13 UTC (rev 418)
+++ trunk/src/CacheWolf/Test.java	2007-01-21 12:51:22 UTC (rev 419)
@@ -1,18 +1,82 @@
 package CacheWolf;
 
-import ewe.sys.Vm;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.io.RandomAccessFile;
+import ewe.sys.*;
 
+import java.lang.Math;;
+ 
+
 public class Test {
 	boolean allPassed=true; 
 
 	void testAll(){
-		testRegex();
+		testPerformance();
+/*		testRegex();
 		if (allPassed) 
 			Vm.debug("SUCCESS: All tests passed"); 
 		else 
 			Vm.debug("FAILURE: At least one test failed"); 
+*/	}
+	void testPerformance(){
+		Time start, end;
+		int i;
+		double tmp;
+		
+		// 100.000 Sinus
+		start = new Time();
+		for (i=0; i<100000; i++){
+			tmp = Math.sin(53);
+		}
+		end = new Time();
+		printResult("sin(53)", start, end, i);
+		
+		// 1.000 CWPoint via constructor
+		start = new Time();
+		for (i=0; i<100; i++){
+			CWPoint cwP = new CWPoint("N 51? 27.635 E 009? 37.621", CWPoint.CW);
+		}
+		end = new Time();
+		printResult("CWPoint constructor", start, end, i);
+
+		// 1.000 CWPoint via set
+		start = new Time();
+		CWPoint cwSet = new CWPoint();
+		for (i=0; i<100; i++){
+			cwSet.set("N 51? 27.635 E 009? 37.621", CWPoint.CW);
+		}
+		end = new Time();
+		printResult("CWPoint set", start, end, i);
+
+		// 1.000 filewrite
+		String fileName = new String("test.tmp");
+		try {
+			RandomAccessFile out =  new RandomAccessFile(fileName,"rw");
+			start = new Time();
+			for (i=0; i<10000; i++){
+				out.writeBytes(fileName);
+			}
+			end = new Time();
+			out.close();
+			File dfile = new File(fileName);
+			dfile.delete();
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		printResult("Filewrite 10 Bytes", start, end, i);
+		
 	}
 	
+	void printResult(String what, Time start, Time end, int count){
+		String VM = Vm.getPlatform();
+		long time;
+		time = end.getTime() - start.getTime();
+		
+		Vm.debug(VM + " " +  Convert.toString(time) + " msec " + Convert.toString(count) + " * " + what);
+	}
+	
 	void testPassedRegex(String pattern, String expectedResult, int format) {
 		CWPoint coord = new CWPoint(pattern, CWPoint.REGEX);
 		String res = coord.toString(format);



From pfeffer at mail.berlios.de  Sun Jan 21 16:13:54 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 21 Jan 2007 16:13:54 +0100
Subject: [Cachewolf-svn] r420 - trunk/src/CacheWolf
Message-ID: <200701211513.l0LFDsXk030054@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-21 16:13:52 +0100 (Sun, 21 Jan 2007)
New Revision: 420

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
kleine Geschwindigkeitsverbesserung beim erzeugen der Zuordnung zu addiWaypints (weiss nicht, ob es viel bringt), siehe http://www.geoclub.de/ftopic13721.html

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-21 12:51:22 UTC (rev 419)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-21 15:13:52 UTC (rev 420)
@@ -440,17 +440,17 @@
    
    public static void buildReferences(Vector cacheDB){
 	   CacheHolder ch, mainCh;
-	   Hashtable dbIndex = new Hashtable();
+	   Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
 	   Integer index;
 	   // Build index for faster search and clear all references
-	   for(int i = 0; i<cacheDB.size();i++){
+	   for(int i = cacheDB.size() -1; i >= 0;i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.addiWpts.clear();
 			ch.mainCache = null;
 			dbIndex.put((String)ch.wayPoint, new Integer(i));
 	   }
 	   // Build refeneces
-	   for(int i = 0; i<cacheDB.size();i++){
+	   for(int i = cacheDB.size() -1; i >= 0;i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.isAddiWpt()) {
 				//search main cache



From salzkammergut at mail.berlios.de  Sun Jan 21 16:22:50 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 16:22:50 +0100
Subject: [Cachewolf-svn] r421 - trunk/src/CacheWolf
Message-ID: <200701211522.l0LFModE031234@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 16:22:46 +0100 (Sun, 21 Jan 2007)
New Revision: 421

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Speichern/Lesen der Koordinaten im Dezimalformat in index.xml

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-21 15:13:52 UTC (rev 420)
+++ trunk/src/CacheWolf/Profile.java	2007-01-21 15:22:46 UTC (rev 421)
@@ -80,10 +80,11 @@
 		
 		try{
 			detfile.print("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
-			detfile.print("<CACHELIST>\n");
+			detfile.print("<CACHELIST format=\"decimal\">\n");
 			if (savedCentre.isValid())
-				detfile.print("    <CENTRE lat=\""+savedCentre.getNSLetter() + " " + savedCentre.getLatDeg(CWPoint.CW) + "&deg; " + savedCentre.getLatMin(CWPoint.CW)+ "\" "+
-				                        "long=\""+savedCentre.getEWLetter() + " " + savedCentre.getLonDeg(CWPoint.CW) + "&deg; " + savedCentre.getLonMin(CWPoint.CW)+"\"/>\n");
+//				detfile.print("    <CENTRE lat=\""+savedCentre.getNSLetter() + " " + savedCentre.getLatDeg(CWPoint.CW) + "&deg; " + savedCentre.getLatMin(CWPoint.CW)+ "\" "+
+//				                        "long=\""+savedCentre.getEWLetter() + " " + savedCentre.getLonDeg(CWPoint.CW) + "&deg; " + savedCentre.getLonMin(CWPoint.CW)+"\"/>\n");
+				detfile.print("    <CENTRE lat=\""+savedCentre.latDec+"\" lon=\""+savedCentre.lonDec+"\"/>\n");
 			if(last_sync_opencaching == null || last_sync_opencaching.endsWith("null") || last_sync_opencaching.equals("")){
 				last_sync_opencaching = "20050801000000";
 			}
@@ -97,7 +98,10 @@
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
-					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+"\" latlon = \""+ SafeXML.clean(ch.LatLon) +"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch!
 .ocCacheID + "\" />\n");
+					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
+							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
+							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
+							"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" />\n");
 				}
 			}
 			detfile.print("</CACHELIST>\n");
@@ -117,11 +121,14 @@
 	*/
 	public void readIndex(){
 		try {
+			boolean fmtDec=false;
+			char decSep=MyLocale.getDigSeparator().charAt(0);
+			char notDecSep=decSep=='.'?',':'.';
 			FileReader in = new FileReader(dataDir + "index.xml");
-//Vm.debug("Reading "+dataDir + "index.xml");
+Vm.debug("Reading "+dataDir + "index.xml DecSep="+MyLocale.getDigSeparator());
 			in.readLine(); // <?xml version= ...
-			in.readLine(); // <CACHELIST>
-			String text;
+			String text=in.readLine(); // <CACHELIST>
+			if (text.indexOf("decimal")>0) fmtDec=true;
 			Extractor ex = new Extractor(null, " = \"", "\" ", 0, true);
 			while ((text = in.readLine()) != null){
 				// Check for Line with cache data
@@ -130,7 +137,13 @@
 					CacheHolder ch = new CacheHolder();
 					ch.CacheName = SafeXML.cleanback(ex.findNext());
 					ch.CacheOwner = SafeXML.cleanback(ex.findNext());
-					ch.LatLon = SafeXML.cleanback(ex.findNext());
+					if (fmtDec) {
+						double lat=Convert.parseDouble(ex.findNext().replace(notDecSep,decSep));
+						double lon=Convert.parseDouble(ex.findNext().replace(notDecSep,decSep));
+						ch.pos=new CWPoint(lat,lon);
+						ch.LatLon=ch.pos.toString();
+					} else
+						ch.LatLon = SafeXML.cleanback(ex.findNext());
 					ch.DateHidden = ex.findNext();
 					ch.wayPoint = SafeXML.cleanback(ex.findNext());
 					ch.CacheStatus = ex.findNext();
@@ -158,12 +171,19 @@
 					ch.ocCacheID = STRreplace.replace(ch.ocCacheID,"\"", null);
 					cacheDB.add(ch);
 				} else if (text.indexOf("<CENTRE")>=0) { // lat=  lon=
-					int start=text.indexOf("lat=\"")+5;
-					String lat=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("long=\"")+6;
-					String lon=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
-					//Vm.debug("Centre "+lat+" "+lon);
-					centre.set(lat+" "+lon,CWPoint.CW); // Fast parse
+					if (fmtDec) {
+						int start=text.indexOf("lat=\"")+5;
+						String lat=text.substring(start,text.indexOf("\"",start)).replace(notDecSep,decSep);
+						start=text.indexOf("lon=\"")+5;
+						String lon=text.substring(start,text.indexOf("\"",start)).replace(notDecSep,decSep);
+						centre.set(Convert.parseDouble(lat),Convert.parseDouble(lon));
+					} else {	
+						int start=text.indexOf("lat=\"")+5;
+						String lat=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
+						start=text.indexOf("long=\"")+6;
+						String lon=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
+						centre.set(lat+" "+lon,CWPoint.CW); // Fast parse
+					}	
 				} else if (text.indexOf("<SYNCOC")>=0) {
 					int start=text.indexOf("date = \"")+8;
 					last_sync_opencaching=text.substring(start,text.indexOf("\"",start));



From salzkammergut at mail.berlios.de  Sun Jan 21 16:27:38 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 16:27:38 +0100
Subject: [Cachewolf-svn] r422 - trunk/src/CacheWolf
Message-ID: <200701211527.l0LFRcTg031483@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 16:27:35 +0100 (Sun, 21 Jan 2007)
New Revision: 422

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Debug message entfernt

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-21 15:22:46 UTC (rev 421)
+++ trunk/src/CacheWolf/Profile.java	2007-01-21 15:27:35 UTC (rev 422)
@@ -125,7 +125,6 @@
 			char decSep=MyLocale.getDigSeparator().charAt(0);
 			char notDecSep=decSep=='.'?',':'.';
 			FileReader in = new FileReader(dataDir + "index.xml");
-Vm.debug("Reading "+dataDir + "index.xml DecSep="+MyLocale.getDigSeparator());
 			in.readLine(); // <?xml version= ...
 			String text=in.readLine(); // <CACHELIST>
 			if (text.indexOf("decimal")>0) fmtDec=true;



From salzkammergut at mail.berlios.de  Sun Jan 21 16:44:23 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 16:44:23 +0100
Subject: [Cachewolf-svn] r423 - trunk/src/CacheWolf
Message-ID: <200701211544.l0LFiNUD001207@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 16:44:06 +0100 (Sun, 21 Jan 2007)
New Revision: 423

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
Bugfix Rev 420

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-21 15:27:35 UTC (rev 422)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-21 15:44:06 UTC (rev 423)
@@ -443,14 +443,14 @@
 	   Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
 	   Integer index;
 	   // Build index for faster search and clear all references
-	   for(int i = cacheDB.size() -1; i >= 0;i++){
+	   for(int i = cacheDB.size() -1; i >= 0;i--){
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.addiWpts.clear();
 			ch.mainCache = null;
 			dbIndex.put((String)ch.wayPoint, new Integer(i));
 	   }
 	   // Build refeneces
-	   for(int i = cacheDB.size() -1; i >= 0;i++){
+	   for(int i = cacheDB.size() -1; i >= 0;i--){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.isAddiWpt()) {
 				//search main cache



From salzkammergut at mail.berlios.de  Sun Jan 21 16:57:23 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 16:57:23 +0100
Subject: [Cachewolf-svn] r424 - trunk/src/CacheWolf
Message-ID: <200701211557.l0LFvNxc001729@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 16:57:21 +0100 (Sun, 21 Jan 2007)
New Revision: 424

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
Fix: Beim Laden eines neuen Profils in die erste Zeile springen

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-21 15:44:06 UTC (rev 423)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-21 15:57:21 UTC (rev 424)
@@ -164,6 +164,7 @@
 		cacheDB.addAll(sortDB);
 		cacheDB.addAll(filteredDB);
 		this.numRows = sortDB.getCount();
+		tcControl.scrollToVisible(0,0);
 	}
 	
 	/**



From pfeffer at mail.berlios.de  Sun Jan 21 17:05:38 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 21 Jan 2007 17:05:38 +0100
Subject: [Cachewolf-svn] r425 - trunk/src/CacheWolf
Message-ID: <200701211605.l0LG5cDq002199@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-21 17:05:35 +0100 (Sun, 21 Jan 2007)
New Revision: 425

Modified:
   trunk/src/CacheWolf/Test.java
Log:
Cachewolf.Test direkt startbar
Performance-test von direktem setzen der lat/lon

Modified: trunk/src/CacheWolf/Test.java
===================================================================
--- trunk/src/CacheWolf/Test.java	2007-01-21 15:57:21 UTC (rev 424)
+++ trunk/src/CacheWolf/Test.java	2007-01-21 16:05:35 UTC (rev 425)
@@ -8,9 +8,15 @@
 import java.lang.Math;;
  
 
-public class Test {
+public class Test extends mThread{
 	boolean allPassed=true; 
+	public static void main(String args[]) {
+		new Test().start();
+	}
 
+	public void run() {
+		testAll();
+	}
 	void testAll(){
 		testPerformance();
 /*		testRegex();
@@ -38,8 +44,30 @@
 			CWPoint cwP = new CWPoint("N 51? 27.635 E 009? 37.621", CWPoint.CW);
 		}
 		end = new Time();
-		printResult("CWPoint constructor", start, end, i);
+		printResult("CWPoint(\"N 51? 27.635 E 009? 37.621\", CWPoint.CW)", start, end, i);
 
+		// 1.000 CWPoint via constructor ohne Lat/Lon
+		start = new Time();
+		for (i=0; i<100; i++){
+			CWPoint cwP = new CWPoint();
+			cwP.set("N 51? 27.635 E 009? 37.621", CWPoint.CW);
+			
+		}
+		end = new Time();
+		printResult("cwp = new CWPoint(); cwp.set(\"N 51 27.635 E 009 37.621\", CWPoint.CW); ", start, end, i);
+
+		// 1.000 CWPoint via constructor ohne Lat/Lon
+		start = new Time();
+		CWPoint[] a = new CWPoint[10000];
+		for (i=0; i<10000; i++){
+			CWPoint cwP = new CWPoint(20, 20);
+			cwP.latDec = 41.123;
+			cwP.lonDec = 9.2388;
+			a[i] = cwP;
+		}
+		end = new Time();
+		printResult("cwp = new CWPoint(); cwP.latDec = 41.123; cwP.lonDec = 9.2388;", start, end, i);
+
 		// 1.000 CWPoint via set
 		start = new Time();
 		CWPoint cwSet = new CWPoint();
@@ -47,7 +75,7 @@
 			cwSet.set("N 51? 27.635 E 009? 37.621", CWPoint.CW);
 		}
 		end = new Time();
-		printResult("CWPoint set", start, end, i);
+		printResult("cwSet.set(\"N 51? 27.635 E 009? 37.621\", CWPoint.CW) CWPoint set", start, end, i);
 
 		// 1.000 filewrite
 		String fileName = new String("test.tmp");



From mik77 at mail.berlios.de  Sun Jan 21 18:17:27 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sun, 21 Jan 2007 18:17:27 +0100
Subject: [Cachewolf-svn] r426 - trunk/src/CacheWolf
Message-ID: <200701211717.l0LHHRvs008107@sheep.berlios.de>

Author: mik77
Date: 2007-01-21 18:17:24 +0100 (Sun, 21 Jan 2007)
New Revision: 426

Modified:
   trunk/src/CacheWolf/MapLoader.java
Log:
neue Tile-Berechnung f?\195?\188r den Expedia-Karten Download

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-01-21 16:05:35 UTC (rev 425)
+++ trunk/src/CacheWolf/MapLoader.java	2007-01-21 17:17:24 UTC (rev 426)
@@ -55,16 +55,11 @@
 	 */
 	public void setTiles (CWPoint center, float radius, int scale, Point size, float overlapping) {
 		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixels =  radius * 2 / EXPEDIA_METERS_PER_PIXEL / scale;
-		numMapsY = (int) java.lang.Math.ceil(pixels * overlapping / (float)size.y);
-		numMapsX = (int) java.lang.Math.ceil(pixels * overlapping / (float)size.x);
-		latinc =  -(radius * 2 / metersPerLat) / (float)numMapsY; // = lat difference from buttom to top / number of tiles
-		loninc = ( radius * 2 / metersPerLat / java.lang.Math.cos(center.latDec/180*java.lang.Math.PI) ) / numMapsX;
-		topleft = new CWPoint(center.latDec - latinc * numMapsY / 2, center.lonDec - loninc * numMapsX /2);
-		buttomright = new CWPoint(center.latDec + latinc * numMapsY / 2, center.lonDec + loninc * numMapsX /2);
-		this.tilesSize = new Point();
-		this.tilesSize.set(size);
-		this.tileScale = scale;
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
+		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
+		
+		this.setTiles(topleft, buttomright, scale, size, overlapping);
 	}
 	
 	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, float overlapping) {
@@ -73,30 +68,55 @@
 		buttomright = new CWPoint(buttomrighti);
 		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
 		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
-		double metersY = (topleft.latDec - buttomright.latDec) * metersPerLat; 
-		double pixelsY =  metersY / EXPEDIA_METERS_PER_PIXEL / scale;
-		double metersX = -(topleft.lonDec - buttomright.lonDec) * metersPerLon ; 
-		double pixelsX =  metersX / EXPEDIA_METERS_PER_PIXEL / scale;
-		numMapsY = (int) java.lang.Math.ceil(pixelsY * overlapping / (float)size.y);
-		numMapsX = (int) java.lang.Math.ceil(pixelsX * overlapping / (float)size.x);
-		latinc = -(topleft.latDec - buttomright.latDec)/ (double)numMapsY; // = lat difference from buttom to top / number of tiles
-		loninc = -(topleft.lonDec - buttomright.lonDec)/ (double)numMapsX;
+		
+		double pixelsPerLat = metersPerLat / (EXPEDIA_METERS_PER_PIXEL * scale);
+		double pixelsPerLon = metersPerLon / (EXPEDIA_METERS_PER_PIXEL * scale);
+
+		//over all pixelsize without borders
+		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat; 
+		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
+		
+		//border siezes around given area and overlapping between tiles
+		int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		
+		numMapsY = (int) java.lang.Math.ceil( (pixelsY + (float)borderY) / (float)(size.y - borderY) );
+		numMapsX = (int) java.lang.Math.ceil( (pixelsX + (float)borderX) / (float)(size.x - borderX) );
+		
+		//increments calulated from pixel offset of tiles
+		latinc = (float)(size.y - borderY) / pixelsPerLat;
+		loninc = (float)(size.x - borderX) / pixelsPerLon;
+		
+		//calculation of center of first tile
+		
+		//additional size for borders and rounding
+		double oversizeX = (float)(numMapsX * (size.x - borderX) + borderX) - pixelsX;
+		double oversizeY = (float)(numMapsY * (size.y - borderY) + borderY) - pixelsY;
+		
+		//offset for upper left corner
+		double offsetLat = ( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLat;
+		double offsetLon = -( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLat;
+		
+		topleft.latDec += offsetLat;
+		topleft.lonDec += offsetLon;
+		
 		this.tilesSize = new Point();
 		this.tilesSize.set(size);
 		this.tileScale = scale;
 	}
 
 	public void downlaodTiles(String tilesPath) {
-		int row = 0, col;
-		for (double lat = topleft.latDec; lat >= buttomright.latDec; lat += latinc) {
-			row++;
-			col = 1;
-			for (double lon = topleft.lonDec; lon <= buttomright.lonDec; lon += loninc) {
+		double lat = topleft.latDec;
+		double lon = topleft.lonDec;
+		for (int row = 1; row <= numMapsY; row++) {
+			lon = topleft.lonDec;
+			for (int col = 1; col <= numMapsX; col++) {
 				if (progressInfobox != null)
 					progressInfobox.setInfo("Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile row: "+row+" / "+numMapsY+" coloumn "+ col + "/"+numMapsX);
-				col++;
 				downloadMap(lat, lon, tileScale, tilesSize.x, tilesSize.y, tilesPath);
+				lon += loninc;
 			}
+			lat += latinc;
 		}
 	}
 	



From salzkammergut at mail.berlios.de  Sun Jan 21 19:37:55 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 19:37:55 +0100
Subject: [Cachewolf-svn] r427 - trunk/src/CacheWolf
Message-ID: <200701211837.l0LIbtP4021633@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 19:37:51 +0100 (Sun, 21 Jan 2007)
New Revision: 427

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Bei fehlendem Profilzentrum wird derzeitiges Zentrum als Profilzentrum gespeichert
(Der alte Code funktionierte wegen der ?\195?\132nderungen in CWPoint nicht mehr).


Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-21 17:17:24 UTC (rev 426)
+++ trunk/src/CacheWolf/Profile.java	2007-01-21 18:37:51 UTC (rev 427)
@@ -76,7 +76,7 @@
 			return;
 		}
 		CWPoint savedCentre=centre;
-		if (centre==null || !centre.isValid()) savedCentre=pref.curCentrePt;
+		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 && savedCentre.lonDec==0.0)) savedCentre=pref.curCentrePt;
 		
 		try{
 			detfile.print("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");



From pfeffer at mail.berlios.de  Sun Jan 21 20:31:33 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 21 Jan 2007 20:31:33 +0100
Subject: [Cachewolf-svn] r428 - trunk/src/CacheWolf
Message-ID: <200701211931.l0LJVXnX025324@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-21 20:31:26 +0100 (Sun, 21 Jan 2007)
New Revision: 428

Modified:
   trunk/src/CacheWolf/MapLoader.java
Log:
MapLoader kleiner Fehler mit gro?\195?\159en Auswirkungen behoben

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-01-21 18:37:51 UTC (rev 427)
+++ trunk/src/CacheWolf/MapLoader.java	2007-01-21 19:31:26 UTC (rev 428)
@@ -76,7 +76,7 @@
 		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat; 
 		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
 		
-		//border siezes around given area and overlapping between tiles
+		//border sizes around given area and overlapping between tiles
 		int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
 		int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
 		
@@ -84,7 +84,7 @@
 		numMapsX = (int) java.lang.Math.ceil( (pixelsX + (float)borderX) / (float)(size.x - borderX) );
 		
 		//increments calulated from pixel offset of tiles
-		latinc = (float)(size.y - borderY) / pixelsPerLat;
+		latinc = (float)-(size.y - borderY) / pixelsPerLat;
 		loninc = (float)(size.x - borderX) / pixelsPerLon;
 		
 		//calculation of center of first tile
@@ -94,8 +94,8 @@
 		double oversizeY = (float)(numMapsY * (size.y - borderY) + borderY) - pixelsY;
 		
 		//offset for upper left corner
-		double offsetLat = ( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLat;
-		double offsetLon = -( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLat;
+		double offsetLat = ( ((float)size.y - oversizeY) / 2.0 ) / pixelsPerLat;
+		double offsetLon = -( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLon;
 		
 		topleft.latDec += offsetLat;
 		topleft.lonDec += offsetLon;



From mik77 at mail.berlios.de  Sun Jan 21 21:12:22 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sun, 21 Jan 2007 21:12:22 +0100
Subject: [Cachewolf-svn] r429 - trunk/src/CacheWolf
Message-ID: <200701212012.l0LKCMj6029246@sheep.berlios.de>

Author: mik77
Date: 2007-01-21 21:12:17 +0100 (Sun, 21 Jan 2007)
New Revision: 429

Modified:
   trunk/src/CacheWolf/MapLoader.java
Log:
Vorzeichenfehler behoben

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-01-21 19:31:26 UTC (rev 428)
+++ trunk/src/CacheWolf/MapLoader.java	2007-01-21 20:12:17 UTC (rev 429)
@@ -94,8 +94,8 @@
 		double oversizeY = (float)(numMapsY * (size.y - borderY) + borderY) - pixelsY;
 		
 		//offset for upper left corner
-		double offsetLat = ( ((float)size.y - oversizeY) / 2.0 ) / pixelsPerLat;
-		double offsetLon = -( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		double offsetLat = -( ((float)size.y - oversizeY) / 2.0 ) / pixelsPerLat;
+		double offsetLon = ( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLon;
 		
 		topleft.latDec += offsetLat;
 		topleft.lonDec += offsetLon;



From pfeffer at mail.berlios.de  Sun Jan 21 21:23:06 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 21 Jan 2007 21:23:06 +0100
Subject: [Cachewolf-svn] r430 - trunk/src/CacheWolf
Message-ID: <200701212023.l0LKN6s9029942@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-21 21:22:45 +0100 (Sun, 21 Jan 2007)
New Revision: 430

Modified:
   trunk/src/CacheWolf/CoordsScreen.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Preferences.java
Log:
* CoordsScreen akzeptiert keine ungueltigen Koos mehr. Man muss jetz auf Abbrechen druecken, wenn man den Dialog beenden will, ohne gueltige Koos eingegeben zu haben
* CoordsScreen wird jetzt auch bei der manuellen Kartenkalibrierung verwendet
* nochmal kleinen Fehler bei den Pfaden zu selbstimportierten Karten behoben

Modified: trunk/src/CacheWolf/CoordsScreen.java
===================================================================
--- trunk/src/CacheWolf/CoordsScreen.java	2007-01-21 20:12:17 UTC (rev 429)
+++ trunk/src/CacheWolf/CoordsScreen.java	2007-01-21 20:22:45 UTC (rev 430)
@@ -177,7 +177,8 @@
 			if (ev.target == btnApply){
 				currFormat = chkFormat.getSelectedIndex();
 				readFields(coordInp, currFormat);
-				this.close(IDOK);
+				if (coordInp.isValid()) this.close(IDOK);
+				else (new MessageBox("Error", "Please enter valid coordinates", MessageBox.OKB)).execute();
 			}
 			
 			if (ev.target == btnPaste){

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-01-21 20:12:17 UTC (rev 429)
+++ trunk/src/CacheWolf/Map.java	2007-01-21 20:22:45 UTC (rev 430)
@@ -70,7 +70,7 @@
 		try {
 			wfl.loadwfl(mapsPath, thisMap);
 		}catch(FileNotFoundException ex){
-			Vm.debug("Cannot load world file!");
+		//	Vm.debug("Cannot load world file!");
 		}catch (IOException ex) { // is thrown if lat/lon out of range
 			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
 			tmpMB.execute();
@@ -195,11 +195,7 @@
 		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
 		if(fc.execute() != FormBase.IDCANCEL){
 			File inDir = fc.getChosenFile();
-			File dir = new File(mapsPath);
 			File mapFile;
-			if (!dir.exists()) {
-				dir.createDir();
-			}
 			try{ // TODO better chekcing for IO-Errors / Disk full etc.
 				//User selected a map, but maybe there are more png(s)
 				//copy all of them!
@@ -418,26 +414,16 @@
 		g.free();
 		this.repaintNow();
 		f.updatePosition(pos.x, pos.y);
-		InfoBox inf = new InfoBox((String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
-		if (inf.execute()==InfoBox.IDOK) {
-			String txt = inf.feedback.getText();
-			Regex rex = new Regex("(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})");
-			try {
-				rex.search(txt);
-				if(rex.didMatch()){
-					double lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
-					double lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-					if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = lat * -1;
-					if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = lon * -1;	
-					GCPoint gcp = new GCPoint(lat, lon);
+		
+		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
+		if (cooS.execute()==CoordsScreen.IDOK) {
+					GCPoint gcp = new GCPoint(cooS.getCoords());
 					gcp.bitMapX = pos.x;
 					gcp.bitMapY = pos.y;
 					f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
-				} else { coosInputFormat(); this.removeImage(aImg); }
-			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
-				coosInputFormat();
-				this.removeImage(aImg);
-			}
+//			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
+//				coosInputFormat();
+//				this.removeImage(aImg);
 		} else this.removeImage(aImg); // CANCEL pressed
 	}
 
@@ -458,6 +444,10 @@
 	public GCPoint(){
 	}
 	
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
+	
 	public GCPoint(double lat, double lon){
 		this.latDec = lat;
 		this.lonDec = lon;

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-21 20:12:17 UTC (rev 429)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-21 20:22:45 UTC (rev 430)
@@ -110,7 +110,7 @@
 		this.addLast(mTab);
 	}
 	public String getMapsDir() {
-		return Global.getPref().getMapExpediaPath();
+		return Global.getPref().getMapExpediaSavePath();
 	}
 	public void downloadTiles() {
 		String mapsDir = getMapsDir();

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-21 20:12:17 UTC (rev 429)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-21 20:22:45 UTC (rev 430)
@@ -154,7 +154,7 @@
 				}catch(IOException ex){ 
 					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
 				}catch(ArithmeticException ex){ // affine contain not allowed values 
-					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+mapsPath+dirs.get(j)+"/" + rawFileName+".wfl \n"+ex.toString(), MessageBox.OKB)).exec();
 				} 
 			}
 		}
@@ -224,6 +224,8 @@
 
 
 	public void addMissingOverlays() {
+		boolean saveGPSIgnoreStatus = ignoreGps; // avoid multi-threading problems
+		ignoreGps = true;
 		Point upperleft = getMapPositionOnScreen();
 		int ww = pref.myAppWidth;
 		int wh = pref.myAppHeight;
@@ -243,6 +245,7 @@
 			}
 		}
 		updateOverlayOnlyPos();
+		ignoreGps = saveGPSIgnoreStatus;
 	}
 
 	private void destroyOverlay(int ov) {
@@ -708,19 +711,20 @@
 			this.title = currentMap.mapName;
 			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 			lastCompareY = Integer.MAX_VALUE;
-			if (! (mmp.mapImage == null) ) {
+			if (mmp.mapImage != null ) {
 				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
 				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 
 				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
 				Vm.getUsedMemory(true); // calls the garbage collection
 			} // give memory free before loading the new map to avoid out of memory error
-			if (currentMap.getImageFilename() == null ) {
+			String ImageFilename = currentMap.getImageFilename(); 
+			if (ImageFilename == null ) {
 				mmp.mapImage = new AniImage();
 				(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
 			}
 			else { 
-				if (currentMap.getImageFilename().length()>0) mmp.mapImage = new AniImage(currentMap.getImageFilename()); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				if (ImageFilename.length() > 0) mmp.mapImage = new AniImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
 				else mmp.mapImage = new AniImage();
 			}
 			mapImage1to1 = mmp.mapImage;
@@ -851,7 +855,8 @@
 
 	public void zoom1to1() {
 		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-		zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else zoomFromUnscaled(1, null, center);
 	}
 
 	/**
@@ -1142,7 +1147,6 @@
 							fc.setTitle((String)MyLocale.getMsg(4200,"Select map directory:"));
 							if(fc.execute() != FileChooser.IDCANCEL){
 								mm.loadMaps(fc.getChosen().toString()+"/", mm.posCircleLat);
-								mm.addOverlaySet();
 								mm.forceMapLoad();
 							}
 						}

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-21 20:12:17 UTC (rev 429)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-21 20:22:45 UTC (rev 430)
@@ -170,7 +170,7 @@
 			else return  File.getProgramDirectory() + "/maps";
 		}
 		// expedia dir
-		return getMapExpediaPath(); 
+		return getMapExpediaLoadPath(); 
 	}
 
 	/**
@@ -185,7 +185,7 @@
 	/**
 	 * to this path the automatically downloaded maps are saved
 	 */
-	public String getMapExpediaPath() {
+	public String getMapExpediaSavePath() {
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length());
 		String mapsDir = Global.getPref().baseDir + "/maps/expedia/" + subdir;
 		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
@@ -197,6 +197,9 @@
 		return mapsDir;
 	}
 
+	public String getMapExpediaLoadPath() {
+		return Global.getPref().baseDir + "/maps/expedia/";
+	}
 
 	/**
 	 * Returns true if coordinates have been set.



From pfeffer at mail.berlios.de  Sun Jan 21 22:40:53 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 21 Jan 2007 22:40:53 +0100
Subject: [Cachewolf-svn] r431 - trunk/src/CacheWolf
Message-ID: <200701212140.l0LLerY7002211@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-21 22:40:47 +0100 (Sun, 21 Jan 2007)
New Revision: 431

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Versuch 1:1 Memory-effizienter zu machen
MovingMap: Vorbereitungen fuer anklickbare Caches

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-21 20:22:45 UTC (rev 430)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-21 21:40:47 UTC (rev 431)
@@ -603,7 +603,7 @@
 						if (ch.is_Checked) {
 							//CWPoint tmpll = new CWPoint(ch.LatLon);
 							int ct = Convert.parseInt(ch.type);
-							mmp.addSymbol(ch.CacheName, new AniImage(myTableModel.cacheImages[ct]), ch.pos.latDec, ch.pos.lonDec);
+							mmp.addSymbol(ch.CacheName, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
 						}
 					}
 				}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-21 20:22:45 UTC (rev 430)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-21 21:40:47 UTC (rev 431)
@@ -525,16 +525,16 @@
 		for (int i=symbols.size()-1; i>=0; i--) {
 			symb = (MapSymbol)symbols.get(i);
 			pOnScreen = getXYonScreen(symb.lat, symb.lon);
-			w=symb.pic.getWidth();
-			h=symb.pic.getHeight();
+			w=symb.getWidth();
+			h=symb.getHeight();
 			if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
 			{
-				symb.pic.properties &= ~mImage.IsInvisible;
-				symb.pic.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+				symb.properties &= ~mImage.IsInvisible;
+				symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
 			}
 			else 
-			{symb.pic.properties |= mImage.IsInvisible;
-			symb.pic.move(30, 30);
+			{symb.properties |= mImage.IsInvisible;
+			symb.move(30, 30);
 			}
 			//symb.pic.move(ww+1, wh+1);
 		}
@@ -545,20 +545,19 @@
 		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
 		ms.loadImage();
 		Point pOnScreen=getXYonScreen(lat, lon);
-		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
-		mmp.addImage(ms.pic);
+		mmp.addImage(ms);
 		return ms;
 	}
-	public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
+	public void addSymbol(String name, Image imSymb, double lat, double lon) {
 		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, " ", lat, lon);
-		ms.pic = imSymb;
-		ms.pic.properties = AniImage.AlwaysOnTop;
+		MapSymbol ms = new MapSymbol(name, imSymb, lat, lon);
+		ms.properties = AniImage.AlwaysOnTop;
 		Point pOnScreen=getXYonScreen(lat, lon);
-		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
-		mmp.addImage(ms.pic);
+		mmp.addImage(ms);
 	}
 
 	public void setGotoPosition(double lat, double lon) {
@@ -590,7 +589,7 @@
 	}
 
 	public void removeMapSymbol(int SymNr) {
-		mmp.removeImage(((MapSymbol)symbols.get(SymNr)).pic);
+		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
 		symbols.removeElementAt(SymNr);
 	}
 
@@ -856,7 +855,7 @@
 	public void zoom1to1() {
 		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
 		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		else zoomFromUnscaled(1, null, center);
+		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
 	}
 
 	/**
@@ -873,19 +872,23 @@
 			int saveprop = AniImage.IsMoveable;
 			AniImage tmp = null; // = mmp.mapImage;
 			if (mmp.mapImage != null) {
+				tmp = mmp.mapImage;
 				saveprop = mmp.mapImage.properties;
 				mmp.removeImage(mmp.mapImage);
 				if (mmp.mapImage != mapImage1to1) {
-					mmp.mapImage .free();
+					mmp.mapImage.free();
 					mmp.mapImage = null;
 				} else tmp = mapImage1to1;
 			}
 			Vm.getUsedMemory(true);
 			try {
-				tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				if (zoomFactor == 1) tmp = mapImage1to1;
+				else tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 			} catch (OutOfMemoryError e) {
-				(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();}
+				(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();
+				//tmp = mapImage1to1;
+			} //if (tmp != null) currentMap.zoom();}
 			Vm.getUsedMemory(true);
 			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
@@ -1116,9 +1119,16 @@
 
 	public void penHeld(Point p){
 		//	if (!menuIsActive()) doMenu(p);
+		AniImage clickedOnImage = images.findHotImage(p);
+		if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
+			
+		}
+			
+
 		if (!mm.zoomingMode) // && ev instanceof PenEvent && (
 			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
 		{ //|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )){
+			this.
 			kontextMenu = new Menu();
 			kontextMenu.addItem(gotoMenuItem);
 			kontextMenu.exec(this, new Point(p.x, p.y), this);
@@ -1304,20 +1314,25 @@
 	}
 }
 
-class MapSymbol {
+class MapSymbol extends AniImage {
 	String name;
 	String filename;
 	double lat, lon;
-	AniImage pic;
 	public MapSymbol(String namei, String filenamei, double lati, double loni) {
 		name = namei;
 		filename = filenamei;
 		lat = lati;
 		lon = loni;
 	}
+	public MapSymbol(String namei, Image fromIm, double lati, double loni) {
+		name = namei;
+		setImage(fromIm);
+		lat = lati;
+		lon = loni;
+	}
 	public void loadImage(){
-		pic = new AniImage(filename);
-		pic.properties = AniImage.AlwaysOnTop;
+		setImage(new Image(filename),0); freeSource();;
+		//properties = AniImage.AlwaysOnTop;
 	}
 }
 



From salzkammergut at mail.berlios.de  Sun Jan 21 22:42:23 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 22:42:23 +0100
Subject: [Cachewolf-svn] r432 - in trunk: resources src/CacheWolf
Message-ID: <200701212142.l0LLgN0M002257@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 22:42:05 +0100 (Sun, 21 Jan 2007)
New Revision: 432

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
Log:
Der OK Button am PDA kann optional deaktiviert werden
(damit man CW nicht versehentlich schliesst)
Beenden dann nur ueber das Hauptmenue

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-21 21:40:47 UTC (rev 431)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-21 21:42:05 UTC (rev 432)
@@ -128,7 +128,9 @@
 		627=Tabs oben
 		628=Status zeigen
 		629=Profil auto. laden
-		630=Hinweise/Logs:  Logs pro Seite 
+		630=Hinweise/Logs:  Logs pro Seite
+		631=PDA hat Schliessen Button 
+		632=Mehr
 		700=Filter setzen
 		701=Entfernung
 		702=Schwierigkeit
@@ -422,6 +424,8 @@
 		628=Show status
 		629=Autoload last profile
 		630=HintLogPanel:  Logs per page 
+		631=PDA has close Button
+		632=More
 		700=Set filter
 		701=Distance
 		702=Difficulty

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-21 21:40:47 UTC (rev 431)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-21 21:42:05 UTC (rev 432)
@@ -32,7 +32,8 @@
 		pref.debug = dbg;
 		doIt();
 	}
-	
+	protected void checkButtons() {} // Need to disable checkButtons, otherwise OK-Button is always enabled
+
 	public void doIt(){
 		this.title = "CacheWolf " + Version.getRelease();
 		this.exitSystemOnClose = true;
@@ -42,6 +43,11 @@
 			this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
 			this.resizable = false;
 			this.moveable = false;
+			this.titleOK=new mButton("OK");
+			this.titleOK.borderWidth=0;
+			this.titleOK.foreGround=Color.White;
+			this.titleOK.backGround = Color.DarkBlue;
+			this.windowFlagsToClear=WindowConstants.FLAG_HAS_TITLE;
 		} else 
 			this.setPreferredSize(800, 600);
 		this.resizeOnSIP = true;
@@ -51,6 +57,8 @@
 		infB.waitUntilPainted(1000);
 		try{
 			pref.readPrefFile();
+			if (this.titleOK!=null && !pref.hasCloseButton)
+				this.titleOK.modify(ControlConstants.Disabled,0);
 			addGuiFont();
 			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
 				ewe.sys.Vm.exit(0); // User MUST select or create a profile

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-21 21:40:47 UTC (rev 431)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-21 21:42:05 UTC (rev 432)
@@ -60,6 +60,7 @@
 	public boolean menuAtTop=true;
 	public boolean tabsAtTop=true;
 	public boolean showStatus=true;
+	public boolean hasCloseButton=true;
 	// This setting determines how many logs are shown per page of hintlogs (default 5)
 	public final int DEFAULT_LOGS_PER_PAGE=5;
 	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
@@ -446,6 +447,8 @@
 			menuAtTop=Boolean.valueOf(atts.getValue("menuattop")).booleanValue();
 			tabsAtTop=Boolean.valueOf(atts.getValue("tabsattop")).booleanValue();
 			showStatus=Boolean.valueOf(atts.getValue("showstatus")).booleanValue();
+			if (atts.getValue("hasclosebutton")!=null)
+				hasCloseButton=Boolean.valueOf(atts.getValue("hasclosebutton")).booleanValue();
 		}
 		if (name.equals("hintlogpanel")) {
 			logsPerPage = Convert.parseInt(atts.getValue("logsperpage"));
@@ -520,7 +523,7 @@
 			outp.print("    <fixedsip state = \""+fixSIP+"\"/>\n");
 			outp.print("    <garmin connection = \""+garminConn+"\"/>\n");
 			outp.print("    <lastprofile autoreload=\""+autoReloadLastProfile+"\">"+lastProfile+"</lastprofile>\n"); //RB
-			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\"/>\n");
+			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\" hasclosebutton=\""+hasCloseButton+"\"/>\n");
 			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>\n");
 			outp.print("    <hintlogpanel logsperpage=\""+logsPerPage+"\"/>\n");
 			outp.print("    <solver ignorevariablecase=\""+solverIgnoreCase+"\"/>\n");

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2007-01-21 21:40:47 UTC (rev 431)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2007-01-21 21:42:05 UTC (rev 432)
@@ -17,7 +17,7 @@
 	mChoice NS, EW;
 	mInput NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS, inpLogsPerPage;
 	mCheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, 
-	          chkTabsAtTop, chkShowStatus;
+	          chkTabsAtTop, chkShowStatus,chkHasCloseButton;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
 	
@@ -25,6 +25,7 @@
 	
 	CellPanel pnlGeneral = new CellPanel();
 	CellPanel pnlDisplay = new CellPanel();
+	CellPanel pnlMore = new CellPanel();
 	ScrollBarPanel scp;
 	String [] garminPorts= new String[]{"com1","com2","com3","com4","usb"};
 	
@@ -132,18 +133,21 @@
 		frmHintLog.addNext(inpLogsPerPage=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.WEST);
 		inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
 		pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
-		
+
+		/////////////////////////////////////////////////////////
+		// Third panel - More
+		/////////////////////////////////////////////////////////
+        pnlMore.addLast(chkHasCloseButton=new mCheckBox(MyLocale.getMsg(631,"PDA has close Button")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));	
+        chkHasCloseButton.setState(pref.hasCloseButton);
+
 		mTab.addCard(pnlGeneral,MyLocale.getMsg(621,"General"),null);
 		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,"Screen"),null);
+		mTab.addCard(pnlMore,MyLocale.getMsg(631,"More"),null);
 		//this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		
 		this.addLast(mTab);
 		addNext(cancelB = new mButton(MyLocale.getMsg(614,"Cancel")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		addLast(applyB = new mButton(MyLocale.getMsg(615,"Apply")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-
-	
-
-	
 	}
 	
 	public void onEvent(Event ev){
@@ -187,6 +191,7 @@
 				pref.menuAtTop=chkMenuAtTop.getState();
 				pref.tabsAtTop=chkTabsAtTop.getState();
 				pref.showStatus=chkShowStatus.getState();
+				pref.hasCloseButton=chkHasCloseButton.getState();
 				pref.savePreferences();
 				pref.dirty = true; // Need to update table in case columns were enabled/disabled
 				this.close(0);



From kalli at mail.berlios.de  Sun Jan 21 23:04:03 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 21 Jan 2007 23:04:03 +0100
Subject: [Cachewolf-svn] r433 - trunk/src/exp
Message-ID: <200701212204.l0LM439C003205@sheep.berlios.de>

Author: kalli
Date: 2007-01-21 23:03:57 +0100 (Sun, 21 Jan 2007)
New Revision: 433

Modified:
   trunk/src/exp/Exporter.java
Log:
Bugfix: Caches ohne cache.xml werden bei der Ausgabe uebersprungen, wenn die Details benoetigt werden
        Caches ohne gueltige Koordinaten werden uebersprungen.

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2007-01-21 21:42:05 UTC (rev 432)
+++ trunk/src/exp/Exporter.java	2007-01-21 22:03:57 UTC (rev 433)
@@ -10,6 +10,7 @@
 import ewe.io.PrintWriter;
 import ewe.ui.ProgressBarForm;
 import ewe.util.*;
+import ewe.io.IOException;
 
 /**
  * @author Kalle
@@ -99,18 +100,26 @@
 					expCount++;
 					h.progress = (float)expCount/(float)counter;
 					h.changed();
-					if (needCacheDetails) holder.readCache(profile.dataDir);
+					try {
+						if (needCacheDetails) {
+							holder.readCache(profile.dataDir);
+						}
+					} catch (IOException e) {
+						continue;
+					}
 					switch (this.howManyParams) {
 					case NO_PARAMS: 
 						str = record(holder);
 						break;
 					case LAT_LON:	
 						coords.set(holder.LatLon, CWPoint.CW);
+						if (coords.isValid() == false) continue;
 						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
 						             		 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
 					case LAT_LON|COUNT: 
 						coords.set(holder.LatLon, CWPoint.CW);
+						if (coords.isValid() == false) continue;
 						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
 											 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
 											 i);
@@ -136,9 +145,10 @@
 			if (str != null) outp.print(str);
 			outp.close();
 			pbf.exit(0);
-		}catch (Exception e){
-			Vm.debug("Problem writing to file! "+e.toString());
-		}//try
+		} catch (IOException ioE){
+			Vm.debug("Error opening " + outFile.getName());
+		}
+		//try
 	}
 	/**
 	 * sets mask for filechooser



From salzkammergut at mail.berlios.de  Sun Jan 21 23:05:49 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Jan 2007 23:05:49 +0100
Subject: [Cachewolf-svn] r434 - trunk/src/CacheWolf
Message-ID: <200701212205.l0LM5nFh003279@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-21 23:05:43 +0100 (Sun, 21 Jan 2007)
New Revision: 434

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Bugfix bei fehlender index.xml

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-21 22:03:57 UTC (rev 433)
+++ trunk/src/CacheWolf/Profile.java	2007-01-21 22:05:43 UTC (rev 434)
@@ -127,7 +127,7 @@
 			FileReader in = new FileReader(dataDir + "index.xml");
 			in.readLine(); // <?xml version= ...
 			String text=in.readLine(); // <CACHELIST>
-			if (text.indexOf("decimal")>0) fmtDec=true;
+			if (text!=null && text.indexOf("decimal")>0) fmtDec=true;
 			Extractor ex = new Extractor(null, " = \"", "\" ", 0, true);
 			while ((text = in.readLine()) != null){
 				// Check for Line with cache data



From salzkammergut at mail.berlios.de  Mon Jan 22 00:15:30 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 22 Jan 2007 00:15:30 +0100
Subject: [Cachewolf-svn] r435 - trunk/src/CacheWolf
Message-ID: <200701212315.l0LNFUHg007283@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-22 00:15:26 +0100 (Mon, 22 Jan 2007)
New Revision: 435

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Fix Nullpointer Ex. beim Speichern von Profilen, pos war nicht gesetzt.
Ursache: Beim Spidern muss ch.pos auch gesetzt werden
Derzeit nur in Profile.java gefixt.

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-21 22:05:43 UTC (rev 434)
+++ trunk/src/CacheWolf/Profile.java	2007-01-21 23:15:26 UTC (rev 435)
@@ -72,7 +72,7 @@
 		try{
 		  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dataDir + "index.xml")));
 		} catch (Exception e) {
-		  Vm.debug("Problem creating index file "+e.toString());
+		  Vm.debug("Problem creating index file "+e.toString()+"\nFilename="+dataDir + "index.xml");
 			return;
 		}
 		CWPoint savedCentre=centre;
@@ -98,6 +98,11 @@
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
+					if (ch.pos==null) {
+						ParseLatLon pl=new ParseLatLon(ch.LatLon);
+						pl.parse();
+						ch.pos=new CWPoint(pl.lat2,pl.lon2);
+					}
 					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
 							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
 							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+



From pfeffer at mail.berlios.de  Mon Jan 22 08:49:44 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 22 Jan 2007 08:49:44 +0100
Subject: [Cachewolf-svn] r436 - trunk/src/CacheWolf
Message-ID: <200701220749.l0M7niu3018955@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-22 08:49:40 +0100 (Mon, 22 Jan 2007)
New Revision: 436

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
MovingMap: mit rechtsklick Cachebeschreibung ?\195?\182ffnen
MovingMap: TrackAnzeige sollte jetz keine Fehler mehr machen (muss noch ausfuehrlicher getestet werden) enthaelt im Moment eine Debug-Anzeige

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-21 23:15:26 UTC (rev 435)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-22 07:49:40 UTC (rev 436)
@@ -582,7 +582,7 @@
 				boolean runbefore=false;
 				if (mmp == null) mmp = new MovingMap(pref, this, cacheDB); // this also loads the list of maps
 				else runbefore = true;
-				if (serThread == null || !serThread.isAlive() ) {
+				if (serThread == null || !serThread.isAlive() || !gpsPosition.isValid()) {
 					// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
 					mmp.ignoreGps = false;
 					if (toPoint.isValid())	mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
@@ -603,7 +603,7 @@
 						if (ch.is_Checked) {
 							//CWPoint tmpll = new CWPoint(ch.LatLon);
 							int ct = Convert.parseInt(ch.type);
-							mmp.addSymbol(ch.CacheName, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+							mmp.addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
 						}
 					}
 				}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-21 23:15:26 UTC (rev 435)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-22 07:49:40 UTC (rev 436)
@@ -30,10 +30,10 @@
 	Vector cacheDB;
 	TrackOverlay[] TrackOverlays;
 	Vector tracks;
-	MapInfoObject currentMap;
+	MapInfoObject currentMap = null;
 	String mapPath;
 
-	AniImage mapImage1to1;
+	MapImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal = new AniImage("position_green.png");
 	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
@@ -48,7 +48,7 @@
 	AniImage arrowDown = new AniImage("arrow_down.png");
 	AniImage arrowLeft = new AniImage("arrow_left.png");
 	AniImage arrowRight = new AniImage("arrow_right.png"); */
-	AniImage posCircle = new AniImage("position_green.png");
+	MapImage posCircle = new MapImage("position_green.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
 
@@ -115,11 +115,15 @@
 		mmp.addImage(arrowLeft);
 		mmp.addImage(arrowRight);
 		 */		
-		currentMap = new MapInfoObject();
+//		currentMap = new MapInfoObject();
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(posCircle);
+		mapsloaded = false;
+		posCircleLat = -361;
+		posCircleLon = -361; // make them invalid
 		//loadMaps(Global.getPref().baseDir+"maps/standard/");
+		MapImage.setScreenSize(pref.myAppWidth, pref.myAppHeight);
 	}
 
 	/**
@@ -220,31 +224,36 @@
 		if (TrackOverlays != null) {
 			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
 		}
+		Vm.getUsedMemory(true); // call garbage collection
+		System.gc();
 	}
 
 
 	public void addMissingOverlays() {
+		if (currentMap == null || posCircleLat < -360) return;
 		boolean saveGPSIgnoreStatus = ignoreGps; // avoid multi-threading problems
 		ignoreGps = true;
-		Point upperleft = getMapPositionOnScreen();
 		int ww = pref.myAppWidth;
 		int wh = pref.myAppHeight;
+		Point upperleftOf4 = new Point(posCircleX, posCircleY); //ScreenXY2LatLon(0, 0); // TrackOverlay[4] == center of Trackoverlays 
+		upperleftOf4.x = upperleftOf4.x % ww;
+		upperleftOf4.y = upperleftOf4.y % wh;
 		int i;
 		if (TrackOverlays == null) TrackOverlays = new TrackOverlay[9];
 		for (int yi=0; yi<3; yi++) {
 			for (int xi=0; xi<3; xi++) {
 				i = yi*3+xi;
 				if (TrackOverlays[i]==null) { 
-					TrackOverlays[i]= new TrackOverlay(currentMap.calcLatLon(-upperleft.x+(xi-1)*ww, -upperleft.y+(yi-1)*wh), ww, wh, currentMap); 
-					TrackOverlays[i].properties |= mImage.IsInvisible;
-					TrackOverlays[i].move(0, 0);
+					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*ww, upperleftOf4.y+(yi-1)*wh), ww, wh, currentMap); 
+					TrackOverlays[i].setLocation(ww+1, wh+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
-					//	mmp.addImage(TrackOverlays[i]);
+					mmp.addImage(TrackOverlays[i]);
 				}
 			}
 		}
 		updateOverlayOnlyPos();
+		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
 		ignoreGps = saveGPSIgnoreStatus;
 	}
 
@@ -256,51 +265,91 @@
 	}
 	public void rearangeOverlays() {
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
+			destroyOverlay(6);
+			destroyOverlay(7);
+			destroyOverlay(8);
+			mmp.removeImage(TrackOverlays[0]);
+			mmp.removeImage(TrackOverlays[1]);
+			mmp.removeImage(TrackOverlays[2]);
 			TrackOverlays[6]=TrackOverlays[0];
 			TrackOverlays[7]=TrackOverlays[1];
 			TrackOverlays[8]=TrackOverlays[2];
-			destroyOverlay(0);
-			destroyOverlay(1);
-			destroyOverlay(2);
+			mmp.addImage(TrackOverlays[6]);
+			mmp.addImage(TrackOverlays[7]);
+			mmp.addImage(TrackOverlays[8]);
+			TrackOverlays[0] = null;
+			TrackOverlays[1] = null;
+			TrackOverlays[2] = null;
 			destroyOverlay(3);
 			destroyOverlay(4);
 			destroyOverlay(5);
 		} else {
 			if (TrackOverlays[3].isOnScreen()) { // links raus
+				destroyOverlay(2);
+				destroyOverlay(5);
+				destroyOverlay(8);
+				mmp.removeImage(TrackOverlays[0]);
+				mmp.removeImage(TrackOverlays[3]);
+				mmp.removeImage(TrackOverlays[6]);
 				TrackOverlays[2]=TrackOverlays[0];
 				TrackOverlays[5]=TrackOverlays[3];
 				TrackOverlays[8]=TrackOverlays[6];
-				destroyOverlay(0);
+				mmp.addImage(TrackOverlays[2]);
+				mmp.addImage(TrackOverlays[5]);
+				mmp.addImage(TrackOverlays[8]);
+				TrackOverlays[0] = null;
+				TrackOverlays[3] = null;
+				TrackOverlays[6] = null;
 				destroyOverlay(1);
-				destroyOverlay(3);
 				destroyOverlay(4);
-				destroyOverlay(6);
 				destroyOverlay(7);
 			} else {
 				if (TrackOverlays[5].isOnScreen()) { // rechts raus
+					destroyOverlay(0);
+					destroyOverlay(3);
+					destroyOverlay(6);
+					mmp.removeImage(TrackOverlays[2]);
+					mmp.removeImage(TrackOverlays[5]);
+					mmp.removeImage(TrackOverlays[8]);
 					TrackOverlays[0]=TrackOverlays[2];
 					TrackOverlays[3]=TrackOverlays[5];
 					TrackOverlays[6]=TrackOverlays[8];
+					mmp.addImage(TrackOverlays[0]);
+					mmp.addImage(TrackOverlays[3]);
+					mmp.addImage(TrackOverlays[6]);
+					TrackOverlays[2] = null;
+					TrackOverlays[5] = null;
+					TrackOverlays[8] = null;
 					destroyOverlay(1);
-					destroyOverlay(2);
 					destroyOverlay(4);
-					destroyOverlay(5);
 					destroyOverlay(7);
-					destroyOverlay(8);
 				} else {
 					if (TrackOverlays[7].isOnScreen()) { // unten raus
+						destroyOverlay(0);
+						destroyOverlay(1);
+						destroyOverlay(2);
+						mmp.removeImage(TrackOverlays[6]);
+						mmp.removeImage(TrackOverlays[7]);
+						mmp.removeImage(TrackOverlays[8]);
 						TrackOverlays[0]=TrackOverlays[6];
 						TrackOverlays[1]=TrackOverlays[7];
 						TrackOverlays[2]=TrackOverlays[8];
+						mmp.addImage(TrackOverlays[0]);
+						mmp.addImage(TrackOverlays[1]);
+						mmp.addImage(TrackOverlays[2]);
+						TrackOverlays[6] = null;
+						TrackOverlays[7] = null;
+						TrackOverlays[8] = null;
 						destroyOverlay(3);
 						destroyOverlay(4);
 						destroyOverlay(5);
-						destroyOverlay(6);
-						destroyOverlay(7);
-						destroyOverlay(8);
 					} else { // it is important to test for diagonal only if the other didn't match
 						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
-							destroyOverlay(0);
+							destroyOverlay(8);
+							mmp.removeImage(TrackOverlays[0]);
+							TrackOverlays[8]=TrackOverlays[0];
+							mmp.addImage(TrackOverlays[8]);
+							TrackOverlays[0] = null;
 							destroyOverlay(1);
 							destroyOverlay(2);
 							destroyOverlay(3);
@@ -308,13 +357,15 @@
 							destroyOverlay(5);
 							destroyOverlay(6);
 							destroyOverlay(7);
-							TrackOverlays[8]=TrackOverlays[0];
 						} else {
 							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
+								destroyOverlay(6);
+								mmp.removeImage(TrackOverlays[2]);
 								TrackOverlays[6]=TrackOverlays[2];
+								mmp.addImage(TrackOverlays[6]);
+								TrackOverlays[2] = null;
 								destroyOverlay(0);
 								destroyOverlay(1);
-								destroyOverlay(2);
 								destroyOverlay(3);
 								destroyOverlay(4);
 								destroyOverlay(5);
@@ -322,18 +373,25 @@
 								destroyOverlay(8);
 							} else {
 								if (TrackOverlays[6].isOnScreen()) { // links unten raus
+									destroyOverlay(2);
+									mmp.removeImage(TrackOverlays[6]);
 									TrackOverlays[2]=TrackOverlays[6];
+									mmp.addImage(TrackOverlays[2]);
+									TrackOverlays[6] = null;
 									destroyOverlay(0);
 									destroyOverlay(1);
 									destroyOverlay(3);
 									destroyOverlay(4);
 									destroyOverlay(5);
-									destroyOverlay(6);
 									destroyOverlay(7);
 									destroyOverlay(8);
 								} else {
 									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
+										destroyOverlay(0);
+										mmp.removeImage(TrackOverlays[8]);
 										TrackOverlays[0]=TrackOverlays[8];
+										mmp.addImage(TrackOverlays[0]);
+										TrackOverlays[8] = null;
 										destroyOverlay(1);
 										destroyOverlay(2);
 										destroyOverlay(3);
@@ -341,10 +399,11 @@
 										destroyOverlay(5);
 										destroyOverlay(6);
 										destroyOverlay(7);
-										destroyOverlay(8);
 									}else
 										for (int i=0; i<TrackOverlays.length; i++) {destroyOverlay(i);} // this happens if a position jump occured
 								}}}}}}} // close all IFs
+		Vm.getUsedMemory(true); // call garbage collection
+		System.gc();
 		Vm.debug("Overlayrearanged"+TrackOverlays.toString());
 	}
 
@@ -364,30 +423,28 @@
 		int ww = ws.width;
 		int wh = ws.height;
 		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		int num, x, y;
 		for (int yi=0; yi<3; yi++) {
 			for (int xi=0; xi<3; xi++) {
-				if (posOnScreen.x +ww >=0 && posOnScreen.x <= ww && posOnScreen.y + wh >=0 && posOnScreen.y <= wh)
-				{
-					if ((TrackOverlays[yi*3+xi].properties & mImage.IsInvisible) > 0) mmp.addImage(TrackOverlays[yi*3+xi]);
-					TrackOverlays[yi*3+xi].properties &= ~mImage.IsInvisible;
-					TrackOverlays[yi*3+xi].move(posOnScreen.x+(xi-1)*ww, posOnScreen.y+(yi-1)*wh);
-				} else {
-					if ((TrackOverlays[yi*3+xi].properties & mImage.IsInvisible) == 0) mmp.removeImage(TrackOverlays[yi*3+xi]);
-					TrackOverlays[yi*3+xi].properties |= mImage.IsInvisible;
-					TrackOverlays[yi*3+xi].move(30, 30);
-				}
+				num = yi*3+xi;
+				x = posOnScreen.x+(xi-1)*ww;
+				y = posOnScreen.y+(yi-1)*wh; 
+				TrackOverlays[num].setLocation(x, y);
 			}
 		}
 	}
 
 	public void updateOverlayPos() {
-		if (TrackOverlays == null || TrackOverlays[4] == null) return;
-		updateOverlayOnlyPos();
-		if (TrackOverlays[0].location.x>pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth < 0 || // testForNeedToRearange
-				TrackOverlays[0].location.y>pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight <0) {
-			rearangeOverlays();
-			addMissingOverlays();
-			// updateOverlayOnlyPos(); is called from addMissingOverlays 
+		if (tracks == null || tracks.size() == 0) return;
+		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		else {
+			updateOverlayOnlyPos();
+			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0
+					|| TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
+				rearangeOverlays();
+				addMissingOverlays();
+				// updateOverlayOnlyPos(); is called from addMissingOverlays 
+			}
 		}
 	}
 
@@ -462,14 +519,7 @@
 		int h = posCircle.getHeight();
 		int npx = posCircleX-w/2+diffX; 
 		int npy = posCircleY-h/2+diffY;
-		if (npx+w >= 0 && npx <= this.width && npy+h >= 0 && npy < this.height)	
-		{
-			posCircle.properties &= ~AniImage.IsInvisible;
-			posCircle.move(npx, npy);
-		} else {
-			posCircle.properties |= AniImage.IsInvisible;
-			posCircle.move(0,0);
-		}
+		posCircle.move(npx, npy);
 		posCircleX = posCircleX+diffX;
 		posCircleY = posCircleY+diffY;
 		updateSymbolPositions();
@@ -485,6 +535,7 @@
 	 * @return
 	 */
 	public Point getMapPositionOnScreen() {
+		if (currentMap == null || posCircleLon < -360) return new Point(pref.myAppWidth +1, pref.myAppHeight +1); // in case no calculation is possible return somthing outside of the screen
 		Point mapPos = new Point(); 
 		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
 		//else {
@@ -502,6 +553,7 @@
 	 * @return
 	 */
 	public Point getXYonScreen(double lat, double lon){
+		if (currentMap == null) return null;
 		Point coords = currentMap.calcMapXY(lat, lon);
 		Point mapPos = getMapPositionOnScreen();
 		//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
@@ -550,12 +602,12 @@
 		mmp.addImage(ms);
 		return ms;
 	}
-	public void addSymbol(String name, Image imSymb, double lat, double lon) {
+	public void addSymbol(String name, Object mapObject, Image imSymb, double lat, double lon) {
 		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, imSymb, lat, lon);
+		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, lat, lon);
 		ms.properties = AniImage.AlwaysOnTop;
 		Point pOnScreen=getXYonScreen(lat, lon);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 	}
@@ -622,7 +674,7 @@
 		if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
 			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
 			updateSymbolPositions();
-			if (updateOverlay && TrackOverlays != null) updateOverlayPos();
+			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
 			//}
 			mmp.repaintNow(); // TODO test if the "if" above can be used
 		}
@@ -632,7 +684,15 @@
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
 	 */
 	public void updatePosition(double lat, double lon){
-		if (!mapsloaded) loadMaps(mapPath, lat);
+		if (!mapsloaded) {
+			loadMaps(mapPath, lat);
+			lastCompareX = Integer.MAX_VALUE;
+			lastCompareY = Integer.MAX_VALUE;
+			setBestMap(lat, lon);
+			forceMapLoad = false;
+			return;
+
+		}
 		lastUpatePosition.latDec=lat;
 		lastUpatePosition.lonDec=lon;
 		if(!ignoreGps || forceMapLoad){
@@ -646,21 +706,24 @@
 						// more then 1/10 of screen moved since last time we tried to find a better map
 						lastCompareX = mapPos.x;
 						lastCompareY = mapPos.y;
-//						Vm.debug("look for a bettermap");
-						int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -> may be it would be better to call it with the coos of the center of the window?, nein, es k?nnte st?ren, wenn man manuell die Karte bewegt und er st?ndig ne neue l?d... bleibt erstmal so
-						MapInfoObject newmap ;
-						newmap = (MapInfoObject) maps.get(newMapN);
-						if (!(currentMap.mapName == newmap.mapName)) {
-							setMap(newmap, lat, lon);
-							Vm.debug("better map found");
-							// use new map
-						}
+						setBestMap(lat, lon);
 						forceMapLoad = false;
 					}
 				}
 			}
 		}
 	}
+	
+	public void setBestMap(double lat, double lon) {
+		int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -> may be it would be better to call it with the coos of the center of the window?, nein, es k?nnte st?ren, wenn man manuell die Karte bewegt und er st?ndig ne neue l?d... bleibt erstmal so
+		MapInfoObject newmap ;
+		newmap = (MapInfoObject) maps.get(newMapN);
+		if (currentMap == null || currentMap.mapName != newmap.mapName) {
+			setMap(newmap, lat, lon);
+			Vm.debug("better map found");
+		}
+		
+	}
 
 	public void setGpsStatus (int status) {
 		if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
@@ -694,7 +757,7 @@
 	 * @param lon -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, double lat, double lon) {
-		if (newmap.mapName == currentMap.mapName && !forceMapLoad) {
+		if (currentMap != null && newmap.mapName == currentMap.mapName && !forceMapLoad) {
 			updateOnlyPosition(lat, lon, true); 
 			return;
 		}
@@ -719,12 +782,12 @@
 			} // give memory free before loading the new map to avoid out of memory error
 			String ImageFilename = currentMap.getImageFilename(); 
 			if (ImageFilename == null ) {
-				mmp.mapImage = new AniImage();
+				mmp.mapImage = new MapImage();
 				(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
 			}
 			else { 
-				if (ImageFilename.length() > 0) mmp.mapImage = new AniImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
-				else mmp.mapImage = new AniImage();
+				if (ImageFilename.length() > 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new MapImage();
 			}
 			mapImage1to1 = mmp.mapImage;
 			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
@@ -870,7 +933,7 @@
 		if (mapImage1to1 != null) {
 			ignoreGps = true; // avoid multi-thread problems
 			int saveprop = AniImage.IsMoveable;
-			AniImage tmp = null; // = mmp.mapImage;
+			MapImage tmp = null; // = mmp.mapImage;
 			if (mmp.mapImage != null) {
 				tmp = mmp.mapImage;
 				saveprop = mmp.mapImage.properties;
@@ -883,7 +946,7 @@
 			Vm.getUsedMemory(true);
 			try {
 				if (zoomFactor == 1) tmp = mapImage1to1;
-				else tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 			} catch (OutOfMemoryError e) {
 				(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();
@@ -931,8 +994,10 @@
 	Menu mapsMenu;
 	Menu kontextMenu;
 	MenuItem gotoMenuItem;
+	MenuItem openCacheDescMenuItem;
+	CacheHolder clickedCache;
 	MovingMap mm;
-	AniImage mapImage;
+	MapImage mapImage;
 	Point saveMapLoc = null;
 	boolean saveGpsIgnoreStatus;
 	boolean paintingZoomArea;
@@ -956,14 +1021,16 @@
 		mm.ignoreGps = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		return super.imageBeginDragged(mapImage, pos);
+		if (mapImage.isOnScreen()) return super.imageBeginDragged(mapImage, pos);
+		else return super.imageBeginDragged(null, pos);
 	}
 
 	public boolean imageNotDragged(ImageDragContext dc,Point pos){
 		boolean ret = super.imageNotDragged(dc, pos);
-		mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		bringMaptoBack();
+		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 		mm.ignoreGps = saveGpsIgnoreStatus;
-		bringMaptoBack();
 		this.repaintNow();
 		return ret;
 	}
@@ -1032,7 +1099,7 @@
 	public void moveMap(int diffX, int diffY) {
 		Point p = new Point();
 		if (mapImage!= null) {
-			p = mapImage.getLocation(null);
+			p = mapImage.locAlways;
 			mapImage.move(p.x+diffX,p.y+diffY);
 		}
 		mapMoved(diffX, diffY);
@@ -1119,18 +1186,17 @@
 
 	public void penHeld(Point p){
 		//	if (!menuIsActive()) doMenu(p);
-		AniImage clickedOnImage = images.findHotImage(p);
-		if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
-			
-		}
-			
-
 		if (!mm.zoomingMode) // && ev instanceof PenEvent && (
 			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
-		{ //|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )){
-			this.
+		{ //|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )){		
 			kontextMenu = new Menu();
 			kontextMenu.addItem(gotoMenuItem);
+			AniImage clickedOnImage = images.findHotImage(p);
+			if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
+				clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
+				openCacheDescMenuItem = new MenuItem("Open "+clickedCache.CacheName);
+				kontextMenu.addItem(openCacheDescMenuItem);
+			}
 			kontextMenu.exec(this, new Point(p.x, p.y), this);
 		}
 	}
@@ -1181,6 +1247,17 @@
 						kontextMenu.close();
 						mm.gotoPanel.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
 					}
+					if (kontextMenu.getSelectedItem() == openCacheDescMenuItem) {
+						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm;
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						mm.gotoPanel.mainT.tbP.selectAndActive(mm.cacheDB.find(clickedCache));
+						mm.gotoPanel.mainT.select(mm.gotoPanel.mainT.descP);
+						mm.gotoPanel.mainT.openDesciptionPanel(clickedCache);
+					}
 				}
 			} // if (ev.target == kontextMenu)
 		} // if (ev instanceof ControlEvent ) 
@@ -1315,6 +1392,7 @@
 }
 
 class MapSymbol extends AniImage {
+	Object mapObject;
 	String name;
 	String filename;
 	double lat, lon;
@@ -1324,11 +1402,12 @@
 		lat = lati;
 		lon = loni;
 	}
-	public MapSymbol(String namei, Image fromIm, double lati, double loni) {
+	public MapSymbol(String namei, Object mapObjecti, Image fromIm, double lati, double loni) {
 		name = namei;
-		setImage(fromIm);
 		lat = lati;
 		lon = loni;
+		mapObject = mapObjecti;
+		setImage(fromIm);
 	}
 	public void loadImage(){
 		setImage(new Image(filename),0); freeSource();;
@@ -1438,3 +1517,61 @@
 	}
 }
 
+/** 
+ * class that can be used with any x and any y
+ * it will save taht location and make itself automatically
+ * invisible if it is not on the screen. Call setscreensize to
+ * set the screensize
+ * @author r
+ *
+ */
+class MapImage extends AniImage {
+	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
+	static Dimension screenDim;
+	
+	public MapImage() {
+		super();
+	}
+	
+	public MapImage(String f) {
+		super(f);
+	}
+	
+	public MapImage(mImage im) {
+		super(im);
+	}
+	public static void setScreenSize(int w, int h) {
+		screenDim = new Dimension(w, h);
+	}
+	public void setLocation (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (isOnScreen()) { 
+			super.setLocation(x, y);
+			properties &= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+	
+	public void move (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (isOnScreen()) { 
+			super.move(x, y);
+			properties &= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+		
+	public boolean isOnScreen() { // i assume that location.width = screen.width and the same for hight
+		if ( (locAlways.x + screenDim.width > 0 && locAlways.x < screenDim.width) && 
+				(locAlways.y + screenDim.height > 0 && locAlways.y < screenDim.height) ) return true;
+		else return false;
+	}
+}
+	
+

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-01-21 23:15:26 UTC (rev 435)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-01-22 07:49:40 UTC (rev 436)
@@ -13,7 +13,7 @@
 import ewe.util.Vector;
 
 
-public class TrackOverlay extends AniImage {
+public class TrackOverlay extends MapImage {
 	TrackPoint topLeft;
 	TrackPoint bottomRight;
 	Graphics draw;
@@ -40,6 +40,8 @@
 
 	
 	public void paintTracks() {
+		draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
+		draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
 		if (tracks == null || tracks.size() == 0) return;
 		int tri, i;
 		Track tr;
@@ -65,7 +67,7 @@
 		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
 		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
 		//draw.drawLine(x, y, x, y);
-		ewe.sys.Vm.debug("showlastaddedpoint, x: "+x+"   y: "+y+"loc.x: "+location.x+"  loc.y:"+location.y);
+		//ewe.sys.Vm.debug("showlastaddedpoint, x: "+x+"   y: "+y+"loc.x: "+location.x+"  loc.y:"+location.y);
 		draw.fillRect(x-1, y-1, 3, 3);
 		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
 			int yd;
@@ -132,12 +134,6 @@
 		paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec);
 	}
 
-	public boolean isOnScreen() { // i assume that location.width = screen.width and the same for hight
-		if ( (location.x + location.width > 0 && location.x < location.width) || 
-				(location.y + location.height > 0 && location.y < location.height) ) return true;
-		else return false;
-	}
-	
 	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
 		super.doDraw(g, options);
 		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside



From bilbowolf at mail.berlios.de  Mon Jan 22 11:11:27 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Mon, 22 Jan 2007 11:11:27 +0100
Subject: [Cachewolf-svn] r437 - trunk/src/CacheWolf
Message-ID: <200701221011.l0MABRQm030567@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-22 11:11:25 +0100 (Mon, 22 Jan 2007)
New Revision: 437

Modified:
   trunk/src/CacheWolf/Version.java
Log:
Neue BE Version

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-01-22 07:49:40 UTC (rev 436)
+++ trunk/src/CacheWolf/Version.java	2007-01-22 10:11:25 UTC (rev 437)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " BE ";
-	static final String VER_SVN ="$LastChangedRevision$"; //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From admin at berlios.de  Mon Jan 22 13:25:03 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 22 Jan 2007 03:25:03 -0900 (AKST)
Subject: [Cachewolf-svn] [Bug #9930] SpiderGC: <Enter> im Passworteingabe
Message-ID: <200701221225.l0MCP3TH004175@unicorn.berlios.de>

Bug #9930, was updated on 2007-Jan-10 13:39
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: pfeffer
Assigned to : cw-tester
Summary: SpiderGC: <Enter> im Passworteingabe

Details: beim SpiderGC <Enter> im Passworteingabe bewirkte abbruch, jetzt sind <enter> und <ESC> f?r die Richtigen Buttons aktiviert

Follow-Ups:

Date: 2007-Jan-22 03:25
By: cw-tester

Comment:
ist OK!!
-------------------------------------------------------

Date: 2007-Jan-10 14:45
By: pfeffer

Comment:
erledigt mit svn: 378
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9930&group_id=2211


From admin at berlios.de  Mon Jan 22 13:28:00 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 22 Jan 2007 03:28:00 -0900 (AKST)
Subject: [Cachewolf-svn] [Feature #3031] Doppelklick in der Cacheliste
Message-ID: <200701221228.l0MCS01I013049@unicorn.berlios.de>

Feature Request #3031, was updated on 2007-Jan-08 15:58
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Doppelklick in der Cacheliste 

By: cw-tester
Date: 2007-Jan-22 03:27

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

ist OK!!

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-10 14:48

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

erldigt gem??t absprache im ersten Posting verlinken Forum
mit SVN: 379

Gru?,
  Pfeffer.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211


From admin at berlios.de  Mon Jan 22 13:45:16 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 22 Jan 2007 03:45:16 -0900 (AKST)
Subject: [Cachewolf-svn] [Bug #10090] Darstellung der gefundenen Caches
Message-ID: <200701221245.l0MCjGAJ005231@unicorn.berlios.de>

Bug #10090, was updated on 2007-Jan-22 03:45
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: cw-tester
Assigned to : none
Summary: Darstellung der gefundenen Caches

Details: Wenn ich eine GPX.Datei lade werden die gefundenen Caches gr?n dargestellt. Der Status ist aber leer. Erst wenn ich in Details gehe schaltet der Status auf gefunden.

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10090&group_id=2211


From pfeffer at mail.berlios.de  Mon Jan 22 17:27:26 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 22 Jan 2007 17:27:26 +0100
Subject: [Cachewolf-svn] r438 - trunk/src/CacheWolf
Message-ID: <200701221627.l0MGRQST006601@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-22 17:27:20 +0100 (Mon, 22 Jan 2007)
New Revision: 438

Modified:
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Preferences.java
Log:
MovingMap: Track wird auf dem PDA nicht mehr auseinander gerissen
MovingMap: Lupe usw. wird neu positioniert, wenn man die Fenstergr?\195?\182?\195?\159e ?\195?\164ndert

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-22 10:11:25 UTC (rev 437)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-22 16:27:20 UTC (rev 438)
@@ -23,7 +23,6 @@
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
-	//AniImage mapImage;
 	Vector maps;
 	Vector symbols;
 	GotoPanel gotoPanel;
@@ -44,10 +43,6 @@
 	AniImage buttonImageLens = new AniImage("lupe.png");
 	AniImage buttonImageLensActivated = new AniImage("lupe_activated.png");
 	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
-	/*AniImage arrowUp = new AniImage("arrow_up.png");
-	AniImage arrowDown = new AniImage("arrow_down.png");
-	AniImage arrowLeft = new AniImage("arrow_left.png");
-	AniImage arrowRight = new AniImage("arrow_right.png"); */
 	MapImage posCircle = new MapImage("position_green.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
@@ -73,7 +68,8 @@
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		this.title = "Moving Map";
 		this.backGround = Color.Black;
-		this.mapPath = Global.getPref().getMapLoadPath()+"/";
+		this.mapPath = Global.getPref().getMapLoadPath();
+
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
@@ -83,49 +79,40 @@
 		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
 		closeX.doDraw(tmp, 0);
 		bottonImageClose.properties |= AniImage.AlwaysOnTop;
-		bottonImageClose.setLocation(Global.getPref().myAppWidth - bottonImageClose.getWidth()- 5, 5);
 		mmp.addImage(bottonImageClose);
-		buttonImageGpsOn.setLocation(pref.myAppWidth - bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
 		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageGpsOn);
-		bottonImageChooseMap.setLocation(10,10);
 		bottonImageChooseMap.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(bottonImageChooseMap);
 		directionArrows.properties = AniImage.AlwaysOnTop;
-		directionArrows.setLocation(Global.getPref().myAppWidth/2-directionArrows.getWidth()/2, 10);
 		mmp.addImage(directionArrows);
-		buttonImageLens.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
 		buttonImageLens.properties = AniImage.AlwaysOnTop;
 		buttonImageLensActivated.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
 		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageLens);
-		buttonImageZoom1to1.setLocation(Global.getPref().myAppWidth - buttonImageZoom1to1.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageZoom1to1);
-		/*		arrowUp.setLocation(pref.myAppWidth/2, 10);
-		arrowDown.setLocation(pref.myAppWidth/2, pref.myAppHeight-20);
-		arrowLeft.setLocation(10, pref.myAppHeight/2+7);
-		arrowRight.setLocation(pref.myAppWidth-25, pref.myAppHeight/2+7);
-		arrowUp.properties = AniImage.AlwaysOnTop;
-		arrowDown.properties = AniImage.AlwaysOnTop;
-		arrowLeft.properties = AniImage.AlwaysOnTop;
-		arrowRight.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(arrowUp);
-		mmp.addImage(arrowDown);
-		mmp.addImage(arrowLeft);
-		mmp.addImage(arrowRight);
-		 */		
-//		currentMap = new MapInfoObject();
+		resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(posCircle);
 		mapsloaded = false;
 		posCircleLat = -361;
 		posCircleLon = -361; // make them invalid
-		//loadMaps(Global.getPref().baseDir+"maps/standard/");
-		MapImage.setScreenSize(pref.myAppWidth, pref.myAppHeight);
 	}
 
+	public void resizeTo(int w,int h) {
+		super.resizeTo(w, h);
+		MapImage.setScreenSize(w, h);
+		bottonImageClose.setLocation(w- bottonImageClose.getWidth()- 5, 5);
+		buttonImageGpsOn.setLocation(w- bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
+		bottonImageChooseMap.setLocation(10,10);
+		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
+		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
+		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		// TODO TrackOverlay-gr??e muss angepasst werden
+	}
+	
 	/**
 	 * loads the list of maps
 	 *
@@ -142,6 +129,7 @@
 		File files = new File(mapsPath);
 		String rawFileName = new String();
 		String[] dirstmp = files.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_DIRECTORIES_ONLY);
+		Vm.debug(dirstmp.length + dirstmp.toString() + dirstmp[0]);
 		Vector dirs = new Vector(dirstmp);
 		dirs.add("."); // include the mapsPath itself
 		MapInfoObject tempMIO;
@@ -153,7 +141,7 @@
 				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
 				try {
 					tempMIO = new MapInfoObject();
-					tempMIO.loadwfl(mapsPath+dirs.get(j)+"/", rawFileName);
+					tempMIO.loadwfl(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
 					maps.add(tempMIO);
 				}catch(IOException ex){ 
 					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
@@ -190,7 +178,8 @@
 	public final FormFrame myExec() {
 		//addOverlaySet(); // neccessary to draw points which were added when the MovingMap was not running, so that these pixels are not stored in the not-immediately-drawing-work-around
 		// doShowExec(null,null,true,Gui.NEW_WINDOW & ~Form.PageHigher);
-		return exec();
+		FormFrame ret = exec();
+		return ret;
 	}
 	public void addTrack(Track tr) {
 		if (tr == null) return;
@@ -233,8 +222,9 @@
 		if (currentMap == null || posCircleLat < -360) return;
 		boolean saveGPSIgnoreStatus = ignoreGps; // avoid multi-threading problems
 		ignoreGps = true;
-		int ww = pref.myAppWidth;
-		int wh = pref.myAppHeight;
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
 		Point upperleftOf4 = new Point(posCircleX, posCircleY); //ScreenXY2LatLon(0, 0); // TrackOverlay[4] == center of Trackoverlays 
 		upperleftOf4.x = upperleftOf4.x % ww;
 		upperleftOf4.y = upperleftOf4.y % wh;
@@ -570,9 +560,8 @@
 		if (symbols == null) return;
 		Point pOnScreen;
 		MapSymbol symb;
-		Dimension ws = mmp.getSize(null);
-		int ww = ws.width;
-		int wh = ws.height;
+		int ww = this.width;
+		int wh = this.height;
 		int w, h;
 		for (int i=symbols.size()-1; i>=0; i--) {
 			symb = (MapSymbol)symbols.get(i);
@@ -974,7 +963,14 @@
 		ignoreGps = savegpsstatus;
 	}
 
-
+/*	public void gotFocus(int how) {
+		super.gotFocus(how);
+		Dimension ws = getSize(null);
+		onWindowResize(ws.width, ws.height);
+		Vm.debug(ws.width + " h: "+ws.height);
+		this.setPreferredSize(width, height)
+	}
+*/
 	public void onEvent(Event ev){
 		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
 			gotoPanel.runMovingMap = false;
@@ -1222,7 +1218,7 @@
 							fc.addMask("*.wfl");
 							fc.setTitle((String)MyLocale.getMsg(4200,"Select map directory:"));
 							if(fc.execute() != FileChooser.IDCANCEL){
-								mm.loadMaps(fc.getChosen().toString()+"/", mm.posCircleLat);
+								mm.loadMaps(fc.getChosen().toString(), mm.posCircleLat);
 								mm.forceMapLoad();
 							}
 						}
@@ -1528,21 +1524,35 @@
 class MapImage extends AniImage {
 	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
 	static Dimension screenDim;
-	
+	public int widthi;
+	public int heighti;
 	public MapImage() {
 		super();
+		widthi = getWidth();
+		heighti = getHeight();
 	}
 	
 	public MapImage(String f) {
 		super(f);
+		widthi = getWidth();
+		heighti = getHeight();
 	}
 	
 	public MapImage(mImage im) {
 		super(im);
+		widthi = getWidth();
+		heighti = getHeight();
 	}
 	public static void setScreenSize(int w, int h) {
 		screenDim = new Dimension(w, h);
 	}
+	
+	public void setImage(Image im, Color c) {
+		super.setImage(im, c);
+		widthi = getWidth();
+		heighti = getHeight();
+	}
+	
 	public void setLocation (int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
@@ -1567,10 +1577,13 @@
 		}
 	}
 		
-	public boolean isOnScreen() { // i assume that location.width = screen.width and the same for hight
-		if ( (locAlways.x + screenDim.width > 0 && locAlways.x < screenDim.width) && 
-				(locAlways.y + screenDim.height > 0 && locAlways.y < screenDim.height) ) return true;
-		else return false;
+	public boolean isOnScreen() { 
+		if ( (locAlways.x + widthi > 0 && locAlways.x < screenDim.width) && 
+				(locAlways.y + heighti > 0 && locAlways.y < screenDim.height) ) return true;
+		else {
+			Vm.debug("la.x: " + locAlways.x + " la.y: " + locAlways + " screeD.w: " + screenDim.width + "scD.h: "+ screenDim.height);
+			return false;
+		}
 	}
 }
 	

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-22 10:11:25 UTC (rev 437)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-22 16:27:20 UTC (rev 438)
@@ -199,7 +199,7 @@
 	}
 
 	public String getMapExpediaLoadPath() {
-		return Global.getPref().baseDir + "/maps/expedia/";
+		return Global.getPref().baseDir + "/maps/expedia";
 	}
 
 	/**



From pfeffer at mail.berlios.de  Mon Jan 22 20:42:17 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 22 Jan 2007 20:42:17 +0100
Subject: [Cachewolf-svn] r439 - trunk/src/CacheWolf
Message-ID: <200701221942.l0MJgH03031978@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-22 20:42:06 +0100 (Mon, 22 Jan 2007)
New Revision: 439

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: TrackOverlays sollten jetz zuverl?\195?\164ssiger funktionieren

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-22 16:27:20 UTC (rev 438)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-22 19:42:06 UTC (rev 439)
@@ -28,6 +28,7 @@
 	GotoPanel gotoPanel;
 	Vector cacheDB;
 	TrackOverlay[] TrackOverlays;
+	CWPoint TrackOverlaySetCenterTopLeft;
 	Vector tracks;
 	MapInfoObject currentMap = null;
 	String mapPath;
@@ -206,7 +207,10 @@
 	public void addOverlaySet() {
 		destroyOverlaySet();
 		if (tracks == null) return; // no tracks
-		addMissingOverlays();
+		try {
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+			addMissingOverlays();
+		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
 	}
 
 	public void destroyOverlaySet() {
@@ -220,22 +224,22 @@
 
 	public void addMissingOverlays() {
 		if (currentMap == null || posCircleLat < -360) return;
+		if (TrackOverlays == null) {
+			TrackOverlays = new TrackOverlay[9];
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+		}
 		boolean saveGPSIgnoreStatus = ignoreGps; // avoid multi-threading problems
 		ignoreGps = true;
-		Dimension ws = mmp.getSize(null);
-		int ww = ws.width;
-		int wh = ws.height;
-		Point upperleftOf4 = new Point(posCircleX, posCircleY); //ScreenXY2LatLon(0, 0); // TrackOverlay[4] == center of Trackoverlays 
-		upperleftOf4.x = upperleftOf4.x % ww;
-		upperleftOf4.y = upperleftOf4.y % wh;
+		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec); // TrackOverlay[4] == center of Trackoverlays 
+		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
+		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
 		int i;
-		if (TrackOverlays == null) TrackOverlays = new TrackOverlay[9];
 		for (int yi=0; yi<3; yi++) {
 			for (int xi=0; xi<3; xi++) {
 				i = yi*3+xi;
 				if (TrackOverlays[i]==null) { 
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*ww, upperleftOf4.y+(yi-1)*wh), ww, wh, currentMap); 
-					TrackOverlays[i].setLocation(ww+1, wh+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
+					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap); 
+					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -254,7 +258,9 @@
 		TrackOverlays[ov]=null;
 	}
 	public void rearangeOverlays() {
+		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec);
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
 			destroyOverlay(6);
 			destroyOverlay(7);
 			destroyOverlay(8);
@@ -275,6 +281,7 @@
 			destroyOverlay(5);
 		} else {
 			if (TrackOverlays[3].isOnScreen()) { // links raus
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
 				destroyOverlay(2);
 				destroyOverlay(5);
 				destroyOverlay(8);
@@ -295,6 +302,7 @@
 				destroyOverlay(7);
 			} else {
 				if (TrackOverlays[5].isOnScreen()) { // rechts raus
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
 					destroyOverlay(0);
 					destroyOverlay(3);
 					destroyOverlay(6);
@@ -315,6 +323,7 @@
 					destroyOverlay(7);
 				} else {
 					if (TrackOverlays[7].isOnScreen()) { // unten raus
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
 						destroyOverlay(0);
 						destroyOverlay(1);
 						destroyOverlay(2);
@@ -335,6 +344,7 @@
 						destroyOverlay(5);
 					} else { // it is important to test for diagonal only if the other didn't match
 						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
 							destroyOverlay(8);
 							mmp.removeImage(TrackOverlays[0]);
 							TrackOverlays[8]=TrackOverlays[0];
@@ -349,6 +359,7 @@
 							destroyOverlay(7);
 						} else {
 							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
 								destroyOverlay(6);
 								mmp.removeImage(TrackOverlays[2]);
 								TrackOverlays[6]=TrackOverlays[2];
@@ -363,6 +374,7 @@
 								destroyOverlay(8);
 							} else {
 								if (TrackOverlays[6].isOnScreen()) { // links unten raus
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
 									destroyOverlay(2);
 									mmp.removeImage(TrackOverlays[6]);
 									TrackOverlays[2]=TrackOverlays[6];
@@ -377,6 +389,7 @@
 									destroyOverlay(8);
 								} else {
 									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
 										destroyOverlay(0);
 										mmp.removeImage(TrackOverlays[8]);
 										TrackOverlays[0]=TrackOverlays[8];
@@ -390,7 +403,10 @@
 										destroyOverlay(6);
 										destroyOverlay(7);
 									}else
-										for (int i=0; i<TrackOverlays.length; i++) {destroyOverlay(i);} // this happens if a position jump occured
+										for (int i=0; i<TrackOverlays.length; i++) {
+											destroyOverlay(i);
+											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+										} // this happens if a position jump occured
 								}}}}}}} // close all IFs
 		Vm.getUsedMemory(true); // call garbage collection
 		System.gc();
@@ -1017,7 +1033,7 @@
 		mm.ignoreGps = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		if (mapImage.isOnScreen()) return super.imageBeginDragged(mapImage, pos);
+		if (mapImage.isOnScreen() && !mm.mapHidden &&((mapImage.properties & AniImage.IsInvisible) == 0)) return super.imageBeginDragged(mapImage, pos);
 		else return super.imageBeginDragged(null, pos);
 	}
 
@@ -1076,7 +1092,10 @@
 	}
 
 	private void bringMapToTop() {
-		if (mapImage == null || (mapImage.properties & AniImage.IsInvisible) > 0 ) return;
+		if (mapImage == null || mm.mapHidden ||(mapImage.properties & AniImage.IsInvisible) > 0 ) {
+			saveImageList = null;
+			return;
+		}
 		saveImageList = new ImageList();
 		saveImageList.copyFrom(images);
 		images.removeAllElements();
@@ -1097,6 +1116,7 @@
 		if (mapImage!= null) {
 			p = mapImage.locAlways;
 			mapImage.move(p.x+diffX,p.y+diffY);
+			if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
@@ -1580,11 +1600,8 @@
 	public boolean isOnScreen() { 
 		if ( (locAlways.x + widthi > 0 && locAlways.x < screenDim.width) && 
 				(locAlways.y + heighti > 0 && locAlways.y < screenDim.height) ) return true;
-		else {
-			Vm.debug("la.x: " + locAlways.x + " la.y: " + locAlways + " screeD.w: " + screenDim.width + "scD.h: "+ screenDim.height);
-			return false;
-		}
+		else return false;
 	}
 }
-	
 
+



From pfeffer at mail.berlios.de  Mon Jan 22 20:52:17 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 22 Jan 2007 20:52:17 +0100
Subject: [Cachewolf-svn] r440 - trunk/src/CacheWolf
Message-ID: <200701221952.l0MJqHVo032449@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-22 20:52:13 +0100 (Mon, 22 Jan 2007)
New Revision: 440

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: verswehentlichj nicht Debug-ausgabe hat in manchen F?\195?\164llen einen Fehler verursacht

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-22 19:42:06 UTC (rev 439)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-22 19:52:13 UTC (rev 440)
@@ -130,7 +130,6 @@
 		File files = new File(mapsPath);
 		String rawFileName = new String();
 		String[] dirstmp = files.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_DIRECTORIES_ONLY);
-		Vm.debug(dirstmp.length + dirstmp.toString() + dirstmp[0]);
 		Vector dirs = new Vector(dirstmp);
 		dirs.add("."); // include the mapsPath itself
 		MapInfoObject tempMIO;



From pfeffer at mail.berlios.de  Tue Jan 23 01:00:37 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 23 Jan 2007 01:00:37 +0100
Subject: [Cachewolf-svn] r441 - trunk/src/CacheWolf
Message-ID: <200701230000.l0N00buD002290@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-23 01:00:32 +0100 (Tue, 23 Jan 2007)
New Revision: 441

Modified:
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
MovingMap: noch kleine Fehler mit bei manchen gro?\195?\159er Wirkung behoben

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-22 19:52:13 UTC (rev 440)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-23 00:00:32 UTC (rev 441)
@@ -130,7 +130,9 @@
 		File files = new File(mapsPath);
 		String rawFileName = new String();
 		String[] dirstmp = files.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_DIRECTORIES_ONLY);
-		Vector dirs = new Vector(dirstmp);
+		Vector dirs;
+		if (dirstmp != null) dirs = new Vector(dirstmp);
+		else dirs = new Vector();
 		dirs.add("."); // include the mapsPath itself
 		MapInfoObject tempMIO;
 		MessageBox f = null;
@@ -680,7 +682,7 @@
 			updateSymbolPositions();
 			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
 			//}
-			mmp.repaintNow(); // TODO test if the "if" above can be used
+			mmp.repaintNow(); // TODO test if the "if" above can be used: i guess it can be used as long as the posCircle doesn't move autonom without a mapmove
 		}
 		//Vm.debug("update only position");			
 	}
@@ -695,10 +697,9 @@
 			setBestMap(lat, lon);
 			forceMapLoad = false;
 			return;
-
 		}
-		lastUpatePosition.latDec=lat;
-		lastUpatePosition.lonDec=lon;
+		lastUpatePosition.latDec = lat;
+		lastUpatePosition.lonDec = lon;
 		if(!ignoreGps || forceMapLoad){
 			updateOnlyPosition(lat, lon, true);
 			if (autoSelectMap || forceMapLoad) {

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-01-22 19:52:13 UTC (rev 440)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-01-23 00:00:32 UTC (rev 441)
@@ -24,7 +24,7 @@
 	public Point trackPixels[] = null;
 	public Color trackPixelsColor[] = null;
 	public int numPixels = 0;
-	final static int maxPixelsInCache = 500;
+	final static int maxPixelsInCache = 100;
 	final static Color transparentColor = Color.White;
 	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
 		topLeft = new TrackPoint(topLefti);
@@ -120,7 +120,7 @@
 
 	public void addPixelIfNeccessary(int x, int y, Color f){
 		if (trackPixels != null) {
-			int ll =(numPixels<50 ? 0 : numPixels-50); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
+			int ll =(numPixels<30 ? 0 : numPixels-30); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
 			for (int i=numPixels-1; i>=ll; i--) {
 				if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) 
 					{ return; } 



From pfeffer at mail.berlios.de  Tue Jan 23 04:25:51 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 23 Jan 2007 04:25:51 +0100
Subject: [Cachewolf-svn] r442 - trunk/src/CacheWolf
Message-ID: <200701230325.l0N3PpN6014233@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-23 04:25:42 +0100 (Tue, 23 Jan 2007)
New Revision: 442

Modified:
   trunk/src/CacheWolf/CWPoint.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Durch Rechtsklick neuen Wegpunkt anlegen
MovingMap: Anzeige der Entfernung zum Zielpunkt
MovingMap: Tuning
Detailspanel verwendet String cachHolder.latlon nicht mehr
an ein paar Stellen ?\195?\156bergabe der Globalen Pref und Profile beseitigt


Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-01-23 00:00:32 UTC (rev 441)
+++ trunk/src/CacheWolf/CWPoint.java	2007-01-23 03:25:42 UTC (rev 442)
@@ -240,7 +240,6 @@
 					set(rex.stringMatched(17),rex.stringMatched(19),rex.stringMatched(18)); //parse sequence is E N, but set needs N E
 				}
 				//else Vm.debug("CWPoint: "+coord+" could not be parsed");
-				//makeValid(); // TODO was solld as hier?
 			}	/**
 	 * set lat and lon 
 	 * @param strLatNS "N" or "S"

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2007-01-23 00:00:32 UTC (rev 441)
+++ trunk/src/CacheWolf/CalcPanel.java	2007-01-23 03:25:42 UTC (rev 442)
@@ -160,7 +160,7 @@
 				readFields(coordInp, bd, currFormat);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				ch.LatLon = coordOut.toString();
-				detP.newWaypoint(ch, mainT, pref, profile);
+				detP.newWaypoint(ch, mainT);
 			}
 			
 			if (ev.target == btnGoto){

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-23 00:00:32 UTC (rev 441)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-23 03:25:42 UTC (rev 442)
@@ -99,7 +99,7 @@
 	/**
 	*	Set the values to display.
 	*/
-	public void setDetails(CacheHolder ch, MainTab mt, Preferences p, Profile prof){
+	public void setDetails(CacheHolder ch, MainTab mt){
 		if (this.newWp){
 			this.newWp = false;
 			btCrWp.setText(MyLocale.getMsg(312,"Save"));
@@ -108,8 +108,8 @@
 		else {
 			btCrWp.setText(MyLocale.getMsg(311,"Create Waypoint"));
 		}
-		pref = p;
-		profile=prof;
+		pref = Global.getPref();
+		profile=Global.getProfile();
 		mainT = mt;
 		cacheDB = profile.cacheDB;
 		thisCache = ch;
@@ -118,7 +118,7 @@
 		dirty_newOrDelete = false; // Cache has been created/deleted but not saved
 		wayPoint.setText(ch.wayPoint);
 		wayName.setText(ch.CacheName);
-	    btnWayLoc.setText(ch.LatLon);
+	    btnWayLoc.setText(ch.pos.toString());
 		wayHidden.setText(ch.DateHidden);
 		wayOwner.setText(ch.CacheOwner);
 		wayStatus.setText(ch.CacheStatus);
@@ -163,12 +163,20 @@
 		return strWp;
 	}
 	
-	public void newWaypoint(CacheHolder ch, MainTab mt, Preferences pref, Profile profile){
-
+	/**
+	 * this is called from goto / MovingMap and so on to 
+	 * offer the user the possibility of entering an new waypoint
+	 * at a given position
+	 * 
+	 * @param ch
+	 * @param mt
+	 */
+	public void newWaypoint(CacheHolder ch, MainTab mt){
+		this.profile = Global.getProfile();
 		ch.wayPoint = getNewWayPointName(profile.cacheDB);
 		ch.type = "0";
 		ch.CacheSize = "None";
-		setDetails(ch, mt,pref, profile);
+		setDetails(ch, mt);
 		this.newWp = true;
 		cacheDB.add(thisCache);
 		mt.select(this);

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-23 00:00:32 UTC (rev 441)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-23 03:25:42 UTC (rev 442)
@@ -614,7 +614,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = gpsPosition.toString();
 				ch.pos = new CWPoint(gpsPosition);
-				detP.newWaypoint(ch,mainT, pref, profile);
+				detP.newWaypoint(ch,mainT);
 			}
 			// change destination waypoint
 			if (ev.target == btnGoto){

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-23 00:00:32 UTC (rev 441)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-23 03:25:42 UTC (rev 442)
@@ -157,7 +157,7 @@
 			  }
 			  if(this.getSelectedItem() == 1){ // DetailsPanel
 				  MyLocale.setSIPButton();
-				  detP.setDetails(ch, this,pref, profile);
+				  detP.setDetails(ch, this);
 			  }
 			  if(this.getSelectedItem() == 2) { // Description Panel
 				  openDesciptionPanel(ch);

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-01-23 00:00:32 UTC (rev 441)
+++ trunk/src/CacheWolf/Map.java	2007-01-23 03:25:42 UTC (rev 442)
@@ -35,7 +35,7 @@
 	*/
 	public Map(Preferences pref){
 		this.pref = pref;
-		mapsPath = pref.getMapManuallySavePath()+"/"; //File.getProgramDirectory() + "/maps/"; // TODO veraltet
+		mapsPath = pref.getMapManuallySavePath()+"/"; //File.getProgramDirectory() + "/maps/";
 	}
 	
 	/**

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-23 00:00:32 UTC (rev 441)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-23 03:25:42 UTC (rev 442)
@@ -44,6 +44,8 @@
 	AniImage buttonImageLens = new AniImage("lupe.png");
 	AniImage buttonImageLensActivated = new AniImage("lupe_activated.png");
 	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
+	AniImage DistanceImage;
+	Graphics DistanceImageGraphics;
 	MapImage posCircle = new MapImage("position_green.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
@@ -93,6 +95,13 @@
 		mmp.addImage(buttonImageLens);
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageZoom1to1);
+		//Label distLbl = new mLabel("Distance: ----,-- km");
+		DistanceImage = new AniImage();
+		DistanceImage.setImage(new Image(120, 20), Color.White); // consider the size of the font used
+		DistanceImageGraphics = new Graphics(DistanceImage.image);
+		DistanceImageGraphics.setFont(new Font("Helvetica", Font.BOLD, 16));
+		DistanceImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(DistanceImage);
 		resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
@@ -111,6 +120,7 @@
 		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
 		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		DistanceImage.setLocation(w/2 - DistanceImage.location.width/2, h - DistanceImage.location.height -10);
 		// TODO TrackOverlay-gr??e muss angepasst werden
 	}
 	
@@ -172,6 +182,27 @@
 		this.mapsloaded = true;
 	}
 
+	public void updateDistance() {
+		if (gotoPos == null || posCircleLat < -360) return;
+		ewe.sys.Double dd = new ewe.sys.Double();
+		dd.set((new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon)));
+		String d; 
+		if (dd.value < 1) {
+			dd.value = dd.value * 1000; 
+			dd.decimalPlaces = 0;
+			d = "Distance: " + dd.toString() + "m";} 
+		else {
+			dd.decimalPlaces = 2;
+			d = "Distance: " + dd.toString() + "km";
+		}
+		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
+		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
+		DistanceImageGraphics.setColor(Color.MediumBlue);
+		DistanceImageGraphics.drawText(d, 0, 0);
+		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.DarkBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+	}
+	
 	public void forceMapLoad() {
 		forceMapLoad = true;
 		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec); // this sets forceMapLoad to false after loading a map
@@ -602,6 +633,7 @@
 		if (symbols==null) symbols=new Vector();
 		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
 		ms.loadImage();
+		ms.properties |= AniImage.AlwaysOnTop;
 		Point pOnScreen=getXYonScreen(lat, lon);
 		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
@@ -621,6 +653,7 @@
 	public void setGotoPosition(double lat, double lon) {
 		removeGotoPosition();
 		gotoPos=addSymbol("goto", "goto_map.png", lat, lon);
+		updateDistance();
 	}
 
 	public void removeGotoPosition() {
@@ -680,6 +713,7 @@
 		if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
 			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
 			updateSymbolPositions();
+			updateDistance();
 			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
 			//}
 			mmp.repaintNow(); // TODO test if the "if" above can be used: i guess it can be used as long as the posCircle doesn't move autonom without a mapmove
@@ -1005,8 +1039,9 @@
 class MovingMapPanel extends InteractivePanel implements EventListener {
 	Menu mapsMenu;
 	Menu kontextMenu;
-	MenuItem gotoMenuItem;
+	MenuItem gotoMenuItem = new MenuItem("Goto here$g", 0, null);
 	MenuItem openCacheDescMenuItem;
+	MenuItem newWayPointMenuItem = new MenuItem("Create new Waypoint here$n", 0, null);;
 	CacheHolder clickedCache;
 	MovingMap mm;
 	MapImage mapImage;
@@ -1018,8 +1053,6 @@
 	public MovingMapPanel(MovingMap f){
 		this.mm = f;
 		set(Control.WantHoldDown, true); // want to get simulated right-clicks
-		gotoMenuItem = new MenuItem("Goto here", 0, null);
-
 	}
 
 	public boolean imageBeginDragged(AniImage which,Point pos) {
@@ -1028,7 +1061,7 @@
 			mm.ignoreGps = true;
 			return false;
 		}
-		if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
+		//if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
 		saveGpsIgnoreStatus = mm.ignoreGps; 
 		mm.ignoreGps = true;
 		saveMapLoc = pos;
@@ -1202,15 +1235,16 @@
 
 	public void penHeld(Point p){
 		//	if (!menuIsActive()) doMenu(p);
-		if (!mm.zoomingMode) // && ev instanceof PenEvent && (
+		if (!mm.zoomingMode) { 
 			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
-		{ //|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )){		
+			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---> these events are not posted --> this overridering is the only solution 
 			kontextMenu = new Menu();
 			kontextMenu.addItem(gotoMenuItem);
+			kontextMenu.addItem(newWayPointMenuItem);
 			AniImage clickedOnImage = images.findHotImage(p);
 			if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
 				clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
-				openCacheDescMenuItem = new MenuItem("Open "+clickedCache.CacheName);
+				openCacheDescMenuItem = new MenuItem("Open '"+clickedCache.CacheName+"'$o");
 				kontextMenu.addItem(openCacheDescMenuItem);
 			}
 			kontextMenu.exec(this, new Point(p.x, p.y), this);
@@ -1259,11 +1293,12 @@
 			} // if (ev.target == mapsMenu)
 			if (ev.target == kontextMenu) {
 				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
-					if (kontextMenu.getSelectedItem() == gotoMenuItem) {
+					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
+					if (action == gotoMenuItem) {
 						kontextMenu.close();
 						mm.gotoPanel.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
 					}
-					if (kontextMenu.getSelectedItem() == openCacheDescMenuItem) {
+					if (action == openCacheDescMenuItem) {
 						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
 						kontextMenu.close();
 						WindowEvent close = new WindowEvent();
@@ -1274,6 +1309,18 @@
 						mm.gotoPanel.mainT.select(mm.gotoPanel.mainT.descP);
 						mm.gotoPanel.mainT.openDesciptionPanel(clickedCache);
 					}
+					if (action == newWayPointMenuItem) {
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm;
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						CacheHolder newWP = new CacheHolder();
+						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
+						mm.gotoPanel.mainT.detP.newWaypoint(newWP, mm.gotoPanel.mainT);
+						
+					}
+					
 				}
 			} // if (ev.target == kontextMenu)
 		} // if (ev instanceof ControlEvent ) 



From bilbowolf at mail.berlios.de  Tue Jan 23 09:40:22 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 23 Jan 2007 09:40:22 +0100
Subject: [Cachewolf-svn] r443 - trunk/resources
Message-ID: <200701230840.l0N8eM1E006850@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-23 09:40:18 +0100 (Tue, 23 Jan 2007)
New Revision: 443

Added:
   trunk/resources/icon_greenlight.gif
Log:


Added: trunk/resources/icon_greenlight.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/icon_greenlight.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From pfeffer at mail.berlios.de  Tue Jan 23 17:55:47 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 23 Jan 2007 17:55:47 +0100
Subject: [Cachewolf-svn] r444 - trunk/src/CacheWolf
Message-ID: <200701231655.l0NGtlhA025434@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-23 17:55:44 +0100 (Tue, 23 Jan 2007)
New Revision: 444

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Tracks werden jetz auch beim ersten Aufruf der MovingMap  richtig dargestellt
MovingMap: Beim Zoomen deutlichere Markierung des Zoomrahmens
MovingMap: kein automatischer Vollbildschirm mehr, wenn pref.MyAppHeight < 640 && pref.MyAppWidth < 640

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-23 08:40:18 UTC (rev 443)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-23 16:55:44 UTC (rev 444)
@@ -64,7 +64,7 @@
 		this.cacheDB = cacheDB;
 		this.gotoPanel = gP;
 		this.pref = pref;
-		this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
+		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)	this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
 		this.windowFlagsToClear = Window.FLAG_HAS_TITLE | Window.BDR_NOBORDER;
 		this.hasTopBar = false;
 		this.noBorder = true;
@@ -102,17 +102,22 @@
 		DistanceImageGraphics.setFont(new Font("Helvetica", Font.BOLD, 16));
 		DistanceImage.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(DistanceImage);
-		resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
+		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(posCircle);
 		mapsloaded = false;
 		posCircleLat = -361;
 		posCircleLon = -361; // make them invalid
+		updateDistance(); // fill Rect with transparent color
 	}
 
 	public void resizeTo(int w,int h) {
 		super.resizeTo(w, h);
+		updateFormSize(w, h);
+	}
+
+	public void updateFormSize(int w, int h) {
 		MapImage.setScreenSize(w, h);
 		bottonImageClose.setLocation(w- bottonImageClose.getWidth()- 5, 5);
 		buttonImageGpsOn.setLocation(w- bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
@@ -121,7 +126,7 @@
 		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
 		DistanceImage.setLocation(w/2 - DistanceImage.location.width/2, h - DistanceImage.location.height -10);
-		// TODO TrackOverlay-gr??e muss angepasst werden
+		if (tracks != null) addOverlaySet();
 	}
 	
 	/**
@@ -183,6 +188,8 @@
 	}
 
 	public void updateDistance() {
+		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
+		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
 		if (gotoPos == null || posCircleLat < -360) return;
 		ewe.sys.Double dd = new ewe.sys.Double();
 		dd.set((new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon)));
@@ -195,8 +202,6 @@
 			dd.decimalPlaces = 2;
 			d = "Distance: " + dd.toString() + "km";
 		}
-		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
-		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
 		DistanceImageGraphics.setColor(Color.MediumBlue);
 		DistanceImageGraphics.drawText(d, 0, 0);
 		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.DarkBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
@@ -243,6 +248,7 @@
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 			addMissingOverlays();
 		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
+		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null 
 	}
 
 	public void destroyOverlaySet() {
@@ -1111,15 +1117,15 @@
 			else left = saveMapLoc.x;
 			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
 			else top = saveMapLoc.y;
-			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)));
-			dr.setColor(Color.LightGreen);
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+2, java.lang.Math.abs(lastZoomHeight)+2));
 			lastZoomWidth = ev.x - saveMapLoc.x;
 			lastZoomHeight =  ev.y - saveMapLoc.y;
 			if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
 			else left = saveMapLoc.x;
 			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
 			else top = saveMapLoc.y;
-			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth) , java.lang.Math.abs(lastZoomHeight), 2);
+			dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
 		}
 		super.onPenEvent(ev);
 	}
@@ -1601,14 +1607,16 @@
 	
 	public MapImage(String f) {
 		super(f);
-		widthi = getWidth();
+		widthi = getWidth(); // this is necessary becaus width is not directly accessable from here and an function call each time the pos ist updated shall be avoided becaus of performance reasons
 		heighti = getHeight();
+		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 	
 	public MapImage(mImage im) {
 		super(im);
 		widthi = getWidth();
 		heighti = getHeight();
+		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 	public static void setScreenSize(int w, int h) {
 		screenDim = new Dimension(w, h);
@@ -1618,6 +1626,7 @@
 		super.setImage(im, c);
 		widthi = getWidth();
 		heighti = getHeight();
+		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 	
 	public void setLocation (int x, int y) {



From salzkammergut at mail.berlios.de  Tue Jan 23 23:55:35 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Tue, 23 Jan 2007 23:55:35 +0100
Subject: [Cachewolf-svn] r445 - trunk/src/CacheWolf
Message-ID: <200701232255.l0NMtZSj032619@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-23 23:55:32 +0100 (Tue, 23 Jan 2007)
New Revision: 445

Modified:
   trunk/src/CacheWolf/NotesScreen.java
Log:
Fix: Zeitstempelformat korrigiert
(Fuehrende 0 bei einstelligen Minuten)

Modified: trunk/src/CacheWolf/NotesScreen.java
===================================================================
--- trunk/src/CacheWolf/NotesScreen.java	2007-01-23 16:55:44 UTC (rev 444)
+++ trunk/src/CacheWolf/NotesScreen.java	2007-01-23 22:55:32 UTC (rev 445)
@@ -41,7 +41,7 @@
 				String note = wayNotes.getText();
 				Time dtm = new Time();
 				dtm.getTime();
-				dtm.setFormat("E dd.MM.yyyy '/' H:m");
+				dtm.setFormat("E dd.MM.yyyy '/' HH:mm");
 				if(note.length() > 0)	note = note + "\n" + dtm.toString();
 				else 	note = note + dtm.toString();
 				note = note + "\n";



From salzkammergut at mail.berlios.de  Tue Jan 23 23:58:55 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Tue, 23 Jan 2007 23:58:55 +0100
Subject: [Cachewolf-svn] r446 - trunk/src/CacheWolf
Message-ID: <200701232258.l0NMwtGE032758@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-23 23:58:53 +0100 (Tue, 23 Jan 2007)
New Revision: 446

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
Bugfix beim Blacklisting von Caches
(wenn ein Cache im Detailpanel blackgelisted wurde, 
wurde bei jedem Umschalten auf das DP der jeweilige Cache auch
geblacklistet).

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-23 22:55:32 UTC (rev 445)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-23 22:58:53 UTC (rev 446)
@@ -129,6 +129,7 @@
 		} else {
 			btnBlack.image = mNoBlack;
 		}
+		blackStatus=ch.is_black; 
 		btnBlack.repaintNow();
 		if(ch.has_bug == true) {
 			showBug.modify(Control.Disabled,1);
@@ -144,7 +145,7 @@
 		if(ch.CacheSize.equals("Very Large")) waySize.setInt(6);
 		if(ch.CacheSize.equals("None")) waySize.setInt(7);
 		if(ch.CacheSize.equals("Not chosen")) waySize.setInt(7);
-		
+
 		if(ch.is_found == true) wayStatus.setText(MyLocale.getMsg(318,"Found"));
 	}
 	



From salzkammergut at mail.berlios.de  Wed Jan 24 00:12:45 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 24 Jan 2007 00:12:45 +0100
Subject: [Cachewolf-svn] r447 - trunk/src/CacheWolf
Message-ID: <200701232312.l0NNCjD2000686@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-24 00:12:40 +0100 (Wed, 24 Jan 2007)
New Revision: 447

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Bugfix: http://www.geoclub.de/ftopic13787.html
Beim Oeffnen eines neuen Profils blieb der Ptr auf den aktuellen Cache
unveraendert, wodurch manchmal keine Caches angezeigt wurden.

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-23 22:58:53 UTC (rev 446)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-23 23:12:40 UTC (rev 447)
@@ -203,6 +203,7 @@
 					profile.readIndex();
 					pref.curCentrePt.set(profile.centre);
 					tbp.resetModel();
+					Global.mainTab.tbP.gotoFirstLine();
 				}
 			}
 			if(mev.selectedItem == mnuEditProfile){
@@ -278,8 +279,8 @@
 				ProgressBarForm.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
 				String cwd = File.getProgramDirectory() + "/temp.pcx";
 				try{
-					ewe.sys.Process p = Vm.exec("gpsbabel -s -i pcx -f "+ cwd +" -o garmin -F " + pref.garminConn +":");
-					Vm.debug("gpsbabel -s -i pcx -f "+ cwd +" -o garmin -F " + pref.garminConn +":");
+					ewe.sys.Process p = Vm.exec("gpsbabel -s -i pcx -f \""+ cwd +"\" -o garmin -F " + pref.garminConn +":");
+					Vm.debug("gpsbabel -s -i pcx -f  \""+ cwd +"\" -o garmin -F " + pref.garminConn +":");
 					p.waitFor();
 				}catch(IOException ioex){};
 				ProgressBarForm.clear();

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-23 22:58:53 UTC (rev 446)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-23 23:12:40 UTC (rev 447)
@@ -73,6 +73,10 @@
 		tc.setTableModel(myMod);
 	}
 	
+	public void gotoFirstLine() {
+		tc.scrollToVisible(0,0);
+	}
+	
 	public void setPanels(GotoPanel gp, MainTab mt) {
 		myGotoPanel = gp;
 		myMaintab = mt;

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-23 22:58:53 UTC (rev 446)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-23 23:12:40 UTC (rev 447)
@@ -164,7 +164,6 @@
 		cacheDB.addAll(sortDB);
 		cacheDB.addAll(filteredDB);
 		this.numRows = sortDB.getCount();
-		tcControl.scrollToVisible(0,0);
 	}
 	
 	/**



From salzkammergut at mail.berlios.de  Wed Jan 24 00:17:51 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 24 Jan 2007 00:17:51 +0100
Subject: [Cachewolf-svn] r448 - trunk/src/CacheWolf
Message-ID: <200701232317.l0NNHp4X001044@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-24 00:17:39 +0100 (Wed, 24 Jan 2007)
New Revision: 448

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
Log:
Bugfixes: PreferencesScreen: Falscher Text gefixt
HintlogPanel: Wenn neuer Cache keinen Hint hatte, blieb alter
Hint stehen (beim somit falschen Cache).
Feature: Hintlogpanel: Die anfaengliche Groesse des HintFeldes kann ueber
pref.xml eingestellt werden (auch 0 moeglich, kein UI geplant, 
ein Feature fuer Experten - schoener Gruss an Pfeffer ;)  )

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-01-23 23:12:40 UTC (rev 447)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-01-23 23:17:39 UTC (rev 448)
@@ -26,10 +26,11 @@
 		CellPanel hintpane = split.getNextPanel();
 		CellPanel logpane = split.getNextPanel();
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
-		hintpane.setCell(INITIALLY_PREFERRED_SIZE);
+		int initialHintHeight=Global.getPref().initialHintHeight;
+		if (initialHintHeight<0 || initialHintHeight>1000) initialHintHeight=Global.getPref().DEFAULT_INITIAL_HINT_HEIGHT;
+		hintpane.setPreferredSize(100,initialHintHeight); 
 		ScrollBarPanel sbphint = new ScrollBarPanel(hint);
 		hintpane.addLast(sbphint,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
-		sbphint.setMinimumSize(0,0);
 		hintpane.addNext(prevBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		hintpane.addNext(decodeButton,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
@@ -43,7 +44,10 @@
 	
 	public void setText(CacheHolder cache){
 		this.cache = cache;
-		if(!cache.Hints.equals("null")) hint.setText(cache.Hints);
+		if(!cache.Hints.equals("null")) 
+			hint.setText(cache.Hints);
+		else
+			hint.setText("");
 		crntLogPosition = 0;
 		setLogs(0);
 		moreBt.modify(0,Control.Disabled);

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-23 23:12:40 UTC (rev 447)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-23 23:17:39 UTC (rev 448)
@@ -64,6 +64,9 @@
 	// This setting determines how many logs are shown per page of hintlogs (default 5)
 	public final int DEFAULT_LOGS_PER_PAGE=5;
 	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
+	// Initial height of hints field (set to 0 to hide them initially)
+	public final int DEFAULT_INITIAL_HINT_HEIGHT=50;
+	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT; 
 	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
 	public boolean downloadMapsOC = true;
 	public boolean downloadmissingOC = false;
@@ -452,6 +455,8 @@
 		}
 		if (name.equals("hintlogpanel")) {
 			logsPerPage = Convert.parseInt(atts.getValue("logsperpage"));
+			String strInitialHintHeight=atts.getValue("initialhintheight");
+			if (strInitialHintHeight!=null) initialHintHeight=Convert.parseInt(strInitialHintHeight);
 		}
 		if (name.equals("solver")) {
 			solverIgnoreCase=Boolean.valueOf(atts.getValue("ignorevariablecase")).booleanValue();
@@ -525,7 +530,7 @@
 			outp.print("    <lastprofile autoreload=\""+autoReloadLastProfile+"\">"+lastProfile+"</lastprofile>\n"); //RB
 			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\" hasclosebutton=\""+hasCloseButton+"\"/>\n");
 			outp.print("    <imagepanel showdeletedimages=\""+showDeletedImages+"\"/>\n");
-			outp.print("    <hintlogpanel logsperpage=\""+logsPerPage+"\"/>\n");
+			outp.print("    <hintlogpanel logsperpage=\""+logsPerPage+"\" initialhintheight=\""+initialHintHeight+"\"/>\n");
 			outp.print("    <solver ignorevariablecase=\""+solverIgnoreCase+"\"/>\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			// Obsolete data kept for backward compatibility

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2007-01-23 23:12:40 UTC (rev 447)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2007-01-23 23:17:39 UTC (rev 448)
@@ -142,7 +142,7 @@
 
 		mTab.addCard(pnlGeneral,MyLocale.getMsg(621,"General"),null);
 		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,"Screen"),null);
-		mTab.addCard(pnlMore,MyLocale.getMsg(631,"More"),null);
+		mTab.addCard(pnlMore,MyLocale.getMsg(632,"More"),null);
 		//this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		
 		this.addLast(mTab);



From salzkammergut at mail.berlios.de  Wed Jan 24 00:52:05 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 24 Jan 2007 00:52:05 +0100
Subject: [Cachewolf-svn] r449 - trunk/src/CacheWolf
Message-ID: <200701232352.l0NNq51r003565@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-24 00:51:47 +0100 (Wed, 24 Jan 2007)
New Revision: 449

Modified:
   trunk/src/CacheWolf/ProfilesForm.java
Log:
Profilauswahldialog: "Enter" ladet das letzte Profil
(Focus nicht mehr auf Button "Neu")

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2007-01-23 23:17:39 UTC (rev 448)
+++ trunk/src/CacheWolf/ProfilesForm.java	2007-01-23 23:51:47 UTC (rev 449)
@@ -93,6 +93,7 @@
 		addNext(btnCancel = new mButton(MyLocale.getMsg(1604,"Cancel")),DONTSTRETCH,DONTFILL|LEFT);
 		addNext(btnOK = new mButton(MyLocale.getMsg(1605,"OK")),DONTSTRETCH,HFILL|RIGHT);
 		this.baseDir=baseDir;
+		choice.takeFocus(Control.ByKeyboard);
 	}
 	
 	/**
@@ -108,17 +109,23 @@
 			 return "";
 	}
 	
+	private boolean first=true;
 	/**
 	*	The event handler to react to a users selection.
 	*	A return value is created and passed back to the calling form
 	*	while it closes itself.
 	*/
 	public void onEvent(Event ev){
+		// Set focus on the choice control initially
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.FOCUS_IN && first) {
+			first=false;  // There must be a better way to set the focus to the choice control ??!?
+			choice.takeFocus(Control.ByKeyboard);
+		}
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnCancel){
 				close(-1);
 			}
-			if (ev.target == btnOK){
+			if (ev.target == btnOK || ev.target == choice){
 				newSelectedProfile=choice.getSelectedItem().toString();
 				close(1);
 			}



From pfeffer at mail.berlios.de  Wed Jan 24 05:09:50 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 24 Jan 2007 05:09:50 +0100
Subject: [Cachewolf-svn] r450 - trunk/src/CacheWolf
Message-ID: <200701240409.l0O49our031415@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-24 05:09:48 +0100 (Wed, 24 Jan 2007)
New Revision: 450

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Liste der Karten markiert die momentan angezeigte Map
MovingMap: behoben: hatte die Karte beim ersten Aufruf erst angezeigt, nachdem irgendeine Aktion (wie verschieben) durchgef?\195?\188hrt wurde
MovingMap: etwas aufgeraeumt

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-23 23:51:47 UTC (rev 449)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-24 04:09:48 UTC (rev 450)
@@ -580,7 +580,7 @@
 			if (ev.target == btnMap){
 				runMovingMap = true;
 				boolean runbefore=false;
-				if (mmp == null) mmp = new MovingMap(pref, this, cacheDB); // this also loads the list of maps
+				if (mmp == null) mmp = new MovingMap(pref, this, cacheDB);
 				else runbefore = true;
 				if (serThread == null || !serThread.isAlive() || !gpsPosition.isValid()) {
 					// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-23 23:51:47 UTC (rev 449)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-24 04:09:48 UTC (rev 450)
@@ -126,6 +126,8 @@
 		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
 		DistanceImage.setLocation(w/2 - DistanceImage.location.width/2, h - DistanceImage.location.height -10);
+		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
+		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
 		if (tracks != null) addOverlaySet();
 	}
 	
@@ -538,7 +540,7 @@
 	public void resetCenterOfMap() {
 		posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
 		posCircleY = pref.myAppHeight/2;
-		posCircle.properties &= ~AniImage.IsInvisible;
+		posCircle.hidden = false;
 		posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
 	}
 
@@ -734,6 +736,7 @@
 			loadMaps(mapPath, lat);
 			lastCompareX = Integer.MAX_VALUE;
 			lastCompareY = Integer.MAX_VALUE;
+			autoSelectMap = true;
 			setBestMap(lat, lon);
 			forceMapLoad = false;
 			return;
@@ -836,7 +839,7 @@
 			}
 			mapImage1to1 = mmp.mapImage;
 			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
-			if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
+			if (mapHidden) mmp.mapImage.hide();
 			mmp.mapImage.move(0,0);
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
@@ -889,14 +892,16 @@
 
 	public void hideMap() {
 		if (mmp != null && mmp.mapImage != null)
-			mmp.mapImage.properties |= AniImage.IsInvisible;
+			mmp.mapImage.hide();
 		mapHidden = true;
 		repaintNow();
 	}
 
 	public void showMap() {
 		if (mmp != null && mmp.mapImage != null)
-			mmp.mapImage.properties &= ~AniImage.IsInvisible;
+		{ mmp.mapImage.unhide();
+		  mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); 
+		}
 		mapHidden = false;
 		repaintNow();
 	}
@@ -1000,6 +1005,7 @@
 			Vm.getUsedMemory(true);
 			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
+			if (mapHidden) mmp.mapImage.hide();
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
 			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
@@ -1072,7 +1078,7 @@
 		mm.ignoreGps = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		if (mapImage.isOnScreen() && !mm.mapHidden &&((mapImage.properties & AniImage.IsInvisible) == 0)) return super.imageBeginDragged(mapImage, pos);
+		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
 		else return super.imageBeginDragged(null, pos);
 	}
 
@@ -1117,6 +1123,10 @@
 			else left = saveMapLoc.x;
 			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
 			else top = saveMapLoc.y;
+			left -= 2;
+			top -= 2;
+			if (top < 0) top = 0;
+			if (left < 0) left = 0;
 			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+2, java.lang.Math.abs(lastZoomHeight)+2));
 			lastZoomWidth = ev.x - saveMapLoc.x;
 			lastZoomHeight =  ev.y - saveMapLoc.y;
@@ -1131,22 +1141,18 @@
 	}
 
 	private void bringMapToTop() {
-		if (mapImage == null || mm.mapHidden ||(mapImage.properties & AniImage.IsInvisible) > 0 ) {
+		if (mapImage == null || mapImage.hidden) {
 			saveImageList = null;
 			return;
 		}
 		saveImageList = new ImageList();
 		saveImageList.copyFrom(images);
 		images.removeAllElements();
-		//images.remove(mapImage);
-		//mapImage.properties |= AniImage.AlwaysOnTop;
 		images.add(mapImage);
 	}
 	private void bringMaptoBack() {
-		//mapImage.properties &= ~AniImage.AlwaysOnTop;
-		//images.moveToBack(mapImage);
 		if (saveImageList == null) return;
-		images=saveImageList;
+		images = saveImageList;
 		saveImageList = null;
 	}
 
@@ -1155,7 +1161,7 @@
 		if (mapImage!= null) {
 			p = mapImage.locAlways;
 			mapImage.move(p.x+diffX,p.y+diffY);
-			if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+	//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
@@ -1178,7 +1184,7 @@
 		CWPoint gpspos;
 		if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
 		else gpspos = null;
-		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
 		if(l.execute() == FormBase.IDOK){
 //			Vm.debug("Trying map: " + l.selectedMap.fileName);
 			mm.autoSelectMap = false;
@@ -1191,6 +1197,7 @@
 				mm.ignoreGpsStatutsChanges = true;
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
 				mm.setCenterOfScreen(l.selectedMap.center);
+				mm.repaintNow();
 				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
 				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
 				//mm.posCircleX = 0; // place map to the upper left corner of windows
@@ -1345,56 +1352,74 @@
 	public boolean selected = false;
 	Vector maps;
 
-	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos){
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
 		this.title = "Maps";
 		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
 		this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
 		this.maps = maps;
 		MapInfoObject map;
 		ScrollBarPanel scb;
+		int oldmap = -1;
+		boolean curMapFound = false;
 		boolean[] inList = new boolean[maps.size()];
+		int row = -1;
 		if (gotopos != null && Gps != null) {
 			list.addItem("--- Karten von akt. Position und Ziel ---");
+			row++;
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
 				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
 				{
 					list.addItem(i + ": " + map.mapName);
+					row++;
 					inList[i] = true;
+					if (map == curMap) { oldmap = row; curMapFound = true; }
 				} else inList[i] = false;
 			}
 		}
 		if (Gps != null) {
 			list.addItem("--- Karten der aktuellen Position ---");
+			row++;
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
+				if (map == curMap) oldmap = i;
+				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
 				{
 					list.addItem(i + ": " + map.mapName);
+					row++;
 					inList[i] = true;
+					if (!curMapFound  && map == curMap) { oldmap = row; curMapFound = true; }
 				}
 			}
 		}
 		if (gotopos != null) {
 			list.addItem("--- Karten des Ziels ---");
+			row++;
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
 				if(map.inBound(gotopos)) {
 					list.addItem(i + ": " + map.mapName);
+					row++;
 					inList[i] = true;
+					if (!curMapFound  && map == curMap) { oldmap = row; curMapFound = true; }
 				}
 			}
 		}
 		list.addItem("--- andere Karten ---");
+		row++;
 		for(int i = 0; i<maps.size();i++){
 			map = new MapInfoObject();
 			map = (MapInfoObject)maps.get(i);
-			if(!inList[i]) list.addItem(i + ": " + map.mapName);
+			if(!inList[i]) {
+				list.addItem(i + ": " + map.mapName);
+				row++;
+				if (!curMapFound  && map == curMap) { oldmap = row; curMapFound = true; }
+			}
 		}
-
+		list.selectItem(oldmap, true);
 		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
 		cancelButton = new mButton("Cancel");
 		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
@@ -1417,17 +1442,6 @@
 		return false;
 	}
 
-
-	public int myExecute() {
-		if (this.maps.size()==1) {
-			//this.selectedMap = 1;
-			this.selectedMap = (MapInfoObject) maps.get(0);
-			return FormBase.IDOK;
-		}
-		return execute();
-	}
-
-
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == cancelButton){
@@ -1599,6 +1613,7 @@
 	static Dimension screenDim;
 	public int widthi;
 	public int heighti;
+	boolean hidden = false;
 	public MapImage() {
 		super();
 		widthi = getWidth();
@@ -1618,6 +1633,7 @@
 		heighti = getHeight();
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
+	
 	public static void setScreenSize(int w, int h) {
 		screenDim = new Dimension(w, h);
 	}
@@ -1632,7 +1648,7 @@
 	public void setLocation (int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (isOnScreen()) { 
+		if (!hidden && isOnScreen()) { 
 			super.setLocation(x, y);
 			properties &= ~AniImage.IsInvisible;
 		} else {
@@ -1644,7 +1660,7 @@
 	public void move (int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (isOnScreen()) { 
+		if (!hidden && isOnScreen()) { 
 			super.move(x, y);
 			properties &= ~AniImage.IsInvisible;
 		} else {
@@ -1658,6 +1674,15 @@
 				(locAlways.y + heighti > 0 && locAlways.y < screenDim.height) ) return true;
 		else return false;
 	}
+	
+	public void hide() {
+		hidden = true;
+		properties |= AniImage.IsInvisible;
+	}
+	public void unhide() {
+		hidden = false;
+		move(locAlways.x, locAlways.y);
+	}
 }
 
 



From pfeffer at mail.berlios.de  Thu Jan 25 01:16:38 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Jan 2007 01:16:38 +0100
Subject: [Cachewolf-svn] r451 - trunk/src/CacheWolf
Message-ID: <200701250016.l0P0GcvX000885@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-25 01:16:35 +0100 (Thu, 25 Jan 2007)
New Revision: 451

Added:
   trunk/src/CacheWolf/MapsList.java
Modified:
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: es gab eine NullpointerException bei rechtsklick auf der Goto-Position
MovingMap / Karten download: Vorbereitung f?\195?\188r besseren automatischen Kartenwechsel und Vorbereitung daf?\195?\188r, dass nur Karten gedowmnloaded werden, die in dem Ma?\195?\159stab noch nicht existieren

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-24 04:09:48 UTC (rev 450)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-25 00:16:35 UTC (rev 451)
@@ -30,7 +30,8 @@
 	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
-	public float zoomFactor = 1;
+	public float scaleX; // in meters per pixel in horizontal direction
+	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
 	public Point shift = new Point (0,0);
 	public CWPoint OrigUpperLeft; // this is only valid after zooming 
 	public float rotationRad; // contains the rotation of the map == north direction in rad
@@ -158,25 +159,27 @@
 	 */
 
 	private void doCalculations() throws ArithmeticException {
-		center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
-		sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
+		try {
+			center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
+			sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
 
-		//calculate reverse affine
-		double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
-		transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
-		transLonX = -affine[2]/nenner;
-		transLatY = -affine[1]/nenner;
-		transLonY = affine[0]/nenner;
+			//calculate reverse affine
+			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
+			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
+			transLonX = -affine[2]/nenner;
+			transLatY = -affine[1]/nenner;
+			transLonY = affine[0]/nenner;
 
-		// calculate north direction
-		float scaleX = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
-		//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
-		float rotationX2x=(float)transLonX*scaleX;
-		float rotationX2y=(float)transLonY*scaleX;
-		//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
-		//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
-		rotationRad = (float)java.lang.Math.atan(rotationX2y);
-		if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad; 
+			// calculate north direction
+			scaleX = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
+			//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
+			float rotationX2x=(float)transLonX*scaleX;
+			float rotationX2y=(float)transLonY*scaleX;
+			//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
+			//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
+			rotationRad = (float)java.lang.Math.atan(rotationX2y);
+			if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad;
+		} catch (ArithmeticException ex) { throw new ArithmeticException("Not allowed values in affine\n (matrix cannot be inverted)\n in file \n" + fileNameWFL); }
 	}
 
 

Added: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-01-24 04:09:48 UTC (rev 450)
+++ trunk/src/CacheWolf/MapsList.java	2007-01-25 00:16:35 UTC (rev 451)
@@ -0,0 +1,116 @@
+package CacheWolf;
+
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.ui.MessageBox;
+import ewe.util.Vector;
+/**
+ * class to handle a list of maps
+ * it loads the list, finds the best map for a given location
+ * says if a map is available for a given lat lon at a given scale
+ * @author r
+ *
+ */
+public class MapsList extends Vector {
+
+	/**
+	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
+	 * @param mapsPath
+	 */
+
+	public MapsList(String mapsPath) {
+		super(); // forget already loaded maps
+		//if (mmp.mapImage != null) 
+		String dateien[];
+		File files = new File(mapsPath);
+		String rawFileName = new String();
+		String[] dirstmp = files.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_DIRECTORIES_ONLY);
+		Vector dirs;
+		if (dirstmp != null) dirs = new Vector(dirstmp);
+		else dirs = new Vector();
+		dirs.add("."); // include the mapsPath itself
+		MapInfoObject tempMIO;
+		MessageBox f = null;
+		for (int j = dirs.size()-1; j >= 0; j--) {
+			files = new File(mapsPath+"/"+dirs.get(j));
+			dateien = files.list("*.wfl", File.LIST_FILES_ONLY);
+			for(int i = 0; i < dateien.length;i++){
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
+				try {
+					tempMIO = new MapInfoObject();
+					tempMIO.loadwfl(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
+					add(tempMIO);
+				}catch(IOException ex){ 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				}catch(ArithmeticException ex){ // affine contain not allowed values 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				} 
+			}
+		}
+	}
+
+	public void addEmptyMaps(double lat) {
+		MapInfoObject tempMIO;
+		tempMIO = new MapInfoObject(1.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(5.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(50.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(250.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(1000.0, lat);
+		add(tempMIO);
+	}
+
+	/**
+	 * find the best map for lat/lon in the list of maps
+	 * currently the best map is the one, whose center is nearest to
+	 * it always return a map (if the list is not empty) 
+	 * even if the map is not inbound
+	 * lat/lon
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+public MapInfoObject getBestMap(double lat, double lon) {
+		if (size() == 0) return null;
+		MapInfoObject mi;
+		MapInfoObject bestMap = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		int minDistMap = -1; // return this value if you are interested in the number of the map
+		boolean better = false;
+		for (int i=0; i < size() ;i++) {
+			better = false;
+			mi = (MapInfoObject)get(i);
+			latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+			lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+			if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+			if ( !better && (latNearer || lonNearer )) { 
+				if ( mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+			}
+			if (better) {
+				minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+				minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+				minDistMap = i;
+				bestMap = mi;
+				// Vm.debug("better"+ i);
+			}
+		}
+		return bestMap; // return minDistMap
+	}
+
+	public MapInfoObject getMapForRect(CWPoint topleft, CWPoint bottomright){
+		MapInfoObject mi;
+		MapInfoObject fittingmap = null;
+		for (int i=0; i < size() ;i++) {
+			mi = (MapInfoObject)get(i);
+			if (mi.inBound(topleft) && mi.inBound(bottomright)) {
+				if (fittingmap == null || fittingmap.scaleX > mi.scaleX) fittingmap = mi;
+			}
+		} // for
+		return fittingmap;
+	}
+}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-24 04:09:48 UTC (rev 450)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-25 00:16:35 UTC (rev 451)
@@ -23,7 +23,7 @@
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
-	Vector maps;
+	MapsList maps;
 	Vector symbols;
 	GotoPanel gotoPanel;
 	Vector cacheDB;
@@ -130,62 +130,25 @@
 		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
 		if (tracks != null) addOverlaySet();
 	}
-	
+
 	/**
 	 * loads the list of maps
 	 *
 	 */
 	public void loadMaps(String mapsPath, double lat){
 		this.mapPath = mapsPath;
-		Vm.showWait(true);
+		Vm.showWait(this, true);
 		resetCenterOfMap();
 		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
 		inf.exec();
-		maps = new Vector(); // forget already loaded maps
-		//if (mmp.mapImage != null) 
-		String dateien[];
-		File files = new File(mapsPath);
-		String rawFileName = new String();
-		String[] dirstmp = files.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_DIRECTORIES_ONLY);
-		Vector dirs;
-		if (dirstmp != null) dirs = new Vector(dirstmp);
-		else dirs = new Vector();
-		dirs.add("."); // include the mapsPath itself
-		MapInfoObject tempMIO;
-		MessageBox f = null;
-		for (int j = dirs.size()-1; j >= 0; j--) {
-			files = new File(mapsPath+"/"+dirs.get(j));
-			dateien = files.list("*.wfl", File.LIST_FILES_ONLY);
-			for(int i = 0; i < dateien.length;i++){
-				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
-				try {
-					tempMIO = new MapInfoObject();
-					tempMIO.loadwfl(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
-					maps.add(tempMIO);
-				}catch(IOException ex){ 
-					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
-				}catch(ArithmeticException ex){ // affine contain not allowed values 
-					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+mapsPath+dirs.get(j)+"/" + rawFileName+".wfl \n"+ex.toString(), MessageBox.OKB)).exec();
-				} 
-			}
-		}
-		if (maps.isEmpty())
-		{
+		maps = new MapsList(mapsPath);
+		if (maps.isEmpty()) {
 			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung"), MessageBox.OKB)).execute();
 			noMapsAvailable = true;
 		} else noMapsAvailable = false;
-		tempMIO = new MapInfoObject(1.0, lat);
-		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(5.0, lat);
-		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(50.0, lat);
-		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(250.0, lat);
-		maps.add(tempMIO);
-		tempMIO = new MapInfoObject(1000.0, lat);
-		maps.add(tempMIO);
+		maps.addEmptyMaps(lat);
 		inf.close(0);
-		Vm.showWait(false);
+		Vm.showWait(this, false);
 		this.mapsloaded = true;
 	}
 
@@ -209,7 +172,7 @@
 		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.DarkBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
 		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
 	}
-	
+
 	public void forceMapLoad() {
 		forceMapLoad = true;
 		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec); // this sets forceMapLoad to false after loading a map
@@ -495,45 +458,6 @@
 	}
 
 	/**
-	 * find the best map for lat/lon in the list of maps
-	 * currently the best map is the one, whose center is nearest to
-	 * lat/lon
-	 * @param lat
-	 * @param lon
-	 * @return
-	 */
-	private int getBestMap(double lat, double lon) { // finds the map which is next (center of the map) to the gps-position / could be a good idea to seachr only maps which show the current position (use InBound)
-		// maps, gotoPanel.gpsPosition.latDec != 0, gotoPanel.gpsPosition
-		MapInfoObject mi = new MapInfoObject();
-		MapInfoObject bestMap = new MapInfoObject();
-		double minDistLat = 1000000000000000000000000000000000000000000000.0;
-		double minDistLon = 1000000000000000000000000000000000000000000000.0;
-		boolean latNearer, lonNearer;
-		int minDistMap = -1;
-		boolean better = false;
-		for (int i=0; i<maps.size() ;i++) {
-			better = false;
-			mi=(MapInfoObject)maps.get(i);
-			latNearer=java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
-			lonNearer=java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
-			if ( latNearer && lonNearer) better = true;
-			if ( !better && (latNearer || lonNearer )) { 
-				if ( mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
-			}
-			if (better) {
-				minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
-				minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
-				minDistMap = i;
-				bestMap = mi;
-				// Vm.debug("better"+ i);
-			}
-		}
-		//	tmp = secBestMap.center.getDistance(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.lonDec)/secBestMap.sizeKm; // quasi second return value 
-		return minDistMap ;
-	}
-
-
-	/**
 	 * move posCircle to the Center of the Screen
 	 *
 	 */
@@ -761,16 +685,14 @@
 			}
 		}
 	}
-	
+
 	public void setBestMap(double lat, double lon) {
-		int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -> may be it would be better to call it with the coos of the center of the window?, nein, es k?nnte st?ren, wenn man manuell die Karte bewegt und er st?ndig ne neue l?d... bleibt erstmal so
-		MapInfoObject newmap ;
-		newmap = (MapInfoObject) maps.get(newMapN);
+		MapInfoObject newmap = maps.getBestMap(lat, lon); 
 		if (currentMap == null || currentMap.mapName != newmap.mapName) {
 			setMap(newmap, lat, lon);
 			Vm.debug("better map found");
 		}
-		
+
 	}
 
 	public void setGpsStatus (int status) {
@@ -900,7 +822,7 @@
 	public void showMap() {
 		if (mmp != null && mmp.mapImage != null)
 		{ mmp.mapImage.unhide();
-		  mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); 
+		mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); 
 		}
 		mapHidden = false;
 		repaintNow();
@@ -1025,14 +947,14 @@
 		ignoreGps = savegpsstatus;
 	}
 
-/*	public void gotFocus(int how) {
+	/*	public void gotFocus(int how) {
 		super.gotFocus(how);
 		Dimension ws = getSize(null);
 		onWindowResize(ws.width, ws.height);
 		Vm.debug(ws.width + " h: "+ws.height);
 		this.setPreferredSize(width, height)
 	}
-*/
+	 */
 	public void onEvent(Event ev){
 		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
 			gotoPanel.runMovingMap = false;
@@ -1161,7 +1083,7 @@
 		if (mapImage!= null) {
 			p = mapImage.locAlways;
 			mapImage.move(p.x+diffX,p.y+diffY);
-	//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
@@ -1257,7 +1179,7 @@
 			AniImage clickedOnImage = images.findHotImage(p);
 			if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
 				clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
-				openCacheDescMenuItem = new MenuItem("Open '"+clickedCache.CacheName+"'$o");
+				if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+clickedCache.CacheName+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
 				kontextMenu.addItem(openCacheDescMenuItem);
 			}
 			kontextMenu.exec(this, new Point(p.x, p.y), this);
@@ -1331,9 +1253,9 @@
 						CacheHolder newWP = new CacheHolder();
 						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
 						mm.gotoPanel.mainT.detP.newWaypoint(newWP, mm.gotoPanel.mainT);
-						
+
 					}
-					
+
 				}
 			} // if (ev.target == kontextMenu)
 		} // if (ev instanceof ControlEvent ) 
@@ -1427,6 +1349,7 @@
 		okButton = new mButton("Select");
 		okButton.setHotKey(0, KeyEvent.getActionKey(true));
 		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton.takeFocus(0);
 	}
 	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
 		String testitem = new String();
@@ -1442,6 +1365,27 @@
 		return false;
 	}
 
+	public void mapSelected() {
+		try { 
+			selectedMap = null;
+			int mapNum = 0;
+			String it = new String();
+			it = list.getText();
+			if (it != ""){
+				it = it.substring(0,it.indexOf(':'));
+				mapNum = Convert.toInt(it);
+				//	Vm.debug("Kartennummer: " + mapNum);
+				selectedMap = (MapInfoObject)maps.get(mapNum);
+				selected = true;
+				this.close(FormBase.IDOK);
+			}
+			else {
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+	}
+
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == cancelButton){
@@ -1449,29 +1393,16 @@
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okButton){
-				try {
-					selectedMap = null;
-					int mapNum = 0;
-					String it = new String();
-					it = list.getText();
-					if (it != ""){
-						it = it.substring(0,it.indexOf(':'));
-						mapNum = Convert.toInt(it);
-						//	Vm.debug("Kartennummer: " + mapNum);
-						selectedMap = (MapInfoObject)maps.get(mapNum);
-						selected = true;
-						this.close(FormBase.IDOK);
-					}
-					else {
-						selected = false;
-						this.close(FormBase.IDCANCEL);
-					}
-				}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+				mapSelected();
 			}
 		}
 		super.onEvent(ev);
 	}
+	
+	public void  penDoubleClicked(Point where) {
+		mapSelected();
+	}
 }
 
 class MapSymbol extends AniImage {
@@ -1619,32 +1550,32 @@
 		widthi = getWidth();
 		heighti = getHeight();
 	}
-	
+
 	public MapImage(String f) {
 		super(f);
 		widthi = getWidth(); // this is necessary becaus width is not directly accessable from here and an function call each time the pos ist updated shall be avoided becaus of performance reasons
 		heighti = getHeight();
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
-	
+
 	public MapImage(mImage im) {
 		super(im);
 		widthi = getWidth();
 		heighti = getHeight();
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
-	
+
 	public static void setScreenSize(int w, int h) {
 		screenDim = new Dimension(w, h);
 	}
-	
+
 	public void setImage(Image im, Color c) {
 		super.setImage(im, c);
 		widthi = getWidth();
 		heighti = getHeight();
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
-	
+
 	public void setLocation (int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
@@ -1656,7 +1587,7 @@
 			super.move(0, 0);
 		}
 	}
-	
+
 	public void move (int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
@@ -1668,13 +1599,13 @@
 			super.move(0, 0);
 		}
 	}
-		
+
 	public boolean isOnScreen() { 
 		if ( (locAlways.x + widthi > 0 && locAlways.x < screenDim.width) && 
 				(locAlways.y + heighti > 0 && locAlways.y < screenDim.height) ) return true;
 		else return false;
 	}
-	
+
 	public void hide() {
 		hidden = true;
 		properties |= AniImage.IsInvisible;



From bilbowolf at mail.berlios.de  Thu Jan 25 12:45:11 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Thu, 25 Jan 2007 12:45:11 +0100
Subject: [Cachewolf-svn] r452 - trunk/src/CacheWolf
Message-ID: <200701251145.l0PBjBNk003327@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-25 12:44:53 +0100 (Thu, 25 Jan 2007)
New Revision: 452

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Blacklist filter funktioniert nun korrekt

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-25 00:16:35 UTC (rev 451)
+++ trunk/src/CacheWolf/Filter.java	2007-01-25 11:44:53 UTC (rev 452)
@@ -209,8 +209,11 @@
 		for(int i = 0; i < cacheDB.size(); i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.is_filtered = true;
-			Vm.debug(ch.CacheName + ": " +ch.is_black);
-			if(ch.is_black == true) ch.is_filtered = false; 
+			//Vm.debug(ch.CacheName + ": " +ch.is_black);
+			if(ch.is_black == true) {
+				ch.is_filtered = false;
+				//Vm.debug("==>not filtered!");
+			}
 			cacheDB.set(i,ch);
 		}
 	}
@@ -358,6 +361,7 @@
 		for(int i = 0; i < cacheDB.size(); i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.is_filtered = false;
+			if(ch.is_black) ch.is_filtered = true;
 			cacheDB.set(i, ch);
 		}
 	}

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-01-25 00:16:35 UTC (rev 451)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-01-25 11:44:53 UTC (rev 452)
@@ -183,6 +183,7 @@
 				Filter flt = new Filter();
 				flt.foundByMe = foundChk.getState();
 				flt.ownedByMe = ownedChk.getState();
+				
 				flt.dist = distIn.getText();
 				flt.diff = difIn.getText();
 				flt.terr = terrIn.getText();
@@ -193,7 +194,12 @@
 				String filterType = new String();
 				String filterVar = new String();
 				String filterRose = new String();
-				
+				filterVar = (archivedChk.getState() == true ? "1" : "0")+
+							(notAvailableChk.getState() == true ? "1" : "0") +
+							(foundChk.getState() == true ? "1" : "0") +
+							(ownedChk.getState() == true ? "1" : "0");
+							
+							
 				int typeMatchPattern = 0;
 				if(tradChk.getState()) typeMatchPattern |= Filter.TRADITIONAL;
 				if(multiChk.getState()) typeMatchPattern |= Filter.MULTI;
@@ -253,15 +259,16 @@
 							 (NW.getState() == true ? "1":"0")+
 							 (NNW.getState() == true ? "1":"0")+
 							 (S.getState() == true ? "1":"0");
-				Vm.showWait(true);
+				
 				InfoBox infB = new InfoBox("Info",MyLocale.getMsg(713,"Saving filter"));
 				infB.exec();
 				Profile pfl = Global.getProfile();
 				pfl.filterRose = filterRose;
 				pfl.filterType = filterType;
+				pfl.filterVar = filterVar;
 				pfl.saveIndex(Global.getPref());
 				infB.close(0);
-				Vm.showWait(false);
+				
 				if(distChc.selectedIndex == 1) flt.distdirec = Filter.SMALLER;
 				else flt.distdirec = Filter.GREATER;
 				if(difChc.selectedIndex == 1) flt.diffdirec = Filter.SMALLER;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-25 00:16:35 UTC (rev 451)
+++ trunk/src/CacheWolf/Profile.java	2007-01-25 11:44:53 UTC (rev 452)
@@ -37,7 +37,7 @@
 	public String filterType = new String("11111111110");
 	public String filterRose = new String("1111111111111111");
 	//filter settings for archived ... owner (section) in filterscreen
-	public String filterVar = new String("0000");
+	public String filterVar = new String("1111");
 	//TODO Add the current filter settings here so that they are restored when the profile is reloaded
 	//TODO Add other settings, such as max. number of logs to spider
 	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
@@ -92,7 +92,7 @@
 				distOC = "0";
 			}
 			
-			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+"\"/>\n");
+			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+"\" var = \""+filterVar+"\"/>\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
@@ -160,6 +160,7 @@
 					ch.is_archived = ex.findNext().equals("true") ? true : false;
 					ch.has_bug = ex.findNext().equals("true") ? true : false;
 					ch.is_black = ex.findNext().equals("true") ? true : false;
+					if(ch.is_black) ch.is_filtered = true;
 					ch.is_owned = ex.findNext().equals("true") ? true : false;
 					ch.is_found = ex.findNext().equals("true") ? true : false;
 					ch.is_new = ex.findNext().equals("true") ? true : false;
@@ -197,6 +198,7 @@
 					ex.setSource(text);
 					filterRose = ex.findNext();
 					filterType = ex.findNext();
+					filterVar = ex.findNext();
 //					 Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-25 00:16:35 UTC (rev 451)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-25 11:44:53 UTC (rev 452)
@@ -116,6 +116,18 @@
 		if (statBar!=null) statBar.updateDisplay();
 	}
 	
+	public void refreshTableBlack(){
+		CacheHolder ch = new CacheHolder();
+		for (int i=0; i<cacheDB.size(); i++){
+			ch = new CacheHolder();
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black) ch.is_filtered = false;
+			else ch.is_filtered = true;
+			cacheDB.set(i, ch);
+		}
+		refreshTable();
+	}
+	
 	public void refreshTable(){
 		myMod.updateRows();
 		tc.update(true);

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-01-25 00:16:35 UTC (rev 451)
+++ trunk/src/CacheWolf/myTableModel.java	2007-01-25 11:44:53 UTC (rev 452)
@@ -142,7 +142,7 @@
 		// - filtered caches are moved to the end
 		for (int i=0; i<cacheDB.size(); i++){
 			ch = (CacheHolder) cacheDB.get(i);
-			if (ch.is_filtered || ch.is_black) {
+			if (ch.is_filtered) {
 				filteredDB.add(ch);
 			} else {
 				if (ch.isAddiWpt()){
@@ -239,7 +239,7 @@
 					CacheHolder ch = (CacheHolder)cacheDB.get(row);
 					//Vm.debug(String.valueOf(row));
 					//Vm.debug(String.valueOf(cols[col]));
-					if(ch.is_filtered == false && ch.is_black == false){
+					if(ch.is_filtered == false){
 						try{
 							if(colName[col].equals(nmCheck)) {
 /* Replaced mCheckBox with two images: One showing the unticked box, one showing the ticked box



From admin at berlios.de  Thu Jan 25 16:26:23 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 16:26:23 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10120] version check
Message-ID: <200701251526.l0PFQNRJ015805@unicorn.berlios.de>

Bug #10120, was updated on 2007-Jan-25 16:26
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : none
Summary: version check

Details: wenn ich den PDA offline hab (keine Internetverbindung) kann er doch gar nicht pr?fen ob ne neue Version vorliegt? Trtzdem sagt er mir "you are at the current version" - wie das???

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10120&group_id=2211


From admin at berlios.de  Thu Jan 25 16:26:54 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 16:26:54 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10121] version check
Message-ID: <200701251526.l0PFQs3I015832@unicorn.berlios.de>

Bug #10121, was updated on 2007-Jan-25 16:26
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : none
Summary: version check

Details: wenn ich den PDA offline hab (keine Internetverbindung) kann er doch gar nicht pr?fen ob ne neue Version vorliegt? Trtzdem sagt er mir "you are at the current version" - wie das???

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10121&group_id=2211


From admin at berlios.de  Thu Jan 25 16:27:46 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 16:27:46 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10122] fehlerhafte meldung bei map import
Message-ID: <200701251527.l0PFRkdv015876@unicorn.berlios.de>

Bug #10122, was updated on 2007-Jan-25 16:27
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 1
Submitted by: albsucher
Assigned to : none
Summary: fehlerhafte meldung bei map import

Details: Wenn ich eine Map importiere und beim Dateidialog auf Abbrechen" klicke sagt er "fehler beim Import" - diese Meldung stimmt ja so nicht ganz - vielleicht besser "User abort" oder ganz weglassen. K?nnte evt. auch bei anderen Dialogen vorkommen, hab nicht alle nachgesehen.

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10122&group_id=2211


From admin at berlios.de  Thu Jan 25 16:28:10 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 16:28:10 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10122] fehlerhafte meldung bei map import
Message-ID: <200701251528.l0PFSANT015897@unicorn.berlios.de>

Bug #10122, was updated on 2007-Jan-25 16:27
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : none
Summary: fehlerhafte meldung bei map import

Details: Wenn ich eine Map importiere und beim Dateidialog auf Abbrechen" klicke sagt er "fehler beim Import" - diese Meldung stimmt ja so nicht ganz - vielleicht besser "User abort" oder ganz weglassen. K?nnte evt. auch bei anderen Dialogen vorkommen, hab nicht alle nachgesehen.

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10122&group_id=2211


From admin at berlios.de  Thu Jan 25 16:29:46 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 16:29:46 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10123] caches verwalten - move
Message-ID: <200701251529.l0PFTkY9015987@unicorn.berlios.de>

Bug #10123, was updated on 2007-Jan-25 16:29
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : none
Summary: caches verwalten - move

Details: Evt. User-Error aber:
auf meinem PDA markiere ich caches inder Liste (vorne Haken rein), dann will ich sie verschieben. Dann scheint er noch was zu machen und dann kommt der mir schon unverst?ndliche Dialog "Weiter?" - danach ist Sense=Absturz!
Mach ich was verkehrt oder wie?
Was ich tun wilL: meine gefundenen und/oder eigenen Caches in ein eigenes (sogar vorher angelegtes) Verzeichnis verschieben. 

ich hoff ich hab mich da vest?ndlich genug ausgedr?ckt...

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10123&group_id=2211


From admin at berlios.de  Thu Jan 25 19:10:07 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 19:10:07 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3065] MovingMap: Anzeige von Zoom-Modus
Message-ID: <200701251810.l0PIA7LZ025752@unicorn.berlios.de>

Feature Request #3065, was updated on 2007-Jan-21 02:38
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3065&group_id=2211

Category: None
Status: Closed
Priority: 5
Summary: MovingMap: Anzeige von Zoom-Modus

By: pfeffer
Date: 2007-Jan-25 19:10

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt, mit SVN ca. 450 auch verschiebung nach 
anklicken in manchen f?llen beseitigt

----------------------------------------------------------------------

By: mik77
Date: 2007-Jan-21 02:38

Message:
Logged In: YES 
user_id=34677
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de-AT; rv:1.8.1) Gecko/20061101 SeaMonkey/1.1b Mnenhy/0.7.4.10002

Die Lupe wird gr?n, wenn sie angeklickt wurde und man
sich im Zoom-Modus befindet.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3065&group_id=2211


From admin at berlios.de  Thu Jan 25 19:11:49 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 19:11:49 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3031] Doppelklick in der Cacheliste
Message-ID: <200701251811.l0PIBnKp000499@unicorn.berlios.de>

Feature Request #3031, was updated on 2007-Jan-09 01:58
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211

Category: None
Status: Closed
Priority: 5
Summary: Doppelklick in der Cacheliste 

By: pfeffer
Date: 2007-Jan-25 19:11

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

wenn es funktionert, dann schlie? den Feature-Request 
oder den Bug.
Danke!

----------------------------------------------------------------------

By: cw-tester
Date: 2007-Jan-22 13:27

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

ist OK!!

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3031&group_id=2211


From pfeffer at mail.berlios.de  Thu Jan 25 19:16:17 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Jan 2007 19:16:17 +0100
Subject: [Cachewolf-svn] r453 - trunk/src/CacheWolf
Message-ID: <200701251816.l0PIGHdn020149@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-25 19:15:55 +0100 (Thu, 25 Jan 2007)
New Revision: 453

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/ProfilesForm.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
done and fixed:[ Feature Request #3065 ] MovingMap: Anzeige von Zoom-Modus
fixed: [ Bug #10122 ] fehlerhafte meldung bei map import

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -446,7 +446,7 @@
 	   for(int i = cacheDB.size() -1; i >= 0;i--){
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.addiWpts.clear();
-			ch.mainCache = null;
+			ch.mainCache = null; 
 			dbIndex.put((String)ch.wayPoint, new Integer(i));
 	   }
 	   // Build refeneces

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/InfoBox.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -20,12 +20,22 @@
 		this.title = title;
 		this.addLast(msgArea = new MessageArea(""), CellConstants.STRETCH, CellConstants.FILL);
 		msgArea.setText(info);
+		mB.setHotKey(0, IKeys.ACTION);
+		mB.setHotKey(0, IKeys.ENTER);
+		//mB.set(Control.Invisible, true);
+		//this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+
 	}
 	
 	public String getInput(){
 		return feedback.getText();
 	}
 	
+	public void addText(String t) {
+		msgArea.setText(msgArea.text + t);
+		this.repaintNow();
+	}
+	
 	public InfoBox(String title, String info, int ty){
 		type = ty;
 		this.setPreferredSize(150,50);
@@ -51,6 +61,11 @@
 		this.repaintNow();
 	}
 	
+/*	public void addOkButton() { unfortunately this doesn't work
+		//mB.set(Control.Invisible, false);
+		this.repaintNow();
+	}
+*/
 	public void onEvent(Event ev){
 		if(ev.target == mB){
 			if(type == CHECKBOX) mCB_state = mCB.getState();

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -437,15 +437,7 @@
 			if(mev.selectedItem == importmap){
 
 				Map map = new Map(pref);
-				boolean ok = map.importMap();
-				if(ok == true){
-					InfoBox inf = new InfoBox(MyLocale.getMsg(152,"File import"), MyLocale.getMsg(153,"Map imported successfully"));
-					inf.execute();
-				} else {
-					InfoBox inf = new InfoBox(MyLocale.getMsg(152,"File import"), MyLocale.getMsg(154,"Error importing map"));
-					inf.execute();
-				}
-				
+				map.importMap();
 			}
 			if(mev.selectedItem == chkVersion){
 				Version vers = new Version();

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/Map.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -10,12 +10,12 @@
 import com.stevesoft.ewe_pat.*;
 
 /**
-*	This class is the main class for mapping,
-*	 (moving map, georeferencing maps, etc)
-*	in CacheWolf.
-*	It also provides a class for importing maps
-*	This class id=4100
-*/
+ *	This class is the main class for mapping,
+ *	 (moving map, georeferencing maps, etc)
+ *	in CacheWolf.
+ *	It also provides a class for importing maps
+ *	This class id=4100
+ */
 public class Map extends Form {
 	Preferences pref;
 	String mapsPath = new String();
@@ -29,21 +29,21 @@
 	ScrollBarPanel scp;
 	AniImage mapImg;
 	int imageWidth, imageHeight = 0;
-	
+
 	/**
-	*	This constructor should be used when importing maps
-	*/
+	 *	This constructor should be used when importing maps
+	 */
 	public Map(Preferences pref){
 		this.pref = pref;
 		mapsPath = pref.getMapManuallySavePath()+"/"; //File.getProgramDirectory() + "/maps/";
 	}
-	
+
 	/**
-	*	When a user clicks on the map and more than three ground control points exist
-	*	then the calculated coordinate based on the affine transformation is displayed in the
-	*	info panel below the map.
-	*	It helps to identify how good the georeferencing works based on the set GCPs.
-	*/
+	 *	When a user clicks on the map and more than three ground control points exist
+	 *	then the calculated coordinate based on the affine transformation is displayed in the
+	 *	info panel below the map.
+	 *	It helps to identify how good the georeferencing works based on the set GCPs.
+	 */
 	public void updatePosition(int x, int y){
 		if(GCPs.size()>=3  || (wfl.affine[4] > 0 && wfl.affine[5] > 0)){
 			double x_ = 0;
@@ -54,10 +54,10 @@
 			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
 		}
 	}
-	
+
 	/**
-	*	This is the correct constructor for georeferencing maps.
-	*/
+	 *	This is the correct constructor for georeferencing maps.
+	 */
 	public Map(Preferences pref, String mapToLoad, boolean worldfileexists){
 		this.pref = pref;
 		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
@@ -70,7 +70,7 @@
 		try {
 			wfl.loadwfl(mapsPath, thisMap);
 		}catch(FileNotFoundException ex){
-		//	Vm.debug("Cannot load world file!");
+			//	Vm.debug("Cannot load world file!");
 		}catch (IOException ex) { // is thrown if lat/lon out of range
 			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
 			tmpMB.execute();
@@ -97,11 +97,11 @@
 	}
 
 	/**
-	*	Add a ground control point to the list
-	*	If the list is longer than 3 GCPs these will be evaluated
-	*	to obtain the required parameters for the affine
-	*	transformation.
-	*/
+	 *	Add a ground control point to the list
+	 *	If the list is longer than 3 GCPs these will be evaluated
+	 *	to obtain the required parameters for the affine
+	 *	transformation.
+	 */
 	public void addGCP(GCPoint GCP){
 		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
 		GCPs.add(GCP);
@@ -109,18 +109,18 @@
 			evalGCP();
 		}
 	}
-	
+
 	/**
-	*	Returns the number of ground control points in the list. (Vector GCPs)
-	*/
+	 *	Returns the number of ground control points in the list. (Vector GCPs)
+	 */
 	public int getGCPCount(){
 		return GCPs.size();
 	}
-	
+
 	/**
-	*	Actuall method to evaluate the ground control points and identify the parameters
-	*	for thew affine transformation
-	*/
+	 *	Actuall method to evaluate the ground control points and identify the parameters
+	 *	for thew affine transformation
+	 */
 	private void evalGCP(){
 		//N 48 16.000 E 11 32.000
 		//N 48 16.000 E 11 50.000
@@ -146,7 +146,7 @@
 		wfl.affine[0] = beta.matrix[1][0];
 		wfl.affine[2] = beta.matrix[2][0];
 		wfl.affine[4] = beta.matrix[0][0];
-		
+
 		//Calculate parameters for longitude affine transformation (affine 1,3,5)
 		X = new Matrix(GCPs.size(),3);
 		trg = new Matrix(GCPs.size(),1);
@@ -179,183 +179,188 @@
 		//Vm.debug("A B C" + affine[0] + " " + affine[2] + " " + affine[4]);
 		//Vm.debug("D E F" + affine[1] + " " + affine[3] + " " + affine[5]);
 	}
-	
+
 	/**
-	*	Method to copy ("import") a png based map
-	*	into the maps folder in the CacheWolf base directory.
-	*	
-	*	If the maps directory does not exist it will create it.
-	*	If it finds .map files it will assume these are oziexplorer calibration files.
-	*	It will use these files to automatically georeference the files during import.
-	*/
-	public boolean importMap(){
+	 *	Method to copy ("import") a png based map
+	 *	into the maps folder in the CacheWolf base directory.
+	 *	
+	 *	If the maps directory does not exist it will create it.
+	 *	If it finds .map files it will assume these are oziexplorer calibration files.
+	 *	It will use these files to automatically georeference the files during import.
+	 */
+	public int importMap(){
 		String rawFileName = new String();
 		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
 		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
 		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
-		if(fc.execute() != FormBase.IDCANCEL){
-			File inDir = fc.getChosenFile();
-			File mapFile;
-			try{ // TODO better chekcing for IO-Errors / Disk full etc.
-				//User selected a map, but maybe there are more png(s)
-				//copy all of them!
-				//at the same time try to find associated .map files!
-				//These are georeference files targeted for OziExplorer.
-				//So lets check if we have more than 1 png file:
-				Vector files;
-				String [] filestemp;
-				String line = new String();
-				InputStream in;
-				OutputStream out;
-				FileReader inMap;
-				byte[] buf;
-				int len;
-				String[] parts;
-				filestemp = inDir.list("*.png", File.LIST_FILES_ONLY);
-				files = new Vector(filestemp);
-				filestemp = inDir.list("*.jpg", File.LIST_FILES_ONLY);
-				files.addAll(filestemp);
-				filestemp = inDir.list("*.gif", File.LIST_FILES_ONLY);
-				files.addAll(filestemp);
-				filestemp = inDir.list("*.bmp", File.LIST_FILES_ONLY);
-				files.addAll(filestemp);
-				
-				InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n")); 
-				Vm.showWait(true);
-				inf.exec();
-				String currfile = null;
-				for(int i = files.size() -1 ; i >= 0;i--){
-					currfile = (String) files.get(i);
-					inf.setInfo(MyLocale.getMsg(4110,"Loading:\n")+ " " + currfile);
-					//Copy the file
-					//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
-					//Vm.debug("to: " + mapsPath + files[i]);
-					in = new FileInputStream(inDir.getFullPath() + "/" +currfile);
-					out = new FileOutputStream(mapsPath + currfile);
-					buf = new byte[1024];
-					while ((len = in.read(buf)) > 0) {
-					    out.write(buf, 0, len);
-					}
-					in.close();
-					out.close();
-					// here catch IOException
-					
-					//Check for a .map file
-					rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
-					mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
-					if(mapFile.exists()){
-						GCPoint gcp1 = new GCPoint();
-						GCPoint gcp2 = new GCPoint();
-						GCPoint gcp3 = new GCPoint();
-						GCPoint gcp4 = new GCPoint();
-						GCPoint gcpG = new GCPoint();
-						//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
-						inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
-						while((line = inMap.readLine()) != null){
-							if(line.equals("MMPNUM,4")){
-								
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								gcp1.bitMapX = Convert.toInt(parts[2]);
-								gcp1.bitMapY = Convert.toInt(parts[3]);
-								if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
-								if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
-									
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								gcp2.bitMapX = Convert.toInt(parts[2]);
-								gcp2.bitMapY = Convert.toInt(parts[3]);
-								if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
-								if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
-								
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								gcp3.bitMapX = Convert.toInt(parts[2]);
-								gcp3.bitMapY = Convert.toInt(parts[3]);
-								if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
-								if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
-								imageWidth = gcp3.bitMapX;
-								imageHeight = gcp3.bitMapY;
-								
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								gcp4.bitMapX = Convert.toInt(parts[2]);
-								gcp4.bitMapY = Convert.toInt(parts[3]);
-								if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
-								if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
-									
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								if(pref.digSeparator.equals(",")) {
-									parts[3]= parts[3].replace('.', ',');
-									parts[2]= parts[2].replace('.', ',');
-								}
-								gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-								gcpG.bitMapX = gcp1.bitMapX;
-								gcpG.bitMapY = gcp1.bitMapY;
-								addGCP(gcpG);
-								
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								if(pref.digSeparator.equals(",")) {
-									parts[3]= parts[3].replace('.', ',');
-									parts[2]= parts[2].replace('.', ',');
-								}
-								gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-								gcpG.bitMapX = gcp2.bitMapX;
-								gcpG.bitMapY = gcp2.bitMapY;
-								addGCP(gcpG);
-								
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								if(pref.digSeparator.equals(",")) {
-									parts[3]= parts[3].replace('.', ',');
-									parts[2]= parts[2].replace('.', ',');
-								}
-								gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-								gcpG.bitMapX = gcp3.bitMapX;
-								gcpG.bitMapY = gcp3.bitMapY;
-								addGCP(gcpG);
+		int tmp = fc.execute() ; 
+		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
+		File inDir = fc.getChosenFile();
+		File mapFile;
+		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n")); 
+		Vm.showWait(this, true);
+		inf.exec();
 
-								line = inMap.readLine();
-								parts = mString.split(line, ',');
-								if(pref.digSeparator.equals(",")) {
-									parts[3]= parts[3].replace('.', ',');
-									parts[2]= parts[2].replace('.', ',');
-								}
-								gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-								gcpG.bitMapX = gcp4.bitMapX;
-								gcpG.bitMapY = gcp4.bitMapY;
-								addGCP(gcpG);
-								
-								evalGCP();
-								//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
-								wfl.saveWFL(mapsPath, rawFileName);
-								GCPs.clear();
-							}
-						}
-						inMap.close();
-					}
+		//User selected a map, but maybe there are more png(s)
+		//copy all of them!
+		//at the same time try to find associated .map files!
+		//These are georeference files targeted for OziExplorer.
+		//So lets check if we have more than 1 png file:
+		Vector files;
+		String [] filestemp;
+		String line = new String();
+		InputStream in;
+		OutputStream out;
+		FileReader inMap;
+		byte[] buf;
+		int len;
+		String[] parts;
+		filestemp = inDir.list("*.png", File.LIST_FILES_ONLY);
+		files = new Vector(filestemp);
+		filestemp = inDir.list("*.jpg", File.LIST_FILES_ONLY);
+		files.addAll(filestemp);
+		filestemp = inDir.list("*.gif", File.LIST_FILES_ONLY);
+		files.addAll(filestemp);
+		filestemp = inDir.list("*.bmp", File.LIST_FILES_ONLY);
+		files.addAll(filestemp);
+
+		String currfile = null;
+		for(int i = files.size() -1 ; i >= 0;i--){
+			currfile = (String) files.get(i);
+			inf.setInfo(MyLocale.getMsg(4110,"Loading:\n")+ " " + currfile);
+			//Copy the file
+			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
+			//Vm.debug("to: " + mapsPath + files[i]);
+			try {
+				in = new FileInputStream(inDir.getFullPath() + "/" +currfile);
+				out = new FileOutputStream(mapsPath + currfile);
+				buf = new byte[1024];
+				while ((len = in.read(buf)) > 0) {
+					out.write(buf, 0, len);
 				}
-				inf.close(0);
-				Vm.showWait(false);
-				return true;
-			}catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
-				MessageBox tmpMB = new MessageBox("Error", "Error while importing .map-file: "+ex.getMessage(),MessageBox.OKB);
-				tmpMB.exec();
-			}catch(IOException ex){
-				Vm.debug("Error:" + ex.toString());
+				in.close();
+				out.close();
+			} catch(IOException ex){
+				inf.addText("IO-Error while copying image \n" + ex.getMessage());
 			}
-		}
-		return false;
+
+			//Check for a .map file
+			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
+			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
+			if(mapFile.exists()){
+				GCPoint gcp1 = new GCPoint();
+				GCPoint gcp2 = new GCPoint();
+				GCPoint gcp3 = new GCPoint();
+				GCPoint gcp4 = new GCPoint();
+				GCPoint gcpG = new GCPoint();
+				//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
+				try {
+					inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
+					while((line = inMap.readLine()) != null){
+						if(line.equals("MMPNUM,4")){
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp1.bitMapX = Convert.toInt(parts[2]);
+							gcp1.bitMapY = Convert.toInt(parts[3]);
+							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
+							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp2.bitMapX = Convert.toInt(parts[2]);
+							gcp2.bitMapY = Convert.toInt(parts[3]);
+							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
+							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp3.bitMapX = Convert.toInt(parts[2]);
+							gcp3.bitMapY = Convert.toInt(parts[3]);
+							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
+							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
+							imageWidth = gcp3.bitMapX;
+							imageHeight = gcp3.bitMapY;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp4.bitMapX = Convert.toInt(parts[2]);
+							gcp4.bitMapY = Convert.toInt(parts[3]);
+							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
+							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp1.bitMapX;
+							gcpG.bitMapY = gcp1.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp2.bitMapX;
+							gcpG.bitMapY = gcp2.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp3.bitMapX;
+							gcpG.bitMapY = gcp3.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp4.bitMapX;
+							gcpG.bitMapY = gcp4.bitMapY;
+							addGCP(gcpG);
+
+							evalGCP();
+							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
+							wfl.saveWFL(mapsPath, rawFileName);
+							GCPs.clear();
+						} // if
+
+					} // while
+					if (inMap != null)	inMap.close();
+				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+					inf.addText("\nError while importing .map-file: "+ex.getMessage());
+				} catch(IOException ex){
+					inf.addText("IO-Error while reading or writing calibration file\n" + ex.getMessage());
+				} 
+			} // if map file.exists
+		} // for file
+		Vm.showWait(this, false);
+		inf.addText("\ndone.");
+		//inf.addOkButton(); doesn't work
+		return Form.IDOK;
 	}
-	
 
+
+
 	/**
-	*	Handles button pressed event
-	*	When the button is pressed a mapname.wfl file is saved in the
-	*	maps directory.
-	*/
+	 *	Handles button pressed event
+	 *	When the button is pressed a mapname.wfl file is saved in the
+	 *	maps directory.
+	 */
 	public void onEvent(Event ev){
 
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
@@ -381,10 +386,10 @@
 }
 
 /**
-*	Class that creates a panel and loads a map.
-*	It catches click events to display a form where the user may enter the required ccordinates
-*	The data is stored as a ground control point in the calling class: Map
-*/
+ *	Class that creates a panel and loads a map.
+ *	It catches click events to display a form where the user may enter the required ccordinates
+ *	The data is stored as a ground control point in the calling class: Map
+ */
 class mapInteractivePanel extends InteractivePanel{
 	Map f;
 	Locale l = Vm.getLocale();
@@ -414,16 +419,16 @@
 		g.free();
 		this.repaintNow();
 		f.updatePosition(pos.x, pos.y);
-		
+
 		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
 		if (cooS.execute()==CoordsScreen.IDOK) {
-					GCPoint gcp = new GCPoint(cooS.getCoords());
-					gcp.bitMapX = pos.x;
-					gcp.bitMapY = pos.y;
-					f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
+			GCPoint gcp = new GCPoint(cooS.getCoords());
+			gcp.bitMapX = pos.x;
+			gcp.bitMapY = pos.y;
+			f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
 //			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
-//				coosInputFormat();
-//				this.removeImage(aImg);
+//			coosInputFormat();
+//			this.removeImage(aImg);
 		} else this.removeImage(aImg); // CANCEL pressed
 	}
 
@@ -434,20 +439,20 @@
 	}
 }
 /**
-*	Class based on CWPoint but intended to handle bitmap x and y
-*	Used for georeferencing bitmaps.
-*/
+ *	Class based on CWPoint but intended to handle bitmap x and y
+ *	Used for georeferencing bitmaps.
+ */
 class GCPoint extends CWPoint{
 	public int bitMapX = 0;
 	public int bitMapY = 0;
-	
+
 	public GCPoint(){
 	}
-	
+
 	public GCPoint(CWPoint p) {
 		super(p);
 	}
-	
+
 	public GCPoint(double lat, double lon){
 		this.latDec = lat;
 		this.lonDec = lon;

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -33,7 +33,7 @@
 	mInput scaleInput = new mInput ("3");
 	mInput scaleInputPerCache = new mInput ("3");
 	mLabel overlappingLbl = new mLabel("overlapping in %");
-	mInput overlappingInput = new mInput("20");
+	mInput overlappingInput = new mInput("10");
 	mCheckBox overviewChkBox = new mCheckBox("download an overview map");
 	mCheckBox overviewChkBoxPerCache = new mCheckBox("download an overview map");
 
@@ -119,7 +119,7 @@
 		progressBox.setPreferredSize(230, 150);
 		progressBox.exec();
 		Vm.showWait(true);
-		ewe.fx.Point size = new ewe.fx.Point(700,700); // Size of the downloaded maps
+		ewe.fx.Point size = new ewe.fx.Point(1000,1000); // Size of the downloaded maps
 		MapLoader ml = new MapLoader(Global.getPref().myproxy, Global.getPref().myproxyport);
 		if (forCachesChkBox.getState() || perCache) {
 			calcDownloadRect(); // calculate map boundaries from cacheDB

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/MapsList.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -113,4 +113,11 @@
 		} // for
 		return fittingmap;
 	}
+	/*
+	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
+		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
+			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
+			return false;
+	}
+	*/
 }

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -90,7 +90,6 @@
 		directionArrows.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(directionArrows);
 		buttonImageLens.properties = AniImage.AlwaysOnTop;
-		buttonImageLensActivated.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
 		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageLens);
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
@@ -125,6 +124,7 @@
 		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
 		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
 		DistanceImage.setLocation(w/2 - DistanceImage.location.width/2, h - DistanceImage.location.height -10);
 		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
 		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/ProfilesForm.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -108,7 +108,7 @@
 		} else
 			 return "";
 	}
-	
+
 	private boolean first=true;
 	/**
 	*	The event handler to react to a users selection.

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-01-25 11:44:53 UTC (rev 452)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-01-25 18:15:55 UTC (rev 453)
@@ -129,7 +129,7 @@
 		addPixel(x, y, f);
 	}
 
-	public void paintLastAddedPoint(Track tr) {
+	public void paintLastAddedPoint(Track tr) { // TODO zuer Performanceverbesserung: wenn in den letzten 60 Updates keines mer f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
 		draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
 		paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec);
 	}



From admin at berlios.de  Thu Jan 25 19:16:07 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 25 Jan 2007 19:16:07 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10122] fehlerhafte meldung bei map import
Message-ID: <200701251816.l0PIG7eG011699@unicorn.berlios.de>

Bug #10122, was updated on 2007-Jan-25 16:27
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: albsucher
Assigned to : albsucher
Summary: fehlerhafte meldung bei map import

Details: Wenn ich eine Map importiere und beim Dateidialog auf Abbrechen" klicke sagt er "fehler beim Import" - diese Meldung stimmt ja so nicht ganz - vielleicht besser "User abort" oder ganz weglassen. K?nnte evt. auch bei anderen Dialogen vorkommen, hab nicht alle nachgesehen.

Follow-Ups:

Date: 2007-Jan-25 19:16
By: pfeffer

Comment:
erldeigt mit SVN 453.
dabei au?erdem Fehlermeldungen beim Import verbessert. Bitte testen
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10122&group_id=2211


From kalli at mail.berlios.de  Fri Jan 26 20:19:57 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 26 Jan 2007 20:19:57 +0100
Subject: [Cachewolf-svn] r454 - trunk/resources
Message-ID: <200701261919.l0QJJvmD029342@sheep.berlios.de>

Author: kalli
Date: 2007-01-26 20:19:54 +0100 (Fri, 26 Jan 2007)
New Revision: 454

Modified:
   trunk/resources/info.html
Log:
homepage geaendert
Mik mit aufgenommen

Modified: trunk/resources/info.html
===================================================================
--- trunk/resources/info.html	2007-01-25 18:15:55 UTC (rev 453)
+++ trunk/resources/info.html	2007-01-26 19:19:54 UTC (rev 454)
@@ -3,7 +3,7 @@
 <font face="Tahoma" size = "3">
 <strong>A geocaching programm</strong><br>
 <font face="Tahoma" size = "2"><em>
-from Bilbowolf, Kalli, Pfeffer, Reini, Blackeye501<br>
+from Bilbowolf, Kalli, Pfeffer, Reini, Mik, Blackeye501<br>
 for Windows, Linux and Pocket PC</em><br>
 <br>
 CacheWolf was created sometime 2003 to enable paperless caching with a Sharp Zaurus.
@@ -13,7 +13,7 @@
 CacheWolf was then reprogrammed using EWE, a Java like virtual machine.<BR><BR>
 If you want to help us developing CacheWolf you are welcome!<BR><BR>
 
-CacheWolf Homepage: cachewolf.berlios.de<br>
+CacheWolf Homepage: www.cachewolf.de<br>
 Discussions may be joined at: www.geoclub.de<br><br>
 <STRONG>Cache On 'n Cache hard!</STRONG>
 </font>
\ No newline at end of file



From kalli at mail.berlios.de  Fri Jan 26 21:12:59 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 26 Jan 2007 21:12:59 +0100
Subject: [Cachewolf-svn] r455 - trunk/src/exp
Message-ID: <200701262012.l0QKCxRS000677@sheep.berlios.de>

Author: kalli
Date: 2007-01-26 21:12:47 +0100 (Fri, 26 Jan 2007)
New Revision: 455

Modified:
   trunk/src/exp/Exporter.java
   trunk/src/exp/TPLExporter.java
   trunk/src/exp/TomTomExporter.java
Log:
Zugriff auf Koordinaten in Exportern geaendert

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2007-01-26 19:19:54 UTC (rev 454)
+++ trunk/src/exp/Exporter.java	2007-01-26 20:12:47 UTC (rev 455)
@@ -69,7 +69,6 @@
 		CacheHolder holder;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
-		CWPoint coords = new CWPoint();
 
 
 		if (variant == ASK_FILE) {
@@ -111,17 +110,15 @@
 					case NO_PARAMS: 
 						str = record(holder);
 						break;
-					case LAT_LON:	
-						coords.set(holder.LatLon, CWPoint.CW);
-						if (coords.isValid() == false) continue;
-						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-						             		 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+					case LAT_LON:
+						if (holder.pos.isValid() == false) continue;
+						str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+								     holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
 					case LAT_LON|COUNT: 
-						coords.set(holder.LatLon, CWPoint.CW);
-						if (coords.isValid() == false) continue;
-						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+						if (holder.pos.isValid() == false) continue;
+						str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+									 holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
 											 i);
 						break;
 					default:

Modified: trunk/src/exp/TPLExporter.java
===================================================================
--- trunk/src/exp/TPLExporter.java	2007-01-26 19:19:54 UTC (rev 454)
+++ trunk/src/exp/TPLExporter.java	2007-01-26 20:12:47 UTC (rev 455)
@@ -174,13 +174,13 @@
 				h.progress = (float)i/(float)counter;
 				h.changed();
 				if(holder.is_black == false && holder.is_filtered == false){
+					if (holder.pos.isValid() == false) continue;
 					try{
 						holder.readCache(profile.dataDir);
 					}catch(Exception e){
 						Vm.debug("Problem reading cache page");
 					}
 					try {
-						CWPoint point = new CWPoint(holder.LatLon, CWPoint.CW);
 						Regex dec = new Regex("[,.]",myFilter.decSep);
 						varParams = new Hashtable();
 						varParams.put("TYPE", CacheType.transType(holder.type));
@@ -201,8 +201,8 @@
 						varParams.put("DISTANCE", dec.replaceAll(holder.distance));
 						varParams.put("BEARING", holder.bearing);
 						varParams.put("LATLON", holder.LatLon);
-						varParams.put("LAT", dec.replaceAll(point.getLatDeg(CWPoint.DD)));
-						varParams.put("LON", dec.replaceAll(point.getLonDeg(CWPoint.DD)));
+						varParams.put("LAT", dec.replaceAll(holder.pos.getLatDeg(CWPoint.DD)));
+						varParams.put("LON", dec.replaceAll(holder.pos.getLonDeg(CWPoint.DD)));
 						varParams.put("STATUS", holder.CacheStatus);
 						varParams.put("DATE", holder.DateHidden);
 						varParams.put("URL", holder.URL);

Modified: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2007-01-26 19:19:54 UTC (rev 454)
+++ trunk/src/exp/TomTomExporter.java	2007-01-26 20:12:47 UTC (rev 455)
@@ -74,7 +74,6 @@
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 		int currExp, counter;
-		CWPoint coords = new CWPoint();
 		
 		pbf.showMainTask = false;
 		pbf.setTask(h,"Exporting ...");
@@ -101,11 +100,11 @@
 						currExp++;
 						h.progress = (float)currExp/(float)counter;
 						h.changed();
-						coords.set(holder.LatLon, CWPoint.CW);
+						if (holder.pos.isValid() == false) continue;
 						if (format == TT_ASC){
-							writeRecordASCII(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+							writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
 						} else {
-							writeRecordBinary(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+							writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
 						}
 					}//if
 				}//for cacheDB
@@ -133,7 +132,6 @@
 		CacheHolder holder;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
-		CWPoint coords = new CWPoint();
 
 		pbf.showMainTask = false;
 		pbf.setTask(h,"Exporting ...");
@@ -156,11 +154,11 @@
 					expCount++;
 					h.progress = (float)expCount/(float)counter;
 					h.changed();
-					coords.set(holder.LatLon, CWPoint.CW);
+					if (holder.pos.isValid() == false) continue;
 					if (format == TT_ASC){
-						writeRecordASCII(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+						writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
 					} else {
-						writeRecordBinary(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+						writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
 					}
 				}//if
 			}//for



From admin at berlios.de  Fri Jan 26 21:33:45 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 26 Jan 2007 21:33:45 +0100 (CET)
Subject: [Bug #7351] Export und zähler
Message-ID: <200701262033.l0QKXjOY009233@unicorn.berlios.de>

Bug #7351, was updated on 2006-May-02 07:14
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: bilbowolf
Assigned to : kalli
Summary: Export und z?hler

Details: Beim export wird immer die cacheDB Gr?sse angezeigt und nicht die Gr??e der gefilterten Datens?tze. Ist nicht ganz logisch.

Follow-Ups:

Date: 2007-Jan-10 00:09
By: kalli

Comment:
In Absprache mit Bilbowolf ?bernommen
-------------------------------------------------------

Date: 2006-Aug-05 11:44
By: kalli

Comment:
Hier k?nnte man vieleicht die Anzeige nehmen, die beim TPL-Export eingebaut wurde.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=7351&group_id=2211


From kalli at mail.berlios.de  Fri Jan 26 21:42:39 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 26 Jan 2007 21:42:39 +0100
Subject: [Cachewolf-svn] r456 - trunk/resources
Message-ID: <200701262042.l0QKgdjI002939@sheep.berlios.de>

Author: kalli
Date: 2007-01-26 21:42:37 +0100 (Fri, 26 Jan 2007)
New Revision: 456

Added:
   trunk/resources/ExpressLogger.tpl
Log:
Feature Request #3059: TPL-Datei fuer Expresslogger

Added: trunk/resources/ExpressLogger.tpl
===================================================================
--- trunk/resources/ExpressLogger.tpl	2007-01-26 20:12:47 UTC (rev 455)
+++ trunk/resources/ExpressLogger.tpl	2007-01-26 20:42:37 UTC (rev 456)
@@ -0,0 +1,16 @@
+<#-- Express Logger GPX -->
+<#-- Codecs: ASCII, UTF8 -->
+<tmpl_par name="charset" value="UTF8">
+<#-- newline: CR, LF, CRLF -->
+<tmpl_par name="newline" value="CRLF">
+<?xml version="1.0" encoding="utf-8"?><br/>
+<gpx><br/>
+<tmpl_loop cache_index>
+   <wpt><br/>
+       <name><tmpl_var name=WAYPOINT></name><br/>
+       <cmlog:log version="1.0" found="true"><br/>
+           <cmlog:notes><tmpl_var name=NOTES></cmlog:notes><br/>
+       </cmlog:log><br/>
+   </wpt><br/>
+</tmpl_loop>
+</gpx><br/>
\ No newline at end of file



From admin at berlios.de  Fri Jan 26 21:42:40 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 26 Jan 2007 21:42:40 +0100 (CET)
Subject: [Feature #3059] TPL-Datei für Express Logger
Message-ID: <200701262042.l0QKgexI019499@unicorn.berlios.de>

Feature Request #3059, was updated on 2007-Jan-16 22:48
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3059&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: TPL-Datei f?r Express Logger

By: kalli
Date: 2007-Jan-16 22:48

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

siehe http://www.geoclub.de/ftopic13554.html

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3059&group_id=2211


From admin at berlios.de  Fri Jan 26 21:43:46 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 26 Jan 2007 21:43:46 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3039] Export TomTom OV2
Message-ID: <200701262043.l0QKhkxW020791@unicorn.berlios.de>

Feature Request #3039, was updated on 2007-Jan-11 12:14
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3039&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Export TomTom OV2

By: kalli
Date: 2007-Jan-11 20:48

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

Der FR beisst sich ein wenig mit dem Wunsch von 
Albsucher, dass zu den Caches auch die richtigen Icons 
angezeigt werden, hierf?r werden die einzelnen Dateien 
ben?tigt. Ich greif mir mal den FR und schaue, ob man 
bei dem Auswahldialog f?r das Vezeichnis irgendetwas 
machen kann, um zu sagen, dass alles in eine Datei 
geschrieben werden soll. Alternativ k?nnte man so 
etwas nat?rlich auch in den Pr?ferenzen einstellen. Ich 
stelle die Frage mal im CW-Forum.

----------------------------------------------------------------------

By: cw-tester
Date: 2007-Jan-11 12:14

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

im Moment werden die Caches in Kategorien
(GC-Multi;GC-Traditional etc.) exportiert. Da ich ?fter
mehrere Zielorte entsprechend der Profile(bzw. einer
Selektion davon)  auf meinem PDA speichere, habe ich
mit der momentanen L?sung ein Problem.
Es sollte hier die M?glichkeit geben einen Dateinamen
vorzugeben.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3039&group_id=2211


From pfeffer at mail.berlios.de  Sat Jan 27 05:57:12 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 27 Jan 2007 05:57:12 +0100
Subject: [Cachewolf-svn] r457 - trunk/src/CacheWolf
Message-ID: <200701270457.l0R4vCQ1009402@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-27 05:57:07 +0100 (Sat, 27 Jan 2007)
New Revision: 457

Added:
   trunk/src/CacheWolf/Area.java
Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MapLoader.java
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Profile.java
Log:
MovingMap um folgende Men?\195?\188punkte (und entsprechene Funktionalit?\195?\164t) erweitert:
---automatischer Kartenwechsel--- 
* immer h?\195?\182chste Aufl?\195?\182sung w?\195?\164hlen, die akt. Pos. und Ziel enthalten 
* immer h?\195?\182chste Aufl?\195?\182sung w?\195?\164hlen 
* manuell gew?\195?\164hlte Aufl?\195?\182sung beibehalten 
---manuell--- 
* Aufl?\195?\182sung w?\195?\164hlen, die alle markierten Caches anzeigt 
* Karte mit n?\195?\164chst h?\195?\182herer Aufl?\195?\182sung laden 
* Karte mit mehr ?\195?\156bersicht w?\195?\164hlen 
--Karte verschieben---
* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
* Karte zum akt. Zentrum verschieben (und ggf. entsprechende Karte laden) 
* Karte zur GPS-Position verschieben (und ggf. entsprechende Karte laden)

Added: trunk/src/CacheWolf/Area.java
===================================================================
--- trunk/src/CacheWolf/Area.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/Area.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -0,0 +1,72 @@
+package CacheWolf;
+
+class Area {
+	 public final static int NOT_ON_EDGE = -1;
+	 public final static int AT_TOP_EDGE = 1;
+	 public final static int AT_RIGHT_EDGE = 2;
+	 public final static int AT_BUTTOM_EDGE = 3;
+	 public final static int AT_LEFT_EDGE = 4;
+	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
+
+	 CWPoint topleft;
+	 CWPoint buttomright;
+
+	 public Area(CWPoint tl, CWPoint br){
+		 topleft = new CWPoint(tl);
+		 buttomright = new CWPoint(br);
+	 }
+
+	 public boolean isInBound(CWPoint p) {
+		 if (topleft.latDec >= p.latDec && topleft.lonDec <= p.lonDec 
+				 && buttomright.latDec <= p.latDec && buttomright.lonDec >= p.lonDec) return true;
+		 else return false;
+	 }
+	 //if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
+		
+	 public boolean isInBound(double lat, double lon) {
+		 if (topleft.latDec >= lat && topleft.lonDec <= lon
+				 && buttomright.latDec <= lat && buttomright.lonDec >= lon) return true;
+		 else return false;
+	 }
+	 
+	 public boolean isOverlapping(Area a) {
+		 if (       isInBound(a.topleft) || isInBound(a.buttomright) 
+				 || isInBound(a.buttomright.latDec, a.topleft.lonDec) // buttom left
+				 || isInBound(a.topleft.latDec, a.buttomright.lonDec) // top right
+				 // in case this is completly within a, the above tests will give false, so testing the otherway around
+				 || a.isInBound(this.topleft) || a.isInBound(this.buttomright)
+				 || a.isInBound(this.buttomright.latDec, this.topleft.lonDec) // buttom left
+				 || a.isInBound(this.topleft.latDec, this.buttomright.lonDec)) // top right
+			 return true;
+		 else return false;
+	 }
+
+	 public boolean equals(Area a) {
+		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) < edgeTolerance 
+				 && java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) < edgeTolerance
+				 && java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) < edgeTolerance
+				 && java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) < edgeTolerance )
+			 return true;
+		 else return false;
+	 }
+	 
+	 public int getEdge(CWPoint tl, CWPoint br) {
+		 if (java.lang.Math.abs(topleft.latDec - br.latDec) < edgeTolerance 
+				 && java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
+				 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
+			 return AT_TOP_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.lonDec - tl.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+				 return AT_RIGHT_EDGE;
+			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
+				 return AT_BUTTOM_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(topleft.lonDec - br.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+				 return AT_LEFT_EDGE;
+			 return NOT_ON_EDGE;
+	 }
+}
\ No newline at end of file

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -540,7 +540,7 @@
 		} catch (IOException e) {
 			(new MessageBox("Error", "Could not connect to GPS-receiver.\n Error while opening serial Port " + e.getMessage()+"\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS", MessageBox.OKB)).execute(); 
 		}
-		currTrack = new Track(RED);
+		currTrack = new Track(RED); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
 	}
 	
 	private String getGotoBtnText() {

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -30,7 +30,7 @@
 	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
-	public float scaleX; // in meters per pixel in horizontal direction
+	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map
 	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
 	public Point shift = new Point (0,0);
 	public CWPoint OrigUpperLeft; // this is only valid after zooming 
@@ -58,11 +58,11 @@
 	 * constructes an MapInfoObject without an associated map
 	 * but with 1 Pixel = scale meters
 	 */
-	public MapInfoObject(double scale, double lat) {
+	public MapInfoObject(double scalei, double lat) {
 		digSep = MyLocale.getDigSeparator();
-		mapName="empty 1 Pixel = "+scale+"meters";
+		mapName="empty 1 Pixel = "+scalei+"meters";
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scale;
+		double pixel2deg = meters2deg * scalei;
 		affine[0]=0; //x2lat
 		affine[1]=pixel2deg / java.lang.Math.cos(lat); //x2lon
 		affine[2]=-pixel2deg; //y2lat
@@ -80,12 +80,12 @@
 	 * with 1 Pixel = scale meters, center and width, hight in pixels
 	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
-	public MapInfoObject(double scale, CWPoint center, int width, int hight, String name) {
+	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
 		digSep = MyLocale.getDigSeparator();
 		mapName = name+".wfl";
 
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scale;
+		double pixel2deg = meters2deg * scalei;
 		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
 		affine[0]=0; //x2lat
 		affine[1]=pixel2deghorizontal; //x2lon
@@ -171,14 +171,17 @@
 			transLonY = affine[0]/nenner;
 
 			// calculate north direction
-			scaleX = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
+			float scaleXpixels = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
 			//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
-			float rotationX2x=(float)transLonX*scaleX;
-			float rotationX2y=(float)transLonY*scaleX;
+			float rotationX2x=(float)transLonX*scaleXpixels;
+			float rotationX2y=(float)transLonY*scaleXpixels;
 			//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
 			//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
 			rotationRad = (float)java.lang.Math.atan(rotationX2y);
 			if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad;
+			// calculate scale in meters per pixel
+			double metersPerLat = 1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0));
+			scale = (float) java.lang.Math.abs((affine[2] * metersPerLat)); 
 		} catch (ArithmeticException ex) { throw new ArithmeticException("Not allowed values in affine\n (matrix cannot be inverted)\n in file \n" + fileNameWFL); }
 	}
 
@@ -306,4 +309,7 @@
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);
 	}
+	public Area getArea(){
+		return new Area(new CWPoint(affine[4], affine[5]), new CWPoint(lowlat, lowlon));
+	}
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/MapLoader.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -146,7 +146,7 @@
 		lonD.decimalPlaces = 4;
 		latD.set(lat);
 		lonD.set(lon);
-		return "expedia_alti"+alti+"_lat"+latD.toString()+"_lon"+lonD.toString()+".gif";
+		return "expedia_alti"+alti+"_lat"+latD.toString().replace(',', '.')+"_lon"+lonD.toString()+".gif";
 	}
 	
 	public void downloadMap(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String path){

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -37,9 +37,8 @@
 	mCheckBox overviewChkBox = new mCheckBox("download an overview map");
 	mCheckBox overviewChkBoxPerCache = new mCheckBox("download an overview map");
 
-	Vector cacheDB;
-	CWPoint topleft, buttomright;
 	CWPoint center;
+	Vector cacheDB;
 	boolean perCache;
 	boolean onlySelected;
 	float radius;
@@ -50,10 +49,10 @@
 
 	public MapLoaderGui(Vector cacheDBi) {
 		super();
-		cacheDB = cacheDBi;
 		this.title = MyLocale.getMsg(1800, "Download georeferenced maps"); 
 		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
 		center = new CWPoint(pref.curCentrePt);
+		cacheDB = cacheDBi;
 		// tiles panel
 		MessageArea desc = new MessageArea(descString);
 		desc.modifyAll(mTextPad.NotEditable | mTextPad.DisplayOnly | mTextPad.NoFocus, mTextPad.TakesKeyFocus);
@@ -122,18 +121,18 @@
 		ewe.fx.Point size = new ewe.fx.Point(1000,1000); // Size of the downloaded maps
 		MapLoader ml = new MapLoader(Global.getPref().myproxy, Global.getPref().myproxyport);
 		if (forCachesChkBox.getState() || perCache) {
-			calcDownloadRect(); // calculate map boundaries from cacheDB
-			if (topleft == null) {
+			Area surArea = Global.getProfile().getSourroundingArea(onlySelected); // calculate map boundaries from cacheDB
+			if (surArea == null) {
 				(new MessageBox("Error", "No Caches are seleted", MessageBox.OKB)).execute();
 				Vm.showWait(false);
 				progressBox.close(0);
 				return;
 			}
-			ml.setTiles(topleft, buttomright, (int)scale, size, 1+ overlapping /100);
+			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, 1+ overlapping /100);
 			// calculate radius and center for overview map
-			center = new CWPoint((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2);
-			double radiuslat = (new CWPoint(center.latDec, buttomright.lonDec)).getDistance(buttomright);
-			double radiuslon = (new CWPoint(buttomright.latDec, center.lonDec)).getDistance(buttomright);
+			center = new CWPoint((surArea.topleft.latDec + surArea.buttomright.latDec)/2, (surArea.topleft.lonDec + surArea.buttomright.lonDec)/2);
+			double radiuslat = (new CWPoint(center.latDec, surArea.buttomright.lonDec)).getDistance(surArea.buttomright);
+			double radiuslon = (new CWPoint(surArea.buttomright.latDec, center.lonDec)).getDistance(surArea.buttomright);
 			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
 		} else 
 		{ // calculate from center point an radius
@@ -172,31 +171,6 @@
 		(new MessageBox("Expedia maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
 	}
 
-	public void calcDownloadRect() {
-		CacheHolder ch;
-		topleft = null;
-		buttomright = null;
-		CWPoint tmpca = new CWPoint();
-		numCaches = 0;
-		for (int i=cacheDB.size()-1; i >= 0; i--) {
-			ch = (CacheHolder) cacheDB.get(i);
-			if (!onlySelected || ch.is_Checked) {
-				if (ch.pos == null) { // this can not happen
-					tmpca.set(ch.LatLon);
-					ch.pos = new CWPoint(tmpca);
-				}
-				if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0 ){ // TODO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
-					if (topleft == null) topleft = new CWPoint(ch.pos);
-					if (buttomright == null) buttomright = new CWPoint(ch.pos);
-					if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
-					if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
-					if (buttomright.latDec > ch.pos.latDec) buttomright.latDec = ch.pos.latDec;
-					if (buttomright.lonDec < ch.pos.lonDec) buttomright.lonDec = ch.pos.lonDec;
-					numCaches++;
-				}
-			}
-		}
-	}
 
 	private void updateForCachesState() {
 		int a, b;

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/MapsList.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -3,21 +3,24 @@
 import ewe.io.File;
 import ewe.io.IOException;
 import ewe.ui.MessageBox;
+import ewe.util.Hashtable;
 import ewe.util.Vector;
+import ewe.fx.*;
 /**
  * class to handle a list of maps
- * it loads the list, finds the best map for a given location
+ * it loads the list, finds the best map for a given location,
  * says if a map is available for a given lat lon at a given scale
  * @author r
  *
  */
 public class MapsList extends Vector {
+	public float scaleTolerance = 0.01f; // absolute deviations from this factor are seen to have the same scale
+	public Hashtable scales2Area;
 
 	/**
 	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
 	 * @param mapsPath
 	 */
-
 	public MapsList(String mapsPath) {
 		super(); // forget already loaded maps
 		//if (mmp.mapImage != null) 
@@ -65,59 +68,165 @@
 
 	/**
 	 * find the best map for lat/lon in the list of maps
-	 * currently the best map is the one, whose center is nearest to
+	 * currently the best map is the one, whose center is nearest to lat/lon
+	 * and in Area with ist scale nearest to scale.
 	 * it always return a map (if the list is not empty) 
 	 * even if the map is not inbound
 	 * lat/lon
 	 * @param lat
 	 * @param lon
+	 * @param forceScale: when true, return null if no map with specified scale could be found
 	 * @return
 	 */
-public MapInfoObject getBestMap(double lat, double lon) {
+	public MapInfoObject getBestMap(double lat, double lon, Rect screen, float scale, boolean forceScale) {
 		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
 		MapInfoObject mi;
-		MapInfoObject bestMap = (MapInfoObject)get(0);
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
 		double minDistLat = 1000000000000000000000000000000000000000000000.0;
 		double minDistLon = 1000000000000000000000000000000000000000000000.0;
 		boolean latNearer, lonNearer;
-		int minDistMap = -1; // return this value if you are interested in the number of the map
 		boolean better = false;
-		for (int i=0; i < size() ;i++) {
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i >= 0 ;i--) { 
 			better = false;
 			mi = (MapInfoObject)get(i);
-			latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
-			lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
-			if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
-			if ( !better && (latNearer || lonNearer )) { 
-				if ( mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+			if (screenArea == null || java.lang.Math.abs(mi.scale - lastscale) > scaleTolerance) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
 			}
-			if (better) {
-				minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
-				minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
-				minDistMap = i;
-				bestMap = mi;
-				// Vm.debug("better"+ i);
+			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
+				if (!forceScale || (forceScale && java.lang.Math.abs(mi.scale - scale) > scaleTolerance)) { // different scale?
+					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || (java.lang.Math.abs(mi.scale-scale) + scaleTolerance < java.lang.Math.abs(bestMap.scale-scale))))) 
+						better = true; // inbound and higher resolution -> better
+					else {
+						if ( bestMap == null || (java.lang.Math.abs(mi.scale-scale) < java.lang.Math.abs(bestMap.scale-scale) + scaleTolerance)) {
+							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+							lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+							if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+							else {
+								if ( (latNearer || lonNearer )) { 
+									if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+								}
+							}
+						}
+					}
+					if (better) {
+						minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+						minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+						bestMap = mi;
+						// Vm.debug("better"+ i);
+					}
+				}
 			}
 		}
-		return bestMap; // return minDistMap
+		return bestMap;
 	}
-
-	public MapInfoObject getMapForRect(CWPoint topleft, CWPoint bottomright){
+	/*
+	public MapInfoObject getBestMapNotStrictScale(double lat, double lon, Area screen, float scale) {
+		MapInfoObject ret = getBestMap(lat, lon, screen, scale, true);
+		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
+		return ret;
+	}
+	 */
+	/**
+	 * return a map which includs topleft and bottomright
+	 * if no map includes both it returns null 
+	 */
+	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
 		MapInfoObject mi;
 		MapInfoObject fittingmap = null;
-		for (int i=0; i < size() ;i++) {
+		for (int i=size() -1; i>=0 ;i--) {
 			mi = (MapInfoObject)get(i);
 			if (mi.inBound(topleft) && mi.inBound(bottomright)) {
-				if (fittingmap == null || fittingmap.scaleX > mi.scaleX) fittingmap = mi;
+				if (fittingmap == null || fittingmap.scale > mi.scale) fittingmap = mi;
 			}
 		} // for
 		return fittingmap;
 	}
-	/*
+
+	/**
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @param screen
+	 * @param curScale
+	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
+	 * @return
+	 */
+	public MapInfoObject getMapChangeResolution(double lat, double lon, Rect screen, float curScale, boolean moreDetails){
+		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i >= 0 ;i--) { 
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (mi.fileNameWFL == "") continue; // exclude "maps" without image
+			if (screenArea == null || java.lang.Math.abs(mi.scale - lastscale) > scaleTolerance) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi.getArea())) { // is on screen
+				if (bestMap == null || java.lang.Math.abs(mi.scale - bestMap.scale) > scaleTolerance) { // different scale then known bestMap?
+					if (mi.inBound(lat, lon) && (      // more details                                 // less details than bestmap
+							(moreDetails && (curScale > mi.scale + scaleTolerance) && (bestMap == null || mi.scale-scaleTolerance > bestMap.scale) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
+							|| (!moreDetails && (curScale < mi.scale - scaleTolerance) && (bestMap == null || mi.scale + scaleTolerance < bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
+					) )	better = true;	// inbound and higher resolution if higher res wanted -> better
+				} else { // same scale as bestmap -> look if naerer 
+					latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+					lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+					if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+					else {
+						if ( (latNearer || lonNearer )) { 
+							if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+						}
+					}
+				} // same scale
+				if (better) {
+					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+					bestMap = mi;
+					// Vm.debug("better"+ i);
+				}
+			}
+		}
+		return bestMap;
+	}
+	/**
+	 * returns an area in lat/lon of the screen
+	 * @param a screen width / height and position of lat/lon on the screen
+	 * @param lat
+	 * @param lon
+	 * @param scale
+	 * @param map
+	 * @return
+	 */
+	private Area getAreaForScreen(Rect a, double lat, double lon, float scale, MapInfoObject map) {
+		Area ret = null;
+/*		if (scales2Area == null) scales2Area = new Hashtable();
+		else ret = (Area)scales2Area.get(scale);
+		if (ret != null) return ret;
+	*/	// calculate screen Area
+		Point xy = map.calcMapXY(lat, lon);
+		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
+		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
+		//scales2Area.put(new Float(scale), ret);
+		return ret; 
+	}
+
+	/** for determining if a new map should be downloaded
 	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
 		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
 			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
 			return false;
 	}
-	*/
+	 */
 }

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -54,7 +54,6 @@
 	boolean ignoreGpsStatutsChanges = false;
 	boolean autoSelectMap = true;
 	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
-	CWPoint lastUpatePosition = new CWPoint();
 	boolean mapHidden = false;
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
@@ -109,11 +108,14 @@
 		posCircleLat = -361;
 		posCircleLon = -361; // make them invalid
 		updateDistance(); // fill Rect with transparent color
+		scaleWanted = 1;
+		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 	}
 
 	public void resizeTo(int w,int h) {
 		super.resizeTo(w, h);
 		updateFormSize(w, h);
+		Vm.debug("resizeTo");
 	}
 
 	public void updateFormSize(int w, int h) {
@@ -175,7 +177,7 @@
 
 	public void forceMapLoad() {
 		forceMapLoad = true;
-		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec); // this sets forceMapLoad to false after loading a map
+		updatePosition(posCircleLat, posCircleLon); // this sets forceMapLoad to false after loading a map
 	}
 
 	public final FormFrame myExec() {
@@ -586,6 +588,8 @@
 		removeGotoPosition();
 		gotoPos=addSymbol("goto", "goto_map.png", lat, lon);
 		updateDistance();
+		forceMapLoad = true;
+		updatePosition(posCircleLat, posCircleLon);
 	}
 
 	public void removeGotoPosition() {
@@ -601,10 +605,7 @@
 		if (symbols == null) return;
 		symbols.removeAllElements();
 		if (gotoPos != null) symbols.add(gotoPos);
-		/*			for (int i=symbols.size()-1; i>=0; i--) {
-				if (((MapSymbol)symbols.get(i)).name != "goto") removeMapSymbol(i);
-			}
-		 */	}
+	}
 
 	public void removeMapSymbol(String name) {
 		int symbNr = findMapSymbol(name);
@@ -629,17 +630,14 @@
 	/**
 	 * Move the map so that the posCircle is at lat/lon
 	 * 
-	 * @param lat && lon == -361 -> ignore lat/lon, set map position to upperleft corner of window 
+	 * @param  
 	 */
 	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
-
 		Point mapPos = new Point(0,0);
 		Point oldMapPos = getMapPositionOnScreen();
-		if (lat != -361.0 || lon != -361.0) {
-			posCircleLat = lat;
-			posCircleLon = lon;
-			mapPos = getMapPositionOnScreen();
-		}
+		posCircleLat = lat;
+		posCircleLon = lon;
+		mapPos = getMapPositionOnScreen();
 		//Vm.debug("mapx = " + mapx);
 		//Vm.debug("mapy = " + mapy);
 		if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
@@ -656,6 +654,7 @@
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
 	 */
 	public void updatePosition(double lat, double lon){
+		Vm.debug("updatepors, lat: "+lat+" lon: "+lon);
 		if (!mapsloaded) {
 			loadMaps(mapPath, lat);
 			lastCompareX = Integer.MAX_VALUE;
@@ -665,14 +664,12 @@
 			forceMapLoad = false;
 			return;
 		}
-		lastUpatePosition.latDec = lat;
-		lastUpatePosition.lonDec = lon;
 		if(!ignoreGps || forceMapLoad){
 			updateOnlyPosition(lat, lon, true);
 			if (autoSelectMap || forceMapLoad) {
 				Point mapPos = getMapPositionOnScreen();
-				if (forceMapLoad || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
-						|| 	mmp.mapImage == null )) 	{
+				if (forceMapLoad || wantMapTest|| (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
+						|| 	mmp.mapImage == null )) 	{ // if force || want || map doesn't cover the scree completly
 					//Vm.debug("Screen not completly covered by map");
 					if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > MyLocale.getScreenHeight()/10)) {
 						// more then 1/10 of screen moved since last time we tried to find a better map
@@ -685,15 +682,112 @@
 			}
 		}
 	}
+	int mapChangeModus;
+	float scaleWanted;
+	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	public final static int HIGHEST_RESOLUTION = 2;
+	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
 
+	/**
+	 * loads the best map for lat/lon according to mapChangeModus
+	 * lat/lon will be at the screen-pos of posCircle
+	 * when posCircle is not on the screen (shifted outside my the user)
+	 * then this routine uses the center of the screen to find the best map
+	 * but anyway the map will be adjusted (moved) relativ to posCircle
+	 * when a better map was found the called method updateposition will set
+	 * posCirleLat/-Lon to lat/lon.
+	 * 
+	 * @param lat
+	 * @param lon
+	 */
 	public void setBestMap(double lat, double lon) {
-		MapInfoObject newmap = maps.getBestMap(lat, lon); 
-		if (currentMap == null || currentMap.mapName != newmap.mapName) {
+		Object [] s = getRectForMapChange(lat, lon);
+		CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		MapInfoObject newmap = null;
+		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		wantMapTest = true;
+		switch (mapChangeModus) {
+		case NORMAL_KEEP_RESOLUTION: 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, scaleWanted, false);
+			if (java.lang.Math.abs(newmap.scale - scaleWanted) < maps.scaleTolerance) wantMapTest = false;
+			break;
+		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
+		case HIGHEST_RESOLUTION_GPS_DEST: 
+			if (gotoPos!= null) newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon));
+			else newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); 
+			break;
+		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
+		}
+		if ( newmap != null && (currentMap == null || currentMap.mapName != newmap.mapName) ) {
 			setMap(newmap, lat, lon);
 			Vm.debug("better map found");
+			return;
 		}
+	}
 
+	public void setResModus (int modus) {
+		mapChangeModus = modus;
+		if (modus == NORMAL_KEEP_RESOLUTION) scaleWanted = currentMap.scale;
+		else setBestMap(posCircleLat, posCircleLon);
 	}
+/**
+ * method to get a point on the screen which must be included in the map
+ * the map methods are looking for. If the poscircle is on the screen this will be 
+ * that point. If it is outside then the center of the screen will be used.
+ * 
+ * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
+ * @param lat
+ * @param lon
+ * @return
+ */
+	public Object[] getRectForMapChange(double lat, double lon) {
+		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		int h = (height != 0 ? height : pref.myAppHeight);
+		int x, y;
+		CWPoint cll;
+		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h) {
+			x = posCircleX; // posCircle is inside the screen
+			y = posCircleY;
+			cll = new CWPoint(lat, lon);
+		} else { // when posCircle out of screen - use center of screen as point which as to be included in the map
+			cll = ScreenXY2LatLon(w/2, h/2);
+			x = w/2;
+			y = h/2;
+		}
+		Object[] ret = new Object[2];
+		ret[0] = cll;
+		ret[1] = new Rect(x, y, w, h);
+		return ret; 
+	}
+	
+	/**
+	 * 
+	 * @param betterOverview true: getmap with better overview
+	 * @return
+	 */
+	public void loadMoreDetailedMap(boolean betterOverview){
+		Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+	//	CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
+		MapInfoObject m = maps.getMapChangeResolution(posCircleLat, posCircleLon, screen, currentMap.scale, !betterOverview);
+		if (m != null) setMap(m, posCircleLat, posCircleLon);
+		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
+	}
+	
+	public void loadMapForAllCaches(){
+		Area sur = Global.getProfile().getSourroundingArea(true);
+		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
+		if (newmap == null ) { // no map that includs all caches is available -> load map with lowest resolution
+			Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+			CWPoint cll = (CWPoint) s[0]; 
+			Rect screen = (Rect) s[1]; 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, Float.MAX_VALUE -1, false);
+		}
+		setMap(newmap, posCircleLat, posCircleLon);
+	}
 
 	public void setGpsStatus (int status) {
 		if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
@@ -820,10 +914,7 @@
 	}
 
 	public void showMap() {
-		if (mmp != null && mmp.mapImage != null)
-		{ mmp.mapImage.unhide();
-		mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); 
-		}
+		if (mmp != null && mmp.mapImage != null) mmp.mapImage.unhide();
 		mapHidden = false;
 		repaintNow();
 	}
@@ -900,7 +991,7 @@
 	 * @param center
 	 */		
 	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
-		Vm.showWait(true);
+		Vm.showWait(this, true);
 		boolean savegpsstatus = ignoreGps;
 		if (mapImage1to1 != null) {
 			ignoreGps = true; // avoid multi-thread problems
@@ -943,7 +1034,7 @@
 		setCenterOfScreen(center);
 		addOverlaySet();
 		this.repaintNow();
-		Vm.showWait(false);
+		Vm.showWait(this, false);
 		ignoreGps = savegpsstatus;
 	}
 
@@ -971,11 +1062,32 @@
  *	Class to display the map bitmap and to select another bitmap to display.
  */
 class MovingMapPanel extends InteractivePanel implements EventListener {
-	Menu mapsMenu;
 	Menu kontextMenu;
 	MenuItem gotoMenuItem = new MenuItem("Goto here$g", 0, null);
+	MenuItem newWayPointMenuItem = new MenuItem("Create new Waypoint here$n", 0, null);;
 	MenuItem openCacheDescMenuItem;
-	MenuItem newWayPointMenuItem = new MenuItem("Create new Waypoint here$n", 0, null);;
+
+	Menu mapsMenu;
+	MenuItem selectMapMI = new MenuItem("Select a map manually$s", 0, null);
+	MenuItem changeMapDirMI = new MenuItem("Change map directory$c", 0, null);
+	MenuItem showMapMI = new MenuItem("Show map", 0, null);
+	MenuItem hideMapMI = new MenuItem("Hide map", 0, null);
+	// automatic
+	MenuItem mapChangeModusMI = new MenuItem("Modus for automatic map change", MenuItem.Separator, null);;
+	MenuItem highestResGpsDestMI = new MenuItem("Highest res. containing dest. & cur. position", 0, null); //immer h?chste Aufl?sung w?hlen, die akt. Pos. und Ziel enthalten 
+	MenuItem highestResolutionMI = new MenuItem("Highest resolution", 0, null); //immer h?chste Aufl?sung w?hlen 
+	MenuItem keepManResolutionMI = new MenuItem("Keep manual resolution", 0, null); // manuell gew?hlte Aufl?sung beibehalten  
+	// manuell
+	MenuItem mapChangeResMI = new MenuItem("Change resolution manually", MenuItem.Separator, null);;
+	MenuItem AllCachesResMI = new MenuItem("Load a map containing all marked caches", 0, null); // Karte w?hlen, die alle markierten Caches enth?lt  
+	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", 0, null); // detailreichere Karte laden 
+	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", 0, null); // Karte mit mehr ?bersicht w?hlen  
+	// move map to
+	MenuItem moveToMI = new MenuItem("Move map to an load map", MenuItem.Separator, null);;
+	MenuItem moveToDestMI = new MenuItem("move to goto point", 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
+	MenuItem moveToGpsMI = new MenuItem("move to GPS position", 0, null);   
+	MenuItem moveToCenterMI = new MenuItem("move to Center", 0, null);   
+
 	CacheHolder clickedCache;
 	MovingMap mm;
 	MapImage mapImage;
@@ -995,7 +1107,7 @@
 			mm.ignoreGps = true;
 			return false;
 		}
-		//if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
+		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.ignoreGps; 
 		mm.ignoreGps = true;
 		saveMapLoc = pos;
@@ -1109,6 +1221,7 @@
 		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
 		if(l.execute() == FormBase.IDOK){
 //			Vm.debug("Trying map: " + l.selectedMap.fileName);
+			mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 			mm.autoSelectMap = false;
 			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
@@ -1134,21 +1247,48 @@
 	 */
 	public void imageClicked(AniImage which, Point pos){
 		if (which == mm.bottonImageChooseMap){
-			mapsMenu = new Menu(new String[]{"Select a map manually$s", "Change map directory$c"}, "map choice");
+			mapsMenu = new Menu();
+			mapsMenu.addItem(selectMapMI);
+			mapsMenu.addItem(changeMapDirMI);
 			if (!mm.noMapsAvailable) 
 			{
-				if (mm.mapHidden) mapsMenu.addItem("show map");
-				else mapsMenu.addItem("hide map");
+				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
+				else mapsMenu.addItem(hideMapMI);
 			}
+
+			// automatic
+			highestResGpsDestMI.modifiers &= ~MenuItem.Checked;
+			highestResolutionMI.modifiers &= ~MenuItem.Checked;
+			keepManResolutionMI.modifiers &= ~MenuItem.Checked;
+			switch (mm.mapChangeModus) {
+			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;   
+			}
+			mapsMenu.addItem(mapChangeModusMI);
+			mapsMenu.addItem(highestResGpsDestMI);
+			mapsMenu.addItem(highestResolutionMI);
+			mapsMenu.addItem(keepManResolutionMI);
+			// manuell
+			mapsMenu.addItem(mapChangeResMI);
+			mapsMenu.addItem(AllCachesResMI);
+			mapsMenu.addItem(moreDetailsMI);
+			mapsMenu.addItem(moreOverviewMI);
+			// move map to
+			mapsMenu.addItem(moveToMI);
+			if (mm.gotoPos != null) moveToDestMI.modifiers &= ~MenuItem.Disabled;
+			else moveToDestMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToDestMI);
+			if (Global.getPref().curCentrePt.isValid()) moveToCenterMI.modifiers &= ~MenuItem.Disabled;
+			else moveToCenterMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToCenterMI);
+			mapsMenu.addItem(moveToGpsMI);
+			
 			//m.set(Menu., status)
 			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
 		}
 		if (which == mm.buttonImageGpsOn) {
-			if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
-				mm.gotoPanel.startGps();
-				mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
-			} 
-			mm.SnapToGps();
+			this.snapToGps();
 		}
 		if (which == mm.buttonImageLens) {
 			mm.setZoomingMode();
@@ -1161,13 +1301,16 @@
 			tmp.type = WindowEvent.CLOSE;
 			mm.postEvent(tmp);
 		}
+	}
 
-		/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
-		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}
-		if (which == mm.arrowDown)	{	moveMap(0,-10);	}
-		if (which == mm.arrowUp)	{	moveMap(0,+10);	} */
+	public void snapToGps() {
+		if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
+			mm.gotoPanel.startGps();
+			mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
+		} 
+		mm.SnapToGps();
 	}
-
+	
 	public void penHeld(Point p){
 		//	if (!menuIsActive()) doMenu(p);
 		if (!mm.zoomingMode) { 
@@ -1194,14 +1337,14 @@
 			if (ev.target == mapsMenu) {
 				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
 				if (ev.type == MenuEvent.SELECTED ) {
+					MenuItem action = (MenuItem) mapsMenu.getSelectedItem(); 
 					if (mapsMenu.getSelectedItem() != null) {
-						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Select a map manually") )
-						{ 
+						//maps
+						if (action == selectMapMI)	{ 
 							mapsMenu.close();
 							chooseMap();
 						}
-						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase("Change map directory") )
-						{
+						if (action == changeMapDirMI)	{
 							mapsMenu.close();
 							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+"/maps");
 							fc.addMask("*.wfl");
@@ -1212,17 +1355,60 @@
 							}
 						}
 						//dont show map
-						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase("hide map") )
-						{
+						if (action == hideMapMI) {
 							mapsMenu.close();
 							mm.hideMap();
 						}
 						// show map
-						if (mapsMenu.getSelectedItem() != null && mapsMenu.getSelectedItem().toString().equalsIgnoreCase("show map") )
-						{
+						if (action == showMapMI) {
 							mapsMenu.close();
 							mm.showMap();
 						}
+						// map change modus
+						if (action == highestResGpsDestMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION_GPS_DEST);
+						}
+						if (action == highestResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
+						}
+						if (action == keepManResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+						}
+						// manually change map resolution
+						if (action == moreDetailsMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+							mm.loadMoreDetailedMap(false);
+						} 
+						if (action == moreOverviewMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+							mm.loadMoreDetailedMap(true);
+						}
+						if (action == AllCachesResMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+							mm.loadMapForAllCaches();
+						}
+						// moveto position
+						if (action == moveToCenterMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(Global.getPref().curCentrePt);
+							mm.repaintNow();
+						}
+						if (action == moveToDestMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(new CWPoint(mm.gotoPos.lat, mm.gotoPos.lon));
+							mm.repaintNow();
+						}
+						if (action == moveToGpsMI) {
+							mapsMenu.close();
+							this.snapToGps();						
+						}
+
 					}
 				}
 			} // if (ev.target == mapsMenu)
@@ -1399,7 +1585,7 @@
 		}
 		super.onEvent(ev);
 	}
-	
+
 	public void  penDoubleClicked(Point where) {
 		mapSelected();
 	}

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-26 20:42:37 UTC (rev 456)
+++ trunk/src/CacheWolf/Profile.java	2007-01-27 04:57:07 UTC (rev 457)
@@ -231,4 +231,34 @@
 		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
 		     last_sync_opencaching+"\ndistOC="+distOC;
 	}
+	public Area getSourroundingArea(boolean onlyOfSelected) {
+		if (cacheDB == null || cacheDB.size() == 0) return null;
+		CacheHolder ch;
+		CWPoint topleft = null;
+		CWPoint buttomright = null;
+		CWPoint tmpca = new CWPoint();
+		int numCaches = 0;
+		for (int i=cacheDB.size()-1; i >= 0; i--) {
+			ch = (CacheHolder) cacheDB.get(i);
+			if (!onlyOfSelected || ch.is_Checked) {
+				if (ch.pos == null) { // this can not happen
+					tmpca.set(ch.LatLon);
+					ch.pos = new CWPoint(tmpca);
+				}
+				if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0 ){ // TODO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
+					if (topleft == null) topleft = new CWPoint(ch.pos);
+					if (buttomright == null) buttomright = new CWPoint(ch.pos);
+					if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
+					if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
+					if (buttomright.latDec > ch.pos.latDec) buttomright.latDec = ch.pos.latDec;
+					if (buttomright.lonDec < ch.pos.lonDec) buttomright.lonDec = ch.pos.lonDec;
+					numCaches++;
+				}
+			}
+		}
+		if (topleft != null && buttomright != null) 
+			return new Area(topleft, buttomright);
+		else return null;
+	}
+
 }



From salzkammergut at mail.berlios.de  Sat Jan 27 11:04:32 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Jan 2007 11:04:32 +0100
Subject: [Cachewolf-svn] r458 - trunk/src/CacheWolf
Message-ID: <200701271004.l0RA4WlD028448@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-27 11:04:29 +0100 (Sat, 27 Jan 2007)
New Revision: 458

Modified:
   trunk/src/CacheWolf/ProfilesForm.java
Log:
Hotkeys fuer Laden des letzten Profils

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2007-01-27 04:57:07 UTC (rev 457)
+++ trunk/src/CacheWolf/ProfilesForm.java	2007-01-27 10:04:29 UTC (rev 458)
@@ -92,6 +92,8 @@
 		addLast(spMList);
 		addNext(btnCancel = new mButton(MyLocale.getMsg(1604,"Cancel")),DONTSTRETCH,DONTFILL|LEFT);
 		addNext(btnOK = new mButton(MyLocale.getMsg(1605,"OK")),DONTSTRETCH,HFILL|RIGHT);
+		btnOK.setHotKey(0, IKeys.ENTER);
+		btnCancel.setHotKey(0, IKeys.ESCAPE);
 		this.baseDir=baseDir;
 		choice.takeFocus(Control.ByKeyboard);
 	}
@@ -109,18 +111,12 @@
 			 return "";
 	}
 
-	private boolean first=true;
 	/**
 	*	The event handler to react to a users selection.
 	*	A return value is created and passed back to the calling form
 	*	while it closes itself.
 	*/
 	public void onEvent(Event ev){
-		// Set focus on the choice control initially
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.FOCUS_IN && first) {
-			first=false;  // There must be a better way to set the focus to the choice control ??!?
-			choice.takeFocus(Control.ByKeyboard);
-		}
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnCancel){
 				close(-1);



From salzkammergut at mail.berlios.de  Sat Jan 27 11:04:57 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Jan 2007 11:04:57 +0100
Subject: [Cachewolf-svn] r459 - trunk/src/CacheWolf
Message-ID: <200701271004.l0RA4vd1028493@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-27 11:04:56 +0100 (Sat, 27 Jan 2007)
New Revision: 459

Modified:
   trunk/src/CacheWolf/Parser.java
Log:
Bugfix Funktion cp()

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-27 10:04:29 UTC (rev 458)
+++ trunk/src/CacheWolf/Parser.java	2007-01-27 10:04:56 UTC (rev 459)
@@ -830,7 +830,7 @@
 	    else if (funcDef.alias.equals("cls")) funcCls();
 	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals("count")) funcCount();
-	    else if (funcDef.alias.equals("cp")) funcCp();     
+	    else if (funcDef.alias.equals("cp")) calcStack.add(funcCp());     
 	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
 	    else if (funcDef.alias.equals("distance")) calcStack.add(new java.lang.Double(funcDistance()));
 	    else if (funcDef.alias.equals("encode")) calcStack.add(funcEncode());



From salzkammergut at mail.berlios.de  Sat Jan 27 15:20:47 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Jan 2007 15:20:47 +0100
Subject: [Cachewolf-svn] r460 - trunk/src/CacheWolf
Message-ID: <200701271420.l0REKlWq019613@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-27 15:20:30 +0100 (Sat, 27 Jan 2007)
New Revision: 460

Modified:
   trunk/src/CacheWolf/MainForm.java
Log:
MainForm: OK Button durch x ersetzt.

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-27 10:04:56 UTC (rev 459)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-27 14:20:30 UTC (rev 460)
@@ -32,7 +32,9 @@
 		pref.debug = dbg;
 		doIt();
 	}
-	protected void checkButtons() {} // Need to disable checkButtons, otherwise OK-Button is always enabled
+	protected void checkButtons() {
+		if (pref.hasCloseButton) super.checkButtons();
+	} 
 
 	public void doIt(){
 		this.title = "CacheWolf " + Version.getRelease();
@@ -43,10 +45,6 @@
 			this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
 			this.resizable = false;
 			this.moveable = false;
-			this.titleOK=new mButton("OK");
-			this.titleOK.borderWidth=0;
-			this.titleOK.foreGround=Color.White;
-			this.titleOK.backGround = Color.DarkBlue;
 			this.windowFlagsToClear=WindowConstants.FLAG_HAS_TITLE;
 		} else 
 			this.setPreferredSize(800, 600);
@@ -57,8 +55,6 @@
 		infB.waitUntilPainted(1000);
 		try{
 			pref.readPrefFile();
-			if (this.titleOK!=null && !pref.hasCloseButton)
-				this.titleOK.modify(ControlConstants.Disabled,0);
 			addGuiFont();
 			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
 				ewe.sys.Vm.exit(0); // User MUST select or create a profile



From salzkammergut at mail.berlios.de  Sat Jan 27 15:26:58 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Jan 2007 15:26:58 +0100
Subject: [Cachewolf-svn] r461 - trunk/src/CacheWolf
Message-ID: <200701271426.l0REQwcr020040@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-27 15:26:46 +0100 (Sat, 27 Jan 2007)
New Revision: 461

Modified:
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/myInteractivePanel.java
Log:
Radar Panel Update:
Zoom in bis 1km (fuer hohe Cachedichte in Staedten)
Gelber 1km Kreis
Cacheinfos beim langen Anklicken (PDA) bzw. Mouseover (PC)

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-01-27 14:20:30 UTC (rev 460)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-01-27 14:26:46 UTC (rev 461)
@@ -28,13 +28,13 @@
 	MainTab mt;
 	boolean penMoving = false;
 	int x1,y1,x2,y2 = 0;
+	boolean reCenterImage=true;
 	/**
 	* Constructor for the radar panel.
 	* Loads images, sets up the interactive panel and
 	* "navigation" buttons.
 	*/
 	public RadarPanel(){
-		
 		cacheImages[0] = new Image("0.png");
 		//cacheImages[1] = new Image();
 		cacheImages[2] = new Image("2.png");
@@ -78,8 +78,7 @@
 		selectedWaypoint = sWp;
 		pref = p;
 		cacheDB = db;
-		double dummy;
-		height = (int)(pref.myAppHeight);
+		height = (int)(pref.myAppHeight)*6/5; // add 10% each at top/bottom 
 		//height = (int)height * 2;
 		////Vm.debug("Height: " + Convert.toString(height));
 		////Vm.debug("App Height: " + Convert.toString(pref.myAppHeight));
@@ -87,6 +86,11 @@
 		//width = (int)width * 2;
 	}
 	
+	// Call this after the center has changed to re-center the radar panel
+	public void recenterRadar() {
+		reCenterImage=true;
+	}
+	
 	/**
 	* Public method to draw the different caches and the
 	* radar background
@@ -101,6 +105,11 @@
 		drawBackground();
 		drawCaches();
 		iActP.repaintNow();
+		if (reCenterImage) {
+			Dimension dispSize=getDisplayedSize(null);
+			iActP.scroll(pref.myAppWidth/10,(height-dispSize.height)/2);
+			reCenterImage=false;
+		}
 	}
 	
 	/**
@@ -114,68 +123,57 @@
 		int x,y = 0;
 		CacheHolder holder;
 		double degrees;
-		int rowCounter = 0;
-		for(int i = 0; i < cacheDB.size(); i++){
+		double pi180=java.lang.Math.PI / 180.0;
+		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false && holder.is_filtered == false)
-			{
-				////Vm.debug(holder.wayPoint + ": " +Convert.toString(holder.degrees));
-				//degrees = (holder.degrees - 360)*-1;
-				degrees = holder.degrees * java.lang.Math.PI / 180;
+			if(!holder.is_black && !holder.is_filtered) {
+				degrees = holder.degrees * pi180;
 				x =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
-				y = new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
-				y=y*-1;
-				if(centerX+x<=width && centerY+y <= height){
-					if(toggleMod == 1){ // draw waypoint names
-						Image img = new Image(fm.getTextWidth(holder.wayPoint),fm.getHeight());
-						Graphics g = new Graphics(img);
-						g.setColor(new Color(0,0,0));
-						g.fillRect(0,0,fm.getTextWidth(holder.wayPoint), fm.getHeight());
-						g.setColor(new Color(255,255,255));
-						g.drawText(holder.wayPoint, 0,0);
-						aImg = new AniImage(img);
-						aImg.setLocation(centerX+x+5,centerY+y);
-						aImg.transparentColor = new Color(0,0,0);
-						aImg.properties = mImage.IsNotHot;
-						iActP.addImage(aImg);
-					}
-					if(toggleMod == 2 && holder.CacheName.length()> 0){ // draw cache names
-						try {
-							Image img = new Image(fm.getTextWidth(holder.CacheName),fm.getHeight());
+				y = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
+				if(centerX+x>=0 && centerY+y>=0 && centerX+x<=width && centerY+y <= height){
+					if (toggleMod>0) {
+						String s;
+						if (toggleMod==1)
+							s=holder.wayPoint;
+						else
+							s=holder.CacheName;
+						if (s.length()>0) { 
+							int tw;
+							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
 							Graphics g = new Graphics(img);
-							g.setColor(new Color(0,0,0));
-							g.fillRect(0,0,fm.getTextWidth(holder.CacheName), fm.getHeight());
-							g.setColor(new Color(255,255,255));
-							g.drawText(holder.CacheName, 0,0);
+							g.setColor(Color.Black);
+							g.fillRect(0,0,tw, fm.getHeight());
+							g.setColor(Color.White);
+							g.drawText(s, 0,0);
 							aImg = new AniImage(img);
 							aImg.setLocation(centerX+x+5,centerY+y);
-							aImg.transparentColor = new Color(0,0,0);
+							aImg.transparentColor = Color.Black;
 							aImg.properties = mImage.IsNotHot;
 							iActP.addImage(aImg);
-						} catch (Exception e) {
-							e.printStackTrace();
 						}
 					}
-					rpi = new RadarPanelImage(cacheImages[Convert.parseInt(holder.type)]);
+					Image imgCache=cacheImages[Convert.parseInt(holder.type)];
+					// If we have no image for the cache type use a question mark
+					if (imgCache==null) imgCache=cacheImages[8]; 
+					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.wayPoint;
-					rpi.rownum = rowCounter;
+					rpi.rownum = i;
 					rpi.setLocation(centerX+x-7,centerY+y-7);
 					iActP.addImage(rpi);
-					if(holder.wayPoint.equals(selectedWaypoint)){
-						Image img = new Image(20, 20);
-						Graphics g = new Graphics(img);
-						g.setColor(new Color(0,0,0));
-						g.fillRect(0,0,20,20);
-						g.setColor(new Color(255,0,0));
-						g.drawEllipse(0,0, 20,20);
-						aImg = new AniImage(img);
+					if(holder.wayPoint.equals(selectedWaypoint)){ // Draw red circle around selected wpt
+						Image imgCircle = new Image(20, 20);
+						Graphics gCircle = new Graphics(imgCircle);
+						gCircle.setColor(Color.Black);
+						gCircle.fillRect(0,0,20,20);
+						gCircle.setColor(new Color(255,0,0));
+						gCircle.drawEllipse(0,0, 20,20);
+						aImg = new AniImage(imgCircle);
 						aImg.setLocation(centerX+x-9,centerY+y-9);
 						aImg.transparentColor = new Color(0,0,0);
 						aImg.properties = mImage.IsNotHot;
 						iActP.addImage(aImg);
 					}
 				}//if center...
-				rowCounter++;
 			}// if is_black...
 		}
 	}
@@ -191,7 +189,7 @@
 		iActP.refresh();
 		Image img = new Image(width, height);
 		Graphics g = new Graphics(img);
-		g.setColor(new Color(0,0,0));
+		g.setColor(Color.Black);
 		//Vm.debug(Convert.toString(height));
 		g.fillRect(0,0,width, height);
 		
@@ -221,8 +219,14 @@
 		}
 		g.drawLine(centerX,0,centerX,height);
 		g.drawLine(0,centerY,width,centerY);
-		
-		g.free();
+
+		// Show 1 KM radius only if we have zoomed in (useful for cities with high density of caches)
+		if (scaleKm<=20) {
+			g.setColor(new Color(255,255,0)); // Yellow for 1km circle
+			radius = radstep/5;
+			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+			g.free();
+		}	
 		AniImage aImg = new AniImage(img);
 		//iActP.addImage(aImg);
 		iActP.backgroundImage = img;
@@ -232,15 +236,19 @@
 	}
 	
 	public void onEvent(Event ev){
-		
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == btPlus){
-				scaleKm = scaleKm - 10;
-				if(scaleKm < 10) scaleKm = 10;
+				if (scaleKm>10) scaleKm = scaleKm - 10;
+				else if (scaleKm==10) scaleKm=5;
+				else if (scaleKm==5) scaleKm=2;
+				else scaleKm=1;
 				drawThePanel();
 			}
 			if (ev.target == btMinus){
-				scaleKm = scaleKm + 10;
+				if (scaleKm==1) scaleKm=2;
+				else if(scaleKm==2) scaleKm=5;
+				else if(scaleKm==5) scaleKm=10;
+				else scaleKm = scaleKm + 10;
 				drawThePanel();
 			}
 			if (ev.target == btToggle){

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2007-01-27 14:20:30 UTC (rev 460)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2007-01-27 14:26:46 UTC (rev 461)
@@ -17,18 +17,66 @@
 	boolean penMoving = false;
 	int x1,y1,x2,y2 = 0;
 	static Color RED = new Color(255,0,0);
+	Font font = new Font("Verdana", Font.BOLD, 10);
+	FontMetrics fm = getFontMetrics();
+	long timePenOn=0;
+	AniImage imgInfo;
+	String strDifficulty=MyLocale.getMsg(1120,"Diff");
+	String strTerrain=MyLocale.getMsg(1121,"Terr");
 	
+	private void clearInfo() {
+		removeImage(imgInfo);
+		imgInfo=null;
+		refresh();
+		onImage=null;
+	}
+	
 	public void imageClicked(AniImage which, Point pos){
-		String fn = new String();
-		if(which instanceof RadarPanelImage){
-			RadarPanelImage ich = (RadarPanelImage)which;
-			mt.selectAndActive(ich.rownum);
+		long timePenOff=Vm.getTimeStampLong();
+		// If the pen rested more than 500 msec, we only display the info and don't treat it as a click
+		if (timePenOff-timePenOn<500 || !Vm.isMobile()) { 
+			String fn = new String();
+			if(which instanceof RadarPanelImage){
+				RadarPanelImage ich = (RadarPanelImage)which;
+				mt.selectAndActive(ich.rownum);
+			}
+		} else {
+			if (imgInfo!=null) clearInfo(); 
 		}
 	}
 	
 	public void setMainTab(MainTab tb){
 		mt = tb;
 	}
+	public boolean imageMovedOn(AniImage which) {
+		timePenOn=Vm.getTimeStampLong();
+		RadarPanelImage imgRP=(RadarPanelImage) which;
+		ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
+		CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+		String s=ch.wayPoint+"  "+ch.CacheSize+" / "+strDifficulty+"="+ch.hard+"  "+strTerrain+"="+ch.terrain;
+		int tw;
+		Image img = new Image(tw=fm.getTextWidth(s)+2,fm.getHeight()+2);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(0,0,255));
+		g.fillRect(0,0,tw, fm.getHeight()+2);
+		g.setColor(Color.White);
+		g.drawText(s, 1,1);
+		imgInfo = new AniImage(img);
+		Rect r=getVisibleArea(null);
+		imgInfo.setLocation(r.x,r.y); // Place the info at top left corner
+		imgInfo.properties = mImage.IsNotHot;
+		addImage(imgInfo);
+		refreshOnScreen(imgInfo);
+		return true;
+	}
+	public boolean imageMovedOff(AniImage which) {
+		clearInfo();
+		return true;
+	}
+	public void onPenEvent(PenEvent ev) {
+		super.onPenEvent(ev);
+		if (ev.type==PenEvent.PEN_UP) clearInfo();
+	}
 	/*
 	public void onEvent(Event ev){
 		BufferedGraphics bfg;



From salzkammergut at mail.berlios.de  Sat Jan 27 15:31:02 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Jan 2007 15:31:02 +0100
Subject: [Cachewolf-svn] r462 - trunk/resources
Message-ID: <200701271431.l0REV2b9020320@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-27 15:31:00 +0100 (Sat, 27 Jan 2007)
New Revision: 462

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Nachtrag zum RadarPanel update

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-27 14:26:46 UTC (rev 461)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-27 14:31:00 UTC (rev 462)
@@ -205,6 +205,8 @@
 		1117=kopieren
 		1118=Profil
 		1119=Alte Profile
+		1120=Schwier
+		1121=Gel%e4nde
 		1200=Liste
 		1201=Details
 		1202=Beschreibung
@@ -498,6 +500,8 @@
 		1117=copy
 		1118=Profile
 		1119=Old Profiles
+		1120=Diff
+		1121=Terr
 		1200=List
 		1201=Details
 		1202=Description



From salzkammergut at mail.berlios.de  Sat Jan 27 16:37:41 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Jan 2007 16:37:41 +0100
Subject: [Cachewolf-svn] r463 - trunk/src/CacheWolf
Message-ID: <200701271537.l0RFbf7O028295@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-27 16:37:27 +0100 (Sat, 27 Jan 2007)
New Revision: 463

Modified:
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/ProfileDataForm.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
updateBearingDistance in Klasse Profile verschoben
Bugfix:Aufruf von updBD nach jeder Aenderung des derzeitigen Zentrums

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/MainForm.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -61,7 +61,7 @@
 			Vm.showWait(true);
 			profile.readIndex();
 			pref.curCentrePt.set(profile.centre);
-			TablePanel.updateBearingDistance(profile.cacheDB,pref);
+			profile.updateBearingDistance();
 		} catch (Exception e){
 			if(pref.debug == true) Vm.debug("MainForm:: Exception:: " + e.toString());
 		}

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/MainTab.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -82,7 +82,7 @@
 	
 	public void updateBearDist(){
 		tbP.pref = pref;
-		TablePanel.updateBearingDistance(cDB,pref);
+		profile.updateBearingDistance();
 		tbP.refreshTable();
 	}
 	

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/Parser.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -333,6 +333,7 @@
 	    	String coordA=popCalcStackAsString();
 			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
 			Global.getPref().curCentrePt.set(coordA);
+			Global.getProfile().updateBearingDistance();
 		}
 	}
 	

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/Profile.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -261,4 +261,37 @@
 		else return null;
 	}
 
+	/**
+		*	Method to calculate bearing and distance of a cache in the index
+		*	list.
+		*	@see	CacheHolder
+		*	@see	Extractor
+		*	@see	Navi
+		*/
+		public void updateBearingDistance(){
+			CWPoint fromPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
+			int anz = cacheDB.getCount();
+			CacheHolder ch;
+			CWPoint toPoint = new CWPoint();
+			// Jetzt durch die CacheDaten schleifen
+			while(--anz >= 0){
+				ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
+				if(ch.LatLon.length()>4){
+					if (ch.pos == null) { // only calculate once
+						toPoint.set(ch.LatLon, CWPoint.CW); // Fast parse with traditional parse algorithm
+						ch.pos = new CWPoint(toPoint);
+					} else toPoint = ch.pos;
+					ch.kilom = fromPoint.getDistance(toPoint);
+					ch.degrees = fromPoint.getBearing(toPoint);
+					ch.bearing = CWPoint.getDirection(ch.degrees);
+					ch.distance = MyLocale.formatDouble(ch.kilom,"0.00");
+					ch.distance = ch.distance + " km";
+				}
+			}
+			// The following call is not very clean as it mixes UI with base classes
+			// However, calling it from here allows us to recenter the
+			// radar panel with only one call
+			Global.mainTab.radarP.recenterRadar();
+		} //updateBearingDistance
+
 }

Modified: trunk/src/CacheWolf/ProfileDataForm.java
===================================================================
--- trunk/src/CacheWolf/ProfileDataForm.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/ProfileDataForm.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -66,6 +66,7 @@
 				if (cs.execute()== CoordsScreen.IDOK){
 					pref.curCentrePt.set(cs.getCoords());
 					btnCurrentCentre.setText(pref.curCentrePt.toString());
+					Global.getProfile().updateBearingDistance();
 				}
 			}
 			if (ev.target == btnProfileCentre){
@@ -83,6 +84,7 @@
 			if (ev.target == btnProf2Cur){
 				pref.curCentrePt.set(profile.centre);
 				btnCurrentCentre.setText(pref.curCentrePt.toString());
+				Global.getProfile().updateBearingDistance();
 			}
 			if (ev.target == btnOldProfiles){
 				ProfilesScreen pfs = new ProfilesScreen(pref);

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -82,7 +82,7 @@
 		//height = (int)height * 2;
 		////Vm.debug("Height: " + Convert.toString(height));
 		////Vm.debug("App Height: " + Convert.toString(pref.myAppHeight));
-		width = (int)(pref.myAppWidth);
+		width = (int)(pref.myAppWidth)*6/5;
 		//width = (int)width * 2;
 	}
 	
@@ -106,8 +106,11 @@
 		drawCaches();
 		iActP.repaintNow();
 		if (reCenterImage) {
+			// Hack to scroll to left origin for a defined position for subsequent
+			// scroll which centers the image
+			iActP.scroll(-1000,-1000); 
 			Dimension dispSize=getDisplayedSize(null);
-			iActP.scroll(pref.myAppWidth/10,(height-dispSize.height)/2);
+			iActP.scroll((width-dispSize.width)/2,(height-dispSize.height+btMinus.getSize(null).height)/2);
 			reCenterImage=false;
 		}
 	}

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/TablePanel.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -106,11 +106,8 @@
 	}
 	
 	public void resetModel() {
-		//RB  myMod.setVector(cacheDB);
 		myMod.numRows = cacheDB.size();
-		updateBearingDistance(cacheDB, pref);
-		////Vm.debug("IS mypref loaded? " + myPreferences.mylgDeg);
-		// tc.setTableModel(myMod); Not needed ?
+		Global.getProfile().updateBearingDistance();
 		myMod.updateRows();
 		tc.update(true);
 		if (statBar!=null) statBar.updateDisplay();
@@ -134,43 +131,6 @@
 		if (statBar!=null) statBar.updateDisplay();
 	}
 	
-	/**
-	*	Method to calculate bearing and distance of a cache in the index
-	*	list.
-	*	@see	CacheHolder
-	*	@see	Extractor
-	*	@see	Navi
-	*/
-	public static void updateBearingDistance(Vector cacheDB, Preferences p){
-		//myPreferences = p;
-
-		CWPoint fromPoint = new CWPoint(p.curCentrePt); // Clone current centre to be sure
-		
-		//Vm.debug(" New location: " + fromPoint);
-		
-		int anz = cacheDB.getCount();
-		CacheHolder ch;
-		CWPoint toPoint = new CWPoint();
-		// Jetzt durch die CacheDaten schleifen
-		while(--anz >= 0){
-			ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
-			if(ch.LatLon.length()>4){
-				if (ch.pos == null) { // only calculate once
-					toPoint.set(ch.LatLon, CWPoint.CW); // Fast parse with traditional parse algorithm
-					ch.pos = new CWPoint(toPoint);
-				} else toPoint = ch.pos;
-				ch.kilom = fromPoint.getDistance(toPoint);
-				ch.degrees = fromPoint.getBearing(toPoint);
-				ch.bearing = CWPoint.getDirection(ch.degrees);
-				ch.distance = MyLocale.formatDouble(ch.kilom,"0.00");
-				ch.distance = ch.distance + " km";
-// skg20061223: These two lines are superfluous as we have already updated the correct CacheHolder object
-//				cacheDB.del(anz);
-//				cacheDB.add(anz, ch);
-			}
-		}
-	} //updateBearingDistance
-	
 	public void onEvent(Event ev)
 	{
 		////Vm.debug(ev.toString());

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-27 14:31:00 UTC (rev 462)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-27 15:37:27 UTC (rev 463)
@@ -114,7 +114,7 @@
 				tmpMB.exec();
 			} else {				
 				pref.curCentrePt.set(cp);
-				TablePanel.updateBearingDistance(db, pref);
+				profile.updateBearingDistance();
 				tbp.refreshTable();
 				(new MessageBox("Info", "Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet", MessageBox.OKB)).execute();
 			}



From salzkammergut at mail.berlios.de  Sat Jan 27 18:28:24 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Jan 2007 18:28:24 +0100
Subject: [Cachewolf-svn] r464 - in trunk/src: CacheWolf exp
Message-ID: <200701271728.l0RHSOxV003865@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-27 18:28:07 +0100 (Sat, 27 Jan 2007)
New Revision: 464

Added:
   trunk/src/exp/LocExporter.java
Modified:
   trunk/src/CacheWolf/MainMenu.java
Log:
Fix: Garmin Export ueber GPSBabel (com: oder usb:)
Benutzt jetzt .loc Datei und kann Symbole fuer
"Geocache" bzw. "Geocache gefunden" setzen

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-27 15:37:27 UTC (rev 463)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-27 17:28:07 UTC (rev 464)
@@ -274,13 +274,14 @@
 			}
 			if(mev.selectedItem == exportGPS){
 				Vm.showWait(true);
-				PCX5Exporter pcx = new PCX5Exporter(pref, profile);
-				pcx.doIt(PCX5Exporter.MODE_AUTO);
+				LocExporter loc = new LocExporter();
+				String tmpFileName = File.getProgramDirectory() + "/temp.loc";
+				loc.setTmpFileName(tmpFileName);
+				loc.doIt(LocExporter.MODE_AUTO);
 				ProgressBarForm.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
-				String cwd = File.getProgramDirectory() + "/temp.pcx";
 				try{
-					ewe.sys.Process p = Vm.exec("gpsbabel -s -i pcx -f \""+ cwd +"\" -o garmin -F " + pref.garminConn +":");
-					Vm.debug("gpsbabel -s -i pcx -f  \""+ cwd +"\" -o garmin -F " + pref.garminConn +":");
+					ewe.sys.Process p = Vm.exec("gpsbabel -i geo -f \""+ tmpFileName +"\" -o garmin -F " + pref.garminConn +":");
+					Vm.debug("gpsbabel -i geo -f  \""+ tmpFileName +"\" -o garmin -F " + pref.garminConn +":");
 					p.waitFor();
 				}catch(IOException ioex){};
 				ProgressBarForm.clear();

Added: trunk/src/exp/LocExporter.java
===================================================================
--- trunk/src/exp/LocExporter.java	2007-01-27 15:37:27 UTC (rev 463)
+++ trunk/src/exp/LocExporter.java	2007-01-27 17:28:07 UTC (rev 464)
@@ -0,0 +1,203 @@
+package exp;
+import CacheWolf.*;
+import ewe.util.Hashtable;
+
+/**
+*	Class to export the cache database into an geocaching .loc file that may be exported
+*	by GPSBabel to a Garmin GPS.
+*/
+public class LocExporter extends Exporter{
+	public static int MODE_AUTO = TMP_FILE;
+	
+	public LocExporter(){
+		super();
+		this.setMask("*.loc");
+		this.setHowManyParams(NO_PARAMS);
+	}
+	
+	public String header () {
+		return "<?xml version=\"1.0\"?><loc version=\"1.0\" src=\"EasyGPS\">\r\n";
+	}
+	
+	public String record(CacheHolder ch){
+		StringBuffer strBuf = new StringBuffer(200);
+		strBuf.append("<waypoint>\r\n   <name id=\"");
+		strBuf.append(simplifyString(ch.wayPoint));
+		strBuf.append("\"><![CDATA[");
+		strBuf.append(simplifyString(ch.CacheName));
+		strBuf.append("]]></name>\r\n   <coord lat=\"");
+		strBuf.append(ch.pos.getLatDeg(CWPoint.DD));
+		strBuf.append("\" lon=\"");
+		strBuf.append(ch.pos.getLonDeg(CWPoint.DD));
+		strBuf.append("\"/>\r\n   <type>");
+		if (ch.is_found)
+			strBuf.append("Geocache Found");
+		else
+			strBuf.append("Geocache");
+		strBuf.append("</type>\r\n</waypoint>\r\n");
+		return strBuf.toString();
+	}
+	public String trailer(){
+		return "</loc>\r\n";
+	}
+
+///////////////////////////////////////////////////
+//  Helper functions for string sanitisation
+///////////////////////////////////////////////////
+	
+	private static Hashtable iso2simpleMappings = new Hashtable(250);
+	static {
+		String[] mappingArray = new String[] {
+				"34",  "'",
+				"160", " ",
+				"161", "i",
+				"162", "c",
+				"163", "$",
+				"164", "o",
+				"165", "$",
+				"166", "!",
+				"167", "$",
+				"168", " ",
+				"169", " ",
+				"170", " ",
+				"171", "<",
+				"172", " ",
+				"173", "-",
+				"174", " ",
+				"175", "-",
+				"176", " ",
+				"177", "+/-",
+				"178", "2",
+				"179", "3",
+				"180", "'",
+				"181", " ",
+				"182", " ",
+				"183", " ",
+				"184", ",",
+				"185", "1",
+				"186", " ",
+				"187", ">",
+				"188", "1/4",
+				"189", "1/2",
+				"190", "3/4",
+				"191", "?",
+				"192", "A",
+				"193", "A",
+				"194", "A",
+				"195", "A",
+				"196", "Ae",
+				"197", "A",
+				"198", "AE",
+				"199", "C",
+				"200", "E",
+				"201", "E",
+				"202", "E",
+				"203", "E",
+				"204", "I",
+				"205", "I",
+				"206", "I",
+				"207", "I",
+				"208", "D",
+				"209", "N",
+				"210", "O",
+				"211", "O",
+				"212", "O",
+				"213", "O",
+				"214", "Oe",
+				"215", "x",
+				"216", "O",
+				"217", "U",
+				"218", "U",
+				"219", "U",
+				"220", "Ue",
+				"221", "Y",
+				"222", " ",
+				"223", "ss",
+				"224", "a",
+				"225", "a",
+				"226", "a",
+				"227", "a",
+				"228", "ae",
+				"229", "a",
+				"230", "ae",
+				"231", "c",
+				"232", "e",
+				"233", "e",
+				"234", "e",
+				"235", "e",
+				"236", "i",
+				"237", "i",
+				"238", "i",
+				"239", "i",
+				"240", "o",
+				"241", "n",
+				"242", "o",
+				"243", "o",
+				"244", "o",
+				"245", "o",
+				"246", "oe",
+				"247", "/",
+				"248", "o",
+				"249", "u",
+				"250", "u",
+				"251", "u",
+				"252", "ue",
+				"253", "y",
+				"254", "p",
+				"255", "y"
+		};
+		for (int i = 0; i < mappingArray.length; i = i + 2) {
+			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
+		}
+	}
+
+	
+	protected static String char2simpleChar( char c )
+    {
+        if ( c < 127 ) {
+            // leave alone as equivalent string.
+            return null;
+        } else {
+            String s=(String) iso2simpleMappings.get( new Integer(c));
+            if (s==null) // not in table, replace with empty string just to be sure
+            	return "";
+            else
+            	return s;
+        }
+    } // end charToEntity
+	
+    public static String simplifyString( String text ) {
+        if ( text == null ) return null;
+        int originalTextLength = text.length();
+        StringBuffer sb = new StringBuffer( 50 );
+        int charsToAppend = 0;
+        for ( int i = 0; i < originalTextLength; i++ ) {
+            char c = text.charAt( i );
+            String entity = char2simpleChar( c );
+            if ( entity == null ) {
+                // we could sb.append( c ), but that would be slower
+                // than saving them up for a big append.
+                charsToAppend++;
+            } else {
+                if ( charsToAppend != 0 ) {
+                    sb.append( text.substring( i - charsToAppend, i ) );
+                    charsToAppend = 0;
+                }
+                sb.append( entity );
+            }
+        } // end for
+        // append chars to the right of the last entity.
+        if ( charsToAppend != 0 ) {
+            sb.append( text.substring( originalTextLength - charsToAppend,
+                                       originalTextLength ) );
+        }
+        // if result is not longer, we did not do anything. Save RAM.
+        return ( sb.length() == originalTextLength ) ? text : sb.toString();
+    } // end insertEntities
+	
+	
+	
+	
+	
+	
+}



From mik77 at mail.berlios.de  Sat Jan 27 21:27:01 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 27 Jan 2007 21:27:01 +0100
Subject: [Cachewolf-svn] r465 - in trunk: resources src/CacheWolf
Message-ID: <200701272027.l0RKR1vH023503@sheep.berlios.de>

Author: mik77
Date: 2007-01-27 21:26:53 +0100 (Sat, 27 Jan 2007)
New Revision: 465

Modified:
   trunk/resources/info.html
   trunk/src/CacheWolf/MapLoader.java
   trunk/src/CacheWolf/MapLoaderGui.java
Log:
?\195?\156berlappung der Expedia maps nun in pixel

Modified: trunk/resources/info.html
===================================================================
--- trunk/resources/info.html	2007-01-27 17:28:07 UTC (rev 464)
+++ trunk/resources/info.html	2007-01-27 20:26:53 UTC (rev 465)
@@ -3,7 +3,7 @@
 <font face="Tahoma" size = "3">
 <strong>A geocaching programm</strong><br>
 <font face="Tahoma" size = "2"><em>
-from Bilbowolf, Kalli, Pfeffer, Reini, Mik, Blackeye501<br>
+from Bilbowolf, Kalli, Pfeffer, Reini, MiK, Blackeye501<br>
 for Windows, Linux and Pocket PC</em><br>
 <br>
 CacheWolf was created sometime 2003 to enable paperless caching with a Sharp Zaurus.

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-01-27 17:28:07 UTC (rev 464)
+++ trunk/src/CacheWolf/MapLoader.java	2007-01-27 20:26:53 UTC (rev 465)
@@ -49,11 +49,11 @@
 	 * @param radius in meters
 	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
 	 * @param size in pixels
-	 * @param overlapping 1.2 means 20% overlapping
+	 * @param overlapping in pixels
 	 * @param path without "/" at the end
 	 * 
 	 */
-	public void setTiles (CWPoint center, float radius, int scale, Point size, float overlapping) {
+	public void setTiles (CWPoint center, float radius, int scale, Point size, int overlapping) {
 		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
 		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
 		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
@@ -62,7 +62,7 @@
 		this.setTiles(topleft, buttomright, scale, size, overlapping);
 	}
 	
-	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, float overlapping) {
+	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, int overlapping) {
 		//if (toplefti.latDec <= buttomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above buttom right");
 		topleft = new CWPoint(toplefti);
 		buttomright = new CWPoint(buttomrighti);
@@ -77,8 +77,10 @@
 		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
 		
 		//border sizes around given area and overlapping between tiles
-		int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
-		int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		int borderX = overlapping;
+		int borderY = overlapping;
 		
 		numMapsY = (int) java.lang.Math.ceil( (pixelsY + (float)borderY) / (float)(size.y - borderY) );
 		numMapsX = (int) java.lang.Math.ceil( (pixelsX + (float)borderX) / (float)(size.x - borderX) );

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-01-27 17:28:07 UTC (rev 464)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-01-27 20:26:53 UTC (rev 465)
@@ -32,8 +32,8 @@
 	mLabel scaleLbl = new mLabel("Approx. m per pixel:");
 	mInput scaleInput = new mInput ("3");
 	mInput scaleInputPerCache = new mInput ("3");
-	mLabel overlappingLbl = new mLabel("overlapping in %");
-	mInput overlappingInput = new mInput("10");
+	mLabel overlappingLbl = new mLabel("overlapping in pixel:");
+	mInput overlappingInput = new mInput("100");
 	mCheckBox overviewChkBox = new mCheckBox("download an overview map");
 	mCheckBox overviewChkBoxPerCache = new mCheckBox("download an overview map");
 
@@ -43,7 +43,7 @@
 	boolean onlySelected;
 	float radius;
 	float scale;
-	float overlapping;
+	int overlapping;
 	boolean overviewmap;
 	int numCaches;
 
@@ -128,7 +128,7 @@
 				progressBox.close(0);
 				return;
 			}
-			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, 1+ overlapping /100);
+			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, overlapping );
 			// calculate radius and center for overview map
 			center = new CWPoint((surArea.topleft.latDec + surArea.buttomright.latDec)/2, (surArea.topleft.lonDec + surArea.buttomright.lonDec)/2);
 			double radiuslat = (new CWPoint(center.latDec, surArea.buttomright.lonDec)).getDistance(surArea.buttomright);
@@ -136,7 +136,7 @@
 			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
 		} else 
 		{ // calculate from center point an radius
-			ml.setTiles(center, radius * 1000, (int)scale, size, 1+ overlapping/100);
+			ml.setTiles(center, radius * 1000, (int)scale, size, overlapping);
 		}
 		if (overviewmap) {
 			progressBox.setInfo("downloading overview map"); 
@@ -207,14 +207,14 @@
 					overviewmap = overviewChkBox.getState();
 					radius = Convert.toFloat(distanceInput.getText());
 					scale = Convert.toFloat(scaleInput.getText());
-					overlapping = Convert.toFloat(overlappingInput.getText());
+					overlapping = Convert.toInt(overlappingInput.getText());
 					if (!forCachesChkBox.getState()) {
 						if (radius <= 0) { 
 							(new MessageBox("Error", "'radius' must be graeter than null", MessageBox.OKB)).execute();
 							return;
 						}
-						if (overlapping < 1 || overlapping > 99) { 
-							(new MessageBox("Error", "'overlapping' must between 1 and 99 ", MessageBox.OKB)).execute();
+						if (overlapping < 0) { 
+							(new MessageBox("Error", "'overlapping' must be greater or equal 0 ", MessageBox.OKB)).execute();
 							return;
 						}
 					}



From kalli at mail.berlios.de  Sun Jan 28 09:07:20 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 28 Jan 2007 09:07:20 +0100
Subject: [Cachewolf-svn] r466 - trunk/src/CacheWolf
Message-ID: <200701280807.l0S87KxK012995@sheep.berlios.de>

Author: kalli
Date: 2007-01-28 09:07:16 +0100 (Sun, 28 Jan 2007)
New Revision: 466

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/Profile.java
Log:
buildReference von CacheHolder nach Profile verschoben, da mit der ganzen Datenbank gearbeit wird.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-27 20:26:53 UTC (rev 465)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-28 08:07:16 UTC (rev 466)
@@ -438,35 +438,6 @@
 	   else return false;
    }
    
-   public static void buildReferences(Vector cacheDB){
-	   CacheHolder ch, mainCh;
-	   Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
-	   Integer index;
-	   // Build index for faster search and clear all references
-	   for(int i = cacheDB.size() -1; i >= 0;i--){
-			ch = (CacheHolder)cacheDB.get(i);
-			ch.addiWpts.clear();
-			ch.mainCache = null; 
-			dbIndex.put((String)ch.wayPoint, new Integer(i));
-	   }
-	   // Build refeneces
-	   for(int i = cacheDB.size() -1; i >= 0;i--){
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.isAddiWpt()) {
-				//search main cache
-				if (ch.wayPoint.length() == 5){
-					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(1));
-				} 
-				else {
-					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
-				}
-				if (index != null) {
-					mainCh = (CacheHolder) cacheDB.get(index.intValue());
-					mainCh.addiWpts.add(ch);
-					ch.mainCache = mainCh;
-				}// if
-			}// if
-	   }// for
-   }
+
   
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-27 20:26:53 UTC (rev 465)
+++ trunk/src/CacheWolf/Profile.java	2007-01-28 08:07:16 UTC (rev 466)
@@ -8,6 +8,7 @@
 import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 import ewe.sys.Vm;
+import ewe.util.Hashtable;
 import ewe.util.Vector;
 
 /**
@@ -111,7 +112,7 @@
 			}
 			detfile.print("</CACHELIST>\n");
 			detfile.close();
-			CacheHolder.buildReferences(cacheDB);
+			buildReferences();
 		}catch(Exception e){
 			Vm.debug("Problem writing to index file "+e.toString());
 		}
@@ -204,7 +205,7 @@
 			}
 			in.close();
 			// Build references between caches and addi wpts
-			CacheHolder.buildReferences(cacheDB);
+			buildReferences();
 			
 		} catch (FileNotFoundException e) {
 			Vm.debug("index.xml not found"); // Normal when profile is opened for first time
@@ -266,7 +267,6 @@
 		*	list.
 		*	@see	CacheHolder
 		*	@see	Extractor
-		*	@see	Navi
 		*/
 		public void updateBearingDistance(){
 			CWPoint fromPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
@@ -294,4 +294,38 @@
 			Global.mainTab.radarP.recenterRadar();
 		} //updateBearingDistance
 
+		/**
+		 * Method to build the reference between addi wpt
+		 * and main cache.
+		 */
+		   public void buildReferences(){
+			   CacheHolder ch, mainCh;
+			   Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
+			   Integer index;
+			   // Build index for faster search and clear all references
+			   for(int i = cacheDB.size() -1; i >= 0;i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					ch.addiWpts.clear();
+					ch.mainCache = null; 
+					dbIndex.put((String)ch.wayPoint, new Integer(i));
+			   }
+			   // Build refeneces
+			   for(int i = cacheDB.size() -1; i >= 0;i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					if (ch.isAddiWpt()) {
+						//search main cache
+						if (ch.wayPoint.length() == 5){
+							index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(1));
+						} 
+						else {
+							index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
+						}
+						if (index != null) {
+							mainCh = (CacheHolder) cacheDB.get(index.intValue());
+							mainCh.addiWpts.add(ch);
+							ch.mainCache = mainCh;
+						}// if
+					}// if
+			   }// for
+		   }
 }



From kalli at mail.berlios.de  Sun Jan 28 10:09:10 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 28 Jan 2007 10:09:10 +0100
Subject: [Cachewolf-svn] r467 - trunk/src/exp
Message-ID: <200701280909.l0S99AaX015511@sheep.berlios.de>

Author: kalli
Date: 2007-01-28 10:09:07 +0100 (Sun, 28 Jan 2007)
New Revision: 467

Modified:
   trunk/src/exp/Exporter.java
   trunk/src/exp/LocExporter.java
   trunk/src/exp/OziExporter.java
Log:
simplifyString() in die ExporterBasisklasse uebernommen, da dies auch anderen Exportern zugute kommt. 
OziExporter bereits angepasst.

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2007-01-28 08:07:16 UTC (rev 466)
+++ trunk/src/exp/Exporter.java	2007-01-28 09:09:07 UTC (rev 467)
@@ -1,7 +1,6 @@
 package exp;
 
 import CacheWolf.*;
-import CacheWolf.CWPoint;
 import ewe.sys.*;
 import ewe.filechooser.FileChooser;
 import ewe.io.BufferedWriter;
@@ -253,5 +252,159 @@
 		return null;
 	}
 
+///////////////////////////////////////////////////
+//  Helper functions for string sanitisation
+///////////////////////////////////////////////////
+	
+	private static Hashtable iso2simpleMappings = new Hashtable(250);
+	static {
+		String[] mappingArray = new String[] {
+				"34",  "'",
+				"160", " ",
+				"161", "i",
+				"162", "c",
+				"163", "$",
+				"164", "o",
+				"165", "$",
+				"166", "!",
+				"167", "$",
+				"168", " ",
+				"169", " ",
+				"170", " ",
+				"171", "<",
+				"172", " ",
+				"173", "-",
+				"174", " ",
+				"175", "-",
+				"176", " ",
+				"177", "+/-",
+				"178", "2",
+				"179", "3",
+				"180", "'",
+				"181", " ",
+				"182", " ",
+				"183", " ",
+				"184", ",",
+				"185", "1",
+				"186", " ",
+				"187", ">",
+				"188", "1/4",
+				"189", "1/2",
+				"190", "3/4",
+				"191", "?",
+				"192", "A",
+				"193", "A",
+				"194", "A",
+				"195", "A",
+				"196", "Ae",
+				"197", "A",
+				"198", "AE",
+				"199", "C",
+				"200", "E",
+				"201", "E",
+				"202", "E",
+				"203", "E",
+				"204", "I",
+				"205", "I",
+				"206", "I",
+				"207", "I",
+				"208", "D",
+				"209", "N",
+				"210", "O",
+				"211", "O",
+				"212", "O",
+				"213", "O",
+				"214", "Oe",
+				"215", "x",
+				"216", "O",
+				"217", "U",
+				"218", "U",
+				"219", "U",
+				"220", "Ue",
+				"221", "Y",
+				"222", " ",
+				"223", "ss",
+				"224", "a",
+				"225", "a",
+				"226", "a",
+				"227", "a",
+				"228", "ae",
+				"229", "a",
+				"230", "ae",
+				"231", "c",
+				"232", "e",
+				"233", "e",
+				"234", "e",
+				"235", "e",
+				"236", "i",
+				"237", "i",
+				"238", "i",
+				"239", "i",
+				"240", "o",
+				"241", "n",
+				"242", "o",
+				"243", "o",
+				"244", "o",
+				"245", "o",
+				"246", "oe",
+				"247", "/",
+				"248", "o",
+				"249", "u",
+				"250", "u",
+				"251", "u",
+				"252", "ue",
+				"253", "y",
+				"254", "p",
+				"255", "y"
+		};
+		for (int i = 0; i < mappingArray.length; i = i + 2) {
+			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
+		}
+	}
 
+	
+	protected static String char2simpleChar( char c )
+    {
+        if ( c < 127 ) {
+            // leave alone as equivalent string.
+            return null;
+        } else {
+            String s=(String) iso2simpleMappings.get( new Integer(c));
+            if (s==null) // not in table, replace with empty string just to be sure
+            	return "";
+            else
+            	return s;
+        }
+    } // end charToEntity
+	
+    public static String simplifyString( String text ) {
+        if ( text == null ) return null;
+        int originalTextLength = text.length();
+        StringBuffer sb = new StringBuffer( 50 );
+        int charsToAppend = 0;
+        for ( int i = 0; i < originalTextLength; i++ ) {
+            char c = text.charAt( i );
+            String entity = char2simpleChar( c );
+            if ( entity == null ) {
+                // we could sb.append( c ), but that would be slower
+                // than saving them up for a big append.
+                charsToAppend++;
+            } else {
+                if ( charsToAppend != 0 ) {
+                    sb.append( text.substring( i - charsToAppend, i ) );
+                    charsToAppend = 0;
+                }
+                sb.append( entity );
+            }
+        } // end for
+        // append chars to the right of the last entity.
+        if ( charsToAppend != 0 ) {
+            sb.append( text.substring( originalTextLength - charsToAppend,
+                                       originalTextLength ) );
+        }
+        // if result is not longer, we did not do anything. Save RAM.
+        return ( sb.length() == originalTextLength ) ? text : sb.toString();
+    } // end insertEntities
+
+
 }

Modified: trunk/src/exp/LocExporter.java
===================================================================
--- trunk/src/exp/LocExporter.java	2007-01-28 08:07:16 UTC (rev 466)
+++ trunk/src/exp/LocExporter.java	2007-01-28 09:09:07 UTC (rev 467)
@@ -40,164 +40,5 @@
 	public String trailer(){
 		return "</loc>\r\n";
 	}
-
-///////////////////////////////////////////////////
-//  Helper functions for string sanitisation
-///////////////////////////////////////////////////
 	
-	private static Hashtable iso2simpleMappings = new Hashtable(250);
-	static {
-		String[] mappingArray = new String[] {
-				"34",  "'",
-				"160", " ",
-				"161", "i",
-				"162", "c",
-				"163", "$",
-				"164", "o",
-				"165", "$",
-				"166", "!",
-				"167", "$",
-				"168", " ",
-				"169", " ",
-				"170", " ",
-				"171", "<",
-				"172", " ",
-				"173", "-",
-				"174", " ",
-				"175", "-",
-				"176", " ",
-				"177", "+/-",
-				"178", "2",
-				"179", "3",
-				"180", "'",
-				"181", " ",
-				"182", " ",
-				"183", " ",
-				"184", ",",
-				"185", "1",
-				"186", " ",
-				"187", ">",
-				"188", "1/4",
-				"189", "1/2",
-				"190", "3/4",
-				"191", "?",
-				"192", "A",
-				"193", "A",
-				"194", "A",
-				"195", "A",
-				"196", "Ae",
-				"197", "A",
-				"198", "AE",
-				"199", "C",
-				"200", "E",
-				"201", "E",
-				"202", "E",
-				"203", "E",
-				"204", "I",
-				"205", "I",
-				"206", "I",
-				"207", "I",
-				"208", "D",
-				"209", "N",
-				"210", "O",
-				"211", "O",
-				"212", "O",
-				"213", "O",
-				"214", "Oe",
-				"215", "x",
-				"216", "O",
-				"217", "U",
-				"218", "U",
-				"219", "U",
-				"220", "Ue",
-				"221", "Y",
-				"222", " ",
-				"223", "ss",
-				"224", "a",
-				"225", "a",
-				"226", "a",
-				"227", "a",
-				"228", "ae",
-				"229", "a",
-				"230", "ae",
-				"231", "c",
-				"232", "e",
-				"233", "e",
-				"234", "e",
-				"235", "e",
-				"236", "i",
-				"237", "i",
-				"238", "i",
-				"239", "i",
-				"240", "o",
-				"241", "n",
-				"242", "o",
-				"243", "o",
-				"244", "o",
-				"245", "o",
-				"246", "oe",
-				"247", "/",
-				"248", "o",
-				"249", "u",
-				"250", "u",
-				"251", "u",
-				"252", "ue",
-				"253", "y",
-				"254", "p",
-				"255", "y"
-		};
-		for (int i = 0; i < mappingArray.length; i = i + 2) {
-			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
-		}
-	}
-
-	
-	protected static String char2simpleChar( char c )
-    {
-        if ( c < 127 ) {
-            // leave alone as equivalent string.
-            return null;
-        } else {
-            String s=(String) iso2simpleMappings.get( new Integer(c));
-            if (s==null) // not in table, replace with empty string just to be sure
-            	return "";
-            else
-            	return s;
-        }
-    } // end charToEntity
-	
-    public static String simplifyString( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( 50 );
-        int charsToAppend = 0;
-        for ( int i = 0; i < originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = char2simpleChar( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
-	
-	
-	
-	
-	
-	
 }

Modified: trunk/src/exp/OziExporter.java
===================================================================
--- trunk/src/exp/OziExporter.java	2007-01-28 08:07:16 UTC (rev 466)
+++ trunk/src/exp/OziExporter.java	2007-01-28 09:09:07 UTC (rev 467)
@@ -25,6 +25,7 @@
 
 	public String record(CacheHolder ch, String lat, String lon){
 		StringBuffer strBuf = new StringBuffer(200);
+		String tmpName;
 
 		// Field 1 : Number - this is the location in the array (max 1000), must be unique, 
 		// usually start at 1 and increment. Can be set to -1 (minus 1) and the number will be auto generated.
@@ -48,11 +49,12 @@
 		// Field 10 : Background Color (RGB value)
 		strBuf.append("16777215,");
 		// Field 11 : Description (max 40), no commas
-		if (ch.CacheName.length() <= 40){
-			strBuf.append(ch.CacheName + ",");
+		tmpName = simplifyString(ch.CacheName);
+		if (tmpName.length() <= 40){
+			strBuf.append(tmpName + ",");
 		}
 		else {
-			strBuf.append(ch.CacheName.substring(0,40) + ",");
+			strBuf.append(tmpName.substring(0,40) + ",");
 		}
 		// Field 12 : Pointer Direction
 		strBuf.append("0,");



From salzkammergut at mail.berlios.de  Sun Jan 28 13:23:16 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Jan 2007 13:23:16 +0100
Subject: [Cachewolf-svn] r468 - trunk/src/CacheWolf
Message-ID: <200701281223.l0SCNGL5002126@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-28 13:23:12 +0100 (Sun, 28 Jan 2007)
New Revision: 468

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/NotesScreen.java
Log:
NotesScreen: Buttons verkleinert

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-28 09:09:07 UTC (rev 467)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-28 12:23:12 UTC (rev 468)
@@ -290,7 +290,7 @@
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			
 			if(ev.target == btNotes){
-				NotesScreen nsc = new NotesScreen(thisCache, profile);
+				NotesScreen nsc = new NotesScreen(thisCache);
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
 			if(ev.target == showMap){

Modified: trunk/src/CacheWolf/NotesScreen.java
===================================================================
--- trunk/src/CacheWolf/NotesScreen.java	2007-01-28 09:09:07 UTC (rev 467)
+++ trunk/src/CacheWolf/NotesScreen.java	2007-01-28 12:23:12 UTC (rev 468)
@@ -13,26 +13,19 @@
 */
 public class NotesScreen extends Form{
 	mTextPad wayNotes = new mTextPad();
-	CacheHolder thisCache = new CacheHolder();
-	mButton addDateTime, btSave;
-	Profile profile;
+	CacheHolder thisCache = null;
+	mButton addDateTime = new mButton((IImage)new mImage("date_time.png"));
+	mButton btSave = new mButton(MyLocale.getMsg(127,"Save"));
+	ScrollBarPanel sbp = new ScrollBarPanel(wayNotes);
 	
-	public NotesScreen(CacheHolder ch, Profile profile){
+	public NotesScreen(CacheHolder ch){
 		this.title = "Notes";
-		this.setPreferredSize(Global.getPref().myAppWidth, Global.getPref().myAppHeight);
+		setPreferredSize(Global.getPref().myAppWidth, Global.getPref().myAppHeight);
 		thisCache = ch;
-		this.profile = profile;
-		mImage mI3 = new mImage("date_time.png");
-		addDateTime = new mButton((IImage)mI3);
-		CellPanel cp = new CellPanel();
-		btSave = new mButton("Save");
-		cp.addNext(addDateTime);
-		cp.addLast(btSave);
-		ScrollBarPanel sbp = new ScrollBarPanel(wayNotes);
 		wayNotes.setText(thisCache.CacheNotes);
-		//this.addLast(sbp, this.STRETCH, this.FILL);
-		this.addLast(sbp.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
-		this.addLast(cp);
+		addLast(sbp.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
+		addLast(btSave,CellConstants.HSTRETCH,CellConstants.HFILL);
 	}
 	
 	public void onEvent(Event ev){
@@ -49,7 +42,7 @@
 			}
 			if(ev.target == btSave){
 				thisCache.CacheNotes = wayNotes.getText();
-				thisCache.saveCacheDetails( profile.dataDir);
+				thisCache.saveCacheDetails( Global.getProfile().dataDir);
 				this.close(0);
 			}
 		}



From salzkammergut at mail.berlios.de  Sun Jan 28 16:11:50 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Jan 2007 16:11:50 +0100
Subject: [Cachewolf-svn] r469 - in trunk: resources src/CacheWolf
Message-ID: <200701281511.l0SFBojL011081@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-28 16:11:44 +0100 (Sun, 28 Jan 2007)
New Revision: 469

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DataMover.java
Log:
DataMover: Bugfix und Entfernen der Cache-Suchfunktion (bereits in Profile)
CacheHolder: Neue Funktion: isVisible = !is_black && !is_filtered

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-28 12:23:12 UTC (rev 468)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-28 15:11:44 UTC (rev 469)
@@ -38,9 +38,9 @@
 		142=Verschieben 
 		143=L%f6schen
 		144=Warnung 
-		145=Cachedaten werden gel%f6scht!  Weiter? 
-		146=Cachedaten werden kopiert!  Weiter? 
-		147=Cachedaten werden verschoben!  Weiter? 
+		145=Cachedaten ALLER ANGEZEIGTEN Caches werden gel%f6scht!  Weiter? 
+		146=Cachedaten ALLER ANGEZEIGTEN Caches werden kopiert!  Weiter? 
+		147=Cachedaten ALLER ANGEZEIGTEN Caches werden verschoben!  Weiter? 
 		148=Zielverzeichnis waehlen 
 		149=Karten
 		150=Importieren
@@ -339,9 +339,9 @@
 		142=Move 
 		143=Delete 
 		144=Warning 
-		145=Cachedata will be deleted! Continue? 
-		146=Cachedata will be copied! Continue? 
-		147=Cachedata will be moved! Continue? 
+		145=Cachedata of ALL SHOWN caches will be deleted! Continue? 
+		146=Cachedata of ALL SHOWN caches will be copied! Continue? 
+		147=Cachedata of ALL SHOWN caches will be moved! Continue? 
 		148=Select Target directory 
 		149=Maps
 		150=Import

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-01-28 12:23:12 UTC (rev 468)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-01-28 15:11:44 UTC (rev 469)
@@ -438,6 +438,9 @@
 	   else return false;
    }
    
-
+   /** A cache is visible if it is not blacklisted and not filtered */
+   public boolean isVisible() {
+	   return !is_black && !is_filtered;
+   }
   
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2007-01-28 12:23:12 UTC (rev 468)
+++ trunk/src/CacheWolf/DataMover.java	2007-01-28 15:11:44 UTC (rev 469)
@@ -20,12 +20,11 @@
 	public DataMover(Preferences p, Profile prof){
 		profile=prof;
 		srcDB = profile.cacheDB;
-		dstDB = new Vector();
 		pref = p;
 	}
 	public void deleteCaches(){
 		
-		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(145,"Cachedata will be deleted! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(145,"Cachedata of ALL VISIBLE caches will be deleted! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
 		if (mBox.execute() != MessageBox.IDOK){
 			return;
 		}
@@ -33,7 +32,7 @@
 		// Loop through database
 		for(int i = 0; i<srcDB.size(); i++){
 			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.is_black == false && srcHolder.is_filtered == false){
+			if(srcHolder.isVisible()){
 				deleteCacheFiles(srcHolder.wayPoint, profile.dataDir);
 				srcDB.removeElementAt(i);
 				i--;
@@ -49,12 +48,13 @@
 		
 		// Select destination directory
 		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.baseDir);
-		fc.setTitle(MyLocale.getMsg(148,"Select Targetdirectory"));
+		fc.setTitle(MyLocale.getMsg(148,"Select Target directory"));
 		if(fc.execute() != FormBase.IDCANCEL){
 			dstProfile.dataDir = fc.getChosen() + "/";
 		}
 		else return;
-		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(146,"Cachedata will be copied! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
+		if (dstProfile.dataDir.equals(profile.dataDir)) return;
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(146,"Cachedata of ALL VISIBLE caches will be copied! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
 		if (mBox.execute() != MessageBox.IDOK){
 			return;
 		}
@@ -64,12 +64,13 @@
 		if(ftest.exists()){
 			dstProfile.readIndex();
 		}
+		dstDB=dstProfile.cacheDB;
 		// Loop through database
 		for(int i = 0; i<srcDB.size(); i++){
 			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.is_black == false && srcHolder.is_filtered == false){
+			if(srcHolder.isVisible()){
 				// does cache exists in destDB ?
-				dstPos = searchWpt(dstDB, srcHolder.wayPoint);
+				dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
 				if (dstPos >= 0){
 					deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
 					copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
@@ -94,12 +95,13 @@
 		
 		// Select destination directory
 		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.baseDir);
-		fc.setTitle(MyLocale.getMsg(148,"Select Targetdirectory"));
+		fc.setTitle(MyLocale.getMsg(148,"Select Target directory"));
 		if(fc.execute() != FormBase.IDCANCEL){
 			dstProfile.dataDir = fc.getChosen() + "/";
 		}
 		else return;
-		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(147,"Cachedata will be moved! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
+		if (dstProfile.dataDir.equals(profile.dataDir)) return;
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(147,"Cachedata of ALL VISIBLE caches will be moved! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
 		if (mBox.execute() != MessageBox.IDOK){
 			return;
 		}
@@ -108,12 +110,13 @@
 		File ftest = new File(dstProfile.dataDir + "index.xml");
 		if(ftest.exists()){
 			dstProfile.readIndex();		}
+		dstDB = dstProfile.cacheDB;
 		// Loop through database
 		for(int i = 0; i<srcDB.size(); i++){
 			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.is_black == false && srcHolder.is_filtered == false){
+			if(srcHolder.isVisible()){
 				// does cache exists in destDB ?
-				dstPos = searchWpt(dstDB, srcHolder.wayPoint);
+				dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
 				if (dstPos >= 0){
 					deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
 					moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
@@ -136,24 +139,6 @@
 		dstProfile.saveIndex(pref);
 		profile.saveIndex(pref);
 	}
-	/**
-	* Method to iterate through cache database and look for waypoint.
-	* Returns true if waypoint is found, else false
-	*/
-	private int searchWpt(Vector db, String wpt){
-		if(wpt.length()>0){
-			wpt = wpt.toUpperCase();
-			CacheHolder ch = new CacheHolder();
-			//Search through complete database
-			for(int i = 0;i < db.size();i++){
-				ch = (CacheHolder)db.get(i);
-				if(ch.wayPoint.indexOf(wpt) >=0 ){
-					return i;
-				}
-			} // for
-		} // if
-		return -1;
-	}
 
 	public void deleteCacheFiles(String wpt, String dir){
 		// delete files in dstDir to clean up trash



From salzkammergut at mail.berlios.de  Sun Jan 28 16:47:51 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Jan 2007 16:47:51 +0100
Subject: [Cachewolf-svn] r470 - trunk/src/CacheWolf
Message-ID: <200701281547.l0SFlpfj013007@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-28 16:47:45 +0100 (Sun, 28 Jan 2007)
New Revision: 470

Modified:
   trunk/src/CacheWolf/NotesScreen.java
Log:
NotesScreen: Alternativloesung mit Buttons oben

Modified: trunk/src/CacheWolf/NotesScreen.java
===================================================================
--- trunk/src/CacheWolf/NotesScreen.java	2007-01-28 15:11:44 UTC (rev 469)
+++ trunk/src/CacheWolf/NotesScreen.java	2007-01-28 15:47:45 UTC (rev 470)
@@ -24,8 +24,9 @@
 		thisCache = ch;
 		wayNotes.setText(thisCache.CacheNotes);
 		addLast(sbp.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
-		addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
-		addLast(btSave,CellConstants.HSTRETCH,CellConstants.HFILL);
+		titleControls=new CellPanel();
+		titleControls.addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
+		titleControls.addLast(btSave,CellConstants.HSTRETCH,CellConstants.HFILL);
 	}
 	
 	public void onEvent(Event ev){



From salzkammergut at mail.berlios.de  Sun Jan 28 20:12:35 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Jan 2007 20:12:35 +0100
Subject: [Cachewolf-svn] r471 - trunk/src/CacheWolf
Message-ID: <200701281912.l0SJCZ85006334@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-28 20:12:33 +0100 (Sun, 28 Jan 2007)
New Revision: 471

Modified:
   trunk/src/CacheWolf/Profile.java
Log:


Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-28 15:47:45 UTC (rev 470)
+++ trunk/src/CacheWolf/Profile.java	2007-01-28 19:12:33 UTC (rev 471)
@@ -291,7 +291,7 @@
 			// The following call is not very clean as it mixes UI with base classes
 			// However, calling it from here allows us to recenter the
 			// radar panel with only one call
-			Global.mainTab.radarP.recenterRadar();
+			if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
 		} //updateBearingDistance
 
 		/**



From salzkammergut at mail.berlios.de  Sun Jan 28 22:42:33 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Jan 2007 22:42:33 +0100
Subject: [Cachewolf-svn] r472 - trunk/src/CacheWolf
Message-ID: <200701282142.l0SLgXt6015460@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-28 22:42:30 +0100 (Sun, 28 Jan 2007)
New Revision: 472

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Profile: Bugfix beim Schreiben von filterVar

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-28 19:12:33 UTC (rev 471)
+++ trunk/src/CacheWolf/Profile.java	2007-01-28 21:42:30 UTC (rev 472)
@@ -93,7 +93,7 @@
 				distOC = "0";
 			}
 			
-			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+"\" var = \""+filterVar+"\"/>\n");
+			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+"\" var = \""+filterVar+"\" />\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);



From bilbowolf at mail.berlios.de  Mon Jan 29 22:06:33 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Mon, 29 Jan 2007 22:06:33 +0100
Subject: [Cachewolf-svn] r473 - trunk/src/CacheWolf
Message-ID: <200701292106.l0TL6Xbs008302@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-29 22:06:30 +0100 (Mon, 29 Jan 2007)
New Revision: 473

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-28 21:42:30 UTC (rev 472)
+++ trunk/src/CacheWolf/Filter.java	2007-01-29 21:06:30 UTC (rev 473)
@@ -303,12 +303,21 @@
 				if(terrdirec == GREATER && dummyd2 >= dummyd1) inTerr = 1;
 			}
 			
-			if(foundByMe == true){
-				inFound = 0;
-				matchFound = 1;
-				if(ch.is_found) inFound = 1; 
+			matchFound = 1;
+			inFound = 1;
+			if(foundByMe == false){
+				matchFound = 0;
+				if(ch.is_found == false) inFound = 0;
 			}
 			
+			/*
+			Vm.debug("Is found: " + ch.is_found);
+			Vm.debug("Params: " +matchFound + " / " +inFound);
+			Vm.debug(" Matcher: " +(~(matchFound ^ inFound)));
+			
+			Vm.debug(" Boolean: " +(foundByMe && ch.is_found));
+			*/
+			
 			if(ownedByMe){
 				matchOwned = 1;
 				inOwned = 0;
@@ -326,16 +335,19 @@
 				if(ch.is_available) inAvailable = 1;
 			}
 
+			
+			
 			if((cacheTypePattern & typeMatchPattern) >= 1 &&
 					(cacheRosePattern & roseMatchPattern) >= 1 && 
-					(~(matchDist ^ inDist)) == -1 &&
-					(~(matchDiff ^ inDiff)) == -1 &&
-					(~(matchTerr ^ inTerr)) == -1 &&
-					(~(matchFound ^ inFound)) == -1 &&
-					(~(matchOwned ^ inOwned)) == -1 &&
-					(~(matchArchived ^ inArchived)) == -1 &&
-					(~(matchAvaliable ^ inAvailable)) == -1)
+					//(~(matchDist ^ inDist)) == -2 &&
+					//(~(matchDiff ^ inDiff)) == -2 &&
+					//(~(matchTerr ^ inTerr)) == -2 &&
+					(~(matchFound ^ inFound)) == -1 )
+					//(~(matchOwned ^ inOwned)) == -2 &&
+					//(~(matchArchived ^ inArchived)) == -2 &&
+					//(~(matchAvaliable ^ inAvailable)) == -2)
 					ch.is_filtered = false;
+			if(ch.is_black) ch.is_filtered = true;
 			cacheDB.set(i,ch);
 		} // for
 	}

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-01-28 21:42:30 UTC (rev 472)
+++ trunk/src/CacheWolf/Version.java	2007-01-29 21:06:30 UTC (rev 473)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " BE ";
-	static final String VER_SVN ="$LastChangedRevision$"; // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From pfeffer at mail.berlios.de  Tue Jan 30 03:43:09 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 30 Jan 2007 03:43:09 +0100
Subject: [Cachewolf-svn] r474 - in trunk: resources src/CacheWolf
Message-ID: <200701300243.l0U2h9nD009986@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-30 03:43:05 +0100 (Tue, 30 Jan 2007)
New Revision: 474

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Handling verbessert, wenn keine Karte zur Verf?\195?\188gung steht ( Aufforderung zur Wahl des Massstabes)

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-29 21:06:30 UTC (rev 473)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-30 02:43:05 UTC (rev 474)
@@ -64,7 +64,7 @@
 		205=Radar
 		206=Liste
 		300=Type:
-		301=Gr%f6sse:
+		301=Gr%f6%dfe:
 		302=Wegpunkt:
 		303=Name:
 		304=Koordinaten:
@@ -89,7 +89,7 @@
 		323=Fehler beim Schreiben der Datei
 		324= - neu versuchen?
 		325=Zuwenige Referenzpunkte, Karte nicht kalibriert
-		326=Es steht keine kalibrierte Karte zur Verf%fcgung
+		326=Es steht keine kalibrierte Karte zur Verf%fcgung \n Bitte w%e4hlen Sie einen Ma%dfstab,\n in dem der Track und die markierten Caches angezeigt werden sollen
 		327=Information
 		340=Cachebilder:
 		341=Eigene Bilder:
@@ -386,7 +386,7 @@
 		323=Fehler beim Schreiben der Datei
 		324= - retry?
 		325=Not enough reference points, map not calibrated
-		326=No calibrated map available
+		326=No calibrated map available. \n Please select a scale to display the track and caches.
 		327=Information
 		340=Cache Images:
 		341=User Images:

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-29 21:06:30 UTC (rev 473)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-30 02:43:05 UTC (rev 474)
@@ -273,7 +273,7 @@
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == exportGPS){
-				Vm.showWait(true);
+	/*			Vm.showWait(true);
 				LocExporter loc = new LocExporter();
 				String tmpFileName = File.getProgramDirectory() + "/temp.loc";
 				loc.setTmpFileName(tmpFileName);
@@ -285,7 +285,7 @@
 					p.waitFor();
 				}catch(IOException ioex){};
 				ProgressBarForm.clear();
-				Vm.showWait(false);
+		*/		Vm.showWait(false);
 			}
 			if(mev.selectedItem == exportCacheMate){
 				Vm.showWait(true);

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-29 21:06:30 UTC (rev 473)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-30 02:43:05 UTC (rev 474)
@@ -115,7 +115,6 @@
 	public void resizeTo(int w,int h) {
 		super.resizeTo(w, h);
 		updateFormSize(w, h);
-		Vm.debug("resizeTo");
 	}
 
 	public void updateFormSize(int w, int h) {
@@ -135,7 +134,8 @@
 
 	/**
 	 * loads the list of maps
-	 *
+	 * @param mapsPath must not have a trailing end "/"
+	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
 	 */
 	public void loadMaps(String mapsPath, double lat){
 		this.mapPath = mapsPath;
@@ -143,14 +143,15 @@
 		resetCenterOfMap();
 		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
 		inf.exec();
-		maps = new MapsList(mapsPath);
+		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
-			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung"), MessageBox.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung \n Bitte w?hlen Sie einen Ma?stab,\n in dem der Track und die markierten Caches angezeigt werden sollen"), MessageBox.OKB)).execute();
 			noMapsAvailable = true;
 		} else noMapsAvailable = false;
 		maps.addEmptyMaps(lat);
 		inf.close(0);
 		Vm.showWait(this, false);
+		if (noMapsAvailable) mmp.chooseMap(); // let the user select an scale
 		this.mapsloaded = true;
 	}
 
@@ -169,9 +170,9 @@
 			dd.decimalPlaces = 2;
 			d = "Distance: " + dd.toString() + "km";
 		}
-		DistanceImageGraphics.setColor(Color.MediumBlue);
+		DistanceImageGraphics.setColor(Color.DarkBlue);
 		DistanceImageGraphics.drawText(d, 0, 0);
-		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.DarkBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
 		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
 	}
 
@@ -486,6 +487,11 @@
 
 	}
 
+	/** call this if the map moved on the screen (by dragging)
+	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * @param diffX
+	 * @param diffY
+	 */
 	public void mapMoved(int diffX, int diffY) {
 		int w = posCircle.getWidth();
 		int h = posCircle.getHeight();
@@ -711,6 +717,7 @@
 		switch (mapChangeModus) {
 		case NORMAL_KEEP_RESOLUTION: 
 			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, scaleWanted, false);
+			if (newmap == null) newmap = currentMap;
 			if (java.lang.Math.abs(newmap.scale - scaleWanted) < maps.scaleTolerance) wantMapTest = false;
 			break;
 		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
@@ -721,7 +728,7 @@
 		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
 		}
 		if ( newmap != null && (currentMap == null || currentMap.mapName != newmap.mapName) ) {
-			setMap(newmap, lat, lon);
+			setMap(newmap, lat, lon); // TODO handling, wenn newmap == null
 			Vm.debug("better map found");
 			return;
 		}
@@ -769,10 +776,10 @@
 	 */
 	public void loadMoreDetailedMap(boolean betterOverview){
 		Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
-	//	CWPoint cll = (CWPoint) s[0]; 
+		CWPoint cll = (CWPoint) s[0]; 
 		Rect screen = (Rect) s[1]; 
 		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
-		MapInfoObject m = maps.getMapChangeResolution(posCircleLat, posCircleLon, screen, currentMap.scale, !betterOverview);
+		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale, !betterOverview);
 		if (m != null) setMap(m, posCircleLat, posCircleLon);
 		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
 	}
@@ -1209,7 +1216,7 @@
 		super.doPaint(g, area);
 		if (mm.gotoPos != null) {
 			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
-			g.setPen(new Pen(Color.MediumBlue, Pen.SOLID, 3));
+			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
 		}
 	}



From pfeffer at mail.berlios.de  Tue Jan 30 04:03:54 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 30 Jan 2007 04:03:54 +0100
Subject: [Cachewolf-svn] r475 - trunk/src/CacheWolf
Message-ID: <200701300303.l0U33s6d010923@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-30 04:03:52 +0100 (Tue, 30 Jan 2007)
New Revision: 475

Modified:
   trunk/src/CacheWolf/MainMenu.java
Log:
versehentlich grade eben lokalen Work-Around eingecheckt, hioermit r?\195?\188ckgan?\195?\164ngi gemacht.

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-30 02:43:05 UTC (rev 474)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-30 03:03:52 UTC (rev 475)
@@ -273,7 +273,7 @@
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == exportGPS){
-	/*			Vm.showWait(true);
+				Vm.showWait(true);
 				LocExporter loc = new LocExporter();
 				String tmpFileName = File.getProgramDirectory() + "/temp.loc";
 				loc.setTmpFileName(tmpFileName);
@@ -285,7 +285,7 @@
 					p.waitFor();
 				}catch(IOException ioex){};
 				ProgressBarForm.clear();
-		*/		Vm.showWait(false);
+				Vm.showWait(false);
 			}
 			if(mev.selectedItem == exportCacheMate){
 				Vm.showWait(true);



From salzkammergut at mail.berlios.de  Wed Jan 31 08:28:20 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 31 Jan 2007 08:28:20 +0100
Subject: [Cachewolf-svn] r476 - trunk/src/CacheWolf
Message-ID: <200701310728.l0V7SKVH006498@sheep.berlios.de>

Author: salzkammergut
Date: 2007-01-31 08:28:01 +0100 (Wed, 31 Jan 2007)
New Revision: 476

Modified:
   trunk/src/CacheWolf/Common.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Profile.java
Log:
Filter: Ueberarbeitet und mit farblicher Kennung der aktivern Filter
Inkl. Speicherung im Profile
TODO: Internationalisierung

Modified: trunk/src/CacheWolf/Common.java
===================================================================
--- trunk/src/CacheWolf/Common.java	2007-01-30 03:03:52 UTC (rev 475)
+++ trunk/src/CacheWolf/Common.java	2007-01-31 07:28:01 UTC (rev 476)
@@ -5,8 +5,14 @@
 
 public final class Common {
 
+	private static char digSep=MyLocale.getDigSeparator().charAt(0);
+	private static char notDigSep=MyLocale.getDigSeparator().charAt(0)=='.'?',':'.';
+	
 	public static double parseDouble(String value){
-		String a = new String();
+
+/*		The following code is EXTREMELY inefficient.
+        ============================================
+ 		String a = new String();
 		String b = new String();
 		char separator = '.';
 		double aDbl, bDbl;
@@ -25,9 +31,16 @@
 		b = value.substring(value.indexOf(separator)+1);
 		bDbl = Convert.toDouble(b);
 		// Calc Minutes
-		bDbl = bDbl / java.lang.Math.pow((double)10,(double)b.length());
+		bDbl = bDbl / java.lang.Math.pow((double)10,(double)b.length()); // Using pow is BAD NEWS!!!
 		
 		return aDbl>=0?aDbl + bDbl:aDbl - bDbl;
+*/      
+		// This is at least a factor of 3 faster (returns 0 for invalid arguments)
+		try {
+			return java.lang.Double.parseDouble(value.replace(notDigSep,digSep));
+		} catch (Exception e) {
+			return 0.0;
+		}
 	}
 	public static String rot13 (String text) {
 		String dummy = new String();

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-01-30 03:03:52 UTC (rev 475)
+++ trunk/src/CacheWolf/Filter.java	2007-01-31 07:28:01 UTC (rev 476)
@@ -8,10 +8,12 @@
 /**
 *	Class that actually filters the cache database.<br>
 *	The class that uses this filter must set the different public variables.
+*   @author BilboWolf (optimiert von salzkammergut)
 */
 public class Filter{
 	
 	public static final int SMALLER = -1;
+	public static final int EQUAL = -1;
 	public static final int GREATER = 1;
 	public static final int FOUND = 2;
 	public static final int NOTFOUND = 3;
@@ -69,13 +71,21 @@
 	public int typeMatchPattern = 0;
 	
 	public boolean foundByMe;
+	public boolean notFoundByMe;
+	
 	public boolean ownedByMe;
+	public boolean notOwnedByMe;
+	
 	//private boolean is_changed;
 	public int filterKriteria = 0;
 	
-	boolean archived = false;
-	boolean notAvailable = false;
+	public boolean archived = false;
+	public boolean notArchived = false;
 	
+	public boolean available=false;
+	public boolean notAvailable = false;
+	double pi180=java.lang.Math.PI / 180.0;
+	
 	/**
 	*	Apply a route filter. Each waypoint is on a seperate line.
 	*	We use a regex method to allow for different formats of waypoints:
@@ -90,7 +100,7 @@
 		double lat,lon, calcDistance = 0;
 		try{
 			FileReader in = new FileReader(routeFile);
-			String line = new String();
+			String line; 
 			while((line = in.readLine()) != null){
 				rex.search(line);
 				/*
@@ -111,8 +121,8 @@
 					lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
 					lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
 				
-					if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = lat * -1;
-					if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = lon * -1;	
+					if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = -lat;
+					if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = -lon;	
 				
 					cwp = new CWPoint(lat, lon);
 					
@@ -120,10 +130,10 @@
 				}
 			}
 			//initialize database
-			for(int i = 0;i<cacheDB.size(); i++){
+			for(int i = cacheDB.size()-1; i >=0 ; i--){
 				ch = (CacheHolder)cacheDB.get(i);
 				ch.is_filtered = true;
-				cacheDB.set(i, ch);
+				//cacheDB.set(i, ch);
 			}
 			// for each segment of the route...
 			for(int z=0;z<wayPoints.size()-1;z++){
@@ -132,7 +142,7 @@
 				fromPoint = (CWPoint)wayPoints.get(z);
 				toPoint = (CWPoint)wayPoints.get(z+1);
 				//... go through the current cache database
-				for(int i = 0;i<cacheDB.size(); i++){
+				for(int i = cacheDB.size()-1; i >=0 ; i--){
 					ch = (CacheHolder)cacheDB.get(i);
 					cwp = new CWPoint(ch.LatLon, CWPoint.CW);
 					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
@@ -143,7 +153,7 @@
 						Vm.debug("Distcalc: " + calcDistance + "Cache: " +ch.CacheName + " / z is = " + z);
 						ch.is_filtered = false;
 					}
-					cacheDB.set(i, ch);
+					//cacheDB.set(i, ch);
 				} // for database
 			} // for segments
 			
@@ -175,12 +185,12 @@
 		return java.lang.Math.abs(XTD);
 		*/
 		double dist = 0;
-		double px = cwp.lonDec * java.lang.Math.PI / 180;
-		double py = cwp.latDec * java.lang.Math.PI / 180;
-		double X1 = fromPoint.lonDec * java.lang.Math.PI / 180;
-		double Y1 = fromPoint.latDec * java.lang.Math.PI / 180;
-		double X2 = toPoint.lonDec * java.lang.Math.PI / 180;
-		double Y2 = toPoint.latDec * java.lang.Math.PI / 180;
+		double px = cwp.lonDec * pi180;
+		double py = cwp.latDec * pi180;
+		double X1 = fromPoint.lonDec * pi180;
+		double Y1 = fromPoint.latDec * pi180;
+		double X2 = toPoint.lonDec * pi180;
+		double Y2 = toPoint.latDec * pi180;
 		double dx = X2 - X1;
 		double dy = Y2 - Y1;
 		if(dx == 0 && dy == 0){
@@ -206,15 +216,9 @@
 	 */
 	public void showBlacklist(Vector cacheDB){
 		CacheHolder ch;
-		for(int i = 0; i < cacheDB.size(); i++){
+		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered = true;
-			//Vm.debug(ch.CacheName + ": " +ch.is_black);
-			if(ch.is_black == true) {
-				ch.is_filtered = false;
-				//Vm.debug("==>not filtered!");
-			}
-			cacheDB.set(i,ch);
+			ch.is_filtered=!ch.is_black;
 		}
 	}
 	
@@ -224,131 +228,122 @@
 	*	not displaying a cache that is filtered.
 	*/
 	public void doFilter(Vector cacheDB, String dir){
-		CacheHolder ch = new CacheHolder();
-		int cacheTypePattern = 0;
-		int cacheRosePattern = 0;
-		int inDist = 0, matchDist = 0;
-		int inDiff = 0, matchDiff = 0;
-		int inTerr = 0, matchTerr = 0;
-		int inFound = 0, matchFound = 0;
-		int matchOwned = 0, inOwned = 0;
-		int matchArchived = 0, inArchived = 0;
-		int matchAvaliable = 0, inAvailable = 0;
-		
-		double dummyd1, dummyd2;
-		String dummy = new String();
+		CacheHolder ch;
+		int cacheTypePattern;
+		int cacheRosePattern;
+		// Values from filterscreen are parsed outside the main filter loop (fsc=FilterSCreen)
+		double fscDist=Common.parseDouble(dist);  // Distance
+		double fscTerr=Common.parseDouble(terr);  // Terrain
+		double fscDiff=Common.parseDouble(diff);  // Difficulty
+		double dummyd1;
 		//Loop db and match once against type pattern and once against rose pattern
-		//Default is_filtered = true, means will not be displayed!
-		//If cache matches type and rose pattern then is_filtered is set to false
-		//Still in the loop check aginst diff, terr, dist, found by, found last
-		for(int i = 0; i < cacheDB.size(); i++){
+		//Default is_filtered = false, means will be displayed!
+		//If cache does not match type or rose pattern then is_filtered is set to true
+		// and we proceed to next cache (no further tests needed)
+		//Then we check the other filter criteria one by one: As soon as one is found that
+		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
+		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
+		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered = true;
+			ch.is_filtered = false;
+			///////////////////////////////
+			// Filter criterium 1: Cache type
+			///////////////////////////////
 			cacheTypePattern = 0;
-			if(ch.type.equals("2")) cacheTypePattern |= TRADITIONAL;
-			if(ch.type.equals("3")) cacheTypePattern |= MULTI;
-			if(ch.type.equals("4")) cacheTypePattern |= VIRTUAL;
-			if(ch.type.equals("5")) cacheTypePattern |= LETTER;
-			if(ch.type.equals("6")|| ch.type.equals("453")) cacheTypePattern |= EVENT;
-			if(ch.type.equals("8")) cacheTypePattern |= MYSTERY;
-			if(ch.type.equals("11")) cacheTypePattern |= WEBCAM;
-			if(ch.type.equals("12")) cacheTypePattern |= LOCLESS;
+			// As each cache can only have one type, we can use else if and set the type
+			if(ch.type.equals("2")) cacheTypePattern = TRADITIONAL;
+			else if(ch.type.equals("3")) cacheTypePattern = MULTI;
+			else if(ch.type.equals("4")) cacheTypePattern = VIRTUAL;
+			else if(ch.type.equals("5")) cacheTypePattern = LETTER;
+			else if(ch.type.equals("6")|| ch.type.equals("453")) cacheTypePattern = EVENT;
+			else if(ch.type.equals("8")) cacheTypePattern = MYSTERY;
+			else if(ch.type.equals("11")) cacheTypePattern = WEBCAM;
+			else if(ch.type.equals("12")) cacheTypePattern = LOCLESS;
+			else if(ch.type.equals("137"))cacheTypePattern = EARTH;
+			else if(ch.type.equals("453"))cacheTypePattern = MEGA;
 			if (CacheType.isAddiWpt(ch.type)) cacheTypePattern |= ADDIWPT;
-			if(ch.type.equals("137"))cacheTypePattern |= EARTH;
-			if(ch.type.equals("453"))cacheTypePattern |= MEGA;
+			if ((cacheTypePattern & typeMatchPattern) == 0) { ch.is_filtered=true; continue; }
 			
-			cacheRosePattern = 0;
-			if(ch.bearing.equals("NW")) cacheRosePattern |= NW;
-			if(ch.bearing.equals("NNW")) cacheRosePattern |= NNW;
-			if(ch.bearing.equals("N")) cacheRosePattern |= N;
-			if(ch.bearing.equals("NNE")) cacheRosePattern |= NNE;
-			if(ch.bearing.equals("NE")) cacheRosePattern |= NE;
-			if(ch.bearing.equals("WNW")) cacheRosePattern |= WNW;
-			if(ch.bearing.equals("ENE")) cacheRosePattern |= ENE;
-			if(ch.bearing.equals("W")) cacheRosePattern |= W;
-			if(ch.bearing.equals("E")) cacheRosePattern |= E;
-			if(ch.bearing.equals("WSW")) cacheRosePattern |= WSW;
-			if(ch.bearing.equals("ESE")) cacheRosePattern |= ESE;
-			if(ch.bearing.equals("SW")) cacheRosePattern |= SW;
-			if(ch.bearing.equals("SSW")) cacheRosePattern |= SSW;
-			if(ch.bearing.equals("S")) cacheRosePattern |= S;
-			if(ch.bearing.equals("SSE")) cacheRosePattern |= SSE;
-			if(ch.bearing.equals("SE")) cacheRosePattern |= SE;
-
-			if(dist.length()>0){
-				matchDist = 1;
-				inDist = 0;
-				dummy = ch.distance.substring(0,ch.distance.length()-3);
-				dummyd1 = Common.parseDouble(dummy); 
-				dummyd2 = Common.parseDouble(dist); 
-				if(distdirec == SMALLER && dummyd2 <= dummyd1) inDist = 1;
-				if(distdirec == GREATER && dummyd2 >= dummyd1) inDist = 1;
+			///////////////////////////////
+			// Filter criterium 2: Bearing from centre
+			///////////////////////////////
+			// The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
+			// By using else if we can reduce the number of comparisons from 16 to just over 8
+			// By first checking the first letter, we can reduce the average number further to
+			// just under 5
+			if (ch.bearing.startsWith("N")) {
+				if(ch.bearing.equals("NW")) cacheRosePattern = NW;
+				else if(ch.bearing.equals("NNW")) cacheRosePattern = NNW;
+				else if(ch.bearing.equals("N")) cacheRosePattern = N;
+				else if(ch.bearing.equals("NNE")) cacheRosePattern = NNE;
+				else cacheRosePattern = NE;
+			} else if (ch.bearing.startsWith("E")) {
+				if(ch.bearing.equals("ENE")) cacheRosePattern = ENE;
+				else if(ch.bearing.equals("E")) cacheRosePattern = E;
+				else cacheRosePattern = ESE;
+			} else if (ch.bearing.startsWith("S")) {
+				if(ch.bearing.equals("SW")) cacheRosePattern = SW;
+				else if(ch.bearing.equals("SSW")) cacheRosePattern = SSW;
+				else if(ch.bearing.equals("S")) cacheRosePattern = S;
+				else if(ch.bearing.equals("SSE")) cacheRosePattern = SSE;
+				else cacheRosePattern = SE;
+			} else {
+				if(ch.bearing.equals("WNW")) cacheRosePattern = WNW;
+				else if(ch.bearing.equals("W")) cacheRosePattern = W;
+				else cacheRosePattern = WSW;
 			}
+			if ((cacheRosePattern & roseMatchPattern) == 0) { ch.is_filtered=true; continue; }
 			
-			if(diff.length()>0){
-				matchDiff = 1;
-				inDiff = 0;
+			///////////////////////////////
+			// Filter criterium 3: Distance
+			///////////////////////////////
+			if(fscDist>0.0){
+				dummyd1 = Common.parseDouble(ch.distance.substring(0,ch.distance.length()-3)); 
+				if(distdirec == SMALLER && dummyd1 > fscDist)  { ch.is_filtered=true; continue; }
+				if(distdirec == GREATER && dummyd1 < fscDist)  { ch.is_filtered=true; continue; }
+			}
+			///////////////////////////////
+			// Filter criterium 4: Difficulty
+			///////////////////////////////
+			if(fscDiff>0.0){
 				dummyd1 = Common.parseDouble(ch.hard);
-				dummyd2 = Common.parseDouble(diff);
-				if(diffdirec == SMALLER && dummyd2 <= dummyd1) inDiff = 1;
-				if(diffdirec == GREATER && dummyd2 >= dummyd1) inDiff = 1;
+				if(diffdirec == SMALLER && dummyd1 > fscDiff) { ch.is_filtered=true; continue; }
+				if(diffdirec == EQUAL && dummyd1 != fscDiff) { ch.is_filtered=true; continue; }
+				if(diffdirec == GREATER && dummyd1 < fscDiff) { ch.is_filtered=true; continue; }
 			}
-			
-			if(terr.length()>0){
-				matchTerr = 1;
-				inTerr = 0;
+			///////////////////////////////
+			// Filter criterium 5: Terrain
+			///////////////////////////////
+			if(fscTerr>0.0){
 				dummyd1 = Common.parseDouble(ch.terrain);
-				dummyd2 = Common.parseDouble(terr);
-				if(terrdirec == SMALLER && dummyd2 <= dummyd1) inTerr = 1;
-				if(terrdirec == GREATER && dummyd2 >= dummyd1) inTerr = 1;
+				if(terrdirec == SMALLER &&  dummyd1 > fscTerr) { ch.is_filtered=true; continue; }
+				if(terrdirec == EQUAL && dummyd1 != fscTerr) { ch.is_filtered=true; continue; }
+				if(terrdirec == GREATER &&  dummyd1 < fscTerr) { ch.is_filtered=true; continue; }
 			}
+			///////////////////////////////
+			// Filter criterium 6: Found by me
+			///////////////////////////////
+			if((ch.is_found && !foundByMe) ||
+			   (!ch.is_found && !notFoundByMe)){ ch.is_filtered=true; continue; }
+
+			///////////////////////////////
+			// Filter criterium 7: Owned by me
+			///////////////////////////////
+			if((ch.is_owned && !ownedByMe) ||
+			   (!ch.is_owned && !notOwnedByMe)) { ch.is_filtered=true; continue; }
 			
-			matchFound = 1;
-			inFound = 1;
-			if(foundByMe == false){
-				matchFound = 0;
-				if(ch.is_found == false) inFound = 0;
-			}
-			
-			/*
-			Vm.debug("Is found: " + ch.is_found);
-			Vm.debug("Params: " +matchFound + " / " +inFound);
-			Vm.debug(" Matcher: " +(~(matchFound ^ inFound)));
-			
-			Vm.debug(" Boolean: " +(foundByMe && ch.is_found));
-			*/
-			
-			if(ownedByMe){
-				matchOwned = 1;
-				inOwned = 0;
-				if(ch.is_owned) inOwned = 1;
-			}
-			
-			if(archived){
-				matchArchived = 1;
-				inArchived = 0;
-				if(ch.is_archived) inArchived = 1;
-			}
-			if(notAvailable){
-				matchAvaliable = 1;
-				inAvailable = 0;
-				if(ch.is_available) inAvailable = 1;
-			}
+			///////////////////////////////
+			// Filter criterium 8: Archived
+			///////////////////////////////
+			if((ch.is_archived && !archived) ||
+			   (!ch.is_archived && !notArchived)){ ch.is_filtered=true; continue; }
 
+			///////////////////////////////
+			// Filter criterium 9: Unavailable
+			///////////////////////////////
+			if((ch.is_available && !available) ||
+			   (!ch.is_available && !notAvailable)) { ch.is_filtered=true; continue; }
 			
-			
-			if((cacheTypePattern & typeMatchPattern) >= 1 &&
-					(cacheRosePattern & roseMatchPattern) >= 1 && 
-					//(~(matchDist ^ inDist)) == -2 &&
-					//(~(matchDiff ^ inDiff)) == -2 &&
-					//(~(matchTerr ^ inTerr)) == -2 &&
-					(~(matchFound ^ inFound)) == -1 )
-					//(~(matchOwned ^ inOwned)) == -2 &&
-					//(~(matchArchived ^ inArchived)) == -2 &&
-					//(~(matchAvaliable ^ inAvailable)) == -2)
-					ch.is_filtered = false;
-			if(ch.is_black) ch.is_filtered = true;
-			cacheDB.set(i,ch);
 		} // for
 	}
 	
@@ -357,11 +352,9 @@
 	*/
 	public void invertFilter(Vector cacheDB){
 		CacheHolder ch;
-		for(int i = 0; i < cacheDB.size(); i++){
+		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.is_filtered == true) ch.is_filtered = false;
-			else ch.is_filtered = true;
-			cacheDB.set(i, ch);
+			ch.is_filtered=!ch.is_filtered; // skg: More efficient
 		}
 	}
 	
@@ -370,12 +363,18 @@
 	*/
 	public void clearFilter(Vector cacheDB){
 		CacheHolder ch;
-		for(int i = 0; i < cacheDB.size(); i++){
+		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered = false;
-			if(ch.is_black) ch.is_filtered = true;
-			cacheDB.set(i, ch);
+			ch.is_filtered=ch.is_black; // Always filter blacklisted caches
 		}
+		Profile prof=Global.getProfile();
+		prof.filterType = new String(Profile.FILTERTYPE);
+		prof.filterRose = new String(Profile.FILTERROSE);
+		prof.filterVar = new String(Profile.FILTERVAR);
+		prof.filterDist="";
+		prof.filterDiff="";
+		prof.filterTerr="";
+		
 	}
 }
 

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-01-30 03:03:52 UTC (rev 475)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-01-31 07:28:01 UTC (rev 476)
@@ -12,144 +12,379 @@
 *	Class ID=700
 */
 public class FilterScreen extends Form{
+	private static final Color COLOR_FILTERINACTIVE=new Color(190,190,190);
+	private static final Color COLOR_FILTERACTIVE=new Color(0,255,0);
+    	
 	mButton btCancel, btApply,btRoute,btArea;
 	
 	mChoice distChc, difChc, terrChc, lastChc;
-	mCheckBox foundChk, tradChk, virtualChk, eventChk, earthChk, megaChk;
-	mCheckBox ownedChk, multiChk, letterChk, webcamChk, mysteryChk,addiWptChk, loclessChk;
-	mInput distIn, difIn, terrIn, lastIn, foundIn;
+	mCheckBox foundChk, notFoundChk, tradChk, virtualChk, eventChk, earthChk, megaChk;
+	mCheckBox ownedChk, notOwnedChk, multiChk, letterChk, webcamChk, mysteryChk,addiWptChk, loclessChk;
+	mInput distIn, lastIn, foundIn, terrIn, difIn;
 	Vector cacheDB;
-	mCheckBox archivedChk, notAvailableChk;
+	mCheckBox archivedChk,notArchivedChk, availableChk,notAvailableChk;
 	mCheckBox NW, NNW , N , NNE, NE;
 	mCheckBox ENE, E, ESE, SE, SSE, S;
-	mCheckBox SSW, SW, WSW, W, WNW;
+	mCheckBox SSW, SW, WSW, W, WNW, chkDeselect,chkSelect;
 	String dir = new String();
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
 	
 	CellPanel content = new CellPanel();
-	ScrollBarPanel scp;
+	CellPanel pnlBearDist=new CellPanel();
+	CellPanel pnlAttributes=new CellPanel();
+	CellPanel pnlRatings=new CellPanel();
+	CellPanel pnlCacheTypes=new CellPanel();
+	CellPanel pnlContainer=new CellPanel();
+	CellPanel pnlSearch=new CellPanel();
+	CellPanel roseP = new CellPanel();
+	CardPanel cp=new CardPanel();
+	CellPanel pnlButtons=new CellPanel();
+	mButton btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnSearch;
+
+	private mButton addImg(String imgName) {
+		mButton mb=new mButton(new mImage(imgName)); mb.borderWidth=0; mb.modify(NotEditable|PreferredSizeOnly,0);
+		return mb;
+	}
+	private void addTitle(CellPanel c, String title) {
+		mLabel lblTitle;
+		c.addLast(lblTitle=new mLabel(title),HSTRETCH,FILL|CENTER);
+		lblTitle.backGround=new Color(127,127,127); 
+		lblTitle.foreGround=Color.White; 
+		lblTitle.setTag(INSETS,new Insets(2,0,4,0));
+		
+	}
 	
-	public FilterScreen(Vector DB, String d){
-		dir = d;
-		cacheDB = DB;
-		//Filter einlesen
+	public FilterScreen() {
+		this.title = MyLocale.getMsg(700,"Set Filter");
+
+		//////////////////////////
+		// Panel 1 - Bearing & Distance
+		//////////////////////////
+		addTitle(pnlBearDist,"Bearings & Distance");
+		pnlBearDist.addNext(new mLabel(MyLocale.getMsg(701,"Distance: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlBearDist.addNext(distChc = new mChoice(new String[]{"<=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlBearDist.addLast(distIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlBearDist.addLast(new mLabel(""));
+		roseP.addNext(NW = new mCheckBox("NW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(NNW = new mCheckBox("NNW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(N = new mCheckBox("N"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addLast(NNE = new mCheckBox("NNE"),CellConstants.HSTRETCH, CellConstants.FILL);
 		
-		//Werte setzen
-		this.title = (String)lr.get(700,"Set Filter");
+		roseP.addNext(NE = new mCheckBox("NE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(ENE = new mCheckBox("ENE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(E = new mCheckBox("E "),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addLast(ESE = new mCheckBox("ESE"),CellConstants.HSTRETCH, CellConstants.FILL);
+
+		roseP.addNext(SE = new mCheckBox("SE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(SSE = new mCheckBox("SSE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(S = new mCheckBox("S"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addLast(SSW = new mCheckBox("SSW"),CellConstants.HSTRETCH, CellConstants.FILL);
+
+		roseP.addNext(SW = new mCheckBox("SW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(WSW = new mCheckBox("WSW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(W = new mCheckBox("W "),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addLast(WNW = new mCheckBox("WNW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		roseP.addNext(chkDeselect=new mCheckBox("Deselect all"));
+		chkDeselect.setTag(SPAN,new Dimension(2,1));
+		roseP.addLast(chkSelect=new mCheckBox("Select all"));
+		pnlBearDist.addLast(roseP, CellConstants.STRETCH,CellConstants.FILL);
 		
-		scp = new ScrollBarPanel(content);
+		//////////////////////////
+		// Panel 2 - Cache attributes
+		//////////////////////////
+		addTitle(pnlAttributes,"Attributes");
+		mLabel lblTitleAtt; 
+		pnlAttributes.addLast(lblTitleAtt=new mLabel("Show all caches with status:"),HSTRETCH,FILL);
+		lblTitleAtt.setTag(SPAN,new Dimension(2,1));
+		pnlAttributes.addNext(archivedChk = new mCheckBox(MyLocale.getMsg(710,"Archived")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(notArchivedChk = new mCheckBox("Nicht archiviert"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		content.addNext(new mLabel((String)lr.get(701,"Distance: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		content.addNext(distChc = new mChoice(new String[]{"<=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addLast(distIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(availableChk = new mCheckBox("Suchbar"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(notAvailableChk = new mCheckBox(MyLocale.getMsg(711,"Not available")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		content.addNext(new mLabel((String)lr.get(702,"Difficulty: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		content.addNext(difChc = new mChoice(new String[]{"<=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addLast(difIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(foundChk = new mCheckBox(MyLocale.getMsg(703,"Found")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(notFoundChk = new mCheckBox("Noch nicht gefunden"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		content.addNext(new mLabel("Terrain: "),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		content.addNext(terrChc = new mChoice(new String[]{"<=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addLast(terrIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(ownedChk = new mCheckBox(MyLocale.getMsg(707,"Owned")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(notOwnedChk = new mCheckBox("Anderer Besitzer"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		//////////////////////////
+		// Panel 3 - Cache ratings
+		//////////////////////////
+		addTitle(pnlRatings,"Cache ratings");
+		pnlRatings.addNext(new mLabel(MyLocale.getMsg(702,"Difficulty: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(difChc = new mChoice(new String[]{"<=","=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//pnlRatings.addLast(difIn = new mChoice(new String[]{"1.0", "1.5", "2.0", "2.5", "3.0", "3.5", "4.0", "4.5", "5.0"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addLast(difIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		content.addNext(lastChc = new mChoice(new String[]{(String)lr.get(703,"Found"), (String)lr.get(704,"Not found")},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addNext(new mLabel((String)lr.get(705," last ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		content.addLast(lastIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(new mLabel("Terrain: "),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(terrChc = new mChoice(new String[]{"<=", "=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//pnlRatings.addLast(terrIn = new mChoice(new String[]{"1.0", "1.5", "2.0", "2.5", "3.0", "3.5", "4.0", "4.5", "5.0"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addLast(terrIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		//////////////////////////
+		// Panel 4 - Cache types
+		//////////////////////////
 		
-		content.addNext(new mLabel((String)lr.get(706,"Found by: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		content.addLast(foundIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		addTitle(pnlCacheTypes,"Cache types");
+		pnlCacheTypes.addNext(addImg("2.png"));
+		pnlCacheTypes.addNext(tradChk = new mCheckBox("Traditonal"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		content.addNext(archivedChk = new mCheckBox((String)lr.get(710,"Archived")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		archivedChk.state = (Global.getProfile().filterVar.charAt(0) == '1' ? true : false);
-		content.addLast(notAvailableChk = new mCheckBox((String)lr.get(711,"Not available")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		notAvailableChk.state = (Global.getProfile().filterVar.charAt(1) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("3.png"));
+		pnlCacheTypes.addLast(multiChk = new mCheckBox("Multi"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		content.addNext(foundChk = new mCheckBox((String)lr.get(703,"Found")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		foundChk.state = (Global.getProfile().filterVar.charAt(2) == '1' ? true : false);
-		content.addLast(ownedChk = new mCheckBox((String)lr.get(707,"Owned")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		ownedChk.state = (Global.getProfile().filterVar.charAt(3) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("4.png"));
+		pnlCacheTypes.addNext(virtualChk = new mCheckBox("Virtual"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		CellPanel ctype = new CellPanel();
+		pnlCacheTypes.addNext(addImg("5.png"));
+		pnlCacheTypes.addLast(letterChk = new mCheckBox("Letterbox"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		ctype.addLast(new mLabel("__________"));
-		ctype.addNext(tradChk = new mCheckBox("Traditonal"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		tradChk.state = (Global.getProfile().filterType.charAt(0) == '1' ? true : false);
-		ctype.addNext(multiChk = new mCheckBox("Multi"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		multiChk.state = (Global.getProfile().filterType.charAt(1) == '1' ? true : false);
-		ctype.addLast(virtualChk = new mCheckBox("Virtual"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		virtualChk.state = (Global.getProfile().filterType.charAt(2) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("6.png"));
+		pnlCacheTypes.addNext(eventChk = new mCheckBox("Event"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		ctype.addNext(letterChk = new mCheckBox("Letterbox"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		letterChk.state = (Global.getProfile().filterType.charAt(3) == '1' ? true : false);
-		ctype.addNext(eventChk = new mCheckBox("Event"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		eventChk.state = (Global.getProfile().filterType.charAt(4) == '1' ? true : false);
-		ctype.addLast(webcamChk = new mCheckBox("Webcam"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		webcamChk.state = (Global.getProfile().filterType.charAt(5) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("11.png"));
+		pnlCacheTypes.addLast(webcamChk = new mCheckBox("Webcam"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		ctype.addNext(mysteryChk = new mCheckBox("Mystery"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		mysteryChk.state = (Global.getProfile().filterType.charAt(6) == '1' ? true : false);
-		ctype.addNext(earthChk = new mCheckBox("Earth"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		earthChk.state = (Global.getProfile().filterType.charAt(7) == '1' ? true : false);
-		ctype.addLast(loclessChk = new mCheckBox("Locationless"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		loclessChk.state = (Global.getProfile().filterType.charAt(8) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("8.png"));
+		pnlCacheTypes.addNext(mysteryChk = new mCheckBox("Mystery"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		ctype.addNext(megaChk = new mCheckBox("Mega-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		megaChk.state = (Global.getProfile().filterType.charAt(9) == '1' ? true : false);
-		ctype.addLast(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		addiWptChk.state = (Global.getProfile().filterType.charAt(10) == '1' ? true : false);
-		ctype.addLast(new mLabel("__________"));
-		content.addLast(ctype, CellConstants.STRETCH,CellConstants.FILL);
+		pnlCacheTypes.addNext(addImg("137.png"));
+		pnlCacheTypes.addLast(earthChk = new mCheckBox("Earth"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		CellPanel roseP = new CellPanel();
-		//Image img = new Image("rose.png");
-		//ImageControl ic = new ImageControl(img);
-		//mLabel ic = new mLabel("");
-		roseP.addNext(NW = new mCheckBox("NW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		NW.state = (Global.getProfile().filterRose.charAt(0) == '1' ? true : false);
-		roseP.addNext(NNW = new mCheckBox("NNW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		NNW.state = (Global.getProfile().filterRose.charAt(1) == '1' ? true : false);
-		roseP.addNext(N = new mCheckBox("N"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		N.state = (Global.getProfile().filterRose.charAt(2) == '1' ? true : false);
-		roseP.addLast(NNE = new mCheckBox("NNE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		NNE.state = (Global.getProfile().filterRose.charAt(3) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("12.png"));
+		pnlCacheTypes.addNext(loclessChk = new mCheckBox("Locationless"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		roseP.addNext(NE = new mCheckBox("NE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		NE.state = (Global.getProfile().filterRose.charAt(4) == '1' ? true : false);
-		roseP.addNext(WNW = new mCheckBox("WNW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		WNW.state = (Global.getProfile().filterRose.charAt(5) == '1' ? true : false);
-		roseP.addNext(ENE = new mCheckBox("ENE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		ENE.state = (Global.getProfile().filterRose.charAt(6) == '1' ? true : false);
-		roseP.addLast(W = new mCheckBox("W "),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		W.state = (Global.getProfile().filterRose.charAt(7) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("453.png"));
+		pnlCacheTypes.addLast(megaChk = new mCheckBox("Mega-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		roseP.addNext(E = new mCheckBox("E "),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		E.state = (Global.getProfile().filterRose.charAt(8) == '1' ? true : false);
-		roseP.addNext(WSW = new mCheckBox("WSW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		WSW.state = (Global.getProfile().filterRose.charAt(9) == '1' ? true : false);
-		roseP.addNext(ESE = new mCheckBox("ESE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		ESE.state = (Global.getProfile().filterRose.charAt(10) == '1' ? true : false);
-		roseP.addLast(SW = new mCheckBox("SW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		SW.state = (Global.getProfile().filterRose.charAt(11) == '1' ? true : false);
+		pnlCacheTypes.addNext(addImg("110.png"));
+		pnlCacheTypes.addLast(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(new mLabel(""));
+
+		//////////////////////////
+		// Panel 5 - Cache container
+		//////////////////////////
+		addTitle(pnlContainer,"Cache container");
+		pnlContainer.addLast(new mLabel("To be implemented"));
 		
-		roseP.addNext(SSW = new mCheckBox("SSW"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		SSW.state = (Global.getProfile().filterRose.charAt(12) == '1' ? true : false);
-		roseP.addNext(S = new mCheckBox("S"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		S.state = (Global.getProfile().filterRose.charAt(13) == '1' ? true : false);
-		roseP.addNext(SSE = new mCheckBox("SSE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		SSE.state = (Global.getProfile().filterRose.charAt(14) == '1' ? true : false);
-		roseP.addLast(SE = new mCheckBox("SE"),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		SE.state = (Global.getProfile().filterRose.charAt(15) == '1' ? true : false);
+		//////////////////////////
+		// Panel 6 - Search
+		//////////////////////////
+		addTitle(pnlSearch,"Search");
+		pnlSearch.addLast(new mLabel("To be implemented"));
 		
-		content.addLast(roseP, CellConstants.STRETCH,CellConstants.FILL);
+		lastChc = new mChoice(new String[]{MyLocale.getMsg(703,"Found"), MyLocale.getMsg(704,"Not found")},0);
+		lastIn = new mInput();
+		foundIn = new mInput();
+/*		content.addNext(lastChc,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		content.addNext(new mLabel(MyLocale.getMsg(705," last ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		content.addLast(lastIn,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		
+		content.addNext(new mLabel(MyLocale.getMsg(706,"Found by: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		content.addLast(foundIn,CellConstants.DONTSTRETCH, CellConstants.FILL);
+*/		
+		Frame frmScreen=new Frame();
+		mLabel lblInfo; 
+		frmScreen.addLast(lblInfo=new mLabel("Note: Filters are additive, active filter=green")).setTag(SPAN,new Dimension(2,1));
+		lblInfo.setTag(INSETS,new Insets(0,0,2,0));
+		frmScreen.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		this.addLast(frmScreen,HSTRETCH,HFILL);
+		
+		CellPanel pnlButtons=new CellPanel();
+		pnlButtons.addLast(new mLabel("Filter"));
+		pnlButtons.addLast(btnBearing=new mButton("Bearing"));
+		pnlButtons.addLast(btnAttributes=new mButton("Attributes"));
+		pnlButtons.addLast(btnRatings=new mButton("Ratings"));
+		pnlButtons.addLast(btnTypes=new mButton("Types")); 
+		pnlButtons.addLast(btnContainer=new mButton("Container")); btnContainer.modify(Disabled,0);
+		pnlButtons.addLast(btnSearch=new mButton("Search")); btnSearch.modify(Disabled,0);
+		addNext(pnlButtons,HSTRETCH,FILL);
+
+		cp.addItem(pnlBearDist,"Bear",null);
+		cp.addItem(pnlAttributes,"Att",null);
+		cp.addItem(pnlRatings,"DT",null); 
+		cp.addItem(pnlCacheTypes,"Type",null);
+		cp.addItem(pnlContainer,"Size",null);
+		cp.addItem(pnlSearch,"Search",null);
+		addLast(cp);
+
 		CellPanel btPanel = new CellPanel();
-		btPanel.addNext(btCancel = new mButton((String)lr.get(708,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
-		btPanel.addNext(btApply = new mButton((String)lr.get(709,"Apply")),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addNext(btCancel = new mButton(MyLocale.getMsg(708,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addNext(btApply = new mButton(MyLocale.getMsg(709,"Apply")),CellConstants.STRETCH, CellConstants.FILL);
 		btPanel.addLast(btRoute = new mButton("Route"),CellConstants.STRETCH, CellConstants.FILL);
-		content.addLast(btPanel.setTag(Control.SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
+		addLast(btPanel.setTag(Control.SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
+		setPreferredSize(240,240);
 		
-		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 	}
 	
+	
+	public void setData(Vector DB, String d){
+		dir = d;
+		cacheDB = DB;
+		Profile prof=Global.getProfile();
+
+		//////////////////////////
+		// Panel 1 - Bearing & Distance
+		//////////////////////////
+		if (prof.filterDist.length()>1) {
+			if (prof.filterDist.charAt(0)=='<')
+				distChc.select(0);
+			else
+				distChc.select(1);
+			distIn.setText(prof.filterDist.substring(1));
+		} else {
+			distChc.select(0);
+			distIn.setText("");
+		}
+		// If filter has been corrupted, pad it to 11 characters
+		String fltRose=prof.filterRose;
+		if (fltRose.length()<16) { 
+			fltRose=(fltRose+"1111111111111111").substring(0,16); 
+			prof.filterRose=fltRose; 
+		}  
+		NW.state   = fltRose.charAt(0) == '1';
+		NNW.state  = fltRose.charAt(1) == '1';
+		N.state    = fltRose.charAt(2) == '1';
+		NNE.state  = fltRose.charAt(3) == '1';
+		
+		NE.state   = fltRose.charAt(4) == '1';
+		ENE.state  = fltRose.charAt(5) == '1';
+		E.state    = fltRose.charAt(6) == '1';
+		ESE.state  = fltRose.charAt(7) == '1';
+
+		SE.state   = fltRose.charAt(8) == '1';
+		SSE.state  = fltRose.charAt(9) == '1';
+		S.state    = fltRose.charAt(10) == '1';
+		SSW.state  = fltRose.charAt(11) == '1';
+
+		SW.state   = fltRose.charAt(12) == '1';
+		WSW.state  = fltRose.charAt(13) == '1';
+		W.state    = fltRose.charAt(14) == '1';
+		WNW.state  = fltRose.charAt(15) == '1';
+		
+		//////////////////////////
+		// Panel 2 - Cache attributes
+		//////////////////////////
+		String fltVar=prof.filterVar;
+		if (fltVar.length()<8) { 
+			fltVar=(fltVar+"11111111").substring(0,8); 
+			prof.filterVar=fltVar; 
+		}  
+		archivedChk.state      = fltVar.charAt(0) == '1';
+		availableChk.state     = fltVar.charAt(1) == '1';
+		foundChk.state         = fltVar.charAt(2) == '1';
+		ownedChk.state         = fltVar.charAt(3) == '1';
+		notArchivedChk.state   = fltVar.charAt(4) == '1';
+		notAvailableChk.state  = fltVar.charAt(5) == '1';
+		notFoundChk.state      = fltVar.charAt(6) == '1';
+		notOwnedChk.state      = fltVar.charAt(7) == '1';
+
+		//////////////////////////
+		// Panel 3 - Cache ratings
+		//////////////////////////
+		if (prof.filterDiff.length()>1) {
+			if (prof.filterDiff.charAt(0)=='<')
+				difChc.select(0);
+			else if (prof.filterDiff.charAt(0)=='=')
+				difChc.select(1);
+			else
+				difChc.select(2);
+			difIn.setText(prof.filterDiff.substring(1));
+		} else {
+			difChc.select(0);
+			difIn.setText("");
+		}
+
+		if (prof.filterTerr.length()>1) {
+			if (prof.filterTerr.charAt(0)=='<')
+				terrChc.select(0);
+			else if (prof.filterTerr.charAt(0)=='=')
+				terrChc.select(1);
+			else
+				terrChc.select(2);
+			terrIn.setText(prof.filterTerr.substring(1));
+		} else {
+			terrChc.select(0);
+			terrIn.setText("");
+		}
+
+
+		//////////////////////////
+		// Panel 4 - Cache types
+		//////////////////////////
+		
+		// If filter has been corrupted, pad it to 11 characters
+		String fltType=prof.filterType;
+		if (fltType.length()<11) { 
+			fltType=(fltType+"11111111111").substring(0,11); 
+			prof.filterType=fltType; 
+		}  
+		tradChk.state    = fltType.charAt(0) == '1';
+		multiChk.state   = fltType.charAt(1) == '1';
+		virtualChk.state = fltType.charAt(2) == '1';
+		letterChk.state  = fltType.charAt(3) == '1';
+		eventChk.state   = fltType.charAt(4) == '1';
+		webcamChk.state  = fltType.charAt(5) == '1';
+		mysteryChk.state = fltType.charAt(6) == '1';
+		earthChk.state   = fltType.charAt(7) == '1';
+		loclessChk.state = fltType.charAt(8) == '1';
+		megaChk.state    = fltType.charAt(9) == '1';
+		addiWptChk.state = fltType.charAt(10) == '1';
+
+		//////////////////////////
+		// Panel 5 - Cache container
+		//////////////////////////
+		
+		//////////////////////////
+		// Panel 6 - Search
+		//////////////////////////
+		
+		// Adjust colors of buttons depending on which filters are active
+		setColors();
+	}
+	
+	// Set the colors of the filter buttons according to which filters are active
+	private void setColors() {
+		// Panel 1 - Bearing & Distance
+		if (distIn.getText().length()>0 || 
+			  !(NW.getState() && NNW.getState() && N.getState() && NNE.getState() &&
+				NE.getState() && ENE.getState() && E.getState() && ESE.getState() &&
+				SE.getState() && SSE.getState() && S.getState() && SSW.getState() &&
+				SW.getState() && WSW.getState() && W.getState() && WNW.getState()))
+			btnBearing.backGround=COLOR_FILTERACTIVE;
+		else
+			btnBearing.backGround=COLOR_FILTERINACTIVE;
+		btnBearing.repaint();
+		
+		// Panel 2 - Cache attributes
+		if (!( archivedChk.getState()    && availableChk.getState()    && foundChk.getState()    && ownedChk.getState() &&
+			   notArchivedChk.getState() && notAvailableChk.getState() && notFoundChk.getState() && notOwnedChk.getState()))
+			btnAttributes.backGround=COLOR_FILTERACTIVE;
+		else
+			btnAttributes.backGround=COLOR_FILTERINACTIVE;
+		btnAttributes.repaint();
+		
+		// Panel 3 - Cache ratings
+		if (difIn.getText().length()>0 || terrIn.getText().length()>0)
+			btnRatings.backGround=COLOR_FILTERACTIVE;
+		else
+			btnRatings.backGround=COLOR_FILTERINACTIVE;
+		btnRatings.repaint();
+
+		// Panel 4 - Cache types
+		if (!(tradChk.getState() && multiChk.getState() && 	virtualChk.getState() && letterChk.getState() &&
+		      eventChk.getState() && webcamChk.getState() && mysteryChk.getState() && earthChk.getState() &&
+		      loclessChk.getState() && megaChk.getState() && !addiWptChk.getState())) 
+			btnTypes.backGround=COLOR_FILTERACTIVE;
+		else
+			btnTypes.backGround=COLOR_FILTERINACTIVE;
+		btnTypes.repaint();
+
+		// Panel 5 - Cache container
+
+		// Panel 6 - Search
+		
+	}
+	
 	/**
 	*	React to the users input, create a filter and set the variable of the filter.
 	*	@see Filter
@@ -159,11 +394,11 @@
 			if (ev.target == btCancel){
 				this.close(0);
 			}
-			if (ev.target == btRoute){
+			else if (ev.target == btRoute){
 				
 				File datei;
 				FileChooser fc = new FileChooser(FileChooser.OPEN, dir);
-				fc.setTitle((String)lr.get(712,"Select route file"));
+				fc.setTitle(MyLocale.getMsg(712,"Select route file"));
 				if(fc.execute() != FormBase.IDCANCEL) {
 					datei = fc.getChosenFile();
 					InfoBox inf = new InfoBox("Distance?", "Dist:", InfoBox.INPUT);
@@ -177,29 +412,36 @@
 				this.close(0);
 				
 			}
-			if (ev.target == btApply){
+			else if (ev.target == btApply){
 				Vm.showWait(true);
 				//Save filter required
 				Filter flt = new Filter();
 				flt.foundByMe = foundChk.getState();
+				flt.notFoundByMe = notFoundChk.getState();
 				flt.ownedByMe = ownedChk.getState();
+				flt.notOwnedByMe = notOwnedChk.getState();
 				
 				flt.dist = distIn.getText();
 				flt.diff = difIn.getText();
 				flt.terr = terrIn.getText();
 				flt.days = lastIn.getText();
 				flt.by = foundIn.getText();
+				flt.available = availableChk.getState();
 				flt.notAvailable = notAvailableChk.getState();
 				flt.archived = archivedChk.getState();
-				String filterType = new String();
-				String filterVar = new String();
-				String filterRose = new String();
-				filterVar = (archivedChk.getState() == true ? "1" : "0")+
-							(notAvailableChk.getState() == true ? "1" : "0") +
-							(foundChk.getState() == true ? "1" : "0") +
-							(ownedChk.getState() == true ? "1" : "0");
+				flt.notArchived = notArchivedChk.getState();
+				String filterType;
+				String filterVar;
+				String filterRose;
+				filterVar = (archivedChk.getState()    ? "1" : "0") +
+							(availableChk.getState()   ? "1" : "0") +
+							(foundChk.getState()       ? "1" : "0") +
+							(ownedChk.getState()       ? "1" : "0") +
+							(notArchivedChk.getState() ? "1" : "0") +
+							(notAvailableChk.getState()? "1" : "0") +
+							(notFoundChk.getState()    ? "1" : "0") +
+							(notOwnedChk.getState()    ? "1" : "0");							
 							
-							
 				int typeMatchPattern = 0;
 				if(tradChk.getState()) typeMatchPattern |= Filter.TRADITIONAL;
 				if(multiChk.getState()) typeMatchPattern |= Filter.MULTI;
@@ -213,75 +455,128 @@
 				if(earthChk.getState()) typeMatchPattern |= Filter.EARTH;
 				if(megaChk.getState()) typeMatchPattern |= Filter.MEGA;
 				flt.typeMatchPattern = typeMatchPattern;
-				filterType = 	(tradChk.getState() == true ? "1" : "0") +
-								(multiChk.getState() == true ? "1" : "0") +
-								(virtualChk.getState() == true ? "1" : "0") +
-								(letterChk.getState() == true ? "1" : "0") +
-								(eventChk.getState() == true ? "1" : "0")+ 
-								(webcamChk.getState() == true ? "1" : "0")+
-								(mysteryChk.getState() == true ? "1" : "0")+
-								(earthChk.getState() == true ? "1" : "0")+
-								(loclessChk.getState() == true ? "1" : "0")+
-								(megaChk.getState() == true ? "1" : "0")+
-								(addiWptChk.getState() == true ? "1" : "0");
+				filterType = 	(tradChk.getState()    ? "1" : "0") +
+								(multiChk.getState()   ? "1" : "0") +
+								(virtualChk.getState() ? "1" : "0") +
+								(letterChk.getState()  ? "1" : "0") +
+								(eventChk.getState()   ? "1" : "0") + 
+								(webcamChk.getState()  ? "1" : "0") +
+								(mysteryChk.getState() ? "1" : "0") +
+								(earthChk.getState()   ? "1" : "0") +
+								(loclessChk.getState() ? "1" : "0") +
+								(megaChk.getState()    ? "1" : "0") +
+								(addiWptChk.getState() ? "1" : "0");
 				
 				int roseMatchPattern = 0;
-				if(N.getState()) roseMatchPattern |= Filter.N;
+				if(N.getState())   roseMatchPattern |= Filter.N;
 				if(NNE.getState()) roseMatchPattern |= Filter.NNE;
-				if(NE.getState()) roseMatchPattern |= Filter.NE;
+				if(NE.getState())  roseMatchPattern |= Filter.NE;
 				if(ENE.getState()) roseMatchPattern |= Filter.ENE;
-				if(E.getState()) roseMatchPattern |= Filter.E;
+				if(E.getState())   roseMatchPattern |= Filter.E;
 				if(ESE.getState()) roseMatchPattern |= Filter.ESE;
-				if(SE.getState()) roseMatchPattern |= Filter.SE;
+				if(SE.getState())  roseMatchPattern |= Filter.SE;
 				if(SSE.getState()) roseMatchPattern |= Filter.SSE;
 				if(SSW.getState()) roseMatchPattern |= Filter.SSW;
-				if(SW.getState()) roseMatchPattern |= Filter.SW;
+				if(SW.getState())  roseMatchPattern |= Filter.SW;
 				if(WSW.getState()) roseMatchPattern |= Filter.WSW;
-				if(W.getState()) roseMatchPattern |= Filter.W;
+				if(W.getState())   roseMatchPattern |= Filter.W;
 				if(WNW.getState()) roseMatchPattern |= Filter.WNW;
-				if(NW.getState()) roseMatchPattern |= Filter.NW;
+				if(NW.getState())  roseMatchPattern |= Filter.NW;
 				if(NNW.getState()) roseMatchPattern |= Filter.NNW;
-				if(S.getState()) roseMatchPattern |= Filter.S;
+				if(S.getState())   roseMatchPattern |= Filter.S;
 				flt.roseMatchPattern = roseMatchPattern;
-				filterRose = (N.getState() == true ? "1":"0")+
-							 (NNE.getState() == true ? "1":"0")+
-							 (NE.getState() == true ? "1":"0")+
-							 (ENE.getState() == true ? "1":"0")+
-							 (E.getState() == true ? "1":"0")+
-							 (ESE.getState() == true ? "1":"0")+
-							 (SE.getState() == true ? "1":"0")+
-							 (SSE.getState() == true ? "1":"0")+
-							 (SSW.getState() == true ? "1":"0")+
-							 (SW.getState() == true ? "1":"0")+
-							 (WSW.getState() == true ? "1":"0")+
-							 (W.getState() == true ? "1":"0")+
-							 (WNW.getState() == true ? "1":"0")+
-							 (NW.getState() == true ? "1":"0")+
-							 (NNW.getState() == true ? "1":"0")+
-							 (S.getState() == true ? "1":"0");
+				filterRose = (NW.getState()  ? "1":"0")+
+							 (NNW.getState() ? "1":"0")+
+							 (N.getState()   ? "1":"0")+
+							 (NNE.getState() ? "1":"0")+
+							 (NE.getState()  ? "1":"0")+
+							 (ENE.getState() ? "1":"0")+
+							 (E.getState()   ? "1":"0")+
+							 (ESE.getState() ? "1":"0")+
+							 (SE.getState()  ? "1":"0")+
+							 (SSE.getState() ? "1":"0")+
+							 (S.getState()   ? "1":"0")+
+							 (SSW.getState() ? "1":"0")+
+							 (SW.getState()  ? "1":"0")+
+							 (WSW.getState() ? "1":"0")+
+							 (W.getState()   ? "1":"0")+
+							 (WNW.getState() ? "1":"0");
 				
-				InfoBox infB = new InfoBox("Info",MyLocale.getMsg(713,"Saving filter"));
-				infB.exec();
 				Profile pfl = Global.getProfile();
+				if(distChc.selectedIndex == 0) { 
+					flt.distdirec = Filter.SMALLER;
+					pfl.filterDist="<"+flt.dist;
+				} else { 
+					flt.distdirec = Filter.GREATER;
+					pfl.filterDist=">"+flt.dist;
+				}
+					
+				if(difChc.selectedIndex == 0) { 
+					flt.diffdirec = Filter.SMALLER;
+					pfl.filterDiff="<"+flt.diff;
+				} else if(difChc.selectedIndex == 1) { 
+					flt.diffdirec = Filter.EQUAL;
+					pfl.filterDiff="="+flt.diff;
+				} else {	
+					flt.diffdirec = Filter.GREATER;
+					pfl.filterDiff=">"+flt.diff;
+				}	
+					
+				if(terrChc.selectedIndex == 0) { 
+					flt.terrdirec = Filter.SMALLER;
+					pfl.filterTerr="<"+flt.terr;
+				} else if(terrChc.selectedIndex == 1){ 
+					flt.terrdirec = Filter.EQUAL;
+					pfl.filterTerr="="+flt.terr;
+				} else { 
+					flt.terrdirec = Filter.GREATER;
+					pfl.filterTerr=">"+flt.terr;
+				}
+				
+				if(lastChc.selectedIndex == 0) 
+					flt.daysdirec = Filter.FOUND;
+				else 
+					flt.daysdirec = Filter.NOTFOUND;
+
+				// Need to think about saving it here. If yes, we also need to save filter when we clear it.
+				// Maybe better to auto-save index upon exit
+				//InfoBox infB = new InfoBox("Info",MyLocale.getMsg(713,"Saving filter"));
+				//infB.exec();
 				pfl.filterRose = filterRose;
 				pfl.filterType = filterType;
 				pfl.filterVar = filterVar;
-				pfl.saveIndex(Global.getPref());
-				infB.close(0);
-				
-				if(distChc.selectedIndex == 1) flt.distdirec = Filter.SMALLER;
-				else flt.distdirec = Filter.GREATER;
-				if(difChc.selectedIndex == 1) flt.diffdirec = Filter.SMALLER;
-				else flt.diffdirec = Filter.GREATER;
-				if(terrChc.selectedIndex == 1) flt.terrdirec = Filter.SMALLER;
-				else flt.terrdirec = Filter.GREATER;
-				if(lastChc.selectedIndex == 0) flt.daysdirec = Filter.FOUND;
-				else flt.daysdirec = Filter.NOTFOUND;
+				//pfl.saveIndex(Global.getPref());
+				//infB.close(0);
 				flt.doFilter(cacheDB, dir);
+				Global.mainTab.tbP.tc.scrollToVisible(0,0);
 				Vm.showWait(false);
 				//Tabelle neu zeichnen lassen!
 				this.close(0);
 			}
+			else if (ev.target == btnBearing) cp.select(0);
+			else if (ev.target == btnAttributes) cp.select(1);
+			else if (ev.target == btnRatings)cp.select(2);
+			else if (ev.target == btnTypes)cp.select(3);
+			else if (ev.target == btnContainer)cp.select(4);
+			else if (ev.target == btnSearch)cp.select(5);
+			else if (ev.target == chkDeselect) {
+				NW.state= NNW.state  = N.state    = NNE.state  = 
+				NE.state   = ENE.state  = E.state    = ESE.state  = 
+				SE.state   = SSE.state  = S.state    = SSW.state  = 
+				SW.state   = WSW.state  = W.state    = WNW.state = false; 
+				chkDeselect.state=false;
+				repaint();
+					
+			} else if (ev.target == chkSelect) {
+				NW.state= NNW.state  = N.state    = NNE.state  = 
+				NE.state   = ENE.state  = E.state    = ESE.state  = 
+				SE.state   = SSE.state  = S.state    = SSW.state  = 
+				SW.state   = WSW.state  = W.state    = WNW.state = true; 
+				chkSelect.state=false;
+				repaint();	
+			}
 		}
+		if (ev instanceof DataChangeEvent )	setColors();
+
 	}
 }

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-30 03:03:52 UTC (rev 475)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-31 07:28:01 UTC (rev 476)
@@ -32,6 +32,7 @@
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditProfile;
 	private Form father;
 	private TablePanel tbp;
+	private FilterScreen scnFilter=new FilterScreen();
 	
 	public MainMenu(Form f){
 		father = f;
@@ -116,13 +117,14 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems=new MenuItem[6];
+		MenuItem[] filterAndSearchMenuItems=new MenuItem[7];
 		filterAndSearchMenuItems[0]=filtCreate;
 		filterAndSearchMenuItems[1]=filtInvert;
 		filterAndSearchMenuItems[2]=filtClear;
-		filterAndSearchMenuItems[3]=mnuSeparator;
-		filterAndSearchMenuItems[4]=search;
-		filterAndSearchMenuItems[5]=searchClr;
+		filterAndSearchMenuItems[3]=filtBlack;
+		filterAndSearchMenuItems[4]=mnuSeparator;
+		filterAndSearchMenuItems[5]=search;
+		filterAndSearchMenuItems[6]=searchClr;
 		
 		// Depending on screen width display either filter and searach menus or the combined menu 
 		if (MyLocale.getScreenWidth()>300) {
@@ -258,8 +260,8 @@
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == filtCreate){
-				FilterScreen fsc = new FilterScreen(cacheDB, pref.baseDir);
-				fsc.execute(father.getFrame(), Gui.CENTER_FRAME);
+				scnFilter.setData(cacheDB, pref.baseDir);
+				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == filtInvert){

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-01-30 03:03:52 UTC (rev 475)
+++ trunk/src/CacheWolf/Profile.java	2007-01-31 07:28:01 UTC (rev 476)
@@ -35,11 +35,17 @@
 	/** Distance for opencaching caches */
 	public String distOC = new String();
 	
-	public String filterType = new String("11111111110");
-	public String filterRose = new String("1111111111111111");
+	public final static String FILTERTYPE="11111111110";
+	public final static String FILTERROSE="1111111111111111";
+	public final static String FILTERVAR="11111111";
+	public String filterType = new String(FILTERTYPE);
+	public String filterRose = new String(FILTERROSE);
 	//filter settings for archived ... owner (section) in filterscreen
-	public String filterVar = new String("1111");
-	//TODO Add the current filter settings here so that they are restored when the profile is reloaded
+	public String filterVar = new String(FILTERVAR);
+	public String filterDist=new String("");
+	public String filterDiff=new String("");
+	public String filterTerr=new String("");
+	
 	//TODO Add other settings, such as max. number of logs to spider
 	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 	
@@ -93,7 +99,9 @@
 				distOC = "0";
 			}
 			
-			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+"\" var = \""+filterVar+"\" />\n");
+			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+
+					 "\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
+					 filterDiff+"\" terr = \""+filterTerr+"\" />\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
@@ -200,6 +208,9 @@
 					filterRose = ex.findNext();
 					filterType = ex.findNext();
 					filterVar = ex.findNext();
+					filterDist = ex.findNext();
+					filterDiff = ex.findNext();
+					filterTerr = ex.findNext();
 //					 Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}



From pfeffer at mail.berlios.de  Wed Jan 31 17:16:49 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 31 Jan 2007 17:16:49 +0100
Subject: [Cachewolf-svn] r477 - trunk/src/CacheWolf
Message-ID: <200701311616.l0VGGnBq007112@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-31 17:16:44 +0100 (Wed, 31 Jan 2007)
New Revision: 477

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
MovingMap: Bug beim erstmaligen Karten-Import: Verzeichnis wurde nicht automatisch erstellt. siehe http://www.geoclub.de/ftopic13912.html

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-01-31 07:28:01 UTC (rev 476)
+++ trunk/src/CacheWolf/Preferences.java	2007-01-31 16:16:44 UTC (rev 477)
@@ -178,12 +178,19 @@
 	}
 
 	/**
-	 * 
+	 * it creates the directory if it doesn't exist
 	 * @return the path where manually imported maps should be stored
 	 * this should be adjustable in preferences...
 	 */
 	public String getMapManuallySavePath() {
-		return baseDir + mapsPath;
+		String mapsDir = baseDir + mapsPath;
+		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
+			if (new File(mapsDir).mkdirs() == false) {// dir creation failed?
+				(new MessageBox("Error", "Error: cannot create maps directory: \n"+mapsDir, MessageBox.OKB)).exec();
+				return null;
+			}
+		}
+		return mapsDir;
 	}
 
 	/**



From pfeffer at mail.berlios.de  Wed Jan 31 17:18:48 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 31 Jan 2007 17:18:48 +0100
Subject: [Cachewolf-svn] r478 - trunk/src/CacheWolf
Message-ID: <200701311618.l0VGImPx007512@sheep.berlios.de>

Author: pfeffer
Date: 2007-01-31 17:18:46 +0100 (Wed, 31 Jan 2007)
New Revision: 478

Modified:
   trunk/src/CacheWolf/Map.java
Log:
Fehlermeldungversch?\195?\182nerung

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-01-31 16:16:44 UTC (rev 477)
+++ trunk/src/CacheWolf/Map.java	2007-01-31 16:18:46 UTC (rev 478)
@@ -241,7 +241,7 @@
 				in.close();
 				out.close();
 			} catch(IOException ex){
-				inf.addText("IO-Error while copying image \n" + ex.getMessage());
+				inf.addText(": IO-Error while copying image \n" + ex.getMessage());
 			}
 
 			//Check for a .map file



From admin at berlios.de  Wed Jan 31 20:50:29 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 31 Jan 2007 20:50:29 +0100 (CET)
Subject: [Bug #9980] Kontextmenü Alle wählen/ alle abwählen
Message-ID: <200701311950.l0VJoTYG013744@unicorn.berlios.de>

Bug #9980, was updated on 2007-Jan-14 20:00
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: cw-tester
Assigned to : kalli
Summary: Kontextmen? Alle w?hlen/ alle abw?hlen

Details: wenn ich in der Listansicht eine Anzahl Caches mittels der suchenfunktion selektiert habe und dann ?ber das Kontextmen? 'alle w?hlen' anklicke werden alle Caches markiert. Auch die nicht mehr sichbaren. Wenn ich nun die markierten l?sche, sind alle weg. Ob das selbe Ergebnis auch f?r das vorherige Filtern gilt, kann ich erst sagen, wenn diese Funktion wieder geht.

Auf jeden Fall ist das ein unerw?nschtes Ergebnis. Alle Befehle sollten nur auf die in der Liste sichtbaren Caches angewendet werden.


For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9980&group_id=2211


From kalli at mail.berlios.de  Wed Jan 31 21:03:06 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Wed, 31 Jan 2007 21:03:06 +0100
Subject: [Cachewolf-svn] r479 - trunk/src/CacheWolf
Message-ID: <200701312003.l0VK36Wp004386@sheep.berlios.de>

Author: kalli
Date: 2007-01-31 21:03:04 +0100 (Wed, 31 Jan 2007)
New Revision: 479

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
[ Bug #9980 ] Kontextmen?\195?\188 Alle w?\195?\164hlen/ alle abw?\195?\164hlen wirkt nur noch auf die sichtbaren Caches in der Liste

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-01-31 16:18:46 UTC (rev 478)
+++ trunk/src/CacheWolf/myTableControl.java	2007-01-31 20:03:04 UTC (rev 479)
@@ -39,7 +39,7 @@
 			CacheHolder ch;
 			for(int i = 0; i <	db.size(); i++){
 				ch = (CacheHolder)db.get(i);
-				ch.is_Checked = true;
+				if (ch.is_filtered == false) ch.is_Checked = true;
 				//db.set(i, ch);
 			}
 			tbp.myMod.cacheSelectionChanged = true;
@@ -57,7 +57,7 @@
 		if (selectedItem.toString().equals(MyLocale.getMsg(1016,"De-select all"))){
 			for(int i = 0; i <	db.size(); i++){
 				ch = (CacheHolder)db.get(i);
-				ch.is_Checked = false;
+				if (ch.is_filtered == false) ch.is_Checked = false;
 				//db.set(i, ch);
 			}
 			tbp.myMod.cacheSelectionChanged = true;



From admin at berlios.de  Wed Jan 31 21:03:12 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 31 Jan 2007 21:03:12 +0100 (CET)
Subject: [Bug #9980] Kontextmenü Alle wählen/ alle abwählen
Message-ID: <200701312003.l0VK3Cqp028550@unicorn.berlios.de>

Bug #9980, was updated on 2007-Jan-14 20:00
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: cw-tester
Assigned to : cw-tester
Summary: Kontextmen? Alle w?hlen/ alle abw?hlen

Details: wenn ich in der Listansicht eine Anzahl Caches mittels der suchenfunktion selektiert habe und dann ?ber das Kontextmen? 'alle w?hlen' anklicke werden alle Caches markiert. Auch die nicht mehr sichbaren. Wenn ich nun die markierten l?sche, sind alle weg. Ob das selbe Ergebnis auch f?r das vorherige Filtern gilt, kann ich erst sagen, wenn diese Funktion wieder geht.

Auf jeden Fall ist das ein unerw?nschtes Ergebnis. Alle Befehle sollten nur auf die in der Liste sichtbaren Caches angewendet werden.


For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9980&group_id=2211


From admin at berlios.de  Wed Jan 31 21:07:53 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 31 Jan 2007 21:07:53 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10123] caches verwalten - move
Message-ID: <200701312007.l0VK7rH6003926@unicorn.berlios.de>

Bug #10123, was updated on 2007-Jan-25 16:29
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : none
Summary: caches verwalten - move

Details: Evt. User-Error aber:
auf meinem PDA markiere ich caches inder Liste (vorne Haken rein), dann will ich sie verschieben. Dann scheint er noch was zu machen und dann kommt der mir schon unverst?ndliche Dialog "Weiter?" - danach ist Sense=Absturz!
Mach ich was verkehrt oder wie?
Was ich tun wilL: meine gefundenen und/oder eigenen Caches in ein eigenes (sogar vorher angelegtes) Verzeichnis verschieben. 

ich hoff ich hab mich da vest?ndlich genug ausgedr?ckt...

Follow-Ups:

Date: 2007-Jan-31 21:07
By: kalli

Comment:
Hast Du die Liste nach dem Markieren gefiltert? Das Verschieben wirkt auf alle angezeigten Caches!

Der Dialog, den Du siehst, ist die Sicherheitsabfrage. Vielleicht gibts auf dem PDA ein Problem mit der Menge der Caches beim Verschieben, mit Massendaten habe ich das auf dem PDA noch nicht getestet.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10123&group_id=2211


From kalli at mail.berlios.de  Wed Jan 31 21:36:55 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Wed, 31 Jan 2007 21:36:55 +0100
Subject: [Cachewolf-svn] r480 - trunk/src/CacheWolf
Message-ID: <200701312036.l0VKatLS008374@sheep.berlios.de>

Author: kalli
Date: 2007-01-31 21:36:42 +0100 (Wed, 31 Jan 2007)
New Revision: 480

Modified:
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
[ Bug #10090 ] Darstellung der gefundenen Caches

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-01-31 20:03:04 UTC (rev 479)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-01-31 20:36:42 UTC (rev 480)
@@ -321,6 +321,7 @@
 		}
 		if (name.equals("sym")&& strData.endsWith("Found")) {
 			holder.is_found = true;
+			holder.CacheStatus = MyLocale.getMsg(318,"Found");
 			return;
 		}
 		if (name.equals("groundspeak:travelbugs")) {

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-01-31 20:03:04 UTC (rev 479)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-01-31 20:36:42 UTC (rev 480)
@@ -544,7 +544,10 @@
 		}
 		if (name.equals("userid")){
 			logFinder = new String(strData);
-			if(logFinder.toLowerCase().compareTo(user) == 0) holder.is_found = true;
+			if(logFinder.toLowerCase().compareTo(user) == 0){
+				holder.is_found = true;
+				holder.CacheStatus = MyLocale.getMsg(318,"Found");
+			}
 			return;
 		}
 		if (name.equals("text")){ 



From admin at berlios.de  Wed Jan 31 21:36:53 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 31 Jan 2007 21:36:53 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10090] Darstellung der gefundenen Caches
Message-ID: <200701312036.l0VKarrm006453@unicorn.berlios.de>

Bug #10090, was updated on 2007-Jan-22 13:45
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: cw-tester
Assigned to : cw-tester
Summary: Darstellung der gefundenen Caches

Details: Wenn ich eine GPX.Datei lade werden die gefundenen Caches gr?n dargestellt. Der Status ist aber leer. Erst wenn ich in Details gehe schaltet der Status auf gefunden.

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10090&group_id=2211


From admin at berlios.de  Wed Jan 31 22:21:43 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 31 Jan 2007 22:21:43 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10123] caches verwalten - move
Message-ID: <200701312121.l0VLLhin025543@unicorn.berlios.de>

Bug #10123, was updated on 2007-Jan-25 16:29
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : none
Summary: caches verwalten - move

Details: Evt. User-Error aber:
auf meinem PDA markiere ich caches inder Liste (vorne Haken rein), dann will ich sie verschieben. Dann scheint er noch was zu machen und dann kommt der mir schon unverst?ndliche Dialog "Weiter?" - danach ist Sense=Absturz!
Mach ich was verkehrt oder wie?
Was ich tun wilL: meine gefundenen und/oder eigenen Caches in ein eigenes (sogar vorher angelegtes) Verzeichnis verschieben. 

ich hoff ich hab mich da vest?ndlich genug ausgedr?ckt...

Follow-Ups:

Date: 2007-Jan-31 22:21
By: albsucher

Comment:
Nein, ich habe vorher nichts gefiltert.
meien Absicht war, die von mir gefundenen caches in ein anderes Verzeichnis zu verschieben. dazu hab ich in der Listenansicht einfach mal ein paar markiert und wollte einen move machen...
-------------------------------------------------------

Date: 2007-Jan-31 21:07
By: kalli

Comment:
Hast Du die Liste nach dem Markieren gefiltert? Das Verschieben wirkt auf alle angezeigten Caches!

Der Dialog, den Du siehst, ist die Sicherheitsabfrage. Vielleicht gibts auf dem PDA ein Problem mit der Menge der Caches beim Verschieben, mit Massendaten habe ich das auf dem PDA noch nicht getestet.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10123&group_id=2211


From bilbowolf at mail.berlios.de  Wed Jan 31 22:28:35 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 31 Jan 2007 22:28:35 +0100
Subject: [Cachewolf-svn] r481 - trunk/src/CacheWolf
Message-ID: <200701312128.l0VLSZk2014902@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-31 22:28:31 +0100 (Wed, 31 Jan 2007)
New Revision: 481

Modified:
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-01-31 20:36:42 UTC (rev 480)
+++ trunk/src/CacheWolf/Version.java	2007-01-31 21:28:31 UTC (rev 481)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " BE ";
-	static final String VER_SVN ="$LastChangedRevision$"; //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From bilbowolf at mail.berlios.de  Wed Jan 31 22:48:56 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 31 Jan 2007 22:48:56 +0100
Subject: [Cachewolf-svn] r482 - trunk/src/CacheWolf
Message-ID: <200701312148.l0VLmu3Y016126@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-31 22:48:50 +0100 (Wed, 31 Jan 2007)
New Revision: 482

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:


Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-01-31 21:28:31 UTC (rev 481)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-01-31 21:48:50 UTC (rev 482)
@@ -19,7 +19,7 @@
 	mInput wayOwner = new mInput();
 	//mInput wayStatus = new mInput();
 	
-	mButton btnDelete,btnCenter;
+	mButton btnDelete,btnCenter, addDateTime;
 	mChoice wayType = new mChoice(new String[]{"Custom", "Traditional", "Multi", "Virtual", "Letterbox", "Event", "Mega Event", "Mystery", "Webcam", "Locationless", "CITO", "Earthcache", "Parking", "Stage", "Question", "Final","Trailhead","Reference"},0);
 	mChoice waySize = new mChoice(new String[]{"", "Micro", "Small", "Regular", "Large","Other","Very Large","None"},0);
 	mComboBox wayStatus = new mComboBox(new String[]{"", MyLocale.getMsg(313,"Flag 1"), MyLocale.getMsg(314,"Flag 2"), MyLocale.getMsg(315,"Flag 3"), MyLocale.getMsg(316,"Flag 4"), MyLocale.getMsg(317,"Search"), MyLocale.getMsg(318,"Found"), MyLocale.getMsg(319,"Not Found"), MyLocale.getMsg(320,"Owner")},0);
@@ -54,14 +54,15 @@
 		showBug = new mButton((IImage)mI);
 		showMap = new mButton((IImage)mI2);
 		
+		addDateTime = new mButton((IImage)new mImage("date_time.png"));
 		addPicture = new mButton((IImage)mI4);
 		btnBlack = new mButton((IImage)mNoBlack);
 		toolP.addNext(showBug,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		showBug.modify(Control.Disabled,0);
 		toolP.addNext(showMap,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		toolP.addNext(addPicture,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		toolP.addLast(btnBlack,CellConstants.DONTSTRETCH, CellConstants.WEST);
-			
+		toolP.addNext(btnBlack,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		toolP.addLast(addDateTime,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		//showMap.modify(Control.Disabled,0);
 		this.addLast(toolP,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(3,1));;
 		
@@ -316,7 +317,17 @@
 					mainT.updateBearDist();
 				}
 			}
-			
+			if (ev.target == addDateTime){
+				String note = thisCache.CacheNotes;
+				Time dtm = new Time();
+				dtm.getTime();
+				dtm.setFormat("E dd.MM.yyyy '/' HH:mm");
+				if(note.length() > 0)	note = note + "\n" + dtm.toString();
+				else 	note = note + dtm.toString();
+				note = note + "\n";
+				thisCache.CacheNotes = note;
+				thisCache.saveCacheDetails( Global.getProfile().dataDir);
+			}
 			if (ev.target == addPicture){
 				thisCache.addUserImage(profile);
 			}



From bilbowolf at mail.berlios.de  Wed Jan 31 23:03:00 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 31 Jan 2007 23:03:00 +0100
Subject: [Cachewolf-svn] r483 - trunk/src/CacheWolf
Message-ID: <200701312203.l0VM30oW016900@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-31 23:02:58 +0100 (Wed, 31 Jan 2007)
New Revision: 483

Modified:
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-01-31 21:48:50 UTC (rev 482)
+++ trunk/src/CacheWolf/Version.java	2007-01-31 22:02:58 UTC (rev 483)
@@ -9,7 +9,7 @@
 public class Version {
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
-	static final String VER_BUILD = " BE ";
+	static final String VER_BUILD = " RC ";
 	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**



From bilbowolf at mail.berlios.de  Wed Jan 31 23:39:16 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 31 Jan 2007 23:39:16 +0100
Subject: [Cachewolf-svn] r484 - in trunk: resources src/CacheWolf
Message-ID: <200701312239.l0VMdGFi019877@sheep.berlios.de>

Author: bilbowolf
Date: 2007-01-31 23:39:12 +0100 (Wed, 31 Jan 2007)
New Revision: 484

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-31 22:02:58 UTC (rev 483)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-31 22:39:12 UTC (rev 484)
@@ -145,6 +145,19 @@
 		711=Nicht suchbar
 		712=Route Datei waehlen
 		713=Speicher Filter
+		714=Richtung & Entfernung
+		715=Zeige alle Caches mit Status
+		716=Alle w%e4hlen
+		717=Alle abw%e4hlen
+		718=Cache Bewertungen
+		719=Cache Typen
+		720=Attribute
+		721=Richtung
+		722=Bewertung
+		723=Typen
+		724=Beh%e4lter
+		725=Hinweis: Filter sind additiv, activ = gr%fcn
+		Note: Filters are additive, active filter=green
 		800=Erstelle Liste
 		801=suche...
 		802=Caches identifiziert. Suche weiter...
@@ -440,6 +453,7 @@
 		709=Apply
 		710=Archived
 		711=Not available
+		714=Bearing & Distance
 		800=Creating list
 		801=searching...
 		802=Caches identified. searching...

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-01-31 22:02:58 UTC (rev 483)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-01-31 22:39:12 UTC (rev 484)
@@ -59,7 +59,7 @@
 		//////////////////////////
 		// Panel 1 - Bearing & Distance
 		//////////////////////////
-		addTitle(pnlBearDist,"Bearings & Distance");
+		addTitle(pnlBearDist,MyLocale.getMsg(714,"Bearings & Distance"));
 		pnlBearDist.addNext(new mLabel(MyLocale.getMsg(701,"Distance: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlBearDist.addNext(distChc = new mChoice(new String[]{"<=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		pnlBearDist.addLast(distIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
@@ -83,17 +83,17 @@
 		roseP.addNext(WSW = new mCheckBox("WSW"),CellConstants.HSTRETCH, CellConstants.FILL);
 		roseP.addNext(W = new mCheckBox("W "),CellConstants.HSTRETCH, CellConstants.FILL);
 		roseP.addLast(WNW = new mCheckBox("WNW"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(chkDeselect=new mCheckBox("Deselect all"));
+		roseP.addNext(chkDeselect=new mCheckBox(MyLocale.getMsg(716,"Deselect all")));
 		chkDeselect.setTag(SPAN,new Dimension(2,1));
-		roseP.addLast(chkSelect=new mCheckBox("Select all"));
+		roseP.addLast(chkSelect=new mCheckBox(MyLocale.getMsg(717,"Select all")));
 		pnlBearDist.addLast(roseP, CellConstants.STRETCH,CellConstants.FILL);
 		
 		//////////////////////////
 		// Panel 2 - Cache attributes
 		//////////////////////////
-		addTitle(pnlAttributes,"Attributes");
+		addTitle(pnlAttributes,MyLocale.getMsg(720,"Attributes"));
 		mLabel lblTitleAtt; 
-		pnlAttributes.addLast(lblTitleAtt=new mLabel("Show all caches with status:"),HSTRETCH,FILL);
+		pnlAttributes.addLast(lblTitleAtt=new mLabel(MyLocale.getMsg(715,"Show all caches with status:")),HSTRETCH,FILL);
 		lblTitleAtt.setTag(SPAN,new Dimension(2,1));
 		pnlAttributes.addNext(archivedChk = new mCheckBox(MyLocale.getMsg(710,"Archived")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlAttributes.addLast(notArchivedChk = new mCheckBox("Nicht archiviert"), CellConstants.DONTSTRETCH, CellConstants.FILL);
@@ -110,7 +110,7 @@
 		//////////////////////////
 		// Panel 3 - Cache ratings
 		//////////////////////////
-		addTitle(pnlRatings,"Cache ratings");
+		addTitle(pnlRatings,MyLocale.getMsg(718,"Cache ratings"));
 		pnlRatings.addNext(new mLabel(MyLocale.getMsg(702,"Difficulty: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlRatings.addNext(difChc = new mChoice(new String[]{"<=","=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//pnlRatings.addLast(difIn = new mChoice(new String[]{"1.0", "1.5", "2.0", "2.5", "3.0", "3.5", "4.0", "4.5", "5.0"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -125,7 +125,7 @@
 		// Panel 4 - Cache types
 		//////////////////////////
 		
-		addTitle(pnlCacheTypes,"Cache types");
+		addTitle(pnlCacheTypes,MyLocale.getMsg(719,"Cache types"));
 		pnlCacheTypes.addNext(addImg("2.png"));
 		pnlCacheTypes.addNext(tradChk = new mCheckBox("Traditonal"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
@@ -163,7 +163,7 @@
 		//////////////////////////
 		// Panel 5 - Cache container
 		//////////////////////////
-		addTitle(pnlContainer,"Cache container");
+		addTitle(pnlContainer,MyLocale.getMsg(720,"Cache container"));
 		pnlContainer.addLast(new mLabel("To be implemented"));
 		
 		//////////////////////////
@@ -184,18 +184,18 @@
 */		
 		Frame frmScreen=new Frame();
 		mLabel lblInfo; 
-		frmScreen.addLast(lblInfo=new mLabel("Note: Filters are additive, active filter=green")).setTag(SPAN,new Dimension(2,1));
+		frmScreen.addLast(lblInfo=new mLabel(MyLocale.getMsg(725,"Note: Filters are additive, active filter=green"))).setTag(SPAN,new Dimension(2,1));
 		lblInfo.setTag(INSETS,new Insets(0,0,2,0));
 		frmScreen.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
 		this.addLast(frmScreen,HSTRETCH,HFILL);
 		
 		CellPanel pnlButtons=new CellPanel();
 		pnlButtons.addLast(new mLabel("Filter"));
-		pnlButtons.addLast(btnBearing=new mButton("Bearing"));
-		pnlButtons.addLast(btnAttributes=new mButton("Attributes"));
-		pnlButtons.addLast(btnRatings=new mButton("Ratings"));
-		pnlButtons.addLast(btnTypes=new mButton("Types")); 
-		pnlButtons.addLast(btnContainer=new mButton("Container")); btnContainer.modify(Disabled,0);
+		pnlButtons.addLast(btnBearing=new mButton(MyLocale.getMsg(721,"Bearing")));
+		pnlButtons.addLast(btnAttributes=new mButton(MyLocale.getMsg(720,"Attributes")));
+		pnlButtons.addLast(btnRatings=new mButton(MyLocale.getMsg(722,"Ratings")));
+		pnlButtons.addLast(btnTypes=new mButton(MyLocale.getMsg(723,"Types"))); 
+		pnlButtons.addLast(btnContainer=new mButton(MyLocale.getMsg(724,"Container"))); btnContainer.modify(Disabled,0);
 		pnlButtons.addLast(btnSearch=new mButton("Search")); btnSearch.modify(Disabled,0);
 		addNext(pnlButtons,HSTRETCH,FILL);
 

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-01-31 22:02:58 UTC (rev 483)
+++ trunk/src/CacheWolf/Version.java	2007-01-31 22:39:12 UTC (rev 484)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



