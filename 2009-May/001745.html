<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1827 - in trunk/src: CacheWolf exp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1827%20-%20in%20trunk/src%3A%20CacheWolf%20exp&In-Reply-To=%3C200905182207.n4IM7g5k022887%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001744.html">
   <LINK REL="Next"  HREF="001746.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1827 - in trunk/src: CacheWolf exp</H1>
    <B>greiol at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1827%20-%20in%20trunk/src%3A%20CacheWolf%20exp&In-Reply-To=%3C200905182207.n4IM7g5k022887%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1827 - in trunk/src: CacheWolf exp">greiol at mail.berlios.de
       </A><BR>
    <I>Tue May 19 00:07:42 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001744.html">[Cachewolf-svn] r1826 - trunk/res_noewe
</A></li>
        <LI>Next message: <A HREF="001746.html">[Cachewolf-svn] r1828 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1745">[ date ]</a>
              <a href="thread.html#1745">[ thread ]</a>
              <a href="subject.html#1745">[ subject ]</a>
              <a href="author.html#1745">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: greiol
Date: 2009-05-19 00:07:35 +0200 (Tue, 19 May 2009)
New Revision: 1827

Added:
   trunk/src/CacheWolf/CacheTerrDiff.java
Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/ShowCacheInBrowser.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/exp/ExploristExporter.java
   trunk/src/exp/Exporter.java
   trunk/src/exp/GPXExporter.java
   trunk/src/exp/HTMLExporter.java
   trunk/src/exp/TPLExporter.java
   trunk/src/exp/TomTomExporter.java
Log:
added class CacheTerrDiff

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -25,28 +25,6 @@
 public class CacheHolder {
 	protected static final String NOBEARING = &quot;?&quot;;
 	protected static final String EMPTY = &quot;&quot;;
-	protected static final byte DT_EMPTY = 0;
-	protected static final byte DT_10 = 10;
-	protected static final byte DT_15 = 15;
-	protected static final byte DT_20 = 20;
-	protected static final byte DT_25 = 25;
-	protected static final byte DT_30 = 30;
-	protected static final byte DT_35 = 35;
-	protected static final byte DT_40 = 40;
-	protected static final byte DT_45 = 45;
-	protected static final byte DT_50 = 50;
-	protected static final byte DT_UNKNOWN = -1;
-	protected static final String DT_EMPTY_TXT = &quot;&quot;;
-	protected static final String DT_10_TXT = &quot;1&quot;;
-	protected static final String DT_15_TXT = &quot;1.5&quot;;
-	protected static final String DT_20_TXT = &quot;2&quot;;
-	protected static final String DT_25_TXT = &quot;2.5&quot;;
-	protected static final String DT_30_TXT = &quot;3&quot;;
-	protected static final String DT_35_TXT = &quot;3.5&quot;;
-	protected static final String DT_40_TXT = &quot;4&quot;;
-	protected static final String DT_45_TXT = &quot;4.5&quot;;
-	protected static final String DT_50_TXT = &quot;5&quot;;
-	protected static final String DT_UNKNOWN_TXT = &quot;?&quot;;
 
 	/** Cachestatus is Found, Not found or a date in format yyyy-mm-dd hh:mm for found date */
 	private String cacheStatus = EMPTY;
@@ -74,9 +52,9 @@
 	/** The angle (0=North, 180=South) from the current centre to this point */
 	public double degrees = 0;
 	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
-	private String hard = EMPTY;
+	private byte hard = CacheTerrDiff.CW_DT_ERROR;
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
-	private String terrain = EMPTY;
+	private byte terrain = CacheTerrDiff.CW_DT_ERROR;
 	/** The cache type (@see CacheType for translation table)  */
 	private byte type = CacheType.CW_TYPE_ERROR; 
 	/** True if the cache has been archived */
@@ -103,8 +81,6 @@
 	public boolean is_flaged = false;
 	/** True if the cache has been selected using the tick box in the list view */
 	public boolean is_Checked = false;
-	/** Not used: This attribute is saved with the cache and read back but never set */
-//	public String dirty = EMPTY;
 	/** The unique OC cache ID */
 	private String ocCacheID = EMPTY;
 	/** The number of times this cache has not been found (max. 5) */
@@ -160,238 +136,256 @@
 	public CacheHolder(String xmlString, int version) {
 		int start,end;
 	        try {
-			if (version == 1) {
-		        start = xmlString.indexOf('&quot;');
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		        
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		        
-		        // Assume coordinates are in decimal format
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                notDecSep, decSep));
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                notDecSep, decSep));
-		        pos = new CWPoint(lat, lon);
-		        LatLon = pos.toString();
-		        
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setDateHidden(xmlString.substring(start + 1, end));
-		        // Convert the US format to YYYY-MM-DD if necessary
-		        if (getDateHidden().indexOf('/') &gt; -1)
-			        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-		        
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		        
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setCacheStatus(xmlString.substring(start + 1, end));
-		        
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        try {
-		        	setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
-		        } catch (IllegalArgumentException ex) {
-		        	setType(CacheType.CW_TYPE_ERROR);
-		        	Global.getPref().log(wayPoint, ex, true);
-		        	setIncomplete(true);
-		        }
-	            
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-	            setHard(CacheHolder.terrHard_OC2GC(xmlString.substring(start + 1, end)));
-
-	            start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-	            setTerrain(CacheHolder.terrHard_OC2GC(xmlString.substring(start + 1, end)));
-		        // The next item was 'dirty' but this is no longer used.
-
-	            start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setFiltered(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        try {
-		        	setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
-		        } catch (IllegalArgumentException ex) {
-		        	setCacheSize(CacheSize.CW_SIZE_ERROR);
-		        	Global.getPref().log(wayPoint, ex, true);
-		        	setIncomplete(true);
-		        }
-		        
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setAvailable(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setArchived(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setHas_bugs(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setBlack(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-		        if (is_black() != Global.getProfile().showBlacklisted())
-			        setFiltered(true);
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setOwned(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setFound(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setNew(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setLog_updated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setUpdated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-		        // for backwards compatibility set value to true, if it is not in the file
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setHTML(!xmlString.substring(start + 1, end).equals(&quot;false&quot;));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-	            setNoFindLogs((byte)Convert.toInt(xmlString.substring(start + 1, end)));
-
-	            start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setOcCacheID(xmlString.substring(start + 1, end));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;) || incomplete);
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setLastSyncOC(xmlString.substring(start + 1, end));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-		        recommendationScore = LogList.getScore(getNumRecommended(),
-		                getNumFoundsSinceRecommendation());
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            if (start &gt; -1 &amp;&amp; end &gt; -1) {
-		            setAttributesYes(Convert.parseLong(xmlString.substring(start + 1, end)));
-
-
-		        start = xmlString.indexOf('&quot;', end + 1);
-		        end = xmlString.indexOf('&quot;', start + 1);
-		            if (start &gt; -1 &amp;&amp; end &gt; -1)
-			            setAttributesNo(Convert.parseLong(xmlString.substring(start + 1, end)));
-	            }
-            } else if (version == 3 || version == 2) {
-	            start = xmlString.indexOf('&quot;');
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-	            
-	            // Assume coordinates are in decimal format
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-	                    notDecSep, decSep));
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-	                    notDecSep, decSep));
-	            pos = new CWPoint(lat, lon);
-	            LatLon = pos.toString();
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setDateHidden(xmlString.substring(start + 1, end));
-	            // Convert the US format to YYYY-MM-DD if necessary
-	            if (getDateHidden().indexOf('/') &gt; -1)
-		            setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setCacheStatus(xmlString.substring(start + 1, end));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setOcCacheID(xmlString.substring(start + 1, end));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setLastSyncOC(xmlString.substring(start + 1, end));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-	            recommendationScore = LogList.getScore(getNumRecommended(),
-	                    getNumFoundsSinceRecommendation());
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-		        if (start &gt; -1 &amp;&amp; end &gt; -1) {
-			        setAttributesYes(Convert.parseLong(xmlString.substring(start + 1, end)));
-
+				if (version == 1) {
+			        start = xmlString.indexOf('&quot;');
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+			        
 			        start = xmlString.indexOf('&quot;', end + 1);
 			        end = xmlString.indexOf('&quot;', start + 1);
-			        if (start &gt; -1 &amp;&amp; end &gt; -1)
-				        setAttributesNo(Convert.parseLong(xmlString.substring(start + 1, end)));
-		        }
-		        
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-	            
-	            start = xmlString.indexOf('&quot;', end + 1);
-	            end = xmlString.indexOf('&quot;', start + 1);
-	            if (version == 2) {
-	            	long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
-	            } else {
-	            	long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+			        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+			        
+			        // Assume coordinates are in decimal format
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
+			                notDecSep, decSep));
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
+			                notDecSep, decSep));
+			        pos = new CWPoint(lat, lon);
+			        LatLon = pos.toString();
+			        
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setDateHidden(xmlString.substring(start + 1, end));
+			        // Convert the US format to YYYY-MM-DD if necessary
+			        if (getDateHidden().indexOf('/') &gt; -1)
+				        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
+			        
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+			        
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setCacheStatus(xmlString.substring(start + 1, end));
+			        
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        try {
+			        	setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
+			        } catch (IllegalArgumentException ex) {
+			        	setType(CacheType.CW_TYPE_ERROR);
+			        	if (Global.getPref().debug) Global.getPref().log(wayPoint, ex, true);
+			        }
+		            
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        try {
+			        	setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+			        } catch (IllegalArgumentException ex) {
+			        	setHard(CacheTerrDiff.CW_DT_ERROR);
+			        	if (Global.getPref().debug) Global.getPref().log(wayPoint, ex, true);
+			        }
+	
+		            start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        try {
+			        	setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+			        } catch (IllegalArgumentException ex) {
+			        	setTerrain(CacheTerrDiff.CW_DT_ERROR);
+			        	if (Global.getPref().debug) Global.getPref().log(wayPoint, ex, true);
+			        }
+	
+			        // The next item was 'dirty' but this is no longer used.
+		            start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setFiltered(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        try {
+			        	setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
+			        } catch (IllegalArgumentException ex) {
+			        	setCacheSize(CacheSize.CW_SIZE_ERROR);
+			        	if (Global.getPref().debug) Global.getPref().log(wayPoint, ex, true);
+			        }
+			        
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setAvailable(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setArchived(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setHas_bugs(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setBlack(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+			        if (is_black() != Global.getProfile().showBlacklisted())
+				        setFiltered(true);
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setOwned(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setFound(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setNew(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setLog_updated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setUpdated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+			        // for backwards compatibility set value to true, if it is not in the file
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setHTML(!xmlString.substring(start + 1, end).equals(&quot;false&quot;));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+		            setNoFindLogs((byte)Convert.toInt(xmlString.substring(start + 1, end)));
+	
+		            start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setOcCacheID(xmlString.substring(start + 1, end));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;) || incomplete);
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setLastSyncOC(xmlString.substring(start + 1, end));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+			        recommendationScore = LogList.getScore(getNumRecommended(),
+			                getNumFoundsSinceRecommendation());
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            if (start &gt; -1 &amp;&amp; end &gt; -1) {
+			            setAttributesYes(Convert.parseLong(xmlString.substring(start + 1, end)));
+	
+	
+			        start = xmlString.indexOf('&quot;', end + 1);
+			        end = xmlString.indexOf('&quot;', start + 1);
+			            if (start &gt; -1 &amp;&amp; end &gt; -1)
+				            setAttributesNo(Convert.parseLong(xmlString.substring(start + 1, end)));
+		            }
+	            } else if (version == 3 || version == 2) {
+		            start = xmlString.indexOf('&quot;');
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+		            
+		            // Assume coordinates are in decimal format
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
+		                    notDecSep, decSep));
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
+		                    notDecSep, decSep));
+		            pos = new CWPoint(lat, lon);
+		            LatLon = pos.toString();
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setDateHidden(xmlString.substring(start + 1, end));
+		            // Convert the US format to YYYY-MM-DD if necessary
+		            if (getDateHidden().indexOf('/') &gt; -1)
+			            setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setCacheStatus(xmlString.substring(start + 1, end));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setOcCacheID(xmlString.substring(start + 1, end));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setLastSyncOC(xmlString.substring(start + 1, end));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+		            recommendationScore = LogList.getScore(getNumRecommended(),
+		                    getNumFoundsSinceRecommendation());
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+			        if (start &gt; -1 &amp;&amp; end &gt; -1) {
+				        setAttributesYes(Convert.parseLong(xmlString.substring(start + 1, end)));
+	
+				        start = xmlString.indexOf('&quot;', end + 1);
+				        end = xmlString.indexOf('&quot;', start + 1);
+				        if (start &gt; -1 &amp;&amp; end &gt; -1)
+					        setAttributesNo(Convert.parseLong(xmlString.substring(start + 1, end)));
+			        }
+			        
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+		            
+		            start = xmlString.indexOf('&quot;', end + 1);
+		            end = xmlString.indexOf('&quot;', start + 1);
+		            if (version == 2) {
+		            	long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
+		            } else {
+		            	long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+		            }
+		            
+		            if (is_black() != Global.getProfile().showBlacklisted())
+			            setFiltered(true);
 	            }
-	            
-	            if (is_black() != Global.getProfile().showBlacklisted())
-		            setFiltered(true);
-            }
 	        } catch (Exception ex) {
 	        	Global.getPref().log(&quot;Ignored Exception in CacheHolder()&quot;, ex, true);
 	        }
+	        
+	        if (type == CacheType.CW_TYPE_ERROR) {
+	        	setIncomplete(true);
+	        } else {
+	        	if (! isAddiWpt() &amp;&amp; 
+	        		(terrain == CacheTerrDiff.CW_DT_ERROR 
+	        		|| hard == CacheTerrDiff.CW_DT_ERROR 
+	        		|| cacheSize == CacheSize.CW_SIZE_ERROR)
+	        	) setIncomplete(true);
+	        }
         }
 	
 	/**
@@ -493,18 +487,10 @@
 		this.setAvailable(ch.is_available());
 		this.setOwned(ch.is_owned());
 		this.setFiltered(ch.is_filtered());
-//		this.setLog_updated(ch.is_log_updated());
-//		this.setUpdated(ch.is_updated());
 		this.setIncomplete(ch.is_incomplete());
 		this.setBlack(ch.is_black());
 		this.addiWpts = ch.addiWpts;
 		this.mainCache=ch.mainCache;
-//		this.setNew(ch.is_new());
-		// I don't think that updating a cache with current data should affect the state
-		// if a cache is checked or a search result. So the following two assignments are
-		// removed.
-//		this.is_flaged = ch.is_flaged;
-//		this.is_Checked = ch.is_Checked;
 		this.setOcCacheID(ch.getOcCacheID());
 		this.setNoFindLogs(ch.getNoFindLogs());
 		this.setHas_bugs(ch.has_bugs());
@@ -772,13 +758,6 @@
 		}
 	}
 
-	/*
-public void finalize() {nObjects--;
-   Vm.debug(&quot;Destroying CacheHolder &quot;+wayPoint);
-   Vm.debug(&quot;CacheHolder: &quot;+nObjects+&quot; objects left&quot;);
-}
-	 */
-	
 	public String GetStatusDate() {
 		String statusDate = &quot;&quot;;
 		
@@ -900,8 +879,8 @@
 	 * @return long value representing the byte field
 	 */
 	private long byteFields2long() {
-		long value = byteBitMask(CacheHolder.terrHard_String2byte(hard), 1)    | 
-		byteBitMask(CacheHolder.terrHard_String2byte(terrain), 2)   |
+		long value = byteBitMask(hard, 1)    | 
+		byteBitMask(terrain, 2)   |
 		byteBitMask(this.type, 3)    |
 		byteBitMask(cacheSize, 4)|
 		byteBitMask(this.noFindLogs, 5);		             
@@ -913,11 +892,14 @@
 	 * @param value The long value which contains up to 8 bytes.
 	 */
 	private void long2byteFields(long value) {
-		this.setHard(CacheHolder.terrHard_byte2String(byteFromLong(value, 1)));
-		this.setTerrain(CacheHolder.terrHard_byte2String(byteFromLong(value, 2)));
-		this.type = byteFromLong(value, 3);
-		this.setCacheSize(byteFromLong(value, 4));
-		this.setNoFindLogs((byteFromLong(value, 5)));
+		setHard(byteFromLong(value, 1));
+		setTerrain(byteFromLong(value, 2));
+		setType(byteFromLong(value, 3));
+		setCacheSize(byteFromLong(value, 4));
+		setNoFindLogs((byteFromLong(value, 5)));
+		if (getHard() == -1 || getTerrain() == 1 || getType() == -1 || getCacheSize() == -1 ) {
+			setIncomplete(true);
+		}
 	}
 	
 	/**
@@ -925,21 +907,22 @@
 	 * @param value
 	 */
 	private void long2byteFieldsv2(long value) {
-		setHard(CacheHolder.terrHard_byte2String(byteFromLong(value, 1)));
-		setTerrain(CacheHolder.terrHard_byte2String(byteFromLong(value, 2)));
+		setHard(byteFromLong(value, 1));
+		setTerrain(byteFromLong(value, 2));
 		try {
 			setType(CacheType.v2Converter(byteFromLong(value, 3)));
 		} catch (IllegalArgumentException ex) {
 			setType(CacheType.CW_TYPE_UNKNOWN);
-			setIncomplete(true);
 		}
 		try {
 			setCacheSize(byteFromLong(value, 4));
 		} catch (IllegalArgumentException ex) {
 			setCacheSize(CacheSize.CW_SIZE_ERROR);
-			setIncomplete(true);
 		}
 		setNoFindLogs((byteFromLong(value, 5)));
+		if (getHard() == -1 || getTerrain() == 1) {
+			setIncomplete(true);
+		}
 	}
 
 	/**
@@ -1105,95 +1088,25 @@
     	this.cacheSize = cacheSize;
     }
 
-	public String getHard() {
+	public byte getHard() {
     	return hard;
     }
 
-	public void setHard(String hard) {
-		Global.getProfile().notifyUnsavedChanges(!hard.equals(this.hard));		
+	public void setHard(byte hard) {
+		Global.getProfile().notifyUnsavedChanges(hard != this.hard);		
     	this.hard = hard;
     }
 
-	public String getTerrain() {
+	public byte getTerrain() {
     	return terrain;
     }
 
-	public void setTerrain(String terrain) {
-		Global.getProfile().notifyUnsavedChanges(!terrain.equals(this.terrain));		
+	public void setTerrain(byte terrain) {
+		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);		
     	this.terrain = terrain;
     }
 
 	/**
-	 * The string representation of the internal value for difficulty and terrain values.
-	 * @param value Difficulty or terrain voting as byte
-	 * @return String representation of the value
-	 */
-	private static String terrHard_byte2String(byte value) {
-		String result;
-		switch (value) {
-		case DT_EMPTY: result = DT_EMPTY_TXT; break;
-		case DT_10: result = DT_10_TXT; break;
-		case DT_15: result = DT_15_TXT; break;
-		case DT_20: result = DT_20_TXT; break;
-		case DT_25: result = DT_25_TXT; break;
-		case DT_30: result = DT_30_TXT; break;
-		case DT_35: result = DT_35_TXT; break;
-		case DT_40: result = DT_40_TXT; break;
-		case DT_45: result = DT_45_TXT; break;
-		case DT_50: result = DT_50_TXT; break;
-		default: result = DT_UNKNOWN_TXT;
-		} 
-		return result;
-	}
-
-	/**
-	 * Decoding the String represenations of difficulty or terrain values to internal (byte) values.
-	 * The format of the String values has to be like 1 ; 1.5 ; 3 ; 4.5&lt;br&gt;
-	 * Other formats won't be recognized.
-     * @param value String representation of the difficulty/terrain
-     * @return The internal byte value for the difficulty/terrain
-     */
-    private static byte terrHard_String2byte(String value) {
-	    byte result;
-	    if (value.equals(DT_EMPTY_TXT)) {
-			result = DT_EMPTY;
-		} else if (value.equals(DT_10_TXT)) {
-			result = DT_10;
-		} else if (value.equals(DT_15_TXT)) {
-			result = DT_15;
-		} else if (value.equals(DT_20_TXT)) {
-			result = DT_20;
-		} else if (value.equals(DT_25_TXT)) {
-			result = DT_25;
-		} else if (value.equals(DT_30_TXT)) {
-			result = DT_30;
-		} else if (value.equals(DT_35_TXT)) {
-			result = DT_35;
-		} else if (value.equals(DT_40_TXT)) {
-			result = DT_40;
-		} else if (value.equals(DT_45_TXT)) {
-			result = DT_45;
-		} else if (value.equals(DT_50_TXT)) {
-			result = DT_50;
-		} else {
-			result = DT_UNKNOWN;
-		}
-	    return result;
-    }
-
-	/**
-	 * Converting the OC format of difficulty values (1,0 ; 3,5) to GC format (1 ; 3.5). If the
-	 * format is already GC, then it is returned unchanged. 
-     * @param pValue String to convert
-     * @return Converted String
-     */
-    public static String terrHard_OC2GC(String pValue) {
-	    String value = pValue.replace(',', '.');
-	    if (value.endsWith(&quot;.0&quot;)) value = value.substring(0,1);
-	    return value;
-    }
- 
-	/**
 	 * Gets the type of cache as integer.
 	 * @return Cache type
 	 */
@@ -1436,7 +1349,6 @@
 		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);		
 		this.hasNote = hasNote;
 	}
-	
 
 }
 

Added: trunk/src/CacheWolf/CacheTerrDiff.java
===================================================================
--- trunk/src/CacheWolf/CacheTerrDiff.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/CacheTerrDiff.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -0,0 +1,105 @@
+package CacheWolf;
+
+/**
+ * Handles all aspects of converting terrain and difficulty
+ * infromations from legacy file versions and various im-
+ * and expoters
+ * 
+ * Only use the class in a static way, do not instantiate it
+ */
+public class CacheTerrDiff {
+	
+	/** terrain or difficulty 1.0 */
+	protected static final byte CW_DT_10 = 10;
+	/** terrain or difficulty 1.5 */
+	protected static final byte CW_DT_15 = 15;
+	/** terrain or difficulty 2.0 */
+	protected static final byte CW_DT_20 = 20;
+	/** terrain or difficulty 2.5 */
+	protected static final byte CW_DT_25 = 25;
+	/** terrain or difficulty 3.0 */
+	protected static final byte CW_DT_30 = 30;
+	/** terrain or difficulty 3.5 */
+	protected static final byte CW_DT_35 = 35;
+	/** terrain or difficulty 4.0 */
+	protected static final byte CW_DT_40 = 40;
+	/** terrain or difficulty 4.5 */
+	protected static final byte CW_DT_45 = 45;
+	/** terrain or difficulty 5.0 */
+	protected static final byte CW_DT_50 = 50;
+	/** wrong terrain or difficulty */
+	protected static final byte CW_DT_ERROR = -1;
+
+	/** constructor dies nothing */
+	public CacheTerrDiff() {
+	}
+	
+	/**
+	 * convert &quot;old style&quot; terran and difficulty information to the new format.
+	 * 
+	 * since it is also used by the importes it is not flagged as deprecated
+	 * @param v1TerrDiff a string representation of terrain or difficulty
+	 * @return internal representation of terrain or difficulty
+	 * @throws IllegalArgumentException if &lt;code&gt;v1TerrDiff&lt;/code&gt; can not be mapped
+	 */
+	static final byte v1Converter(String v1TerrDiff) throws IllegalArgumentException {
+		if (v1TerrDiff == null) {
+			throw new IllegalArgumentException(&quot;error mapping terrain or difficulty&quot;);
+		}
+		v1TerrDiff = v1TerrDiff.replace(',', '.');
+		if (v1TerrDiff.equals(&quot;1&quot;) || v1TerrDiff.equals(&quot;1.0&quot;)) return CW_DT_10;
+		if (v1TerrDiff.equals(&quot;2&quot;) || v1TerrDiff.equals(&quot;2.0&quot;)) return CW_DT_20;
+		if (v1TerrDiff.equals(&quot;3&quot;) || v1TerrDiff.equals(&quot;3.0&quot;)) return CW_DT_30;
+		if (v1TerrDiff.equals(&quot;4&quot;) || v1TerrDiff.equals(&quot;4.0&quot;)) return CW_DT_40;
+		if (v1TerrDiff.equals(&quot;5&quot;) || v1TerrDiff.equals(&quot;5.0&quot;)) return CW_DT_50;
+		
+		if (v1TerrDiff.equals(&quot;1.5&quot;)) return CW_DT_15;
+		if (v1TerrDiff.equals(&quot;2.5&quot;)) return CW_DT_25;
+		if (v1TerrDiff.equals(&quot;3.5&quot;)) return CW_DT_35;
+		if (v1TerrDiff.equals(&quot;4.5&quot;)) return CW_DT_45;
+		
+		throw new IllegalArgumentException(&quot;error mapping terrain or difficulty&quot;);
+	}
+	
+	/**
+	 * generate strings of terrain and difficulty for general use
+	 * @param td internal terrain or difficulty value
+	 * @return long version of terrain or difficulty (includeing .0)
+	 * @throws IllegalArgumentException
+	 */
+	public static final String longDT(byte td) throws IllegalArgumentException {
+		switch(td) {
+		case CW_DT_10: return &quot;1.0&quot;;
+		case CW_DT_15: return &quot;1.5&quot;;
+		case CW_DT_20: return &quot;2.0&quot;;
+		case CW_DT_25: return &quot;2.5&quot;;
+		case CW_DT_30: return &quot;3.0&quot;;
+		case CW_DT_35: return &quot;3.5&quot;;
+		case CW_DT_40: return &quot;4.0&quot;;
+		case CW_DT_45: return &quot;4.5&quot;;
+		case CW_DT_50: return &quot;5.0&quot;;
+		default: throw new IllegalArgumentException(&quot;unmapped terrain or diffulty &quot;+td);
+		}
+	}
+
+	/**
+	 * generate strings of terrain and difficulty information for GC.com-like GPX exports
+	 * @param td internal terrain or difficulty value
+	 * @return short version of terrainor difficulty (omit .0)
+	 * @throws IllegalArgumentException
+	 */
+	public static final String shortDT(byte td) throws IllegalArgumentException {
+		switch(td) {
+		case CW_DT_10: return &quot;1&quot;;
+		case CW_DT_15: return &quot;1.5&quot;;
+		case CW_DT_20: return &quot;2&quot;;
+		case CW_DT_25: return &quot;2.5&quot;;
+		case CW_DT_30: return &quot;3&quot;;
+		case CW_DT_35: return &quot;3.5&quot;;
+		case CW_DT_40: return &quot;4&quot;;
+		case CW_DT_45: return &quot;4.5&quot;;
+		case CW_DT_50: return &quot;5&quot;;
+		default: throw new IllegalArgumentException(&quot;unmapped terrain or diffulty &quot;+td);
+		}
+	}
+}

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/DetailsPanel.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -213,8 +213,10 @@
 		chcSize.setInt(ch.getCacheSize());
 
 		attV.showImages(ch.getCacheDetails(true).attributes);
-		lblTerr.setText((ch.getTerrain().length()&gt;0) ? (MyLocale.getMsg(1001,&quot;T&quot;)+&quot;: &quot;+ch.getTerrain()) : &quot;&quot;);
-		lblDiff.setText((ch.getHard().length()&gt;0)    ? (MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: &quot;+ch.getHard()) : &quot;&quot;); 
+		lblTerr.setText((ch.getTerrain() != CacheTerrDiff.CW_DT_ERROR) ? 
+				(MyLocale.getMsg(1001,&quot;T&quot;)+&quot;: &quot;+CacheTerrDiff.longDT(ch.getTerrain())) : &quot;&quot;);
+		lblDiff.setText((ch.getHard() != CacheTerrDiff.CW_DT_ERROR) ? 
+				(MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: &quot;+CacheTerrDiff.longDT(ch.getHard())) : &quot;&quot;); 
 
 		if(isBigScreen)	mNotes.setText(ch.getExistingDetails().getCacheNotes());
 	}

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/Filter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -485,7 +485,7 @@
 	        // Filter criterium 4: Difficulty
 	        ///////////////////////////////
 	        if (fscDiff &gt; 0.0) {
-		        dummyd1 = Common.parseDouble(ch.getHard());
+		        dummyd1 = ch.getHard() / 10D;
 		        if (diffdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDiff) {
 			        cacheFiltered = true; break;
 		        }
@@ -500,7 +500,7 @@
 	        // Filter criterium 5: Terrain
 	        ///////////////////////////////
 	        if (fscTerr &gt; 0.0) {
-		        dummyd1 = Common.parseDouble(ch.getTerrain());
+	        	dummyd1 = ch.getTerrain() / 10D;
 		        if (terrdirec == SMALLER &amp;&amp; dummyd1 &gt; fscTerr) {
 			        cacheFiltered = true; break;
 		        }
@@ -511,11 +511,7 @@
 			        cacheFiltered = true; break;
 		        }
 	        }
-	        //Vm.debug(ch.wayPoint+&quot; Found&quot;+ch.is_found+&quot;  FoundyMe=&quot;+foundByMe+&quot;   notFoundByMe=&quot;+notFoundByMe);
-	        //Vm.debug(ch.wayPoint+&quot; Owned&quot;+ch.is_owned+&quot;  OwnedByMe=&quot;+ownedByMe+&quot;   notOwnedByMe=&quot;+notOwnedByMe);
-	        //Vm.debug(ch.wayPoint+&quot; Archived&quot;+ch.is_archived+&quot;  Archived=&quot;+archived+&quot;   notArchived=&quot;+notArchived);
-	        //Vm.debug(ch.wayPoint+&quot; Available&quot;+ch.is_available+&quot;  Available=&quot;+available+&quot;   notAvailable=&quot;+notAvailable);
-	        //Vm.debug(&quot;Blacklisted: &quot;+ch.is_black);
+
 	        ///////////////////////////////
 	        // Filter criterium 6: Found by me
 	        ///////////////////////////////

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -400,11 +400,11 @@
 			return;
 		}
 		if (name.equals(&quot;groundspeak:difficulty&quot;) || name.equals(&quot;difficulty&quot;) || name.equals(&quot;terra:mental_challenge&quot;)) {
-			holder.setHard(strData);
+			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
 		if (name.equals(&quot;groundspeak:terrain&quot;)|| name.equals(&quot;terrain&quot;)|| name.equals(&quot;terra:physical_challenge&quot;)) {
-			holder.setTerrain(strData);
+			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
 		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/MyComparer.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -25,12 +25,12 @@
 		} else if (colToCompare==2) {
 			for (int i=0; i&lt;visibleSize; i++) {
 				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getHard();
+				ch.sort=CacheTerrDiff.longDT(ch.getHard());
 			}
 		} else if (colToCompare==3) {
 			for (int i=0; i&lt;visibleSize; i++) {
 				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getTerrain();
+				ch.sort=CacheTerrDiff.longDT(ch.getTerrain());
 			}
 		} else if (colToCompare==4) {
 			for (int i=0; i&lt;visibleSize; i++) {

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -483,11 +483,11 @@
 			return;
 		}
 		if(name.equals(&quot;difficulty&quot;)) {
-			holder.setHard(CacheHolder.terrHard_OC2GC(strData));
+			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
 		if(name.equals(&quot;terrain&quot;)) {
-			holder.setTerrain(CacheHolder.terrHard_OC2GC(strData));
+			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
 		if(name.equals(&quot;datehidden&quot;)) {

Modified: trunk/src/CacheWolf/ShowCacheInBrowser.java
===================================================================
--- trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -73,10 +73,8 @@
 					tpl.setParam(&quot;WAYPOINT&quot;, chD.getWayPoint());
 					tpl.setParam(&quot;CACHE_NAME&quot;, chD.getCacheName());
 					tpl.setParam(&quot;OWNER&quot;, chD.getCacheOwner());
-					if (chD.getHard().endsWith(&quot;.0&quot;)) chD.setHard(chD.getHard().substring(0,chD.getHard().length()-2));
-					tpl.setParam(&quot;DIFFICULTY&quot;, (String) diff.get(chD.getHard().replace(',','.')));
-					if (chD.getTerrain().endsWith(&quot;.0&quot;)) chD.setTerrain(chD.getTerrain().substring(0,chD.getTerrain().length()-2));
-					tpl.setParam(&quot;TERRAIN&quot;, (String) terr.get(chD.getTerrain().replace(',','.')));
+					tpl.setParam(&quot;DIFFICULTY&quot;, CacheTerrDiff.longDT(chD.getHard()));
+					tpl.setParam(&quot;TERRAIN&quot;, CacheTerrDiff.longDT(chD.getTerrain()));
 					tpl.setParam(&quot;DISTANCE&quot;, chD.getDistance().replace(',','.'));
 					tpl.setParam(&quot;BEARING&quot;, chD.bearing);
 					if (chD.pos!=null &amp;&amp; chD.pos.isValid()) {

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -728,12 +728,12 @@
 						else pref.log(&quot;Got size&quot;);
 
 						pref.log(&quot;Trying difficulty&quot;);
-						ch.setHard(getDiff(completeWebPage));
+						ch.setHard(CacheTerrDiff.v1Converter(getDiff(completeWebPage)));
 						if (pref.debug) pref.log(&quot;Hard: &quot; + ch.getHard());
 						else pref.log(&quot;Got difficulty&quot;);
 
 						pref.log(&quot;Trying terrain&quot;);
-						ch.setTerrain(getTerr(completeWebPage));
+						ch.setTerrain(CacheTerrDiff.v1Converter(getTerr(completeWebPage)));
 						if (pref.debug) pref.log(&quot;Terr: &quot; + ch.getTerrain());
 						else pref.log(&quot;Got terrain&quot;);
 

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/CacheWolf/myTableModel.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -293,9 +293,9 @@
 					case 1: // Type
 						return GuiImageBroker.getTypeImage(ch.getType());
 					case 2: // Difficulty;
-						return ch.getHard();
+						return CacheTerrDiff.longDT(ch.getHard());
 					case 3: // Terrain
-						return ch.getTerrain();
+						return CacheTerrDiff.longDT(ch.getTerrain());
 					case 4: // Waypoint
 						if (showExtraWptInfo) {
 							if(ch.is_incomplete()) return ch.getIconAndTextWP(4, fm);

Modified: trunk/src/exp/ExploristExporter.java
===================================================================
--- trunk/src/exp/ExploristExporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/exp/ExploristExporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -263,9 +263,9 @@
 		
 		sb.append(toGsDateFormat(lastFound)); // lastFound - DDMMYYY, YYY = year - 1900
 		sb.append(&quot;,&quot;);
-		sb.append(removeCommas(ch.getHard()));
+		sb.append(CacheTerrDiff.longDT(ch.getHard()));
 		sb.append(&quot;,&quot;);
-		sb.append(removeCommas(ch.getTerrain()));
+		sb.append(CacheTerrDiff.longDT(ch.getTerrain()));
 		sb.append(&quot;*41&quot;);
 		return Exporter.simplifyString(sb.toString() + &quot;\r\n&quot;);
 	}

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/exp/Exporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -413,17 +413,9 @@
     	StringBuffer strBuf = new StringBuffer(7);
     	strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());			
     	if (!ch.isAddiWpt()) {
-    		if ( (ch.getHard().length() &gt; 0) &amp;&amp; (ch.getTerrain().length() &gt; 0) ) {
-    			strBuf.append(ch.getHard().charAt(0));
-    			if ( ch.getHard().endsWith(&quot;.5&quot;) ) {
-    				strBuf.append(&quot;5&quot;);
-    			}
-    			strBuf.append(&quot;/&quot;);
-    			strBuf.append(ch.getTerrain().charAt(0));
-    			if ( ch.getTerrain().endsWith(&quot;.5&quot;) ) {
-    				strBuf.append(&quot;5&quot;);
-    			}
-    		}
+   			strBuf.append(ch.getHard());
+   			strBuf.append(&quot;/&quot;);
+   			strBuf.append(ch.getTerrain());
     		strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
     	}
 

Modified: trunk/src/exp/GPXExporter.java
===================================================================
--- trunk/src/exp/GPXExporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/exp/GPXExporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -82,15 +82,10 @@
 				strBuf.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.id2GpxString(ch.getType())).append(&quot;&lt;/groundspeak:type&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(CacheSize.cw2ExportString(ch.getCacheSize())).append(&quot;&lt;/groundspeak:container&gt;\r\n&quot;);
 				//for Colorado/Oregon: 2.0 -&gt; 2
-				String diffTerr = ch.getHard().replace(',','.');
-				if ( diffTerr.endsWith( &quot;.0&quot; ) ) {
-					diffTerr = diffTerr.substring(0, 1);
-				}
+				String diffTerr = CacheTerrDiff.shortDT(ch.getHard());
+				
 				strBuf.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;).append(diffTerr).append(&quot;&lt;/groundspeak:difficulty&gt;\r\n&quot;);
-				diffTerr = ch.getTerrain().replace(',','.');
-				if ( diffTerr.endsWith( &quot;.0&quot; ) ) {
-					diffTerr = diffTerr.substring(0, 1);
-				}
+				diffTerr = CacheTerrDiff.shortDT(ch.getTerrain());
 				strBuf.append(&quot;      &lt;groundspeak:terrain&gt;&quot;).append(diffTerr).append(&quot;&lt;/groundspeak:terrain&gt;\r\n&quot;);
 				
 				strBuf.append(&quot;      &lt;groundspeak:country&gt;&quot;).append(SafeXML.cleanGPX(det.Country)+&quot;&lt;/groundspeak:country&gt;\r\n&quot;);

Modified: trunk/src/exp/HTMLExporter.java
===================================================================
--- trunk/src/exp/HTMLExporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/exp/HTMLExporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -89,8 +89,8 @@
 					varParams.put(&quot;WAYPOINT&quot;, ch.getWayPoint());
 					varParams.put(&quot;NAME&quot;, ch.getCacheName());
 					varParams.put(&quot;OWNER&quot;, ch.getCacheOwner());
-					varParams.put(&quot;DIFFICULTY&quot;, ch.getHard());
-					varParams.put(&quot;TERRAIN&quot;, ch.getTerrain());
+					varParams.put(&quot;DIFFICULTY&quot;, CacheTerrDiff.longDT(ch.getHard()));
+					varParams.put(&quot;TERRAIN&quot;, CacheTerrDiff.longDT(ch.getTerrain()));
 					varParams.put(&quot;DISTANCE&quot;, ch.getDistance());
 					varParams.put(&quot;BEARING&quot;, ch.bearing);
 					varParams.put(&quot;LATLON&quot;, ch.LatLon);

Modified: trunk/src/exp/TPLExporter.java
===================================================================
--- trunk/src/exp/TPLExporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/exp/TPLExporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -202,8 +202,8 @@
 						varParams.put(&quot;SHORTSIZE&quot;, CacheSize.getExportShortId(ch.getCacheSize()));
 						varParams.put(&quot;WAYPOINT&quot;, ch.getWayPoint());
 						varParams.put(&quot;OWNER&quot;, ch.getCacheOwner());
-						varParams.put(&quot;DIFFICULTY&quot;, dec.replaceAll(ch.getHard()));
-						varParams.put(&quot;TERRAIN&quot;, dec.replaceAll(ch.getTerrain()));
+						varParams.put(&quot;DIFFICULTY&quot;, String.valueOf(ch.getHard()));
+						varParams.put(&quot;TERRAIN&quot;, String.valueOf(ch.getTerrain()));
 						varParams.put(&quot;DISTANCE&quot;, dec.replaceAll(ch.getDistance()));
 						varParams.put(&quot;BEARING&quot;, ch.bearing);
 						varParams.put(&quot;LATLON&quot;, ch.LatLon);

Modified: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2009-05-18 20:16:57 UTC (rev 1826)
+++ trunk/src/exp/TomTomExporter.java	2009-05-18 22:07:35 UTC (rev 1827)
@@ -183,9 +183,9 @@
 			outp.writeBytes(&quot; by &quot;);
 			outp.writeBytes(ch.getCacheOwner());
 			outp.writeBytes(&quot;- &quot;);             
-			outp.writeBytes(ch.getHard());
+			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes(&quot;/&quot;);
-			outp.writeBytes(ch.getTerrain());
+			outp.writeBytes(String.valueOf(ch.getTerrain()));
 			outp.writeBytes(&quot; - &quot;);
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			outp.writeBytes(&quot;\&quot;\r\n&quot;);
@@ -203,7 +203,7 @@
 		try {
 			d = 2;
 			outp.writeByte((byte)d);
-			data = ch.getWayPoint().length()+ch.getCacheName().length()+ch.getCacheOwner().length()+ch.getHard().length()+ch.getTerrain().length()+CacheSize.cw2ExportString(ch.getCacheSize()).length()+27;
+			data = ch.getWayPoint().length()+ch.getCacheName().length()+ch.getCacheOwner().length()+String.valueOf(ch.getHard()).length()+String.valueOf(ch.getTerrain()).length()+CacheSize.cw2ExportString(ch.getCacheSize()).length()+27;
 			writeIntBinary(outp, data);
 			latlon = Common.parseDouble(lon);
 			latlon *=100000;
@@ -221,9 +221,9 @@
 			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
 			//wider um 1 erh&#246;hen
 			outp.writeBytes(&quot;- &quot;);             
-			outp.writeBytes(ch.getHard());
+			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes(&quot;/&quot;);
-			outp.writeBytes(ch.getTerrain());
+			outp.writeBytes(String.valueOf(ch.getTerrain()));
 			outp.writeBytes(&quot; - &quot;);
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			d = 0;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001744.html">[Cachewolf-svn] r1826 - trunk/res_noewe
</A></li>
	<LI>Next message: <A HREF="001746.html">[Cachewolf-svn] r1828 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1745">[ date ]</a>
              <a href="thread.html#1745">[ thread ]</a>
              <a href="subject.html#1745">[ subject ]</a>
              <a href="author.html#1745">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
