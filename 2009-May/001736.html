<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1818 - in trunk: . resources src/CacheWolf	src/CacheWolf/navi src/exp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1818%20-%20in%20trunk%3A%20.%20resources%20src/CacheWolf%0A%09src/CacheWolf/navi%20src/exp&In-Reply-To=%3C200905171911.n4HJB8FZ014578%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001735.html">
   <LINK REL="Next"  HREF="001737.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1818 - in trunk: . resources src/CacheWolf	src/CacheWolf/navi src/exp</H1>
    <B>greiol at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1818%20-%20in%20trunk%3A%20.%20resources%20src/CacheWolf%0A%09src/CacheWolf/navi%20src/exp&In-Reply-To=%3C200905171911.n4HJB8FZ014578%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1818 - in trunk: . resources src/CacheWolf	src/CacheWolf/navi src/exp">greiol at mail.berlios.de
       </A><BR>
    <I>Sun May 17 21:11:08 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001735.html">[Cachewolf-svn] r1817 - experiments/greiol/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="001737.html">[Cachewolf-svn] r1819 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1736">[ date ]</a>
              <a href="thread.html#1736">[ thread ]</a>
              <a href="subject.html#1736">[ subject ]</a>
              <a href="author.html#1736">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: greiol
Date: 2009-05-17 21:10:50 +0200 (Sun, 17 May 2009)
New Revision: 1818

Added:
   trunk/resources/typeApe.png
   trunk/resources/typeMaze.png
   trunk/src/CacheWolf/GuiImageBroker.java
Modified:
   trunk/build.xml
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/CacheSize.java
   trunk/src/CacheWolf/CacheType.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/ShowCacheInBrowser.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myInteractivePanel.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/exp/ExploristExporter.java
   trunk/src/exp/Exporter.java
   trunk/src/exp/GPXExporter.java
   trunk/src/exp/HTMLExporter.java
   trunk/src/exp/KMLExporter.java
   trunk/src/exp/MSARCSVExporter.java
   trunk/src/exp/TPLExporter.java
   trunk/src/exp/TomTomExporter.java
Log:
mergend in new CacheType class
some expoters still do have known issues

Modified: trunk/build.xml
===================================================================
--- trunk/build.xml	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/build.xml	2009-05-17 19:10:50 UTC (rev 1818)
@@ -55,7 +55,7 @@
 	&lt;property name=&quot;assemble.dir&quot; value=&quot;assemble&quot;/&gt;
 
 	&lt;!-- lists of files to be packaged, this should become less confusing later on --&gt;
-	&lt;property name=&quot;template.files&quot; value=&quot;*/*.tpl&quot;/&gt;
+	&lt;property name=&quot;template.files&quot; value=&quot;*.tpl&quot;/&gt;
 	&lt;property name=&quot;icons.gui.files&quot; value=&quot;dnf.gif,bug.gif,red.png,yellow.png,blue.png&quot;/&gt;
 	&lt;property name=&quot;icons.log.files&quot; value=&quot;traffic_cone.gif,recommendedlog.gif,icon_smile.gif,icon_sad.gif,icon_rsvp.gif,icon_note.gif,icon_needsmaint.gif,icon_maint.gif,icon_enabled.gif,icon_disabled.gif,icon_camera.gif,icon_attended.gif,big_smile.gif,coord_update.gif,icon_greenlight.gif,icon_redlight.gif&quot;/&gt;
 	&lt;property name=&quot;icons.cache.files&quot; value=&quot;11.gif,8.gif,6.gif,5.gif,4.gif,3.gif,2.gif,1858.gif,13.gif,137.gif,12.gif&quot;/&gt;
@@ -239,54 +239,54 @@
 
 	&lt;target name=&quot;copyres&quot; description=&quot;copy images to the assembly directory&quot;&gt;
 		&lt;!-- copy templates --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe&quot;&gt;
 				&lt;include name=&quot;${template.files}&quot;/&gt;
 			&lt;/fileset&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy gui icons --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe&quot; includes=&quot;${icons.gui.files}&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy browser icons --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe&quot; includes=&quot;${icons.browser.files}&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy cache icons --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe&quot; includes=&quot;${icons.cache.files}&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy log icons --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe&quot; includes=&quot;${icons.log.files}&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy webmapservices --&gt;
-		&lt;copy todir=&quot;${assemble.dir}/webmapservices&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}/webmapservices&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe/webmapservices&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy languages --&gt;
-		&lt;copy todir=&quot;${assemble.dir}/languages&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}/languages&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe/languages&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy attributes --&gt;
-		&lt;copy todir=&quot;${assemble.dir}/attributes&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}/attributes&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;resources/attributes&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy addons --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe&quot;&gt;
 				&lt;include name=&quot;Garmin*.zip&quot;/&gt;
 				&lt;include name=&quot;POI*.zip&quot;/&gt;
 			&lt;/fileset&gt;
 		&lt;/copy&gt;
 		&lt;!-- copy logo --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot; file=&quot;resources/CacheWolf.ico&quot;/&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; file=&quot;resources/CacheWolf.ico&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;/&gt;
 		&lt;!-- copy documentation --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot;&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;&gt;
 			&lt;fileset dir=&quot;res_noewe&quot; includes=&quot;${doc.files}&quot;/&gt;
 		&lt;/copy&gt;
 		&lt;!-- spider.def --&gt;
-		&lt;copy todir=&quot;${assemble.dir}&quot; file=&quot;res_noewe/spider.def&quot;/&gt;
+		&lt;copy todir=&quot;${assemble.dir}&quot; file=&quot;res_noewe/spider.def&quot; failonerror=&quot;true&quot; verbose=&quot;true&quot;/&gt;
 	&lt;/target&gt;
 
 	&lt;target name=&quot;compilecabhelper&quot; description=&quot;helper classes for building cabs&quot; if=&quot;build.cab&quot;&gt;

Copied: trunk/resources/typeApe.png (from rev 1817, experiments/greiol/resources/typeApe.png)

Copied: trunk/resources/typeMaze.png (from rev 1817, experiments/greiol/resources/typeMaze.png)

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/CacheHolder.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -65,7 +65,7 @@
 	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
 	private byte cacheSize = CacheSize.CW_SIZE_NOTCHOSEN;
 	/** The distance from the centre in km */
-	public double kilom = -1; int bla = 0;
+	public double kilom = -1;
 	public double lastKilom = -2; // Cache last value
 	public int lastMetric = -1; // Cache last metric
 	public String lastDistance = &quot;&quot;; // Cache last distance
@@ -78,7 +78,7 @@
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
 	private String terrain = EMPTY;
 	/** The cache type (@see CacheType for translation table)  */
-	private byte type = -128; 
+	private byte type = CacheType.CW_TYPE_ERROR; 
 	/** True if the cache has been archived */
 	private boolean archived = false;
 	/** True if the cache is available for searching */
@@ -164,9 +164,11 @@
 		        start = xmlString.indexOf('&quot;');
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+		        
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+		        
 		        // Assume coordinates are in decimal format
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
@@ -178,94 +180,130 @@
 		                notDecSep, decSep));
 		        pos = new CWPoint(lat, lon);
 		        LatLon = pos.toString();
+		        
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setDateHidden(xmlString.substring(start + 1, end));
 		        // Convert the US format to YYYY-MM-DD if necessary
 		        if (getDateHidden().indexOf('/') &gt; -1)
 			        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
+		        
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+		        
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setCacheStatus(xmlString.substring(start + 1, end));
+		        
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
-	            setType(Integer.parseInt(xmlString.substring(start + 1, end)));
+		        try {
+		        	setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
+		        } catch (IllegalArgumentException ex) {
+		        	setType(CacheType.CW_TYPE_ERROR);
+		        	Global.getPref().log(wayPoint, ex, true);
+		        	setIncomplete(true);
+		        }
+	            
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 	            setHard(CacheHolder.terrHard_OC2GC(xmlString.substring(start + 1, end)));
-		        start = xmlString.indexOf('&quot;', end + 1);
+
+	            start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 	            setTerrain(CacheHolder.terrHard_OC2GC(xmlString.substring(start + 1, end)));
 		        // The next item was 'dirty' but this is no longer used.
-		        start = xmlString.indexOf('&quot;', end + 1);
+
+	            start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setFiltered(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
+		        try {
+		        	setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
+		        } catch (IllegalArgumentException ex) {
+		        	setCacheSize(CacheSize.CW_SIZE_ERROR);
+		        	Global.getPref().log(wayPoint, ex, true);
+		        	setIncomplete(true);
+		        }
 		        
-		        setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
-		        
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setAvailable(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setArchived(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setHas_bugs(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setBlack(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
 		        if (is_black() != Global.getProfile().showBlacklisted())
 			        setFiltered(true);
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setOwned(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setFound(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setNew(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setLog_updated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setUpdated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
 		        // for backwards compatibility set value to true, if it is not in the file
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setHTML(!xmlString.substring(start + 1, end).equals(&quot;false&quot;));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 	            setNoFindLogs((byte)Convert.toInt(xmlString.substring(start + 1, end)));
-		        start = xmlString.indexOf('&quot;', end + 1);
+
+	            start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setOcCacheID(xmlString.substring(start + 1, end));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
-		        setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+		        setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;) || incomplete);
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setLastSyncOC(xmlString.substring(start + 1, end));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
 		        recommendationScore = LogList.getScore(getNumRecommended(),
 		                getNumFoundsSinceRecommendation());
-	            start = xmlString.indexOf('&quot;', end + 1);
+
+		        start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            if (start &gt; -1 &amp;&amp; end &gt; -1) {
 		            setAttributesYes(Convert.parseLong(xmlString.substring(start + 1, end)));
 
+
 		        start = xmlString.indexOf('&quot;', end + 1);
 		        end = xmlString.indexOf('&quot;', start + 1);
 		            if (start &gt; -1 &amp;&amp; end &gt; -1)
@@ -275,9 +313,11 @@
 	            start = xmlString.indexOf('&quot;');
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+	            
 	            // Assume coordinates are in decimal format
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
@@ -289,32 +329,40 @@
 	                    notDecSep, decSep));
 	            pos = new CWPoint(lat, lon);
 	            LatLon = pos.toString();
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setDateHidden(xmlString.substring(start + 1, end));
 	            // Convert the US format to YYYY-MM-DD if necessary
 	            if (getDateHidden().indexOf('/') &gt; -1)
 		            setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setCacheStatus(xmlString.substring(start + 1, end));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setOcCacheID(xmlString.substring(start + 1, end));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setLastSyncOC(xmlString.substring(start + 1, end));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 	            setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
 	            recommendationScore = LogList.getScore(getNumRecommended(),
 	                    getNumFoundsSinceRecommendation());
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
 		        if (start &gt; -1 &amp;&amp; end &gt; -1) {
@@ -325,12 +373,15 @@
 			        if (start &gt; -1 &amp;&amp; end &gt; -1)
 				        setAttributesNo(Convert.parseLong(xmlString.substring(start + 1, end)));
 		        }
+		        
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
-	            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));	            
+	            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+	            
 	            start = xmlString.indexOf('&quot;', end + 1);
 	            end = xmlString.indexOf('&quot;', start + 1);
-	            this.long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));	            
+	            this.long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));	  
+	            
 	            if (is_black() != Global.getProfile().showBlacklisted())
 		            setFiltered(true);
             }
@@ -1116,8 +1167,8 @@
 	 * Gets the type of cache as integer.
 	 * @return Cache type
 	 */
-	public int getType() {
-		return CacheType.toInt(type);
+	public byte getType() {
+		return type;
     }
 
 	/**
@@ -1125,8 +1176,8 @@
 	 * and byte internally of CacheHolder, some conversion has to be done.
 	 * @param type Cache Type
 	 */
-	public void setType(int type) {
-		byte newType = CacheType.toByte(type);
+	public void setType(byte type) {
+		byte newType = type;
 		Global.getProfile().notifyUnsavedChanges(newType != this.type);		
     	this.type = newType;
     }

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/CacheList.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -92,7 +92,7 @@
 				 CacheHolder ch=cacheList.get(idx);
 				 wayPoint=ch.getWayPoint();
 				 IconAndText imgDrag=new IconAndText();
-				 imgDrag.addColumn(CacheType.cache2Img(ch.getType()));
+				 imgDrag.addColumn(GuiImageBroker.getTypeImage(ch.getType()));
 				 imgDrag.addColumn(ch.getWayPoint());
 				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
 			 } 
@@ -313,7 +313,7 @@
 			// Add cache reference to hidden list
 			cacheList.add(ch);
 			// Add Cache and cache icon to visible list
-			lstCaches.addItem((new MenuItem()).iconize(ch.getWayPoint()+&quot;   &quot;+ch.getCacheName(),CacheType.cache2Img(ch.getType()),true));
+			lstCaches.addItem((new MenuItem()).iconize(ch.getWayPoint()+&quot;   &quot;+ch.getCacheName(),GuiImageBroker.getTypeImage(ch.getType()),true));
 		    dirty=true;
 			return true;
 		} else

Modified: trunk/src/CacheWolf/CacheSize.java
===================================================================
--- trunk/src/CacheWolf/CacheSize.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/CacheSize.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -1,100 +1,116 @@
 package CacheWolf;
 
+/**
+ * Handels all aspects of converting cache size information from
+ * and to the various im- and exporters as well as for converting
+ * legavy profiles to current standard
+ */
 public final class CacheSize {
 
 	/*
 	 * internal representation of cache sizes in CacheHolder we just made them
 	 * up ;-)
 	 */
-	static final protected byte CW_SIZE_NOTCHOSEN = 0;
-	static final protected byte CW_SIZE_OTHER = 1;
-	static final protected byte CW_SIZE_MICRO = 2;
-	static final protected byte CW_SIZE_SMALL = 3;
-	static final protected byte CW_SIZE_REGULAR = 4;
-	static final protected byte CW_SIZE_LARGE = 5;
-	static final protected byte CW_SIZE_VERYLARGE = 6;
-	static final protected byte CW_SIZE_NONE = 7;
-	static final protected byte CW_SIZE_VIRTUAL = 8;
+	/** container size not chosen */
+	public static final byte CW_SIZE_NOTCHOSEN = 0;
+	/** container size other */
+	public static final byte CW_SIZE_OTHER = 1;
+	/** container size micro */
+	public static final byte CW_SIZE_MICRO = 2;
+	/* container size small */
+	public static final byte CW_SIZE_SMALL = 3;
+	/** container size regular */
+	public static final byte CW_SIZE_REGULAR = 4;
+	/** container size large */
+	public static final byte CW_SIZE_LARGE = 5;
+	/** container size very large */
+	public static final byte CW_SIZE_VERYLARGE = 6;
+	/** container size none */
+	public static final byte CW_SIZE_NONE = 7;
+	/** container size virtual */
+	public static final byte CW_SIZE_VIRTUAL = 8;
+	/** unparsable size or missing size information should throw IllegalArgumentExceptions when found */
+	public static final byte CW_SIZE_ERROR = -1;
 
 	/*
-	 * geocaching.com size string as found by analyzing GPX files plus OC/TC
-	 * Very large
+	 * geocaching.com size strings as found by analyzing GPX files 
+	 * plus opencaching &amp; terracaching Very large + none
 	 */
-	static final protected String GC_SIZE_MICRO = &quot;Micro&quot;;
-	static final protected String GC_SIZE_SMALL = &quot;Small&quot;;
-	static final protected String GC_SIZE_REGULAR = &quot;Regular&quot;;
-	static final protected String GC_SIZE_LARGE = &quot;Large&quot;;
-	static final protected String GC_SIZE_NOTCHOSEN = &quot;Not chosen&quot;;
-	static final protected String GC_SIZE_OTHER = &quot;Other&quot;;
-	static final protected String GC_SIZE_VIRTUAL = &quot;Virtual&quot;;
-	static final protected String OCTC_SIZE_VERYLARGE = &quot;Very large&quot;;
-	static final protected String OCTC_SIZE_NONE = &quot;None&quot;;
+	public static final String GC_SIZE_MICRO = &quot;Micro&quot;;
+	public static final String GC_SIZE_SMALL = &quot;Small&quot;;
+	public static final String GC_SIZE_REGULAR = &quot;Regular&quot;;
+	public static final String GC_SIZE_LARGE = &quot;Large&quot;;
+	public static final String GC_SIZE_NOTCHOSEN = &quot;Not chosen&quot;;
+	public static final String GC_SIZE_OTHER = &quot;Other&quot;;
+	public static final String GC_SIZE_VIRTUAL = &quot;Virtual&quot;;
+	public static final String OCTC_SIZE_VERYLARGE = &quot;Very large&quot;;
+	public static final String OCTC_SIZE_NONE = &quot;None&quot;;
 
 	/*
 	 * OpenCaching Size IDs see
 	 * <A HREF="http://oc-server.svn.sourceforge.net/viewvc/oc-server/doc/sql/static-data/data.sql?view=markup">http://oc-server.svn.sourceforge.net/viewvc/oc-server/doc/sql/static-data/data.sql?view=markup</A>
 	 */
-	static final protected String OC_SIZE_OTHER = &quot;1&quot;;
-	static final protected String OC_SIZE_MICRO = &quot;2&quot;;
-	static final protected String OC_SIZE_SMALL = &quot;3&quot;;
-	static final protected String OC_SIZE_NORMAL = &quot;4&quot;;
-	static final protected String OC_SIZE_LARGE = &quot;5&quot;;
-	static final protected String OC_SIZE_VERYLARGE = &quot;6&quot;;
-	static final protected String OC_SIZE_NONE = &quot;7&quot;;
+	public static final String OC_SIZE_OTHER = &quot;1&quot;;
+	public static final String OC_SIZE_MICRO = &quot;2&quot;;
+	public static final String OC_SIZE_SMALL = &quot;3&quot;;
+	public static final String OC_SIZE_NORMAL = &quot;4&quot;;
+	public static final String OC_SIZE_LARGE = &quot;5&quot;;
+	public static final String OC_SIZE_VERYLARGE = &quot;6&quot;;
+	public static final String OC_SIZE_NONE = &quot;7&quot;;
 
 	/*
 	 * TerraCaching Size IDs taken from old GPXimporter (?? reliable source ??)
 	 */
-	static final protected String TC_SIZE_MICRO = &quot;1&quot;;
-	static final protected String TC_SIZE_MEDIUM = &quot;2&quot;;
-	static final protected String TC_SIZE_REGULAR = &quot;3&quot;;
-	static final protected String TC_SIZE_LARGE = &quot;4&quot;;
-	static final protected String TC_SIZE_VERYLARGE = &quot;4&quot;;
+	public static final String TC_SIZE_MICRO = &quot;1&quot;;
+	public static final String TC_SIZE_MEDIUM = &quot;2&quot;;
+	public static final String TC_SIZE_REGULAR = &quot;3&quot;;
+	public static final String TC_SIZE_LARGE = &quot;4&quot;;
+	public static final String TC_SIZE_VERYLARGE = &quot;4&quot;;
 
 	/*
 	 * images to show in CW index panel we use less images than sizes since all
 	 * non physical caches are represented by the same symbol
 	 */
 	/** GUI image for micro caches */
-	static final protected String CW_GUIIMG_MICRO = &quot;sizeMicro.png&quot;;
+	public static final String CW_GUIIMG_MICRO = &quot;sizeMicro.png&quot;;
 	/** GUI image for small caches */
-	static final protected String CW_GUIIMG_SMALL = &quot;sizeSmall.png&quot;;
+	public static final String CW_GUIIMG_SMALL = &quot;sizeSmall.png&quot;;
 	/** GUI image for regular / normal caches */
-	static final protected String CW_GUIIMG_NORMAL = &quot;sizeReg.png&quot;;
+	public static final String CW_GUIIMG_NORMAL = &quot;sizeReg.png&quot;;
 	/** GUI image for large caches */
-	static final protected String CW_GUIIMG_LARGE = &quot;sizeLarge.png&quot;;
+	public static final String CW_GUIIMG_LARGE = &quot;sizeLarge.png&quot;;
 	/** GUI image for non physical caches */
-	static final protected String CW_GUIIMG_NONPHYSICAL = &quot;sizeNonPhysical.png&quot;;
+	public static final String CW_GUIIMG_NONPHYSICAL = &quot;sizeNonPhysical.png&quot;;
 	/** GUI image for very large caches */
-	static final protected String CW_GUIIMG_VERYLARGE = &quot;sizeVLarge.png&quot;;
+	public static final String CW_GUIIMG_VERYLARGE = &quot;sizeVLarge.png&quot;;
 
 	/*
 	 * IDs for the sizePics[] array in TableModel therefore they must start with
 	 * 0 and be consecutive
 	 */
-	static final protected byte CW_GUIIMGID_MICRO = 0;
-	static final protected byte CW_GUIIMGID_SMALL = 1;
-	static final protected byte CW_GUIIMGID_NORMAL = 2;
-	static final protected byte CW_GUIIMGID_LARGE = 3;
-	static final protected byte CW_GUIIMGID_NONPHYSICAL = 4;
-	static final protected byte CW_GUIIMGID_VERYLARGE = 5;
+	public static final byte CW_GUIIMGID_MICRO = 0;
+	public static final byte CW_GUIIMGID_SMALL = 1;
+	public static final byte CW_GUIIMGID_NORMAL = 2;
+	public static final byte CW_GUIIMGID_LARGE = 3;
+	public static final byte CW_GUIIMGID_NONPHYSICAL = 4;
+	public static final byte CW_GUIIMGID_VERYLARGE = 5;
 
 	/*
 	 * total number of different size images will be used to det the dimension
 	 * of sizePics[] array in TableModel
 	 */
-	static final protected byte CW_TOTAL_SIZE_IMAGES = 6;
+	public static final byte CW_TOTAL_SIZE_IMAGES = 6;
 
 	/*
 	 * bit masks to be used with the filter function
 	 */
-	static final protected byte CW_FILTER_MICRO = 0x01 &lt;&lt; 0;
-	static final protected byte CW_FILTER_SMALL = 0x01 &lt;&lt; 1;
-	static final protected byte CW_FILTER_NORMAL = 0x01 &lt;&lt; 2;
-	static final protected byte CW_FILTER_LARGE = 0x01 &lt;&lt; 3;
-	static final protected byte CW_FILTER_VERYLARGE = 0x01 &lt;&lt; 4;
-	static final protected byte CW_FILTER_NONPHYSICAL = 0x01 &lt;&lt; 5;
-	static final protected byte CW_FILTER_ALL = CW_FILTER_MICRO
+	public static final byte CW_FILTER_MICRO = 0x01 &lt;&lt; 0;
+	public static final byte CW_FILTER_SMALL = 0x01 &lt;&lt; 1;
+	public static final byte CW_FILTER_NORMAL = 0x01 &lt;&lt; 2;
+	public static final byte CW_FILTER_LARGE = 0x01 &lt;&lt; 3;
+	public static final byte CW_FILTER_VERYLARGE = 0x01 &lt;&lt; 4;
+	public static final byte CW_FILTER_NONPHYSICAL = 0x01 &lt;&lt; 5;
+	public static final byte CW_FILTER_ALL = CW_FILTER_MICRO
 			| CW_FILTER_SMALL | CW_FILTER_NORMAL | CW_FILTER_LARGE
 			| CW_FILTER_NONPHYSICAL | CW_FILTER_VERYLARGE;
 
@@ -115,7 +131,7 @@
 	 * @throws IllegalArgumentException
 	 *             if there is no image associated to the id
 	 */
-	public static String sizeImageForId(byte id) {
+	public static String sizeImageForId(byte id) throws IllegalArgumentException {
 		switch (id) {
 			case CW_GUIIMGID_MICRO:
 				return CW_GUIIMG_MICRO;
@@ -144,7 +160,7 @@
 	 * @throws IllegalArgumentException
 	 *             if cwsize can not be mapped to a CW_SIZE constant
 	 */
-	public static String cw2ExportString(byte size) {
+	public static String cw2ExportString(byte size) throws IllegalArgumentException {
 		switch (size) {
 			case CW_SIZE_MICRO:
 				return GC_SIZE_MICRO;
@@ -181,7 +197,7 @@
 	 *             (CW_SIZE_*)
 	 */
 
-	public static byte tcGpxString2Cw(String tcstring) {
+	public static byte tcGpxString2Cw(String tcstring) throws IllegalArgumentException {
 		if (tcstring.equals(TC_SIZE_MICRO)) {
 			return CW_SIZE_MICRO;
 		} else if (tcstring.equals(TC_SIZE_MEDIUM)) {
@@ -209,7 +225,7 @@
 	 *             (CW_SIZE_*)
 	 */
 
-	public static byte gcGpxString2Cw(String gcstring) {
+	public static byte gcGpxString2Cw(String gcstring) throws IllegalArgumentException {
 		if (gcstring.equals(GC_SIZE_MICRO)) {
 			return CW_SIZE_MICRO;
 		} else if (gcstring.equals(GC_SIZE_SMALL)) {
@@ -240,7 +256,7 @@
 	 *             if spiderstring can not be mapped to internal representation
 	 *             (CW_SIZE_*)
 	 */
-	public static byte gcSpiderString2Cw(String spiderstring) {
+	public static byte gcSpiderString2Cw(String spiderstring) throws IllegalArgumentException {
 		// at the moment both sources use the same strings
 		return gcGpxString2Cw(spiderstring);
 	}
@@ -255,7 +271,7 @@
 	 * @trows IllegalArgumentException if ocxmlstring can not be mapped to a
 	 *        CW_SIZE_*
 	 */
-	public static byte ocXmlString2Cw(String ocxmlstring) {
+	public static byte ocXmlString2Cw(String ocxmlstring) throws IllegalArgumentException {
 		if (ocxmlstring.equals(OC_SIZE_OTHER)) {
 			return CW_SIZE_OTHER;
 		} else if (ocxmlstring.equals(OC_SIZE_MICRO)) {
@@ -284,7 +300,7 @@
 	 * @throws IllegalArgumentException
 	 *             if size can not be mapped
 	 */
-	public static byte guiSizeImageId(byte size) {
+	public static byte guiSizeImageId(byte size) throws IllegalArgumentException {
 		switch (size) {
 			case CW_SIZE_MICRO:
 				return CW_GUIIMGID_MICRO;
@@ -310,15 +326,15 @@
 	}
 
 	/**
-	 * convert an &quot;old style&quot; size string to the new internal representation
+	 * convert v1 style size string to the new internal representation
 	 * 
 	 * @param v1Size
 	 *            old size string
 	 * @return CW internal representation of cache size
-	 * @throws if v1Size can not be mapped
+	 * @throws IllegalArgumentException if v1Size can not be mapped
 	 * @deprecated remove once v1 file version compatibility is abandoned
 	 */
-	public static final byte v1Converter(String v1Size) {
+	public static final byte v1Converter(String v1Size) throws IllegalArgumentException {
 		if (v1Size.equals(GC_SIZE_MICRO)) {
 			return CW_SIZE_MICRO;
 		} else if (v1Size.equals(GC_SIZE_SMALL)) {
@@ -346,23 +362,6 @@
 		}
 	}
 	
-	public static final byte v2Converter(byte v2Size) {
-		switch(v2Size) {
-			case CW_SIZE_MICRO: // fall through
-			case CW_SIZE_SMALL: // fall through
-			case CW_SIZE_REGULAR: // fall through
-			case CW_SIZE_LARGE: // fall through
-			case CW_SIZE_NOTCHOSEN: // fall through
-			case CW_SIZE_OTHER: // fall through
-			case CW_SIZE_VIRTUAL: // fall through
-			case CW_SIZE_NONE: // fall through
-			case CW_SIZE_VERYLARGE: return v2Size;
-			case -1: return CW_SIZE_NOTCHOSEN; // -1 was catch all in v2
-			default:
-				throw (new IllegalArgumentException(&quot;unmatched argument &quot; + v2Size + &quot; in v2Converter()&quot;));
-		}
-	}
-
 	/**
 	 * return a bit mask representing the caches size for use in the Filter
 	 * 
@@ -372,8 +371,7 @@
 	 * @throws IllegalArgumentException
 	 *             if size can not be mapped to a bit mask
 	 */
-
-	public static byte getFilterPattern(byte size) {
+	public static byte getFilterPattern(byte size) throws IllegalArgumentException {
 		switch (size) {
 			case CW_SIZE_MICRO:
 				return CW_FILTER_MICRO;
@@ -408,7 +406,7 @@
 	 *             if size can not be mapped
 	 */
 
-	public static String getExportShortId(byte size) {
+	public static String getExportShortId(byte size) throws IllegalArgumentException {
 		switch (size) {
 			case CW_SIZE_MICRO:
 				return &quot;m&quot;;
@@ -440,12 +438,19 @@
 	 * @see guiSizeStrings2CwSize
 	 * @see cwSizeId2GuiSizeId
 	 */
-
 	public static String[] guiSizeStrings() {
 		// make sure strings appear in ascending order for CW_SIZE_*
-		String ret[] = new String[] { GC_SIZE_NOTCHOSEN, GC_SIZE_OTHER,
-				GC_SIZE_MICRO, GC_SIZE_SMALL, GC_SIZE_REGULAR, GC_SIZE_LARGE,
-				OCTC_SIZE_VERYLARGE, OCTC_SIZE_NONE, GC_SIZE_VIRTUAL };
+		String ret[] = new String[] { 
+				GC_SIZE_NOTCHOSEN, 
+				GC_SIZE_OTHER,
+				GC_SIZE_MICRO, 
+				GC_SIZE_SMALL, 
+				GC_SIZE_REGULAR, 
+				GC_SIZE_LARGE,
+				OCTC_SIZE_VERYLARGE, 
+				OCTC_SIZE_NONE, 
+				GC_SIZE_VIRTUAL 
+				};
 		return ret;
 	}
 
@@ -460,7 +465,7 @@
 	 * @see cwSizeId2GuiSizeId
 	 * @see guiSizeStrings
 	 */
-	public static byte guiSizeStrings2CwSize(String id) {
+	public static byte guiSizeStrings2CwSize(String id) throws IllegalArgumentException {
 		// map the strings in guiSizeStrings() back to cw byte types
 		if (id.equals(GC_SIZE_NOTCHOSEN)) {
 			return CW_SIZE_NOTCHOSEN;
@@ -495,7 +500,7 @@
 	 * @see guiSizeStrings2CwSize
 	 * @see cwSizeId2GuiSizeId
 	 */
-	public static int cwSizeId2GuiSizeId(byte id) {
+	public static int cwSizeId2GuiSizeId(byte id) throws IllegalArgumentException {
 		switch (id) {
 		case CW_SIZE_NOTCHOSEN:
 			return 0;

Modified: trunk/src/CacheWolf/CacheType.java
===================================================================
--- trunk/src/CacheWolf/CacheType.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/CacheType.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -1,348 +1,579 @@
-/**
- * 
- */
-package CacheWolf;
-
-import ewe.fx.Image;
-import ewe.sys.Vm;
-
-
-/**
- * @author Kalle
- * Class for dealing with different cachetypes from gc and oc
- */
-
-/**
-*	Listing of types and mappings
-*	
-*	OC		GC		Comment		Regel
-*	1		8		Other			1-&gt;8
-*	2		2		Traditional		2-&gt;2
-*	3		3		Multi			3-&gt;3
-*	4		4		Virtual		4-&gt;4
-*	5		11		Webcam		5-&gt;11
-*	6		6		Event			6-&gt;6
-*	7		8		Quiz			7-&gt;8
-*	8		??		Math			8-&gt;108 (ok)
-*	9		??		Moving		9-&gt;109 (ok)
-*	10		??		Drive-In		10-&gt;110 (ok)
-*/
-
-public class CacheType {
-	private static Image cacheImages[] = new Image[138]; // Images are used by TableControl
-	public static final int WHERIGO=100; // The cache we mapped the wherigo to
-	public static final int MEGA_EVENT=101; // Mapping for Mega Event 
-	static {
-		cacheImages[0] = new Image(&quot;0.png&quot;);
-		//cacheImages[1] = new Image();
-		cacheImages[2] = new Image(&quot;2.png&quot;);
-		cacheImages[3] = new Image(&quot;3.png&quot;);
-		cacheImages[4] = new Image(&quot;4.png&quot;);
-		cacheImages[5] = new Image(&quot;5.png&quot;);
-		cacheImages[6] = new Image(&quot;6.png&quot;);
-		cacheImages[8] = new Image(&quot;8.png&quot;);
-		//cacheImages[9] = new Image();
-		//cacheImages[10] = new Image();
-		cacheImages[11] = new Image(&quot;11.png&quot;);
-		cacheImages[12] = new Image(&quot;12.png&quot;);
-		cacheImages[13] = new Image(&quot;13.png&quot;);
-		//additional waypoints, begin with 50
-		cacheImages[50] = new Image(&quot;pkg.png&quot;);
-		cacheImages[51] = new Image(&quot;stage.png&quot;);
-		cacheImages[52] = new Image(&quot;puzzle.png&quot;);
-		cacheImages[53] = new Image(&quot;flag.png&quot;);
-		cacheImages[54] = new Image(&quot;trailhead.png&quot;);
-		cacheImages[55] = new Image(&quot;waypoint.png&quot;);
-
-		cacheImages[108] = new Image(&quot;108.png&quot;);
-		cacheImages[109] = new Image(&quot;109.png&quot;);
-		cacheImages[110] = new Image(&quot;110.png&quot;);
-		cacheImages[137] = new Image(&quot;137.png&quot;);
-		cacheImages[WHERIGO] = new Image(&quot;1858.png&quot;);  // Fudge as whereigo is really 1858
-		cacheImages[MEGA_EVENT] = new Image(&quot;453.png&quot;);
-	}
-
-	//Types from gc.com
-	static protected final int GC_TRADITIONAL = 2;
-	static protected final int GC_MULTI = 3;
-	static protected final int GC_VIRTUAL = 4;
-	static protected final int GC_LETTERBOX = 5;
-	static protected final int GC_EVENT = 6;
-	static protected final int GC_UNKNOWN = 8;
-	static protected final int GC_WEBCAM = 11;
-	static protected final int GC_LOCATIONLESS = 12;
-	static protected final int GC_CITO = 13;
-	static protected final int GC_EARTH = 137;
-	static protected final int GC_MEGA_EVENT = 453;
-	// additional waypoints have no numbers in GPX Files, so lets use our own.
-	static protected final int GC_AW_PARKING = 50;
-	static protected final int GC_AW_STAGE_OF_MULTI = 51;
-	static protected final int GC_AW_QUESTION = 52;
-	static protected final int GC_AW_FINAL = 53;
-	static protected final int GC_AW_TRAILHEAD = 54;
-	static protected final int GC_AW_REFERENCE = 55;
-	
-	//Types from oc.de
-	static protected final int OC_UNKNOWN = 1;
-	static protected final int OC_TRADITIONAL = 2;
-	static protected final int OC_MULTI = 3;
-	static protected final int OC_VIRTUAL = 4;
-	static protected final int OC_WEBCAM = 5;
-	static protected final int OC_EVENT = 6;
-	static protected final int OC_QUIZ = 7;
-	static protected final int OC_MATH = 8;
-	static protected final int OC_MOVING = 9;
-	static protected final int OC_DRIVE_IN = 10;
-	
-	//Our own mapping
-	static protected final int CW_TRADITIONAL = 2;
-	static protected final int CW_MULTI = 3;
-	static protected final int CW_VIRTUAL = 4;
-	static protected final int CW_LETTERBOX = 5;
-	static protected final int CW_EVENT = 6;
-	static protected final int CW_QUIZ = 7;
-	static protected final int CW_UNKNOWN = 8;
-	static protected final int CW_MATH = 8;
-	static protected final int CW_MOVING = 9;
-	static protected final int CW_DRIVE_IN = 10;
-	static protected final int CW_WEBCAM = 11;
-	static protected final int CW_LOCATIONLESS = 12;
-	static protected final int CW_CITO = 13;
-	static protected final int CW_EARTH = 137;
-	static protected final int CW_MEGA_EVENT = 453;
-	static protected final int CW_WHERIGO = 1858;
-	static protected final int CW_PARKING = 50;
-	static protected final int CW_STAGE_OF_MULTI = 51;
-	static protected final int CW_QUESTION = 52;
-	static protected final int CW_FINAL = 53;
-	static protected final int CW_TRAILHEAD = 54;
-	static protected final int CW_REFERENCE = 55;
-	static protected final int CW_CNT_TYPES = 20;
-
-	//Sources
-	static protected final int SRC_GC = 1;
-	static protected final int SRC_OC = 2;
-	static protected final int SRC_CW = 3;
-
-	//pictures
-	static protected final String CW_PIC_UNKNOWN = &quot;8.png&quot;;
-	static protected final String CW_PIC_TRADITIONAL = &quot;2.png&quot;;
-	static protected final String CW_PIC_MULTI = &quot;3.png&quot;;
-	static protected final String CW_PIC_VIRTUAL = &quot;4.png&quot;;
-	static protected final String CW_PIC_WEBCAM = &quot;11.png&quot;;
-	static protected final String CW_PIC_EVENT = &quot;6.png&quot;;
-	static protected final String CW_PIC_QUIZ = &quot;8.png&quot;;
-	static protected final String CW_PIC_MATH = &quot;108.png&quot;;
-	static protected final String CW_PIC_MOVING = &quot;109.png&quot;;
-	static protected final String CW_PIC_DRIVE_IN = &quot;110.png&quot;;
-	static protected final String CW_PIC_LETTERBOX = &quot;5.png&quot;;
-	static protected final String CW_PIC_LOCATIONLESS = &quot;12.png&quot;;
-	static protected final String CW_PIC_CITO = &quot;13.png&quot;;
-	static protected final String CW_PIC_EARTH = &quot;137.png&quot;;
-	static protected final String CW_PIC_MEGA_EVENT = &quot;453.png&quot;;
-	static protected final String CW_PIC_WHERIGO = &quot;1858.png&quot;;
-	static protected final String CW_PIC_PARKING = &quot;pkg.png&quot;;
-	static protected final String CW_PIC_STAGE_OF_MULTI = &quot;stage.png&quot;;
-	static protected final String CW_PIC_QUESTION = &quot;puzzle.png&quot;;
-	static protected final String CW_PIC_FINAL = &quot;flag.png&quot;;
-	static protected final String CW_PIC_TRAILHEAD = &quot;trailhead.png&quot;;
-	static protected final String CW_PIC_REFERENCE = &quot;waypoint.png&quot;;
-	
-	//fields
-	int type = 0;
-	
-	// array with names and types for exporters
-	public final static int WPT_TEXT = 0;
-	public final static int WPT_NUM = 1;
-
-	public static String[][] wayType = {{&quot;Custom&quot;,&quot;0&quot;},{&quot;Traditional&quot;,&quot;2&quot;},
-			{&quot;Multi&quot;,&quot;3&quot;}, {&quot;Virtual&quot;,&quot;4&quot;},
-			{&quot;Letterbox&quot;,&quot;5&quot;},{&quot;Event&quot;,&quot;6&quot;},
-			{&quot;Mega Event&quot;,&quot;453&quot;}, {&quot;Mystery&quot;,&quot;8&quot;},
-			{&quot;Webcam&quot;,&quot;11&quot;},{&quot;Locationless&quot;,&quot;12&quot;},
-			{&quot;CITO&quot;,&quot;13&quot;},{&quot;Earthcache&quot;,&quot;137&quot;},
-			{&quot;Parking&quot;,&quot;50&quot;},{&quot;Stage&quot;,&quot;51&quot;},
-			{&quot;Question&quot;,&quot;52&quot;},{&quot;Final&quot;,&quot;53&quot;},
-			{&quot;Trailhead&quot;,&quot;54&quot;},{&quot;Reference&quot;,&quot;55&quot;},{&quot;WhereIGo&quot;,&quot;1858&quot;}};
-
-	public static String shortType(int typeNum){
-		String shortType = new String(&quot;O&quot;);
-		if(typeNum == 0) shortType = &quot;C&quot;;
-		if(typeNum == 2) shortType = &quot;T&quot;;
-		if(typeNum == 3) shortType = &quot;M&quot;;
-		if(typeNum == 4) shortType = &quot;V&quot;;
-		if(typeNum == 5) shortType = &quot;L&quot;;
-		if(typeNum == 6) shortType = &quot;O&quot;;
-		if(typeNum == 11) shortType = &quot;W&quot;;
-		if(typeNum == 8) shortType = &quot;U&quot;;
-		if(typeNum == 12) shortType = &quot;O&quot;;
-		if(typeNum == 13) shortType = &quot;O&quot;;
-		if(typeNum == 137) shortType = &quot;E&quot;;
-		if(typeNum == 453) shortType = &quot;O&quot;;
-		if(typeNum == 1858) shortType = &quot;O&quot;;
-		if(typeNum == 50) shortType = &quot;P&quot;;
-		if(typeNum == 51) shortType = &quot;S&quot;;
-		if(typeNum == 52) shortType = &quot;Q&quot;;
-		if(typeNum == 53) shortType = &quot;F&quot;;
-		if(typeNum == 54) shortType = &quot;H&quot;;
-		if(typeNum == 55) shortType = &quot;R&quot;;
-		return shortType;
-	}
-	public static String transType(int geoNum){
-		String geo = new String(&quot;Unknown&quot;);
-		if(geoNum == 2) geo = &quot;Traditional Cache&quot;;
-		if(geoNum == 3) geo = &quot;Multi-cache&quot;;
-		if(geoNum == 4) geo = &quot;Virtual Cache&quot;;
-		if(geoNum == 5) geo = &quot;Letterbox Hybrid&quot;;
-		if(geoNum == 6) geo = &quot;Event Cache&quot;;
-		if(geoNum == 11) geo = &quot;Webcam Cache&quot;;
-		if(geoNum == 8) geo = &quot;Unknown Cache&quot;;
-		if(geoNum == 12) geo = &quot;Locationless Cache&quot;;
-		if(geoNum == 13) geo = &quot;Cache In Trash Out Event&quot;;
-		if(geoNum == 137) geo = &quot;Earthcache&quot;;
-		if(geoNum == 453) geo = &quot;Mega Event Cache&quot;;
-		if(geoNum == 1858) geo = &quot;WhereIGo Cache&quot;;
-		if(geoNum == 50) geo = &quot;Parking Area&quot;;
-		if(geoNum == 51) geo = &quot;Stages of a Multicache&quot;;
-		if(geoNum == 52) geo = &quot;Question to Answer&quot;;
-		if(geoNum == 53) geo = &quot;Final Location&quot;;
-		if(geoNum == 54) geo = &quot;Trailhead&quot;;
-		if(geoNum == 55) geo = &quot;Reference Point&quot;;
-		return geo;
-	}
-	
-	/**
-	 * Returns the image name of a given internal type
-	 * @param type Type of cache
-	 * @return The image name of the cache
-	 */
-	public static String type2pic(int type) {
-		switch(type) {
-			case CW_TRADITIONAL:	return CW_PIC_TRADITIONAL;
-			case CW_MULTI:			return CW_PIC_MULTI;
-			case CW_VIRTUAL:		return CW_PIC_VIRTUAL;
-			case CW_LETTERBOX:		return CW_PIC_LETTERBOX;
-			case CW_EVENT:			return CW_PIC_EVENT;
-			case CW_QUIZ:			return CW_PIC_QUIZ;
-			case CW_UNKNOWN:		return CW_PIC_UNKNOWN;
-			case CW_MOVING:			return CW_PIC_MOVING;
-			case CW_DRIVE_IN:		return CW_PIC_DRIVE_IN;
-			case CW_WEBCAM:			return CW_PIC_WEBCAM;
-			case CW_LOCATIONLESS:	return CW_PIC_LOCATIONLESS;
-			case CW_CITO:			return CW_PIC_CITO;
-			case CW_EARTH:			return CW_PIC_EARTH;
-			case CW_MEGA_EVENT:		return CW_PIC_MEGA_EVENT;
-			case CW_WHERIGO:	    return CW_PIC_WHERIGO;
-			case CW_PARKING:		return CW_PIC_PARKING;
-			case CW_STAGE_OF_MULTI:	return CW_PIC_STAGE_OF_MULTI;
-			case CW_QUESTION:		return CW_PIC_QUESTION;
-			case CW_FINAL:			return CW_PIC_FINAL;
-			case CW_TRAILHEAD:		return CW_PIC_TRAILHEAD;
-			case CW_REFERENCE:		return CW_PIC_REFERENCE;
-			default:		return &quot;no_picture.png&quot;;
-		}
-	}
-
-	public static boolean isAddiWpt(int type){
-		return (type &gt;= 50 &amp;&amp; type &lt;= 55);
-	}
-
-	public static int typeText2Number(String typeText){
-		if (typeText.equals(&quot;Traditional Cache&quot;) || typeText.equals(&quot;Traditional&quot;)|| typeText.equals(&quot;Classic&quot;)) return 2;
-		if (typeText.equals(&quot;Multi-cache&quot;) || typeText.equals(&quot;Multi&quot;) || typeText.equals(&quot;Offset&quot;)) return 3;
-		if (typeText.equals(&quot;Virtual Cache&quot;) || typeText.equals(&quot;Virtual&quot;)) return 4;
-		if (typeText.equals(&quot;Letterbox Hybrid&quot;)) return 5;
-		if (typeText.equals(&quot;Event Cache&quot;) || typeText.equals(&quot;Event&quot;)) return 6;
-		if (typeText.equals(&quot;Unknown Cache&quot;) || typeText.equals(&quot;Other&quot;) || typeText.equals(&quot;Quiz&quot;)) return 8;
-		if (typeText.equals(&quot;Webcam Cache&quot;) || typeText.equals(&quot;Webcam&quot;)) return 11;
-		if (typeText.equals(&quot;Locationless (Reverse) Cache&quot;)) return 12;
-		if (typeText.equals(&quot;Cache In Trash Out Event&quot;)) return 13;
-		if (typeText.equals(&quot;Earthcache&quot;) || typeText.equals(&quot;Earth&quot;)) return 137;
-		if (typeText.equals(&quot;Mega-Event Cache&quot;)) return 453;
-		if (typeText.equals(&quot;Wherigo Cache&quot;)) return 1858;
-		if (typeText.equals(&quot;Waypoint|Parking Area&quot;)) return 50;
-		if (typeText.equals(&quot;Waypoint|Stages of a Multicache&quot;)) return 51;
-		if (typeText.equals(&quot;Waypoint|Question to Answer&quot;)) return 52;
-		if (typeText.equals(&quot;Waypoint|Final Coordinates&quot;)||typeText.equals(&quot;Waypoint|Final Location&quot;)) return 53;
-		if (typeText.equals(&quot;Waypoint|Trailhead&quot;)) return 54;
-		if (typeText.equals(&quot;Waypoint|Reference Point&quot;)) return 55;
-		Vm.debug(&quot;Unknown Cache Type:&quot; + typeText);
-		return 0;
-	}
-
-	/**
-		*	Method to translate opencaching types to geocaching types.
-		*	Required to be &quot;backwards&quot; compatible :-(
-		*	OC		GC		Comment		Regel
-		*	1		8		Other			1-&gt;8
-		*	2		2		Traditional		2-&gt;2
-		*	3		3		Multi			3-&gt;3
-		*	4		4		Virtual		4-&gt;4
-		*	5		11		Webcam		5-&gt;11
-		*	6		6		Event			6-&gt;6
-		*	7		8		Quiz			7-&gt;8
-		*	8		??		Math			8-&gt;108 (ok)
-		*	9		??		Moving		9-&gt;109 (ok)
-		*	10		??		Drive-In		10-&gt;110 (ok)
-		*/
-		public static int transOCType(int type){
-			if(type == 1) return 8;
-			if(type == 2) return 2;
-			if(type == 3) return 3;	
-			if(type == 4) return 4;
-			if(type == 5) return 11;
-			if(type == 6) return 6;
-			if(type == 7) return 8;
-			if(type &gt;= 8 || type &lt;= 10) return 8;
-	/* Not supportet at the moment
-			if(type.equals(&quot;8&quot;)) return &quot;108&quot;;
-			if(type.equals(&quot;9&quot;)) return &quot;109&quot;;
-			if(type.equals(&quot;10&quot;)) return &quot;110&quot;;
-	*/
-			//no match found? return custom type!
-			return 0;
-		}
-
-		
-	public static Image cache2Img(int cacheType) {
-		int index = cacheType;
-		switch (cacheType) {
-			case 1858: index =  WHERIGO; break;
-			case 453:  index =  MEGA_EVENT; break;
-		}
-		return cacheImages[index];
-	}
-	
-	/**
-	 * Packs the cache type into the range of a byte. For the int values which don't fit in the 
-	 * byte range, some conversion has to be done.
-	 * @param cacheType Cache Type as integer
-	 * @return A corresponding byte value. 
-	 */
-	public static byte toByte(int cacheType) {
-		int result = cacheType-128;
-		switch (cacheType) {
-			case 1858: result =  WHERIGO; break;
-			case 453:  result =  MEGA_EVENT; break;
-			default: result = cacheType-128;
-		}
-		return (byte)(result);
-	}
-	
-	/**
-	 * Unpacks the cache type from byte to int. 
-	 * @param cacheType Cache type as byte
-	 * @return The cache type as int
-	 */
-	public static int toInt(byte cacheType) {
-		int result;
-		switch (cacheType) {
-		case WHERIGO:     result =  1858; break;
-		case MEGA_EVENT:  result =  453; break;
-		default: result = cacheType+128;
-		}
-		return result;
-	}
-	
-
-}
+package CacheWolf;
+
+/**
+ * Handels all aspects of converting cache type information from
+ * and to the various im- and exporters as well as for converting
+ * legavy profiles to current standard
+ * 
+ * Do not instantiate this class, only use it in a static way
+ */
+public final class CacheType {
+	
+	/** custom waypoint */
+	public static final byte CW_TYPE_CUSTOM = 0;
+	/** traditional cache (GC,OC) */
+	public static final byte CW_TYPE_TRADITIONAL = 2;
+	/** multi cache (GC,OC) */
+	public static final byte CW_TYPE_MULTI = 3;
+	/** virtual cache (GC) */
+	public static final byte CW_TYPE_VIRTUAL = 4;
+	/** letterbox cache (GC) */
+	public static final byte CW_TYPE_LETTERBOX = 5;
+	/** event cache (OC,GC) */
+	public static final byte CW_TYPE_EVENT = 6;
+	/** quiz cache (OC) */
+	public static final byte CW_TYPE_QUIZ = 7;
+	/** unknown cache (GC) */
+	public static final byte CW_TYPE_UNKNOWN = 8;
+	/** math cache (OC) */
+	public static final byte CW_TYPE_MATH = 108;
+	/** moving cache (OC) */
+	public static final byte CW_TYPE_MOVING = 9;
+	/** drive in cache (OC) */
+	public static final byte CW_TYPE_DRIVE_IN = 10;
+	/** webcam cache (GC,OC) */
+	public static final byte CW_TYPE_WEBCAM = 11;
+	/** locationless cache (GC) */
+	public static final byte CW_TYPE_LOCATIONLESS = 12;
+	/** CITO cache (GC,OC)*/
+	public static final byte CW_TYPE_CITO = 13;
+	/** Additional Waypoint Parking (GC) */
+	public static final byte CW_TYPE_PARKING = 50;
+	/** Additional Waypoint Stage of a Multi (GC) */
+	public static final byte CW_TYPE_STAGE = 51;
+	/** Additional Waypoint Question to answer (GC) */
+	public static final byte CW_TYPE_QUESTION = 52;
+	/** Additional Waypoint Final (GC) */
+	public static final byte CW_TYPE_FINAL = 53;
+	/** Additional Waypoint Trailhead (GC) */
+	public static final byte CW_TYPE_TRAILHEAD = 54;
+	/** Additional Waypoint Reference (GC) */
+	public static final byte CW_TYPE_REFERENCE = 55;
+	/** Mega Event Cache (GC) */
+	public static final byte CW_TYPE_MEGA_EVENT = 100;
+	/** WhereIGo Cache (GC) */
+	public static final byte CW_TYPE_WHEREIGO = 101;
+	/** Project Ape cache (GC)*/
+	public static final byte CW_TYPE_APE = 102;
+	/** Adenture Maze Exhibit (GC)*/
+	public static final byte CW_TYPE_MAZE = 103;
+	/** Earth Cache (GC) */
+	public static final byte CW_TYPE_EARTH = 104;
+	/** unrecognized cache type or missing information, should throw IllegalArgumentExceptions when found */
+	public static final byte CW_TYPE_ERROR = -1;
+	
+	/** image for custom waypoints */
+	public static final String CW_GUIIMG_CUSTOM = &quot;0.png&quot;;
+	/** image for traditional cache (GC,OC) */
+	public static final String CW_GUIIMG_TRADITIONAL = &quot;2.png&quot;;
+	/** image for multi cache (GC,OC) */
+	public static final String CW_GUIIMG_MULTI = &quot;3.png&quot;;
+	/** image for virtual cache (GC) */
+	public static final String CW_GUIIMG_VIRTUAL = &quot;4.png&quot;;
+	/** image for letterbox cache (GC) */
+	public static final String CW_GUIIMG_LETTERBOX = &quot;5.png&quot;;
+	/** image for event cache (OC,GC) */
+	public static final String CW_GUIIMG_EVENT = &quot;6.png&quot;;
+	/** image for quiz cache (OC) */
+	public static final String CW_GUIIMG_QUIZ = &quot;8.png&quot;;
+	/** image for unknown cache (GC) */
+	public static final String CW_GUIIMG_UNKNOWN = &quot;8.png&quot;;
+	/** image for math cache (OC) */
+	public static final String CW_GUIIMG_MATH = &quot;108.png&quot;;
+	/** image for moving cache (OC) */
+	public static final String CW_GUIIMG_MOVING = &quot;109.png&quot;;
+	/** image for drive in cache (OC) */
+	public static final String CW_GUIIMG_DRIVE_IN = &quot;110.png&quot;;
+	/** image for webcam cache (GC,OC) */
+	public static final String CW_GUIIMG_WEBCAM = &quot;11.png&quot;;
+	/** image for locationless cache (GC) */
+	public static final String CW_GUIIMG_LOCATIONLESS = &quot;12.png&quot;;
+	/** image for CITO cache (GC,OC)*/
+	public static final String CW_GUIIMG_CITO = &quot;13.png&quot;;
+	/** image for Additional Waypoint Parking (GC) */
+	public static final String CW_GUIIMG_PARKING = &quot;pkg.png&quot;;
+	/** image for Additional Waypoint Stage of a Multi (GC) */
+	public static final String CW_GUIIMG_STAGE = &quot;stage.png&quot;;
+	/** image for Additional Waypoint Question to answer (GC) */
+	public static final String CW_GUIIMG_QUESTION = &quot;puzzle.png&quot;;
+	/** image for Additional Waypoint Final (GC) */
+	public static final String CW_GUIIMG_FINAL = &quot;flag.png&quot;;
+	/** image for Additional Waypoint Trailhead (GC) */
+	public static final String CW_GUIIMG_TRAILHEAD = &quot;trailhead.png&quot;;
+	/** image for Additional Waypoint Reference Point (GC) */
+	public static final String CW_GUIIMG_REFERENCE = &quot;waypoint.png&quot;;
+	/** image for Mega Event Cache (GC) */
+	public static final String CW_GUIIMG_MEGA_EVENT = &quot;453.png&quot;;
+	/** image for WhereIGo Cache (GC) */
+	public static final String CW_GUIIMG_WHEREIGO = &quot;1858.png&quot;;
+	/** image for Project Ape cache (GC)*/
+	public static final String CW_GUIIMG_APE = &quot;typeApe.png&quot;;
+	/** image for Adenture Maze Exhibit (GC)*/
+	public static final String CW_GUIIMG_MAZE = &quot;typeMaze.png&quot;;
+	/** image for Earth Cache (GC) */
+	public static final String CW_GUIIMG_EARTH = &quot;137.png&quot;;
+	
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_CUSTOM = &quot;Custom&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_TRADI = &quot;Tradi&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_MULTI = &quot;Multi&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_VIRTUAL = &quot;Virtual&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_LETTERBOX = &quot;Letterbox&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_EVENT = &quot;Event&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_MEGAEVENT = &quot;Mega Event&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_WEBCAM = &quot;Webcam&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_UNKNOWN = &quot;Mystery&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_LOCATIONLESS = &quot;Locationless&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_CITO = &quot;CITO&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_EARTH = &quot;Earthcache&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_WHEREIGO = &quot;WherIGo&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_PARKING = &quot;Addi: Parking&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_STAGE = &quot;Addi: Stage&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_QUESTION = &quot;Addi: Question&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_FINAL = &quot;Addi: Final&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_TRAILHEAD = &quot;Addi: Trailhead&quot;;
+	/** GUI string for custom waypoit */
+	public static final String CW_GUISTR_REFERENCE = &quot;Addi: Reference&quot;;
+	
+	/** GPX identifier for Traditional caches */
+	public static final String GC_GPX_TRADITIONAL = &quot;Traditional Cache&quot;;
+	/** GPX identifier for Multi caches */
+	public static final String GC_GPX_MULTI = &quot;Multi-cache&quot;;
+	/** GPX identifier for virtual caches */
+	public static final String GC_GPX_VIRTUAL = &quot;Virtual Cache&quot;;
+	/** GPX identifier for Letterbox hybrids */
+	public static final String GC_GPX_LETTERBOX = &quot;Letterbox Hybrid&quot;;
+	/** GPX identifier for Event caches */
+	public static final String GC_GPX_EVENT = &quot;Event Cache&quot;;
+	/** GPX identifier for Unknown or Mystery caches */ 
+	public static final String GC_GPX_UNKNOWN = &quot;Unknown Cache&quot;;
+	/** GPX identifier for Webcam caches */
+	public static final String GC_GPX_WEBCAM = &quot;Webcam Cache&quot;;
+	/** GPX identifier for Locationless caches */
+	public static final String GC_GPX_LOCATIONLESS = &quot;Locationless (Reverse) Cache&quot;;
+	/** GPX identifier for CITO events */
+	public static final String GC_GPX_CITO = &quot;Cache In Trash Out Event&quot;;
+	/** GPX identifier for Earth caches */
+	public static final String GC_GPX_EARTH = &quot;Earthcache&quot;;
+	/** GPX identifier for Mega Events */
+	public static final String GC_GPX_MEGA_EVENT = &quot;Mega-Event Cache&quot;;
+	/** GPX identifier for WhereIGo caches */
+	public static final String GC_GPX_WHEREIGO = &quot;Wherigo Cache&quot;;
+	/** GPX identifier for additional waypoint Parking */
+	public static final String GC_GPX_PARKING = &quot;Waypoint|Parking Area&quot;;
+	/** GPX identifier for additional waypoint Stage */
+	public static final String GC_GPX_STAGE = &quot;Waypoint|Stages of a Multicache&quot;;
+	/** GPX identifier for additional waypoint QTA */
+	public static final String GC_GPX_QUESTION = &quot;Waypoint|Question to Answer&quot;;
+	/** GPX identifier for additional waypoint Final */
+	public static final String GC_GPX_FINAL = &quot;Waypoint|Final Coordinates&quot;;
+	/** GPX identifier for additional waypoint Trailhead */
+	public static final String GC_GPX_TRAILHEAD = &quot;Waypoint|Trailhead&quot;;
+	/** GPX identifier for additional waypoint Reference Point */
+	public static final String GC_GPX_REFERENCE = &quot;Waypoint|Reference Point&quot;;
+	/** GPX identifier for additional waypoint Adventure Maze Exhibit Events */
+	public static final String GC_GPX_MAZE = &quot;GPS Adventures Exhibit&quot;; 
+	/** GPX identifier for additional waypoint Project Ape caches */
+	public static final String GC_GPX_APE = &quot;Project APE Cache&quot;; 
+	
+	/**  constructor does nothing */
+	public CacheType() {
+
+	}
+	
+	/**
+	 * translate cache type to a short version for compact exporters or &quot;smart&quot; cache names. 
+	 * @param type CacheWolf internal type information
+	 * @return abbreviation of cache type
+	 * @throws IllegalArgumentException if &lt;code&gt;type&lt;/code&gt; can not be mapped
+	 */
+	public static String getExportShortId(byte type) throws IllegalArgumentException {
+		switch (type){
+		case CW_TYPE_CUSTOM: return &quot;C&quot;;
+		case CW_TYPE_TRADITIONAL: return &quot;T&quot;;
+		case CW_TYPE_MULTI: return &quot;M&quot;;
+		case CW_TYPE_VIRTUAL: return &quot;V&quot;;
+		case CW_TYPE_LETTERBOX: return &quot;L&quot;;
+		case CW_TYPE_EVENT: return &quot;X&quot;;
+		case CW_TYPE_WEBCAM: return &quot;W&quot;;
+		case CW_TYPE_UNKNOWN: return &quot;U&quot;;
+		case CW_TYPE_LOCATIONLESS: return &quot;O&quot;;
+		case CW_TYPE_CITO: return &quot;X&quot;;
+		case CW_TYPE_EARTH: return &quot;E&quot;;
+		case CW_TYPE_MEGA_EVENT: return &quot;X&quot;;
+		case CW_TYPE_WHEREIGO: return &quot;G&quot;;
+		case CW_TYPE_PARKING: return &quot;P&quot;;
+		case CW_TYPE_STAGE: return &quot;S&quot;;
+		case CW_TYPE_QUESTION: return &quot;Q&quot;;
+		case CW_TYPE_FINAL: return &quot;F&quot;;
+		case CW_TYPE_TRAILHEAD: return &quot;H&quot;;
+		case CW_TYPE_REFERENCE: return &quot;R&quot;;
+		case CW_TYPE_APE: return &quot;T&quot;;
+		case CW_TYPE_MAZE: return &quot;X&quot;;
+		default: throw new IllegalArgumentException(&quot;unmatched argument &quot;+type+&quot; in CacheSizeNew getExportShortId()&quot;);
+		}
+	}
+	
+	/**
+	 * convert version1 type information to current values
+	 * @param type version1 cache type information
+	 * @return current version cache type information
+	 * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; can not be mapped to internal representation
+	 * @deprecated remove once v1 file version compatibility is abandoned
+	 */
+	public static final byte v1Converter(String type) throws IllegalArgumentException  {
+		if (type.equals(&quot;0&quot;)) return CW_TYPE_CUSTOM;
+		if (type.equals(&quot;2&quot;)) return CW_TYPE_TRADITIONAL;
+		if (type.equals(&quot;3&quot;)) return CW_TYPE_MULTI;
+		if (type.equals(&quot;4&quot;)) return CW_TYPE_VIRTUAL;
+		if (type.equals(&quot;5&quot;)) return CW_TYPE_LETTERBOX;
+		if (type.equals(&quot;6&quot;)) return CW_TYPE_EVENT;
+		if (type.equals(&quot;8&quot;)) return CW_TYPE_UNKNOWN;
+		if (type.equals(&quot;11&quot;)) return CW_TYPE_WEBCAM;
+		if (type.equals(&quot;12&quot;)) return CW_TYPE_LOCATIONLESS;
+		if (type.equals(&quot;50&quot;)) return CW_TYPE_PARKING;
+		if (type.equals(&quot;51&quot;)) return CW_TYPE_STAGE;
+		if (type.equals(&quot;52&quot;)) return CW_TYPE_QUESTION;
+		if (type.equals(&quot;53&quot;)) return CW_TYPE_FINAL;
+		if (type.equals(&quot;54&quot;)) return CW_TYPE_TRAILHEAD;
+		if (type.equals(&quot;55&quot;)) return CW_TYPE_REFERENCE;
+		if (type.equals(&quot;453&quot;)) return CW_TYPE_MEGA_EVENT;
+		if (type.equals(&quot;1858&quot;)) return CW_TYPE_WHEREIGO;
+		if (type.equals(&quot;137&quot;)) return CW_TYPE_EARTH;
+		
+		throw new IllegalArgumentException(&quot;unmatched argument &quot;+type+&quot; in CacheSizeNew v1Converter()&quot;);
+	}
+
+	/**
+	 * convert version1 type information to current values
+	 * @param type version2 cache type information
+	 * @return current version cache type information
+	 * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; can not be mapped to internal representation
+	 * @deprecated remove once v2 file version compatibility is abandoned
+	 */
+	public static final byte v2Converter(byte type) throws IllegalArgumentException  {
+		switch (type) {
+		case -128: return CW_TYPE_CUSTOM;
+		case -126: return CW_TYPE_TRADITIONAL;
+		case -125: return CW_TYPE_MULTI;
+		case -124: return CW_TYPE_VIRTUAL;
+		case -123: return CW_TYPE_LETTERBOX;
+		case -122: return CW_TYPE_EVENT;
+		case -121: return CW_TYPE_QUIZ;
+		case -120: return CW_TYPE_UNKNOWN;
+		case -119: return CW_TYPE_MOVING;
+		case -118: return CW_TYPE_DRIVE_IN;
+		case -117: return CW_TYPE_WEBCAM;
+		case -116: return CW_TYPE_LOCATIONLESS;
+		case -115: return CW_TYPE_CITO;
+		case -78: return CW_TYPE_PARKING;
+		case -77: return CW_TYPE_STAGE;
+		case -76: return CW_TYPE_QUESTION;
+		case -75: return CW_TYPE_FINAL;
+		case -74: return CW_TYPE_TRAILHEAD;
+		case -73: return CW_TYPE_REFERENCE;
+		case 101: return CW_TYPE_MEGA_EVENT;
+		case 100: return CW_TYPE_WHEREIGO;
+		case 9: return CW_TYPE_EARTH;
+		default: throw new IllegalArgumentException(&quot;unmatched argument &quot;+type+&quot; in CacheSizeNew v2Converter()&quot;);
+		}
+	}
+	
+	/**
+	 * check if a given waypoint type is an additional waypoint
+	 * @param type waypoint type to check 
+	 * @return true if it is an additional waypint, false otherwise
+	 */
+	public static final boolean isAddiWpt(byte type) {
+		switch (type) {
+		case CW_TYPE_PARKING: // fall through
+		case CW_TYPE_STAGE: // fall through
+		case CW_TYPE_QUESTION: // fall through
+		case CW_TYPE_FINAL: // fall through
+		case CW_TYPE_TRAILHEAD: // fall through
+		case CW_TYPE_REFERENCE: return true;
+		default: return false;
+		}
+		
+	}
+	
+	/**
+	 * create list of cache types to be shown in GUI drop down lists
+	 * @return list of cache types to be shown in GUI drop down list
+	 * @see guiSelect2Cw
+	 * @see cw2GuiSelect
+	 */
+	//TODO: move to a class &quot;closer&quot; to the gui?
+	public static final String[] guiTypeStrings() {
+		String ret[] = new String[] {
+				CW_GUISTR_CUSTOM,
+				CW_GUISTR_TRADI,
+				CW_GUISTR_MULTI,
+				CW_GUISTR_VIRTUAL,
+				CW_GUISTR_LETTERBOX,
+				CW_GUISTR_EVENT,
+				CW_GUISTR_MEGAEVENT,
+				CW_GUISTR_WEBCAM,
+				CW_GUISTR_UNKNOWN,
+				CW_GUISTR_LOCATIONLESS,
+				CW_GUISTR_CITO,
+				CW_GUISTR_EARTH,
+				CW_GUISTR_WHEREIGO,
+				CW_GUISTR_PARKING,
+				CW_GUISTR_STAGE,
+				CW_GUISTR_QUESTION,
+				CW_GUISTR_FINAL,
+				CW_GUISTR_TRAILHEAD,
+				CW_GUISTR_REFERENCE
+			};
+		return ret;
+	}
+	
+	/**
+	 * translate GUI drop down index selection back to internally stored type
+	 * @param selection index value from drop down list
+	 * @return internal type
+	 * @throws IllegalArgumentException if &lt;code&gt;selection&lt;/code&gt; can not be matched
+	 * @see guiTypeStrings
+	 * @see cw2GuiSelect
+	 */
+	//TODO: move to a class &quot;closer&quot; to the gui?
+	public static final byte guiSelect2Cw(int selection) throws IllegalArgumentException {
+		// make sure to reflect the order of guiTypeStrings()
+		switch (selection) {
+		case  0: return CW_TYPE_CUSTOM;
+		case  1: return CW_TYPE_TRADITIONAL;
+		case  2: return CW_TYPE_MULTI;
+		case  3: return CW_TYPE_VIRTUAL;
+		case  4: return CW_TYPE_LETTERBOX;
+		case  5: return CW_TYPE_EVENT;
+		case  6: return CW_TYPE_MEGA_EVENT;
+		case  7: return CW_TYPE_WEBCAM;
+		case  8: return CW_TYPE_UNKNOWN;
+		case  9: return CW_TYPE_LOCATIONLESS;
+		case 10: return CW_TYPE_CITO;
+		case 11: return CW_TYPE_EARTH;
+		case 12: return CW_TYPE_WHEREIGO;
+		case 13: return CW_TYPE_PARKING;
+		case 14: return CW_TYPE_STAGE;
+		case 15: return CW_TYPE_QUESTION;
+		case 16: return CW_TYPE_FINAL;
+		case 17: return CW_TYPE_TRAILHEAD;
+		case 18: return CW_TYPE_REFERENCE;
+		default: throw new IllegalArgumentException(&quot;unmatched argument &quot;+selection+&quot; in CacheSize guiSelect2Cw()&quot;);
+		}
+	}
+	
+	/**
+	 * translate cache type to position of index to highlight in GUI cache type drop down list 
+	 * @param id internal id of cache type
+	 * @return index of the cache type in GUI list
+	 * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; can not be matched
+	 * @see guiTypeStrings
+	 * @see guiSelect2Cw
+	 */
+	//TODO: move to a class &quot;closer&quot; to the gui?
+	public static final int cw2GuiSelect(byte id) throws IllegalArgumentException {
+		switch (id) {
+		case CW_TYPE_CUSTOM: return 0;
+		case CW_TYPE_TRADITIONAL: return 1;
+		case CW_TYPE_MULTI: return 2;
+		case CW_TYPE_VIRTUAL: return 3;
+		case CW_TYPE_LETTERBOX: return 4;
+		case CW_TYPE_EVENT: return 5;
+		case CW_TYPE_MEGA_EVENT: return 6;
+		case CW_TYPE_WEBCAM: return 7;
+		case CW_TYPE_UNKNOWN: return 8;
+		case CW_TYPE_LOCATIONLESS: return 9;
+		case CW_TYPE_CITO: return 10;
+		case CW_TYPE_EARTH: return 11;
+		case CW_TYPE_WHEREIGO: return 12;
+		case CW_TYPE_PARKING: return 13;
+		case CW_TYPE_STAGE: return 14;
+		case CW_TYPE_QUESTION: return 15;
+		case CW_TYPE_FINAL: return 16;
+		case CW_TYPE_TRAILHEAD: return 17;
+		case CW_TYPE_REFERENCE: return 18;
+		default: throw new IllegalArgumentException(&quot;unmatched argument &quot;+id+&quot; in CacheSize cw2GuiSelect()&quot;);
+		}
+	}
+	
+	/**
+	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type 
+	 * @param gpxType type information found in GPX
+	 * @return internal cache type
+	 * @throws IllegalArgumentException if &lt;code&gt;gpxType&lt;/code&gt; can not be matched
+	 */
+	public static final byte gpxType2CwType(String gpxType) throws IllegalArgumentException {
+		if (gpxType.equals(GC_GPX_TRADITIONAL) || gpxType.equals(&quot;Traditional&quot;)|| gpxType.equals(&quot;Classic&quot;)) return CW_TYPE_TRADITIONAL;
+		if (gpxType.equals(GC_GPX_MULTI) || gpxType.equals(&quot;Multi&quot;) || gpxType.equals(&quot;Offset&quot;)) return CW_TYPE_MULTI;
+		if (gpxType.equals(GC_GPX_VIRTUAL) || gpxType.equals(&quot;Virtual&quot;)) return CW_TYPE_VIRTUAL;
+		if (gpxType.equals(GC_GPX_LETTERBOX)) return CW_TYPE_LETTERBOX;
+		if (gpxType.equals(GC_GPX_EVENT) || gpxType.equals(&quot;Event&quot;)) return CW_TYPE_EVENT;
+		if (gpxType.equals(GC_GPX_UNKNOWN) || gpxType.equals(&quot;Other&quot;) || gpxType.equals(&quot;Quiz&quot;)) return CW_TYPE_UNKNOWN;
+		if (gpxType.equals(GC_GPX_WEBCAM) || gpxType.equals(&quot;Webcam&quot;)) return CW_TYPE_WEBCAM;
+		if (gpxType.equals(GC_GPX_LOCATIONLESS)) return CW_TYPE_LOCATIONLESS;
+		if (gpxType.equals(GC_GPX_CITO)) return CW_TYPE_CITO;
+		if (gpxType.equals(GC_GPX_EARTH) || gpxType.equals(&quot;Earth&quot;)) return CW_TYPE_EARTH;
+		if (gpxType.equals(GC_GPX_MEGA_EVENT)) return CW_TYPE_MEGA_EVENT;
+		if (gpxType.equals(GC_GPX_WHEREIGO)) return CW_TYPE_WHEREIGO;
+		if (gpxType.equals(GC_GPX_PARKING)) return CW_TYPE_PARKING;
+		if (gpxType.equals(GC_GPX_STAGE)) return CW_TYPE_STAGE;
+		if (gpxType.equals(GC_GPX_QUESTION)) return CW_TYPE_QUESTION;
+		if (gpxType.equals(GC_GPX_FINAL)||gpxType.equals(&quot;Waypoint|Final Location&quot;)) return CW_TYPE_FINAL;
+		if (gpxType.equals(GC_GPX_TRAILHEAD)) return CW_TYPE_TRAILHEAD;
+		if (gpxType.equals(GC_GPX_REFERENCE)) return CW_TYPE_REFERENCE;
+		if (gpxType.equals(GC_GPX_MAZE)) return CW_TYPE_MAZE;
+		if (gpxType.equals(GC_GPX_APE)) return CW_TYPE_APE;
+		throw new IllegalArgumentException(&quot;unmatched argument &quot;+gpxType+&quot; in CacheSize gpxType2CwType()&quot;);
+	}
+	
+	/**
+	 * convert the cache type information from an OC XML import to internal cache type
+	 * @param ocType cache type found in OC XML
+	 * @return internal cache type
+	 * @throws IllegalArgumentException if &lt;code&gt;ocType&lt;/code&gt; can not be macthed
+	 */
+	public static final byte ocType2CwType(String ocType) throws IllegalArgumentException {
+		if(ocType.equals(&quot;1&quot;)) return CW_TYPE_UNKNOWN;
+		if(ocType.equals(&quot;2&quot;)) return CW_TYPE_TRADITIONAL;
+		if(ocType.equals(&quot;3&quot;)) return CW_TYPE_MULTI;	
+		if(ocType.equals(&quot;4&quot;)) return CW_TYPE_VIRTUAL;
+		if(ocType.equals(&quot;5&quot;)) return CW_TYPE_WEBCAM;
+		if(ocType.equals(&quot;6&quot;)) return CW_TYPE_EVENT;
+		if(ocType.equals(&quot;7&quot;)) return CW_TYPE_UNKNOWN;
+		if(ocType.equals(&quot;8&quot;)) return CW_TYPE_UNKNOWN;
+		if(ocType.equals(&quot;9&quot;)) return CW_TYPE_UNKNOWN;
+		if(ocType.equals(&quot;10&quot;)) return CW_TYPE_UNKNOWN;
+		throw new IllegalArgumentException(&quot;unmatched argument &quot;+ocType+&quot; in CacheSize ocType2CwType()&quot;);
+	}
+	
+	/**
+	 * convert type information discovered by GC spider to internal type information
+	 * @param gcType type information from GC spider
+	 * @return internal representation of cache type
+	 * @throws IllegalArgumentException if &lt;code&gt;gcType&lt;/code&gt; can not be matched
+	 */
+	public static final byte gcSpider2CwType(String gcType) throws IllegalArgumentException {
+		if (gcType.equals(&quot;2&quot;)) { return CW_TYPE_TRADITIONAL; }
+		if (gcType.equals(&quot;3&quot;)) { return CW_TYPE_MULTI; }
+		if (gcType.equals(&quot;4&quot;)) { return CW_TYPE_VIRTUAL; }
+		if (gcType.equals(&quot;5&quot;)) { return CW_TYPE_LETTERBOX; }
+		if (gcType.equals(&quot;6&quot;)) { return CW_TYPE_EVENT; }
+		if (gcType.equals(&quot;8&quot;)) { return CW_TYPE_UNKNOWN; }
+		if (gcType.equals(&quot;9&quot;)) { return CW_TYPE_APE; }
+		if (gcType.equals(&quot;11&quot;)) { return CW_TYPE_WEBCAM; }
+		if (gcType.equals(&quot;12&quot;)) { return CW_TYPE_LOCATIONLESS; }
+		if (gcType.equals(&quot;13&quot;)) { return CW_TYPE_CITO; }
+		if (gcType.equals(&quot;137&quot;)) { return CW_TYPE_EARTH; }
+		if (gcType.equals(&quot;453&quot;)) { return CW_TYPE_MEGA_EVENT; }
+		if (gcType.equals(&quot;1304&quot;)) { return CW_TYPE_MAZE; }
+		if (gcType.equals(&quot;1858&quot;)) { return CW_TYPE_WHEREIGO; }
+		throw new IllegalArgumentException(&quot;unmatched argument &quot;+gcType+&quot; in CacheSize gcSpider2CwType()&quot;);
+	}
+	
+	/**
+	 * map cache types to images
+	 * @param id internal cache type id
+	 * @return non qualified name of image
+	 * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; can not be matched
+	 */
+	public static final String typeImageForId(byte id) throws IllegalArgumentException {
+		switch (id) {
+		case CW_TYPE_CUSTOM: return &quot;CW_GUIIMG_CUSTOM&quot;;
+		case CW_TYPE_TRADITIONAL: return CW_GUIIMG_TRADITIONAL;
+		case CW_TYPE_MULTI: return CW_GUIIMG_MULTI;
+		case CW_TYPE_VIRTUAL: return CW_GUIIMG_VIRTUAL;
+		case CW_TYPE_LETTERBOX: return CW_GUIIMG_LETTERBOX;
+		case CW_TYPE_EVENT: return CW_GUIIMG_EVENT;
+		case CW_TYPE_WEBCAM: return CW_GUIIMG_WEBCAM;
+		case CW_TYPE_UNKNOWN: return CW_GUIIMG_UNKNOWN;
+		case CW_TYPE_LOCATIONLESS: return CW_GUIIMG_LOCATIONLESS;
+		case CW_TYPE_CITO: return CW_GUIIMG_CITO;
+		case CW_TYPE_EARTH: return CW_GUIIMG_EARTH;
+		case CW_TYPE_MEGA_EVENT: return CW_GUIIMG_MEGA_EVENT;
+		case CW_TYPE_WHEREIGO: return CW_GUIIMG_WHEREIGO;
+		case CW_TYPE_PARKING: return CW_GUIIMG_PARKING;
+		case CW_TYPE_STAGE: return CW_GUIIMG_STAGE;
+		case CW_TYPE_QUESTION: return CW_GUIIMG_QUESTION;
+		case CW_TYPE_FINAL: return CW_GUIIMG_FINAL;
+		case CW_TYPE_TRAILHEAD: return CW_GUIIMG_TRAILHEAD;
+		case CW_TYPE_REFERENCE: return CW_GUIIMG_REFERENCE;
+		case CW_TYPE_APE: return CW_GUIIMG_APE;
+		case CW_TYPE_MAZE: return CW_GUIIMG_MAZE;
+		default: throw new IllegalArgumentException(&quot;unmatched argument &quot;+id+&quot; in CacheSize typeImageForId()&quot;);
+		}
+	}
+	
+	/**
+	 * generate type description matching those of GC for GPX export
+	 * @param id internal type id
+	 * @return type information in GC.com GPX format 
+	 * @throws IllegalArgumentException
+	 */
+	public static final String id2GpxString(byte id) throws IllegalArgumentException {
+		switch (id) {
+		case CW_TYPE_TRADITIONAL: return GC_GPX_TRADITIONAL;
+		case CW_TYPE_MULTI: return GC_GPX_MULTI;
+		case CW_TYPE_VIRTUAL: return GC_GPX_VIRTUAL;
+		case CW_TYPE_LETTERBOX: return GC_GPX_LETTERBOX;
+		case CW_TYPE_EVENT: return GC_GPX_EVENT;
+		case CW_TYPE_UNKNOWN: return GC_GPX_UNKNOWN;
+		case CW_TYPE_WEBCAM: return GC_GPX_WEBCAM;
+		case CW_TYPE_LOCATIONLESS: return GC_GPX_LOCATIONLESS;
+		case CW_TYPE_CITO: return GC_GPX_CITO;
+		case CW_TYPE_EARTH: return GC_GPX_EARTH;
+		case CW_TYPE_MEGA_EVENT: return GC_GPX_MEGA_EVENT;
+		case CW_TYPE_WHEREIGO: return GC_GPX_WHEREIGO;
+		case CW_TYPE_PARKING: return GC_GPX_PARKING;
+		case CW_TYPE_STAGE: return GC_GPX_STAGE;
+		case CW_TYPE_QUESTION: return GC_GPX_QUESTION;
+		case CW_TYPE_FINAL: return GC_GPX_FINAL;
+		case CW_TYPE_TRAILHEAD: return GC_GPX_TRAILHEAD;
+		case CW_TYPE_REFERENCE: return GC_GPX_REFERENCE;
+		case CW_TYPE_MAZE: return GC_GPX_MAZE;
+		case CW_TYPE_APE: return GC_GPX_APE;
+		default: throw new IllegalArgumentException(&quot;unmatched argument &quot;+id+&quot; in CacheSize id2GpxString()&quot;);
+		}
+		
+	}
+	
+	//TODO: do we actually need this one
+	/**
+	 * generate human readable type description for exporters
+	 * @param id internal type id
+	 * @return human readable description of waypoint type for exporters  
+	 * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; is not a valid cache type
+	 */
+	public static final String cw2ExportString(byte id) throws IllegalArgumentException {
+		String ret;
+		try {
+			ret = id2GpxString(id);
+			// check for | in additional waypoints and only use the string after |
+			int pipePosistion = ret.indexOf(&quot;|&quot;);
+			if (pipePosistion &gt; -1) {
+				ret = ret.substring(pipePosistion);
+			}
+		} catch (IllegalArgumentException ex) {
+			ret = &quot;&quot;;
+		}
+		return ret;
+	}
+}

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/CalcPanel.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -62,9 +62,9 @@
 		cacheDB = profile.cacheDB;
 		
 		
-		TopP.addNext(chkDD =new mCheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMM =new mCheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMS =new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
+		TopP.addNext(chkDD =new mCheckBox(&quot;d.d&#239;&#191;&#189;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMM =new mCheckBox(&quot;d&#239;&#191;&#189;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMS =new mCheckBox(&quot;d&#239;&#191;&#189;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
 		TopP.addNext(chkUTM =new mCheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
 		TopP.addLast(chkGK =new mCheckBox(&quot;GK&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
 
@@ -200,7 +200,7 @@
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				ch.LatLon = coordOut.toString();
 				ch.pos.set(coordOut);
-				ch.setType(51); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				ch.setType(CacheType.CW_TYPE_STAGE); // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/DetailsPanel.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -17,7 +17,7 @@
 	mInput inpHidden = new mInput();
 	mInput inpOwner = new mInput();
 	mButton btnDelete,btnCenter, btnAddDateTime;
-	mChoice chcType = new mChoice(new String[]{&quot;Custom&quot;, &quot;Traditional&quot;, &quot;Multi&quot;, &quot;Virtual&quot;, &quot;Letterbox&quot;, &quot;Event&quot;, &quot;Mega Event&quot;, &quot;Mystery&quot;, &quot;Webcam&quot;, &quot;Locationless&quot;, &quot;CITO&quot;, &quot;Earthcache&quot;, &quot;wherIGo&quot;, &quot;Addi: Parking&quot;, &quot;Addi: Stage&quot;, &quot;Addi: Question&quot;, &quot;Addi: Final&quot;,&quot;Addi: Trailhead&quot;,&quot;Addi: Reference&quot;},0);
+	mChoice chcType = new mChoice(CacheType.guiTypeStrings(),0);
 	mChoice chcSize = new mChoice(CacheSize.guiSizeStrings(),0);
 	mComboBox chcStatus = new mComboBox(new String[]{&quot;&quot;, MyLocale.getMsg(313,&quot;Flag 1&quot;), MyLocale.getMsg(314,&quot;Flag 2&quot;), MyLocale.getMsg(315,&quot;Flag 3&quot;), MyLocale.getMsg(316,&quot;Flag 4&quot;), MyLocale.getMsg(317,&quot;Search&quot;), MyLocale.getMsg(318,&quot;Found&quot;), MyLocale.getMsg(319,&quot;Not Found&quot;), MyLocale.getMsg(320,&quot;Owner&quot;)},0);
 	mButton btnNewWpt, btnShowBug, btnShowMap, btnGoto, btnAddPicture, btnBlack, btnNotes, btnSave, btnCancel;
@@ -189,7 +189,7 @@
 			// If the cache status contains a date, do not overwrite it with 'found' message
 			if(ch.is_found() == true) chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;));
 		}
-		chcType.setInt(transType(ch.getType()));
+		chcType.setInt(CacheType.cw2GuiSelect(ch.getType()));
 		if(ch.is_black()){
 			btnBlack.image = imgBlack;
 		} else {
@@ -217,87 +217,14 @@
 		if(isBigScreen)	mNotes.setText(ch.getExistingDetails().getCacheNotes());
 	}
 	
-	
 	/**
-	*	Translate the cache type to the value in the cache type dropdown
-	*	control.
-	*/
-	private int transType(int type){
-		// TODO Hab ich so eine &#220;bersetzungstabelle nicht schon an anderer Stelle gesehen ??? Redundanz ??
-		int c_type = 0;
-		int tt = 0;
-		tt = type;
-		switch(tt){
-			case 0: c_type = 0; break;
-			case 2: c_type = 1; break;
-			case 3: c_type = 2; break;
-			case 4: c_type = 3; break;
-			case 5: c_type = 4; break;
-			case 6: c_type = 5; break;
-			case 453: c_type = 6;break;
-			case 8: c_type = 7; break;
-			case 11: c_type = 8; break; //Earth
-			case 12: c_type = 9; break;
-			case 13: c_type = 10; break;
-			case 137: c_type = 11;break;
-			case 1858: c_type = 12; break;
-			case 50: c_type = 13;break;
-			case 51: c_type = 14;break;
-			case 52: c_type = 15;break;
-			case 53: c_type = 16;break;
-			case 54: c_type = 17;break;
-			case 55: c_type = 18;break;
-
-			default: Vm.debug(&quot;Unknown cachetype: &quot; + type);
-					break;
-		}
-		return c_type;
-	}
-	
-	/**
-	*	Method to translate a selected cache type in the drop down control
-	*	to a &quot;true&quot; cache type.&lt;br&gt;
-	*	This transformation is required to ease the display of the cache type
-	*	icon in the table display.
-	*/
-	public int transSelect(int num){
-		int ret = 0;
-		switch(num){
-			case 0: ret = 0; break;
-			case 1: ret = 2; break;
-			case 2: ret = 3; break;
-			case 3: ret = 4; break;
-			case 4: ret = 5; break;
-			case 5: ret = 6; break;
-			case 6: ret = 453; break;
-			case 7: ret = 8; break;
-			case 8: ret = 11; break;
-			case 9: ret = 12; break;
-			case 10: ret = 13; break;
-			case 11: ret = 137; break;
-			case 12: ret = 1858; break;
-			case 13: ret = 50; break;
-			case 14: ret = 51; break;
-			case 15: ret = 52; break;
-			case 16: ret = 53; break;
-			case 17: ret = 54; break;
-			case 18: ret = 55; break;
-
-			default: Vm.debug(&quot;Unknown cachetype: &quot; + num);
-			break;
-
-		} //switch
-		return ret;
-	}
-	
-	/**
 	 * if is addi -&gt; returns the respective AddiWpt
 	 * if is main -&gt; returns the respective MainWpt 
 	 *
 	 */
 	public void createWptName() {
 		String wpt = inpWaypoint.getText().toUpperCase();
-		if (CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp; 
+		if (CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) &amp;&amp; 
 				(Global.mainTab.mainCache.startsWith(&quot;GC&quot;)||Global.mainTab.mainCache.startsWith(&quot;OC&quot;)||Global.mainTab.mainCache.startsWith(&quot;CW&quot;)) &amp;&amp;
 				wpt.startsWith(&quot;CW&quot;)) {
 			// for what was this?:
@@ -305,7 +232,7 @@
 			
 			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(Global.mainTab.mainCache));
 		} 
-		if (!CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp; !(wpt.startsWith(&quot;GC&quot;) 
+		if (!CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) &amp;&amp; !(wpt.startsWith(&quot;GC&quot;) 
 				|| wpt.startsWith(&quot;OC&quot;) || wpt.startsWith(&quot;CW&quot;)) ) {
 			inpWaypoint.setText(Global.getProfile().getNewWayPointName());
 		}
@@ -394,7 +321,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = thisCache.LatLon;
 				ch.pos = new CWPoint( thisCache.pos );
-				ch.setType(51);
+				ch.setType(CacheType.CW_TYPE_STAGE);
 				Global.mainTab.newWaypoint(ch);
 			}
 			else if (ev.target == btnGoto){
@@ -496,8 +423,8 @@
 		  thisCache.setCacheName(inpName.getText().trim());
 		  thisCache.LatLon = thisCache.pos.toString();
 		  thisCache.setDateHidden(inpHidden.getText().trim());
-		  int oldType=thisCache.getType();
-		  thisCache.setType(transSelect(chcType.getInt()));
+		  byte oldType=thisCache.getType();
+		  thisCache.setType(CacheType.guiSelect2Cw(chcType.getInt()));
 		 // thisCache.saveCacheDetails(profile.dataDir); // this is redundant, because all changes affecting the details are immediately saved
 		  // Now update the table
 		  CacheHolder ch = thisCache; // TODO variable ch is redundant

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/FilterScreen.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -15,18 +15,18 @@
 	private static final Color COLOR_FILTERACTIVE=new Color(0,255,0);
 	private static final Color COLOR_FILTERALL=new Color(255,0,0); // Red
     	
-	private mButton btnCancel, btnApply,btnRoute,
-				    btnSaveFlt, btnDelFlt,
-					btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnSearch,btnAddi, btnSelect,btnDeselect,btnCacheAttributes;
+	private mButton btnCancel, btnApply, btnRoute, btnSaveFlt, btnDelFlt,
+					btnBearing, btnTypes, btnAttributes, btnRatings, btnContainer, btnSearch,
+					btnAddi, btnSelect, btnDeselect, btnCacheAttributes;
 	
 	private mChoice chcDist, chcDiff, chcTerr, chcAttrib;
 	private mCheckBox chkFound, chkNotFound, chkTrad, chkVirtual, chkEvent, chkEarth, chkMega,
 					  chkOwned, chkNotOwned, chkMulti, chkLetter, chkWebcam, chkMystery, chkLocless,
-	                  chkCustom,chkParking,	chkStage, chkQuestion, chkFinal, chkTrailhead, chkReference,
+	                  chkCustom, chkParking, chkStage, chkQuestion, chkFinal, chkTrailhead, chkReference,
 					  chkMicro,chkSmall,chkRegular,chkLarge,chkVeryLarge,chkOther,chkCito,
-	                  chkArchived,chkNotArchived, chkAvailable,chkNotAvailable,
+	                  chkArchived, chkNotArchived, chkAvailable, chkNotAvailable,
 					  chkNW, chkNNW , chkN , chkNNE, chkNE, chkENE, chkE, chkESE, chkSE, chkSSE, chkS,
-					  chkSSW, chkSW, chkWSW, chkW, chkWNW,chkWherigo;
+					  chkSSW, chkSW, chkWSW, chkW, chkWNW, chkWherigo;
 	private mComboBox chcStatus, fltList;
 	private mCheckBox chkUseRegexp;
 	

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/GPXImporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -386,7 +386,7 @@
 		
 		// aditional wapypoint
 		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
-			holder.setType(CacheType.typeText2Number(strData));
+			holder.setType(CacheType.gpxType2CwType(strData));
 			holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 		}
 		
@@ -408,7 +408,7 @@
 			return;
 		}
 		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){
-			holder.setType(CacheType.typeText2Number(strData));
+			holder.setType(CacheType.gpxType2CwType(strData));
 			return;
 		}
 		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){

Copied: trunk/src/CacheWolf/GuiImageBroker.java (from rev 1817, experiments/greiol/src/CacheWolf/GuiImageBroker.java)

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/MainTab.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -305,7 +305,7 @@
 			profile.setAddiRef(pCh);
 		} else { 
 			pCh.setWayPoint(profile.getNewWayPointName());
-			pCh.setType(0);
+			pCh.setType(CacheType.CW_TYPE_CUSTOM);
 			lastselected=pCh.getWayPoint();
 		}
 		pCh.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -354,7 +354,7 @@
 			cacheID = atts.getValue(&quot;id&quot;);
 		}
 		if(name.equals(&quot;type&quot;)){
-			holder.setType(CacheType.transOCType(new Integer(atts.getValue(&quot;id&quot;)).intValue())); 
+			holder.setType(CacheType.ocType2CwType(atts.getValue(&quot;id&quot;)));
 			return;
 		}
 		if(name.equals(&quot;status&quot;)){

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/Parser.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -691,10 +691,10 @@
 				String stage=MyLocale.formatLong(i,&quot;00&quot;);
 				String stageWpt=&quot;$&quot;+stage+waypointName.substring(2);
 				String stageName = &quot;Stage &quot;+(i+1);
-				int type = 51;
+				byte type = CacheType.CW_TYPE_STAGE;
 				if (i == nStages - 1) {
 					stageName = &quot;Final&quot;;
-					type = 53;
+					type = CacheType.CW_TYPE_FINAL;
 				}
 				didCreateWp|=createWptIfNeeded(stage+waypointName.substring(2), stageName, type);
 				op.append(&quot;IF &quot;+stageWpt+&quot;=\&quot;\&quot; THEN\n&quot;);
@@ -1095,7 +1095,7 @@
 		}
 	}
 
-	private boolean createWptIfNeeded(String wayPoint, String name, int type){
+	private boolean createWptIfNeeded(String wayPoint, String name, byte type){
 	   	int ci=Global.getProfile().getCacheIndex(wayPoint);
     	if (ci &gt;= 0) return false;
 

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/RadarPanel.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -132,9 +132,9 @@
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=CacheType.cache2Img(holder.getType());
+					Image imgCache=GuiImageBroker.getTypeImage(holder.getType());
 					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=CacheType.cache2Img(8); 
+					if (imgCache==null) imgCache=GuiImageBroker.getTypeImage(CacheType.CW_TYPE_UNKNOWN); 
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;

Modified: trunk/src/CacheWolf/ShowCacheInBrowser.java
===================================================================
--- trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/ShowCacheInBrowser.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -65,9 +65,9 @@
 			if(chD.isVisible()){
 				Vm.showWait(true);
 				try {
-					if (chD.getWayPoint().startsWith(&quot;OC&quot;))
-						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+FileBase.getProgramDirectory()+&quot;/&quot;+CacheType.transOCType(chD.getType())+&quot;.gif\&quot;&quot;);
-					else	
+//					if (chD.getWayPoint().startsWith(&quot;OC&quot;))
+//						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+FileBase.getProgramDirectory()+&quot;/&quot;+CacheType.transOCType(chD.getType())+&quot;.gif\&quot;&quot;);
+//					else	
 						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+FileBase.getProgramDirectory()+&quot;/&quot;+chD.getType()+&quot;.gif\&quot;&quot;);
 					tpl.setParam(&quot;SIZE&quot;, CacheSize.cw2ExportString(chD.getCacheSize()));
 					tpl.setParam(&quot;WAYPOINT&quot;, chD.getWayPoint());
@@ -193,7 +193,7 @@
 							addis.put(&quot;WAYPOINT&quot;,ch.getWayPoint());
 							addis.put(&quot;NAME&quot;,ch.getCacheName());
 							addis.put(&quot;LATLON&quot;,ch.LatLon);
-							addis.put(&quot;IMG&quot;,&quot;&lt;img src=\&quot;&quot;+CacheType.type2pic(ch.getType())+&quot;\&quot;&gt;&quot;);
+							addis.put(&quot;IMG&quot;,&quot;&lt;img src=\&quot;&quot;+CacheType.typeImageForId(ch.getType())+&quot;\&quot;&gt;&quot;);
 							addis.put(&quot;LONGDESC&quot;,ch.getExistingDetails().LongDescription); // Do we need to treat longDesc as above ?
 							addiVect.add(addis);
 						}

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/SpiderGC.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -969,10 +969,10 @@
 	 * @param doc A previously fetched cachepage
 	 * @return the waypoint type (Tradi, Multi, etc.)
 	 */
-	private int getType(String doc) throws Exception{
+	private byte getType(String doc) throws Exception {
 		inRex = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
 		inRex.search(doc);
-		if(inRex.didMatch()) return new Integer(inRex.stringMatched(1)).intValue();
+		if(inRex.didMatch()) return CacheType.gcSpider2CwType(inRex.stringMatched(1));
 		else return 0;
 	}
 
@@ -982,7 +982,7 @@
 	 * @param chD Cache Details
 	 * @return A HTML string containing the logs
 	 */
-	private LogList getLogs(String doc, CacheHolderDetail chD) throws Exception{
+	private LogList getLogs(String doc, CacheHolderDetail chD) throws Exception {
 		String icon = &quot;&quot;;
 		String name = &quot;&quot;;
 		String logText = &quot;&quot;;
@@ -1331,7 +1331,7 @@
 				typeRex.search(rowBlock);
 				hd.setCacheName(nameRex.stringMatched(1));
 				if(koordRex.didMatch()) hd.setLatLon(koordRex.stringMatched(1));
-				if(typeRex.didMatch()) hd.setType(CacheType.typeText2Number(&quot;Waypoint|&quot;+typeRex.stringMatched(1)));
+				if(typeRex.didMatch()) hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot;+typeRex.stringMatched(1)));
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
 				hd.getFreshDetails().setLongDescription(descRex.stringMatched(1));

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -110,7 +110,7 @@
 		CacheHolder ch=Global.getProfile().cacheDB.get(wayPoint);
 		if (ch != null) {
 			 IconAndText icnDrag=new IconAndText();
-			 icnDrag.addColumn(CacheType.cache2Img(ch.getType()));
+			 icnDrag.addColumn(GuiImageBroker.getTypeImage(ch.getType()));
 			 icnDrag.addColumn(ch.getWayPoint());
 			 dc.dragData=dc.startImageDrag(icnDrag,new Point(8,8),this);
 			 //if (dc instanceof ImageDragContext) Vm.debug(&quot;&gt;&gt;&gt;&gt;Is Image drag&quot;);

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/myTableControl.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -298,7 +298,7 @@
 			 wayPoint=ch.getWayPoint();
 			 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
 			 imgDrag=new IconAndText();
-			 imgDrag.addColumn(CacheType.cache2Img(ch.getType()));
+			 imgDrag.addColumn(GuiImageBroker.getTypeImage(ch.getType()));
 			 imgDrag.addColumn(ch.getWayPoint());
 			 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
 		 } else super.startDragging(dc);

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/myTableModel.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -291,7 +291,7 @@
 						else 
 							return checkboxUnticked;
 					case 1: // Type
-						return CacheType.cache2Img(ch.getType());
+						return GuiImageBroker.getTypeImage(ch.getType());
 					case 2: // Difficulty;
 						return ch.getHard();
 					case 3: // Terrain

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -3,6 +3,7 @@
 import CacheWolf.CWPoint;
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
+import CacheWolf.CacheType;
 import CacheWolf.CoordsScreen;
 import CacheWolf.DetailsPanel;
 import CacheWolf.Global;
@@ -92,11 +93,11 @@
 		//Format selection for coords		
 		//context menu
 		mnuContextFormt = new Menu();
-		mnuContextFormt.addItem(miDD = new MenuItem(&quot;d.d&#176;&quot;));
+		mnuContextFormt.addItem(miDD = new MenuItem(&quot;d.d&#239;&#191;&#189;&quot;));
 		miDD.modifiers &amp;= ~MenuItem.Checked;
-		mnuContextFormt.addItem(miDMM = new MenuItem(&quot;d&#176;m.m\'&quot;));
+		mnuContextFormt.addItem(miDMM = new MenuItem(&quot;d&#239;&#191;&#189;m.m\'&quot;));
 		miDMM.modifiers |= MenuItem.Checked;
-		mnuContextFormt.addItem(miDMS = new MenuItem(&quot;d&#176;m\'s\&quot;&quot;));
+		mnuContextFormt.addItem(miDMS = new MenuItem(&quot;d&#239;&#191;&#189;m\'s\&quot;&quot;));
 		miDMS.modifiers &amp;= ~MenuItem.Checked;
 		mnuContextFormt.addItem(miUTM = new MenuItem(&quot;UTM&quot;));
 		miUTM.modifiers &amp;= ~MenuItem.Checked;
@@ -171,7 +172,7 @@
 
 		//while (true){
 //		int notinterpreted = 0;
-//		if (myGPS.examine(&quot;@&#246;&#246;H @&#246;&#246;H&#246;@&#214;&#214;HH&#220;&#196;&#220;&#214;&#196;&#196;&#196;H&quot;)) { notinterpreted = 0;} else notinterpreted++;
+//		if (myGPS.examine(&quot;@&#239;&#191;&#189;&#239;&#191;&#189;H @&#239;&#191;&#189;&#239;&#191;&#189;H&#239;&#191;&#189;@&#239;&#191;&#189;&#239;&#191;&#189;HH&#239;&#191;&#189;&#239;&#191;&#189;&#239;&#191;&#189;&#239;&#191;&#189;&#239;&#191;&#189;&#239;&#191;&#189;&#239;&#191;&#189;H&quot;)) { notinterpreted = 0;} else notinterpreted++;
 //		if (notinterpreted &gt; 5) myGPS.noInterpretableData();
 //		// myGPS.noInterpretableData();
 
@@ -408,7 +409,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = myNavigation.gpsPos.toString();
 				ch.pos = new CWPoint(myNavigation.gpsPos);
-				ch.setType(51); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				ch.setType(CacheType.CW_TYPE_STAGE); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -5,6 +5,7 @@
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheType;
 import CacheWolf.Global;
+import CacheWolf.GuiImageBroker;
 import CacheWolf.InfoBox;
 import CacheWolf.MainTab;
 import CacheWolf.MyLocale;
@@ -380,7 +381,7 @@
 			for (int i=cacheDB.size()-1; i&gt;=0; i--) {
 				ch = cacheDB.get(i);
 				if (ch.is_Checked &amp;&amp; ch.isVisible() &amp;&amp; ch != mainT.ch) {
-					if (ch.pos.isValid()) addSymbol(ch.getCacheName(), ch, CacheType.cache2Img(ch.getType()), ch.pos);
+					if (ch.pos.isValid()) addSymbol(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType()), ch.pos);
 				}
 			}
 		}
@@ -402,7 +403,7 @@
 		}
 		if (ch != null) {
 			addSymbol(&quot;selectedCache&quot;, MARK_CACHE_IMAGE, ch.pos);
-			addSymbolIfNecessary(ch.getCacheName(), ch, CacheType.cache2Img(ch.getType()), ch.pos);
+			addSymbolIfNecessary(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType()), ch.pos);
 		}
 		markedCache = ch;
 	}
@@ -1043,7 +1044,7 @@
 			return;
 		}
 		if (currentMap == null &amp;&amp; newmap == null) {
-			// (new MessageBox(&quot;Information&quot;, &quot;F&#252;r die aktuelle Position steht keine Karte zur Verf&#252;ng, bitte w&#228;hlen Sie eine manuell&quot;, MessageBox.OKB)).execute();
+			// (new MessageBox(&quot;Information&quot;, &quot;F&#239;&#191;&#189;r die aktuelle Position steht keine Karte zur Verf&#239;&#191;&#189;ng, bitte w&#239;&#191;&#189;hlen Sie eine manuell&quot;, MessageBox.OKB)).execute();
 			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
 			try {
 				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
@@ -1082,7 +1083,7 @@
 		if (posCircleX &gt;= 0 &amp;&amp; posCircleX &lt;= w &amp;&amp; posCircleY &gt;= 0 &amp;&amp; posCircleY &lt;= h &amp;&amp; ll.isValid()) {
 			posCircleOnScreen = java.lang.Boolean.TRUE;
 			pX = posCircleX; // posCircle is inside the screen
-			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#252;hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
 		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
 			cll = ScreenXY2LatLon(w/2, h/2);
@@ -1130,7 +1131,7 @@
 	public void loadMapForAllCaches(){
 		Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#228;ckchen ausgew&#228;hlt&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#239;&#191;&#189;ckchen ausgew&#239;&#191;&#189;hlt&quot;), FormBase.OKB)).execute();
 			return;
 		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
@@ -1488,9 +1489,9 @@
 	MenuItem hideMapMI = new MenuItem(MyLocale.getMsg(4240, &quot;Hide map&quot;), new IconAndText(new mImage(&quot;map_off.png&quot;), MyLocale.getMsg(4241, &quot;Hide map&quot;), null, CellConstants.RIGHT));
 	// automatic
 	MenuItem mapChangeModusMI = new MenuItem(MyLocale.getMsg(4242, &quot;Modus for automatic map change&quot;), MenuItem.Separator, null);;
-	MenuItem highestResGpsDestMI = new MenuItem(MyLocale.getMsg(4244, &quot;Highest res. containing dest. &amp; cur. position&quot;), new IconAndText(new mImage(&quot;res_gps_goto.png&quot;), MyLocale.getMsg(4245, &quot;Highest res. containing dest. &amp; cur. position&quot;), null, CellConstants.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen, die akt. Pos. und Ziel enthalten 
-	MenuItem highestResolutionMI = new MenuItem(MyLocale.getMsg(4246, &quot;Highest resolution&quot;), new IconAndText(new mImage(&quot;res_high.png&quot;), MyLocale.getMsg(4247, &quot;Highest resolution&quot;), null, CellConstants.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen 
-	MenuItem keepManResolutionMI = new MenuItem(MyLocale.getMsg(4248, &quot;Keep manual resolution&quot;), new IconAndText(new mImage(&quot;res_manuell.png&quot;), MyLocale.getMsg(4249, &quot;Keep manual resolution&quot;), null, CellConstants.RIGHT)); // manuell gew&#228;hlte Aufl&#246;sung beibehalten  
+	MenuItem highestResGpsDestMI = new MenuItem(MyLocale.getMsg(4244, &quot;Highest res. containing dest. &amp; cur. position&quot;), new IconAndText(new mImage(&quot;res_gps_goto.png&quot;), MyLocale.getMsg(4245, &quot;Highest res. containing dest. &amp; cur. position&quot;), null, CellConstants.RIGHT)); //immer h&#239;&#191;&#189;chste Aufl&#239;&#191;&#189;sung w&#239;&#191;&#189;hlen, die akt. Pos. und Ziel enthalten 
+	MenuItem highestResolutionMI = new MenuItem(MyLocale.getMsg(4246, &quot;Highest resolution&quot;), new IconAndText(new mImage(&quot;res_high.png&quot;), MyLocale.getMsg(4247, &quot;Highest resolution&quot;), null, CellConstants.RIGHT)); //immer h&#239;&#191;&#189;chste Aufl&#239;&#191;&#189;sung w&#239;&#191;&#189;hlen 
+	MenuItem keepManResolutionMI = new MenuItem(MyLocale.getMsg(4248, &quot;Keep manual resolution&quot;), new IconAndText(new mImage(&quot;res_manuell.png&quot;), MyLocale.getMsg(4249, &quot;Keep manual resolution&quot;), null, CellConstants.RIGHT)); // manuell gew&#239;&#191;&#189;hlte Aufl&#239;&#191;&#189;sung beibehalten  
 	// manuell
 	MenuItem mapChangeResMI = new MenuItem(MyLocale.getMsg(4250, &quot;Change resolution manually&quot;), MenuItem.Separator, null);;
 	MenuItem AllCachesResMI = new MenuItem(MyLocale.getMsg(4252, &quot;Load a map containing all marked caches&quot;),  new IconAndText(new mImage(&quot;loupe_all.png&quot;), MyLocale.getMsg(4253, &quot;Load a map containing all marked caches&quot;), null, CellConstants.RIGHT));   

Modified: trunk/src/exp/ExploristExporter.java
===================================================================
--- trunk/src/exp/ExploristExporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/ExploristExporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -246,8 +246,8 @@
 		
 		if (!add.equals(&quot;&quot;)) { // Set Picture in Explorist to Virtual
 			sb.append(&quot;Virtual Cache&quot;);
-		} else if (ch.getType() != 8) { // Rewrite Unknown Caches
-			sb.append(CacheType.transType(ch.getType()));
+		} else if (ch.getType() != CacheType.CW_TYPE_UNKNOWN) { // Rewrite Unknown Caches
+			sb.append(CacheType.cw2ExportString(ch.getType()));
 		} else {
 			sb.append(&quot;Mystery Cache&quot;);
 		}

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/Exporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -411,7 +411,7 @@
 
     public static String getShortDetails( CacheHolder ch ) {
     	StringBuffer strBuf = new StringBuffer(7);
-    	strBuf.append(CacheType.shortType(ch.getType()).toLowerCase());			
+    	strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());			
     	if (!ch.isAddiWpt()) {
     		if ( (ch.getHard().length() &gt; 0) &amp;&amp; (ch.getTerrain().length() &gt; 0) ) {
     			strBuf.append(ch.getHard().charAt(0));

Modified: trunk/src/exp/GPXExporter.java
===================================================================
--- trunk/src/exp/GPXExporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/GPXExporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -71,7 +71,7 @@
 				} else {
 					strBuf.append(&quot;    &lt;sym&gt;Geocache&lt;/sym&gt;\r\n&quot;);
 				}
-				strBuf.append(&quot;    &lt;type&gt;Geocache|&quot;).append(CacheType.transType(ch.getType())).append(&quot;&lt;/type&gt;\r\n&quot;);
+				strBuf.append(&quot;    &lt;type&gt;Geocache|&quot;).append(CacheType.id2GpxString(ch.getType())).append(&quot;&lt;/type&gt;\r\n&quot;);
 				String dummyAvailable = ch.is_available() ? STRING_TRUE:STRING_FALSE;
 				String dummyArchived = ch.is_archived() ? STRING_TRUE:STRING_FALSE;
 				strBuf.append(&quot;    &lt;groundspeak:cache id=\&quot;&quot;).append( ch.GetCacheID() ).append( &quot;\&quot; available=\&quot;&quot; ).append( dummyAvailable ).append( &quot;\&quot; archived=\&quot;&quot; ).append( dummyArchived).append( &quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;\r\n&quot;);
@@ -79,7 +79,7 @@
 				strBuf.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:placed_by&gt;\r\n&quot;);
 				//todo low prio: correct owner-id
 				strBuf.append(&quot;      &lt;groundspeak:owner id=\&quot;23\&quot;&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())+&quot;&lt;/groundspeak:owner&gt;\r\n&quot;);
-				strBuf.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.transType(ch.getType())).append(&quot;&lt;/groundspeak:type&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.id2GpxString(ch.getType())).append(&quot;&lt;/groundspeak:type&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(CacheSize.cw2ExportString(ch.getCacheSize())).append(&quot;&lt;/groundspeak:container&gt;\r\n&quot;);
 				//for Colorado/Oregon: 2.0 -&gt; 2
 				String diffTerr = ch.getHard().replace(',','.');
@@ -149,8 +149,8 @@
 				strBuf.append(&quot;    &lt;/groundspeak:cache&gt;\r\n&quot;);
 			}else {
 				// there is no HTML in the description of addi wpts
-				strBuf.append(&quot;    &lt;sym&gt;&quot;).append(CacheType.transType(ch.getType())).append(&quot;&lt;/sym&gt;\r\n&quot;);
-				strBuf.append(&quot;    &lt;type&gt;Waypoint|&quot;).append(CacheType.transType(ch.getType())).append(&quot;&lt;/type&gt;\r\n&quot;);
+				strBuf.append(&quot;    &lt;sym&gt;&quot;).append(CacheType.id2GpxString(ch.getType())).append(&quot;&lt;/sym&gt;\r\n&quot;);
+				strBuf.append(&quot;    &lt;type&gt;Waypoint|&quot;).append(CacheType.id2GpxString(ch.getType())).append(&quot;&lt;/type&gt;\r\n&quot;);
 			}
 			strBuf.append(&quot;  &lt;/wpt&gt;\r\n&quot;);
 		}catch(Exception e){

Modified: trunk/src/exp/HTMLExporter.java
===================================================================
--- trunk/src/exp/HTMLExporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/HTMLExporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -84,7 +84,7 @@
 				if(	ch.isVisible()){
 					det=ch.getExistingDetails();
 					varParams = new Hashtable();
-					varParams.put(&quot;TYPE&quot;, CacheType.transType(ch.getType()));
+					varParams.put(&quot;TYPE&quot;, CacheType.cw2ExportString(ch.getType()));
 					varParams.put(&quot;SIZE&quot;, CacheSize.cw2ExportString(ch.getCacheSize()));
 					varParams.put(&quot;WAYPOINT&quot;, ch.getWayPoint());
 					varParams.put(&quot;NAME&quot;, ch.getCacheName());
@@ -100,7 +100,7 @@
 					//We can generate the individual page here!
 					try{
 						Template page_tpl = new Template(template_init_page);
-						page_tpl.setParam(&quot;TYPE&quot;, CacheType.transType(ch.getType()));
+						page_tpl.setParam(&quot;TYPE&quot;, CacheType.cw2ExportString(ch.getType()));
 						page_tpl.setParam(&quot;SIZE&quot;, CacheSize.cw2ExportString(ch.getCacheSize()));
 						page_tpl.setParam(&quot;WAYPOINT&quot;, ch.getWayPoint());
 						page_tpl.setParam(&quot;NAME&quot;, ch.getCacheName());
@@ -116,92 +116,120 @@
 							page_tpl.setParam(&quot;DESCRIPTION&quot;, modifyLongDesc(det,targetDir));
 						else {
 							String dummyText = new String();
+							try {
 							dummyText = STRreplace.replace(det.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;);
+							} catch (NullPointerException e) {
+								dummyText = &quot;CacheWolf Error: Missing Long Description&quot;;
+						}
 							page_tpl.setParam(&quot;DESCRIPTION&quot;,dummyText);
-							
 						}
-						page_tpl.setParam(&quot;HINTS&quot;, det.Hints);
-						page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(det.Hints));
+						try {
+							page_tpl.setParam(&quot;HINTS&quot;, det.Hints);
+						} catch (NullPointerException e) { 
+							page_tpl.setParam(&quot;HINTS&quot;, &quot;CacheWolf Error: Hint information missing&quot;);
+						}
+						try {
+							page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(det.Hints));
+						} catch (NullPointerException e) { 
+							page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(&quot;CacheWolf Error: Hint information missing&quot;));
+						}
+						
 						StringBuffer sb=new StringBuffer(2000);
-						for(int j = 0; j&lt;det.CacheLogs.size(); j++){
-							sb.append(STRreplace.replace(det.CacheLogs.getLog(j).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,null));
-							sb.append(&quot;&lt;br&gt;&quot;);
-							icon=det.CacheLogs.getLog(j).getIcon();
-							if (logIcons.find(icon)&lt;0) logIcons.add(icon); // Add the icon to list of icons to copy to dest directory
-						}
-						page_tpl.setParam(&quot;LOGS&quot;, sb.toString());
-						page_tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(det.getCacheNotes(), &quot;\n&quot;,&quot;&lt;br&gt;&quot;)); 
+						try {
+							for(int j = 0; j&lt;det.CacheLogs.size(); j++){
+								sb.append(STRreplace.replace(det.CacheLogs.getLog(j).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,null));
+								sb.append(&quot;&lt;br&gt;&quot;);
+								icon=det.CacheLogs.getLog(j).getIcon();
+								if (logIcons.find(icon)&lt;0) logIcons.add(icon); // Add the icon to list of icons to copy to dest directory
+							}
+						} catch (Exception e) { Vm.debug(&quot;P &quot;+e); } //TODO: find out what is going wrong and especially why
+						try {
+							page_tpl.setParam(&quot;LOGS&quot;, sb.toString());
+						} catch (Exception e) { Vm.debug(&quot;Q &quot;+e); } //TODO: find out what is going wrong and especially why
+						try {
+							page_tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(det.getCacheNotes(), &quot;\n&quot;,&quot;&lt;br&gt;&quot;));
+						} catch (Exception e) { Vm.debug(&quot;R &quot;+e); } //TODO: find out what is going wrong and especially why
 						// Cache Images
-						cacheImg.clear();
-						for(int j = 0; j&lt;det.Images.size(); j++){
-							imgParams = new Hashtable();
-							String imgFile = new String((String)det.Images.get(j));
-							imgParams.put(&quot;FILE&quot;, imgFile);
-							if (j &lt; det.ImagesText.size())
-								imgParams.put(&quot;TEXT&quot;,det.ImagesText.get(j));
-							else
-								imgParams.put(&quot;TEXT&quot;,imgFile);
-							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
-							cacheImg.add(imgParams);
-						}
-						page_tpl.setParam(&quot;cacheImg&quot;, cacheImg);
-						// Log images
-						logImg.clear();
-						for(int j = 0; j&lt;det.LogImages.size(); j++){
-							logImgParams = new Hashtable();
-							String logImgFile = (String) det.LogImages.get(j);
-							logImgParams.put(&quot;FILE&quot;, logImgFile);
-							if (j &lt; det.LogImagesText.size())
-								logImgParams.put(&quot;TEXT&quot;,det.LogImagesText.get(j));
-							else
-								logImgParams.put(&quot;TEXT&quot;,logImgFile);
-							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
-							logImg.add(logImgParams);
-						}
-						page_tpl.setParam(&quot;logImg&quot;, logImg);
-						// User images
-						usrImg.clear();
-						for(int j = 0; j&lt;det.UserImages.size(); j++){
-							usrImgParams = new Hashtable();
-							String usrImgFile = new String((String)det.UserImages.get(j));
-							usrImgParams.put(&quot;FILE&quot;, usrImgFile);
-							if (j &lt; det.UserImagesText.size())
-								usrImgParams.put(&quot;TEXT&quot;,det.UserImagesText.get(j));
-							else
-								usrImgParams.put(&quot;TEXT&quot;,usrImgFile);
-							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
-							usrImg.add(usrImgParams);
-						}
+						try {
+							cacheImg.clear();
+							for(int j = 0; j&lt;det.Images.size(); j++){
+								imgParams = new Hashtable();
+								String imgFile = new String((String)det.Images.get(j));
+								imgParams.put(&quot;FILE&quot;, imgFile);
+								if (j &lt; det.ImagesText.size())
+									imgParams.put(&quot;TEXT&quot;,det.ImagesText.get(j));
+								else
+									imgParams.put(&quot;TEXT&quot;,imgFile);
+								DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
+								cacheImg.add(imgParams);
+							}
+						} catch (Exception e) { Vm.debug(&quot;S &quot;+e); } //TODO: find out what is going wrong and especially why
+						try {
+							page_tpl.setParam(&quot;cacheImg&quot;, cacheImg);
+							// Log images
+							logImg.clear();
+							for(int j = 0; j&lt;det.LogImages.size(); j++){
+								logImgParams = new Hashtable();
+								String logImgFile = (String) det.LogImages.get(j);
+								logImgParams.put(&quot;FILE&quot;, logImgFile);
+								if (j &lt; det.LogImagesText.size())
+									logImgParams.put(&quot;TEXT&quot;,det.LogImagesText.get(j));
+								else
+									logImgParams.put(&quot;TEXT&quot;,logImgFile);
+								DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
+								logImg.add(logImgParams);
+							}
+						} catch (Exception e) { Vm.debug(&quot;T &quot;+e); } //TODO: find out what is going wrong and especially why
+						try {
+							page_tpl.setParam(&quot;logImg&quot;, logImg);
+							// User images
+							usrImg.clear();
+							for(int j = 0; j&lt;det.UserImages.size(); j++){
+								usrImgParams = new Hashtable();
+								String usrImgFile = new String((String)det.UserImages.get(j));
+								usrImgParams.put(&quot;FILE&quot;, usrImgFile);
+								if (j &lt; det.UserImagesText.size())
+									usrImgParams.put(&quot;TEXT&quot;,det.UserImagesText.get(j));
+								else
+									usrImgParams.put(&quot;TEXT&quot;,usrImgFile);
+								DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
+								usrImg.add(usrImgParams);
+							}
+						} catch (Exception e) { Vm.debug(&quot;U &quot;+e); } //TODO: find out what is going wrong and especially why
+						
 						page_tpl.setParam(&quot;userImg&quot;, usrImg);
 
 						// Map images
 						mapImg.clear();
 						mapImgParams = new Hashtable();
+						
 						String mapImgFile = new String(ch.getWayPoint() + &quot;_map.gif&quot;);
 						// check if map file exists
 						File test = new File(profile.dataDir + mapImgFile);
-						if (test.exists()) {
-							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
-							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
-							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
-							mapImg.add(mapImgParams);
-							
-							mapImgParams = new Hashtable();
-							mapImgFile = ch.getWayPoint() + &quot;_map_2.gif&quot;;
-							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
-							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
-							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
-							mapImg.add(mapImgParams);
-	
-							page_tpl.setParam(&quot;mapImg&quot;, mapImg);
-						}
-
-						
-						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + ch.getWayPoint()+&quot;.html&quot;)));
-						pagefile.print(page_tpl.output());
-						pagefile.close();
+						try {
+							if (test.exists()) {
+								mapImgParams.put(&quot;FILE&quot;, mapImgFile);
+								mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
+								DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+								mapImg.add(mapImgParams);
+								
+								mapImgParams = new Hashtable();
+								mapImgFile = ch.getWayPoint() + &quot;_map_2.gif&quot;;
+								mapImgParams.put(&quot;FILE&quot;, mapImgFile);
+								mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
+								DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+								mapImg.add(mapImgParams);
+		
+								page_tpl.setParam(&quot;mapImg&quot;, mapImg);
+							}
+						} catch (Exception e) { Vm.debug(&quot;V &quot;+e); } //TODO: find out what is going wrong and especially why
+						try {
+							PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + ch.getWayPoint()+&quot;.html&quot;)));
+							pagefile.print(page_tpl.output());
+							pagefile.close();
+						} catch (Exception e) { Vm.debug(&quot;W &quot;+e); }  //TODO: find out what is going wrong and especially why
 					}catch(Exception e){
-						Vm.debug(&quot;Problem writing waypoint html file&quot;);
+						Vm.debug(&quot;Problem writing waypoint html file&quot;+e);
 					}
 				}//if is black, filtered
 			}

Modified: trunk/src/exp/KMLExporter.java
===================================================================
--- trunk/src/exp/KMLExporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/KMLExporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -17,7 +17,7 @@
 import ewe.util.zip.ZipEntry;
 import ewe.util.zip.ZipException;
 import ewe.util.zip.ZipFile;
-import CacheWolf.*;
+import CacheWolf.*; // if we would use public instead of protected we would not need this.
 
 /**
 *	Class to export the cache database (index) to an KML-File
@@ -98,7 +98,7 @@
 					tmp = (Vector)entry.getValue();
 					// skip over empty cachetypes
 					if (tmp.size() == 0) continue;
-					outp.print(startFolder(CacheType.transType(new Integer((String)entry.getKey()).intValue())));
+					outp.print(startFolder(CacheType.cw2ExportString(CacheType.guiSelect2Cw(new Integer((String)entry.getKey()).byteValue()))));
 
 					for(int i = 0; i&lt;tmp.size(); i++){
 						ch = (CacheHolder) tmp.get(i);
@@ -160,15 +160,15 @@
 		for (int i = 0; i &lt; categoryNames.length; i++) {
 			outCacheDB[i] = new Hashtable();
 			// create the roots for the cachetypes
-			for (int j = 0; j &lt; CacheType.wayType.length; j++) {
-				outCacheDB[i].put(CacheType.wayType[j][CacheType.WPT_NUM], new Vector());
+			for (int j = 0; j &lt; CacheType.guiTypeStrings().length; j++) {
+				outCacheDB[i].put(String.valueOf(CacheType.guiSelect2Cw(j)), new Vector());
 			}
 		}
 
 		// fill structure with data from cacheDB
 		for(int i = 0; i&lt;cacheDB.size(); i++){
 			ch=cacheDB.get(i);
-			// TODO Das Argument nach STring zu casten gef&#228;llt mir nicht ganz...
+			// TODO Das Argument nach STring zu casten gef&#239;&#191;&#189;llt mir nicht ganz...
 			if(ch.isVisible() &amp;&amp; !ch.isAddiWpt()){
 				if (ch.is_found()) { tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));}
 				else if (ch.is_owned()) { tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));}
@@ -225,8 +225,8 @@
 			int len;
 			String entName, fileName; 
 
-			for (int i = 0; i &lt; CacheType.wayType.length; i++) {
-				fileName = CacheType.type2pic(Convert.parseInt(CacheType.wayType[i][CacheType.WPT_NUM]));
+			for (int i = 0; i &lt; CacheType.guiTypeStrings().length; i++) {
+				fileName = CacheType.typeImageForId(CacheType.guiSelect2Cw(i));
 				entName = &quot;GoogleEarthIcons/&quot; + fileName;
 				zipEnt = zif.getEntry(entName);
 				if (zipEnt == null) continue;
@@ -284,7 +284,7 @@
 		strBuf.append(&quot;      &lt;IconStyle&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;Icon&gt;\r\n&quot;);
 //		strBuf.append(&quot;            &lt;href&gt;&quot;+ File.getProgramDirectory()+ &quot;/&quot; + CacheType.type2pic(Convert.parseInt(ch.type))+ &quot;&lt;/href&gt;\r\n&quot;);
-		strBuf.append(&quot;            &lt;href&gt;&quot;+ CacheType.type2pic(ch.getType())+ &quot;&lt;/href&gt;\r\n&quot;);
+		strBuf.append(&quot;            &lt;href&gt;&quot;+ CacheType.typeImageForId(ch.getType())+ &quot;&lt;/href&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;/Icon&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;/IconStyle&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;LabelStyle&gt;\r\n&quot;);

Modified: trunk/src/exp/MSARCSVExporter.java
===================================================================
--- trunk/src/exp/MSARCSVExporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/MSARCSVExporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -5,7 +5,7 @@
 /**
  * Class to export the cache database (index) to an CSV File which can bei easy
  * importet bei MS AutoRoute (testet with AR 2001 German) Format of the file:
- * Name;Breitengrad;L&#239;&#191;&#189;ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink
+ * Name;Breitengrad;L&#228;ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink
  * 
  */
 public class MSARCSVExporter extends Exporter {
@@ -26,7 +26,7 @@
 		StringBuffer str = new StringBuffer(200);
 		str.append(&quot;\&quot;&quot; + ch.getWayPoint() + &quot; - &quot; + ch.getCacheName() + &quot;\&quot;;&quot;);
 		str.append(lat + &quot;;&quot; + lon +&quot;;&quot;);
-		str.append(&quot;\&quot;&quot; + CacheType.transType(ch.getType())+ &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + CacheType.cw2ExportString(ch.getType())+ &quot;\&quot;;&quot;);
 		str.append(&quot;\&quot;&quot; + CacheSize.cw2ExportString(ch.getCacheSize()) + &quot;\&quot;;&quot;);
 		str.append(&quot;\&quot;&quot; + ch.getWayPoint() + &quot;\&quot;;&quot;);
 		str.append(&quot;\&quot;&quot; + ch.getDateHidden() + &quot;\&quot;;&quot;);

Modified: trunk/src/exp/TPLExporter.java
===================================================================
--- trunk/src/exp/TPLExporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/TPLExporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -194,8 +194,8 @@
 						Regex dec = new Regex(&quot;[,.]&quot;,myFilter.decSep);
 						if (myFilter.badChars != null) rex = new Regex(&quot;[&quot;+myFilter.badChars+&quot;]&quot;,&quot;&quot;);
 						varParams = new Hashtable();
-						varParams.put(&quot;TYPE&quot;, CacheType.transType(ch.getType()));
-						varParams.put(&quot;SHORTTYPE&quot;, CacheType.transType(ch.getType()).substring(0,1));
+						varParams.put(&quot;TYPE&quot;, CacheType.cw2ExportString(ch.getType()));
+						varParams.put(&quot;SHORTTYPE&quot;, CacheType.getExportShortId(ch.getType()));
 						varParams.put(&quot;SIZE&quot;, CacheSize.cw2ExportString(ch.getCacheSize()));
 						varParams.put(&quot;SHORTSIZE&quot;, CacheSize.getExportShortId(ch.getCacheSize()));
 						varParams.put(&quot;WAYPOINT&quot;, ch.getWayPoint());

Modified: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2009-05-17 18:41:01 UTC (rev 1817)
+++ trunk/src/exp/TomTomExporter.java	2009-05-17 19:10:50 UTC (rev 1818)
@@ -85,14 +85,14 @@
 		ext = format==TT_ASC?&quot;.asc&quot;:&quot;.ov2&quot;;
 		try{
 			//loop through type
-			for(int j = 0; j &lt; CacheType.wayType.length; j++){
-				fileName = dirName + &quot;/&quot; + prefix + CacheType.wayType[j][TT_WPT_TEXT]+ ext;
+			for(int j = 0; j &lt; CacheType.guiTypeStrings().length; j++){
+				fileName = dirName + &quot;/&quot; + prefix + CacheType.guiTypeStrings()[j]+ ext;
 				dfile = new File(fileName);
 				dfile.delete();
 				out =  new RandomAccessFile(fileName,&quot;rw&quot;);
 				for(int i = 0; i&lt;cacheDB.size(); i++){
 					holder=cacheDB.get(i);
-					if(holder.getType() == new Integer(CacheType.wayType[j][TT_WPT_NUM]).intValue() &amp;&amp; holder.isVisible() == false){
+					if(holder.getType() == new Integer(CacheType.guiSelect2Cw(j)).intValue() &amp;&amp; holder.isVisible() == false){
 						currExp++;
 						h.progress = (float)currExp/(float)counter;
 						h.changed();
@@ -110,7 +110,7 @@
 				if (dfile.length()==0) {
 					dfile.delete();
 				} else {
-					copyIcon(j, dirName + &quot;/&quot; + prefix + CacheType.wayType[j][TT_WPT_TEXT]); 
+					copyIcon(j, dirName + &quot;/&quot; + prefix + CacheType.guiTypeStrings()[j]); 
 				}
 			}//for wayType
 			pbf.exit(0);
@@ -259,7 +259,7 @@
 			int len;
 			String entName; 
 			
-			entName = &quot;TomTomIcons/&quot;+ &quot;GC-&quot; + CacheType.wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot;;
+			entName = &quot;TomTomIcons/&quot;+ &quot;GC-&quot; + CacheType.guiTypeStrings()[intWayType] + &quot;.bmp&quot;;
 			zipEnt = zif.getEntry(entName);
 			if (zipEnt == null) return;
 			
@@ -272,10 +272,10 @@
 		    fos.close();
 		    fis.close();
 		} catch (ZipException e) {
-			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot; );
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.guiTypeStrings()[intWayType] + &quot;.bmp&quot; );
 			e.printStackTrace();
 		} catch (IOException e) {
-			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot; );
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.guiTypeStrings()[intWayType] + &quot;.bmp&quot; );
 			e.printStackTrace();
 		}
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001735.html">[Cachewolf-svn] r1817 - experiments/greiol/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="001737.html">[Cachewolf-svn] r1819 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1736">[ date ]</a>
              <a href="thread.html#1736">[ thread ]</a>
              <a href="subject.html#1736">[ subject ]</a>
              <a href="author.html#1736">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
