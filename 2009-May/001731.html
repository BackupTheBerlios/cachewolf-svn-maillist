<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1813 - in trunk: res_noewe/languages resources	src/CacheWolf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1813%20-%20in%20trunk%3A%20res_noewe/languages%20resources%0A%09src/CacheWolf&In-Reply-To=%3C200905161814.n4GIE5bk007484%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001730.html">
   <LINK REL="Next"  HREF="001732.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1813 - in trunk: res_noewe/languages resources	src/CacheWolf</H1>
    <B>engywuck at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1813%20-%20in%20trunk%3A%20res_noewe/languages%20resources%0A%09src/CacheWolf&In-Reply-To=%3C200905161814.n4GIE5bk007484%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1813 - in trunk: res_noewe/languages resources	src/CacheWolf">engywuck at mail.berlios.de
       </A><BR>
    <I>Sat May 16 20:14:05 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001730.html">[Cachewolf-svn] r1812 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="001732.html">[Cachewolf-svn] r1814 - in experiments/greiol: docs src/CacheWolf	src/exp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1731">[ date ]</a>
              <a href="thread.html#1731">[ thread ]</a>
              <a href="subject.html#1731">[ subject ]</a>
              <a href="author.html#1731">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: engywuck
Date: 2009-05-16 20:13:57 +0200 (Sat, 16 May 2009)
New Revision: 1813

Added:
   trunk/resources/trash.png
Modified:
   trunk/res_noewe/languages/DE.cfg
   trunk/res_noewe/languages/EN.cfg
   trunk/res_noewe/languages/FR.cfg
   trunk/res_noewe/languages/NL.cfg
   trunk/src/CacheWolf/FilterData.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/Profile.java
Log:
Filter screen with new features: Filters can be named and saved for later use. To use a saved filter, select it in the drop down list in the filter screen.

Modified: trunk/res_noewe/languages/DE.cfg
===================================================================
--- trunk/res_noewe/languages/DE.cfg	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/res_noewe/languages/DE.cfg	2009-05-16 18:13:57 UTC (rev 1813)
@@ -110,6 +110,10 @@
 		218=Auch in Beschreibung/Notizen
 		219=Suche...
 		220=Pr%fcfe Notizen und L%f6ser
+		221=Filter %fcberschreiben?
+		222=Der Filter existiert schon. %dcberschreiben?
+		223=Filter l%f6schen?
+		224=+- Den gespeicherten Filter l%f6schen? 
 		299=Regul%e4rer Ausdruck
 		300=Type:
 		301=Gr%f6%dfe:

Modified: trunk/res_noewe/languages/EN.cfg
===================================================================
--- trunk/res_noewe/languages/EN.cfg	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/res_noewe/languages/EN.cfg	2009-05-16 18:13:57 UTC (rev 1813)
@@ -110,6 +110,10 @@
 		218=Also in description/notes
 		219=Searching...
 		220=Check notes and solver
+		221=Overwrite filter?
+		222=This filter already exists. Overwrite it?
+		223=Delete filter?
+		224=+- Delete the saved filter?
 		299=Regular expression
 		300=Type:
 		301=Size:

Modified: trunk/res_noewe/languages/FR.cfg
===================================================================
--- trunk/res_noewe/languages/FR.cfg	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/res_noewe/languages/FR.cfg	2009-05-16 18:13:57 UTC (rev 1813)
@@ -107,6 +107,10 @@
 		218=Aussi dans description/notes
 		219=Cherchant...
 		220=V%e9rifier notes et resoudeur
+		221=%c9craser filtre?
+		222=Ce filtre existe d%e9j%e0. %c9craser-le?
+		223=Effacer filtre?
+		224=+- Effacer ce filtre enregistr%e9?
 		299=Expression rationnelle
 		300=Type:
 		301=Gabarit:

Modified: trunk/res_noewe/languages/NL.cfg
===================================================================
--- trunk/res_noewe/languages/NL.cfg	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/res_noewe/languages/NL.cfg	2009-05-16 18:13:57 UTC (rev 1813)
@@ -99,6 +99,10 @@
 		218=Ook in opmerkingen/beschrijving
 		219=Zoeken...
 		220=Onderzoek opmerkingen en oplosser
+		221=Overschrijf filter?
+		222=De filter exiteerd al. Overschrijven?
+		223=Filter verwijderen?
+		224=+- Deze filter verwijderen?
 		299=Reguliere expressie
 		300=Type:
 		301=Grote:

Added: trunk/resources/trash.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/trash.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/FilterData.java
===================================================================
--- trunk/src/CacheWolf/FilterData.java	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/src/CacheWolf/FilterData.java	2009-05-16 18:13:57 UTC (rev 1813)
@@ -1,5 +1,10 @@
 package CacheWolf;
 
+/**
+ * This class represents the settings of the filter that can be done when the users changes the
+ * filter in CacheWolf.
+ *
+ */
 public class FilterData {
 
 	// When extending the filter check &quot;normaliseFilters&quot;
@@ -22,7 +27,8 @@
 	private long filterAttrYes = 0l;
 	private long filterAttrNo = 0l;
 	private int filterAttrChoice = 0;
-	
+
+	// filter setting for state of cache
 	private String filterStatus = &quot;&quot;;
 	private boolean useRegexp = false;
 
@@ -33,12 +39,30 @@
 	public FilterData(){ // public constructor
 	}
 
-
 	/**
+	 * Returns an XML representation of the filter data. If a non empty String is passed as
+	 * parameter, then this String is used as ID-tag for the filter. If it is empty, then the ID
+	 * tag will not appear in the cache data. The ID tag is the string which is used in the filter
+	 * screen to appear in the filter list.
+	 * @param ID ID tag of filter 
+	 * @return XML represenation of filter
+	 */
+	public String toXML(String ID) {
+		String saveID=&quot;&quot;;
+		if (ID != null &amp;&amp; ! ID.equals(&quot;&quot;)) {
+			saveID = &quot;id = \&quot;&quot;+SafeXML.strxmlencode(ID)+&quot;\&quot; &quot;;
+		}
+	    return &quot;    &lt;FILTERDATA &quot;+saveID+&quot;rose = \&quot;&quot;+getFilterRose()+&quot;\&quot; type = \&quot;&quot;+getFilterType()+
+		&quot;\&quot; var = \&quot;&quot;+getFilterVar()+&quot;\&quot; dist = \&quot;&quot;+getFilterDist().replace('&quot;',' ')+&quot;\&quot; diff = \&quot;&quot;+
+		getFilterDiff()+&quot;\&quot; terr = \&quot;&quot;+getFilterTerr()+&quot;\&quot; size = \&quot;&quot;+getFilterSize()+&quot;\&quot; attributesYes = \&quot;&quot;+getFilterAttrYes()+
+		&quot;\&quot; attributesNo = \&quot;&quot;+getFilterAttrNo()+&quot;\&quot; attributesChoice = \&quot;&quot;+getFilterAttrChoice()+
+		&quot;\&quot; status = \&quot;&quot;+SafeXML.strxmlencode(getFilterStatus())+&quot;\&quot; useRegexp = \&quot;&quot;+useRegexp()+&quot;\&quot; /&gt;\n&quot;;	
+	}
+	/**
 	 * Ensure that all filters have the proper length so that the 'charAt' access in the filter do
 	 * not cause nullPointer Exceptions
 	 */
-	private void normaliseFilters() {
+	public void normaliseFilters() {
 		String manyOnes = &quot;11111111111111111111111111111&quot;;
 		if (getFilterRose().length() &lt; FILTERROSE.length()) {
 			setFilterRose((getFilterRose() + manyOnes).substring(0, FILTERROSE.length()));
@@ -67,22 +91,14 @@
 	}
 
 	public void setFilterType(String filterType) {
-		this.notifyUnsavedChanges(!filterType.equals(this.filterType));
 		this.filterType = filterType;
 	}
 
-	private void notifyUnsavedChanges(boolean b) {
-	    // TODO Auto-generated method stub
-	    
-    }
-
-
 	public String getFilterRose() {
 		return filterRose;
 	}
 
 	public void setFilterRose(String filterRose) {
-		this.notifyUnsavedChanges(!filterRose.equals(this.filterRose));
 		this.filterRose = filterRose;
 	}
 
@@ -91,7 +107,6 @@
 	}
 
 	public void setFilterSize(String filterSize) {
-		this.notifyUnsavedChanges(!filterSize.equals(this.filterSize));
 		this.filterSize = filterSize;
 	}
 
@@ -100,7 +115,6 @@
 	}
 
 	public void setFilterVar(String filterVar) {
-		this.notifyUnsavedChanges(!filterVar.equals(this.filterVar));
 		this.filterVar = filterVar;
 	}
 
@@ -109,7 +123,6 @@
 	}
 
 	public void setFilterDist(String filterDist) {
-		this.notifyUnsavedChanges(!filterDist.equals(this.filterDist));
 		this.filterDist = filterDist;
 	}
 
@@ -118,7 +131,6 @@
 	}
 
 	public void setFilterDiff(String filterDiff) {
-		this.notifyUnsavedChanges(!filterDiff.equals(this.filterDiff));
 		this.filterDiff = filterDiff;
 	}
 
@@ -127,7 +139,6 @@
 	}
 
 	public void setFilterTerr(String filterTerr) {
-		this.notifyUnsavedChanges(!filterTerr.equals(this.filterTerr));
 		this.filterTerr = filterTerr;
 	}
 
@@ -136,7 +147,6 @@
 	}
 
 	public void setFilterAttrYes(long filterAttrYes) {
-		this.notifyUnsavedChanges(filterAttrYes != this.filterAttrYes);
 		this.filterAttrYes = filterAttrYes;
 	}
 
@@ -145,7 +155,6 @@
 	}
 
 	public void setFilterAttrNo(long filterAttrNo) {
-		this.notifyUnsavedChanges(filterAttrNo != this.filterAttrNo);
 		this.filterAttrNo = filterAttrNo;
 	}
 
@@ -154,26 +163,21 @@
 	}
 
 	public void setFilterAttrChoice(int filterAttrChoice) {
-		this.notifyUnsavedChanges(filterAttrChoice != this.filterAttrChoice);
 		this.filterAttrChoice = filterAttrChoice;
 	}
 
-
 	public String getFilterStatus() {
     	return filterStatus;
     }
 
-
 	public void setFilterStatus(String filterStatus) {
     	this.filterStatus = filterStatus;
     }
 
-
 	public boolean useRegexp() {
     	return useRegexp;
     }
 
-
 	public void setUseRegexp(boolean useRegexp) {
     	this.useRegexp = useRegexp;
     }

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/src/CacheWolf/FilterScreen.java	2009-05-16 18:13:57 UTC (rev 1813)
@@ -16,6 +16,7 @@
 	private static final Color COLOR_FILTERALL=new Color(255,0,0); // Red
     	
 	private mButton btnCancel, btnApply,btnRoute,
+				    btnSaveFlt, btnDelFlt,
 					btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnSearch,btnAddi, btnSelect,btnDeselect,btnCacheAttributes;
 	
 	private mChoice chcDist, chcDiff, chcTerr, chcAttrib;
@@ -26,7 +27,7 @@
 	                  chkArchived,chkNotArchived, chkAvailable,chkNotAvailable,
 					  chkNW, chkNNW , chkN , chkNNE, chkNE, chkENE, chkE, chkESE, chkSE, chkSSE, chkS,
 					  chkSSW, chkSW, chkWSW, chkW, chkWNW,chkWherigo;
-	private mComboBox chcStatus;
+	private mComboBox chcStatus, fltList;
 	private mCheckBox chkUseRegexp;
 	
 	private mInput inpDist, inpTerr, inpDiff;
@@ -43,6 +44,11 @@
 	private CellPanel pnlAddi=new CellPanel();
 	private CellPanel pnlCacheAttributes=new CellPanel();
 	private CardPanel cp=new CardPanel();
+	
+	// ID of last filter selected from the filter list
+	private String currentFilterID = &quot;&quot;; 
+	// Flag, true if filters have been changed, added or deleted. Leads to saving of pref.xml
+	private boolean savedFiltersChanged= false;
 
 	// A subclassed checkbox with a &quot;third&quot; state (=grey background).
 	// If all addi wpts are false or all addi wpts are true, the background is white
@@ -267,6 +273,23 @@
 		frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
 		this.addLast(frmScreen,HSTRETCH,HFILL);
 		
+		// Had to move the button panel to the top, so that the SIP can't display over the 
+		// filter list field - in case we want to enter a new filter name.
+		CellPanel savDelPanel = new CellPanel(); // Panel for &quot;save&quot; and &quot;delete&quot; button
+		savDelPanel.equalWidths = true;
+		mImage savImg=new mImage(&quot;clsave.png&quot;); savImg.transparentColor=new Color(255,0,0);
+		savDelPanel.addNext(btnSaveFlt = new mButton(savImg),STRETCH,FILL);
+		savDelPanel.addLast(btnDelFlt = new mButton(new mImage(&quot;trash.png&quot;)),STRETCH,FILL);
+		Panel fltListPanel = new Panel();
+		fltListPanel.addLast(fltList = new mComboBox());
+		fltListPanel.addLast(savDelPanel);
+		Panel btPanel = new Panel();
+		btPanel.addNext(btnCancel = new mButton(MyLocale.getMsg(708,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addNext(btnApply = new mButton(MyLocale.getMsg(709,&quot;Apply&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addLast(fltListPanel,CellConstants.STRETCH, CellConstants.FILL);
+//		btPanel.addLast(btnRoute = new mButton(&quot;Route&quot;),CellConstants.STRETCH, CellConstants.FILL);
+		addLast(btPanel.setTag(CellConstants.SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
+
 		CellPanel pnlButtons=new CellPanel();
 		pnlButtons.addLast(new mLabel(&quot;Filter&quot;));
 		pnlButtons.addLast(btnBearing=new mButton(MyLocale.getMsg(721,&quot;Bearing&quot;)));
@@ -290,11 +313,10 @@
 		cp.addItem(pnlCacheAttributes,&quot;Attr&quot;,null);
 		addLast(cp,VSTRETCH,FILL);
 
-		Panel btPanel = new Panel();
-		btPanel.addNext(btnCancel = new mButton(MyLocale.getMsg(708,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
-		btPanel.addLast(btnApply = new mButton(MyLocale.getMsg(709,&quot;Apply&quot;)),CellConstants.STRETCH, CellConstants.FILL);
-//		btPanel.addLast(btnRoute = new mButton(&quot;Route&quot;),CellConstants.STRETCH, CellConstants.FILL);
-		addLast(btPanel.setTag(CellConstants.SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
+		// ***********
+		// Here: Former position of Cancel/Apply buttons
+		// ***********
+		
 		int sw = MyLocale.getScreenWidth(); int sh = MyLocale.getScreenHeight(); 
 		Preferences pref = Global.getPref();int fs = pref.fontSize;
 		int psx; int psy;
@@ -314,6 +336,9 @@
 				setPreferredSize(240,240);
 		}
 		cp.select(3);
+		
+		// Populating the comboBox of saved filters
+		buildFilterList();
 	}
 	
 	
@@ -567,6 +592,10 @@
 	public void onEvent(Event ev){
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnCancel){
+				if (savedFiltersChanged) {
+					Global.getPref().savePreferences();
+					savedFiltersChanged = false;
+				}
 				this.close(0);
 			}
 			else if (ev.target == btnRoute){
@@ -588,104 +617,56 @@
 			}
 			else if (ev.target == btnApply){
 				Vm.showWait(true);
-				//Save filter required
-				Profile pfl = Global.getProfile();
-				pfl.setFilterVar((chkArchived.state    ? &quot;1&quot; : &quot;0&quot;) +
-							(chkAvailable.state   ? &quot;1&quot; : &quot;0&quot;) +
-							(chkFound.state       ? &quot;1&quot; : &quot;0&quot;) +
-							(chkOwned.state       ? &quot;1&quot; : &quot;0&quot;) +
-							(chkNotArchived.state ? &quot;1&quot; : &quot;0&quot;) +
-							(chkNotAvailable.state? &quot;1&quot; : &quot;0&quot;) +
-							(chkNotFound.state    ? &quot;1&quot; : &quot;0&quot;) +
-							(chkNotOwned.state    ? &quot;1&quot; : &quot;0&quot;));							
-				pfl.setFilterType((chkTrad.state    ? &quot;1&quot; : &quot;0&quot;) +
-								(chkMulti.state   ? &quot;1&quot; : &quot;0&quot;) +
-								(chkVirtual.state ? &quot;1&quot; : &quot;0&quot;) +
-								(chkLetter.state  ? &quot;1&quot; : &quot;0&quot;) +
-								(chkEvent.state   ? &quot;1&quot; : &quot;0&quot;) + 
-								(chkWebcam.state  ? &quot;1&quot; : &quot;0&quot;) +
-								(chkMystery.state ? &quot;1&quot; : &quot;0&quot;) +
-								(chkEarth.state   ? &quot;1&quot; : &quot;0&quot;) +
-								(chkLocless.state ? &quot;1&quot; : &quot;0&quot;) +
-								(chkMega.state    ? &quot;1&quot; : &quot;0&quot;) +
-								(chkCustom.state  ? &quot;1&quot; : &quot;0&quot;) +
-								(chkParking.state ? &quot;1&quot; : &quot;0&quot;) +
-								(chkStage.state   ? &quot;1&quot; : &quot;0&quot;) +
-								(chkQuestion.state? &quot;1&quot; : &quot;0&quot;) +
-								(chkFinal.state   ? &quot;1&quot; : &quot;0&quot;) +
-								(chkTrailhead.state ? &quot;1&quot; : &quot;0&quot;) +
-								(chkReference.state ? &quot;1&quot; : &quot;0&quot;)+
-								(chkCito.state ? &quot;1&quot; : &quot;0&quot;)+
-								(chkWherigo.state ? &quot;1&quot; : &quot;0&quot;));
-				pfl.setFilterRose((chkNW.state  ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkNNW.state ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkN.state   ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkNNE.state ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkNE.state  ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkENE.state ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkE.state   ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkESE.state ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkSE.state  ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkSSE.state ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkS.state   ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkSSW.state ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkSW.state  ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkWSW.state ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkW.state   ? &quot;1&quot;:&quot;0&quot;)+
-							 (chkWNW.state ? &quot;1&quot;:&quot;0&quot;));
-				pfl.setFilterSize((chkMicro.state ? &quot;1&quot; : &quot;0&quot;)+
-							(chkSmall.state ? &quot;1&quot; : &quot;0&quot;)+
-							(chkRegular.state ? &quot;1&quot; : &quot;0&quot;)+
-							(chkLarge.state ? &quot;1&quot; : &quot;0&quot;)+
-							(chkVeryLarge.state ? &quot;1&quot; : &quot;0&quot;)+
-							(chkOther.state ? &quot;1&quot; : &quot;0&quot;));
-				
-				// Distance: If Metric system is set to imperial units,
-				//           then the entered value is meant to be miles,
-				//           otherwise it's kilometer.
-				double distValue = java.lang.Double.NaN;
-				String rawDistance = inpDist.getText().replace(',', '.');
-				String newDistance = rawDistance; // initial Value;
-				if (! rawDistance.trim().equals(&quot;&quot;)) {
-					distValue = java.lang.Double.valueOf(rawDistance).doubleValue();
-					if (Global.getPref().metricSystem == Metrics.IMPERIAL){
-						newDistance = String.valueOf(Metrics.convertUnit(distValue, Metrics.MILES, Metrics.KILOMETER));
-					}
-				}
-				if(chcDist.selectedIndex == 0) { 
-					pfl.setFilterDist(&quot;L&quot;+newDistance);
-				} else { 
-					pfl.setFilterDist(&quot;G&quot;+newDistance);
-				}
-					
-				if(chcDiff.selectedIndex == 0) { 
-					pfl.setFilterDiff(&quot;L&quot;+inpDiff.getText());
-				} else if(chcDiff.selectedIndex == 1) { 
-					pfl.setFilterDiff(&quot;=&quot;+inpDiff.getText());
-				} else {	
-					pfl.setFilterDiff(&quot;G&quot;+inpDiff.getText());
-				}	
-					
-				if(chcTerr.selectedIndex == 0) { 
-					pfl.setFilterTerr(&quot;L&quot;+inpTerr.getText());
-				} else if(chcTerr.selectedIndex == 1){ 
-					pfl.setFilterTerr(&quot;=&quot;+inpTerr.getText());
-				} else { 
-					pfl.setFilterTerr(&quot;G&quot;+inpTerr.getText());
-				}
-				pfl.setFilterAttrYes(attV.selectionMaskYes);
-				pfl.setFilterAttrNo(attV.selectionMaskNo);
-				pfl.setFilterAttrChoice(chcAttrib.selectedIndex);
-				pfl.setFilterStatus(chcStatus.getText());
-				pfl.setFilterUseRegexp(chkUseRegexp.getState());
-				// FIXME Das geht bestimmt auch &#252;ber Filter-Objekte
+
+				FilterData data = getDataFromScreen();
+				Global.getProfile().setCurrentFilter(data);
+
 				Filter flt = new Filter();
 				flt.setFilter();
 				flt.doFilter();
+				if (savedFiltersChanged) {
+					Global.getPref().savePreferences();
+					savedFiltersChanged = false;
+				}
 				Global.mainTab.tbP.tc.scrollToVisible(0,0);
 				Vm.showWait(false);
-				//Tabelle neu zeichnen lassen!
 				this.close(0);
+			} else if (ev.target == btnSaveFlt) {
+				String ID = fltList.getText();
+				FilterData data = getDataFromScreen();
+				MessageBox mBox;
+				if (ID.equals(&quot;&quot;)) {
+					mBox = new MessageBox(MyLocale.getMsg(221,&quot;No filter name&quot;), MyLocale.getMsg(222,&quot;Please enter a name for the filter&quot;) , FormBase.IDOK);
+					mBox.execute();
+				} else if (Global.getPref().hasFilter(ID)) {
+					mBox = new MessageBox(MyLocale.getMsg(221,&quot;Overwrite Filter?&quot;), MyLocale.getMsg(222,&quot;The filter already exists. Overwrite it?&quot;) , FormBase.IDYES |FormBase.IDNO);
+					if (mBox.execute() == FormBase.IDYES){
+						Global.getPref().addFilter(ID, data);
+						savedFiltersChanged = true;
+					}	
+				} else {
+					Global.getPref().addFilter(ID, data);
+					savedFiltersChanged = true;
+				}	
+				buildFilterList();
+			} else if (ev.target == btnDelFlt) {
+				String ID = fltList.getText();
+				if (!ID.equals(&quot;&quot;)) {
+					FilterData data = Global.getPref().getFilter(ID);
+					// We only need to delete anything, if there is already a filter of the id
+					// in the list box. If not, just delete the text in the box.
+					if (data != null) {
+						MessageBox mBox = new MessageBox(MyLocale.getMsg(223,&quot;Delete filter?&quot;), ID+MyLocale.getMsg(224,&quot; - Delete this filter?&quot;) , FormBase.IDYES |FormBase.IDNO);
+						if (mBox.execute() == FormBase.IDYES){
+							Global.getPref().removeFilter(ID);
+							fltList.setText(&quot;&quot;);
+							savedFiltersChanged = true;
+							this.buildFilterList();
+						}							
+					} else {
+						fltList.setText(&quot;&quot;);
+					}
+				}
 			} else if (ev.target == addiWptChk) { // Set all addi filters to value of main addi filter
 				chkParking.setState(addiWptChk.state);
 				chkStage.setState(addiWptChk.state);
@@ -721,9 +702,131 @@
 			}
 		}
 		if (ev instanceof DataChangeEvent )	{ 
+			if (ev.target == fltList) {
+				if (!currentFilterID.equals(fltList.getText())) {
+					FilterData data = Global.getPref().getFilter(fltList.getText());
+					if (data!=null) {
+						currentFilterID = fltList.getText();
+						this.setData(data);
+						this.repaintNow();
+					}
+				}
+//				Vm.debug(&quot;Event: &quot;+ev.toString()+&quot;; Target: &quot;+ev.target+&quot;; Liste: &quot;+fltList.getText()+
+//						&quot; (alt: &quot;+fltList.oldText+&quot;)&quot;);
+				//setColors();
+			}
 			setColors();
 		}
 
 	}
+	
+	/**
+	 * Populating the list of available filters in the comboBox from memory, so that the comboBox
+	 * reflects the filters that are currenty in memory.
+	 */
+	private void buildFilterList() {
+		while (fltList.choice.itemsSize()&gt;0) {
+			fltList.choice.deleteItem(0);
+		}
+		fltList.choice.addItems(Global.getPref().getFilterIDs());
+		fltList.choice.updateItems();
+	}
+	
+	/**
+     * Examines the filter screen and creates a FilterData object that represents the data
+     * entered in the screen.
+     */
+    private FilterData getDataFromScreen() {
+    	FilterData data = new FilterData();
+    	data.setFilterVar((chkArchived.state    ? &quot;1&quot; : &quot;0&quot;) +
+	    			(chkAvailable.state   ? &quot;1&quot; : &quot;0&quot;) +
+	    			(chkFound.state       ? &quot;1&quot; : &quot;0&quot;) +
+	    			(chkOwned.state       ? &quot;1&quot; : &quot;0&quot;) +
+	    			(chkNotArchived.state ? &quot;1&quot; : &quot;0&quot;) +
+	    			(chkNotAvailable.state? &quot;1&quot; : &quot;0&quot;) +
+	    			(chkNotFound.state    ? &quot;1&quot; : &quot;0&quot;) +
+	    			(chkNotOwned.state    ? &quot;1&quot; : &quot;0&quot;));							
+	    data.setFilterType((chkTrad.state    ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkMulti.state   ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkVirtual.state ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkLetter.state  ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkEvent.state   ? &quot;1&quot; : &quot;0&quot;) + 
+	    				(chkWebcam.state  ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkMystery.state ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkEarth.state   ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkLocless.state ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkMega.state    ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkCustom.state  ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkParking.state ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkStage.state   ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkQuestion.state? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkFinal.state   ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkTrailhead.state ? &quot;1&quot; : &quot;0&quot;) +
+	    				(chkReference.state ? &quot;1&quot; : &quot;0&quot;)+
+	    				(chkCito.state ? &quot;1&quot; : &quot;0&quot;)+
+	    				(chkWherigo.state ? &quot;1&quot; : &quot;0&quot;));
+	    data.setFilterRose((chkNW.state  ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkNNW.state ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkN.state   ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkNNE.state ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkNE.state  ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkENE.state ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkE.state   ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkESE.state ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkSE.state  ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkSSE.state ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkS.state   ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkSSW.state ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkSW.state  ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkWSW.state ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkW.state   ? &quot;1&quot;:&quot;0&quot;)+
+	    			 (chkWNW.state ? &quot;1&quot;:&quot;0&quot;));
+	    data.setFilterSize((chkMicro.state ? &quot;1&quot; : &quot;0&quot;)+
+	    			(chkSmall.state ? &quot;1&quot; : &quot;0&quot;)+
+	    			(chkRegular.state ? &quot;1&quot; : &quot;0&quot;)+
+	    			(chkLarge.state ? &quot;1&quot; : &quot;0&quot;)+
+	    			(chkVeryLarge.state ? &quot;1&quot; : &quot;0&quot;)+
+	    			(chkOther.state ? &quot;1&quot; : &quot;0&quot;));
+	    
+	    // Distance: If Metric system is set to imperial units,
+	    //           then the entered value is meant to be miles,
+	    //           otherwise it's kilometer.
+	    double distValue = java.lang.Double.NaN;
+	    String rawDistance = inpDist.getText().replace(',', '.');
+	    String newDistance = rawDistance; // initial Value;
+	    if (! rawDistance.trim().equals(&quot;&quot;)) {
+	    	distValue = java.lang.Double.valueOf(rawDistance).doubleValue();
+	    	if (Global.getPref().metricSystem == Metrics.IMPERIAL){
+	    		newDistance = String.valueOf(Metrics.convertUnit(distValue, Metrics.MILES, Metrics.KILOMETER));
+	    	}
+	    }
+	    if(chcDist.selectedIndex == 0) { 
+	    	data.setFilterDist(&quot;L&quot;+newDistance);
+	    } else { 
+	    	data.setFilterDist(&quot;G&quot;+newDistance);
+	    }
+	    	
+	    if(chcDiff.selectedIndex == 0) { 
+	    	data.setFilterDiff(&quot;L&quot;+inpDiff.getText());
+	    } else if(chcDiff.selectedIndex == 1) { 
+	    	data.setFilterDiff(&quot;=&quot;+inpDiff.getText());
+	    } else {	
+	    	data.setFilterDiff(&quot;G&quot;+inpDiff.getText());
+	    }	
+	    	
+	    if(chcTerr.selectedIndex == 0) { 
+	    	data.setFilterTerr(&quot;L&quot;+inpTerr.getText());
+	    } else if(chcTerr.selectedIndex == 1){ 
+	    	data.setFilterTerr(&quot;=&quot;+inpTerr.getText());
+	    } else { 
+	    	data.setFilterTerr(&quot;G&quot;+inpTerr.getText());
+	    }
+	    data.setFilterAttrYes(attV.selectionMaskYes);
+	    data.setFilterAttrNo(attV.selectionMaskNo);
+	    data.setFilterAttrChoice(chcAttrib.selectedIndex);
+	    data.setFilterStatus(chcStatus.getText());
+	    data.setUseRegexp(chkUseRegexp.getState());
+	    return data;
+    }
 
 }

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/src/CacheWolf/Preferences.java	2009-05-16 18:13:57 UTC (rev 1813)
@@ -23,6 +23,8 @@
 	public static final int YES = 0;
 	public static final int NO = 1;
 	public static final int ASK = 2;
+	// Hashtable is saving filter data objects the user wants to save
+	private Hashtable filterList = new Hashtable(15);
 
 	//////////////////////////////////////////////////////////////////////////////////////
     // Constructor
@@ -414,6 +416,26 @@
 		else if (name.equals(&quot;locale&quot;)) {
 			language = atts.getValue(&quot;language&quot;);
 		}
+		else if (name.equals(&quot;FILTERDATA&quot;)) {
+			// Creating a filter object and reading the saved data
+			String id = SafeXML.strxmldecode(atts.getValue(&quot;id&quot;));
+			FilterData data = new FilterData();
+			data.setFilterRose(atts.getValue(&quot;rose&quot;));
+			data.setFilterType(atts.getValue(&quot;type&quot;));
+			data.setFilterVar(atts.getValue(&quot;var&quot;));
+			data.setFilterDist(atts.getValue(&quot;dist&quot;));
+			data.setFilterDiff(atts.getValue(&quot;diff&quot;));
+			data.setFilterTerr(atts.getValue(&quot;terr&quot;));
+			data.setFilterSize(atts.getValue(&quot;size&quot;));
+			data.setFilterAttrYes(Convert.parseLong(atts.getValue(&quot;attributesYes&quot;)));
+			data.setFilterAttrNo(Convert.parseLong(atts.getValue(&quot;attributesNo&quot;)));
+			data.setFilterAttrChoice(Convert.parseInt(atts.getValue(&quot;attributesChoice&quot;)));
+			data.setFilterStatus(SafeXML.strxmldecode(atts.getValue(&quot;status&quot;)));
+			data.setUseRegexp(Boolean.valueOf(atts.getValue(&quot;useRegexp&quot;)).booleanValue());
+			// Filter object is remembered under the given ID
+			this.addFilter(id, data);
+		}
+
 	}
 
 	public void characters( char ch[], int start, int length ) {
@@ -476,6 +498,11 @@
 			outp.print(&quot;    &lt;metric type=\&quot;&quot; + SafeXML.strxmlencode(metricSystem) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;export numberOfLogsToExport=\&quot;&quot; + SafeXML.strxmlencode(numberOfLogsToExport) + &quot;\&quot; exportTravelbugs=\&quot;&quot; + SafeXML.strxmlencode(exportTravelbugs) + &quot;\&quot; exportGpxAsMyFinds=\&quot;&quot; + SafeXML.strxmlencode(exportGpxAsMyFinds) + &quot;\&quot;/&gt;\n&quot;);
 			if (customMapsPath!=null) outp.print(&quot;	&lt;mapspath dir = \&quot;&quot; + SafeXML.strxmlencode(customMapsPath.replace('\\','/')) + &quot;\&quot;/&gt;\n&quot;);
+			// Saving filters
+			String[] filterIDs = this.getFilterIDs();
+			for (int i=0; i&lt;filterIDs.length; i++){
+				outp.print(this.getFilter(filterIDs[i]).toXML(filterIDs[i]));
+			}
 			if (debug) outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the debug switch if it is set
 			// save last path of different exporters
 			Iterator itPath = exporterPaths.entries();
@@ -776,4 +803,57 @@
 		return dir;
 	}
 
+	/**
+	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is 
+	 * saved in the preferences.
+	 * @param filterID ID of the filter to check
+	 * @return True or false
+	 */
+	public boolean hasFilter(String filterID) {
+		return this.filterList.containsKey(filterID);
+	}
+	
+	/**
+	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, 
+	 * so it may be resaved under another ID.
+	 * @param filterID ID of the FilterData object
+	 * @return FilterData object
+	 */
+	public FilterData getFilter(String filterID) {
+		return (FilterData)this.filterList.get(filterID);
+	}
+	
+	/**
+	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the 
+	 * given ID, the old object is removed and the new one is set at its place.
+	 * @param filterID ID to associate with the filter object
+	 * @param filter FilterData object
+	 */
+	public void addFilter(String filterID, FilterData filter) {
+		this.filterList.put(filterID, filter);
+	}
+	
+	/**
+	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object
+	 * exists, nothing happens.
+	 * @param filterID ID of FilterData object to remove
+	 */
+	public void removeFilter(String filterID) {
+		this.filterList.remove(filterID);
+	}
+	
+	/**
+	 * Returns an array of ID of saved FilterData objects.
+	 * @return Array of IDs
+	 */
+	public String[] getFilterIDs() {
+		String[] result;
+		result = new String[this.filterList.size()];
+		Enumeration en = this.filterList.keys();
+		int i=0;
+		while (en.hasMoreElements()) {
+			result[i++] = (String) en.nextElement();
+		}
+		return result;
+	}
 }

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2009-05-15 21:41:29 UTC (rev 1812)
+++ trunk/src/CacheWolf/Profile.java	2009-05-16 18:13:57 UTC (rev 1813)
@@ -181,12 +181,9 @@
 			} else {
 				activeFilterForSave = getFilterActive();
 			}
-			detfile.print(&quot;    &lt;FILTER status = \&quot;&quot;+activeFilterForSave+(isFilterInverted()?&quot;T&quot;:&quot;F&quot;)+ 
-					&quot;\&quot; rose = \&quot;&quot;+getFilterRose()+&quot;\&quot; type = \&quot;&quot;+getFilterType()+
-					&quot;\&quot; var = \&quot;&quot;+getFilterVar()+&quot;\&quot; dist = \&quot;&quot;+getFilterDist().replace('&quot;',' ')+&quot;\&quot; diff = \&quot;&quot;+
-					getFilterDiff()+&quot;\&quot; terr = \&quot;&quot;+getFilterTerr()+&quot;\&quot; size = \&quot;&quot;+getFilterSize()+&quot;\&quot; attributesYes = \&quot;&quot;+getFilterAttrYes()+
-					&quot;\&quot; attributesNo = \&quot;&quot;+getFilterAttrNo()+&quot;\&quot; attributesChoice = \&quot;&quot;+getFilterAttrChoice()+&quot;\&quot; showBlacklist = \&quot;&quot;+showBlacklisted()+
-					&quot;\&quot; status = \&quot;&quot;+SafeXML.clean(getFilterStatus())+&quot;\&quot; useRegexp = \&quot;&quot;+getFilterUseRegexp()+&quot;\&quot; /&gt;\n&quot;);
+			detfile.print(&quot;    &lt;FILTERCONFIG status = \&quot;&quot;+activeFilterForSave+
+					(isFilterInverted()?&quot;T&quot;:&quot;F&quot;)+&quot;\&quot; showBlacklist = \&quot;&quot;+showBlacklisted()+&quot;\&quot; /&gt;\n&quot;);
+			detfile.print(this.getCurrentFilter().toXML(&quot;&quot;));
 			detfile.print(&quot;    &lt;SYNCOC date = \&quot;&quot;+getLast_sync_opencaching()+&quot;\&quot; dist = \&quot;&quot;+getDistOC()+&quot;\&quot;/&gt;\n&quot;);
 			detfile.print(&quot;    &lt;SPIDERGC dist = \&quot;&quot; + getDistGC() + &quot;\&quot;/&gt;\n&quot;);
 			int size = cacheDB.size();
@@ -197,13 +194,8 @@
 				}
 				ch = cacheDB.get(i);
 				// //Vm.debug(&quot;Saving: &quot; + ch.CacheName);
-				if (ch.getWayPoint().length() &gt; 0) { // TODO &amp;&amp; ch.LongDescription.equals(&quot;An
-/*					detfile.print(&quot;    &lt;CACHE name = \&quot;&quot;+SafeXML.clean(ch.CacheName)+&quot;\&quot; owner = \&quot;&quot;+SafeXML.clean(ch.CacheOwner)+
-							//&quot;\&quot; lat = \&quot;&quot;+ SafeXML.clean(ch.LatLon) +
-							&quot;\&quot; lat = \&quot;&quot;+ ch.pos.latDec + &quot;\&quot; lon = \&quot;&quot;+ch.pos.lonDec+
-							&quot;\&quot; hidden = \&quot;&quot;+ch.DateHidden+&quot;\&quot; wayp = \&quot;&quot;+SafeXML.clean(ch.wayPoint)+&quot;\&quot; status = \&quot;&quot;+ch.CacheStatus+&quot;\&quot; type = \&quot;&quot;+ch.type+&quot;\&quot; dif = \&quot;&quot;+ch.hard+&quot;\&quot; terrain = \&quot;&quot; + ch.terrain + &quot;\&quot; dirty = \&quot;false&quot; + // ch.dirty + dirty is not used, so we save it as false 
-							&quot;\&quot; size = \&quot;&quot;+ch.CacheSize+&quot;\&quot; online = \&quot;&quot; + Convert.toString(ch.is_available) + &quot;\&quot; archived = \&quot;&quot; + Convert.toString(ch.is_archived) + &quot;\&quot; has_bug = \&quot;&quot; + Convert.toString(ch.has_bug) + &quot;\&quot; black = \&quot;&quot; + Convert.toString(ch.is_black) + &quot;\&quot; owned = \&quot;&quot; + Convert.toString(ch.is_owned) + &quot;\&quot; found = \&quot;&quot; + Convert.toString(ch.is_found) + &quot;\&quot; is_new = \&quot;&quot; + Convert.toString(ch.is_new) +&quot;\&quot; is_log_update = \&quot;&quot; + Convert.toString(ch.is_log_update) + &quot;\&quot; is_update = \&quot;&quot; + Convert.toString(ch.is_update) + &quot;\&quot; is_HTML = \&quot;&quot; + Convert.toString(ch.is_HTML) + &quot;\&quot; DNFLOGS = \&quot;&quot; + ch.noFindLogs + &quot;\&quot; ocCacheID = \&quot;&quot; + ch.ocCacheID + &quot;\&quot; is_INCOMPLETE = \&quot;&quot;+Convert.toString(ch.is_incomplete)+ &quot;\&quot; lastSyncOC = \&quot;&quot; + ch.lastSyncOC + &quot;\&quot; /&gt;\n&quot;);
-*/					detfile.print(ch.toXML());
+				if (ch.getWayPoint().length() &gt; 0) { 
+					detfile.print(ch.toXML());
 				}
 			}
 			detfile.print(&quot;&lt;/CACHELIST&gt;\n&quot;);
@@ -268,8 +260,9 @@
 				} else if (text.indexOf(&quot;&lt;SPIDERGC&quot;)&gt;=0) {
 					int start=text.indexOf(&quot;dist = \&quot;&quot;)+8;
 					setDistGC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-				} else if (text.indexOf(&quot;&lt;FILTER&quot;)&gt;=0){
-					ex.setSource(text);
+				} else if (indexXmlVersion &lt;=2 &amp;&amp; text.indexOf(&quot;&lt;FILTER&quot;)&gt;=0){
+					// Read filter data of file versions 1 and 2. (Legacy code)
+					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTER&quot;)));
 					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
 					if (temp.length()==2) {
 						// Compatibility with previous versions
@@ -301,8 +294,33 @@
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						setFilterAttrChoice(Convert.parseInt(attr));
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
-					setFilterStatus(SafeXML.cleanback(ex.findNext()));
+				} else if (text.indexOf(&quot;&lt;FILTERDATA&quot;)&gt;=0){
+					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTERDATA&quot;)));
+					setFilterRose(ex.findNext());
+					setFilterType(ex.findNext());
+					//Need this to stay &quot;downward&quot; compatible. New type introduced
+					//if(filterType.length()&lt;=17) filterType = filterType + &quot;1&quot;;
+					//Vm.debug(&quot;fil len: &quot; +filterType.length());
+					//This is handled by &quot;normaliseFilters&quot; which is called at the end.
+					setFilterVar(ex.findNext());
+					setFilterDist(ex.findNext());
+					setFilterDiff(ex.findNext());
+					setFilterTerr(ex.findNext());
+					setFilterSize(ex.findNext());
+					String attr = ex.findNext();
+					setFilterAttrYes(Convert.parseLong(attr));
+					attr = ex.findNext();
+					setFilterAttrNo(Convert.parseLong(attr));
+					attr = ex.findNext();
+					setFilterAttrChoice(Convert.parseInt(attr));
+					setFilterStatus(SafeXML.strxmldecode(ex.findNext()));
 					setFilterUseRegexp(Boolean.valueOf(ex.findNext()).booleanValue());
+				} else if (text.indexOf(&quot;&lt;FILTERCONFIG&quot;)&gt;=0){
+					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTERCONFIG&quot;)));
+					String temp=ex.findNext();
+					setFilterActive(Common.parseInt(temp.substring(0,1)));
+					setFilterInverted(temp.charAt(1)=='T');
+					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
 				}
 			}
 			in.close();
@@ -318,8 +336,8 @@
 		} catch (IOException e){
 			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot;+dataDir,e,true); 
 		}
-		// FIXME Brauchen wir das noch? Und wenn ja: Hier?
-		//normaliseFilters();
+		// TODO Brauchen wir das noch?
+		this.getCurrentFilter().normaliseFilters();
 		resetUnsavedChanges();
 	}
 
@@ -710,6 +728,10 @@
 		this.distGC = distGC;
 	}
 
+	/**
+	 * Returns the currently active FilterData object for the profile.
+	 * @return Object representing the setting of the filter
+	 */
 	public FilterData getCurrentFilter() {
     	return currentFilter;
     }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001730.html">[Cachewolf-svn] r1812 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="001732.html">[Cachewolf-svn] r1814 - in experiments/greiol: docs src/CacheWolf	src/exp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1731">[ date ]</a>
              <a href="thread.html#1731">[ thread ]</a>
              <a href="subject.html#1731">[ subject ]</a>
              <a href="author.html#1731">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
