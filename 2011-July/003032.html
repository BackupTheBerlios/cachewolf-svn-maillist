<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3041 - in trunk/src/CacheWolf: . exp imp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-July/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3041%20-%20in%20trunk/src/CacheWolf%3A%20.%20exp%20imp&In-Reply-To=%3C20110720200754.6E43A4814C0%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003031.html">
   <LINK REL="Next"  HREF="003033.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3041 - in trunk/src/CacheWolf: . exp imp</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3041%20-%20in%20trunk/src/CacheWolf%3A%20.%20exp%20imp&In-Reply-To=%3C20110720200754.6E43A4814C0%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3041 - in trunk/src/CacheWolf: . exp imp">araber95 at mail.berlios.de
       </A><BR>
    <I>Wed Jul 20 10:07:54 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003031.html">[Cachewolf-svn] r3040 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="003033.html">[Cachewolf-svn] r3042 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3032">[ date ]</a>
              <a href="thread.html#3032">[ thread ]</a>
              <a href="subject.html#3032">[ subject ]</a>
              <a href="author.html#3032">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-07-20 22:07:54 +0200 (Wed, 20 Jul 2011)
New Revision: 3041

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheImages.java
   trunk/src/CacheWolf/exp/SpoilerPOIExporter.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
   trunk/src/CacheWolf/myTableControl.java
Log:
1. remove \r\n within img - tags (resulting no/wrong local image access in html export)
2. doing cacheName private. correct direct access by getter.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -58,7 +58,7 @@
 	/** The name of the waypoint, typically GC.... or OC.... or CW...... (can be any characters) */
 	private String wayPoint = EMPTY;
 	/** The name of the cache (short description) */
-	public String cacheName = EMPTY;
+	private String cacheName = EMPTY;
 	/** The alias of the owner */
 	private String cacheOwner = EMPTY;
 	/** The coordinates of the cache */

Modified: trunk/src/CacheWolf/CacheImages.java
===================================================================
--- trunk/src/CacheWolf/CacheImages.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/CacheImages.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -30,66 +30,75 @@
 import ewe.util.Vector;
 
 /**
- * This class holds the image information of a cache. 
+ * This class holds the image information of a cache.
+ * 
  * @author torsti
- *
+ * 
  */
 public class CacheImages {
-	
-	private int initialSize=10;
-	/** Lazy initialization of the vector: It is created only when needed. If it is not accessed,
-	 * it will stay &lt;code&gt;null&lt;/code&gt;.*/
-	private Vector vector=null;
+
+	private int initialSize = 10;
+	/**
+	 * Lazy initialization of the vector: It is created only when needed. If it is not accessed,
+	 * it will stay &lt;code&gt;null&lt;/code&gt;.
+	 */
+	private Vector vector = null;
 	/** Images that should display in the image panel */
-	private CacheImages display=null;
-	
-	public CacheImages(){ // Public constructor
+	private CacheImages display = null;
+
+	public CacheImages() { // Public constructor
 	}
 
 	public CacheImages(int initialSize) {
-		if (initialSize&lt;0) {
-			throw new IllegalArgumentException(&quot;Initial size for CacheImage must be &gt; 0. Value: &quot;+String.valueOf(initialSize));
+		if (initialSize &lt; 0) {
+			throw new IllegalArgumentException(&quot;Initial size for CacheImage must be &gt; 0. Value: &quot; + String.valueOf(initialSize));
 		}
 		this.initialSize = initialSize;
 	}
-	private Vector getVector(){
-		if (this.vector==null) {
+
+	private Vector getVector() {
+		if (this.vector == null) {
 			vector = new Vector(this.initialSize);
 		}
 		return this.vector;
 	}
-	
+
 	/**
-	 * Adds an ImageInfo object to the list of images. The object is always appended in the 
+	 * Adds an ImageInfo object to the list of images. The object is always appended in the
 	 * last position.
-	 * @param img ImageInfo object to add.
+	 * 
+	 * @param img
+	 *            ImageInfo object to add.
 	 */
 	public void add(ImageInfo img) {
-		display = null;  // New Image? Force display to get reevaluated 
-        getVector().add(img);
-    }
-	
+		display = null; // New Image? Force display to get reevaluated
+		getVector().add(img);
+	}
+
 	/**
 	 * Gets the ImageInfo object at the specified position.
-	 * @param idx Index of object to retrieve.
+	 * 
+	 * @param idx
+	 *            Index of object to retrieve.
 	 * @return ImageInfo object
 	 */
 	public ImageInfo get(int idx) {
 		return (ImageInfo) getVector().get(idx);
 	}
-	
+
 	/**
 	 * Removes all image information.
 	 */
 	public void clear() {
-		if (this.vector!=null) {
-			display = null; 
+		if (this.vector != null) {
+			display = null;
 			this.vector.clear();
 		}
 	}
-	
+
 	/**
 	 * Returns the number of ImageInfo objects in the collection.
+	 * 
 	 * @return Number
 	 */
 	public int size() {
@@ -99,52 +108,59 @@
 			return this.vector.size();
 		}
 	}
-	
+
 	/**
 	 * Fills the &lt;code&gt;display&lt;/code&gt; collection with the images that really should display
 	 * in the image panel.
-	 * @param prefix The prefix which is used to name default image titles
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
 	 */
 	private void checkForDisplayImages(String prefix) {
-		if (this.size()&gt;1) {
+		if (this.size() &gt; 1) {
 			display = new CacheImages(this.size());
 			// Loop over every image
-			for (int i=0; i&lt;this.size(); i++) {
+			for (int i = 0; i &lt; this.size(); i++) {
 				boolean shouldDisplay = true;
 				ImageInfo currImg = this.get(i);
 				// Now check against every other image
-				for (int j=0; j&lt;this.size(); j++) {
-					if (i==j) continue; // Except same image
+				for (int j = 0; j &lt; this.size(); j++) {
+					if (i == j)
+						continue; // Except same image
 					ImageInfo testImg = this.get(j);
 					// Are the filenames the same?
 					if (currImg.getFilename().toLowerCase().equals(testImg.getFilename().toLowerCase())) {
 						// Check if other title is better than current one
-						if (currImg.getTitle().startsWith(prefix) &amp;&amp;
-							!testImg.getTitle().startsWith(prefix)) {
+						if (currImg.getTitle().startsWith(prefix) &amp;&amp; !testImg.getTitle().startsWith(prefix)) {
 							// If yes: Don't show the image
 							shouldDisplay = false;
 						}
 					}
 				}
-				if (shouldDisplay) display.add(currImg);
+				if (shouldDisplay)
+					display.add(currImg);
 			}
 		}
 	}
-	
+
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is
 	 * starting with the indicated prefix and if there is another image referring to the same file but
 	 * with a different title.&lt;br&gt;
 	 * Normally, the results are cached and don't need to be evaluated again. If they should
-	 * be reevaluated for whatever reason, then pass &lt;code&gt;true&lt;/code&gt; as parameter.  
-	 * @param prefix The prefix which is used to name default image titles
-	 * @param forceEvaluation When &lt;code&gt;true&lt;/code&gt; the images that should display are
-	 * reexamined.
-	 * @return The CacheImage collection of images. 
+	 * be reevaluated for whatever reason, then pass &lt;code&gt;true&lt;/code&gt; as parameter.
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @param forceEvaluation
+	 *            When &lt;code&gt;true&lt;/code&gt; the images that should display are
+	 *            reexamined.
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix, boolean forceEvaluation) {
-		if (display == null || forceEvaluation) this.checkForDisplayImages(prefix);
+		if (display == null || forceEvaluation)
+			this.checkForDisplayImages(prefix);
 		if (display == null) {
 			return this;
 		} else {
@@ -153,40 +169,42 @@
 	}
 
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is
 	 * equivalent to its filename and if there is another image referring to the same file but
 	 * with a different title.
-	 * @param prefix The prefix which is used to name default image titles
-	 * @return The CacheImage collection of images. 
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix) {
 		return this.getDisplayImages(prefix, false);
 	}
-	
+
 	/**
 	 * Checks if a image of a given URL needs to be spidered. It does &lt;b&gt;not&lt;/b&gt; need to be spidered
-	 * if the following conditions meet: &lt;ul&gt;
-	 * &lt;li&gt;The url is from &lt;code&gt;<A HREF="http://img.geocaching.com/cache/&lt;/code">http://img.geocaching.com/cache/&lt;/code</A>&gt; or 
-	 * &lt;code&gt;<A HREF="http://img.groundspeak.com/cache/&lt;/code">http://img.groundspeak.com/cache/&lt;/code</A>&gt;. (Reason: Images at these places don't change - 
-	 * if images change, they get a new url.)&lt;/li&gt;
+	 * if the following conditions meet:
+	 * &lt;ul&gt;
+	 * &lt;li&gt;The url is from &lt;code&gt;<A HREF="http://img.geocaching.com/cache/&lt;/code">http://img.geocaching.com/cache/&lt;/code</A>&gt; or &lt;code&gt;<A HREF="http://img.groundspeak.com/cache/&lt;/code">http://img.groundspeak.com/cache/&lt;/code</A>&gt;. (Reason: Images at these places don't change - if images change, they get a new url.)&lt;/li&gt;
 	 * &lt;li&gt;An image with the given URL is among the images of the caches image object.&lt;/li&gt;
 	 * &lt;li&gt;The intended file name is the same.&lt;/li&gt;
 	 * &lt;li&gt;The image is present in the file system.&lt;/li&gt;
-	 * &lt;/ul&gt; If no spidering is needed, then the &lt;code&gt;ImageInfo&lt;/code&gt; object of the equivalent image is
+	 * &lt;/ul&gt;
+	 * If no spidering is needed, then the &lt;code&gt;ImageInfo&lt;/code&gt; object of the equivalent image is
 	 * returned, otherwise (when spidering is needed) &lt;code&gt;null&lt;/code&gt; is returned.
-	 * @param pNewUrl URL to check
+	 * 
+	 * @param pNewUrl
+	 *            URL to check
 	 * @return ImageInfo object
 	 */
 	public ImageInfo needsSpidering(String pNewUrl, String pFilename) {
 		String newUrl = CacheImages.optimizeLink(pNewUrl);
 		ImageInfo result = null;
-		if (this.size() &gt; 0 &amp;&amp; 
-				(newUrl.startsWith(&quot;<A HREF="http://img.geocaching.com/cache/">http://img.geocaching.com/cache/</A>&quot;))) {
-			for (int i=0; i&lt;this.size(); i++) {
+		if (this.size() &gt; 0 &amp;&amp; (newUrl.startsWith(&quot;<A HREF="http://img.geocaching.com/cache/">http://img.geocaching.com/cache/</A>&quot;))) {
+			for (int i = 0; i &lt; this.size(); i++) {
 				ImageInfo img = this.get(i);
-				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) 
-						&amp;&amp; img.getFilename().equals(pFilename)) {
+				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) &amp;&amp; img.getFilename().equals(pFilename)) {
 					String location = Global.getProfile().dataDir + pFilename;
 					if ((new FileBugfix(location)).exists()) {
 						result = img;
@@ -197,16 +215,18 @@
 		}
 		return result;
 	}
-	
+
 	/**
-	 * Checks if an image with a certain filename is present in the collection of the caches 
+	 * Checks if an image with a certain filename is present in the collection of the caches
 	 * images.
-	 * @param filename Filename to check
+	 * 
+	 * @param filename
+	 *            Filename to check
 	 * @return &lt;code&gt;true&lt;/code&gt; if there is such a file, &lt;code&gt;false&lt;/code&gt; if not.
 	 */
 	private boolean hasFile(String filename) {
 		boolean result = false;
-		for (int i=0; i&lt;this.size(); i++) {
+		for (int i = 0; i &lt; this.size(); i++) {
 			if (this.get(i).getFilename().toUpperCase().equals(filename.toUpperCase())) {
 				result = true;
 				break;
@@ -214,47 +234,53 @@
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Deletes images that are no longer needed. It takes two CacheImage objects as arguments, one
-	 * as a collection of images before an update, the other after. Then every file in the old 
+	 * as a collection of images before an update, the other after. Then every file in the old
 	 * collection is checked if it is also present in the new collection. If not, the file is deleted.
 	 * Note that the &lt;i&gt;content&lt;/i&gt; of the files is irrelevant. It is only important to remove files
-	 * - regardles of their contents - if they are no longer referenced after a cache update. 
-	 * @param oldImages Set of images before update
-	 * @param newImages Set of images after update
+	 * - regardles of their contents - if they are no longer referenced after a cache update.
+	 * 
+	 * @param oldImages
+	 *            Set of images before update
+	 * @param newImages
+	 *            Set of images after update
 	 */
 	public static void cleanupOldImages(CacheImages oldImages, CacheImages newImages) {
 		// Loop over every image in the old collection
-		for (int i=0; i&lt;oldImages.size(); i++) {
+		for (int i = 0; i &lt; oldImages.size(); i++) {
 			// Check if image file is present in new collection
 			String obsoleteFilename = oldImages.get(i).getFilename();
 			if (!newImages.hasFile(obsoleteFilename)) {
 				String location = Global.getProfile().dataDir + obsoleteFilename;
 				File tmpFile = new FileBugfix(location);
 				if (tmpFile.exists() &amp;&amp; tmpFile.canWrite()) {
-					Global.getPref().log(&quot;Image not longer needed. Deleting: &quot;+obsoleteFilename);
+					Global.getPref().log(&quot;Image not longer needed. Deleting: &quot; + obsoleteFilename);
 					tmpFile.delete();
 				}
 			}
 		}
 	}
-	
+
 	/**
 	 * Takes an image url and does some optimization: As img.groundspeak.com is the same as
-	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html, 
-	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to 
+	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html,
+	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to
 	 * identify identical pictures as such.
-	 * @param pUrl URL to modify
+	 * 
+	 * @param pUrl
+	 *            URL to modify
 	 * @return Same URL, eventually modified
 	 */
 	public static String optimizeLink(String pUrl) {
-		String url = pUrl;
+		String url = STRreplace.replace(pUrl, &quot;\n&quot;, &quot;&quot;);
+		url = STRreplace.replace(pUrl, &quot;\r&quot;, &quot;&quot;);
 		// img.groundspeak.com is same as img.geocaching.com, so replace it
 		if (url.toLowerCase().startsWith(&quot;<A HREF="http://img.groundspeak.com/">http://img.groundspeak.com/</A>&quot;)) {
 			url = &quot;<A HREF="http://img.geocaching.com/">http://img.geocaching.com/</A>&quot; + url.substring(27);
 		}
 		return url;
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/exp/SpoilerPOIExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheImages;
 import CacheWolf.Common;
@@ -35,18 +36,18 @@
 import ewe.sys.Time;
 import ewe.ui.FormBase;
 
-/** 
+/**
  * 
  * @author Kalle
- * Class to create a gpx-File with links to the pictures of a 
- * cache, which is used as input for the POILoader from Garmin.
+ *         Class to create a gpx-File with links to the pictures of a
+ *         cache, which is used as input for the POILoader from Garmin.
  */
 
 public class SpoilerPOIExporter extends Exporter {
 	private SpoilerPOIExporterScreen infoScreen;
 	private boolean onlySpoiler;
-	
-	public SpoilerPOIExporter(Preferences p, Profile prof){
+
+	public SpoilerPOIExporter(Preferences p, Profile prof) {
 		super();
 		this.setMask(&quot;*.gpx&quot;);
 		this.setHowManyParams(LAT_LON);
@@ -55,19 +56,19 @@
 
 	public void doIt() {
 		infoScreen = new SpoilerPOIExporterScreen(&quot;SpoilerPOIExport&quot;);
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		onlySpoiler = infoScreen.getOnlySpoiler();
 		super.doIt();
 	}
-	
-	public String header () {
+
+	public String header() {
 		StringBuffer strBuf = new StringBuffer(200);
 		Time tim = new Time();
 
 		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; standalone=\&quot;no\&quot; ?&gt;\r\n&quot;);
-		strBuf.append(&quot;&lt;gpx xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/1\">http://www.topografix.com/GPX/1/1\</A>&quot; creator=\&quot;CacheWolf\&quot; version=\&quot;1.1\&quot;&quot; +
-				      &quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; &quot; +
-				      &quot;xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/1">http://www.topografix.com/GPX/1/1</A> <A HREF="http://www.topografix.com/GPX/1/1/gpx.xsd\">http://www.topografix.com/GPX/1/1/gpx.xsd\</A>&quot;&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;gpx xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/1\">http://www.topografix.com/GPX/1/1\</A>&quot; creator=\&quot;CacheWolf\&quot; version=\&quot;1.1\&quot;&quot; + &quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; &quot;
+				+ &quot;xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/1">http://www.topografix.com/GPX/1/1</A> <A HREF="http://www.topografix.com/GPX/1/1/gpx.xsd\">http://www.topografix.com/GPX/1/1/gpx.xsd\</A>&quot;&gt;\r\n&quot;);
 		strBuf.append(&quot;  &lt;metadata&gt;\r\n&quot;);
 		strBuf.append(&quot;    &lt;link href=\&quot;<A HREF="http://www.cachewolf.de\">http://www.cachewolf.de\</A>&quot;&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;text&gt;CacheWolf&lt;/text&gt;\r\n&quot;);
@@ -78,48 +79,54 @@
 		strBuf.append(&quot;  &lt;/metadata&gt;\r\n&quot;);
 		return strBuf.toString();
 	}
-	
+
 	public String record(CacheHolder ch, String lat, String lon) {
 		StringBuffer strBuf = new StringBuffer(1000);
-		String comment,filename, url;
+		String comment, filename, url;
 		CacheImages images;
 		int picCounter;
-		
+
 		// Makes only sense for main waypoints
-		if (ch.isAddiWpt()) return null;
-		
+		if (ch.isAddiWpt())
+			return null;
+
 		// First check, if there a any pictures in the db for the wpt
 		ch.getCacheDetails(true);
-		if (! ch.detailsLoaded()) return null;
-		if (ch.getCacheDetails(true).images.size() == 0) return null;
-		
+		if (!ch.detailsLoaded())
+			return null;
+		if (ch.getCacheDetails(true).images.size() == 0)
+			return null;
+
 		images = ch.getCacheDetails(true).images.getDisplayImages(ch.getWayPoint());
 		picCounter = 0;
-		for (int i=0; i &lt; images.size(); i++ ) {
+		for (int i = 0; i &lt; images.size(); i++) {
 			filename = images.get(i).getFilename();
 			comment = images.get(i).getTitle();
 			url = profile.dataDir + filename;
-			
+
 			// POILoader can only work with JPG-Files
-			if ( !filename.endsWith(&quot;.jpg&quot;)) continue;
+			if (!filename.endsWith(&quot;.jpg&quot;))
+				continue;
 			// Try to export only Spoiler
-			if ( onlySpoiler &amp;&amp; (comment.indexOf(&quot;oiler&quot;) &lt; 1)) continue;
+			if (onlySpoiler &amp;&amp; (comment.indexOf(&quot;oiler&quot;) &lt; 1))
+				continue;
 			// check if the file is not deleted
-			if (!(new FileBugfix(url)).exists()) continue;
-			
+			if (!(new FileBugfix(url)).exists())
+				continue;
+
 			picCounter++;
 			strBuf.append(&quot;&lt;wpt lat=\&quot;&quot; + lat + &quot;\&quot; lon=\&quot;&quot; + lon + &quot;\&quot;&gt;\r\n&quot;);
-			strBuf.append(&quot;  &lt;name&gt;Sp &quot; + picCounter + &quot;: &quot; + SafeXML.cleanGPX(ch.cacheName) + &quot;&lt;/name&gt;\r\n&quot;);
+			strBuf.append(&quot;  &lt;name&gt;Sp &quot; + picCounter + &quot;: &quot; + SafeXML.cleanGPX(ch.getCacheName()) + &quot;&lt;/name&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;cmt&gt;\r\n&quot;);
-			if (ch.getCacheDetails(true).Hints.length()&gt; 0){
+			if (ch.getCacheDetails(true).Hints.length() &gt; 0) {
 				strBuf.append(&quot;  Hint: &quot; + SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints)) + &quot;\r\n&quot;);
 			}
-			if (comment != null){
+			if (comment != null) {
 				strBuf.append(&quot;  Comment: &quot; + SafeXML.cleanGPX(SafeXML.cleanback(comment)) + &quot;\r\n&quot;);
 			}
 			strBuf.append(&quot;  &lt;/cmt&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;desc&gt;GCcode: &quot; + ch.getWayPoint() + &quot; &lt;/desc&gt;\r\n&quot;);
-			strBuf.append(&quot;   &lt;link href=\&quot;&quot; + URLUTF8Encoder.encode(url, false)  + &quot;\&quot;/&gt;\r\n&quot;);
+			strBuf.append(&quot;   &lt;link href=\&quot;&quot; + URLUTF8Encoder.encode(url, false) + &quot;\&quot;/&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;sym&gt;Scenic Area&lt;/sym&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;extensions&gt;\r\n&quot;);
 			strBuf.append(&quot;     &lt;gpxx:WaypointExtension xmlns:gpxx=\&quot;<A HREF="http://www.garmin.com/xmlschemas/GpxExtensions/v3\">http://www.garmin.com/xmlschemas/GpxExtensions/v3\</A>&quot;&gt;\r\n&quot;);
@@ -129,10 +136,10 @@
 			strBuf.append(&quot;&lt;/wpt&gt;\r\n&quot;);
 			strBuf.append(&quot;\r\n&quot;);
 		}
-	
+
 		return strBuf.toString();
 	}
-	
+
 	public String trailer() {
 		return &quot;&lt;/gpx&gt;\r\n&quot;;
 	}

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -105,7 +105,7 @@
 					url = baseurl + &quot;mode=locate&amp;lat=&quot; + nLat + &quot;&amp;lon=&quot; + nLon;
 					result = SafeXML.cleanback(UrlFetcher.fetch(url));
 					String ocCacheName = new Extractor(result, &quot;name=\&quot;&quot;, &quot;\&quot;&quot;, 0, true).findNext();
-					if (ch.cacheName.equals(ocCacheName)) {
+					if (ch.getCacheName().equals(ocCacheName)) {
 						hasOC = true;
 					} else {
 						int start = result.indexOf(&quot;coords=\&quot;&quot;) + 8;

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/myTableControl.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -376,7 +376,7 @@
 			if (ch.pos.isValid()) {
 				String lat = &quot;&quot; + ch.pos.getLatDeg(CWPoint.DD);
 				String lon = &quot;&quot; + ch.pos.getLonDeg(CWPoint.DD);
-				String nameOfCache = UrlFetcher.encodeURL(ch.cacheName, false).replace('#', 'N').replace('@', '_');
+				String nameOfCache = UrlFetcher.encodeURL(ch.getCacheName(), false).replace('#', 'N').replace('@', '_');
 				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
 				if (!pref.language.equalsIgnoreCase(&quot;auto&quot;)) {
 					language = pref.language;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003031.html">[Cachewolf-svn] r3040 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="003033.html">[Cachewolf-svn] r3042 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3032">[ date ]</a>
              <a href="thread.html#3032">[ thread ]</a>
              <a href="subject.html#3032">[ subject ]</a>
              <a href="author.html#3032">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
