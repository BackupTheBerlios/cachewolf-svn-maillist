<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3045 - in trunk/src/CacheWolf: . exp imp navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-July/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3045%20-%20in%20trunk/src/CacheWolf%3A%20.%20exp%20imp%20navi&In-Reply-To=%3C20110721102635.68E07483458%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003035.html">
   <LINK REL="Next"  HREF="003034.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3045 - in trunk/src/CacheWolf: . exp imp navi</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3045%20-%20in%20trunk/src/CacheWolf%3A%20.%20exp%20imp%20navi&In-Reply-To=%3C20110721102635.68E07483458%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3045 - in trunk/src/CacheWolf: . exp imp navi">araber95 at mail.berlios.de
       </A><BR>
    <I>Thu Jul 21 12:26:34 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003035.html">[Cachewolf-svn] r3044 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="003034.html">[Cachewolf-svn] r3043 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3036">[ date ]</a>
              <a href="thread.html#3036">[ thread ]</a>
              <a href="subject.html#3036">[ subject ]</a>
              <a href="author.html#3036">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-07-21 12:26:34 +0200 (Thu, 21 Jul 2011)
New Revision: 3045

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/exp/DistanceComparer.java
   trunk/src/CacheWolf/exp/ExploristExporter.java
   trunk/src/CacheWolf/exp/Exporter.java
   trunk/src/CacheWolf/exp/GpxExportNg.java
   trunk/src/CacheWolf/exp/KMLExporter.java
   trunk/src/CacheWolf/exp/LocExporter.java
   trunk/src/CacheWolf/exp/TPLExporter.java
   trunk/src/CacheWolf/exp/TomTomExporter.java
   trunk/src/CacheWolf/imp/GPXImporter.java
   trunk/src/CacheWolf/imp/LOCXMLImporter.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
   trunk/src/CacheWolf/imp/OCXMLImporter.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapLoader.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/Navigate.java
Log:
using getter and setter for CacheHolder CWPoint pos.
removed String latLon and their getter and setter from CacheHolder (this is pos.toString())

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -28,6 +28,7 @@
 import CacheWolf.exp.Exporter;
 import CacheWolf.exp.GarminMap;
 import CacheWolf.navi.Metrics;
+import CacheWolf.navi.TrackPoint;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -62,9 +63,7 @@
 	/** The alias of the owner */
 	private String cacheOwner = EMPTY;
 	/** The coordinates of the cache */
-	public CWPoint pos = new CWPoint();
-	/** The coordinates of the cache */
-	private String LatLon = pos.toString();
+	private CWPoint pos = new CWPoint();
 	/** The date when the cache was hidden in format yyyy-mm-dd */
 	private String dateHidden = EMPTY;
 	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
@@ -182,8 +181,7 @@
 				start = xmlString.indexOf('&quot;', end + 1);
 				end = xmlString.indexOf('&quot;', start + 1);
 				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
-				pos = new CWPoint(lat, lon);
-				LatLon = pos.toString();
+				pos.set(lat, lon);
 
 				start = xmlString.indexOf('&quot;', end + 1);
 				end = xmlString.indexOf('&quot;', start + 1);
@@ -343,7 +341,6 @@
 				end = xmlString.indexOf('&quot;', start + 1);
 				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
 				pos = new CWPoint(lat, lon);
-				LatLon = pos.toString();
 
 				start = xmlString.indexOf('&quot;', end + 1);
 				end = xmlString.indexOf('&quot;', start + 1);
@@ -492,7 +489,6 @@
 		if (ch.pos.isValid() || !this.pos.isValid()) {
 			if (mayChangeCoordinates) {
 				this.pos = ch.pos;
-				this.LatLon = ch.LatLon;
 			}
 		}
 		this.setWayPoint(ch.getWayPoint());
@@ -655,7 +651,7 @@
 		varParams.put(&quot;DISTANCE&quot;, decSep.replaceAll(getDistance()));
 		varParams.put(&quot;BEARING&quot;, bearing);
 		if ((pos != null &amp;&amp; pos.isValid())) {
-			varParams.put(&quot;LATLON&quot;, decSep.replaceAll(LatLon));
+			varParams.put(&quot;LATLON&quot;, decSep.replaceAll(pos.toString()));
 			varParams.put(&quot;LAT&quot;, decSep.replaceAll(pos.getLatDeg(CWPoint.DD)));
 			varParams.put(&quot;LON&quot;, decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));
 		} else {
@@ -1492,16 +1488,14 @@
 
 	// Getter and Setter for private properties
 
-	public String getLatLon() {
-		return LatLon;
+	public CWPoint getPos() {
+		return pos;
 	}
 
-	public void setLatLon(String _LatLon) {
-		_LatLon = _LatLon.trim();
-		if (!_LatLon.equals(LatLon.trim()))
+	public void setPos(TrackPoint _pos) {
+		if (!_pos.toString().equals(pos.toString()))
 			setUpdated(true);
-		LatLon = _LatLon;
-		pos.set(_LatLon);
+		pos.set(_pos);
 	}
 
 	public String getBearing() {

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/CalcPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -45,10 +45,10 @@
 import ewe.ui.formatted.TextDisplay;
 
 /**
-*	Class to create the panel to do calculation with waypoints&lt;br&gt;
-*	Also allows for creation of a custom waypoint.&lt;br&gt;
-*	Class ID 1400
-*/
+ *	Class to create the panel to do calculation with waypoints&lt;br&gt;
+ *	Also allows for creation of a custom waypoint.&lt;br&gt;
+ *	Class ID 1400
+ */
 
 /**
  * Wrapper class to pass bearing and distance
@@ -57,7 +57,7 @@
 	public double degrees;
 	public double distance;
 
-	public BearingDistance(){
+	public BearingDistance() {
 		this.degrees = 0;
 		this.distance = 0;
 	}
@@ -95,18 +95,17 @@
 	int currFormat;
 	mButton btnChangeLatLon;
 
-	public CalcPanel()	{
+	public CalcPanel() {
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		cacheDB = profile.cacheDB;
 
+		TopP.addNext(chkDD = new mCheckBox(&quot;d.d&#176;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMM = new mCheckBox(&quot;d&#176;m.m\'&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMS = new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkCustom = new mCheckBox(&quot;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		TopP.addNext(chkDD =new mCheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMM =new mCheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMS =new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		TopP.addNext(chkCustom =new mCheckBox(&quot;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-
 		chkDD.setGroup(chkFormat);
 		chkDMM.setGroup(chkFormat);
 		chkDMS.setGroup(chkFormat);
@@ -114,24 +113,25 @@
 		chkFormat.setInt(1);
 		currFormat = 1;
 		String[] ls = TransformCoordinates.getProjectedSystemNames();
-		TopP.addLast(localCooSystem = new mChoice(ls, 0),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addLast(localCooSystem = new mChoice(ls, 0), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		btnChangeLatLon=new mButton();
-		TopP.addLast(btnChangeLatLon,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//inpBearing and direction, unit for inpDistance
-		BottomP.addNext(new mLabel(MyLocale.getMsg(1403,&quot;Bearing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(new mLabel(MyLocale.getMsg(1404,&quot;Distance&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(inpBearing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		btnChangeLatLon = new mButton();
+		TopP.addLast(btnChangeLatLon, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpBearing and direction, unit for inpDistance
+		BottomP.addNext(new mLabel(MyLocale.getMsg(1403, &quot;Bearing&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(new mLabel(MyLocale.getMsg(1404, &quot;Distance&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(inpBearing = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpBearing.setText(&quot;0&quot;);
-		BottomP.addNext(inpDistance = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(inpDistance = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpDistance.setText(&quot;0&quot;);
 		// Check for narrow screen and reduce width of fields to avoid horizontal scroll panel
-		if (MyLocale.getScreenWidth()&lt;=240) {
+		if (MyLocale.getScreenWidth() &lt;= 240) {
 			FontMetrics fm = getFontMetrics(inpBearing.getFont());
-			inpBearing.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
-			inpDistance.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
+			inpBearing.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;), fm.getHeight() * 4 / 3);
+			inpDistance.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;), fm.getHeight() * 4 / 3);
 		}
-		BottomP.addLast(chcDistUnit = new mChoice(new String[]{&quot;m&quot;, &quot;km&quot;, MyLocale.getMsg(1407,&quot;steps&quot;), MyLocale.getMsg(1408,&quot;feet&quot;), MyLocale.getMsg(1409,&quot;yards&quot;), MyLocale.getMsg(1410,&quot;miles&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.INSETS,new ewe.fx.Insets(0,2,0,0));
+		BottomP.addLast(chcDistUnit = new mChoice(new String[] { &quot;m&quot;, &quot;km&quot;, MyLocale.getMsg(1407, &quot;steps&quot;), MyLocale.getMsg(1408, &quot;feet&quot;), MyLocale.getMsg(1409, &quot;yards&quot;), MyLocale.getMsg(1410, &quot;miles&quot;) }, 0), CellConstants.DONTSTRETCH,
+				(CellConstants.HFILL | CellConstants.WEST)).setTag(CellConstants.INSETS, new ewe.fx.Insets(0, 2, 0, 0));
 		if (Global.getPref().metricSystem == Metrics.METRIC) {
 			chcDistUnit.setInt(0); // Meter
 		} else {
@@ -139,19 +139,19 @@
 		}
 
 		// Buttons for calc and save
-		BottomP.addNext(btnCalc = new mButton(&quot;Calc&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnClear = new mButton(&quot;Clear&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnGoto = new mButton(&quot;Goto&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnCalc = new mButton(&quot;Calc&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnClear = new mButton(&quot;Clear&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnGoto = new mButton(&quot;Goto&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311, &quot;Create Waypoint&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
 		// Output
-		txtOutput = new TextDisplay(3,1); // Need to limit size for small screens
+		txtOutput = new TextDisplay(3, 1); // Need to limit size for small screens
 		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
-		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4, 1)), CellConstants.STRETCH, (CellConstants.FILL | CellConstants.WEST));
 
-		//add Panels
-		this.addLast(TopP,CellConstants.HSTRETCH, CellConstants.WEST);//.setTag(SPAN,new Dimension(4,1));
-		this.addLast(BottomP,CellConstants.VSTRETCH, CellConstants.VFILL|CellConstants.WEST); //.setTag(SPAN,new Dimension(4,1));
+		// add Panels
+		this.addLast(TopP, CellConstants.HSTRETCH, CellConstants.WEST);// .setTag(SPAN,new Dimension(4,1));
+		this.addLast(BottomP, CellConstants.VSTRETCH, CellConstants.VFILL | CellConstants.WEST); // .setTag(SPAN,new Dimension(4,1));
 
 	}
 
@@ -159,13 +159,13 @@
 		return CoordsScreen.getLocalSystem(currFormat);
 	}
 
-	public final void readFields(CWPoint coords, BearingDistance degKm){
+	public final void readFields(CWPoint coords, BearingDistance degKm) {
 		// coords.set(btnChangeLatLon.getText());
 		currFormat = CoordsScreen.combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt());
 		degKm.degrees = Common.parseDouble(inpBearing.getText());
 
 		double rawDistance = Common.parseDouble(inpDistance.getText());
-		switch ( chcDistUnit.getInt() ) {
+		switch (chcDistUnit.getInt()) {
 		case 0:
 			// meter
 			degKm.distance = rawDistance / 1000.0;
@@ -199,88 +199,81 @@
 	}
 
 	// ch must not be null
-	public void setFields(CacheHolder ch){
-		if ( !ch.getWayPoint().equalsIgnoreCase(lastWaypoint) ) {
+	public void setFields(CacheHolder ch) {
+		if (!ch.getWayPoint().equalsIgnoreCase(lastWaypoint)) {
 			lastWaypoint = ch.getWayPoint();
-			if (ch.pos.isValid()) {
+			if (ch.getPos().isValid()) {
 				inpBearing.setText(&quot;0&quot;);
 				inpDistance.setText(&quot;0&quot;);
-
-				//currFormat = 1;
-				if (ch.getLatLon().length()== 0) coordInp.set(0,0);
-				else coordInp.set(ch.getLatLon(), TransformCoordinates.CW);
+				coordInp.set(ch.getPos());
 				setFields();
 			}
 		}
 	}
 
-
 	public void setFields() {
 		btnChangeLatLon.setText(coordInp.toString(getLocalCooSystem()));
-		//chkFormat.selectIndex(currFormat);
+		// chkFormat.selectIndex(currFormat);
 	}
 
+	public void onEvent(Event ev) {
 
-	public void onEvent(Event ev){
-
-
-
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == chkFormat
-					|| ((ev.type == ControlEvent.PRESSED) &amp;&amp; (ev.target == localCooSystem )) ) {
-				if (ev.target == localCooSystem) chkFormat.selectIndex(3);
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == chkFormat || ((ev.type == ControlEvent.PRESSED) &amp;&amp; (ev.target == localCooSystem))) {
+				if (ev.target == localCooSystem)
+					chkFormat.selectIndex(3);
 				readFields(coordInp, bd);
 				setFields();
 				this.repaintNow();
 			}
 
-			if (ev.target == btnCalc){
+			if (ev.target == btnCalc) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				txtOutput.appendText(coordOut.toString(getLocalCooSystem())+ &quot;\n&quot;,true);
+				txtOutput.appendText(coordOut.toString(getLocalCooSystem()) + &quot;\n&quot;, true);
 			}
-			if (ev.target == btnClear){
+			if (ev.target == btnClear) {
 				txtOutput.setText(&quot;&quot;);
 			}
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				ch.setLatLon(coordOut.toString());
-				ch.pos.set(coordOut);
+				ch.setPos(coordOut);
 				ch.setType(CacheType.CW_TYPE_STAGE); // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 
-			if (ev.target == btnGoto){
+			if (ev.target == btnGoto) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				mainT.gotoP.setDestinationAndSwitch(coordOut);
 			}
-			
-			if (ev.target == btnChangeLatLon){
-				if(Vm.isMobile()){
+
+			if (ev.target == btnChangeLatLon) {
+				if (Vm.isMobile()) {
 					readFields(coordInp, bd);
 					InputScreen InScr = new InputScreen(getLocalCooSystem());
-					if (coordInp.isValid())	InScr.setCoords(coordInp);
-						else InScr.setCoords(new CWPoint(0,0));
-				if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
-				{
-					btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(InScr.getCoords());
+					if (coordInp.isValid())
+						InScr.setCoords(coordInp);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
+					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
+						btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(InScr.getCoords());
+					}
+				} else {
+					CoordsScreen cs = new CoordsScreen();
+					readFields(coordInp, bd);
+					cs.setFields(coordInp, getLocalCooSystem());
+					if (cs.execute() == FormBase.IDOK) {
+						btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(cs.getCoords());
+					}
 				}
-			}else{
-				CoordsScreen cs = new CoordsScreen();
-				readFields(coordInp, bd);
-				cs.setFields(coordInp, getLocalCooSystem());
-				if (cs.execute()== FormBase.IDOK){
-					btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(cs.getCoords());
-				}
-			}
 
+			}
+			super.onEvent(ev);
 		}
-		super.onEvent(ev);
 	}
-	}
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/DetailsPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -345,7 +345,7 @@
 		dirtyDetails = false;
 		inpWaypoint.setText(ch.getWayPoint());
 		inpName.setText(ch.getCacheName());
-		btnCoordinates.setText(ch.pos.toString());
+		btnCoordinates.setText(ch.getPos().toString());
 		inpHidden.setText(mainCache.getDateHidden());
 		inpOwner.setText(mainCache.getCacheOwner());
 		chcStatus.setText(ch.getStatusText());
@@ -508,7 +508,7 @@
 					waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
 				}
 			} else if (ev.target == btnShowMap) {
-				Global.mainTab.SwitchToMovingMap(cache.pos, true);
+				Global.mainTab.SwitchToMovingMap(cache.getPos(), true);
 			} else if (ev.target == btnShowBug) {
 				// InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
 				// &quot;Travelbugs&quot;,
@@ -566,8 +566,7 @@
 				blackStatusChanged = true;
 			} else if (ev.target == btnNewWpt) {
 				final CacheHolder ch = new CacheHolder();
-				ch.setLatLon(cache.getLatLon());
-				ch.pos = new CWPoint(cache.pos);
+				ch.setPos(cache.getPos());
 				ch.setType(CacheType.CW_TYPE_STAGE);
 				ch.setHard(CacheTerrDiff.CW_DT_UNSET);
 				ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
@@ -587,10 +586,8 @@
 					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
 						dirtyDetails = true;
 						coords = InScr.getCoords();
-						Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-						cache.pos.set(coords);
+						cache.setPos(coords);
 						btnCoordinates.setText(coords.toString());
-						cache.setLatLon(coords.toString());
 						// If the current centre is valid, calculate the distance and bearing to it
 						final CWPoint centre = Global.getPref().getCurCentrePt();
 						if (centre.isValid()) {
@@ -603,10 +600,8 @@
 					if (cs.execute() == FormBase.IDOK) {
 						dirtyDetails = true;
 						coords = cs.getCoords();
-						Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-						cache.pos.set(coords);
+						cache.setPos(coords);
 						btnCoordinates.setText(coords.toString());
-						cache.setLatLon(coords.toString());
 						// If the current centre is valid, calculate the distance and bearing to it
 						final CWPoint centre = Global.getPref().getCurCentrePt();
 						if (centre.isValid()) {
@@ -771,7 +766,6 @@
 		if (cache.getWayPoint().length() &lt; 2)
 			cache.setWayPoint(cache.getWayPoint() + &quot; &quot;);
 		cache.setCacheName(inpName.getText().trim());
-		cache.setLatLon(cache.pos.toString());
 		if (!cache.isAddiWpt()) {
 			cache.setDateHidden(inpHidden.getText().trim());
 		}

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/Filter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,31 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import CacheWolf.imp.KMLImporter;
-import CacheWolf.navi.TransformCoordinates;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -40,21 +40,22 @@
 import ewe.util.Vector;
 
 /**
-*	Class that actually filters the cache database.&lt;br&gt;
-*	The class that uses this filter must set the different public variables.
-*   @author BilboWolf (optimiert von salzkammergut)
-*/
-public class Filter{
-	public static final int FILTER_INACTIVE=0;
-	public static final int FILTER_ACTIVE=1;
-	public static final int FILTER_CACHELIST=2;
-	public static final int FILTER_MARKED_ONLY=3;
-	
+ * Class that actually filters the cache database.&lt;br&gt;
+ * The class that uses this filter must set the different public variables.
+ * 
+ * @author BilboWolf (optimiert von salzkammergut)
+ */
+public class Filter {
+	public static final int FILTER_INACTIVE = 0;
+	public static final int FILTER_ACTIVE = 1;
+	public static final int FILTER_CACHELIST = 2;
+	public static final int FILTER_MARKED_ONLY = 3;
+
 	/** Indicator whether a filter is inverted */
-	//public static boolean filterInverted=false;
+	// public static boolean filterInverted=false;
 	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
-	//public static int filterActive=FILTER_INACTIVE;
-	
+	// public static int filterActive=FILTER_INACTIVE;
+
 	private static final int SMALLER = -1;
 	private static final int EQUAL = 0;
 	private static final int GREATER = 1;
@@ -75,123 +76,125 @@
 	private static final int NW = 8192;
 	private static final int NNW = 16384;
 	private static final int S = 32768;
-	private static final int ROSE_ALL= N|NNE|NE|ENE|E|ESE|SE|SSE|SSW|SW|WSW|W|WNW|NW|NNW|S;
+	private static final int ROSE_ALL = N | NNE | NE | ENE | E | ESE | SE | SSE | SSW | SW | WSW | W | WNW | NW | NNW | S;
 
 	private int distdirec = 0;
 	private int diffdirec = 0;
 	private int terrdirec = 0;
-	
+
 	String[] byVec;
-	
-	
+
 	private int roseMatchPattern;
 	private boolean hasRoseMatchPattern;
 	private int typeMatchPattern;
 	private boolean hasTypeMatchPattern;
 	private int sizeMatchPattern;
 	private boolean hasSizeMatchPattern;
-	
+
 	private boolean foundByMe;
 	private boolean notFoundByMe;
 
 	private String cacheStatus;
 	private boolean useRegexp;
 	private boolean filterNoCoord;
-	
+
 	private boolean ownedByMe;
 	private boolean notOwnedByMe;
 
 	double fscDist;
 	double fscTerr;
 	double fscDiff;
-	
+
 	private boolean archived = false;
 	private boolean notArchived = false;
-	
-	private boolean available=false;
+
+	private boolean available = false;
 	private boolean notAvailable = false;
-	double pi180=java.lang.Math.PI / 180.0;
+	double pi180 = java.lang.Math.PI / 180.0;
 
-	private long[] attributesPattern = {0l,0l,0l,0l};
+	private long[] attributesPattern = { 0l, 0l, 0l, 0l };
 	private int attributesChoice = 0;
-	
+
 	/**
-	*	Apply a route filter. Each waypoint is on a seperate line.
-	*	We use a regex method to allow for different formats of waypoints:
-	*	possible is currently: DD MM.mmm
-	*/
-	public void doFilterRoute(File routeFile, double distance){
+	 * Apply a route filter. Each waypoint is on a seperate line.
+	 * We use a regex method to allow for different formats of waypoints:
+	 * possible is currently: DD MM.mmm
+	 */
+	public void doFilterRoute(File routeFile, double distance) {
 		Global.getProfile().selectionChanged = true;
-	    CacheDB cacheDB=Global.getProfile().cacheDB;
-		//load file into a vector:
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		// load file into a vector:
 		Vector wayPoints = new Vector();
 		Regex rex = new Regex(&quot;(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})&quot;);
 		CWPoint cwp, fromPoint, toPoint;
 		CacheHolder ch;
-		double lat,lon, calcDistance = 0;
-		try{
-			if((routeFile.getFullPath()).indexOf(&quot;.kml&quot;) &gt; 0){
+		double lat, lon, calcDistance = 0;
+		try {
+			if ((routeFile.getFullPath()).indexOf(&quot;.kml&quot;) &gt; 0) {
 				KMLImporter kml = new KMLImporter(routeFile.getFullPath());
 				kml.importFile();
 				wayPoints = kml.getPoints();
 			} else {
 				FileReader in = new FileReader(routeFile);
-				String line; 
-				while((line = in.readLine()) != null){
+				String line;
+				while ((line = in.readLine()) != null) {
 					rex.search(line);
 					// parse the route file
-					if(rex.didMatch()){
-						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
-						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-					
-						if(rex.stringMatched(1).equals(&quot;S&quot;) || rex.stringMatched(1).equals(&quot;s&quot;)) lat = -lat;
-						if(rex.stringMatched(6).equals(&quot;W&quot;) || rex.stringMatched(6).equals(&quot;w&quot;)) lon = -lon;	
-					
+					if (rex.didMatch()) {
+						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3)) / 60 + Convert.toDouble(rex.stringMatched(5)) / 60000;
+						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8)) / 60 + Convert.toDouble(rex.stringMatched(10)) / 60000;
+
+						if (rex.stringMatched(1).equals(&quot;S&quot;) || rex.stringMatched(1).equals(&quot;s&quot;))
+							lat = -lat;
+						if (rex.stringMatched(6).equals(&quot;W&quot;) || rex.stringMatched(6).equals(&quot;w&quot;))
+							lon = -lon;
+
 						cwp = new CWPoint(lat, lon);
-						
+
 						wayPoints.add(cwp);
 					}
 				}
 			}
-			//initialise database
-			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			// initialise database
+			for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 				ch = cacheDB.get(i);
 				ch.in_range = false;
-				//cacheDB.set(i, ch);
+				// cacheDB.set(i, ch);
 			}
 			// for each segment of the route...
-			for(int z=0;z&lt;wayPoints.size()-1;z++){
+			for (int z = 0; z &lt; wayPoints.size() - 1; z++) {
 				fromPoint = new CWPoint();
 				toPoint = new CWPoint();
-				fromPoint = (CWPoint)wayPoints.get(z);
-				toPoint = (CWPoint)wayPoints.get(z+1);
-				//... go through the current cache database
-				for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+				fromPoint = (CWPoint) wayPoints.get(z);
+				toPoint = (CWPoint) wayPoints.get(z + 1);
+				// ... go through the current cache database
+				for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 					ch = cacheDB.get(i);
-					cwp = new CWPoint(ch.getLatLon(), TransformCoordinates.CW);
+					cwp = new CWPoint(ch.getPos());
 					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
-					calcDistance = (calcDistance*180*60)/java.lang.Math.PI;
+					calcDistance = (calcDistance * 180 * 60) / java.lang.Math.PI;
 					calcDistance = calcDistance * 1.852;
-					if(calcDistance &lt;= distance) {
+					if (calcDistance &lt;= distance) {
 						ch.in_range = true;
 					}
 				} // for database
 			} // for segments
-			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 				ch = cacheDB.get(i);
-				if(ch.is_filtered() == false &amp;&amp; ch.in_range == false) ch.setFiltered(true);
+				if (ch.is_filtered() == false &amp;&amp; ch.in_range == false)
+					ch.setFiltered(true);
 			}
-		}catch(FileNotFoundException fnex){
+		} catch (FileNotFoundException fnex) {
 			(new MessageBox(&quot;Error&quot;, &quot;File not found&quot;, FormBase.OKB)).execute();
-		}catch(IOException ioex){
+		} catch (IOException ioex) {
 			(new MessageBox(&quot;Error&quot;, &quot;Problem reading file!&quot;, FormBase.OKB)).execute();
 		}
 	}
-	
+
 	/**
-	*	Method to calculate the distance of a point to a segment
-	*/
-	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp){
+	 * Method to calculate the distance of a point to a segment
+	 */
+	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp) {
 		double dist = 0;
 		double px = cwp.lonDec * pi180;
 		double py = cwp.latDec * pi180;
@@ -201,91 +204,114 @@
 		double Y2 = toPoint.latDec * pi180;
 		double dx = X2 - X1;
 		double dy = Y2 - Y1;
-		if(dx == 0 &amp;&amp; dy == 0){
+		if (dx == 0 &amp;&amp; dy == 0) {
 			// have a point and not a segment!
 			dx = px - X1;
 			dy = py - Y1;
-			return java.lang.Math.sqrt(dx*dx + dy*dy);
+			return java.lang.Math.sqrt(dx * dx + dy * dy);
 		}
-		dist = Matrix.cross(X1,Y1,X2,Y2,px,py) / Matrix.dist(X1,Y1,X2,Y2);
-		double dot1 = Matrix.dot(X1,Y1,X2,Y2,px,py);
-		if(dot1 &gt; 0) return Matrix.dist(X2,Y2,px,py);
-		double dot2 = Matrix.dot(X2,Y2,X1,Y1,px,py);
-		if(dot2 &gt; 0) return Matrix.dist(X1,Y1,px,py);
+		dist = Matrix.cross(X1, Y1, X2, Y2, px, py) / Matrix.dist(X1, Y1, X2, Y2);
+		double dot1 = Matrix.dot(X1, Y1, X2, Y2, px, py);
+		if (dot1 &gt; 0)
+			return Matrix.dist(X2, Y2, px, py);
+		double dot2 = Matrix.dot(X2, Y2, X1, Y1, px, py);
+		if (dot2 &gt; 0)
+			return Matrix.dist(X1, Y1, px, py);
 		dist = java.lang.Math.abs(dist);
 		return dist;
-		
+
 	}
-	
+
 	/**
 	 * Set the filter from the filter data stored in the profile
 	 * (the filterscreen also updates the profile)
 	 */
 	public void setFilter() {
-		Profile profile=Global.getProfile();
-		archived     = profile.getFilterVar().charAt(0) == '1';
-		available    = profile.getFilterVar().charAt(1) == '1';
-		foundByMe    = profile.getFilterVar().charAt(2) == '1';
-		ownedByMe    = profile.getFilterVar().charAt(3) == '1';
-		notArchived  = profile.getFilterVar().charAt(4) == '1';
+		Profile profile = Global.getProfile();
+		archived = profile.getFilterVar().charAt(0) == '1';
+		available = profile.getFilterVar().charAt(1) == '1';
+		foundByMe = profile.getFilterVar().charAt(2) == '1';
+		ownedByMe = profile.getFilterVar().charAt(3) == '1';
+		notArchived = profile.getFilterVar().charAt(4) == '1';
 		notAvailable = profile.getFilterVar().charAt(5) == '1';
 		notFoundByMe = profile.getFilterVar().charAt(6) == '1';
 		notOwnedByMe = profile.getFilterVar().charAt(7) == '1';
-		cacheStatus  = profile.getFilterStatus();
-		useRegexp    = profile.getFilterUseRegexp();
+		cacheStatus = profile.getFilterStatus();
+		useRegexp = profile.getFilterUseRegexp();
 		filterNoCoord = profile.getFilterNoCoord();
-		
-		typeMatchPattern=CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
-		hasTypeMatchPattern=CacheType.hasTypeMatchPattern(typeMatchPattern);
-		roseMatchPattern=0;
-		String filterRose=profile.getFilterRose();
-		if (filterRose.charAt(0) == '1') roseMatchPattern|=NW;
-		if (filterRose.charAt(1) == '1') roseMatchPattern|=NNW;
-		if (filterRose.charAt(2) == '1') roseMatchPattern|=N;
-		if (filterRose.charAt(3) == '1') roseMatchPattern|=NNE;
-		if (filterRose.charAt(4) == '1') roseMatchPattern|=NE;
-		if (filterRose.charAt(5) == '1') roseMatchPattern|=ENE;
-		if (filterRose.charAt(6) == '1') roseMatchPattern|=E;
-		if (filterRose.charAt(7) == '1') roseMatchPattern|=ESE;
-		if (filterRose.charAt(8) == '1') roseMatchPattern|=SE;
-		if (filterRose.charAt(9) == '1') roseMatchPattern|=SSE;
-		if (filterRose.charAt(10) == '1') roseMatchPattern|=S;
-		if (filterRose.charAt(11) == '1') roseMatchPattern|=SSW;
-		if (filterRose.charAt(12) == '1') roseMatchPattern|=SW;
-		if (filterRose.charAt(13) == '1') roseMatchPattern|=WSW;
-		if (filterRose.charAt(14) == '1') roseMatchPattern|=W;
-		if (filterRose.charAt(15) == '1') roseMatchPattern|=WNW;
-		hasRoseMatchPattern=roseMatchPattern!=ROSE_ALL;
-		sizeMatchPattern=0;
-		String filterSize=profile.getFilterSize();
-		if (filterSize.charAt(0) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_MICRO;
-		if (filterSize.charAt(1) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_SMALL;
-		if (filterSize.charAt(2) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NORMAL;
-		if (filterSize.charAt(3) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_LARGE;
-		if (filterSize.charAt(4) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_VERYLARGE;
-		if (filterSize.charAt(5) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NONPHYSICAL;
-		hasSizeMatchPattern=sizeMatchPattern!=CacheSize.CW_FILTER_ALL;
-		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER; 
-		fscDist = Common.parseDouble(profile.getFilterDist().substring(1));  // Distance
-		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : 
-					(profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER );
-		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1));  // Difficulty
-		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : 
-				(profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER );
-		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1));  // Terrain
+
+		typeMatchPattern = CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
+		hasTypeMatchPattern = CacheType.hasTypeMatchPattern(typeMatchPattern);
+		roseMatchPattern = 0;
+		String filterRose = profile.getFilterRose();
+		if (filterRose.charAt(0) == '1')
+			roseMatchPattern |= NW;
+		if (filterRose.charAt(1) == '1')
+			roseMatchPattern |= NNW;
+		if (filterRose.charAt(2) == '1')
+			roseMatchPattern |= N;
+		if (filterRose.charAt(3) == '1')
+			roseMatchPattern |= NNE;
+		if (filterRose.charAt(4) == '1')
+			roseMatchPattern |= NE;
+		if (filterRose.charAt(5) == '1')
+			roseMatchPattern |= ENE;
+		if (filterRose.charAt(6) == '1')
+			roseMatchPattern |= E;
+		if (filterRose.charAt(7) == '1')
+			roseMatchPattern |= ESE;
+		if (filterRose.charAt(8) == '1')
+			roseMatchPattern |= SE;
+		if (filterRose.charAt(9) == '1')
+			roseMatchPattern |= SSE;
+		if (filterRose.charAt(10) == '1')
+			roseMatchPattern |= S;
+		if (filterRose.charAt(11) == '1')
+			roseMatchPattern |= SSW;
+		if (filterRose.charAt(12) == '1')
+			roseMatchPattern |= SW;
+		if (filterRose.charAt(13) == '1')
+			roseMatchPattern |= WSW;
+		if (filterRose.charAt(14) == '1')
+			roseMatchPattern |= W;
+		if (filterRose.charAt(15) == '1')
+			roseMatchPattern |= WNW;
+		hasRoseMatchPattern = roseMatchPattern != ROSE_ALL;
+		sizeMatchPattern = 0;
+		String filterSize = profile.getFilterSize();
+		if (filterSize.charAt(0) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_MICRO;
+		if (filterSize.charAt(1) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_SMALL;
+		if (filterSize.charAt(2) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NORMAL;
+		if (filterSize.charAt(3) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_LARGE;
+		if (filterSize.charAt(4) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_VERYLARGE;
+		if (filterSize.charAt(5) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NONPHYSICAL;
+		hasSizeMatchPattern = sizeMatchPattern != CacheSize.CW_FILTER_ALL;
+		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER;
+		fscDist = Common.parseDouble(profile.getFilterDist().substring(1)); // Distance
+		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : (profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER);
+		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1)); // Difficulty
+		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : (profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER);
+		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1)); // Terrain
 		attributesPattern = profile.getFilterAttr();
 		attributesChoice = profile.getFilterAttrChoice();
 	}
-	
+
 	/**
-	*	Apply the filter. Caches that match a criteria are flagged
-	*	is_filtered = true. The table model is responsible for displaying or
-	*	not displaying a cache that is filtered.
-	*/
-	public void doFilter(){
-		CacheDB cacheDB=Global.getProfile().cacheDB;
+	 * Apply the filter. Caches that match a criteria are flagged
+	 * is_filtered = true. The table model is responsible for displaying or
+	 * not displaying a cache that is filtered.
+	 */
+	public void doFilter() {
+		CacheDB cacheDB = Global.getProfile().cacheDB;
 		Hashtable examinedCaches;
-		if (cacheDB.size()==0) return;
+		if (cacheDB.size() == 0)
+			return;
 		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
 			clearFilter();
 			return;
@@ -293,13 +319,14 @@
 		Global.getProfile().selectionChanged = true;
 		CacheHolder ch;
 		examinedCaches = new Hashtable(cacheDB.size());
-		
-		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
-			if (examinedCaches.containsKey(ch)) continue;
-			
+			if (examinedCaches.containsKey(ch))
+				continue;
+
 			boolean filterCache = excludedByFilter(ch);
-			if (!filterCache &amp;&amp; ch.mainCache!=null &amp;&amp; CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
+			if (!filterCache &amp;&amp; ch.mainCache != null &amp;&amp; CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
 				if (examinedCaches.containsKey(ch.mainCache)) {
 					filterCache = ch.mainCache.is_filtered();
 				} else {
@@ -308,270 +335,261 @@
 					examinedCaches.put(ch.mainCache, null);
 				}
 			}
-			ch.setFiltered(filterCache);			
+			ch.setFiltered(filterCache);
 		}
 		Global.getProfile().setFilterActive(FILTER_ACTIVE);
 		examinedCaches = null;
-		//Global.getProfile().hasUnsavedChanges=true;
+		// Global.getProfile().hasUnsavedChanges=true;
 	}
 
 	public boolean excludedByFilter(CacheHolder ch) {
-		//Match once against type pattern and once against rose pattern
-		//Default is_filtered = false, means will be displayed!
-		//If cache does not match type or rose pattern then is_filtered is set to true
+		// Match once against type pattern and once against rose pattern
+		// Default is_filtered = false, means will be displayed!
+		// If cache does not match type or rose pattern then is_filtered is set to true
 		// and we proceed to next cache (no further tests needed)
-		//Then we check the other filter criteria one by one: As soon as one is found that
+		// Then we check the other filter criteria one by one: As soon as one is found that
 		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
 		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
-	    int cacheTypePattern;
-	    int cacheRosePattern;
-	    int cacheSizePattern;
-	    double dummyd1;
-	    boolean cacheFiltered=false;
-	    do {
-	        ///////////////////////////////
-	        // Filter criterium 1: Cache type
-	        ///////////////////////////////
-	        if (hasTypeMatchPattern) { // Only do the checks if we have a filter
-	        	cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
-		        if ((cacheTypePattern &amp; typeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 2: Bearing from centre
-	        ///////////////////////////////
-	        // The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
-	        // By using else if we can reduce the number of comparisons from 16 to just over 8
-	        // By first checking the first letter, we can reduce the average number further to
-	        // just under 5
-	        if (hasRoseMatchPattern) {
-		        if (ch.getBearing().startsWith(&quot;N&quot;)) {
-			        if (ch.getBearing().equals(&quot;NW&quot;))
-				        cacheRosePattern = NW;
-			        else if (ch.getBearing().equals(&quot;NNW&quot;))
-				        cacheRosePattern = NNW;
-			        else if (ch.getBearing().equals(&quot;N&quot;))
-				        cacheRosePattern = N;
-			        else if (ch.getBearing().equals(&quot;NNE&quot;))
-				        cacheRosePattern = NNE;
-			        else
-				        cacheRosePattern = NE;
-		        } else if (ch.getBearing().startsWith(&quot;E&quot;)) {
-			        if (ch.getBearing().equals(&quot;ENE&quot;))
-				        cacheRosePattern = ENE;
-			        else if (ch.getBearing().equals(&quot;E&quot;))
-				        cacheRosePattern = E;
-			        else
-				        cacheRosePattern = ESE;
-		        } else if (ch.getBearing().startsWith(&quot;S&quot;)) {
-			        if (ch.getBearing().equals(&quot;SW&quot;))
-				        cacheRosePattern = SW;
-			        else if (ch.getBearing().equals(&quot;SSW&quot;))
-				        cacheRosePattern = SSW;
-			        else if (ch.getBearing().equals(&quot;S&quot;))
-				        cacheRosePattern = S;
-			        else if (ch.getBearing().equals(&quot;SSE&quot;))
-				        cacheRosePattern = SSE;
-			        else
-				        cacheRosePattern = SE;
-		        } else {
-			        if (ch.getBearing().equals(&quot;WNW&quot;))
-				        cacheRosePattern = WNW;
-			        else if (ch.getBearing().equals(&quot;W&quot;))
-				        cacheRosePattern = W;
-			        else if (ch.getBearing().equals(&quot;WSW&quot;))
-				        cacheRosePattern = WSW;
-			        else
-				        cacheRosePattern = 0;
-		        }
-		        if ((cacheRosePattern != 0) &amp;&amp; ((cacheRosePattern &amp; roseMatchPattern) == 0)) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 3: Distance
-	        ///////////////////////////////
-	        if (fscDist &gt; 0.0) {
-		        dummyd1 = ch.kilom;
-		        if (distdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDist) {
-			        cacheFiltered = true; break;
-		        }
-		        if (distdirec == GREATER &amp;&amp; dummyd1 &lt; fscDist) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 4: Difficulty
-	        ///////////////////////////////
-	        if (fscDiff &gt; 0.0) {
-		        dummyd1 = ch.getHard() / 10D;
-		        if (diffdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == EQUAL &amp;&amp; dummyd1 != fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == GREATER &amp;&amp; dummyd1 &lt; fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 5: Terrain
-	        ///////////////////////////////
-	        if (fscTerr &gt; 0.0) {
-	        	dummyd1 = ch.getTerrain() / 10D;
-		        if (terrdirec == SMALLER &amp;&amp; dummyd1 &gt; fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == EQUAL &amp;&amp; dummyd1 != fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == GREATER &amp;&amp; dummyd1 &lt; fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-	        }
+		int cacheTypePattern;
+		int cacheRosePattern;
+		int cacheSizePattern;
+		double dummyd1;
+		boolean cacheFiltered = false;
+		do {
+			// /////////////////////////////
+			// Filter criterium 1: Cache type
+			// /////////////////////////////
+			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
+				cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
+				if ((cacheTypePattern &amp; typeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 2: Bearing from centre
+			// /////////////////////////////
+			// The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
+			// By using else if we can reduce the number of comparisons from 16 to just over 8
+			// By first checking the first letter, we can reduce the average number further to
+			// just under 5
+			if (hasRoseMatchPattern) {
+				if (ch.getBearing().startsWith(&quot;N&quot;)) {
+					if (ch.getBearing().equals(&quot;NW&quot;))
+						cacheRosePattern = NW;
+					else if (ch.getBearing().equals(&quot;NNW&quot;))
+						cacheRosePattern = NNW;
+					else if (ch.getBearing().equals(&quot;N&quot;))
+						cacheRosePattern = N;
+					else if (ch.getBearing().equals(&quot;NNE&quot;))
+						cacheRosePattern = NNE;
+					else
+						cacheRosePattern = NE;
+				} else if (ch.getBearing().startsWith(&quot;E&quot;)) {
+					if (ch.getBearing().equals(&quot;ENE&quot;))
+						cacheRosePattern = ENE;
+					else if (ch.getBearing().equals(&quot;E&quot;))
+						cacheRosePattern = E;
+					else
+						cacheRosePattern = ESE;
+				} else if (ch.getBearing().startsWith(&quot;S&quot;)) {
+					if (ch.getBearing().equals(&quot;SW&quot;))
+						cacheRosePattern = SW;
+					else if (ch.getBearing().equals(&quot;SSW&quot;))
+						cacheRosePattern = SSW;
+					else if (ch.getBearing().equals(&quot;S&quot;))
+						cacheRosePattern = S;
+					else if (ch.getBearing().equals(&quot;SSE&quot;))
+						cacheRosePattern = SSE;
+					else
+						cacheRosePattern = SE;
+				} else {
+					if (ch.getBearing().equals(&quot;WNW&quot;))
+						cacheRosePattern = WNW;
+					else if (ch.getBearing().equals(&quot;W&quot;))
+						cacheRosePattern = W;
+					else if (ch.getBearing().equals(&quot;WSW&quot;))
+						cacheRosePattern = WSW;
+					else
+						cacheRosePattern = 0;
+				}
+				if ((cacheRosePattern != 0) &amp;&amp; ((cacheRosePattern &amp; roseMatchPattern) == 0)) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 3: Distance
+			// /////////////////////////////
+			if (fscDist &gt; 0.0) {
+				dummyd1 = ch.kilom;
+				if (distdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+				if (distdirec == GREATER &amp;&amp; dummyd1 &lt; fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 4: Difficulty
+			// /////////////////////////////
+			if (fscDiff &gt; 0.0) {
+				dummyd1 = ch.getHard() / 10D;
+				if (diffdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == EQUAL &amp;&amp; dummyd1 != fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == GREATER &amp;&amp; dummyd1 &lt; fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 5: Terrain
+			// /////////////////////////////
+			if (fscTerr &gt; 0.0) {
+				dummyd1 = ch.getTerrain() / 10D;
+				if (terrdirec == SMALLER &amp;&amp; dummyd1 &gt; fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == EQUAL &amp;&amp; dummyd1 != fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == GREATER &amp;&amp; dummyd1 &lt; fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+			}
 
-	        ///////////////////////////////
-	        // Filter criterium 6: Found by me
-	        ///////////////////////////////
-	        if ((ch.is_found() &amp;&amp; !foundByMe) || (!ch.is_found() &amp;&amp; !notFoundByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 7: Owned by me
-	        ///////////////////////////////
-	        if ((ch.is_owned() &amp;&amp; !ownedByMe) || (!ch.is_owned() &amp;&amp; !notOwnedByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 8: Archived
-	        ///////////////////////////////
-	        if ((ch.is_archived() &amp;&amp; !archived) || (!ch.is_archived() &amp;&amp; !notArchived)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 9: Unavailable
-	        ///////////////////////////////
-	        if ((ch.is_available() &amp;&amp; !available) || (!ch.is_available() &amp;&amp; !notAvailable)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 10: Size
-	        ///////////////////////////////
-	        if (hasSizeMatchPattern) {
-		        cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
-		        if ((cacheSizePattern &amp; sizeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: Attributes
-	        ///////////////////////////////
-	        if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) 
-	        		&amp;&amp; ch.mainCache == null) {
-	        	long[] chAtts=ch.getAttributesBits();
-		        if (attributesChoice == 0) {
-			        // AND-condition:
-			        if ((chAtts[0] &amp; attributesPattern[0]) != attributesPattern[0] ||
-				        	(chAtts[1] &amp; attributesPattern[1]) != attributesPattern[1] ||
-				        	(chAtts[2] &amp; attributesPattern[2]) != attributesPattern[2] ||
-				        	(chAtts[3] &amp; attributesPattern[3]) != attributesPattern[3] )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else if (attributesChoice == 1) {
-			        // OR-condition:
-			        if ((chAtts[0] &amp; attributesPattern[0]) == 0 &amp;&amp;
-				        	(chAtts[1] &amp; attributesPattern[1]) == 0 &amp;&amp;
-				        	(chAtts[2] &amp; attributesPattern[2]) == 0 &amp;&amp;
-				        	(chAtts[3] &amp; attributesPattern[3]) == 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else {
-			        // NOT-condition:
-			        if ((chAtts[0] &amp; attributesPattern[0]) != 0 ||
-				        	(chAtts[1] &amp; attributesPattern[1]) != 0 ||
-				        	(chAtts[2] &amp; attributesPattern[2]) != 0 ||
-				        	(chAtts[3] &amp; attributesPattern[3]) != 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 12: Status
-	        ///////////////////////////////
-	        if (!cacheStatus.equals(&quot;&quot;)) {
-	        	if (!useRegexp) {
-	        		if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase())&lt;0) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	} else {
-	        		Regex rex=new Regex(cacheStatus.toLowerCase());
-	        		rex.search(ch.getStatusText().toLowerCase());
-	        		if (rex.stringMatched()==null) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	}
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: NoCoord
-	        ///////////////////////////////
-	        if (!filterNoCoord &amp;&amp; !ch.pos.isValid()) {
-	          cacheFiltered = true;
-	        	break;
-        }
+			// /////////////////////////////
+			// Filter criterium 6: Found by me
+			// /////////////////////////////
+			if ((ch.is_found() &amp;&amp; !foundByMe) || (!ch.is_found() &amp;&amp; !notFoundByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 7: Owned by me
+			// /////////////////////////////
+			if ((ch.is_owned() &amp;&amp; !ownedByMe) || (!ch.is_owned() &amp;&amp; !notOwnedByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 8: Archived
+			// /////////////////////////////
+			if ((ch.is_archived() &amp;&amp; !archived) || (!ch.is_archived() &amp;&amp; !notArchived)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 9: Unavailable
+			// /////////////////////////////
+			if ((ch.is_available() &amp;&amp; !available) || (!ch.is_available() &amp;&amp; !notAvailable)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 10: Size
+			// /////////////////////////////
+			if (hasSizeMatchPattern) {
+				cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
+				if ((cacheSizePattern &amp; sizeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: Attributes
+			// /////////////////////////////
+			if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) &amp;&amp; ch.mainCache == null) {
+				long[] chAtts = ch.getAttributesBits();
+				if (attributesChoice == 0) {
+					// AND-condition:
+					if ((chAtts[0] &amp; attributesPattern[0]) != attributesPattern[0] || (chAtts[1] &amp; attributesPattern[1]) != attributesPattern[1] || (chAtts[2] &amp; attributesPattern[2]) != attributesPattern[2]
+							|| (chAtts[3] &amp; attributesPattern[3]) != attributesPattern[3]) {
+						cacheFiltered = true;
+						break;
+					}
+				} else if (attributesChoice == 1) {
+					// OR-condition:
+					if ((chAtts[0] &amp; attributesPattern[0]) == 0 &amp;&amp; (chAtts[1] &amp; attributesPattern[1]) == 0 &amp;&amp; (chAtts[2] &amp; attributesPattern[2]) == 0 &amp;&amp; (chAtts[3] &amp; attributesPattern[3]) == 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					// NOT-condition:
+					if ((chAtts[0] &amp; attributesPattern[0]) != 0 || (chAtts[1] &amp; attributesPattern[1]) != 0 || (chAtts[2] &amp; attributesPattern[2]) != 0 || (chAtts[3] &amp; attributesPattern[3]) != 0) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 12: Status
+			// /////////////////////////////
+			if (!cacheStatus.equals(&quot;&quot;)) {
+				if (!useRegexp) {
+					if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase()) &lt; 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					Regex rex = new Regex(cacheStatus.toLowerCase());
+					rex.search(ch.getStatusText().toLowerCase());
+					if (rex.stringMatched() == null) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: NoCoord
+			// /////////////////////////////
+			if (!filterNoCoord &amp;&amp; !ch.getPos().isValid()) {
+				cacheFiltered = true;
+				break;
+			}
 
-	        break;
-        } while (true);
+			break;
+		} while (true);
 		return cacheFiltered;
-    }
-	
+	}
+
 	/**
-	*	Switches flag to invert filter property.
-	*/
-	public void invertFilter(){
+	 * Switches flag to invert filter property.
+	 */
+	public void invertFilter() {
 		Global.getProfile().setFilterInverted(!Global.getProfile().isFilterInverted());
 	}
-	
+
 	/**
-	*	Clear the is_filtered flag from the cache database.
-	*/
-	public void clearFilter(){
+	 * Clear the is_filtered flag from the cache database.
+	 */
+	public void clearFilter() {
 		Global.getProfile().selectionChanged = true;
-		CacheDB cacheDB=Global.getProfile().cacheDB;
-		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			CacheHolder ch = cacheDB.get(i);
 			ch.setFiltered(false);
 		}
 		Global.getProfile().setFilterActive(FILTER_INACTIVE);
 	}
 
-		public boolean hasFilter() {
-		Profile prof=Global.getProfile();
-		long[] attribs=prof.getFilterAttr();
-		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) &amp;&amp;
-		    prof.getFilterRose().equals(FilterData.FILTERROSE) &amp;&amp;
-		    prof.getFilterVar().equals(FilterData.FILTERVAR) &amp;&amp;
-		    prof.getFilterSize().equals(FilterData.FILTERSIZE) &amp;&amp;
-		    prof.getFilterDist().equals(&quot;L&quot;) &amp;&amp;
-		    prof.getFilterDiff().equals(&quot;L&quot;) &amp;&amp;
-		    prof.getFilterTerr().equals(&quot;L&quot;) &amp;&amp;
-		    attribs[0] == 0l &amp;&amp;
-		    attribs[1] == 0l &amp;&amp;
-		    attribs[2] == 0l &amp;&amp;
-		    attribs[3] == 0l &amp;&amp;
-		    prof.getFilterStatus().equals(&quot;&quot;) &amp;&amp;
-        prof.getFilterNoCoord());
+	public boolean hasFilter() {
+		Profile prof = Global.getProfile();
+		long[] attribs = prof.getFilterAttr();
+		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) &amp;&amp; prof.getFilterRose().equals(FilterData.FILTERROSE) &amp;&amp; prof.getFilterVar().equals(FilterData.FILTERVAR) &amp;&amp; prof.getFilterSize().equals(FilterData.FILTERSIZE)
+				&amp;&amp; prof.getFilterDist().equals(&quot;L&quot;) &amp;&amp; prof.getFilterDiff().equals(&quot;L&quot;) &amp;&amp; prof.getFilterTerr().equals(&quot;L&quot;) &amp;&amp; attribs[0] == 0l &amp;&amp; attribs[1] == 0l &amp;&amp; attribs[2] == 0l &amp;&amp; attribs[3] == 0l &amp;&amp; prof.getFilterStatus().equals(&quot;&quot;) &amp;&amp; prof
+					.getFilterNoCoord());
 	}
 
 }
-
-

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/MainTab.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -386,15 +386,15 @@
 			// why not using the target ???
 			CacheHolder selectedCache = profile.cacheDB.get(selectedIndex);
 			// try to start new waypoint with real coords
-			if (!pCh.pos.isValid()) {
-				pCh.pos.set(selectedCache.pos);
+			if (!pCh.getPos().isValid()) {
+				pCh.setPos(selectedCache.getPos());
 			}
 			if (selectedCache.isAddiWpt()) {
 				if (selectedCache.mainCache != null) {
 					mainCache = selectedCache.mainCache.getWayPoint();
 					// try to start new waypoint with real coords
-					if (!pCh.pos.isValid()) {
-						pCh.pos.set(selectedCache.mainCache.pos);
+					if (!pCh.getPos().isValid()) {
+						pCh.setPos(selectedCache.mainCache.getPos());
 					}
 				} else {
 					mainCache = null;

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/MyComparer.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -73,7 +73,7 @@
 		} else if (colToCompare == 6) {
 			for (int i = 0; i &lt; visibleSize; i++) {
 				CacheHolder ch = cacheDB.get(i);
-				ch.sort = ch.getLatLon();
+				ch.sort = ch.getPos().toString();
 			}
 		} else if (colToCompare == 7) {
 			for (int i = 0; i &lt; visibleSize; i++) {

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/Parser.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,72 +1,72 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 /* 
-A parser that parses the following grammar:
-EBNF Meta-Symbols:
-  {xx}        xx can occur any number of times incl 0
-  [xx]        xx or empty
-  |           or
-  &quot;x&quot;         x is terminal symbol
+ A parser that parses the following grammar:
+ EBNF Meta-Symbols:
+ {xx}        xx can occur any number of times incl 0
+ [xx]        xx or empty
+ |           or
+ &quot;x&quot;         x is terminal symbol
 
-command -&gt; if |
-         simplecommand
+ command -&gt; if |
+ simplecommand
 
-simplecommand -&gt; &quot;stop&quot; | &quot;st&quot; |
-		   assign
-         stringexp |
+ simplecommand -&gt; &quot;stop&quot; | &quot;st&quot; |
+ assign
+ stringexp |
 
-if -&gt; &quot;IF&quot; stringexpr compop stringexpr &quot;THEN&quot; simplecommand { &quot;;&quot; simplecommand } &quot;ENDIF&quot;          // Nested IF's not allowed
+ if -&gt; &quot;IF&quot; stringexpr compop stringexpr &quot;THEN&quot; simplecommand { &quot;;&quot; simplecommand } &quot;ENDIF&quot;          // Nested IF's not allowed
 
-compop -&gt; &quot;=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;&gt;&quot; | &quot;!=&quot; | &quot;&gt;&lt;&quot;
+ compop -&gt; &quot;=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;&gt;&quot; | &quot;!=&quot; | &quot;&gt;&lt;&quot;
 
-assign -&gt; ident = [ stringexpr ]
+ assign -&gt; ident = [ stringexpr ]
 
-stringexp -&gt; (string | expr ) {string | tailexp }
+ stringexp -&gt; (string | expr ) {string | tailexp }
 
-expr -&gt; [&quot;+&quot; | &quot;-&quot;] tailexp [ formatstring ]
+ expr -&gt; [&quot;+&quot; | &quot;-&quot;] tailexp [ formatstring ]
 
-tailexp -&gt; term { (&quot;+&quot; | &quot;-&quot;) term }
+ tailexp -&gt; term { (&quot;+&quot; | &quot;-&quot;) term }
 
-term -&gt; factor { (&quot;*&quot; | &quot;/&quot;) factor }
+ term -&gt; factor { (&quot;*&quot; | &quot;/&quot;) factor }
 
-factor -&gt; expfactor { &quot;^&quot; expfactor }
+ factor -&gt; expfactor { &quot;^&quot; expfactor }
 
-expfactor -&gt; ident |
-        number |
-        &quot;(&quot; stringexpr &quot;)&quot; |
-        function &quot;(&quot; stringexpr { &quot;,&quot; stringexpr }&quot;)&quot;
+ expfactor -&gt; ident |
+ number |
+ &quot;(&quot; stringexpr &quot;)&quot; |
+ function &quot;(&quot; stringexpr { &quot;,&quot; stringexpr }&quot;)&quot;
 
-function -&gt; &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;asin&quot; | &quot;acos&quot; | &quot;atan&quot; | &quot;goto&quot; | &quot;project&quot; | &quot;show&quot;  | &quot;crosstotal&quot; |
-          &quot;rot13&quot; | &quot;len&quot; | &quot;mid&quot;
+ function -&gt; &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;asin&quot; | &quot;acos&quot; | &quot;atan&quot; | &quot;goto&quot; | &quot;project&quot; | &quot;show&quot;  | &quot;crosstotal&quot; |
+ &quot;rot13&quot; | &quot;len&quot; | &quot;mid&quot;
 
-ident -&gt; valid identifier
-number -&gt; valid number
+ ident -&gt; valid identifier
+ number -&gt; valid number
 
 
-*/
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -82,196 +82,155 @@
 import ewe.util.mString;
 
 /**
-*	The wolf language parser. New version - January 2007
-*
-*   New features:
-*   - Improved error handling
-*   - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
-*   - Variables can store strings or doubles
-*   - Global variables (starting with $) are remembered across multiple calls to parser
-*   - Global variables are initialised with &quot;&quot;, local variables result in error if used before setting value
-*   - IF statement added
-*   - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
-*   - less typing
-*   	- Function aliases
-*   	- Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
-*   	- show no longer needed
-*   	- Command terminator ; no longer compulsory (only between multiple commands on same line)
-*   - New functions can easily be added
-*   - Can select whether variable names are case sensitive
-*
-*   To add a new function:
-*     1) Add its name and alias and allowed number of args to array functions
-*     2) Add a new private method in the &quot;functions&quot; section
-*     3) Add call to private method in executeFunction
-*   @author salzkammergut Januay 2007
-*/
-public class Parser{
+ * The wolf language parser. New version - January 2007
+ * 
+ * New features:
+ * - Improved error handling
+ * - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
+ * - Variables can store strings or doubles
+ * - Global variables (starting with $) are remembered across multiple calls to parser
+ * - Global variables are initialised with &quot;&quot;, local variables result in error if used before setting value
+ * - IF statement added
+ * - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
+ * - less typing
+ * - Function aliases
+ * - Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
+ * - show no longer needed
+ * - Command terminator ; no longer compulsory (only between multiple commands on same line)
+ * - New functions can easily be added
+ * - Can select whether variable names are case sensitive
+ * 
+ * To add a new function:
+ * 1) Add its name and alias and allowed number of args to array functions
+ * 2) Add a new private method in the &quot;functions&quot; section
+ * 3) Add call to private method in executeFunction
+ * 
+ * @author salzkammergut Januay 2007
+ */
+public class Parser {
 
 	private class fnType {
-		public String funcName; 	 // the function name in the user input
-		public String alias;         // the funcName is mapped to this alias
-		public int nargs;            // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
-									 // i.e. 1&lt;&lt;nargs ORed together
+		public String funcName; // the function name in the user input
+		public String alias; // the funcName is mapped to this alias
+		public int nargs; // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+							// i.e. 1&lt;&lt;nargs ORed together
+
 		fnType(String funcName, String alias, int nargs) {
-			this.funcName=funcName; this.alias=alias; this.nargs=nargs;
+			this.funcName = funcName;
+			this.alias = alias;
+			this.nargs = nargs;
 		}
-		boolean nargsValid(int testNargs){
-			return ((1&lt;&lt;testNargs)&amp;this.nargs)!=0;
+
+		boolean nargsValid(int testNargs) {
+			return ((1 &lt;&lt; testNargs) &amp; this.nargs) != 0;
 		}
 	}
-    fnType[] functions=new fnType[]{ // in alphabetical order
-    	new fnType(&quot;abs&quot;,&quot;abs&quot;,2),
-    	new fnType(&quot;acos&quot;,&quot;acos&quot;,2),
-    	new fnType(&quot;asin&quot;,&quot;asin&quot;,2),
-    	new fnType(&quot;atan&quot;,&quot;atan&quot;,2),
-      	new fnType(&quot;bearing&quot;,&quot;bearing&quot;,4),
-    	new fnType(&quot;cb&quot;,&quot;cb&quot;,16),
-     	new fnType(&quot;centre&quot;,&quot;center&quot;,3),
-    	new fnType(&quot;center&quot;,&quot;center&quot;,3),
-    	new fnType(&quot;cls&quot;,&quot;cls&quot;,1),
-    	new fnType(&quot;clearscreen&quot;,&quot;cls&quot;,1),
-    	new fnType(&quot;cos&quot;,&quot;cos&quot;,2),
-    	new fnType(&quot;count&quot;,&quot;count&quot;,4),
-     	new fnType(&quot;cp&quot;,&quot;cp&quot;,1),
-    	new fnType(&quot;crossbearing&quot;,&quot;cb&quot;,16),
-    	new fnType(&quot;crosstotal&quot;,&quot;ct&quot;,6),
-    	new fnType(&quot;ct&quot;,&quot;ct&quot;,2),
-     	new fnType(&quot;curpos&quot;,&quot;cp&quot;,1),
-     	new fnType(&quot;d2r&quot;,&quot;deg2rad&quot;,2),
-     	new fnType(&quot;deg&quot;,&quot;deg&quot;,1),
-     	new fnType(&quot;deg2rad&quot;,&quot;deg2rad&quot;,2),
-     	new fnType(&quot;distance&quot;,&quot;distance&quot;,4),
-     	new fnType(&quot;encode&quot;,&quot;encode&quot;,8),
-    	new fnType(&quot;format&quot;,&quot;format&quot;,12),
-    	new fnType(&quot;goto&quot;,&quot;goto&quot;,6),
-    	new fnType(&quot;ic&quot;,&quot;ic&quot;,3),
-    	new fnType(&quot;ignorecase&quot;,&quot;ic&quot;,3),
-    	new fnType(&quot;instr&quot;,&quot;instr&quot;,12),
-    	new fnType(&quot;int&quot;,&quot;int&quot;,2),
-    	new fnType(&quot;lcase&quot;,&quot;lc&quot;,2),
-    	new fnType(&quot;length&quot;,&quot;len&quot;,2),
-    	new fnType(&quot;mid&quot;,&quot;mid&quot;,12),
-    	new fnType(&quot;mod&quot;,&quot;mod&quot;,4),
-     	new fnType(&quot;pc&quot;,&quot;pz&quot;,3),
-     	new fnType(&quot;profilecenter&quot;,&quot;pz&quot;,3),
-     	new fnType(&quot;profilecentre&quot;,&quot;pz&quot;,3),
-     	new fnType(&quot;profilzentrum&quot;,&quot;pz&quot;,3),
-    	new fnType(&quot;project&quot;,&quot;project&quot;,8),
-     	new fnType(&quot;pz&quot;,&quot;pz&quot;,3),
-    	new fnType(&quot;quersumme&quot;,&quot;ct&quot;,6),
-    	new fnType(&quot;r2d&quot;,&quot;rad2deg&quot;,2),
-    	new fnType(&quot;rad&quot;,&quot;rad&quot;,1),
-    	new fnType(&quot;rad2deg&quot;,&quot;rad2deg&quot;,2),
-    	new fnType(&quot;replace&quot;,&quot;replace&quot;,8),
-    	new fnType(&quot;reverse&quot;,&quot;reverse&quot;,2),
-    	new fnType(&quot;rot13&quot;,&quot;rot13&quot;,2),
-    	new fnType(&quot;show&quot;,&quot;show&quot;,2),
-    	new fnType(&quot;sin&quot;,&quot;sin&quot;,2),
-    	new fnType(&quot;skeleton&quot;,&quot;skeleton&quot;,3),
-    	new fnType(&quot;sqrt&quot;,&quot;sqrt&quot;,2),
-    	new fnType(&quot;sval&quot;,&quot;sval&quot;,2),
-    	new fnType(&quot;tolowercase&quot;,&quot;lc&quot;,2),
-    	new fnType(&quot;touppercase&quot;,&quot;uc&quot;,2),
-    	new fnType(&quot;tan&quot;,&quot;tan&quot;,2),
-    	new fnType(&quot;ucase&quot;,&quot;uc&quot;,2),
-    	new fnType(&quot;val&quot;,&quot;val&quot;,2),
-     	new fnType(&quot;zentrum&quot;,&quot;center&quot;,3)
-     	    	};
+
+	fnType[] functions = new fnType[] { // in alphabetical order
+	new fnType(&quot;abs&quot;, &quot;abs&quot;, 2), new fnType(&quot;acos&quot;, &quot;acos&quot;, 2), new fnType(&quot;asin&quot;, &quot;asin&quot;, 2), new fnType(&quot;atan&quot;, &quot;atan&quot;, 2), new fnType(&quot;bearing&quot;, &quot;bearing&quot;, 4), new fnType(&quot;cb&quot;, &quot;cb&quot;, 16), new fnType(&quot;centre&quot;, &quot;center&quot;, 3),
+			new fnType(&quot;center&quot;, &quot;center&quot;, 3), new fnType(&quot;cls&quot;, &quot;cls&quot;, 1), new fnType(&quot;clearscreen&quot;, &quot;cls&quot;, 1), new fnType(&quot;cos&quot;, &quot;cos&quot;, 2), new fnType(&quot;count&quot;, &quot;count&quot;, 4), new fnType(&quot;cp&quot;, &quot;cp&quot;, 1), new fnType(&quot;crossbearing&quot;, &quot;cb&quot;, 16),
+			new fnType(&quot;crosstotal&quot;, &quot;ct&quot;, 6), new fnType(&quot;ct&quot;, &quot;ct&quot;, 2), new fnType(&quot;curpos&quot;, &quot;cp&quot;, 1), new fnType(&quot;d2r&quot;, &quot;deg2rad&quot;, 2), new fnType(&quot;deg&quot;, &quot;deg&quot;, 1), new fnType(&quot;deg2rad&quot;, &quot;deg2rad&quot;, 2), new fnType(&quot;distance&quot;, &quot;distance&quot;, 4),
+			new fnType(&quot;encode&quot;, &quot;encode&quot;, 8), new fnType(&quot;format&quot;, &quot;format&quot;, 12), new fnType(&quot;goto&quot;, &quot;goto&quot;, 6), new fnType(&quot;ic&quot;, &quot;ic&quot;, 3), new fnType(&quot;ignorecase&quot;, &quot;ic&quot;, 3), new fnType(&quot;instr&quot;, &quot;instr&quot;, 12), new fnType(&quot;int&quot;, &quot;int&quot;, 2),
+			new fnType(&quot;lcase&quot;, &quot;lc&quot;, 2), new fnType(&quot;length&quot;, &quot;len&quot;, 2), new fnType(&quot;mid&quot;, &quot;mid&quot;, 12), new fnType(&quot;mod&quot;, &quot;mod&quot;, 4), new fnType(&quot;pc&quot;, &quot;pz&quot;, 3), new fnType(&quot;profilecenter&quot;, &quot;pz&quot;, 3), new fnType(&quot;profilecentre&quot;, &quot;pz&quot;, 3),
+			new fnType(&quot;profilzentrum&quot;, &quot;pz&quot;, 3), new fnType(&quot;project&quot;, &quot;project&quot;, 8), new fnType(&quot;pz&quot;, &quot;pz&quot;, 3), new fnType(&quot;quersumme&quot;, &quot;ct&quot;, 6), new fnType(&quot;r2d&quot;, &quot;rad2deg&quot;, 2), new fnType(&quot;rad&quot;, &quot;rad&quot;, 1), new fnType(&quot;rad2deg&quot;, &quot;rad2deg&quot;, 2),
+			new fnType(&quot;replace&quot;, &quot;replace&quot;, 8), new fnType(&quot;reverse&quot;, &quot;reverse&quot;, 2), new fnType(&quot;rot13&quot;, &quot;rot13&quot;, 2), new fnType(&quot;show&quot;, &quot;show&quot;, 2), new fnType(&quot;sin&quot;, &quot;sin&quot;, 2), new fnType(&quot;skeleton&quot;, &quot;skeleton&quot;, 3), new fnType(&quot;sqrt&quot;, &quot;sqrt&quot;, 2),
+			new fnType(&quot;sval&quot;, &quot;sval&quot;, 2), new fnType(&quot;tolowercase&quot;, &quot;lc&quot;, 2), new fnType(&quot;touppercase&quot;, &quot;uc&quot;, 2), new fnType(&quot;tan&quot;, &quot;tan&quot;, 2), new fnType(&quot;ucase&quot;, &quot;uc&quot;, 2), new fnType(&quot;val&quot;, &quot;val&quot;, 2), new fnType(&quot;zentrum&quot;, &quot;center&quot;, 3) };
 	private static int scanpos = 0;
-	CWPoint cwPt=new CWPoint();
-	Vector calcStack=new Vector();
+	CWPoint cwPt = new CWPoint();
+	Vector calcStack = new Vector();
 	Hashtable symbolTable = new Hashtable(50);
 	TokenObj thisToken = new TokenObj();
 	Vector tokenStack;
 	Vector messageStack;
 
-	public Parser(){ // Global constructor
+	public Parser() { // Global constructor
 	}
 
-///////////////////////////////////////////
-//  Utility functions
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// Utility functions
+	// /////////////////////////////////////////
 
-	/* All errors are handled via function 'err'. Rather than creating many different Exceptions,
+	/*
+	 * All errors are handled via function 'err'. Rather than creating many different Exceptions,
 	 * only the standard Exception is used. err raises this exception and thereby causes the stack to be
 	 * unwound until 'parse' eventually catches the exception and returns to SolverPanel, which displays
 	 * the messageStack containing the error message.
 	 */
 
 	/**
-     * Add an error message to the message stack and raise an Exception.
-    */
+	 * Add an error message to the message stack and raise an Exception.
+	 */
 	private void err(String str) throws Exception {
-    	messageStack.add(MyLocale.getMsg(1700,&quot;Error on line: &quot;) + thisToken.line + &quot;  &quot;+MyLocale.getMsg(1701,&quot;position: &quot;) + thisToken.position);
-    	messageStack.add(str);
-    	// move cursor to error location
-    	if (Global.mainTab.solverP.mText.setSelectionRange(0,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1))Global.mainTab.solverP.mText.repaintNow();
-    	throw new Exception(&quot;Error &quot;+str);
-    }
+		messageStack.add(MyLocale.getMsg(1700, &quot;Error on line: &quot;) + thisToken.line + &quot;  &quot; + MyLocale.getMsg(1701, &quot;position: &quot;) + thisToken.position);
+		messageStack.add(str);
+		// move cursor to error location
+		if (Global.mainTab.solverP.mText.setSelectionRange(0, thisToken.line - 1, thisToken.position + thisToken.token.length() - 1, thisToken.line - 1))
+			Global.mainTab.solverP.mText.repaintNow();
+		throw new Exception(&quot;Error &quot; + str);
+	}
 
-    /** Shows global symbols */
-    private void showVars(boolean globals) throws Exception {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
-    		if (globals == varName.startsWith(&quot;$&quot;)) {
-    			String value=(String) getVariable(varName);
-    			if (java.lang.Double.isNaN(toNumber(value)))
-    				messageStack.add(varName+&quot; = \&quot;&quot;+STRreplace.replace(value.toString(),&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
-    			else
-    				messageStack.add(varName+&quot; = &quot;+value);
-    		}
-    	}
-    }
+	/** Shows global symbols */
+	private void showVars(boolean globals) throws Exception {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			String varName = ((String) ((ewe.util.Map.MapEntry) it.next()).getKey());
+			if (globals == varName.startsWith(&quot;$&quot;)) {
+				String value = (String) getVariable(varName);
+				if (java.lang.Double.isNaN(toNumber(value)))
+					messageStack.add(varName + &quot; = \&quot;&quot; + STRreplace.replace(value.toString(), &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;);
+				else
+					messageStack.add(varName + &quot; = &quot; + value);
+			}
+		}
+	}
 
 	/** Clears the symbol table of all non-global symbols (those not starting with $) */
-    private void clearLocalSymbols() {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		ewe.util.Map.MapEntry sym=(ewe.util.Map.MapEntry) it.next();
-    		if (!((String)sym.getKey()).startsWith(&quot;$&quot;))
-    			symbolTable.remove(sym.getKey());
-    	}
-    	Double pi=new Double(java.lang.Math.PI);
-    	symbolTable.put(&quot;PI&quot;,pi);
-    	symbolTable.put(&quot;pi&quot;,pi); // To make it easier for the user we also add a lowercase version of pi
-    }
+	private void clearLocalSymbols() {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			ewe.util.Map.MapEntry sym = (ewe.util.Map.MapEntry) it.next();
+			if (!((String) sym.getKey()).startsWith(&quot;$&quot;))
+				symbolTable.remove(sym.getKey());
+		}
+		Double pi = new Double(java.lang.Math.PI);
+		symbolTable.put(&quot;PI&quot;, pi);
+		symbolTable.put(&quot;pi&quot;, pi); // To make it easier for the user we also add a lowercase version of pi
+	}
 
 	private boolean isVariable(String varName) {
-		return varName.startsWith(&quot;$&quot;) ||  // Global variables exist per default
-		       symbolTable.containsKey(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+		return varName.startsWith(&quot;$&quot;) || // Global variables exist per default
+				symbolTable.containsKey(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
 	}
 
 	private boolean isInteger(double d) {
-		return java.lang.Math.ceil(d)==d &amp;&amp; java.lang.Math.floor(d)==d;
+		return java.lang.Math.ceil(d) == d &amp;&amp; java.lang.Math.floor(d) == d;
 	}
 
-    private boolean isValidCoord(String coord) {
-    	cwPt.set(coord);
-    	return cwPt.isValid();
-    }
+	private boolean isValidCoord(String coord) {
+		cwPt.set(coord);
+		return cwPt.isValid();
+	}
 
 	private Object getVariable(String varName) throws Exception {
 		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Found it!
 				// Check whether coordinates are valid
-				cwPt.set(ch.pos);
-				if (cwPt.isValid() )
+				cwPt.set(ch.getPos());
+				if (cwPt.isValid())
 					return cwPt.toString();
 				else
 					return &quot;&quot;; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
 			}
 		}
-		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-		if(result == null) {
+		Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+		if (result == null) {
 			// If it is a global variable, add it with a default value
 			if (varName.startsWith(&quot;$&quot;)) {
-				result=&quot;&quot;;
-				symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName,&quot;&quot;);
+				result = &quot;&quot;;
+				symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, &quot;&quot;);
 			} else
-				err (MyLocale.getMsg(1702,&quot;Variable not defined: &quot;)+varName);
+				err(MyLocale.getMsg(1702, &quot;Variable not defined: &quot;) + varName);
 		}
 		return result;
 	}
@@ -281,66 +240,68 @@
 			if (MyLocale.getDigSeparator().equals(&quot;,&quot;))
 				str = str.replace('.', ',');
 			else
-				str = str.replace(',','.');
+				str = str.replace(',', '.');
 			return java.lang.Double.parseDouble(str);
 		} catch (NumberFormatException e) {
-			 return java.lang.Double.NaN;
+			return java.lang.Double.NaN;
 		}
 	}
 
 	private Double getNumber(String str) throws Exception {
-		double ret=toNumber(str);
+		double ret = toNumber(str);
 		if (java.lang.Double.isNaN(ret))
-			err(MyLocale.getMsg(1703,&quot;Not a valid number: &quot;) + str);
+			err(MyLocale.getMsg(1703, &quot;Not a valid number: &quot;) + str);
 		return new java.lang.Double(ret);
 	}
 
 	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
 	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
 		double num;
-		if (calcStack.get(calcStack.size()-1) instanceof String) {
-			if (((String)calcStack.get(calcStack.size()-1)).equals(&quot;&quot;))
-				num=defaultForEmptyString;
+		if (calcStack.get(calcStack.size() - 1) instanceof String) {
+			if (((String) calcStack.get(calcStack.size() - 1)).equals(&quot;&quot;))
+				num = defaultForEmptyString;
 			else
-				num = getNumber((String)calcStack.get(calcStack.size()-1)).doubleValue();
+				num = getNumber((String) calcStack.get(calcStack.size() - 1)).doubleValue();
 		} else {
-			num = ((java.lang.Double)calcStack.get(calcStack.size()-1)).doubleValue();
+			num = ((java.lang.Double) calcStack.get(calcStack.size() - 1)).doubleValue();
 		}
-		calcStack.removeElementAt(calcStack.size()-1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return num;
 	}
 
 	private String popCalcStackAsString() {
 		String s;
-		if (calcStack.get(calcStack.size()-1) instanceof Double) {
-			java.lang.Double D=((java.lang.Double)calcStack.get(calcStack.size()-1));
+		if (calcStack.get(calcStack.size() - 1) instanceof Double) {
+			java.lang.Double D = ((java.lang.Double) calcStack.get(calcStack.size() - 1));
 			// Double.toString() formats numbers &gt; 1E7 and &lt; 1E-3 with exponential notation
 			// For large integers we therefore use Longs
-			double d=D.doubleValue();
+			double d = D.doubleValue();
 			// If the double is an integer and within range of longs, use Long
-			if (java.lang.Math.floor(d)==d &amp;&amp; d&lt;java.lang.Long.MAX_VALUE &amp;&amp; d&gt;java.lang.Long.MIN_VALUE) {
-				java.lang.Long L=new java.lang.Long((long)d);
-				s=L.toString();
+			if (java.lang.Math.floor(d) == d &amp;&amp; d &lt; java.lang.Long.MAX_VALUE &amp;&amp; d &gt; java.lang.Long.MIN_VALUE) {
+				java.lang.Long L = new java.lang.Long((long) d);
+				s = L.toString();
 			} else { // Use the default Double format
-				s = D.toString().replace(',','.'); // always show numbers with decimal point;
-				if (s.endsWith(&quot;.0&quot;)) s=s.substring(0,s.length()-2);
+				s = D.toString().replace(',', '.'); // always show numbers with decimal point;
+				if (s.endsWith(&quot;.0&quot;))
+					s = s.substring(0, s.length() - 2);
 			}
 		} else
-			s = (String)calcStack.get(calcStack.size()-1);
-		calcStack.removeElementAt(calcStack.size()-1);
+			s = (String) calcStack.get(calcStack.size() - 1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return s;
 	}
 
 	private void getToken() throws Exception {
-		if(scanpos &lt; tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		if (scanpos &lt; tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-		} else err(MyLocale.getMsg(1704,&quot;Unexpected end of source&quot;));
+		} else
+			err(MyLocale.getMsg(1704, &quot;Unexpected end of source&quot;));
 	}
 
 	private TokenObj peekToken() {
-		if(scanpos &lt; tokenStack.size()){
-			return (TokenObj)tokenStack.get(scanpos);
+		if (scanpos &lt; tokenStack.size()) {
+			return (TokenObj) tokenStack.get(scanpos);
 		} else
 			return new TokenObj();
 	}
@@ -352,54 +313,58 @@
 	}
 
 	private void skipPastEndif(TokenObj ifToken) throws Exception {
-		while(scanpos &lt; tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		while (scanpos &lt; tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-			if (thisToken.tt==TokenObj.TT_ENDIF) {
+			if (thisToken.tt == TokenObj.TT_ENDIF) {
 				getToken();
 				return;
 			}
 		}
-		thisToken=ifToken;
-		err(MyLocale.getMsg(1705,&quot;Missing ENDIF&quot;));
+		thisToken = ifToken;
+		err(MyLocale.getMsg(1705, &quot;Missing ENDIF&quot;));
 	}
+
 	private TokenObj lookAheadToken() {
-		return (TokenObj)tokenStack.get(scanpos);
+		return (TokenObj) tokenStack.get(scanpos);
 	}
 
 	private boolean checkNextSymIs(String str) throws Exception {
-		if(thisToken.token.toUpperCase().equals(str)){
+		if (thisToken.token.toUpperCase().equals(str)) {
 			return true;
 		} else {
-			err(MyLocale.getMsg(1706,&quot;Expected &quot;) + str + &quot;  &quot;+MyLocale.getMsg(1707,&quot;Found: &quot;)+thisToken.token);
-			return false; //Dummy as err does not return
+			err(MyLocale.getMsg(1706, &quot;Expected &quot;) + str + &quot;  &quot; + MyLocale.getMsg(1707, &quot;Found: &quot;) + thisToken.token);
+			return false; // Dummy as err does not return
 		}
 	}
 
 	private fnType getFunctionDefinition(String str) throws Exception {
-    	fnType fnd=null;
-    	str=str.toLowerCase();
-    	for (int i=functions.length-1; i&gt;=0; i--) {
-    		// Return the function if there is an exact match
-    		if (functions[i].funcName.equals(str)) return functions[i];
-    		if (functions[i].funcName.startsWith(str)) { // Partial match?
-        		// Only one partial match allowed
-    			if (fnd!=null) err(MyLocale.getMsg(1708,&quot;Ambiguous function name: &quot;)+str);
-    			fnd=functions[i];
-    		}
-    	}
-    	if (fnd==null) err(MyLocale.getMsg(1709,&quot;Unknown function: &quot;)+str);
-    	return fnd;
-    }
+		fnType fnd = null;
+		str = str.toLowerCase();
+		for (int i = functions.length - 1; i &gt;= 0; i--) {
+			// Return the function if there is an exact match
+			if (functions[i].funcName.equals(str))
+				return functions[i];
+			if (functions[i].funcName.startsWith(str)) { // Partial match?
+				// Only one partial match allowed
+				if (fnd != null)
+					err(MyLocale.getMsg(1708, &quot;Ambiguous function name: &quot;) + str);
+				fnd = functions[i];
+			}
+		}
+		if (fnd == null)
+			err(MyLocale.getMsg(1709, &quot;Unknown function: &quot;) + str);
+		return fnd;
+	}
 
-///////////////////////////////////////////
-//  FUNCTIONS
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// FUNCTIONS
+	// /////////////////////////////////////////
 
 	/** If we are in DEGree mode, convert the argument to RADiants, if not leave it unchanged */
 	private double makeRadiant(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg*java.lang.Math.PI/180.0;
+			return arg * java.lang.Math.PI / 180.0;
 		else
 			return arg;
 	}
@@ -407,30 +372,33 @@
 	/** If we are in DEGree mode, convert the argument to degrees */
 	private double makeDegree(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg/java.lang.Math.PI*180.0;
+			return arg / java.lang.Math.PI * 180.0;
 		else
 			return arg;
 	}
 
-    /** Calculate brearing from one point to the next */
-    private double funcBearing() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
- 		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
-	   	cwPt.set(coordA);
-	   	double angleDeg=cwPt.getBearing(new CWPoint(coordB));
-	   	// getBearing returns a result in degrees
-	   	return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI/180.0;
-    }
+	/** Calculate brearing from one point to the next */
+	private double funcBearing() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordB);
+		cwPt.set(coordA);
+		double angleDeg = cwPt.getBearing(new CWPoint(coordB));
+		// getBearing returns a result in degrees
+		return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI / 180.0;
+	}
 
-    /** Get or set the current centre */
+	/** Get or set the current centre */
 	private void funcCenter(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getPref().getCurCentrePt().toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
 			Global.getPref().setCurCentrePt(new CWPoint(coordA));
 		}
 	}
@@ -442,218 +410,246 @@
 	}
 
 	private int funcCountChar(String s, char c) {
-    	int count=0;
-    	for (int i=0; i&lt;s.length(); i++)
-    		if (s.charAt(i)==c) count++;
-    	return count;
-    }
+		int count = 0;
+		for (int i = 0; i &lt; s.length(); i++)
+			if (s.charAt(i) == c)
+				count++;
+		return count;
+	}
 
-    /** count(string1,string2)
-     * */
-    private void funcCount()throws Exception {
-       	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	if (s2.length()==0) err(MyLocale.getMsg(1710,&quot;Cannot count empty string&quot;));
-    	if (s2.length()==1) {
-    		calcStack.add(new Double(funcCountChar(s1,s2.charAt(0))));
-    	} else {
-    		String res=&quot;&quot;;
-    		for(int i=0; i&lt;s2.length(); i++) {
-    			res+=s2.charAt(i)+&quot;=&quot;+funcCountChar(s1,s2.charAt(i))+&quot; &quot;;
-    		}
-    		calcStack.add(res);
-    	}
-    }
+	/**
+	 * count(string1,string2)
+	 * */
+	private void funcCount() throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		if (s2.length() == 0)
+			err(MyLocale.getMsg(1710, &quot;Cannot count empty string&quot;));
+		if (s2.length() == 1) {
+			calcStack.add(new Double(funcCountChar(s1, s2.charAt(0))));
+		} else {
+			String res = &quot;&quot;;
+			for (int i = 0; i &lt; s2.length(); i++) {
+				res += s2.charAt(i) + &quot;=&quot; + funcCountChar(s1, s2.charAt(i)) + &quot; &quot;;
+			}
+			calcStack.add(res);
+		}
+	}
 
-    private String funcCp(){
-    	return Global.mainTab.nav.gpsPos.toString();
-    }
+	private String funcCp() {
+		return Global.mainTab.nav.gpsPos.toString();
+	}
 
-    /**
-     *  Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
-     *  Warning: When the number is non-integer or &gt; 9223372036854775807, it is formatted using the E
-     *  notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
-     */
-    private double funcCrossTotal(int nargs) throws Exception {
-    	int cycles=1;
-		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
-		String aString=popCalcStackAsString().replace('-','0').trim();
-		double a=0;
-		if (cycles&lt;0) cycles=1;
-    	if (cycles&gt;5) cycles=5;
-    	while (cycles--&gt;0) {
-	    	// Cross total = Quersumme berechnen
-			a=0;
-			for (int i=0; i&lt;aString.length(); i++) {
-			   if (aString.charAt(i)&gt;='0' &amp;&amp; aString.charAt(i)&lt;='9')
-			      a += aString.charAt(i)-'0';
+	/**
+	 * Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
+	 * Warning: When the number is non-integer or &gt; 9223372036854775807, it is formatted using the E
+	 * notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
+	 */
+	private double funcCrossTotal(int nargs) throws Exception {
+		int cycles = 1;
+		if (nargs == 2)
+			cycles = (int) popCalcStackAsNumber(1);
+		String aString = popCalcStackAsString().replace('-', '0').trim();
+		double a = 0;
+		if (cycles &lt; 0)
+			cycles = 1;
+		if (cycles &gt; 5)
+			cycles = 5;
+		while (cycles-- &gt; 0) {
+			// Cross total = Quersumme berechnen
+			a = 0;
+			for (int i = 0; i &lt; aString.length(); i++) {
+				if (aString.charAt(i) &gt;= '0' &amp;&amp; aString.charAt(i) &lt;= '9')
+					a += aString.charAt(i) - '0';
 			}
-			aString=Convert.toString(a);
-    	}
-    	return a;
-    }
+			aString = Convert.toString(a);
+		}
+		return a;
+	}
 
-    private void funcDeg(boolean arg) {
-    	Global.getPref().solverDegMode=arg;
-    	Global.mainTab.solverP.showSolverMode();
-    }
+	private void funcDeg(boolean arg) {
+		Global.getPref().solverDegMode = arg;
+		Global.mainTab.solverP.showSolverMode();
+	}
 
-    /** Convert degrees into Radiants */
-    private double funcDeg2Rad() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a/180.0*java.lang.Math.PI;
-    }
+	/** Convert degrees into Radiants */
+	private double funcDeg2Rad() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a / 180.0 * java.lang.Math.PI;
+	}
 
-    	/** Calculate distance between 2 points */
-    private double funcDistance() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
-    	double result = 0;
+	/** Calculate distance between 2 points */
+	private double funcDistance() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		double result = 0;
 		// Attention: isValidCoord has sideeffect of setting cwPt
-    	if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
-    	cwPt.set(coordA);
-    	double distKM = cwPt.getDistance(new CWPoint(coordB));
-    	result = distKM*1000.0;
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
-    	}
-    	return result;
-    }
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordB);
+		cwPt.set(coordA);
+		double distKM = cwPt.getDistance(new CWPoint(coordB));
+		result = distKM * 1000.0;
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
+		}
+		return result;
+	}
 
-    /**
-     * Encode a string by replacing all characters in a string with their corresponding characters in
-     * another string
-     * @throws Exception
-     */
-    private String funcEncode() throws Exception {
-    	String newChars=popCalcStackAsString();
-    	String oldChars=popCalcStackAsString();
-    	if (newChars.length()!=oldChars.length()) err(MyLocale.getMsg(1711,&quot;Replacement characters strings must be of equal length&quot;));
-    	String s=popCalcStackAsString();
-    	String encodedStr=&quot;&quot;;
-    	for (int i=0; i&lt;s.length(); i++) {
-    		int pos;
-    		if ((pos=oldChars.indexOf(s.charAt(i)))!=-1) {
-    			encodedStr+=newChars.charAt(pos);
-    		} else
-    			encodedStr+=s.charAt(i);
-    	}
-    	 return encodedStr;
-    }
+	/**
+	 * Encode a string by replacing all characters in a string with their corresponding characters in
+	 * another string
+	 * 
+	 * @throws Exception
+	 */
+	private String funcEncode() throws Exception {
+		String newChars = popCalcStackAsString();
+		String oldChars = popCalcStackAsString();
+		if (newChars.length() != oldChars.length())
+			err(MyLocale.getMsg(1711, &quot;Replacement characters strings must be of equal length&quot;));
+		String s = popCalcStackAsString();
+		String encodedStr = &quot;&quot;;
+		for (int i = 0; i &lt; s.length(); i++) {
+			int pos;
+			if ((pos = oldChars.indexOf(s.charAt(i))) != -1) {
+				encodedStr += newChars.charAt(pos);
+			} else
+				encodedStr += s.charAt(i);
+		}
+		return encodedStr;
+	}
 
-    /** Format a valid coordinate
-     *  If called with one args, format the argument on the stack to CW standard
-     *  The optional second argument is one of these strings &quot;UTM&quot;,&quot;DMS&quot;,&quot;DD&quot;,&quot;DMM&quot; or &quot;CW&quot;
-     * @param nargs 1 or 2 args
-     */
-    private String funcFormat(int nargs) throws Exception {
-    	int spart=0;
-    	if (nargs==3) spart=(int) popCalcStackAsNumber(0);
-    	String fmtStr=&quot;&quot;;
-    	if (nargs&gt;=2)fmtStr=popCalcStackAsString().toLowerCase();
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
-    	cwPt.set(coord);
-    	int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
-    	if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED) err(MyLocale.getMsg(1713,&quot;Invalid coordinate format. Allowed are cw / dd / dmm / dms / &quot;) + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), &quot; / &quot;));
-    	String ret = cwPt.toString(fmt);
-    	if (nargs==3){
-    		String[] parts=mString.split(ret, ' ');
-    		if (spart&gt;0 &amp;&amp; parts.length&gt;=spart)
-    		ret = parts[spart-1];
-    		else err(&quot;Param 3 !!! &quot;+MyLocale.getMsg(1713,&quot;Invalid coordinate format.&quot;));
-    	}
-    	return ret;
-    }
+	/**
+	 * Format a valid coordinate
+	 * If called with one args, format the argument on the stack to CW standard
+	 * The optional second argument is one of these strings &quot;UTM&quot;,&quot;DMS&quot;,&quot;DD&quot;,&quot;DMM&quot; or &quot;CW&quot;
+	 * 
+	 * @param nargs
+	 *            1 or 2 args
+	 */
+	private String funcFormat(int nargs) throws Exception {
+		int spart = 0;
+		if (nargs == 3)
+			spart = (int) popCalcStackAsNumber(0);
+		String fmtStr = &quot;&quot;;
+		if (nargs &gt;= 2)
+			fmtStr = popCalcStackAsString().toLowerCase();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
+		cwPt.set(coord);
+		int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
+		if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED)
+			err(MyLocale.getMsg(1713, &quot;Invalid coordinate format. Allowed are cw / dd / dmm / dms / &quot;) + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), &quot; / &quot;));
+		String ret = cwPt.toString(fmt);
+		if (nargs == 3) {
+			String[] parts = mString.split(ret, ' ');
+			if (spart &gt; 0 &amp;&amp; parts.length &gt;= spart)
+				ret = parts[spart - 1];
+			else
+				err(&quot;Param 3 !!! &quot; + MyLocale.getMsg(1713, &quot;Invalid coordinate format.&quot;));
+		}
+		return ret;
+	}
 
-    /** Implements a goto command goto(coordinate,optionalWaypointName).
-     */
-    private void funcGoto(int nargs) throws Exception {
-    	Navigate nav=Global.mainTab.nav;
-		String waypointName=null;
-        if (nargs==2) waypointName=popCalcStackAsString();
-		String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+	/**
+	 * Implements a goto command goto(coordinate,optionalWaypointName).
+	 */
+	private void funcGoto(int nargs) throws Exception {
+		Navigate nav = Global.mainTab.nav;
+		String waypointName = null;
+		if (nargs == 2)
+			waypointName = popCalcStackAsString();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
 		// Don't want to switch to goto panel, just set the values
 		nav.setDestination(coord);
-		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
-    		cwPt.set(coord);
-    		CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-    		if (ch == null) {
-    			err(MyLocale.getMsg(1714,&quot;Goto: Waypoint does not exist: &quot;)+waypointName);
-    			return;
-    		}
-    		ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-    		ch.pos.set(cwPt);
-    		ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
-    		nav.setDestination(ch);
-    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-    	}
-    }
+		if (nargs == 2) { // Now set the value of the addi waypoint (it must exist already)
+			cwPt.set(coord);
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, &quot;Goto: Waypoint does not exist: &quot;) + waypointName);
+				return;
+			}
+			ch.setPos(cwPt);
+			ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
+			nav.setDestination(ch);
+			Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+		}
+	}
 
-    /** Display or change the case sensitivity of variable names */
-    private void funcIgnoreVariableCase(int nargs) throws Exception {
-    	if (nargs==0)
-    		calcStack.add(&quot;&quot;+Global.getPref().solverIgnoreCase);
-    	else {
-    		Global.getPref().solverIgnoreCase=(popCalcStackAsNumber(0)!=0)?true:false;
-    	}
-    }
+	/** Display or change the case sensitivity of variable names */
+	private void funcIgnoreVariableCase(int nargs) throws Exception {
+		if (nargs == 0)
+			calcStack.add(&quot;&quot; + Global.getPref().solverIgnoreCase);
+		else {
+			Global.getPref().solverIgnoreCase = (popCalcStackAsNumber(0) != 0) ? true : false;
+		}
+	}
 
-    /** VB instr function
-     * instr([start],string1,string2)
-     * */
-    private int funcInstr(int nargs) throws Exception {
-    	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	int start=1;
-    	if (nargs==3) start=(int) popCalcStackAsNumber(1);
-    	if (start&gt;s1.length()) err(MyLocale.getMsg(1715,&quot;instr: Start position not in string&quot;));
-    	if(s2.equals(&quot;&quot;)) {
-    		if (s1.equals(&quot;&quot;))
-    			return 0;
-    		else
-    			return 1;
-    	}
-    	return s1.indexOf(s2,start-1)+1;
-    }
+	/**
+	 * VB instr function
+	 * instr([start],string1,string2)
+	 * */
+	private int funcInstr(int nargs) throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		int start = 1;
+		if (nargs == 3)
+			start = (int) popCalcStackAsNumber(1);
+		if (start &gt; s1.length())
+			err(MyLocale.getMsg(1715, &quot;instr: Start position not in string&quot;));
+		if (s2.equals(&quot;&quot;)) {
+			if (s1.equals(&quot;&quot;))
+				return 0;
+			else
+				return 1;
+		}
+		return s1.indexOf(s2, start - 1) + 1;
+	}
 
-    /** MID function as in Basic */
-    private String funcMid(int nargs) throws Exception {
-    	if (nargs==2) {
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
-    		if (start&lt;1 || start&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
-    		return s.substring((int)start-1);
-    	} else {
-        	double len=popCalcStackAsNumber(0);
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
-    		int end=(int)(start+len-1);
-    		if (start&gt;s.length() || start&lt;1 || end&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
-    		return s.substring((int)start-1,end);
-    	}
-    }
+	/** MID function as in Basic */
+	private String funcMid(int nargs) throws Exception {
+		if (nargs == 2) {
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start))
+				err(MyLocale.getMsg(1716, &quot;mid: Integer argument expected&quot;));
+			if (start &lt; 1 || start &gt; s.length())
+				err(MyLocale.getMsg(1717, &quot;mid: Argument out of range&quot;));
+			return s.substring((int) start - 1);
+		} else {
+			double len = popCalcStackAsNumber(0);
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start) || !isInteger(len))
+				err(MyLocale.getMsg(1716, &quot;mid: Integer argument expected&quot;));
+			int end = (int) (start + len - 1);
+			if (start &gt; s.length() || start &lt; 1 || end &gt; s.length())
+				err(MyLocale.getMsg(1717, &quot;mid: Argument out of range&quot;));
+			return s.substring((int) start - 1, end);
+		}
+	}
 
-    /** MOD function as in Basic */
-    private Double funcMod() throws Exception {
-    	double b=popCalcStackAsNumber(0);
-    	double a=popCalcStackAsNumber(0);
-		if (b==0.0)
-			err(MyLocale.getMsg(1729,&quot;Division by 0&quot;));
+	/** MOD function as in Basic */
+	private Double funcMod() throws Exception {
+		double b = popCalcStackAsNumber(0);
+		double a = popCalcStackAsNumber(0);
+		if (b == 0.0)
+			err(MyLocale.getMsg(1729, &quot;Division by 0&quot;));
 		return new java.lang.Double(a % b);
-    }
+	}
 
 	/** Get or set the profile centre */
 	private void funcPz(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getProfile().centre.toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
 			Global.getProfile().centre.set(coordA);
 		}
 	}
@@ -662,266 +658,281 @@
 	 * Calculates the crossbearing from point1 with bearing 1 and point2 with bearing2
 	 * point1 and point 2 must be different.
 	 * Not very well tested. No guarantee for correct result if any of the distance is greater than 300 kilometers and / or any of the angles in the spherical triangle id greater then 90degrees
+	 * 
 	 * @return
 	 * @throws Exception
 	 */
-	private String funcCrossBearing () throws Exception{
-		//parameters come in reversed order!
+	private String funcCrossBearing() throws Exception {
+		// parameters come in reversed order!
 		double degrees2 = popCalcStackAsNumber(-1);
 		String coordinates2 = popCalcStackAsString();
 		double degrees1 = popCalcStackAsNumber(-1);
 		String coordinates1 = popCalcStackAsString();
-		if (!isValidCoord(coordinates1)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordinates1);
- 		if (!isValidCoord(coordinates2)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordinates2);
+		if (!isValidCoord(coordinates1))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordinates1);
+		if (!isValidCoord(coordinates2))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordinates2);
 
-		//Check parameters: Range
-    	if (degrees1&lt;0 || degrees1&gt;360 || degrees2 &lt; 0 || degrees2 &gt; 360){
-    		if (Global.getPref().solverDegMode){
-    			err(MyLocale.getMsg(1740,&quot;Crossbearing degrees must be in interval [0;360]&quot;));
-    		}
-    		else{
-    			err(MyLocale.getMsg(1741,&quot;Crossbearing degrees must be in interval [0;2*PI]&quot;));
-    		}
-    	}
-    	double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0
-				* java.lang.Math.PI : degrees1;
-		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0
-				* java.lang.Math.PI : degrees2;
+		// Check parameters: Range
+		if (degrees1 &lt; 0 || degrees1 &gt; 360 || degrees2 &lt; 0 || degrees2 &gt; 360) {
+			if (Global.getPref().solverDegMode) {
+				err(MyLocale.getMsg(1740, &quot;Crossbearing degrees must be in interval [0;360]&quot;));
+			} else {
+				err(MyLocale.getMsg(1741, &quot;Crossbearing degrees must be in interval [0;2*PI]&quot;));
+			}
+		}
+		double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0 * java.lang.Math.PI : degrees1;
+		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0 * java.lang.Math.PI : degrees2;
 
-		CWPoint point1=new CWPoint(coordinates1);
-		CWPoint point2=new CWPoint(coordinates2);
+		CWPoint point1 = new CWPoint(coordinates1);
+		CWPoint point2 = new CWPoint(coordinates2);
 
-    	//check Parameters: bearings to project must be different from the bearing between point1 and point2
-    	if (degrees1 == degrees2){
-    		double bearing1 = point1.getBearing(point2);
-    		double bearing2 = point1.getBearing(point1);
-    		if (bearing1 == degrees1 || bearing2 == degrees2){
-    			err(MyLocale.getMsg(1740,&quot;Invalid crossbearing angles&quot;));
-    		}
-    	}
+		// check Parameters: bearings to project must be different from the bearing between point1 and point2
+		if (degrees1 == degrees2) {
+			double bearing1 = point1.getBearing(point2);
+			double bearing2 = point1.getBearing(point1);
+			if (bearing1 == degrees1 || bearing2 == degrees2) {
+				err(MyLocale.getMsg(1740, &quot;Invalid crossbearing angles&quot;));
+			}
+		}
 
 		CWPoint result2 = crossbearingCalculation(point1, point2, rAN, rBN);
 		return result2.toString();
 	}
 
 	private CWPoint crossbearingCalculation(CWPoint point1, CWPoint point2, double rAN, double rBN) throws Exception {
-		//see german wikipedia keyword vorwaertsschnitt for the calculation.
-		//peilung von a-&gt;b
-		//Yes we will make an error, therefore we have to calculate the target-point iteratively.
-		//Testcode for crossbearing:
+		// see german wikipedia keyword vorwaertsschnitt for the calculation.
+		// peilung von a-&gt;b
+		// Yes we will make an error, therefore we have to calculate the target-point iteratively.
+		// Testcode for crossbearing:
 		// MP=&quot;S35 47.100 W089 43.200&quot; # MP is centre of circle, could be any waypoint
 		// A=project(MP,0,1000); B=project(MP,120,1000) # Points of equilateral triangle on circle
 		// C1=project(MP,240,1000); C2=cb(A,210 ,B,270)
-		//	C1 &quot;=&quot; C2
+		// C1 &quot;=&quot; C2
 		final int maxRadius = 6378;
-    	double distance = point1.getDistance(point2);
-    	if (Math.abs (distance) &lt;= 0.0000000001){
-    		err (MyLocale.getMsg(1742,&quot;Crossbearing: distance between points to small&quot;));
-    	}
-    	double distanceInRad = distance / maxRadius;
-	    double phiAB = point1.getBearing(point2);
-	    if (Global.getPref().solverDegMode) phiAB=phiAB / 180.0 * java.lang.Math.PI;
-	    double phiBA = point2.getBearing(point1);
-	    if (Global.getPref().solverDegMode) phiBA=phiBA / 180.0 * java.lang.Math.PI;
+		double distance = point1.getDistance(point2);
+		if (Math.abs(distance) &lt;= 0.0000000001) {
+			err(MyLocale.getMsg(1742, &quot;Crossbearing: distance between points to small&quot;));
+		}
+		double distanceInRad = distance / maxRadius;
+		double phiAB = point1.getBearing(point2);
+		if (Global.getPref().solverDegMode)
+			phiAB = phiAB / 180.0 * java.lang.Math.PI;
+		double phiBA = point2.getBearing(point1);
+		if (Global.getPref().solverDegMode)
+			phiBA = phiBA / 180.0 * java.lang.Math.PI;
 
-	    double psi = phiAB - rAN;
-	    double phi = rBN - phiBA;
+		double psi = phiAB - rAN;
+		double phi = rBN - phiBA;
 
-	    //calculate projetiondistance
-	    double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi+psi);
-	    double b = bInRad * maxRadius ;//* (1-flattening);
-	    double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi+psi);
-	    double a = aInRad * maxRadius ;//* (1-flattening);
-	    double phiAN = phiAB - psi;
-	    double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
-	    double phiBN = phiBA + phi;
-	    double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
-	    CWPoint result2 = point2.project(phiBNDegrees, a);
-	    CWPoint result = point1.project(phiANDegrees, b);
-	    double errorDistance = result.getDistance(result2);
-	    //if the distance between the points is to large, we will restart the calculation with the new points found.
-	    //since the error is mostly very small these iterations are seldom used and the needed depth is very low.
-	    //First we will make sure, that this calculation will terminate
-	    if (distance &lt; errorDistance){
-    		err (MyLocale.getMsg(1743,&quot;Crossbearing calculation failed. Please inform the developers at geoclub.de&quot;));
-	    }
-	    if (errorDistance * 1000 &gt; 1){
-	    	return crossbearingCalculation(result, result2, rAN, rBN);
-	    }
+		// calculate projetiondistance
+		double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi + psi);
+		double b = bInRad * maxRadius;// * (1-flattening);
+		double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi + psi);
+		double a = aInRad * maxRadius;// * (1-flattening);
+		double phiAN = phiAB - psi;
+		double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
+		double phiBN = phiBA + phi;
+		double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
+		CWPoint result2 = point2.project(phiBNDegrees, a);
+		CWPoint result = point1.project(phiANDegrees, b);
+		double errorDistance = result.getDistance(result2);
+		// if the distance between the points is to large, we will restart the calculation with the new points found.
+		// since the error is mostly very small these iterations are seldom used and the needed depth is very low.
+		// First we will make sure, that this calculation will terminate
+		if (distance &lt; errorDistance) {
+			err(MyLocale.getMsg(1743, &quot;Crossbearing calculation failed. Please inform the developers at geoclub.de&quot;));
+		}
+		if (errorDistance * 1000 &gt; 1) {
+			return crossbearingCalculation(result, result2, rAN, rBN);
+		}
 		return result2;
 	}
 
-    /** Project a waypoint at some angle and some distance */
-    private String funcProject() throws Exception {
-    	double distance=popCalcStackAsNumber(0);
-    	if (distance&lt;0) err(MyLocale.getMsg(1718,&quot;Cannot project a negative distance&quot;));
-    	double degrees=popCalcStackAsNumber(0);
-    	// If we are not in degree mode, arg is in radiants ==&gt; convert it
-    	if (!Global.getPref().solverDegMode) degrees=degrees * 180.0 / java.lang.Math.PI;
-    	if (degrees&lt;0 || degrees&gt;360)
-    		if (Global.getPref().solverDegMode)
-    			err(MyLocale.getMsg(1719,&quot;Projection degrees must be in interval [0;360]&quot;));
-    		else
-    			err(MyLocale.getMsg(1739,&quot;Projection degrees must be in interval [0;2*PI]&quot;));
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
-    	cwPt.set(coord);
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
-    	} else {
-    		distance = distance / 1000.0;
-    	}
-    	return cwPt.project(degrees,distance).toString();
-    }
+	/** Project a waypoint at some angle and some distance */
+	private String funcProject() throws Exception {
+		double distance = popCalcStackAsNumber(0);
+		if (distance &lt; 0)
+			err(MyLocale.getMsg(1718, &quot;Cannot project a negative distance&quot;));
+		double degrees = popCalcStackAsNumber(0);
+		// If we are not in degree mode, arg is in radiants ==&gt; convert it
+		if (!Global.getPref().solverDegMode)
+			degrees = degrees * 180.0 / java.lang.Math.PI;
+		if (degrees &lt; 0 || degrees &gt; 360)
+			if (Global.getPref().solverDegMode)
+				err(MyLocale.getMsg(1719, &quot;Projection degrees must be in interval [0;360]&quot;));
+			else
+				err(MyLocale.getMsg(1739, &quot;Projection degrees must be in interval [0;2*PI]&quot;));
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
+		cwPt.set(coord);
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
+		} else {
+			distance = distance / 1000.0;
+		}
+		return cwPt.project(degrees, distance).toString();
+	}
 
-    /** Convert Radiants into degrees */
-    private double funcRad2Deg() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a*180.0/java.lang.Math.PI;
-    }
+	/** Convert Radiants into degrees */
+	private double funcRad2Deg() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a * 180.0 / java.lang.Math.PI;
+	}
 
-    /** Replace all occurrences of a string with another string */
-    private String funcReplace() throws Exception {
-    	String replaceWith=popCalcStackAsString();
-    	String whatToReplace=popCalcStackAsString();
-    	String s=popCalcStackAsString();
-        if (whatToReplace.equals(&quot;&quot;)) return s;
-        return STRreplace.replace(s,whatToReplace,replaceWith);
-    }
+	/** Replace all occurrences of a string with another string */
+	private String funcReplace() throws Exception {
+		String replaceWith = popCalcStackAsString();
+		String whatToReplace = popCalcStackAsString();
+		String s = popCalcStackAsString();
+		if (whatToReplace.equals(&quot;&quot;))
+			return s;
+		return STRreplace.replace(s, whatToReplace, replaceWith);
+	}
 
-    /** Reverse a string */
-    private String funcReverse(String s) {
-    	String res=&quot;&quot;;
-    	for (int i=s.length()-1; i&gt;=0; i--) res+=s.charAt(i);
-    	return res;
-    }
+	/** Reverse a string */
+	private String funcReverse(String s) {
+		String res = &quot;&quot;;
+		for (int i = s.length() - 1; i &gt;= 0; i--)
+			res += s.charAt(i);
+		return res;
+	}
 
-    /** Create a skeleton for multis. This function can be called in three ways:&lt;br&gt;
-     *  &lt;pre&gt;sk()                Create skeleton for current cache (must have addi wpts)
-     *  sk(number)          Create skeleton for number variables
-     */
-    private void funcSkeleton(int nargs) throws Exception {
-   		String waypointName=Global.mainTab.lastselected;
-    	CacheHolder c=Global.getProfile().cacheDB.get(waypointName);
-    	if (c == null) return;
-    	// If it is an addi, find its main cache
-    	if (c.isAddiWpt()) {
-    		waypointName=c.mainCache.getWayPoint();
-    	}
-   		int nStages=-1;
-    	if (nargs==1) {
-    		nStages=(int)popCalcStackAsNumber(-1.0);
-    	}
-    	// Remove the sk command from the instructions
-    	Regex rex=new Regex(&quot;sk\\(.*?\\)&quot;,&quot;&quot;);
-    	Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
-		StringBuffer op=new StringBuffer(1000);
-    	// Check for sk(number)
-    	if (nStages&gt;0 &amp;&amp; nStages&lt;30) { // e.g. sk(3)
-			/*IF $01xxxx=&quot;&quot; THEN
-			   $01xxxx=&quot;&quot;
-			   &quot;Station 1 = &quot; $01xxxx
-			   goto($01xxxx); STOP
-			ENDIF*/
-			boolean didCreateWp=false;
-    		for (int i=0; i&lt;nStages; i++) {
-				String stage=MyLocale.formatLong(i,&quot;00&quot;);
-				String stageWpt=&quot;$&quot;+stage+waypointName.substring(2);
-				String stageName = &quot;Stage &quot;+(i+1);
+	/**
+	 * Create a skeleton for multis. This function can be called in three ways:&lt;br&gt;
+	 * 
+	 * &lt;pre&gt;
+	 * sk()                Create skeleton for current cache (must have addi wpts)
+	 * sk(number)          Create skeleton for number variables
+	 */
+	private void funcSkeleton(int nargs) throws Exception {
+		String waypointName = Global.mainTab.lastselected;
+		CacheHolder c = Global.getProfile().cacheDB.get(waypointName);
+		if (c == null)
+			return;
+		// If it is an addi, find its main cache
+		if (c.isAddiWpt()) {
+			waypointName = c.mainCache.getWayPoint();
+		}
+		int nStages = -1;
+		if (nargs == 1) {
+			nStages = (int) popCalcStackAsNumber(-1.0);
+		}
+		// Remove the sk command from the instructions
+		Regex rex = new Regex(&quot;sk\\(.*?\\)&quot;, &quot;&quot;);
+		Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
+		StringBuffer op = new StringBuffer(1000);
+		// Check for sk(number)
+		if (nStages &gt; 0 &amp;&amp; nStages &lt; 30) { // e.g. sk(3)
+			/*
+			 * IF $01xxxx=&quot;&quot; THEN
+			 * $01xxxx=&quot;&quot;
+			 * &quot;Station 1 = &quot; $01xxxx
+			 * goto($01xxxx); STOP
+			 * ENDIF
+			 */
+			boolean didCreateWp = false;
+			for (int i = 0; i &lt; nStages; i++) {
+				String stage = MyLocale.formatLong(i, &quot;00&quot;);
+				String stageWpt = &quot;$&quot; + stage + waypointName.substring(2);
+				String stageName = &quot;Stage &quot; + (i + 1);
 				byte type = CacheType.CW_TYPE_STAGE;
 				if (i == nStages - 1) {
 					stageName = &quot;Final&quot;;
 					type = CacheType.CW_TYPE_FINAL;
 				}
-				didCreateWp|=createWptIfNeeded(stage+waypointName.substring(2), stageName, type);
-				op.append(&quot;IF &quot;+stageWpt+&quot;=\&quot;\&quot; THEN\n&quot;);
-				op.append(&quot;  &quot;+stageWpt+&quot; = \&quot;\&quot;\n&quot;);
-				op.append(&quot;  \&quot;&quot;+stageName+&quot; = \&quot; &quot;+stageWpt+&quot;\n&quot;);
-				op.append(&quot;  goto(&quot;+stageWpt+&quot;); STOP\n&quot;);
+				didCreateWp |= createWptIfNeeded(stage + waypointName.substring(2), stageName, type);
+				op.append(&quot;IF &quot; + stageWpt + &quot;=\&quot;\&quot; THEN\n&quot;);
+				op.append(&quot;  &quot; + stageWpt + &quot; = \&quot;\&quot;\n&quot;);
+				op.append(&quot;  \&quot;&quot; + stageName + &quot; = \&quot; &quot; + stageWpt + &quot;\n&quot;);
+				op.append(&quot;  goto(&quot; + stageWpt + &quot;); STOP\n&quot;);
 				op.append(&quot;ENDIF\n&quot;);
 			}
-			Global.mainTab.solverP.mText.appendText(op.toString(),true);
+			Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			if (didCreateWp) {
-		    	Global.mainTab.updatePendingChanges();
+				Global.mainTab.updatePendingChanges();
 				Global.mainTab.tbP.refreshTable();
 			}
-    	} else {
-	   	    CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-	   	    if (ch == null) {
-	   	    	err(MyLocale.getMsg(1714,&quot;Goto: Waypoint does not exist: &quot;)+waypointName);
-	   	    	return;
-	   	    }
+		} else {
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, &quot;Goto: Waypoint does not exist: &quot;) + waypointName);
+				return;
+			}
 			CacheHolder addiWpt;
-	   	    if (ch.hasAddiWpt()){
-	   	    	op.append(&quot;cls()\n&quot;);
-				for (int j=0; j&lt;ch.addiWpts.getCount();j++){
-					addiWpt = (CacheHolder)ch.addiWpts.get(j);
+			if (ch.hasAddiWpt()) {
+				op.append(&quot;cls()\n&quot;);
+				for (int j = 0; j &lt; ch.addiWpts.getCount(); j++) {
+					addiWpt = (CacheHolder) ch.addiWpts.get(j);
 					op.append(&quot;IF $&quot;);
 					op.append(addiWpt.getWayPoint());
 					op.append(&quot;=\&quot;\&quot; THEN\n   $&quot;);
 					op.append(addiWpt.getWayPoint());
 					op.append(&quot;=\&quot;\&quot;&quot;);
-					//op.append(addiWpt.pos.toString());
+					// op.append(addiWpt.pos.toString());
 					op.append(&quot;\n   \&quot;Punkt &quot;);
-					op.append(addiWpt.getWayPoint().substring(0,2));
+					op.append(addiWpt.getWayPoint().substring(0, 2));
 					op.append(&quot; [&quot;);
 					op.append(addiWpt.getCacheName());
 					op.append(&quot;] = \&quot; $&quot;);
 					op.append(addiWpt.getWayPoint());
-					if (addiWpt.getCacheDetails(true).LongDescription.trim().length()&gt;0)
-						op.append(&quot;\n   \&quot;&quot;+STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription,&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
+					if (addiWpt.getCacheDetails(true).LongDescription.trim().length() &gt; 0)
+						op.append(&quot;\n   \&quot;&quot; + STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription, &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;);
 					op.append(&quot;\n   goto($&quot;);
 					op.append(addiWpt.getWayPoint());
 					op.append(&quot;); STOP\nENDIF\n\n&quot;);
 				}
-				Global.mainTab.solverP.mText.appendText(op.toString(),true);
+				Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			}// if hasAddiWpt
-    	}
-    }
+		}
+	}
 
-    private double funcSqrt() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	if (a&lt;0) err(MyLocale.getMsg(1720,&quot;Cannot calculate square root of a negative number&quot;));
-    	return java.lang.Math.sqrt(a);
-    }
+	private double funcSqrt() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		if (a &lt; 0)
+			err(MyLocale.getMsg(1720, &quot;Cannot calculate square root of a negative number&quot;));
+		return java.lang.Math.sqrt(a);
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and put result into a string */
-    private String funcSval(String s) {
-       	s=s.toLowerCase();
-    	String res=&quot;&quot;;
-       	for (int i=0; i&lt;s.length(); i++) {
-    		int pos=&quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i));
-    		if (pos&gt;=0)
-    			res+=(res==&quot;&quot;?&quot;&quot;:&quot; &quot;)+MyLocale.formatLong(pos+1,&quot;00&quot;);
-    	}
-    	return res;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and put result into a string */
+	private String funcSval(String s) {
+		s = s.toLowerCase();
+		String res = &quot;&quot;;
+		for (int i = 0; i &lt; s.length(); i++) {
+			int pos = &quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i));
+			if (pos &gt;= 0)
+				res += (res == &quot;&quot; ? &quot;&quot; : &quot; &quot;) + MyLocale.formatLong(pos + 1, &quot;00&quot;);
+		}
+		return res;
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and sum them */
-    private double funcVal(String s) {
-    	s=s.toLowerCase();
-    	int sum=0;
-    	for (int i=0; i&lt;s.length(); i++) {
-    		sum+=&quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i))+1;
-    	}
-    	return sum;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and sum them */
+	private double funcVal(String s) {
+		s = s.toLowerCase();
+		int sum = 0;
+		for (int i = 0; i &lt; s.length(); i++) {
+			sum += &quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i)) + 1;
+		}
+		return sum;
+	}
 
-///////////////////////////////////////////
-//  PARSER
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// PARSER
+	// /////////////////////////////////////////
 
+	/**
+	 * The following methods implement a recursive descent parser.
+	 * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
+	 * a valid token.
+	 */
 
-    /** The following methods implement a recursive descent parser.
-     * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
-     * a valid token.
-     */
-
-	private void parseCommand()  throws Exception {
-		while(scanpos &lt; tokenStack.size()) {
+	private void parseCommand() throws Exception {
+		while (scanpos &lt; tokenStack.size()) {
 			getToken();
-			if (thisToken.token.equals(&quot;;&quot;)) continue;  // skip an empty command
-			if (thisToken.tt==TokenObj.TT_IF)
+			if (thisToken.token.equals(&quot;;&quot;))
+				continue; // skip an empty command
+			if (thisToken.tt == TokenObj.TT_IF)
 				parseIf();
 			else
 				parseSimpleCommand();
@@ -929,314 +940,385 @@
 		}
 	}
 
-	private void parseSimpleCommand() throws Exception{
-		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception(&quot;STOP&quot;);  // Terminate without error message
+	private void parseSimpleCommand() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STOP)
+			throw new Exception(&quot;STOP&quot;); // Terminate without error message
 		if (thisToken.token.equals(&quot;$&quot;)) { // Show all global variables
 			showVars(true);
 			getToken();
 		} else if (thisToken.token.equals(&quot;?&quot;)) { // Show all local variables
 			showVars(false);
 			getToken();
-		} else if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt==TokenObj.TT_EQ)
+		} else if (thisToken.tt == TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt == TokenObj.TT_EQ)
 			parseAssign();
 		else {
 			parseStringExp();
-			while (calcStack.size()&gt;0) messageStack.add(popCalcStackAsString());
+			while (calcStack.size() &gt; 0)
+				messageStack.add(popCalcStackAsString());
 		}
 	}
 
-	private void parseIf() throws Exception{
+	private void parseIf() throws Exception {
 		int compOp;
-		boolean compRes=false;
-		TokenObj ifToken=thisToken;
+		boolean compRes = false;
+		TokenObj ifToken = thisToken;
 		getToken();
 		// Check for &quot;IF varName THEN&quot; construct to check whether a variable is defined
-		if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; peekToken().token.toUpperCase().equals(&quot;THEN&quot;)) {
-			String varName=thisToken.token;
-			getToken(); //THEN
-			Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-			if(result == null) { // Var not found check whether it is a waypoint
+		if (thisToken.tt == TokenObj.TT_VARIABLE &amp;&amp; peekToken().token.toUpperCase().equals(&quot;THEN&quot;)) {
+			String varName = thisToken.token;
+			getToken(); // THEN
+			Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+			if (result == null) { // Var not found check whether it is a waypoint
 				if (varName.startsWith(&quot;$&quot;)) { // Could be a cachename
-					varName=varName.substring(1);
-					compRes=Global.getProfile().getCacheIndex(varName)!=-1;
+					varName = varName.substring(1);
+					compRes = Global.getProfile().getCacheIndex(varName) != -1;
 				} else
-					compRes=false;
-			} else // Found the variable, it must have a value
-				compRes=true;
+					compRes = false;
+			} else
+				// Found the variable, it must have a value
+				compRes = true;
 			getNextTokenOtherThanSemi();
 		} else { // Normal: IF expression THEN
 			parseStringExp();
-			compOp=thisToken.tt;
-			if (compOp&lt;TokenObj.TT_LT || compOp&gt;TokenObj.TT_NE) err(MyLocale.getMsg(1723,&quot;Comparison operator expected&quot;));
+			compOp = thisToken.tt;
+			if (compOp &lt; TokenObj.TT_LT || compOp &gt; TokenObj.TT_NE)
+				err(MyLocale.getMsg(1723, &quot;Comparison operator expected&quot;));
 			getToken();
 			parseStringExp();
 			checkNextSymIs(&quot;THEN&quot;);
 			getNextTokenOtherThanSemi();
-			boolean compAsString=false; //calcStack.get(calcStack.size()-2) instanceof String;
+			boolean compAsString = false; // calcStack.get(calcStack.size()-2) instanceof String;
 			// If we can parse the first argument as a double, we will do a numeric comparison
 			try {
-				Common.parseDoubleException((String)calcStack.get(calcStack.size()-2) );
+				Common.parseDoubleException((String) calcStack.get(calcStack.size() - 2));
 			} catch (Exception ex) {
-				compAsString=true;
+				compAsString = true;
 			}
 			// If the first expression is not a double, compare as string.
 			if (compAsString) {
-				String b=popCalcStackAsString();
-				String a=popCalcStackAsString();
+				String b = popCalcStackAsString();
+				String a = popCalcStackAsString();
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a.equals(b); break;
-					case TokenObj.TT_NE: compRes=!a.equals(b); break;
-					case TokenObj.TT_LT: compRes=a.compareTo(b)&lt;0; break;
-					case TokenObj.TT_GT: compRes=a.compareTo(b)&gt;0; break;
-					case TokenObj.TT_LE: compRes=a.compareTo(b)&lt;=0; break;
-					case TokenObj.TT_GE: compRes=a.compareTo(b)&gt;=0; break;
+				case TokenObj.TT_EQ:
+					compRes = a.equals(b);
+					break;
+				case TokenObj.TT_NE:
+					compRes = !a.equals(b);
+					break;
+				case TokenObj.TT_LT:
+					compRes = a.compareTo(b) &lt; 0;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a.compareTo(b) &gt; 0;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a.compareTo(b) &lt;= 0;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a.compareTo(b) &gt;= 0;
+					break;
 				}
 			} else { // First expression is a number, compare as numbers
-				double b=popCalcStackAsNumber(0);
-				double a=popCalcStackAsNumber(0);
+				double b = popCalcStackAsNumber(0);
+				double a = popCalcStackAsNumber(0);
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a==b; break;
-					case TokenObj.TT_NE: compRes=a!=b; break;
-					case TokenObj.TT_LT: compRes=a&lt;b; break;
-					case TokenObj.TT_GT: compRes=a&gt;b; break;
-					case TokenObj.TT_LE: compRes=a&lt;=b; break;
-					case TokenObj.TT_GE: compRes=a&gt;=b; break;
+				case TokenObj.TT_EQ:
+					compRes = a == b;
+					break;
+				case TokenObj.TT_NE:
+					compRes = a != b;
+					break;
+				case TokenObj.TT_LT:
+					compRes = a &lt; b;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a &gt; b;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a &lt;= b;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a &gt;= b;
+					break;
 				}
 			}
 		}
 		if (compRes) { // comparison resulted in TRUE
-			if (thisToken.tt!=TokenObj.TT_ENDIF) {
+			if (thisToken.tt != TokenObj.TT_ENDIF) {
 				parseSimpleCommand();
 				while (thisToken.token.equals(&quot;;&quot;)) {
 					getNextTokenOtherThanSemi(); // Now we have either an ENDIF or the start of a simpleexpression
-					if (thisToken.tt==TokenObj.TT_ENDIF) break;
+					if (thisToken.tt == TokenObj.TT_ENDIF)
+						break;
 					parseSimpleCommand();
 				}
 				checkNextSymIs(&quot;ENDIF&quot;);
 			}
 			getToken();
-		} else // comparison failed
+		} else
+			// comparison failed
 			skipPastEndif(ifToken);
 	}
 
-	private void parseAssign() throws Exception  {
-		String varName=new String(thisToken.token);
-		getToken(); //=
+	private void parseAssign() throws Exception {
+		String varName = new String(thisToken.token);
+		getToken(); // =
 		getToken();
 		// Assigns of the format A=; are ignored so that they can stay as placeholders and
 		// we can fill the data progressively during a multicache
-		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(&quot;;&quot;)) return;
+		if (thisToken.tt == TokenObj.TT_ENDIF || thisToken.token.equals(&quot;;&quot;))
+			return;
 		parseStringExp();
 		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Yes, is a coordinate
 				// Check whether new coordinates are valid
-				String coord=popCalcStackAsString();
+				String coord = popCalcStackAsString();
 				cwPt.set(coord);
 				if (cwPt.isValid() || coord.equals(&quot;&quot;)) { // Can clear coord with empty string
-					ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-					ch.pos.set(cwPt);
+					ch.setPos(cwPt);
 					ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance and bearing
-		    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-				    return;
+					Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+					return;
 				} else
-					err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+					err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
 			}
 			// Name starts with $ but is not a waypoint, fall through and set it as global variable
 		}
-		symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName, popCalcStackAsString());
+		symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, popCalcStackAsString());
 	}
 
-	private void parseStringExp()throws Exception {
-		if (thisToken.tt==TokenObj.TT_STRING) {
+	private void parseStringExp() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 			getToken();
 		} else {
 			parseExp();
 		}
-		//calcStack.add(popCalcStackAsString());
-		while (thisToken.tt==TokenObj.TT_STRING ||
-			   thisToken.tt==TokenObj.TT_NUMBER ||
-			   thisToken.tt==TokenObj.TT_VARIABLE ||
-			   thisToken.tt==TokenObj.TT_SYMBOL &amp;&amp; thisToken.token.equals(&quot;(&quot;)) {
-			if (thisToken.tt==TokenObj.TT_STRING) {
+		// calcStack.add(popCalcStackAsString());
+		while (thisToken.tt == TokenObj.TT_STRING || thisToken.tt == TokenObj.TT_NUMBER || thisToken.tt == TokenObj.TT_VARIABLE || thisToken.tt == TokenObj.TT_SYMBOL &amp;&amp; thisToken.token.equals(&quot;(&quot;)) {
+			if (thisToken.tt == TokenObj.TT_STRING) {
 				calcStack.add(thisToken.token);
 				getToken();
 			} else {
 				parseTailExp('+');
 			}
-			String b=popCalcStackAsString();
-			String a=popCalcStackAsString();
-			calcStack.add(a+b);
+			String b = popCalcStackAsString();
+			String a = popCalcStackAsString();
+			calcStack.add(a + b);
 		}
 	}
 
-	private void parseExp()throws Exception {
-		char unaryOp='+';
-		if (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;) ) {
-			unaryOp=thisToken.token.charAt(0);
+	private void parseExp() throws Exception {
+		char unaryOp = '+';
+		if (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;)) {
+			unaryOp = thisToken.token.charAt(0);
 			getToken();
 		}
 		parseTailExp(unaryOp);
 	}
 
-	private void parseTailExp(char unaryOp)throws Exception {
+	private void parseTailExp(char unaryOp) throws Exception {
 		parseTerm();
-		if (unaryOp=='-') { // Unary minus, negate the first term
+		if (unaryOp == '-') { // Unary minus, negate the first term
 			calcStack.add(new java.lang.Double(-popCalcStackAsNumber(0)));
 		}
-		while (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;) ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;)) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseTerm();
-			double b=popCalcStackAsNumber(0);
-			double a=popCalcStackAsNumber(0);
-			if (op=='+')
-				calcStack.add(new java.lang.Double(a+b));
+			double b = popCalcStackAsNumber(0);
+			double a = popCalcStackAsNumber(0);
+			if (op == '+')
+				calcStack.add(new java.lang.Double(a + b));
 			else
-				calcStack.add(new java.lang.Double(a-b));
+				calcStack.add(new java.lang.Double(a - b));
 		}
 		// If expression is followed by a formatstring, format it
-		if (thisToken.tt==TokenObj.TT_FORMATSTR) {
-			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0),thisToken.token).replace(',','.'));
+		if (thisToken.tt == TokenObj.TT_FORMATSTR) {
+			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0), thisToken.token).replace(',', '.'));
 			getToken();
 		}
 	}
 
-	private void parseTerm() throws Exception{
+	private void parseTerm() throws Exception {
 		parseFactor();
-		while (thisToken.token.equals(&quot;*&quot;) || thisToken.token.equals(&quot;/&quot;) ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals(&quot;*&quot;) || thisToken.token.equals(&quot;/&quot;)) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseFactor();
-			double b=popCalcStackAsNumber(1);
-			double a=popCalcStackAsNumber(1);
-			if (op=='*')
-				calcStack.add(new java.lang.Double(a*b));
+			double b = popCalcStackAsNumber(1);
+			double a = popCalcStackAsNumber(1);
+			if (op == '*')
+				calcStack.add(new java.lang.Double(a * b));
+			else if (b == 0.0)
+				err(MyLocale.getMsg(1729, &quot;Division by 0&quot;));
 			else
-				if (b==0.0)
-					err(MyLocale.getMsg(1729,&quot;Division by 0&quot;));
-				else
-					calcStack.add(new java.lang.Double(a/b));
+				calcStack.add(new java.lang.Double(a / b));
 		}
 	}
 
-	private void parseFactor() throws Exception{
+	private void parseFactor() throws Exception {
 		parseExpFactor();
 		while (thisToken.token.equals(&quot;^&quot;)) {
 			getToken();
 			parseExpFactor();
-			double exp=popCalcStackAsNumber(0);
-			double base=popCalcStackAsNumber(0);
-			calcStack.add(new java.lang.Double(java.lang.Math.pow(base,exp)));
+			double exp = popCalcStackAsNumber(0);
+			double base = popCalcStackAsNumber(0);
+			calcStack.add(new java.lang.Double(java.lang.Math.pow(base, exp)));
 		}
 	}
 
 	private void parseExpFactor() throws Exception {
 		fnType funcDef;
-		if (thisToken.tt==TokenObj.TT_VARIABLE) {
-			if (isVariable(thisToken.token) &amp;&amp; !lookAheadToken().token.equals(&quot;(&quot;) )
+		if (thisToken.tt == TokenObj.TT_VARIABLE) {
+			if (isVariable(thisToken.token) &amp;&amp; !lookAheadToken().token.equals(&quot;(&quot;))
 				calcStack.add(getVariable(thisToken.token));
-			else if (!lookAheadToken().token.equals(&quot;(&quot;)) err(MyLocale.getMsg(1724,&quot;Variable not set: &quot;)+thisToken.token);
-			    else {// Must be a function definition
-				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
+			else if (!lookAheadToken().token.equals(&quot;(&quot;))
+				err(MyLocale.getMsg(1724, &quot;Variable not set: &quot;) + thisToken.token);
+			else {// Must be a function definition
+				funcDef = getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
 				parseFunction(funcDef);
-			    }
-		} else if (thisToken.tt==TokenObj.TT_NUMBER) {
+			}
+		} else if (thisToken.tt == TokenObj.TT_NUMBER) {
 			calcStack.add(getNumber(thisToken.token));
-		} else if (thisToken.tt==TokenObj.TT_STRING) {
+		} else if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 		} else if (thisToken.token.equals(&quot;(&quot;)) {
 			getToken();
 			parseStringExp();
 			checkNextSymIs(&quot;)&quot;);
-		}
-		else err(MyLocale.getMsg(1725,&quot;Unexpected character(s): &quot;)+thisToken.token);
+		} else
+			err(MyLocale.getMsg(1725, &quot;Unexpected character(s): &quot;) + thisToken.token);
 		getToken();
 	}
 
 	private void parseFunction(fnType funcDef) throws Exception {
-		String funcName=new String(thisToken.token);
-        int nargs=0;
+		String funcName = new String(thisToken.token);
+		int nargs = 0;
 		getToken();
 		checkNextSymIs(&quot;(&quot;);
 		getToken();
 		if (!thisToken.token.equals(&quot;)&quot;)) { // at least one argument
 			parseStringExp();
-			nargs=1;
+			nargs = 1;
 			while (thisToken.token.equals(&quot;,&quot;)) {
-				if (nargs==4) err(MyLocale.getMsg(1726,&quot;Too many arguments for function &quot;)+funcName);
+				if (nargs == 4)
+					err(MyLocale.getMsg(1726, &quot;Too many arguments for function &quot;) + funcName);
 				getToken();
 				parseStringExp();
 				nargs++;
 			}
 			checkNextSymIs(&quot;)&quot;);
 		}
-		//getToken(); done in parseFactor
-		executeFunction(funcName,nargs,funcDef);
+		// getToken(); done in parseFactor
+		executeFunction(funcName, nargs, funcDef);
 	}
 
 	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
-		if (!funcDef.nargsValid(nargs)) err(MyLocale.getMsg(1727,&quot;Invalid number of arguments&quot;));
-	         if (funcDef.alias.equals(&quot;asin&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
-	 	else if (funcDef.alias.equals(&quot;abs&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
-	    else if (funcDef.alias.equals(&quot;acos&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;atan&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;bearing&quot;)) calcStack.add(new java.lang.Double(funcBearing()));
-	    else if (funcDef.alias.equals(&quot;center&quot;)) funcCenter(nargs);
-	    else if (funcDef.alias.equals(&quot;cls&quot;)) funcCls();
-	    else if (funcDef.alias.equals(&quot;cos&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;count&quot;)) funcCount();
-	    else if (funcDef.alias.equals(&quot;cp&quot;)) calcStack.add(funcCp());
-	    else if (funcDef.alias.equals(&quot;ct&quot;)) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
-	    else if (funcDef.alias.equals(&quot;deg&quot;)) funcDeg(true);
-	    else if (funcDef.alias.equals(&quot;deg2rad&quot;)) calcStack.add(new java.lang.Double(funcDeg2Rad()));
-	    else if (funcDef.alias.equals(&quot;distance&quot;)) calcStack.add(new java.lang.Double(funcDistance()));
-	    else if (funcDef.alias.equals(&quot;encode&quot;)) calcStack.add(funcEncode());
-	    else if (funcDef.alias.equals(&quot;format&quot;)) calcStack.add(funcFormat(nargs));
-	    else if (funcDef.alias.equals(&quot;goto&quot;)) funcGoto(nargs);
-	    else if (funcDef.alias.equals(&quot;ic&quot;)) funcIgnoreVariableCase(nargs);
-	    else if (funcDef.alias.equals(&quot;instr&quot;)) calcStack.add(new Double(funcInstr(nargs)));
-	    else if (funcDef.alias.equals(&quot;int&quot;)) calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
-	    else if (funcDef.alias.equals(&quot;lc&quot;)) calcStack.add(popCalcStackAsString().toLowerCase());
-	    else if (funcDef.alias.equals(&quot;len&quot;)) calcStack.add(new Double(popCalcStackAsString().length()));
-	    else if (funcDef.alias.equals(&quot;mid&quot;)) calcStack.add(funcMid(nargs));
-	    else if (funcDef.alias.equals(&quot;mod&quot;)) calcStack.add(funcMod());
-	    else if (funcDef.alias.equals(&quot;project&quot;)) calcStack.add(funcProject());
-	    else if (funcDef.alias.equals(&quot;pz&quot;)) funcPz(nargs);
-	    else if (funcDef.alias.equals(&quot;rad&quot;)) funcDeg(false);
-	    else if (funcDef.alias.equals(&quot;rad2deg&quot;)) calcStack.add(new java.lang.Double(funcRad2Deg()));
-	    else if (funcDef.alias.equals(&quot;replace&quot;)) calcStack.add(funcReplace());
-	    else if (funcDef.alias.equals(&quot;reverse&quot;)) calcStack.add(funcReverse(popCalcStackAsString()));
-	    else if (funcDef.alias.equals(&quot;rot13&quot;)) calcStack.add(Common.rot13(popCalcStackAsString()));
-//	    else if (funcDef.alias.equals(&quot;rs&quot;)) funcRequireSemicolon(nargs);
-	    else if (funcDef.alias.equals(&quot;show&quot;));
-	    else if (funcDef.alias.equals(&quot;sin&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;skeleton&quot;)) funcSkeleton(nargs);
-	    else if (funcDef.alias.equals(&quot;sqrt&quot;)) calcStack.add(new java.lang.Double(funcSqrt()));
-	    else if (funcDef.alias.equals(&quot;sval&quot;)) calcStack.add(funcSval(popCalcStackAsString()));
-	    else if (funcDef.alias.equals(&quot;tan&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;uc&quot;)) calcStack.add(popCalcStackAsString().toUpperCase());
-	    else if (funcDef.alias.equals(&quot;val&quot;)) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
-	    else if (funcDef.alias.equals(&quot;cb&quot;)) calcStack.add(funcCrossBearing ());
-	    else err(MyLocale.getMsg(1728,&quot;Function not yet implemented: &quot;)+funcName);
+		if (!funcDef.nargsValid(nargs))
+			err(MyLocale.getMsg(1727, &quot;Invalid number of arguments&quot;));
+		if (funcDef.alias.equals(&quot;asin&quot;))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;abs&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
+		else if (funcDef.alias.equals(&quot;acos&quot;))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;atan&quot;))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;bearing&quot;))
+			calcStack.add(new java.lang.Double(funcBearing()));
+		else if (funcDef.alias.equals(&quot;center&quot;))
+			funcCenter(nargs);
+		else if (funcDef.alias.equals(&quot;cls&quot;))
+			funcCls();
+		else if (funcDef.alias.equals(&quot;cos&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;count&quot;))
+			funcCount();
+		else if (funcDef.alias.equals(&quot;cp&quot;))
+			calcStack.add(funcCp());
+		else if (funcDef.alias.equals(&quot;ct&quot;))
+			calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
+		else if (funcDef.alias.equals(&quot;deg&quot;))
+			funcDeg(true);
+		else if (funcDef.alias.equals(&quot;deg2rad&quot;))
+			calcStack.add(new java.lang.Double(funcDeg2Rad()));
+		else if (funcDef.alias.equals(&quot;distance&quot;))
+			calcStack.add(new java.lang.Double(funcDistance()));
+		else if (funcDef.alias.equals(&quot;encode&quot;))
+			calcStack.add(funcEncode());
+		else if (funcDef.alias.equals(&quot;format&quot;))
+			calcStack.add(funcFormat(nargs));
+		else if (funcDef.alias.equals(&quot;goto&quot;))
+			funcGoto(nargs);
+		else if (funcDef.alias.equals(&quot;ic&quot;))
+			funcIgnoreVariableCase(nargs);
+		else if (funcDef.alias.equals(&quot;instr&quot;))
+			calcStack.add(new Double(funcInstr(nargs)));
+		else if (funcDef.alias.equals(&quot;int&quot;))
+			calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
+		else if (funcDef.alias.equals(&quot;lc&quot;))
+			calcStack.add(popCalcStackAsString().toLowerCase());
+		else if (funcDef.alias.equals(&quot;len&quot;))
+			calcStack.add(new Double(popCalcStackAsString().length()));
+		else if (funcDef.alias.equals(&quot;mid&quot;))
+			calcStack.add(funcMid(nargs));
+		else if (funcDef.alias.equals(&quot;mod&quot;))
+			calcStack.add(funcMod());
+		else if (funcDef.alias.equals(&quot;project&quot;))
+			calcStack.add(funcProject());
+		else if (funcDef.alias.equals(&quot;pz&quot;))
+			funcPz(nargs);
+		else if (funcDef.alias.equals(&quot;rad&quot;))
+			funcDeg(false);
+		else if (funcDef.alias.equals(&quot;rad2deg&quot;))
+			calcStack.add(new java.lang.Double(funcRad2Deg()));
+		else if (funcDef.alias.equals(&quot;replace&quot;))
+			calcStack.add(funcReplace());
+		else if (funcDef.alias.equals(&quot;reverse&quot;))
+			calcStack.add(funcReverse(popCalcStackAsString()));
+		else if (funcDef.alias.equals(&quot;rot13&quot;))
+			calcStack.add(Common.rot13(popCalcStackAsString()));
+		// else if (funcDef.alias.equals(&quot;rs&quot;)) funcRequireSemicolon(nargs);
+		else if (funcDef.alias.equals(&quot;show&quot;))
+			;
+		else if (funcDef.alias.equals(&quot;sin&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;skeleton&quot;))
+			funcSkeleton(nargs);
+		else if (funcDef.alias.equals(&quot;sqrt&quot;))
+			calcStack.add(new java.lang.Double(funcSqrt()));
+		else if (funcDef.alias.equals(&quot;sval&quot;))
+			calcStack.add(funcSval(popCalcStackAsString()));
+		else if (funcDef.alias.equals(&quot;tan&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;uc&quot;))
+			calcStack.add(popCalcStackAsString().toUpperCase());
+		else if (funcDef.alias.equals(&quot;val&quot;))
+			calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
+		else if (funcDef.alias.equals(&quot;cb&quot;))
+			calcStack.add(funcCrossBearing());
+		else
+			err(MyLocale.getMsg(1728, &quot;Function not yet implemented: &quot;) + funcName);
 	}
 
-	public void parse(Vector tck, Vector msgStack){
+	public void parse(Vector tck, Vector msgStack) {
 		calcStack.clear();
 		clearLocalSymbols();
 		tokenStack = tck;
 		messageStack = msgStack;
 		scanpos = 0;
-		try{
+		try {
 			parseCommand();
-		}catch(Exception ex){
+		} catch (Exception ex) {
 		}
 	}
 
-	private boolean createWptIfNeeded(String wayPoint, String name, byte type){
-	   	int ci=Global.getProfile().getCacheIndex(wayPoint);
-    	if (ci &gt;= 0) return false;
+	private boolean createWptIfNeeded(String wayPoint, String name, byte type) {
+		int ci = Global.getProfile().getCacheIndex(wayPoint);
+		if (ci &gt;= 0)
+			return false;
 
 		CacheHolder ch = new CacheHolder();
 		ch.setWayPoint(wayPoint);

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/Profile.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -592,32 +592,29 @@
 		CacheHolder ch;
 		CWPoint topleft = null;
 		CWPoint bottomright = null;
-		CWPoint tmpca = new CWPoint();
 		numCachesInArea = 0;
 		boolean isAddi = false;
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
-				if (ch.pos == null) { // this can not happen
-					tmpca.set(ch.getLatLon());
-					ch.pos = new CWPoint(tmpca);
-				}
-				if (ch.pos.isValid()) { // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
+				if (ch.getPos().isValid()) { // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
 					isAddi = ch.isAddiWpt();
-					if (!isAddi || (isAddi &amp;&amp; ch.mainCache != null &amp;&amp; ch.pos.getDistance(ch.mainCache.pos) &lt; 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -&gt; ignore it //
-																														// &amp;&amp; ch.mainCache != null is only necessary because the data base may be corrupted
+					// test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -&gt;
+					// ignore it //
+					// &amp;&amp; ch.mainCache != null is only necessary because the data base may be corrupted
+					if (!isAddi || (isAddi &amp;&amp; ch.mainCache != null &amp;&amp; ch.getPos().getDistance(ch.mainCache.getPos()) &lt; 1000)) {
 						if (topleft == null)
-							topleft = new CWPoint(ch.pos);
+							topleft = new CWPoint(ch.getPos());
 						if (bottomright == null)
-							bottomright = new CWPoint(ch.pos);
-						if (topleft.latDec &lt; ch.pos.latDec)
-							topleft.latDec = ch.pos.latDec;
-						if (topleft.lonDec &gt; ch.pos.lonDec)
-							topleft.lonDec = ch.pos.lonDec;
-						if (bottomright.latDec &gt; ch.pos.latDec)
-							bottomright.latDec = ch.pos.latDec;
-						if (bottomright.lonDec &lt; ch.pos.lonDec)
-							bottomright.lonDec = ch.pos.lonDec;
+							bottomright = new CWPoint(ch.getPos());
+						if (topleft.latDec &lt; ch.getPos().latDec)
+							topleft.latDec = ch.getPos().latDec;
+						if (topleft.lonDec &gt; ch.getPos().lonDec)
+							topleft.lonDec = ch.getPos().lonDec;
+						if (bottomright.latDec &gt; ch.getPos().latDec)
+							bottomright.latDec = ch.getPos().latDec;
+						if (bottomright.lonDec &lt; ch.getPos().lonDec)
+							bottomright.lonDec = ch.getPos().lonDec;
 						numCachesInArea++;
 					}
 				}

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/RadarPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -139,7 +139,7 @@
 		final double pi180 = java.lang.Math.PI / 180.0;
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			holder = cacheDB.get(i);
-			if (holder.isVisible() &amp;&amp; holder.pos.isValid()) {
+			if (holder.isVisible() &amp;&amp; holder.getPos().isValid()) {
 				degrees = holder.degrees * pi180;
 				drX = new Float(holder.kilom / scale * java.lang.Math.sin(degrees)).intValue();
 				drY = -new Float(holder.kilom / scale * java.lang.Math.cos(degrees)).intValue();

Modified: trunk/src/CacheWolf/exp/DistanceComparer.java
===================================================================
--- trunk/src/CacheWolf/exp/DistanceComparer.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/DistanceComparer.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -30,21 +30,21 @@
 import ewe.util.Comparer;
 
 public class DistanceComparer implements Comparer {
-	
+
 	CWPoint centre;
-	
+
 	public DistanceComparer(CWPoint centre) {
 		this.centre = centre;
 	}
 
 	public int compare(Object one, Object two) {
-		if ((! (one instanceof CacheHolder)) &amp;&amp; (!(two instanceof CacheHolder))) {
+		if ((!(one instanceof CacheHolder)) &amp;&amp; (!(two instanceof CacheHolder))) {
 			return 0;
 		} else {
 			CacheHolder a = (CacheHolder) one;
 			CacheHolder b = (CacheHolder) two;
-			return (int) ((a.pos.getDistance(centre) - b.pos.getDistance(centre)) * 1000);
+			return (int) ((a.getPos().getDistance(centre) - b.getPos().getDistance(centre)) * 1000);
 		}
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/exp/ExploristExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/ExploristExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/ExploristExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -95,19 +95,19 @@
 	public void doIt() {
 		File configFile = new File(&quot;magellan.cfg&quot;);
 		if (configFile.exists()) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName+&quot;Dir&quot;));
+			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName + &quot;Dir&quot;));
 			fc.setTitle(MyLocale.getMsg(2104, &quot;Choose directory for exporting .gs files&quot;));
 			String targetDir;
-			if(fc.execute() != FormBase.IDCANCEL){
+			if (fc.execute() != FormBase.IDCANCEL) {
 				targetDir = fc.getChosen() + &quot;/&quot;;
-				pref.setExportPath(expName+&quot;Dir&quot;, targetDir);
+				pref.setExportPath(expName + &quot;Dir&quot;, targetDir);
 
 				CWPoint centre = profile.centre;
 				try {
 					LineNumberReader reader = new LineNumberReader(new BufferedReader(new FileReader(configFile)));
 					String line, fileName, coordinate;
-					while ((line = reader.readLine()) != null)  {
-						StringTokenizer tokenizer = new StringTokenizer(line,&quot;=&quot;);
+					while ((line = reader.readLine()) != null) {
+						StringTokenizer tokenizer = new StringTokenizer(line, &quot;=&quot;);
 						fileName = targetDir + tokenizer.nextToken().trim() + &quot;.gs&quot;;
 						coordinate = tokenizer.nextToken().trim();
 						CWPoint point = new CWPoint(coordinate);
@@ -117,17 +117,16 @@
 					}
 					reader.close();
 				} catch (FileNotFoundException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;),MyLocale.getMsg(2101, &quot;Failure at loading magellan.cfg\n&quot; + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;), MyLocale.getMsg(2101, &quot;Failure at loading magellan.cfg\n&quot; + e.getMessage()));
 					info.show();
 				} catch (IOException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;),MyLocale.getMsg(2103, &quot;Failure at reading magellan.cfg\n&quot; + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;), MyLocale.getMsg(2103, &quot;Failure at reading magellan.cfg\n&quot; + e.getMessage()));
 					info.show();
 				} finally {
-					cacheDB.sort(new DistanceComparer(centre),false);
+					cacheDB.sort(new DistanceComparer(centre), false);
 				}
 			}
-		}
-		else {
+		} else {
 			doIt(null);
 		}
 	}
@@ -164,18 +163,14 @@
 
 		try {
 			// Set initial value for outp to calm down compiler
-			PrintWriter outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + &quot;.gs&quot;))));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + &quot;.gs&quot;))));
 			for (int i = 0; i &lt; cacheDB.size(); i++) {
 				ch = cacheDB.get(i);
 				if (ch.isVisible()) {
 					// all 200 caches we need a new file
 					if (expCount % 200 == 0 &amp;&amp; expCount &gt; 0) {
 						outp.close();
-						outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + &quot;.gs&quot;))));
+						outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + &quot;.gs&quot;))));
 					}
 
 					expCount++;
@@ -195,20 +190,19 @@
 			outp.close();
 			pbf.exit(0);
 		} catch (IOException ioE) {
-			pref.log(&quot;Error opening &quot; + outFile.getName(),ioE);
+			pref.log(&quot;Error opening &quot; + outFile.getName(), ioE);
 		}
 		// try
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
-	 *
+	 * 
 	 * @return
 	 */
 	public File getOutputFile() {
 		File file;
-		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref
-				.getExportPath(expName));
+		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle(MyLocale.getMsg(2102, &quot;Select target file:&quot;));
 		fc.addMask(mask);
 		if (fc.execute() != FormBase.IDCANCEL) {
@@ -222,7 +216,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @param ch
 	 *            cachedata
 	 * @return formated cache data
@@ -230,21 +224,21 @@
 	public String record(CacheHolder ch) {
 		CacheHolderDetail det = ch.getCacheDetails(true);
 		/*
-		static protected final int GC_AW_PARKING = 50;
-		static protected final int GC_AW_STAGE_OF_MULTI = 51;
-		static protected final int GC_AW_QUESTION = 52;
-		static protected final int GC_AW_FINAL = 53;
-		static protected final int GC_AW_TRAILHEAD = 54;
-		static protected final int GC_AW_REFERENCE = 55;
-		*/
+		 * static protected final int GC_AW_PARKING = 50;
+		 * static protected final int GC_AW_STAGE_OF_MULTI = 51;
+		 * static protected final int GC_AW_QUESTION = 52;
+		 * static protected final int GC_AW_FINAL = 53;
+		 * static protected final int GC_AW_TRAILHEAD = 54;
+		 * static protected final int GC_AW_REFERENCE = 55;
+		 */
 		StringBuffer sb = new StringBuffer();
 		sb.append(&quot;$PMGNGEO,&quot;);
-		sb.append(ch.pos.getLatDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLatMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLatDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLatMin(CWPoint.DMM));
 		sb.append(&quot;,&quot;);
 		sb.append(&quot;N,&quot;);
-		sb.append(ch.pos.getLonDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLonMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLonDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLonMin(CWPoint.DMM));
 		sb.append(&quot;,&quot;);
 		sb.append(&quot;E,&quot;);
 		sb.append(&quot;0000,&quot;); // Height
@@ -281,11 +275,11 @@
 			sb.append(CacheType.type2GSTypeTag(ch.getType()));
 		}
 		sb.append(&quot;,&quot;);
-		sb.append(toGsDateFormat(ch.getDateHidden()));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(toGsDateFormat(ch.getDateHidden())); // created - DDMMYYY, YYY = year - 1900
 		sb.append(&quot;,&quot;);
 		String lastFound = &quot;0000&quot;;
 		for (int i = 0; i &lt; det.CacheLogs.size(); i++) {
-			if (det.CacheLogs.getLog(i).isFoundLog() &amp;&amp; det.CacheLogs.getLog(i).getDate().compareTo(lastFound) &gt; 0 ) {
+			if (det.CacheLogs.getLog(i).isFoundLog() &amp;&amp; det.CacheLogs.getLog(i).getDate().compareTo(lastFound) &gt; 0) {
 				lastFound = det.CacheLogs.getLog(i).getDate();
 			}
 		}
@@ -301,7 +295,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @return formated trailer data
 	 */
 	public String trailer() {
@@ -310,6 +304,7 @@
 
 	/**
 	 * Changes &quot;,&quot; in &quot;.&quot; in the input String
+	 * 
 	 * @param input
 	 * @return changed String
 	 */
@@ -319,14 +314,15 @@
 
 	/**
 	 * change the Dateformat from &quot;yyyy-mm-dd&quot; to ddmmyyy, where yyy is years after 1900
-	 * @param input Date in yyyy-mm-dd
- 	 * @return Date in ddmmyyy
+	 * 
+	 * @param input
+	 *            Date in yyyy-mm-dd
+	 * @return Date in ddmmyyy
 	 */
 	private String toGsDateFormat(String input) {
 		if (input.length() &gt;= 10) {
 			return input.substring(8, 10) + input.substring(5, 7) + &quot;1&quot; + input.substring(2, 4);
-		}
-		else {
+		} else {
 			return &quot;&quot;;
 		}
 	}

Modified: trunk/src/CacheWolf/exp/Exporter.java
===================================================================
--- trunk/src/CacheWolf/exp/Exporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/Exporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -48,11 +48,11 @@
 
 /**
  * @author Kalle
- * Base class for exporter, handles basic things like selecting
- * outputfile, display a counter etc.
- * A new Exporter must only override the header(), record() and 
- * trailer() methods. The member howManyParams must be set to identify
- * which ethod should be called  
+ *         Base class for exporter, handles basic things like selecting
+ *         outputfile, display a counter etc.
+ *         A new Exporter must only override the header(), record() and
+ *         trailer() methods. The member howManyParams must be set to identify
+ *         which ethod should be called
  */
 
 public class Exporter {
@@ -60,12 +60,12 @@
 	final static int TMP_FILE = 0;
 	// brings up a screen to select a file
 	final static int ASK_FILE = 1;
-	
+
 	// selection, which method should be called
-	final static int NO_PARAMS 	= 0;
-	final static int LAT_LON 	= 1;
-	final static int COUNT 		= 2;
-	
+	final static int NO_PARAMS = 0;
+	final static int LAT_LON = 1;
+	final static int COUNT = 2;
+
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
@@ -74,97 +74,100 @@
 	// file name, if no file chooser is used
 	String tmpFileName;
 	// decimal separator for lat- and lon-String
-	char decimalSeparator='.';
-	// if  true, the complete cache details are read
-	// before a call to the record method is made 
+	char decimalSeparator = '.';
+	// if true, the complete cache details are read
+	// before a call to the record method is made
 	boolean needCacheDetails = false;
 	// selection, which method should be called
 	int howManyParams = 0;
-	
-	//name of exporter for saving pathname
+
+	// name of exporter for saving pathname
 	String expName;
-	
+
 	public Exporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 		howManyParams = LAT_LON;
-		expName = this.getClass().getName(); 
+		expName = this.getClass().getName();
 		// remove package
 		expName = expName.substring(expName.indexOf(&quot;.&quot;) + 1);
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		this.doIt(ASK_FILE);
 	}
 
 	/**
 	 * Does the most work for exporting data
-	 * @param variant 0, if no filechooser
-	 *                1, if filechooser
+	 * 
+	 * @param variant
+	 *            0, if no filechooser
+	 *            1, if filechooser
 	 */
-	public void doIt(int variant){
+	public void doIt(int variant) {
 		File outFile;
 		String str;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
-
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
-			if (outFile == null) return;
+			if (outFile == null)
+				return;
 		} else {
 			outFile = new File(tmpFileName);
 		}
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.setTask(h, &quot;Exporting ...&quot;);
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			int incompleteWaypoints = 0;
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
 			str = this.header();
-			if (str != null) outp.print(str);
-			for(int i = 0; i&lt;cacheDB.size(); i++){
-				ch=cacheDB.get(i);
-				if(ch.isVisible()){
+			if (str != null)
+				outp.print(str);
+			for (int i = 0; i &lt; cacheDB.size(); i++) {
+				ch = cacheDB.get(i);
+				if (ch.isVisible()) {
 					if (ch.is_incomplete()) {
-						Global.getPref().log(&quot;skipping export of incomplete waypoint &quot;+ch.getWayPoint());
+						Global.getPref().log(&quot;skipping export of incomplete waypoint &quot; + ch.getWayPoint());
 						incompleteWaypoints++;
 						continue;
 					}
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
 					switch (this.howManyParams) {
 					case NO_PARAMS:
 						str = record(ch);
 						break;
 					case LAT_LON:
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
-					case LAT_LON|COUNT: 
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-									 ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											 i);
+					case LAT_LON | COUNT:
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator), i);
 						break;
 					default:
 						str = null;
 						break;
 					}
-					if (str != null) outp.print(str);
-				}//if
-			}//for
+					if (str != null)
+						outp.print(str);
+				}// if
+			}// for
 			switch (this.howManyParams &amp; COUNT) {
-			case NO_PARAMS: 
+			case NO_PARAMS:
 				str = trailer();
 				break;
 			case COUNT:
@@ -174,64 +177,75 @@
 				str = null;
 				break;
 			}
-			if (str != null) outp.print(str);
+			if (str != null)
+				outp.print(str);
 			outp.close();
 			pbf.exit(0);
 			if (incompleteWaypoints &gt; 0) {
-				new MessageBox(&quot;Export Error&quot;, incompleteWaypoints+&quot; incomplete waypoints have not been exported. See log for details.&quot;, FormBase.OKB).execute();
+				new MessageBox(&quot;Export Error&quot;, incompleteWaypoints + &quot; incomplete waypoints have not been exported. See log for details.&quot;, FormBase.OKB).execute();
 			}
-		} catch (IOException ioE){
-			pref.log(&quot;Error opening &quot; + outFile.getName(),ioE);
+		} catch (IOException ioE) {
+			pref.log(&quot;Error opening &quot; + outFile.getName(), ioE);
 		}
-		//try
+		// try
 	}
+
 	/**
 	 * sets mask for filechooser
-	 * @param mask 
+	 * 
+	 * @param mask
 	 */
-	public void setMask(String mask){
+	public void setMask(String mask) {
 		this.mask = mask;
 	}
+
 	/**
 	 * sets decimal separator for lat/lon-string
+	 * 
 	 * @param sep
 	 */
-	public void setDecimalSeparator (char sep){
+	public void setDecimalSeparator(char sep) {
 		this.decimalSeparator = sep;
 	}
+
 	/**
-	 *  sets needCacheDetails
+	 * sets needCacheDetails
+	 * 
 	 * @param how
 	 */
-	public void setNeedCacheDetails(boolean how){
+	public void setNeedCacheDetails(boolean how) {
 		this.needCacheDetails = how;
 	}
-	
+
 	/**
 	 * sets howManyParams
+	 * 
 	 * @param paramBits
 	 */
-	public void setHowManyParams(int paramBits){
+	public void setHowManyParams(int paramBits) {
 		this.howManyParams = paramBits;
 	}
+
 	/**
 	 * sets tmpFileName
+	 * 
 	 * @param fName
 	 */
-	public void setTmpFileName(String fName){
+	public void setTmpFileName(String fName) {
 		this.tmpFileName = fName;
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
+	 * 
 	 * @return
 	 */
-	public File getOutputFile (){
+	public File getOutputFile() {
 		File file;
 		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle(&quot;Select target file:&quot;);
 		fc.addMask(mask);
-		if(fc.execute() != FormBase.IDCANCEL){
+		if (fc.execute() != FormBase.IDCANCEL) {
 			file = fc.getChosenFile();
 			pref.setExportPath(expName, file.getPath());
 			return file;
@@ -239,226 +253,145 @@
 			return null;
 		}
 	}
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated header data
-	 */	
-	public String header () {
+	 */
+	public String header() {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
+	 * 
+	 * @param ch
+	 *            cachedata
 	 * @return formated cache data
-	 */	
-	public String record(CacheHolder chD){
+	 */
+	public String record(CacheHolder chD) {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon){
+	public String record(CacheHolder ch, String lat, String lon) {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
-	 * @param count of actual record
+	 * @param count
+	 *            of actual record
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon, int count){
+	public String record(CacheHolder ch, String lat, String lon, int count) {
 		return null;
 	}
-	
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated trailer data
-	 */	
-	public String trailer(){
+	 */
+	public String trailer() {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param total count of exported caches
+	 * 
+	 * @param total
+	 *            count of exported caches
 	 * @return
 	 */
-	public String trailer(int total){
+	public String trailer(int total) {
 		return null;
 	}
 
-///////////////////////////////////////////////////
-//  Helper functions for string sanitisation
-///////////////////////////////////////////////////
-	
+	// /////////////////////////////////////////////////
+	// Helper functions for string sanitisation
+	// /////////////////////////////////////////////////
+
 	private static Hashtable iso2simpleMappings = new Hashtable(250);
 	static {
-		String[] mappingArray = new String[] {
-				&quot;34&quot;,  &quot;'&quot;,
-				&quot;160&quot;, &quot; &quot;,
-				&quot;161&quot;, &quot;i&quot;,
-				&quot;162&quot;, &quot;c&quot;,
-				&quot;163&quot;, &quot;$&quot;,
-				&quot;164&quot;, &quot;o&quot;,
-				&quot;165&quot;, &quot;$&quot;,
-				&quot;166&quot;, &quot;!&quot;,
-				&quot;167&quot;, &quot;$&quot;,
-				&quot;168&quot;, &quot; &quot;,
-				&quot;169&quot;, &quot; &quot;,
-				&quot;170&quot;, &quot; &quot;,
-				&quot;171&quot;, &quot;&lt;&quot;,
-				&quot;172&quot;, &quot; &quot;,
-				&quot;173&quot;, &quot;-&quot;,
-				&quot;174&quot;, &quot; &quot;,
-				&quot;175&quot;, &quot;-&quot;,
-				&quot;176&quot;, &quot; &quot;,
-				&quot;177&quot;, &quot;+/-&quot;,
-				&quot;178&quot;, &quot;2&quot;,
-				&quot;179&quot;, &quot;3&quot;,
-				&quot;180&quot;, &quot;'&quot;,
-				&quot;181&quot;, &quot; &quot;,
-				&quot;182&quot;, &quot; &quot;,
-				&quot;183&quot;, &quot; &quot;,
-				&quot;184&quot;, &quot;,&quot;,
-				&quot;185&quot;, &quot;1&quot;,
-				&quot;186&quot;, &quot; &quot;,
-				&quot;187&quot;, &quot;&gt;&quot;,
-				&quot;188&quot;, &quot;1/4&quot;,
-				&quot;189&quot;, &quot;1/2&quot;,
-				&quot;190&quot;, &quot;3/4&quot;,
-				&quot;191&quot;, &quot;?&quot;,
-				&quot;192&quot;, &quot;A&quot;,
-				&quot;193&quot;, &quot;A&quot;,
-				&quot;194&quot;, &quot;A&quot;,
-				&quot;195&quot;, &quot;A&quot;,
-				&quot;196&quot;, &quot;Ae&quot;,
-				&quot;197&quot;, &quot;A&quot;,
-				&quot;198&quot;, &quot;AE&quot;,
-				&quot;199&quot;, &quot;C&quot;,
-				&quot;200&quot;, &quot;E&quot;,
-				&quot;201&quot;, &quot;E&quot;,
-				&quot;202&quot;, &quot;E&quot;,
-				&quot;203&quot;, &quot;E&quot;,
-				&quot;204&quot;, &quot;I&quot;,
-				&quot;205&quot;, &quot;I&quot;,
-				&quot;206&quot;, &quot;I&quot;,
-				&quot;207&quot;, &quot;I&quot;,
-				&quot;208&quot;, &quot;D&quot;,
-				&quot;209&quot;, &quot;N&quot;,
-				&quot;210&quot;, &quot;O&quot;,
-				&quot;211&quot;, &quot;O&quot;,
-				&quot;212&quot;, &quot;O&quot;,
-				&quot;213&quot;, &quot;O&quot;,
-				&quot;214&quot;, &quot;Oe&quot;,
-				&quot;215&quot;, &quot;x&quot;,
-				&quot;216&quot;, &quot;O&quot;,
-				&quot;217&quot;, &quot;U&quot;,
-				&quot;218&quot;, &quot;U&quot;,
-				&quot;219&quot;, &quot;U&quot;,
-				&quot;220&quot;, &quot;Ue&quot;,
-				&quot;221&quot;, &quot;Y&quot;,
-				&quot;222&quot;, &quot; &quot;,
-				&quot;223&quot;, &quot;ss&quot;,
-				&quot;224&quot;, &quot;a&quot;,
-				&quot;225&quot;, &quot;a&quot;,
-				&quot;226&quot;, &quot;a&quot;,
-				&quot;227&quot;, &quot;a&quot;,
-				&quot;228&quot;, &quot;ae&quot;,
-				&quot;229&quot;, &quot;a&quot;,
-				&quot;230&quot;, &quot;ae&quot;,
-				&quot;231&quot;, &quot;c&quot;,
-				&quot;232&quot;, &quot;e&quot;,
-				&quot;233&quot;, &quot;e&quot;,
-				&quot;234&quot;, &quot;e&quot;,
-				&quot;235&quot;, &quot;e&quot;,
-				&quot;236&quot;, &quot;i&quot;,
-				&quot;237&quot;, &quot;i&quot;,
-				&quot;238&quot;, &quot;i&quot;,
-				&quot;239&quot;, &quot;i&quot;,
-				&quot;240&quot;, &quot;o&quot;,
-				&quot;241&quot;, &quot;n&quot;,
-				&quot;242&quot;, &quot;o&quot;,
-				&quot;243&quot;, &quot;o&quot;,
-				&quot;244&quot;, &quot;o&quot;,
-				&quot;245&quot;, &quot;o&quot;,
-				&quot;246&quot;, &quot;oe&quot;,
-				&quot;247&quot;, &quot;/&quot;,
-				&quot;248&quot;, &quot;o&quot;,
-				&quot;249&quot;, &quot;u&quot;,
-				&quot;250&quot;, &quot;u&quot;,
-				&quot;251&quot;, &quot;u&quot;,
-				&quot;252&quot;, &quot;ue&quot;,
-				&quot;253&quot;, &quot;y&quot;,
-				&quot;254&quot;, &quot;p&quot;,
-				&quot;255&quot;, &quot;y&quot;
-		};
+		String[] mappingArray = new String[] { &quot;34&quot;, &quot;'&quot;, &quot;160&quot;, &quot; &quot;, &quot;161&quot;, &quot;i&quot;, &quot;162&quot;, &quot;c&quot;, &quot;163&quot;, &quot;$&quot;, &quot;164&quot;, &quot;o&quot;, &quot;165&quot;, &quot;$&quot;, &quot;166&quot;, &quot;!&quot;, &quot;167&quot;, &quot;$&quot;, &quot;168&quot;, &quot; &quot;, &quot;169&quot;, &quot; &quot;, &quot;170&quot;, &quot; &quot;, &quot;171&quot;, &quot;&lt;&quot;, &quot;172&quot;, &quot; &quot;, &quot;173&quot;, &quot;-&quot;, &quot;174&quot;, &quot; &quot;, &quot;175&quot;, &quot;-&quot;,
+				&quot;176&quot;, &quot; &quot;, &quot;177&quot;, &quot;+/-&quot;, &quot;178&quot;, &quot;2&quot;, &quot;179&quot;, &quot;3&quot;, &quot;180&quot;, &quot;'&quot;, &quot;181&quot;, &quot; &quot;, &quot;182&quot;, &quot; &quot;, &quot;183&quot;, &quot; &quot;, &quot;184&quot;, &quot;,&quot;, &quot;185&quot;, &quot;1&quot;, &quot;186&quot;, &quot; &quot;, &quot;187&quot;, &quot;&gt;&quot;, &quot;188&quot;, &quot;1/4&quot;, &quot;189&quot;, &quot;1/2&quot;, &quot;190&quot;, &quot;3/4&quot;, &quot;191&quot;, &quot;?&quot;, &quot;192&quot;, &quot;A&quot;, &quot;193&quot;, &quot;A&quot;, &quot;194&quot;, &quot;A&quot;,
+				&quot;195&quot;, &quot;A&quot;, &quot;196&quot;, &quot;Ae&quot;, &quot;197&quot;, &quot;A&quot;, &quot;198&quot;, &quot;AE&quot;, &quot;199&quot;, &quot;C&quot;, &quot;200&quot;, &quot;E&quot;, &quot;201&quot;, &quot;E&quot;, &quot;202&quot;, &quot;E&quot;, &quot;203&quot;, &quot;E&quot;, &quot;204&quot;, &quot;I&quot;, &quot;205&quot;, &quot;I&quot;, &quot;206&quot;, &quot;I&quot;, &quot;207&quot;, &quot;I&quot;, &quot;208&quot;, &quot;D&quot;, &quot;209&quot;, &quot;N&quot;, &quot;210&quot;, &quot;O&quot;, &quot;211&quot;, &quot;O&quot;, &quot;212&quot;, &quot;O&quot;, &quot;213&quot;, &quot;O&quot;, &quot;214&quot;,
+				&quot;Oe&quot;, &quot;215&quot;, &quot;x&quot;, &quot;216&quot;, &quot;O&quot;, &quot;217&quot;, &quot;U&quot;, &quot;218&quot;, &quot;U&quot;, &quot;219&quot;, &quot;U&quot;, &quot;220&quot;, &quot;Ue&quot;, &quot;221&quot;, &quot;Y&quot;, &quot;222&quot;, &quot; &quot;, &quot;223&quot;, &quot;ss&quot;, &quot;224&quot;, &quot;a&quot;, &quot;225&quot;, &quot;a&quot;, &quot;226&quot;, &quot;a&quot;, &quot;227&quot;, &quot;a&quot;, &quot;228&quot;, &quot;ae&quot;, &quot;229&quot;, &quot;a&quot;, &quot;230&quot;, &quot;ae&quot;, &quot;231&quot;, &quot;c&quot;, &quot;232&quot;, &quot;e&quot;, &quot;233&quot;, &quot;e&quot;,
+				&quot;234&quot;, &quot;e&quot;, &quot;235&quot;, &quot;e&quot;, &quot;236&quot;, &quot;i&quot;, &quot;237&quot;, &quot;i&quot;, &quot;238&quot;, &quot;i&quot;, &quot;239&quot;, &quot;i&quot;, &quot;240&quot;, &quot;o&quot;, &quot;241&quot;, &quot;n&quot;, &quot;242&quot;, &quot;o&quot;, &quot;243&quot;, &quot;o&quot;, &quot;244&quot;, &quot;o&quot;, &quot;245&quot;, &quot;o&quot;, &quot;246&quot;, &quot;oe&quot;, &quot;247&quot;, &quot;/&quot;, &quot;248&quot;, &quot;o&quot;, &quot;249&quot;, &quot;u&quot;, &quot;250&quot;, &quot;u&quot;, &quot;251&quot;, &quot;u&quot;, &quot;252&quot;, &quot;ue&quot;, &quot;253&quot;,
+				&quot;y&quot;, &quot;254&quot;, &quot;p&quot;, &quot;255&quot;, &quot;y&quot; };
 		for (int i = 0; i &lt; mappingArray.length; i = i + 2) {
-			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
+			iso2simpleMappings.put(Integer.valueOf(mappingArray[i]), mappingArray[i + 1]);
 		}
 	}
 
-	
-	protected static String char2simpleChar( char c )
-    {
-        if ( c &lt; 127 ) {
-            // leave alone as equivalent string.
-            return null;
-        } else {
-            String s=(String) iso2simpleMappings.get( new Integer(c));
-            if (s==null) // not in table, replace with empty string just to be sure
-            	return &quot;&quot;;
-            else
-            	return s;
-        }
-    } // end charToEntity
-	
-    public static String simplifyString( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( 50 );
-        int charsToAppend = 0;
-        for ( int i = 0; i &lt; originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = char2simpleChar( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
+	protected static String char2simpleChar(char c) {
+		if (c &lt; 127) {
+			// leave alone as equivalent string.
+			return null;
+		} else {
+			String s = (String) iso2simpleMappings.get(new Integer(c));
+			if (s == null) // not in table, replace with empty string just to be sure
+				return &quot;&quot;;
+			else
+				return s;
+		}
+	} // end charToEntity
 
-    public static String getShortDetails( CacheHolder ch ) {
-    	StringBuffer strBuf = new StringBuffer(7);
-    	strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());			
-    	if (!ch.isAddiWpt()) {
-   			strBuf.append(ch.getHard());
-   			strBuf.append(&quot;/&quot;);
-   			strBuf.append(ch.getTerrain());
-    		strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
-    	}
+	public static String simplifyString(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(50);
+		int charsToAppend = 0;
+		for (int i = 0; i &lt; originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = char2simpleChar(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
-    	return strBuf.toString();
-    }
+	public static String getShortDetails(CacheHolder ch) {
+		StringBuffer strBuf = new StringBuffer(7);
+		strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());
+		if (!ch.isAddiWpt()) {
+			strBuf.append(ch.getHard());
+			strBuf.append(&quot;/&quot;);
+			strBuf.append(ch.getTerrain());
+			strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
+		}
 
+		return strBuf.toString();
+	}
+
 }

Modified: trunk/src/CacheWolf/exp/GpxExportNg.java
===================================================================
--- trunk/src/CacheWolf/exp/GpxExportNg.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/GpxExportNg.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -528,7 +528,7 @@
 		if ((STYLE_GPX_MYFINDS == exportStyle) &amp;&amp; (ch.isCustomWpt() || ch.isAddiWpt() || !ch.is_found()))
 			return &quot;&quot;;
 
-		if (!ch.pos.isValid()) {
+		if (!ch.getPos().isValid()) {
 			Global.getPref().log(&quot;[GPX Export:formatCache] &quot; + ch.getWayPoint() + &quot; has invalid coords.&quot;);
 			return &quot;&quot;;
 		}
@@ -569,7 +569,7 @@
 
 		// .append(&quot;\t\t&lt;desc&gt;@@WPDESC@@&lt;/desc&gt;&quot;).append(newLine)
 
-		ret.append(&quot;  &lt;wpt lat=\&quot;&quot; + ch.pos.getLatDeg(CWPoint.DD) + &quot;\&quot; lon=\&quot;&quot; + ch.pos.getLonDeg(CWPoint.DD) + &quot;\&quot;&gt;&quot;).append(newLine);
+		ret.append(&quot;  &lt;wpt lat=\&quot;&quot; + ch.getPos().getLatDeg(CWPoint.DD) + &quot;\&quot; lon=\&quot;&quot; + ch.getPos().getLonDeg(CWPoint.DD) + &quot;\&quot;&gt;&quot;).append(newLine);
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
 			if (ch.isAddiWpt()) {
@@ -841,12 +841,12 @@
 		}
 		return trans.replaceFirst(GPXHEADER);
 		/*
-		String ret = STRreplace.replace(GPXHEADER,&quot;@@CREATEDATE@@&quot;, new Date().setToCurrentTime().setFormat(&quot;yyyy-MM-dd&quot;).toString());
-		if (exportStyle==STYLE_GPX_MYFINDS)
-			 { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;My Finds Pocket Query&quot;);}
-		else { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;);}
-		return ret;
-		*/
+		 * String ret = STRreplace.replace(GPXHEADER,&quot;@@CREATEDATE@@&quot;, new Date().setToCurrentTime().setFormat(&quot;yyyy-MM-dd&quot;).toString());
+		 * if (exportStyle==STYLE_GPX_MYFINDS)
+		 * { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;My Finds Pocket Query&quot;);}
+		 * else { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;);}
+		 * return ret;
+		 */
 	}
 
 	/**
@@ -884,7 +884,7 @@
 					trans.add(new Regex(&quot;@@ADDIID@@&quot;, addi.getWayPoint()));
 					trans.add(new Regex(&quot;@@ADDISHORT@@&quot;, addi.getCacheName()));
 					trans.add(new Regex(&quot;@@ADDIDELIM@@&quot;, delim));
-					trans.add(new Regex(&quot;@@ADDILAT@@&quot;, formatAddiLatLon(addi.pos)));
+					trans.add(new Regex(&quot;@@ADDILAT@@&quot;, formatAddiLatLon(addi.getPos())));
 					trans.add(new Regex(&quot;@@ADDILON@@&quot;, &quot;&quot;));
 					trans.add(new Regex(&quot;@@ADDILONG@@&quot;, addi.getCacheDetails(true).LongDescription));
 					ret.append(trans.replaceAll(GPXADDIINMAIN));
@@ -911,8 +911,7 @@
 	}
 
 	/**
-	 * copy the bitmap identified by &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; from &lt;code&gt;poiZip&lt;/code&gt; to
-	 * &lt;code&gt;outdir&lt;/code&gt;
+	 * copy the bitmap identified by &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; from &lt;code&gt;poiZip&lt;/code&gt; to &lt;code&gt;outdir&lt;/code&gt;
 	 * 
 	 * @param outdir
 	 * @param type

Modified: trunk/src/CacheWolf/exp/KMLExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/KMLExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/KMLExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -134,8 +134,8 @@
 						h.progress = (float) expCount / (float) counter;
 						h.changed();
 
-						if (ch.pos.isValid()) {
-							str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.getPos().isValid()) {
+							str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 							if (str != null)
 								outp.print(str);
 						}
@@ -144,12 +144,12 @@
 							for (int j = 0; j &lt; ch.addiWpts.size(); j++) {
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
 								expCount++;
-								if (ch.pos.isValid() &amp;&amp; addiWpt.isVisible()) {
+								if (ch.getPos().isValid() &amp;&amp; addiWpt.isVisible()) {
 									if (!createdAdditionalWaypointsFolder) {
 										outp.print(startFolder(&quot;Additional Waypoints&quot;, false));
 										createdAdditionalWaypointsFolder = true;
 									}
-									str = record(addiWpt, addiWpt.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), addiWpt.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+									str = record(addiWpt, addiWpt.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), addiWpt.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 									if (str != null)
 										outp.print(str);
 								}

Modified: trunk/src/CacheWolf/exp/LocExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/LocExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/LocExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,102 +1,106 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CWPoint;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheHolderDetail;
 import CacheWolf.Common;
 import CacheWolf.Global;
 
-
 /**
-*	Class to export the cache database into an geocaching .loc file that may be exported
-*	by GPSBabel to a Garmin GPS.
-*
-*	Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
-*/
-public class LocExporter extends Exporter{
+ * Class to export the cache database into an geocaching .loc file that may be exported
+ * by GPSBabel to a Garmin GPS.
+ * 
+ * Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
+ */
+public class LocExporter extends Exporter {
 	public static int MODE_AUTO = TMP_FILE;
 	/**
 	 * Defines how certain cachetypes are mapped to user icons
 	 */
-	private static GarminMap gm=null;
+	private static GarminMap gm = null;
 
-	public LocExporter(){
+	public LocExporter() {
 		super();
 		this.setMask(&quot;*.loc&quot;);
 		this.setHowManyParams(NO_PARAMS);
 		if (Global.getPref().addDetailsToName) {
 			this.setNeedCacheDetails(true);
 		}
-		gm=new GarminMap();
+		gm = new GarminMap();
 	}
 
-	public String header () {
+	public String header() {
 		return &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;loc version=\&quot;1.0\&quot; src=\&quot;EasyGPS\&quot;&gt;\r\n&quot;;
 	}
 
-	public String record(CacheHolder ch){
+	public String record(CacheHolder ch) {
 
 		// filter out not valid coords
-		if (!ch.pos.isValid()) return null;
+		if (!ch.getPos().isValid())
+			return null;
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append(&quot;&lt;waypoint&gt;\r\n   &lt;name id=\&quot;&quot;);
-		String wptName=simplifyString(ch.getWayPoint());
+		String wptName = simplifyString(ch.getWayPoint());
 		if (Global.getPref().addDetailsToWaypoint) {
-			wptName += getShortDetails( ch );
+			wptName += getShortDetails(ch);
 		}
-		if (Global.getPref().garminMaxLen==0)
+		if (Global.getPref().garminMaxLen == 0)
 			strBuf.append(wptName);
 		else {
 			try {
-				strBuf.append(wptName.substring(wptName.length()-Global.getPref().garminMaxLen));
-			} catch (Exception ex){ pref.log(&quot;[LocExporter:record]Invalid value for garmin.MaxWaypointLength&quot;,ex); }
+				strBuf.append(wptName.substring(wptName.length() - Global.getPref().garminMaxLen));
+			} catch (Exception ex) {
+				pref.log(&quot;[LocExporter:record]Invalid value for garmin.MaxWaypointLength&quot;, ex);
+			}
 		}
 		strBuf.append(&quot;\&quot;&gt;&lt;![CDATA[&quot;);
 		strBuf.append(simplifyString(ch.getCacheName()));
 		if (Global.getPref().addDetailsToName) {
-			if ( !Global.getPref().addDetailsToWaypoint ) {
-				strBuf.append( getShortDetails( ch ) );
+			if (!Global.getPref().addDetailsToWaypoint) {
+				strBuf.append(getShortDetails(ch));
 			}
 			CacheHolderDetail det = ch.getCacheDetails(true);
-			if ( (!det.Hints.equals(&quot;null&quot;)) &amp;&amp; (det.Hints.length() &gt; 0) ) {
+			if ((!det.Hints.equals(&quot;null&quot;)) &amp;&amp; (det.Hints.length() &gt; 0)) {
 				strBuf.append(&quot;:&quot;);
-				strBuf.append( simplifyString(Common.rot13(det.Hints)) );
+				strBuf.append(simplifyString(Common.rot13(det.Hints)));
 			}
 		}
 		strBuf.append(&quot;]]&gt;&lt;/name&gt;\r\n   &lt;coord lat=\&quot;&quot;);
-		strBuf.append(ch.pos.getLatDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLatDeg(CWPoint.DD));
 		strBuf.append(&quot;\&quot; lon=\&quot;&quot;);
-		strBuf.append(ch.pos.getLonDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLonDeg(CWPoint.DD));
 		strBuf.append(&quot;\&quot;/&gt;\r\n   &lt;type&gt;&quot;);
 		strBuf.append(gm.getIcon(ch));
 		strBuf.append(&quot;&lt;/type&gt;\r\n&lt;/waypoint&gt;\r\n&quot;);
 		return strBuf.toString();
 	}
-	public String trailer(){
+
+	public String trailer() {
 		return &quot;&lt;/loc&gt;\r\n&quot;;
 	}
 }

Modified: trunk/src/CacheWolf/exp/TPLExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/TPLExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/TPLExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -249,7 +249,7 @@
 				imgExpName = expName;
 			for (int i = 0; i &lt; counter; i++) {
 				CacheHolder ch = cacheDB.get(i);
-				if (ch.isVisible() &amp;&amp; (ch.pos.isValid() || myFilter.formatModifier &gt; 0)) {
+				if (ch.isVisible() &amp;&amp; (ch.getPos().isValid() || myFilter.formatModifier &gt; 0)) {
 					boolean get = true;
 					if (myFilter.getAddiWp) {
 						get = ch.isAddiWpt();

Modified: trunk/src/CacheWolf/exp/TomTomExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/TomTomExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/TomTomExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -60,46 +60,51 @@
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
-	
+
 	public TomTomExporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		String fileName, dirName, prefix;
 		int fileFormat;
 
 		TomTomExporterScreen infoScreen = new TomTomExporterScreen(&quot;TomTomExport&quot;);
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		fileFormat = infoScreen.getFormat();
 
 		dirName = pref.getExportPath(expName);
-		
-		if (infoScreen.oneFilePerType()){
+
+		if (infoScreen.oneFilePerType()) {
 			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, dirName);
 			fc.setTitle(&quot;Select target dir:&quot;);
-			if(fc.execute() == FormBase.IDCANCEL) return;
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			dirName = fc.getChosen();
 			pref.setExportPath(expName, dirName);
 			prefix = infoScreen.getPrefix();
 			writeOneFilePerType(fileFormat, dirName, prefix);
-		} else{
+		} else {
 			FileChooser fc = new FileChooser(FileChooserBase.SAVE, dirName);
 			fc.setTitle(&quot;Select target file:&quot;);
-	
-			if (fileFormat == TT_ASC) fc.addMask(&quot;*.asc&quot;);
-			else fc.addMask(&quot;*.ov2&quot;);
-			
-			if(fc.execute() == FormBase.IDCANCEL) return;
+
+			if (fileFormat == TT_ASC)
+				fc.addMask(&quot;*.asc&quot;);
+			else
+				fc.addMask(&quot;*.ov2&quot;);
+
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			fileName = fc.getChosen();
 			pref.setExportPathFromFileName(expName, fileName);
 			writeSingleFile(fileFormat, fileName);
 		}
 	}
-	
-	public void writeOneFilePerType(int format, String dirName, String prefix){
+
+	public void writeOneFilePerType(int format, String dirName, String prefix) {
 		RandomAccessFile out = null;
 		File dfile;
 		String ext, fileName = null;
@@ -108,63 +113,64 @@
 		ProgressBarForm progressForm = new ProgressBarForm();
 		Handle h = new Handle();
 		int currExp, counter;
-		
+
 		progressForm.showMainTask = false;
-		progressForm.setTask(h,&quot;Exporting ...&quot;);
+		progressForm.setTask(h, &quot;Exporting ...&quot;);
 		progressForm.exec();
-		
+
 		currExp = 0;
 		counter = cacheDB.countVisible();
-		
-		ext = format==TT_ASC?&quot;.asc&quot;:&quot;.ov2&quot;;
 
-		try{
-			//loop through type
-			for(int j = 0; j &lt; CacheType.guiTypeStrings().length; j++){
+		ext = format == TT_ASC ? &quot;.asc&quot; : &quot;.ov2&quot;;
+
+		try {
+			// loop through type
+			for (int j = 0; j &lt; CacheType.guiTypeStrings().length; j++) {
 				/*
-				String typeName = CacheType.guiTypeStrings()[j];
-				if (typeName.startsWith(&quot;Addi: &quot;)) {
-					typeName = typeName.substring(6);
-				}
-				*/
+				 * String typeName = CacheType.guiTypeStrings()[j];
+				 * if (typeName.startsWith(&quot;Addi: &quot;)) {
+				 * typeName = typeName.substring(6);
+				 * }
+				 */
 				String typeName = CacheType.typeImageForId(CacheType.guiSelect2Cw(j));
-				typeName=typeName.substring(0, typeName.length()-4);		
-				
+				typeName = typeName.substring(0, typeName.length() - 4);
+
 				fileName = dirName + &quot;/&quot; + prefix + typeName + ext;
 				dfile = new File(fileName);
 				dfile.delete();
-				out =  new RandomAccessFile(fileName,&quot;rw&quot;);
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=cacheDB.get(i);
+				out = new RandomAccessFile(fileName, &quot;rw&quot;);
+				for (int i = 0; i &lt; cacheDB.size(); i++) {
+					holder = cacheDB.get(i);
 
-					if(holder.getType() == CacheType.guiSelect2Cw(j) &amp;&amp; holder.isVisible()){
+					if (holder.getType() == CacheType.guiSelect2Cw(j) &amp;&amp; holder.isVisible()) {
 						currExp++;
-						h.progress = (float)currExp/(float)counter;
+						h.progress = (float) currExp / (float) counter;
 						h.changed();
-						if (holder.pos.isValid() == false) continue;
-						if (format == TT_ASC){
-							writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						if (holder.getPos().isValid() == false)
+							continue;
+						if (format == TT_ASC) {
+							writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						} else {
-							writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+							writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						}
-					}//if
-				}//for cacheDB
+					}// if
+				}// for cacheDB
 				out.close();
 				// check for empty files and delete them
 				dfile = new File(fileName);
-				if (dfile.length()==0) {
+				if (dfile.length() == 0) {
 					dfile.delete();
 				} else {
-					copyIcon(j, dirName + &quot;/&quot; + prefix,typeName); 
+					copyIcon(j, dirName + &quot;/&quot; + prefix, typeName);
 				}
-			}//for wayType
+			}// for wayType
 			progressForm.exit(0);
-		} catch (IOException e){
-			pref.log(&quot;Problem creating file! &quot; + fileName,e,true);
-		}//try
+		} catch (IOException e) {
+			pref.log(&quot;Problem creating file! &quot; + fileName, e, true);
+		}// try
 	}
-	
-	public void writeSingleFile(int format, String fileName){
+
+	public void writeSingleFile(int format, String fileName) {
 		RandomAccessFile out = null;
 		File dfile;
 
@@ -173,53 +179,53 @@
 		Handle h = new Handle();
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.setTask(h, &quot;Exporting ...&quot;);
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			dfile = new File(fileName);
 			dfile.delete();
-			out =  new RandomAccessFile(fileName,&quot;rw&quot;);
-			for(int i = 0; i&lt;cacheDB.size(); i++){
-				holder=cacheDB.get(i);
-				if(holder.isVisible()){
+			out = new RandomAccessFile(fileName, &quot;rw&quot;);
+			for (int i = 0; i &lt; cacheDB.size(); i++) {
+				holder = cacheDB.get(i);
+				if (holder.isVisible()) {
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
-					if (holder.pos.isValid() == false) continue;
-					if (format == TT_ASC){
-						writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+					if (holder.getPos().isValid() == false)
+						continue;
+					if (format == TT_ASC) {
+						writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					} else {
-						writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					}
-				}//if
-			}//for
+				}// if
+			}// for
 			out.close();
-			copyIcon(0, fileName.substring(0,fileName.indexOf(&quot;.&quot;)),&quot;&quot;);
+			copyIcon(0, fileName.substring(0, fileName.indexOf(&quot;.&quot;)), &quot;&quot;);
 			pbf.exit(0);
-		}catch (Exception e){
-			pref.log(&quot;Problem writing to file! &quot; + fileName,e,true);
-		}//try
+		} catch (Exception e) {
+			pref.log(&quot;Problem writing to file! &quot; + fileName, e, true);
+		}// try
 	}
-	
-	
-	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+
+	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
 		try {
 			outp.writeBytes(lon);
 			outp.writeBytes(&quot;,&quot;);
 			outp.writeBytes(lat);
 			outp.writeBytes(&quot;,&quot;);
-			//outp.writeBytes(&quot;\&quot;&quot; + ch.CacheName.replace(',',' ') + &quot;\&quot;\r\n&quot;);
+			// outp.writeBytes(&quot;\&quot;&quot; + ch.CacheName.replace(',',' ') + &quot;\&quot;\r\n&quot;);
 			outp.writeBytes(&quot;\&quot;&quot;);
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(&quot; - &quot;);
-			outp.writeBytes(ch.getCacheName().replace(',',' '));
+			outp.writeBytes(ch.getCacheName().replace(',', ' '));
 			outp.writeBytes(&quot; by &quot;);
 			outp.writeBytes(ch.getCacheOwner());
-			outp.writeBytes(&quot;- &quot;);             
+			outp.writeBytes(&quot;- &quot;);
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes(&quot;/&quot;);
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
@@ -227,52 +233,53 @@
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			outp.writeBytes(&quot;\&quot;\r\n&quot;);
 		} catch (IOException e) {
-			pref.log(&quot;Error writing to file&quot;,e,true);
+			pref.log(&quot;Error writing to file&quot;, e, true);
 		}
 		return;
 	}
 
-	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
-		int d,data;
+	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
+		int d, data;
 		double latlon;
-		
+
 		try {
 			d = 2;
-			outp.writeByte((byte)d);
-			data = ch.getWayPoint().length()+ch.getCacheName().length()+ch.getCacheOwner().length()+String.valueOf(ch.getHard()).length()+String.valueOf(ch.getTerrain()).length()+CacheSize.cw2ExportString(ch.getCacheSize()).length()+27;
+			outp.writeByte((byte) d);
+			data = ch.getWayPoint().length() + ch.getCacheName().length() + ch.getCacheOwner().length() + String.valueOf(ch.getHard()).length() + String.valueOf(ch.getTerrain()).length() + CacheSize.cw2ExportString(ch.getCacheSize()).length() + 27;
 			writeIntBinary(outp, data);
 			latlon = Common.parseDouble(lon);
-			latlon *=100000;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
-			latlon = Common.parseDouble(lat);;
-			latlon *=100000;
+			latlon = Common.parseDouble(lat);
+			;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(&quot; - &quot;);
 			outp.writeBytes(ch.getCacheName());
 			outp.writeBytes(&quot; by &quot;);
 			outp.writeBytes(ch.getCacheOwner());
-			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
-			//Hier wieder einf&#252;gen
-			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
-			//wider um 1 erh&#246;hen
-			outp.writeBytes(&quot;- &quot;);             
+			// Wenn Leerzeichen am Ende von Cache.Owner entfernt:
+			// Hier wieder einf&#252;gen
+			// und data = holder.wayPoint.length()+holder.CacheName.length()+.....
+			// wider um 1 erh&#246;hen
+			outp.writeBytes(&quot;- &quot;);
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes(&quot;/&quot;);
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
 			outp.writeBytes(&quot; - &quot;);
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			d = 0;
-			outp.writeByte((byte)d);
+			outp.writeByte((byte) d);
 		} catch (IOException e) {
-			pref.log(&quot;Error writing to file&quot;,e,true);
+			pref.log(&quot;Error writing to file&quot;, e, true);
 		}
 
 		return;
 	}
 
-	public void writeIntBinary(RandomAccessFile outp, int data){
-		
+	public void writeIntBinary(RandomAccessFile outp, int data) {
+
 		ByteArray buf = new ByteArray();
 		buf.appendInt(data);
 		try {
@@ -281,42 +288,44 @@
 			outp.writeByte(buf.data[1]);
 			outp.writeByte(buf.data[0]);
 		} catch (IOException e) {
-			pref.log(&quot;Error writing to file&quot;,e,true);
+			pref.log(&quot;Error writing to file&quot;, e, true);
 		}
 
 		return;
 	}
-	
-	public void copyIcon(int intWayType, String prefix, String typeName){
-		ZipFile zif=null;
+
+	public void copyIcon(int intWayType, String prefix, String typeName) {
+		ZipFile zif = null;
 		try {
-			zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+&quot;exporticons&quot;+FileBase.separator+&quot;TomTom.zip&quot;);
-		} catch (IOException e) {}
+			zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;TomTom.zip&quot;);
+		} catch (IOException e) {
+		}
 		try {
 			if (zif == null) {
-				zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+&quot;exporticons&quot;+ FileBase.separator+&quot;exporticons&quot;+FileBase.separator+&quot;TomTom.zip&quot;);
+				zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;TomTom.zip&quot;);
 			}
 			ZipEntry zipEnt;
 			int len;
-			String entName; 
-			
+			String entName;
+
 			entName = &quot;GC-&quot; + typeName + &quot;.bmp&quot;;
 			zipEnt = zif.getEntry(entName);
-			if (zipEnt == null) return;
-			
-		    byte[] buff = new byte[ zipEnt.getSize() ];
-		    InputStream  fis = zif.getInputStream(zipEnt);
-		    FileOutputStream fos = new FileOutputStream( prefix + typeName + &quot;.bmp&quot;);
-		    while( 0 &lt; (len = fis.read( buff )) )
-		      fos.write( buff, 0, len );
-		    fos.flush();
-		    fos.close();
-		    fis.close();
+			if (zipEnt == null)
+				return;
+
+			byte[] buff = new byte[zipEnt.getSize()];
+			InputStream fis = zif.getInputStream(zipEnt);
+			FileOutputStream fos = new FileOutputStream(prefix + typeName + &quot;.bmp&quot;);
+			while (0 &lt; (len = fis.read(buff)))
+				fos.write(buff, 0, len);
+			fos.flush();
+			fos.close();
+			fis.close();
 		} catch (ZipException e) {
-			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot; ,e,true);
+			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot;, e, true);
 		} catch (IOException e) {
-			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot; ,e,true);
+			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot;, e, true);
 		}
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/imp/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/GPXImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/GPXImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -46,6 +46,7 @@
 import CacheWolf.Travelbug;
 import CacheWolf.UrlFetcher;
 import CacheWolf.imp.SpiderGC.SpiderProperties;
+import CacheWolf.navi.TrackPoint;
 import CacheWolf.utils.FileBugfix;
 
 import com.stevesoft.ewe_pat.Regex;
@@ -191,7 +192,7 @@
 			if (holder.getWayPoint().length() &gt; 0) {
 				pref.log(&quot;[GPXImporter:DoIt] &quot; + holder.getWayPoint() + &quot; LogID=&quot; + logId, e, true);
 			} else {
-				pref.log(&quot;[GPXImporter:DoIt] &quot; + holder.getLatLon() + &quot; LogID=&quot; + logId, e, true);
+				pref.log(&quot;[GPXImporter:DoIt] &quot; + holder.getPos().toString() + &quot; LogID=&quot; + logId, e, true);
 			}
 			infB.close(0);
 			Vm.showWait(false);
@@ -223,8 +224,7 @@
 		}
 		if (name.equals(&quot;wpt&quot;)) {
 			holder = new CacheHolder();
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;))));
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
@@ -364,8 +364,6 @@
 				// if waypoint starts with &quot;GC&quot;
 				if (doSpider) {
 					if (spiderOK &amp;&amp; holder.is_archived() == false) {
-						if (holder.getLatLon().length() &gt; 1) {
-						}
 						// spiderImages();
 						spiderImagesUsingSpider();
 						// Rename image sources

Modified: trunk/src/CacheWolf/imp/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/LOCXMLImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/LOCXMLImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheSize;
@@ -34,6 +33,7 @@
 import CacheWolf.Common;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
+import CacheWolf.navi.TrackPoint;
 import ewe.io.FileReader;
 import ewe.io.Reader;
 import ewe.sys.Vm;
@@ -80,7 +80,7 @@
 	public void startElement(String name, AttributeList atts) {
 		if (debugXML) {
 			for (int i = 0; i &lt; atts.getLength(); i++) {
-				pref.log(&quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i),null);
+				pref.log(&quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i), null);
 			}
 		}
 		strData = &quot;&quot;;
@@ -89,8 +89,7 @@
 			return;
 		}
 		if (name.equals(&quot;coord&quot;)) {
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;))));
 			return;
 		}
 	}
@@ -127,7 +126,7 @@
 		String chars = new String(ch, start, length);
 		strData += chars;
 		if (debugXML)
-			pref.log(strData,null);
+			pref.log(strData, null);
 	}
 
 	private CacheHolder getHolder(String wpt) {

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -100,8 +100,8 @@
 				else {
 					// check over coordinates
 					// getting a cache next to the coordinates
-					String nLat = ch.pos.getLatDeg(CWPoint.DD);
-					String nLon = ch.pos.getLonDeg(CWPoint.DD);
+					String nLat = ch.getPos().getLatDeg(CWPoint.DD);
+					String nLon = ch.getPos().getLonDeg(CWPoint.DD);
 					url = baseurl + &quot;mode=locate&amp;lat=&quot; + nLat + &quot;&amp;lon=&quot; + nLon;
 					result = SafeXML.cleanback(UrlFetcher.fetch(url));
 					String ocCacheName = new Extractor(result, &quot;name=\&quot;&quot;, &quot;\&quot;&quot;, 0, true).findNext();
@@ -113,7 +113,7 @@
 						int latend = result.indexOf(&quot;\&quot;&quot;, lonend);
 						double lon = Common.parseDouble(result.substring(start, lonend));
 						double lat = Common.parseDouble(result.substring(lonend + 1, latend));
-						boolean sameCoord = lon == ch.pos.lonDec &amp;&amp; lat == ch.pos.latDec;
+						boolean sameCoord = lon == ch.getPos().lonDec &amp;&amp; lat == ch.getPos().latDec;
 						if (sameCoord) {
 							start = result.indexOf(&quot;username=\&quot;&quot;) + 10;
 							int end = result.indexOf(&quot;\&quot;&quot;, start);

Modified: trunk/src/CacheWolf/imp/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCXMLImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/OCXMLImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
 import CacheWolf.CWPoint;
@@ -41,6 +41,7 @@
 import CacheWolf.Profile;
 import CacheWolf.SafeXML;
 import CacheWolf.UrlFetcher;
+import CacheWolf.navi.TrackPoint;
 import CacheWolf.navi.TransformCoordinates;
 import CacheWolf.utils.FileBugfix;
 
@@ -68,11 +69,11 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	Class to import Data from opencaching.
- *	It uses the lastmodified parameter to identify new or changed caches.
- *	See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
- *   See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
- *	for more information.
+ * Class to import Data from opencaching.
+ * It uses the lastmodified parameter to identify new or changed caches.
+ * See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
+ * See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
+ * for more information.
  */
 public class OCXMLImporter extends MinML {
 	static protected final int STAT_INIT = 0;
@@ -90,7 +91,7 @@
 	boolean debugGPX = false;
 	CacheDB cacheDB;
 	InfoBox inf;
-	//CacheHolder ch;
+	// CacheHolder ch;
 	CacheHolder holder;
 	Preferences pref;
 	Profile profile;
@@ -102,7 +103,7 @@
 	Hashtable DBindexID = new Hashtable();
 
 	String picUrl = &quot;&quot;;
-	String picTitle =  &quot;&quot;;
+	String picTitle = &quot;&quot;;
 	String picID;
 	String cacheID;
 
@@ -118,29 +119,27 @@
 	boolean isHTML;
 	boolean isSyncSingle; // to load archieved
 
-	public OCXMLImporter(Preferences p,Profile prof)
-	{
+	public OCXMLImporter(Preferences p, Profile prof) {
 		pref = p;
-		profile=prof;
+		profile = prof;
 		cacheDB = profile.cacheDB;
-		incUpdate=true;
-		if(profile.getLast_sync_opencaching() == null ||
-				profile.getLast_sync_opencaching().length() &lt; 12){
+		incUpdate = true;
+		if (profile.getLast_sync_opencaching() == null || profile.getLast_sync_opencaching().length() &lt; 12) {
 			profile.setLast_sync_opencaching(&quot;20050801000000&quot;);
 			incUpdate = false;
 		}
 		user = p.myAlias.toLowerCase();
 		CacheHolder ch;
-		for(int i = 0; i&lt;cacheDB.size();i++){
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (!ch.getOcCacheID().equals(&quot;&quot;))
 				DBindexID.put(ch.getOcCacheID(), ch.getWayPoint());
-		}//for
+		}// for
 
 	}
 
 	/**
-	 *
+	 * 
 	 * @param number
 	 * @param infB
 	 * @return true, if some change was made to the cacheDB
@@ -149,89 +148,87 @@
 
 		CacheHolder ch;
 		ch = cacheDB.get(number);
-		hostname=OC.getOCHostName(ch.getWayPoint());
-		holder= null;
+		hostname = OC.getOCHostName(ch.getWayPoint());
+		holder = null;
 
 		if (infB.isClosed) {
 			// there could have been an update before
 			return true;
 		}
 
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from &quot; + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608, &quot;downloading data\n from &quot; + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
 		String lastS;
-		/** pref.downloadmissingOC = true, if not the last syncdate shall be used,
-		 *  but the caches shall be reloaded
-		 *  only used in syncSingle  */
+		/**
+		 * pref.downloadmissingOC = true, if not the last syncdate shall be used,
+		 * but the caches shall be reloaded
+		 * only used in syncSingle
+		 */
 		incUpdate = false;
-		if (pref.downloadAllOC)  lastS = &quot;20050801000000&quot;;
+		if (pref.downloadAllOC)
+			lastS = &quot;20050801000000&quot;;
 		else {
-			if (ch.getLastSync().length() &lt; 14) lastS = &quot;20050801000000&quot;;
-			else { lastS = ch.getLastSync(); incUpdate=true; }
+			if (ch.getLastSync().length() &lt; 14)
+				lastS = &quot;20050801000000&quot;;
+			else {
+				lastS = ch.getLastSync();
+				incUpdate = true;
+			}
 		}
 		dateOfthisSync = new Time();
 		dateOfthisSync.parse(lastS, &quot;yyyyMMddHHmmss&quot;);
 
-
 		picCnt = 0;
-		//Build url
-		String url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
+		// Build url
+		String url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot; + &quot;modifiedsince=&quot; + lastS + &quot;&amp;cache=1&quot; + &quot;&amp;cachedesc=1&quot;;
 
-		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;wp=&quot; + ch.getWayPoint()
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
+		if (pref.downloadPics)
+			url += &quot;&amp;picture=1&quot;;
+		else
+			url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot; + &quot;&amp;removedobject=0&quot; + &quot;&amp;wp=&quot; + ch.getWayPoint() + &quot;&amp;charset=utf-8&quot; + &quot;&amp;cdata=0&quot; + &quot;&amp;session=0&quot;;
 		ch.setUpdated(false);
-		isSyncSingle=true;
+		isSyncSingle = true;
 		syncOC(url);
 		inf.close(0);
 		return true;
 	}
 
-	public void doIt(){
-		boolean success=true;
+	public void doIt() {
+		boolean success = true;
 		String finalMessage;
 
-		String lastS =  profile.getLast_sync_opencaching();
+		String lastS = profile.getLast_sync_opencaching();
 		final CWPoint centre = pref.getCurCentrePt(); // No need to clone curCentrePt as centre is only read
 		if (!centre.isValid()) {
 			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, FormBase.OKB)).execute();
 			return;
 		}
-		final OCXMLImporterScreen importOpt = new OCXMLImporterScreen(
-				MyLocale.getMsg(130,&quot;Download from opencaching&quot;),
-				OCXMLImporterScreen.ALL |
-				OCXMLImporterScreen.DIST |
-				OCXMLImporterScreen.IMAGES|
-				OCXMLImporterScreen.INCLUDEFOUND|
-				OCXMLImporterScreen.HOST);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
+		final OCXMLImporterScreen importOpt = new OCXMLImporterScreen(MyLocale.getMsg(130, &quot;Download from opencaching&quot;), OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.INCLUDEFOUND
+				| OCXMLImporterScreen.HOST);
+		if (importOpt.execute() == FormBase.IDCANCEL) {
+			return;
+		}
 		Vm.showWait(true);
 		String dist = importOpt.maxDistanceInput.getText();
 		incFinds = !importOpt.foundCheckBox.getState();
-		if (importOpt.domains.getSelectedItem()!=null) {
-			hostname = (String)importOpt.domains.getSelectedItem();
-			pref.lastOCSite=hostname;
+		if (importOpt.domains.getSelectedItem() != null) {
+			hostname = (String) importOpt.domains.getSelectedItem();
+			pref.lastOCSite = hostname;
 		}
 
-		if (dist.length()== 0) return;
+		if (dist.length() == 0)
+			return;
 
 		final Double distDouble = new Double();
 		distDouble.value = Common.parseDouble(dist);
 		dist = distDouble.toString(0, 1, 0).replace(',', '.');
-		//check, if distance is greater than before
+		// check, if distance is greater than before
 		incUpdate = true;
-		if (Convert.toInt(dist) &gt; Convert.toInt(profile.getDistOC()) ||	pref.downloadAllOC  ){
+		if (Convert.toInt(dist) &gt; Convert.toInt(profile.getDistOC()) || pref.downloadAllOC) {
 			// resysnc
 			lastS = &quot;20050801000000&quot;;
 			incUpdate = false;
@@ -239,135 +236,130 @@
 		profile.setDistOC(dist);
 		// Clear status of caches in db
 		CacheHolder ch;
-		for(int i = cacheDB.size()-1; i&gt;=0 ;i--){
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
 			ch.setUpdated(false);
 			ch.setNew(false);
 			ch.setLog_updated(false);
 		}
 		picCnt = 0;
-		//Build url
-		String url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
-		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;lat=&quot; + centre.getLatDeg(TransformCoordinates.DD)
-			+ &quot;&amp;lon=&quot; + centre.getLonDeg(TransformCoordinates.DD)
-			+ &quot;&amp;distance=&quot; + dist
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// Build url
+		String url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot; + &quot;modifiedsince=&quot; + lastS + &quot;&amp;cache=1&quot; + &quot;&amp;cachedesc=1&quot;;
+		if (pref.downloadPics)
+			url += &quot;&amp;picture=1&quot;;
+		else
+			url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot; + &quot;&amp;removedobject=0&quot; + &quot;&amp;lat=&quot; + centre.getLatDeg(TransformCoordinates.DD) + &quot;&amp;lon=&quot; + centre.getLonDeg(TransformCoordinates.DD) + &quot;&amp;distance=&quot; + dist + &quot;&amp;charset=utf-8&quot; + &quot;&amp;cdata=0&quot; + &quot;&amp;session=0&quot;;
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608, &quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
-		isSyncSingle=false;
+		isSyncSingle = false;
 		success = syncOC(url);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 		Vm.showWait(false);
 		if (success) {
 			profile.setLast_sync_opencaching(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
-			//pref.savePreferences();
-			finalMessage = MyLocale.getMsg(1607,&quot;Update from opencaching successful&quot;);
-			inf.addWarning(&quot;\nNumber of&quot;+
-			&quot;\n...caches new/updated: &quot; + numCacheImported + &quot; / &quot; + numCacheUpdated +
-			&quot;\n...cache descriptions new/updated: &quot; + numDescImported +
-			&quot;\n...logs new/updated: &quot; + numLogImported);
+			// pref.savePreferences();
+			finalMessage = MyLocale.getMsg(1607, &quot;Update from opencaching successful&quot;);
+			inf.addWarning(&quot;\nNumber of&quot; + &quot;\n...caches new/updated: &quot; + numCacheImported + &quot; / &quot; + numCacheUpdated + &quot;\n...cache descriptions new/updated: &quot; + numDescImported + &quot;\n...logs new/updated: &quot; + numLogImported);
 			inf.setInfo(finalMessage);
 		}
 		inf.addOkButton();
 	}
 
 	private boolean syncOC(String address) {
-		boolean success=true;
+		boolean success = true;
 		File tmpFile = null;
 		BufferedReader r;
 
-		//inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
 
 		picCnt = 0;
 		String finalMessage = &quot;&quot;;
-		try{
+		try {
 			holder = null;
 			final String target = profile.dataDir + &quot;dummy.zip&quot;;
 			UrlFetcher.fetchDataFile(address, target);
 
-			//parse
+			// parse
 			tmpFile = new FileBugfix(target);
-			if (tmpFile.getLength() == 0 ) {
+			if (tmpFile.getLength() == 0) {
 				throw new IOException(&quot;no updates available&quot;);
 			}
 
-			final ZipFile zif = new ZipFile (target);
+			final ZipFile zif = new ZipFile(target);
 			ZipEntry zipEnt;
 			final Enumeration zipEnum = zif.entries();
 			inf.setInfo(&quot;...unzipping update file&quot;);
-			while (zipEnum.hasMoreElements())
-			{
+			while (zipEnum.hasMoreElements()) {
 				zipEnt = (ZipEntry) zipEnum.nextElement();
 				// skip over PRC-files and empty files
-				if (zipEnt.getSize()&gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)){
-					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
+				if (zipEnt.getSize() &gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)) {
+					r = new BufferedReader(new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
 					parse(r);
 					r.close();
 				}
 			}
 			zif.close();
-		}catch (final ZipException e){
-			finalMessage = MyLocale.getMsg(1614,&quot;Error while unzipping udpate file&quot;);
+		} catch (final ZipException e) {
+			finalMessage = MyLocale.getMsg(1614, &quot;Error while unzipping udpate file&quot;);
 			success = false;
-		}catch (final IOException e){
-			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) { finalMessage = &quot;No updates available&quot;; success = false; }
-			else {
-				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
-					finalMessage = MyLocale.getMsg(1616,&quot;Error: could not download update file from &quot; + hostname);
-				} else { finalMessage = &quot;IOException: &quot;+e.getMessage(); }
+		} catch (final IOException e) {
+			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) {
+				finalMessage = &quot;No updates available&quot;;
 				success = false;
+			} else {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) || e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
+					finalMessage = MyLocale.getMsg(1616, &quot;Error: could not download update file from &quot; + hostname);
+				} else {
+					finalMessage = &quot;IOException: &quot; + e.getMessage();
+				}
+				success = false;
 			}
-		}catch (final IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,&quot;Error parsing update file\n this is likely a bug in &quot; + hostname + &quot;\nplease try again later\n, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
+		} catch (final IllegalArgumentException e) {
+			finalMessage = MyLocale.getMsg(1621, &quot;Error parsing update file\n this is likely a bug in &quot; + hostname + &quot;\nplease try again later\n, state:&quot;) + &quot; &quot; + state + &quot;, waypoint: &quot; + holder.getWayPoint();
 			success = false;
-			pref.log(&quot;Parse error: &quot; + state + &quot; &quot; + holder.getWayPoint(),e,true);
-		}catch (final Exception e){ // here should be used the correct exception
-			if (holder != null)	finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
-			else finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &lt;unkown&gt;&quot;;
+			pref.log(&quot;Parse error: &quot; + state + &quot; &quot; + holder.getWayPoint(), e, true);
+		} catch (final Exception e) { // here should be used the correct exception
+			if (holder != null)
+				finalMessage = MyLocale.getMsg(1615, &quot;Error parsing update file, state:&quot;) + &quot; &quot; + state + &quot;, waypoint: &quot; + holder.getWayPoint();
+			else
+				finalMessage = MyLocale.getMsg(1615, &quot;Error parsing update file, state:&quot;) + &quot; &quot; + state + &quot;, waypoint: &lt;unkown&gt;&quot;;
 			success = false;
-			pref.log(&quot;&quot;,e,true);
+			pref.log(&quot;&quot;, e, true);
 		} finally {
-			if (tmpFile != null) tmpFile.delete();
+			if (tmpFile != null)
+				tmpFile.delete();
 		}
 		/*
-		for (int i=cacheDB.size()-1; i &gt;=0; i--) {
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
-				ch.calcRecommendationScore();
-			}
-		} */
+		 * for (int i=cacheDB.size()-1; i &gt;=0; i--) {
+		 * ch = (CacheHolder)cacheDB.get(i);
+		 * if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
+		 * ch.calcRecommendationScore();
+		 * }
+		 * }
+		 */
 		inf.setInfo(finalMessage);
 
 		return success;
 	}
 
-	public void startElement(String name, AttributeList atts){
-		if (debugGPX){
+	public void startElement(String name, AttributeList atts) {
+		if (debugGPX) {
 			for (int i = 0; i &lt; atts.getLength(); i++) {
-				pref.log(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
+				pref.log(&quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i));
 			}
 		}
-		strData =&quot;&quot;;
+		strData = &quot;&quot;;
 
-		if (name.equals(&quot;oc11xml&quot;)){
+		if (name.equals(&quot;oc11xml&quot;)) {
 			final Time lastSync = new Time();
 			try {
-				lastSync.parse(atts.getValue(&quot;date&quot;),&quot;yyyy-MM-dd HH:mm:ss&quot;);
-			}catch (final IllegalArgumentException e){
-				pref.log(&quot;&quot;,e,true);
+				lastSync.parse(atts.getValue(&quot;date&quot;), &quot;yyyy-MM-dd HH:mm:ss&quot;);
+			} catch (final IllegalArgumentException e) {
+				pref.log(&quot;&quot;, e, true);
 			}
 			// reduce time at 1 second to avoid sync problems
 			lastSync.setTime(lastSync.getTime() - 1000);
@@ -376,81 +368,110 @@
 		}
 
 		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		{ state = STAT_CACHE; }
-		if (name.equals(&quot;cachedesc&quot;)) 	{ state = STAT_CACHE_DESC;}
-		if (name.equals(&quot;cachelog&quot;)) 	{ state = STAT_CACHE_LOG; logtype = 0;}
-		if (name.equals(&quot;picture&quot;)) 	{ state = STAT_PICTURE; }
+		if (name.equals(&quot;cache&quot;)) {
+			state = STAT_CACHE;
+		}
+		if (name.equals(&quot;cachedesc&quot;)) {
+			state = STAT_CACHE_DESC;
+		}
+		if (name.equals(&quot;cachelog&quot;)) {
+			state = STAT_CACHE_LOG;
+			logtype = 0;
+		}
+		if (name.equals(&quot;picture&quot;)) {
+			state = STAT_PICTURE;
+		}
 
-		//examine data
+		// examine data
 		switch (state) {
-		case STAT_CACHE: startCache(name, atts); break;
-		case STAT_CACHE_DESC: startCacheDesc(name, atts); break;
-		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
-		case STAT_PICTURE: startPicture(name,atts); break;
+		case STAT_CACHE:
+			startCache(name, atts);
+			break;
+		case STAT_CACHE_DESC:
+			startCacheDesc(name, atts);
+			break;
+		case STAT_CACHE_LOG:
+			startCacheLog(name, atts);
+			break;
+		case STAT_PICTURE:
+			startPicture(name, atts);
+			break;
 		}
 
 	}
 
-	public void endElement(String name){
-		//examine data
+	public void endElement(String name) {
+		// examine data
 		switch (state) {
-		case STAT_CACHE: endCache(name); break;
-		case STAT_CACHE_DESC: endCacheDesc(name);break;
-		case STAT_CACHE_LOG: endCacheLog(name); break;
-		case STAT_PICTURE: endPicture(name); break;
+		case STAT_CACHE:
+			endCache(name);
+			break;
+		case STAT_CACHE_DESC:
+			endCacheDesc(name);
+			break;
+		case STAT_CACHE_LOG:
+			endCacheLog(name);
+			break;
+		case STAT_PICTURE:
+			endPicture(name);
+			break;
 		}
 
 		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		state = STAT_INIT;
-		if (name.equals(&quot;cachedesc&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;cachelog&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;picture&quot;)) 	state = STAT_INIT;
+		if (name.equals(&quot;cache&quot;))
+			state = STAT_INIT;
+		if (name.equals(&quot;cachedesc&quot;))
+			state = STAT_INIT;
+		if (name.equals(&quot;cachelog&quot;))
+			state = STAT_INIT;
+		if (name.equals(&quot;picture&quot;))
+			state = STAT_INIT;
 
 	}
 
-	public void characters(char[] ch2,int start,int length){
-		final String chars = new String(ch2,start,length);
+	public void characters(char[] ch2, int start, int length) {
+		final String chars = new String(ch2, start, length);
 		strData += chars;
-		if (debugGPX) pref.log(strData,null);
+		if (debugGPX)
+			pref.log(strData, null);
 	}
 
-	private void startCache(String name, AttributeList atts){
-		if(name.equals(&quot;id&quot;)){
+	private void startCache(String name, AttributeList atts) {
+		if (name.equals(&quot;id&quot;)) {
 			cacheID = atts.getValue(&quot;id&quot;);
 			return;
 		}
-		if (holder==null) return;
-		inf.setInfo(MyLocale.getMsg(1609,&quot;Importing Cache:&quot;)+&quot; &quot; + numCacheImported + &quot; / &quot; + numCacheUpdated + &quot;\n&quot;);
-		if(name.equals(&quot;type&quot;)){
+		if (holder == null)
+			return;
+		inf.setInfo(MyLocale.getMsg(1609, &quot;Importing Cache:&quot;) + &quot; &quot; + numCacheImported + &quot; / &quot; + numCacheUpdated + &quot;\n&quot;);
+		if (name.equals(&quot;type&quot;)) {
 			holder.setType(CacheType.ocType2CwType(atts.getValue(&quot;id&quot;)));
 			holder.getCacheDetails(false).attributes.clear();
 			return;
 		}
-		if(name.equals(&quot;status&quot;)){
-            // meaning of OC status :
-			//  1=Kann gesucht werden ;
-			//  2=Momentan nicht verf&#252;gbar ;
-			//  3=Archiviert ;
-			//  4= ;
-			//  5= ;
-			//  6=Gesperrt ;
-			//  are there more ? ;
+		if (name.equals(&quot;status&quot;)) {
+			// meaning of OC status :
+			// 1=Kann gesucht werden ;
+			// 2=Momentan nicht verf&#252;gbar ;
+			// 3=Archiviert ;
+			// 4= ;
+			// 5= ;
+			// 6=Gesperrt ;
+			// are there more ? ;
 			if (atts.getValue(&quot;id&quot;).equals(&quot;1&quot;)) {
 				holder.setAvailable(true);
 				holder.setArchived(false);
 			} else {
 				holder.setAvailable(false);
-				if( (atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) || (atts.getValue(&quot;id&quot;).equals(&quot;6&quot;))|| (atts.getValue(&quot;id&quot;).equals(&quot;7&quot;)) ) {
+				if ((atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) || (atts.getValue(&quot;id&quot;).equals(&quot;6&quot;)) || (atts.getValue(&quot;id&quot;).equals(&quot;7&quot;))) {
 					if (!isSyncSingle) {
-						holder=null;
+						holder = null;
 						numCacheImported--;
-					}
-					else {
+					} else {
 						// Umsetzung wie in gpx f&#252;r Status 6
 						if (atts.getValue(&quot;id&quot;).equals(&quot;6&quot;)) {
 							holder.setArchived(false);
-						}
-						else {
+						} else {
 							holder.setArchived(true);
 						}
 					}
@@ -458,24 +479,24 @@
 			}
 			return;
 		}
-		if(name.equals(&quot;size&quot;)){
+		if (name.equals(&quot;size&quot;)) {
 			holder.setCacheSize(CacheSize.ocXmlString2Cw(atts.getValue(&quot;id&quot;)));
 			return;
 		}
 
-		if(name.equals(&quot;waypoints&quot;)){
+		if (name.equals(&quot;waypoints&quot;)) {
 			holder.setWayPoint(atts.getValue(&quot;oc&quot;));
 			final String CName = atts.getValue(&quot;nccom&quot;) + &quot; &quot; + atts.getValue(&quot;gccom&quot;);
 			if (!CName.equals(&quot; &quot;)) {
 				holder.setCacheOwner(holder.getCacheOwner() + &quot; / &quot; + CName.trim());
 				holder.getCacheDetails(false).attributes.add(7); // wwwlink
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
-			}
-			else {
+			} else {
 				holder.getCacheDetails(false).attributes.add(6); // oconly
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			}
-			if (holder.getWayPoint().length()==0) throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
+			if (holder.getWayPoint().length() == 0)
+				throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
 			return;
 		}
 
@@ -488,17 +509,17 @@
 
 	}
 
-	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported);
+	private void startCacheDesc(String name, AttributeList atts) {
+		inf.setInfo(MyLocale.getMsg(1611, &quot;Importing cache description:&quot;) + &quot; &quot; + numDescImported);
 
-		if (name.equals(&quot;cacheid&quot;)){
+		if (name.equals(&quot;cacheid&quot;)) {
 			cacheID = atts.getValue(&quot;id&quot;);
 			holder = getHolder(cacheID, false);
 			return;
 		}
 
-		if (name.equals(&quot;desc&quot;)){
-			isHTML = atts.getValue(&quot;html&quot;).equals(&quot;1&quot;)?true:false;
+		if (name.equals(&quot;desc&quot;)) {
+			isHTML = atts.getValue(&quot;html&quot;).equals(&quot;1&quot;) ? true : false;
 			return;
 		}
 
@@ -508,21 +529,22 @@
 		}
 	}
 
-	private void startCacheLog(String name, AttributeList atts){
-		if (name.equals(&quot;id&quot;)){
+	private void startCacheLog(String name, AttributeList atts) {
+		if (name.equals(&quot;id&quot;)) {
 			logId = atts.getValue(&quot;id&quot;);
 			return;
 		}
 
-		if (name.equals(&quot;cacheid&quot;)){
+		if (name.equals(&quot;cacheid&quot;)) {
 			holder = getHolder(atts.getValue(&quot;id&quot;), false);
 			return;
 		}
-		if (holder==null) return;
+		if (holder == null)
+			return;
 
-		inf.setInfo(MyLocale.getMsg(1612,&quot;Importing Cachlog:&quot;)+&quot; &quot; + numLogImported);
+		inf.setInfo(MyLocale.getMsg(1612, &quot;Importing Cachlog:&quot;) + &quot; &quot; + numLogImported);
 
-		if (name.equals(&quot;logtype&quot;)){
+		if (name.equals(&quot;logtype&quot;)) {
 			logtype = Convert.toInt(atts.getValue(&quot;id&quot;));
 			switch (logtype) {
 			case 1:
@@ -530,7 +552,7 @@
 				break;
 			case 2:
 				logIcon = Log.typeText2Image(&quot;Not Found&quot;);
-				holder.setNoFindLogs((byte)(holder.getNoFindLogs()+1));
+				holder.setNoFindLogs((byte) (holder.getNoFindLogs() + 1));
 				break;
 			case 3:
 				logIcon = Log.typeText2Image(&quot;Note&quot;);
@@ -540,28 +562,29 @@
 		}
 	}
 
-	private void startPicture(String name, AttributeList atts){
-		if (name.equals(&quot;object&quot;)){
+	private void startPicture(String name, AttributeList atts) {
+		if (name.equals(&quot;object&quot;)) {
 			cacheID = atts.getValue(&quot;id&quot;); // are there picture without cacheID?
 			holder = getHolder(cacheID, false);
 			return;
 		}
 	}
 
-	private void endCache(String name){
-		if(name.equals(&quot;id&quot;)){ // &lt;/id&gt;
+	private void endCache(String name) {
+		if (name.equals(&quot;id&quot;)) { // &lt;/id&gt;
 			// the guid (=strData) is not part of gpx , so we use id of cacheID
 			holder = getHolder(cacheID, true); // Allocate a new CacheHolder object
 			holder.setOcCacheID(cacheID);
 			holder.getCacheDetails(false).URL = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/viewcache.php?cacheid=&quot; + cacheID;
 			return;
 		}
-		if (holder == null) return; // id should always be the first for a &lt;cache&gt;
-		if (name.equals(&quot;cache&quot;)){
+		if (holder == null)
+			return; // id should always be the first for a &lt;cache&gt;
+		if (name.equals(&quot;cache&quot;)) {
 			holder.setLastSync(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
 			int index;
 			index = cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){
+			if (index == -1) {
 				numCacheImported++;
 				holder.setNew(true);
 				cacheDB.add(holder);
@@ -576,7 +599,7 @@
 				DBindexID.put(holder.getOcCacheID(), holder.getWayPoint());
 			}
 			// clear data (picture, logs) if we do a complete Update
-			if (! incUpdate){
+			if (!incUpdate) {
 				holder.getCacheDetails(false).CacheLogs.clear();
 				holder.getCacheDetails(false).images.clear();
 			}
@@ -586,52 +609,53 @@
 			// chD.saveCacheDetails(profile.dataDir);
 			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
 
-			holder=null;
+			holder = null;
 			return;
 		}
 
-		if(name.equals(&quot;name&quot;)){
+		if (name.equals(&quot;name&quot;)) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if(name.equals(&quot;userid&quot;)) {
+		if (name.equals(&quot;userid&quot;)) {
 			holder.setCacheOwner(strData);
-			if(holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) holder.setOwned(true);
+			if (holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() &gt; 0 &amp;&amp; holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2)))
+				holder.setOwned(true);
 			return;
 		}
 
-		if(name.equals(&quot;longitude&quot;)){
+		if (name.equals(&quot;longitude&quot;)) {
 			longitude = Common.parseDouble(strData);
 			return;
 		}
-		if(name.equals(&quot;latitude&quot;)) {
-			holder.pos.set(Common.parseDouble(strData),longitude);
-			holder.setLatLon(holder.pos.toString());
+		if (name.equals(&quot;latitude&quot;)) {
+			holder.setPos(new TrackPoint(Common.parseDouble(strData), longitude));
 			return;
 		}
-		if(name.equals(&quot;difficulty&quot;)) {
+		if (name.equals(&quot;difficulty&quot;)) {
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals(&quot;terrain&quot;)) {
+		if (name.equals(&quot;terrain&quot;)) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals(&quot;datehidden&quot;)) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+		if (name.equals(&quot;datehidden&quot;)) {
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
-		if (name.equals(&quot;country&quot;)){
+		if (name.equals(&quot;country&quot;)) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
 	}
 
-	private void endCacheDesc(String name){
-		if (holder == null) return;
-		if (name.equals(&quot;cachedesc&quot;)){
-			 numDescImported++;
-			 holder.setHTML(isHTML);
+	private void endCacheDesc(String name) {
+		if (holder == null)
+			return;
+		if (name.equals(&quot;cachedesc&quot;)) {
+			numDescImported++;
+			holder.setHTML(isHTML);
 			if (pref.downloadPics &amp;&amp; isHTML) {
 				getImageNamesFromDescription();
 			}
@@ -639,56 +663,66 @@
 			return;
 		}
 
-		if (name.equals(&quot;shortdesc&quot;)){
+		if (name.equals(&quot;shortdesc&quot;)) {
 			String linebraek;
 
-			if (isHTML)	linebraek = &quot;&lt;br&gt;\n&quot;;
-			else 					linebraek = &quot;\n&quot;;
+			if (isHTML)
+				linebraek = &quot;&lt;br&gt;\n&quot;;
+			else
+				linebraek = &quot;\n&quot;;
 
-			     // this is set by &quot;hint&quot; a few lines down: if a long description is already updated, then this one is likely to be in another language
-			if (holder.is_updated())	holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + &quot;:&quot; +  linebraek + strData  +  linebraek;
-			else 					 	holder.getCacheDetails(false).LongDescription =              processingDescLang + &quot;:&quot; +  linebraek + strData  +  linebraek;
+			// this is set by &quot;hint&quot; a few lines down: if a long description is already updated, then this one is likely to be in another language
+			if (holder.is_updated())
+				holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + &quot;:&quot; + linebraek + strData + linebraek;
+			else
+				holder.getCacheDetails(false).LongDescription = processingDescLang + &quot;:&quot; + linebraek + strData + linebraek;
 			return;
 		}
 
-		if (name.equals(&quot;desc&quot;)){ // &lt;/desc&gt;
-			if (isHTML)	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.equals(&quot;desc&quot;)) { // &lt;/desc&gt;
+			if (isHTML)
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
-		if (name.equals(&quot;hint&quot;)){
+		if (name.equals(&quot;hint&quot;)) {
 			String linebreak;
-			if (isHTML)	linebreak = &quot;&lt;br&gt;\n&quot;;
-			else 					linebreak = &quot;\n&quot;;
-			if (holder.is_updated())	holder.getCacheDetails(false).Hints += linebreak + &quot;[&quot; + processingDescLang + &quot;:]&quot; +  linebreak + Common.rot13(strData)  +  linebreak;
-			else 					 	holder.getCacheDetails(false).Hints =              &quot;[&quot; + processingDescLang + &quot;:]&quot; +  linebreak + Common.rot13(strData)  +  linebreak;
+			if (isHTML)
+				linebreak = &quot;&lt;br&gt;\n&quot;;
+			else
+				linebreak = &quot;\n&quot;;
+			if (holder.is_updated())
+				holder.getCacheDetails(false).Hints += linebreak + &quot;[&quot; + processingDescLang + &quot;:]&quot; + linebreak + Common.rot13(strData) + linebreak;
+			else
+				holder.getCacheDetails(false).Hints = &quot;[&quot; + processingDescLang + &quot;:]&quot; + linebreak + Common.rot13(strData) + linebreak;
 			holder.setUpdated(true); // remark: this is used in &quot;shortdesc&quot; to decide weather the description should be appended or replaced
 			return;
 		}
 	}
 
-	private void endCacheLog(String name){
-		if (holder == null) return;
-		if (name.equals(&quot;cachelog&quot;)){ // &lt;/cachelog&gt;
-			if (holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended))&gt; -1) {
+	private void endCacheLog(String name) {
+		if (holder == null)
+			return;
+		if (name.equals(&quot;cachelog&quot;)) { // &lt;/cachelog&gt;
+			if (holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended)) &gt; -1) {
 				numLogImported++;
-				holder.getCacheDetails(false).hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
+				holder.getCacheDetails(false).hasUnsavedChanges = true; // chD.saveCacheDetails(profile.dataDir);
 			}
 			//
-			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1) {
+			if ((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1) {
 				if (incFinds || !holder.is_new()) {
 					// aber vorhandene werden mit gefunden aktualisiert
 					holder.setCacheStatus(logDate);
 					holder.setFound(true);
 					holder.getCacheDetails(false).OwnLogId = logId;
 					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
-				}
-				else {
-					//if (holder.is_new())
+				} else {
+					// if (holder.is_new())
 					cacheDB.removeElementAt(cacheDB.getIndex(holder));
 					DBindexID.remove(holder.GetCacheID());
 					// und Dateien l&#246;schen?
-					final File tmpFile = new File(profile.dataDir + holder.getWayPoint()+&quot;.xml&quot;);
+					final File tmpFile = new File(profile.dataDir + holder.getWayPoint() + &quot;.xml&quot;);
 					tmpFile.delete();
 					// todo: was ist mit den schon heruntergeladenen Bildern?
 				}
@@ -696,103 +730,108 @@
 			return;
 		}
 
-		if (name.equals(&quot;date&quot;))  {
+		if (name.equals(&quot;date&quot;)) {
 			logDate = strData;
 			return;
 		}
-		if (name.equals(&quot;userid&quot;)){
+		if (name.equals(&quot;userid&quot;)) {
 			logFinder = strData;
 			return;
 		}
-		if (name.equals(&quot;text&quot;)){
+		if (name.equals(&quot;text&quot;)) {
 			logData = strData;
 			return;
 		}
 
 	}
 
-	private void endPicture(String name){
-		if (holder == null) return;
+	private void endPicture(String name) {
+		if (holder == null)
+			return;
 
-		if(name.equals(&quot;id&quot;)){
+		if (name.equals(&quot;id&quot;)) {
 			picID = strData;
 			return;
 		}
 
-		if (name.equals(&quot;url&quot;)){
+		if (name.equals(&quot;url&quot;)) {
 			picUrl = strData;
 			return;
 		}
-		if (name.equals(&quot;title&quot;)){
+		if (name.equals(&quot;title&quot;)) {
 			picTitle = strData;
 			return;
 		}
-		if(name.equals(&quot;picture&quot;)){
-			inf.setInfo(MyLocale.getMsg(1613,&quot;Pictures:&quot;)+&quot; &quot; + ++picCnt);
-			//String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
+		if (name.equals(&quot;picture&quot;)) {
+			inf.setInfo(MyLocale.getMsg(1613, &quot;Pictures:&quot;) + &quot; &quot; + ++picCnt);
+			// String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
 			final ImageInfo ii = new ImageInfo();
 			ii.setTitle(picTitle);
 			ii.setURL(picUrl);
 			getPic(ii);
-			holder.getCacheDetails(false).hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+			holder.getCacheDetails(false).hasUnsavedChanges = true; // saveCacheDetails(profile.dataDir);
 			return;
 		}
 	}
 
-	private CacheHolder getHolder(String guid, boolean create){// See also LOCXMLImporter
+	private CacheHolder getHolder(String guid, boolean create) {// See also LOCXMLImporter
 		CacheHolder ch = null;
-		//Integer INTR = (Integer)DBindexID.get(guid);
-		final String wp = (String)DBindexID.get(guid);
-		//if(INTR != null){
-		if(wp != null){
-			//ch = cacheDB.get(INTR.intValue());
+		// Integer INTR = (Integer)DBindexID.get(guid);
+		final String wp = (String) DBindexID.get(guid);
+		// if(INTR != null){
+		if (wp != null) {
+			// ch = cacheDB.get(INTR.intValue());
 			ch = cacheDB.get(wp);
 		} else {
-			if (create) ch = new CacheHolder();
+			if (create)
+				ch = new CacheHolder();
 		}
 		return ch;
 	}
 
-
 	private void getImageNamesFromDescription() {
 		String fetchUrl;
 		String imgTag;
 		String imgAltText;
-		final Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); //  Ergebnis enthlt keine Anfhrungszeichen
+		final Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); // Ergebnis enthlt keine Anfhrungszeichen
 		final Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;); // get alternative text for Pic
 		imgRegexAlt.setIgnoreCase(true);
 		imgRegexUrl.setIgnoreCase(true);
-		int descIndex=0;
-		int numDownloaded=1;
+		int descIndex = 0;
+		int numDownloaded = 1;
 		while (imgRegexUrl.searchFrom(holder.getCacheDetails(false).LongDescription, descIndex)) { // &quot;img&quot; found
-			imgTag=imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte &lt;img ...&gt;-tag
-			fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
-			if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
-			if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-				inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot;+holder.getWayPoint()));
+			imgTag = imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte &lt;img ...&gt;-tag
+			fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			}
+			if (fetchUrl == null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
+				inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot; + holder.getWayPoint()));
 				continue;
 			}
-			inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported + &quot;\n&quot;+MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
+			inf.setInfo(MyLocale.getMsg(1611, &quot;Importing cache description:&quot;) + &quot; &quot; + numDescImported + &quot;\n&quot; + MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
 			if (imgRegexAlt.search(imgTag)) {
-				imgAltText=imgRegexAlt.stringMatched(1);
-				if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
+				imgAltText = imgRegexAlt.stringMatched(1);
+				if (imgAltText == null)
+					imgAltText = imgRegexAlt.stringMatched(2);
 				// no alternative text as image title -&gt; use filename
 			} else {
-				if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+				if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) // wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
 					imgAltText = &quot;No image title&quot;;
-				else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/')+1);
+				else
+					imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
 			}
 			descIndex = imgRegexUrl.matchedTo();
 			try {
-				//TODO this is not quite correct: actually the &quot;base&quot; URL must be known...
-				// but anyway a different baseURL should not happen very often  - it doesn't in my area
+				// TODO this is not quite correct: actually the &quot;base&quot; URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
 				if (!fetchUrl.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) {
-					fetchUrl = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + hostname+&quot;/&quot;), fetchUrl).toString();
+					fetchUrl = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/&quot;), fetchUrl).toString();
 				}
 			} catch (final MalformedURLException e) {
-				final String ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchUrl;
-				inf.addWarning(&quot;\n&quot;+ErrMessage);
-				pref.log(ErrMessage,e);
+				final String ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage() + &quot; while downloading from URL:&quot; + fetchUrl;
+				inf.addWarning(&quot;\n&quot; + ErrMessage);
+				pref.log(ErrMessage, e);
 			}
 			final ImageInfo imageInfo = new ImageInfo();
 			imageInfo.setURL(fetchUrl);
@@ -801,27 +840,27 @@
 		}
 	}
 
-
 	private void getPic(ImageInfo imageInfo) { // TODO handling of relativ URLs
-		String fileName = holder.getWayPoint() + &quot;_&quot; + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/')+1);
+		String fileName = holder.getWayPoint() + &quot;_&quot; + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
 		fileName = Common.ClearForFileName(fileName).toLowerCase();
 		final String target = profile.dataDir + fileName;
 		imageInfo.setFilename(fileName);
 		try {
 			File ftest = new FileBugfix(target);
-			if (ftest.exists()){
-				if (ftest.length() == 0) { ftest.delete(); }
-				else { holder.getCacheDetails(false).images.add(imageInfo);	}
-			}
-			else {
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
 				if (pref.downloadPics) {
 					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
 					ftest = new FileBugfix(target);
-					if (ftest.exists()){
-						if ( ftest.length() &gt; 0 ) {
+					if (ftest.exists()) {
+						if (ftest.length() &gt; 0) {
 							holder.getCacheDetails(false).images.add(imageInfo);
-						}
-						else {
+						} else {
 							ftest.delete();
 						}
 					}
@@ -830,22 +869,26 @@
 		} catch (final IOException e) {
 			String ErrMessage;
 			String wp, n;
-			if (holder != null &amp;&amp; holder.getWayPoint() != null) wp = holder.getWayPoint();
-			else 												wp = &quot;WP???&quot;;
-			if (holder != null &amp;&amp; holder.getCacheName() != null) n = holder.getCacheName();
-			else 												 n = &quot;name???&quot;;
+			if (holder != null &amp;&amp; holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = &quot;WP???&quot;;
+			if (holder != null &amp;&amp; holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = &quot;name???&quot;;
 
-			if (e == null) ErrMessage = &quot;Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: &quot;+fileName+&quot; from URL:&quot;+imageInfo.getURL();
+			if (e == null)
+				ErrMessage = &quot;Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: &quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
 			else {
-				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) || e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) {
 					// is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+ n + &quot; (&quot;+wp+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;)&quot; + MyLocale.getMsg(1619, &quot;: could not download image from URL: &quot;) + imageInfo.getURL();
 				} else
-					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+ n + &quot; (&quot;+wp+&quot;): ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;): ignoring IOException: &quot; + e.getMessage() + &quot; while downloading picture:&quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
 			}
-			inf.addWarning(&quot;\n&quot;+ErrMessage);
-			pref.log(ErrMessage,e,true);
+			inf.addWarning(&quot;\n&quot; + ErrMessage);
+			pref.log(ErrMessage, e, true);
 		}
 
 	}

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -460,8 +460,8 @@
 		CacheHolder ch = null;
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			if (ch.is_Checked &amp;&amp; ch.pos.isValid()) {
-				final CWPoint tmpPos = ch.pos;
+			if (ch.is_Checked &amp;&amp; ch.getPos().isValid()) {
+				final CWPoint tmpPos = ch.getPos();
 				final double tmpDistance = tmpPos.getDistance(startPos);
 				if (nextDistance == 0) {
 					// Startwert
@@ -484,7 +484,7 @@
 			}
 		}
 		if (index &gt; -1) {
-			return cacheDB.get(index).pos;
+			return cacheDB.get(index).getPos();
 		} else
 			return null;
 	}
@@ -630,7 +630,7 @@
 
 				ch = new CacheHolder();
 				ch.setWayPoint(wp);
-				ch.setLatLon(lat + &quot; &quot; + lon);
+				ch.setPos(new CWPoint(lat + &quot; &quot; + lon));
 				ch.setType(cacheType);
 				if (own.equals(&quot;true&quot;)) {
 					ch.setOwned(true);
@@ -1711,7 +1711,7 @@
 			boolean pm = subrOnly.equals(&quot;false&quot;) ? false : true;
 			if (pm &amp;&amp; !pref.isPremium)
 				ch.setCacheStatus(&quot;PM&quot;);
-			ch.pos = p;
+			ch.setPos(p);
 			ch.setCacheOwner(owner);
 			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
 			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
@@ -2319,8 +2319,8 @@
 						// ==========
 						// General Cache Data
 						// ==========
-						ch.setLatLon(latLon);
-						pref.log(&quot;LatLon: &quot; + ch.getLatLon());
+						ch.setPos(new CWPoint(latLon));
+						pref.log(&quot;LatLon: &quot; + ch.getPos().toString());
 
 						final String longDesc = getLongDesc(completeWebPage);
 						ch.getCacheDetails(false).setLongDescription(longDesc);
@@ -3047,7 +3047,7 @@
 
 					koordRex.search(rowBlock);
 					if (koordRex.didMatch()) {
-						hd.setLatLon(koordRex.stringMatched(1));
+						hd.setPos(new CWPoint(koordRex.stringMatched(1)));
 						koords_not_yet_found = false;
 					} else {
 						if (koords_not_yet_found) {

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/myTableControl.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -317,7 +317,7 @@
 				return;
 			}
 			CacheHolder thisCache = cacheDB.get(tbp.getSelectedCache());
-			CWPoint cp = new CWPoint(thisCache.getLatLon());
+			CWPoint cp = new CWPoint(thisCache.getPos());
 			if (!cp.isValid()) {
 				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(4111, &quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
 				tmpMB.execute();
@@ -373,9 +373,9 @@
 
 		if (selectedItem == miOpenGmaps) {
 			ch = cacheDB.get(tbp.getSelectedCache());
-			if (ch.pos.isValid()) {
-				String lat = &quot;&quot; + ch.pos.getLatDeg(CWPoint.DD);
-				String lon = &quot;&quot; + ch.pos.getLonDeg(CWPoint.DD);
+			if (ch.getPos().isValid()) {
+				String lat = &quot;&quot; + ch.getPos().getLatDeg(CWPoint.DD);
+				String lon = &quot;&quot; + ch.getPos().getLonDeg(CWPoint.DD);
 				String nameOfCache = UrlFetcher.encodeURL(ch.getCacheName(), false).replace('#', 'N').replace('@', '_');
 				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
 				if (!pref.language.equalsIgnoreCase(&quot;auto&quot;)) {

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/myTableModel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -417,7 +417,7 @@
 					wpVal.addColumn(ch.getCacheName());
 					return wpVal;
 				case 6: // Location
-					return ch.getLatLon();
+					return ch.getPos().toString();
 				case 7: // Owner
 					return ch.getCacheOwner();
 				case 8: // Date hidden

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -68,18 +68,17 @@
 import ewe.ui.mLabel;
 
 /**
- *	Class to create the panel which handles the connection to the GPS-device&lt;br&gt;
- *	Displays: current position,speed and bearing; relation to destination waypoint&lt;br&gt;
- *	Class ID: 1500
+ * Class to create the panel which handles the connection to the GPS-device&lt;br&gt;
+ * Displays: current position,speed and bearing; relation to destination waypoint&lt;br&gt;
+ * Class ID: 1500
  */
 
-
 public final class GotoPanel extends CellPanel {
 
-	//public CWGPSPoint gpsPosition = new CWGPSPoint();
-	//public CWPoint toPoint = new CWPoint();
+	// public CWGPSPoint gpsPosition = new CWGPSPoint();
+	// public CWPoint toPoint = new CWPoint();
 	public Navigate myNavigation;
-	mButton btnGPS, btnCenter,btnSave;
+	mButton btnGPS, btnCenter, btnSave;
 	mButton btnGoto, btnMap;
 	int currFormatSel;
 
@@ -101,13 +100,13 @@
 	ImageControl icRose;
 	GotoRose compassRose;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
 
 	Menu mnuContextFormt;
-	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; //miDMM, miDMS, miDD, miUTM, miGK;
+	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; // miDMM, miDMS, miDD, miUTM, miGK;
 
 	Menu mnuContextRose;
 	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
@@ -115,27 +114,32 @@
 
 	/**
 	 * Create GotoPanel
-	 * @param Preferences 	global preferences
-	 * @param MainTab		reference to MainTable
-	 * @param DetailsPanel 	reference to DetailsPanel
-	 * @param Vector		cacheDB
+	 * 
+	 * @param Preferences
+	 *            global preferences
+	 * @param MainTab
+	 *            reference to MainTable
+	 * @param DetailsPanel
+	 *            reference to DetailsPanel
+	 * @param Vector
+	 *            cacheDB
 	 */
 	public GotoPanel(Navigate nav) {
 		myNavigation = nav;
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		detP = mainT.detP;
 		cacheDB = profile.cacheDB;
 
 		// Button
-		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504,&quot;Start&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,&quot;Centre&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504, &quot;Start&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309, &quot;Centre&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311, &quot;Create Waypoint&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		// ButtonP.addLast(btnMap = new mButton(MyLocale.getMsg(1506,&quot;Map&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
-		//Format selection for coords
-		//context menu
+		// Format selection for coords
+		// context menu
 		mnuContextFormt = new Menu();
 		currFormatSel = 1; // default to d&#176; m.m
 		mnuContextFormt.addItem(miCooformat[0] = new MenuItem(&quot;d.d&#176;&quot;));
@@ -148,14 +152,16 @@
 
 		// Create context menu for compass rose: select luminary for orientation
 		mnuContextRose = new Menu();
-		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i &lt; SkyOrientation.LUMINARY_NAMES.length; i++) {
 			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
-			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-			else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+			if (i == myNavigation.luminary)
+				miLuminary[i].modifiers |= MenuItem.Checked;
+			else
+				miLuminary[i].modifiers &amp;= MenuItem.Checked;
 		}
 
-		//Coords
-		CoordsP.addNext(lblGPS = new mLabel(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		// Coords
+		CoordsP.addNext(lblGPS = new mLabel(&quot;GPS: &quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		lblGPS.backGround = RED;
 		lblGPS.setMenu(mnuContextFormt);
 		lblGPS.modifyAll(ControlConstants.WantHoldDown, 0);
@@ -164,45 +170,47 @@
 		lblPosition.anchor = CellConstants.CENTER;
 		lblPosition.setMenu(mnuContextFormt);
 		lblPosition.modifyAll(ControlConstants.WantHoldDown, 0);
-		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,&quot;DST:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblDST.backGround = new Color(0,0,255);
+		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500, &quot;DST:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		lblDST.backGround = new Color(0, 0, 255);
 		lblDST.setMenu(mnuContextFormt);
 		lblDST.modifyAll(ControlConstants.WantHoldDown, 0);
 
-		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		//Rose for bearing
-		//		compassRose = new GotoRose(&quot;rose.png&quot;);
+		// Rose for bearing
+		// compassRose = new GotoRose(&quot;rose.png&quot;);
 		compassRose = new GotoRose();
 		icRose = new ImageControl(compassRose);
 		icRose.setMenu(mnuContextRose);
 		icRose.modifyAll(ControlConstants.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
-		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		roseP.addLast(icRose, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.NORTH));
 
 		mnuContextRose.addItem(new MenuItem(&quot;&quot;, MenuItem.Separator, null));
-		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,&quot;North Centered&quot;)));
-		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
-		else miNorthCentered.modifiers &amp;= MenuItem.Checked;
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503, &quot;North Centered&quot;)));
+		if (compassRose.isNorthCentered())
+			miNorthCentered.modifiers |= MenuItem.Checked;
+		else
+			miNorthCentered.modifiers &amp;= MenuItem.Checked;
 
-		//add Panels
-		HeadP.addLast(ButtonP,CellConstants.HSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		HeadP.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));	
-		this.addNext(HeadP,CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(2,1));		
-		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506,&quot;Map&quot;)+&quot; &quot;),CellConstants.HSTRETCH, CellConstants.VFILL|CellConstants.RIGHT).setTag(SPAN,new Dimension(2,1));
-		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		btnMap.backGround=GREEN;
+		// add Panels
+		HeadP.addLast(ButtonP, CellConstants.HSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		HeadP.addLast(CoordsP, CellConstants.HSTRETCH, CellConstants.HFILL | CellConstants.NORTH).setTag(SPAN, new Dimension(2, 1));
+		this.addNext(HeadP, CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506, &quot;Map&quot;) + &quot; &quot;), CellConstants.HSTRETCH, CellConstants.VFILL | CellConstants.RIGHT).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(roseP, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		btnMap.backGround = GREEN;
 	}
 
-	public void resizeTo(int pWidth, int pHeight){
+	public void resizeTo(int pWidth, int pHeight) {
 		super.resizeTo(pWidth, pHeight);
 		Rect coordsRect = CoordsP.getRect();
 		int roseHeight = pHeight - coordsRect.y - coordsRect.height;
 		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
-			//some space for the SIP button
-			if ( (Vm.getParameter(VmConstants.VM_FLAGS) &amp; (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
-				Rect screen = (Rect)Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new Rect(),0);
+			// some space for the SIP button
+			if ((Vm.getParameter(VmConstants.VM_FLAGS) &amp; (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) {
+				Rect screen = (Rect) Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new Rect(), 0);
 				roseHeight -= screen.height / 14;
 			}
 		}
@@ -211,14 +219,17 @@
 		compassRose.resize(pWidth, roseHeight);
 	}
 
-
 	/**
 	 * set the coords of the destination
-	 * @param dest destination
+	 * 
+	 * @param dest
+	 *            destination
 	 */
-	public void setDestination(CWPoint dest){
+	public void setDestination(CWPoint dest) {
 		myNavigation.setDestination(dest);
-		if (!myNavigation.destination.isValid()) (new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1507,&quot;Coordinates are out of range:&quot;) +&quot;\n&quot;+MyLocale.getMsg(1508,&quot;latitude&quot;)+&quot;: &quot;+myNavigation.destination.latDec+&quot;\n &quot;+MyLocale.getMsg(1509,&quot;longditue&quot;)+&quot;: &quot;+myNavigation.destination.lonDec, FormBase.OKB)).execute();
+		if (!myNavigation.destination.isValid())
+			(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1507, &quot;Coordinates are out of range:&quot;) + &quot;\n&quot; + MyLocale.getMsg(1508, &quot;latitude&quot;) + &quot;: &quot; + myNavigation.destination.latDec + &quot;\n &quot; + MyLocale.getMsg(1509, &quot;longditue&quot;) + &quot;: &quot;
+					+ myNavigation.destination.lonDec, FormBase.OKB)).execute();
 
 	}
 
@@ -227,15 +238,17 @@
 		updateDistance();
 	}
 
-
 	/**
 	 * set the coords of the destination and switch to gotoPanel
-	 * @param LatLon destination
+	 * 
+	 * @param LatLon
+	 *            destination
 	 */
 	public void setDestinationAndSwitch(CWPoint where) {
 		myNavigation.setDestination(where);
 		mainT.select(this);
 	}
+
 	public void setDestinationAndSwitch(CacheHolder ch) {
 		myNavigation.setDestination(ch);
 		mainT.select(this);
@@ -243,16 +256,16 @@
 
 	/**
 	 * updates distance and bearing
-	 *
+	 * 
 	 */
 
 	public void updateDistance() {
-		//update distance
+		// update distance
 		float distance = -1.0f;
-		if (myNavigation.gpsPos.isValid() &amp;&amp; myNavigation.destination.isValid() ) {
-			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		if (myNavigation.gpsPos.isValid() &amp;&amp; myNavigation.destination.isValid()) {
+			distance = (float) myNavigation.gpsPos.getDistance(myNavigation.destination);
 		}
-		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+		compassRose.setWaypointDirectionDist((float) myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
 	}
 
 	/**
@@ -263,37 +276,41 @@
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getSatsInView(), myNavigation.gpsPos.getHDOP());
-		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) {
 			// display values only, if signal good
 			lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 			speed.set(myNavigation.gpsPos.getSpeed());
 			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
 			bearMov.set(myNavigation.gpsPos.getBear());
 			updateDistance();
-			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			compassRose.setSunMoveDirections((float) sunAzimut.value, (float) bearMov.value, (float) speed.value);
 			// Set background to signal quality
 		}
 
 		// receiving data, but signal ist not good
-		if ((fix == 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+		if ((fix == 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) {
 			gpsStatus = YELLOW;
 		}
 		// receiving no data
 		if (fix == -1) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1510, &quot;No data from GPS.\nConnection to serial port/gpsd closed.&quot;),FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1510, &quot;No data from GPS.\nConnection to serial port/gpsd closed.&quot;), FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps();
 		}
 		// cannot interpret data
 		if (fix == -2) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1511, &quot;Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n&quot;)+myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1511,
+						&quot;Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n&quot;)
+						+ myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps(); // TODO automatic in myNavigate?
 		}
 	}
 
 	public void gpsStarted() {
-		btnGPS.setText(MyLocale.getMsg(1505,&quot;Stop&quot;));
+		btnGPS.setText(MyLocale.getMsg(1505, &quot;Stop&quot;));
 	}
 
 	public void startGps() {
@@ -301,28 +318,33 @@
 	}
 
 	public void gpsStoped() {
-		btnGPS.setText(MyLocale.getMsg(1504,&quot;Start&quot;));
+		btnGPS.setText(MyLocale.getMsg(1504, &quot;Start&quot;));
 		gpsStatus = this.backGround;
 		this.repaintNow(); // without this the change in the background color will not be displayed
 	}
 
-
 	private String getGotoBtnText() {
-		if (myNavigation.destination == null) return MyLocale.getMsg(999,&quot;Not set&quot;);
-		else return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
+		if (myNavigation.destination == null)
+			return MyLocale.getMsg(999, &quot;Not set&quot;);
+		else
+			return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
 	}
 
 	public void switchToMovingMap() {
 		CWPoint centerTo = null;
-		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		if (myNavigation.isGpsPosValid())
+			centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
 		else {
 			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-			//centerTo = new CWPoint(myNavigation.destination);
-			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			// centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())
+				centerTo = new CWPoint(myNavigation.destination);
 			else {
-				if (mainT.ch != null &amp;&amp; mainT.ch.pos.isValid()) centerTo = new CWPoint(mainT.ch.pos);
+				if (mainT.ch != null &amp;&amp; mainT.ch.getPos().isValid())
+					centerTo = new CWPoint(mainT.ch.getPos());
 				else {
-					if (pref.getCurCentrePt().isValid()) centerTo = new CWPoint(pref.getCurCentrePt());
+					if (pref.getCurCentrePt().isValid())
+						centerTo = new CWPoint(pref.getCurCentrePt());
 				}
 			}
 		}
@@ -335,10 +357,10 @@
 	/**
 	 * Eventhandler
 	 */
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		if (ev instanceof MenuEvent) {
 			if (ev.type == MenuEvent.SELECTED) {
-				if (((MenuEvent)ev).menu == mnuContextFormt) {
+				if (((MenuEvent) ev).menu == mnuContextFormt) {
 					mnuContextFormt.close();
 					mnuContextFormt.getItemAt(currFormatSel).modifiers &amp;= ~MenuItem.Checked;
 					currFormatSel = mnuContextFormt.getInt();
@@ -346,23 +368,22 @@
 					lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 					btnGoto.setText(getGotoBtnText());
 				} // end lat-lon-format context menu
-				if (((MenuEvent)ev).menu == mnuContextRose) {
+				if (((MenuEvent) ev).menu == mnuContextRose) {
 					MenuItem action = (MenuItem) mnuContextRose.getSelectedItem();
 					if (action != null) {
-						for (int i=0; i&lt;miLuminary.length; i++) {
+						for (int i = 0; i &lt; miLuminary.length; i++) {
 							if (action == miLuminary[i]) {
 								myNavigation.setLuminary(i);
 								miLuminary[i].modifiers |= MenuItem.Checked;
 								compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
-							} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+							} else
+								miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
 						}
 						if (action == miNorthCentered) {
 							if (compassRose.isNorthCentered()) {
 								compassRose.setNorthCentered(false);
 								miNorthCentered.modifiers &amp;= ~MenuItem.Checked;
-							}
-							else
-							{
+							} else {
 								compassRose.setNorthCentered(true);
 								miNorthCentered.modifiers |= MenuItem.Checked;
 							}
@@ -372,44 +393,49 @@
 			}
 		}
 
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
 			// start/stop GPS connection
-			if (ev.target == btnGPS){
-				if (btnGPS.getText().equals(MyLocale.getMsg(1504, &quot;Start&quot;))) startGps();
-				else myNavigation.stopGps();
+			if (ev.target == btnGPS) {
+				if (btnGPS.getText().equals(MyLocale.getMsg(1504, &quot;Start&quot;)))
+					startGps();
+				else
+					myNavigation.stopGps();
 			}
 
 			// set current position as centre and recalculate distance of caches in MainTab
-			if (ev.target == btnCenter){
+			if (ev.target == btnCenter) {
 				if (myNavigation.gpsPos.isValid()) {
 					pref.setCurCentrePt(myNavigation.gpsPos);
-				} else (new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(1514, &quot;Cannot recalculate distances, because the GPS position is not set&quot;), FormBase.OKB)).execute();
+				} else
+					(new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(1514, &quot;Cannot recalculate distances, because the GPS position is not set&quot;), FormBase.OKB)).execute();
 			}
-			//Start moving map
-			if (ev.target == btnMap){
+			// Start moving map
+			if (ev.target == btnMap) {
 				switchToMovingMap();
 			}
 			// create new waypoint with current GPS-position
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
-				ch.setLatLon(myNavigation.gpsPos.toString());
-				ch.pos = new CWPoint(myNavigation.gpsPos);
+				ch.setPos(myNavigation.gpsPos);
 				ch.setType(CacheType.CW_TYPE_STAGE); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint
-			if (ev.target == btnGoto){
-				if(Vm.isMobile()){
+			if (ev.target == btnGoto) {
+				if (Vm.isMobile()) {
 					InputScreen InScr = new InputScreen(CoordsScreen.getLocalSystem(currFormatSel));
-					if (myNavigation.destination.isValid())	InScr.setCoords(myNavigation.destination);
-					else InScr.setCoords(new CWPoint(0,0));
+					if (myNavigation.destination.isValid())
+						InScr.setCoords(myNavigation.destination);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
 					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(InScr.getCoords());
-				}else
-				{
+				} else {
 					CoordsScreen cs = new CoordsScreen();
-					if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
-					else cs.setFields(new CWPoint(0,0), CoordsScreen.getLocalSystem(currFormatSel));
+					if (myNavigation.destination.isValid())
+						cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
+					else
+						cs.setFields(new CWPoint(0, 0), CoordsScreen.getLocalSystem(currFormatSel));
 					if (cs.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(cs.getCoords());
 				}
@@ -420,7 +446,8 @@
 	}
 }
 
-/** class for displaying the compass rose
+/**
+ * class for displaying the compass rose
  * including goto, sun and moving direction
  */
 class GotoRose extends AniImage {
@@ -445,25 +472,28 @@
 
 	boolean northCentered = Global.getPref().northCenteredGoto;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
-	final static Color ORANGE = new Color(255,128,0);
-	final static Color DARKGREEN = new Color(0,192,0);
-	final static Color CYAN = new Color(0,255,255);
-	final static Color MAGENTA = new Color(255,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
+	final static Color ORANGE = new Color(255, 128, 0);
+	final static Color DARKGREEN = new Color(0, 192, 0);
+	final static Color CYAN = new Color(0, 255, 255);
+	final static Color MAGENTA = new Color(255, 0, 255);
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public GotoRose(String fn){
+	public GotoRose(String fn) {
 		super(fn);
 	}
 
-	public GotoRose(){
+	public GotoRose() {
 		super();
 	}
 
@@ -472,7 +502,7 @@
 		distance = dist;
 	}
 
-	public void setSunMoveDirections(float sd, float md, float speed ) {
+	public void setSunMoveDirections(float sd, float md, float speed) {
 		sunDir = sd;
 		moveDir = md;
 		m_speed = speed;
@@ -492,15 +522,18 @@
 		refresh();
 	}
 
-
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
+	public void doDraw(Graphics g, int options) {
 		g.setColor(Color.White);
 		g.fillRect(0, 0, location.width, location.height);
 
@@ -512,15 +545,14 @@
 		roseRadius = java.lang.Math.min((location.width * 3) / 4, location.height) / 2;
 
 		if (northCentered) {
-			//scale(location.width, location.height, null, 0);
-			//super.doDraw(g, options);
-			drawFullRose(g, 0, new Color(255,255,255), new Color(200,200,200), new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(75,75,75), 1.0f, true, true);
-		}
-		else {
-			int radius = (int)(roseRadius * 0.75f);
+			// scale(location.width, location.height, null, 0);
+			// super.doDraw(g, options);
+			drawFullRose(g, 0, new Color(255, 255, 255), new Color(200, 200, 200), new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(75, 75, 75), 1.0f, true, true);
+		} else {
+			int radius = (int) (roseRadius * 0.75f);
 
-			g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
-			g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+			g.setPen(new Pen(new Color(150, 150, 150), Pen.SOLID, 3));
+			g.drawEllipse(location.width / 2 - radius, location.height / 2 - radius, 2 * radius, 2 * radius);
 		}
 
 		drawArrows(g);
@@ -530,7 +562,7 @@
 		drawGpsStatus(g);
 	}
 
-	private void drawWayPointData(Graphics g){
+	private void drawWayPointData(Graphics g) {
 		String strTemp = MyLocale.getMsg(1512, &quot;Waypoint&quot;);
 		g.setColor(Color.DarkBlue);
 		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4, lineHeight);
@@ -559,29 +591,30 @@
 			threshold = 1.0;
 			newDistance = distance;
 		}
-		if ( newDistance &gt;= 0.0f ) {
+		if (newDistance &gt;= 0.0f) {
 			tmp.set(newDistance);
-			if (tmp.value &gt;= threshold){
-				strTemp = MyLocale.formatDouble(tmp,&quot;0.000&quot;)+ &quot; &quot; + Metrics.getUnit(bigUnit);
+			if (tmp.value &gt;= threshold) {
+				strTemp = MyLocale.formatDouble(tmp, &quot;0.000&quot;) + &quot; &quot; + Metrics.getUnit(bigUnit);
 			} else {
 				tmp.set(Metrics.convertUnit(tmp.value, bigUnit, smallUnit));
-				strTemp = tmp.toString(3,0,0) + &quot; &quot; + Metrics.getUnit(smallUnit);
+				strTemp = tmp.toString(3, 0, 0) + &quot; &quot; + Metrics.getUnit(smallUnit);
 			}
-		}
-		else strTemp = &quot;--- &quot;+Metrics.getUnit(bigUnit);
+		} else
+			strTemp = &quot;--- &quot; + Metrics.getUnit(bigUnit);
 		g.drawText(strTemp, 2, lineHeight);
 
 		tmp.set(gotoDir);
 		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
-			strTemp = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
-		else strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
-		g.drawText(strTemp, 2, 2*lineHeight);
+			strTemp = tmp.toString(0, 0, 0) + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
+		else
+			strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
+		g.drawText(strTemp, 2, 2 * lineHeight);
 	}
 
-	private void drawGpsData(Graphics g){
+	private void drawGpsData(Graphics g) {
 		g.setColor(RED);
 
-		String strHeadline = MyLocale.getMsg(1501,&quot;Current&quot;);
+		String strHeadline = MyLocale.getMsg(1501, &quot;Current&quot;);
 
 		Double tmp = new Double();
 
@@ -600,17 +633,16 @@
 		}
 		if (tmp.value &gt;= 0) {
 			if (tmp.value &gt;= 100) {
-				strSpeed = MyLocale.formatDouble(tmp,&quot;0&quot;) + unit;
+				strSpeed = MyLocale.formatDouble(tmp, &quot;0&quot;) + unit;
+			} else {
+				strSpeed = MyLocale.formatDouble(tmp, &quot;0.0&quot;) + unit;
 			}
-			else {
-				strSpeed = MyLocale.formatDouble(tmp,&quot;0.0&quot;) + unit;
-			}
 		}
 
 		tmp.set(moveDir);
-		String strMoveDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		String strMoveDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
-			strMoveDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+			strMoveDir = tmp.toString(0, 0, 0) + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
 		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
@@ -621,21 +653,21 @@
 		g.setColor(Color.Black);
 		g.drawText(strHeadline, startX + 2, 0);
 		g.drawText(strSpeed, startX + 2, lineHeight);
-		g.drawText(strMoveDir, startX + 2, 2*lineHeight);
+		g.drawText(strMoveDir, startX + 2, 2 * lineHeight);
 	}
 
-	private void drawLuminaryData(Graphics g){
+	private void drawLuminaryData(Graphics g) {
 		g.setColor(YELLOW);
 
-		String strSunDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		String strSunDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 		if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) {
 			Double tmp = new Double();
 			tmp.set(sunDir);
-			strSunDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+			strSunDir = tmp.toString(0, 0, 0) + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 		}
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
-		int startY = location.height - 2*lineHeight;
+		int startY = location.height - 2 * lineHeight;
 		g.fillRect(0, startY, textWidth + 4, location.height - startY);
 
 		g.setColor(Color.Black);
@@ -643,104 +675,96 @@
 		g.drawText(strSunDir, 2, startY + lineHeight);
 	}
 
-	private void drawGpsStatus(Graphics g){
+	private void drawGpsStatus(Graphics g) {
 		if ((m_fix &gt; 0) &amp;&amp; (m_sats &gt;= 0)) {
 			// Set background to signal quality
 			g.setColor(GREEN);
+		} else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) &amp;&amp; (m_sats &gt;= 0)) {
+			g.setColor(YELLOW);
+		} else {
+			g.setColor(RED);
 		}
-		else
-			// receiving data, but signal ist not good
-			if ((m_fix == 0) &amp;&amp; (m_sats &gt;= 0)) {
-				g.setColor(YELLOW);
-			}
-			else {
-				g.setColor(RED);
-			}
 
 		String strSats = &quot;Sats: -&quot;;
 		if (m_sats &gt;= 0) {
 			strSats = &quot;Sats: &quot; + Convert.toString(m_sats) + &quot;/&quot; + Convert.toString(m_satsInView);
 		}
 		String strHdop = &quot;HDOP: -&quot;;
-		if (m_hdop &gt;= 0) strHdop = &quot;HDOP: &quot; + Convert.toString(m_hdop);
+		if (m_hdop &gt;= 0)
+			strHdop = &quot;HDOP: &quot; + Convert.toString(m_hdop);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
 		int startX = location.width - (textWidth + 4);
-		int startY = location.height - 2*lineHeight;
-		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+		int startY = location.height - 2 * lineHeight;
+		g.fillRect(startX, startY, location.width - startX, location.height - startY);
 
 		g.setColor(Color.Black);
 		g.drawText(strSats, startX + 2, startY);
 		g.drawText(strHdop, startX + 2, startY + lineHeight);
 	}
 
-	private void drawArrows(Graphics g){
-		if (g != null)
-		{
+	private void drawArrows(Graphics g) {
+		if (g != null) {
 			// select moveDirColor according to difference to gotoDir
 			Color moveDirColor = RED;
 
-			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360 &amp;&amp; moveDir &lt; 360 &amp;&amp; moveDir &gt; -360)
-			{
+			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360 &amp;&amp; moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
 				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff &gt; 360)
-				{
+				while (diff &gt; 360) {
 					diff -= 360.0f;
 				}
-				if (diff &gt; 180.0f)
-				{
+				if (diff &gt; 180.0f) {
 					diff = 360.0f - diff;
 				}
 
-				if (diff &lt;= 12.25f)
-				{
+				if (diff &lt;= 12.25f) {
 					moveDirColor = GREEN;
-				}
-				else if (diff &lt;= 22.5f)
-				{
+				} else if (diff &lt;= 22.5f) {
 					moveDirColor = CYAN;
-				}
-				else if (diff &lt;= 45.0f)
-				{
+				} else if (diff &lt;= 45.0f) {
 					moveDirColor = ORANGE;
-				}
-				else if (diff &lt;= 90.0f)
-				{
+				} else if (diff &lt;= 90.0f) {
 					moveDirColor = MAGENTA;
 				}
 			}
 
 			// draw only valid arrows
 			if (northCentered) {
-				if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
-				if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
-			}
-			else {
-				//moveDir centered
+				if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360)
+					drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360)
+					drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360)
+					drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			} else {
+				// moveDir centered
 				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
-					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
-					//drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
-					drawFullRose(g, 360 - moveDir, new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(200,200,200), new Color(200,200,200), new Color(75,75,75), 1.0f, false, false);
+					// drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					// drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					drawFullRose(g, 360 - moveDir, new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(200, 200, 200), new Color(200, 200, 200), new Color(75, 75, 75), 1.0f, false, false);
 
-					int radius = (int)(roseRadius * 0.75f);
-					g.setPen(new Pen(RED,Pen.SOLID,3));
-					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					int radius = (int) (roseRadius * 0.75f);
+					g.setPen(new Pen(RED, Pen.SOLID, 3));
+					g.drawLine(location.width / 2, location.height / 2 - radius, location.width / 2, location.height / 2 + radius);
 
-					if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
-					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
+					if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360)
+						drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360)
+						drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
 				}
 			}
 		}
 	}
 
 	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.08f;
 		float circlePos = arrowLength * 0.7f;
-		int circleRadius = (int)(arrowLength * 0.1f);
+		int circleRadius = (int) (arrowLength * 0.1f);
 
 		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
 		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
@@ -757,20 +781,20 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		//		g.setPen(new Pen(col,Pen.SOLID,3));
-		//		g.drawLine(centerX,centerY,pointX,pointY);
+		// g.setPen(new Pen(col,Pen.SOLID,3));
+		// g.drawLine(centerX,centerY,pointX,pointY);
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
 	}
 
 	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
-		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float halfOpeningAngle = (float) (java.lang.Math.PI * 0.03);
 		float sideLineLength = arrowLength * 0.75f;
 
 		int[] pointsX = new int[4];
@@ -785,7 +809,7 @@
 		pointsX[3] = centerX;
 		pointsY[3] = centerY;
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		if (colPoint != null) {
@@ -794,29 +818,28 @@
 		}
 	}
 
-	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight,
-			Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
+	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight, Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
 		float subScale1 = 1.0f;
 		float subScale2 = 0.9f;
 		float innerScale = 0.15f;
-		if(bDrawEightArrows){
+		if (bDrawEightArrows) {
 			innerScale = 0.12f;
-			drawRosePart(g,  45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NE&quot;, bDrawText);
+			drawRosePart(g, 45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NE&quot;, bDrawText);
 			drawRosePart(g, 135 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SE&quot;, bDrawText);
 			drawRosePart(g, 225 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SW&quot;, bDrawText);
 			drawRosePart(g, 315 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NW&quot;, bDrawText);
 		}
 
-		drawRosePart(g,   0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, &quot;N&quot;, bDrawText);
-		drawRosePart(g,  90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;E&quot;, bDrawText);
+		drawRosePart(g, 0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, &quot;N&quot;, bDrawText);
+		drawRosePart(g, 90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;E&quot;, bDrawText);
 		drawRosePart(g, 180 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;S&quot;, bDrawText);
 		drawRosePart(g, 270 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;W&quot;, bDrawText);
 	}
 
 	private void drawRosePart(Graphics g, float angle, Color colLeft, Color colRight, Color colBorder, Color colText, float scale, float innerScale, String strDir, boolean bDrawText) {
-		float angleRad = angle * (float)java.lang.Math.PI / 180;
-		float angleRadText = (angle + 7.5f) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = angle * (float) java.lang.Math.PI / 180;
+		float angleRadText = (angle + 7.5f) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * innerScale;
@@ -831,7 +854,7 @@
 		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
 		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
 
-		g.setPen(new Pen(colBorder,Pen.SOLID,1));
+		g.setPen(new Pen(colBorder, Pen.SOLID, 1));
 		g.setBrush(new Brush(colLeft, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
@@ -841,27 +864,26 @@
 		g.setBrush(new Brush(colRight, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
-		if (bDrawText){
+		if (bDrawText) {
 			int tempFontSize = new Float(scale * mainFont.getSize()).intValue();
 			Font tempFont = new Font(mainFont.getName(), Font.BOLD, tempFontSize);
 			g.setFont(tempFont);
 			FontMetrics tempFm = g.getFontMetrics(tempFont);
 			float stringHeight = tempFm.getHeight();
-			float stringWidth = tempFm.getTextWidth( strDir );
-			float stringGap = (float)java.lang.Math.sqrt(stringHeight*stringHeight + stringWidth*stringWidth);
+			float stringWidth = tempFm.getTextWidth(strDir);
+			float stringGap = (float) java.lang.Math.sqrt(stringHeight * stringHeight + stringWidth * stringWidth);
 
 			float stringPosition = arrowLength - stringGap / 2.0f;
 			g.setColor(colText);
-			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(),
-					centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
+			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(), centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
 
 			g.setFont(mainFont);
 		}
 	}
 
 	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.1f;
 
@@ -877,7 +899,7 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 	}
@@ -900,15 +922,14 @@
 		FontMetrics metrics = g.getFontMetrics(newFont);
 		int fontHeight = metrics.getHeight();
 
-		float ratio = (float)fontHeight / (float)size;
-		if(ratio &lt; 0.9 || ratio &gt; 1.1){
+		float ratio = (float) fontHeight / (float) size;
+		if (ratio &lt; 0.9 || ratio &gt; 1.1) {
 			size = (int) (size / ratio + 0.5);
-			if(size&lt;5)
-				size=5;
+			if (size &lt; 5)
+				size = 5;
 			newFont = new Font(name, style, size);
 		}
 
 		return newFont;
 	}
 }
-

Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -56,18 +56,16 @@
 import ewe.util.Vector;
 import ewe.util.mString;
 
-
 /**
- *
+ * 
  * start offset for language file: 4800
  */
 
-//Um Karten zu holen!
-//<A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|</A>
-//oder
-//<A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||</A>
+// Um Karten zu holen!
+// <A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|</A>
+// oder
+// <A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||</A>
 
-
 public class MapLoader {
 	InfoBox progressInfobox;
 
@@ -81,15 +79,16 @@
 	CWPoint bottomright;
 	Point tilesSize;
 	float tileScale;
-	boolean fetchOnlyMapWithCache=false;
+	boolean fetchOnlyMapWithCache = false;
 
 	/**
-	 *
+	 * 
 	 * @param prxy
 	 * @param prt
-	 * @param wmspath without trailing &quot;/&quot;
+	 * @param wmspath
+	 *            without trailing &quot;/&quot;
 	 */
-	public MapLoader(String wmspath){
+	public MapLoader(String wmspath) {
 		long start = new Time().getTime();
 		InfoBox progressBox = null;
 		boolean showprogress = false;
@@ -100,11 +99,11 @@
 		String FileName;
 		OnlineMapService tempOMS;
 		MessageBox f = null;
-		dateien = files.list(&quot;*.wms&quot;, FileBase.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
-		for(int i = 0; i &lt; dateien.length;i++){
+		dateien = files.list(&quot;*.wms&quot;, FileBase.LIST_FILES_ONLY); // &quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		for (int i = 0; i &lt; dateien.length; i++) {
 			FileName = dateien[i];
 			try {
-				if (!showprogress &amp;&amp; ((i &amp; 0) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
+				if (!showprogress &amp;&amp; ((i &amp; 0) == 0) &amp;&amp; (new Time().getTime() - start &gt; 100)) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
 					showprogress = true;
 					progressBox = new InfoBox(MyLocale.getMsg(327, &quot;Info&quot;), MyLocale.getMsg(4800, &quot;Loading online map services&quot;));
 					progressBox.exec();
@@ -113,8 +112,9 @@
 				}
 				tempOMS = new WebMapService(STRreplace.replace(wmspath + &quot;/&quot; + FileName, &quot;//&quot;, &quot;/&quot;));
 				onlineMapServices.add(tempOMS);
-			}catch(Exception ex){
-				if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4801, &quot;Ignoring error while \n reading web map service definition file \n&quot;)+ex.toString(), FormBase.OKB)).exec();
+			} catch (Exception ex) {
+				if (f == null)
+					(f = new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4801, &quot;Ignoring error while \n reading web map service definition file \n&quot;) + ex.toString(), FormBase.OKB)).exec();
 			}
 		}
 		tempOMS = new ExpediaMapService();
@@ -126,29 +126,32 @@
 	}
 
 	public void setFetchOnlyMapWithCache(boolean value) {
-		fetchOnlyMapWithCache=value;
+		fetchOnlyMapWithCache = value;
 	}
 
-	public String[] getAvailableOnlineMapServices(){
+	public String[] getAvailableOnlineMapServices() {
 		int s = onlineMapServices.size();
 		String[] services = new String[s];
-		for (int i=0; i &lt; s; i++) {
-			services[i]=onlineMapServices.get(i).toString();
+		for (int i = 0; i &lt; s; i++) {
+			services[i] = onlineMapServices.get(i).toString();
 		}
 		return services;
 	}
 
 	public void setCurrentMapService(int index) {
-		if (index==-1) index=0; // if no center set
+		if (index == -1)
+			index = 0; // if no center set
 		currentOnlineMapService = (OnlineMapService) onlineMapServices.get(index);
 	}
 
 	/**
 	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * 
 	 * @param center
-	 * @param distance in meters
+	 * @param distance
+	 *            in meters
 	 * @return meters per pixel calculatet in a way that the circle around center
-	 * is completly within the map
+	 *         is completly within the map
 	 */
 
 	public static float getScale(CWPoint center, float distance, Point size) {
@@ -161,17 +164,24 @@
 	/**
 	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
 	 * in path
-	 * @param center centre of all tiles
-	 * @param radius in meters
-	 * @param scale in &quot;alti&quot; value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
-	 * @param size in pixels
-	 * @param overlapping in pixels
-	 * @param path without &quot;/&quot; at the end
-	 *
+	 * 
+	 * @param center
+	 *            centre of all tiles
+	 * @param radius
+	 *            in meters
+	 * @param scale
+	 *            in &quot;alti&quot; value 1 alti = 3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size
+	 *            in pixels
+	 * @param overlapping
+	 *            in pixels
+	 * @param path
+	 *            without &quot;/&quot; at the end
+	 * 
 	 */
-	public void setTiles (CWPoint center, float radius, float scale, Point size, int overlapping) {
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+	public void setTiles(CWPoint center, float radius, float scale, Point size, int overlapping) {
+		double metersPerLat = (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec / 180 * java.lang.Math.PI);
 		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
 		bottomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
 
@@ -179,41 +189,41 @@
 	}
 
 	public void setTiles(CWPoint toplefti, CWPoint bottomrighti, float scale, Point size, int overlapping) {
-		//if (toplefti.latDec &lt;= bottomrighti.latDec || toplefti.lonDec &gt;= toplefti.lonDec) throw new IllegalArgumentException(&quot;topleft must be left and above bottom right&quot;);
+		// if (toplefti.latDec &lt;= bottomrighti.latDec || toplefti.lonDec &gt;= toplefti.lonDec) throw new IllegalArgumentException(&quot;topleft must be left and above bottom right&quot;);
 		topleft = new CWPoint(toplefti);
 		bottomright = new CWPoint(bottomrighti);
-		double metersPerLat = (1000.0 * (new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec)/2/180*java.lang.Math.PI);
+		double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
 		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
 		double pixelsPerLat = metersPerLat / metersperpixel;
 		double pixelsPerLon = metersPerLon / metersperpixel;
 
-		//over all pixelsize without borders
+		// over all pixelsize without borders
 		double pixelsY = (topleft.latDec - bottomright.latDec) * pixelsPerLat;
-		double pixelsX = -(topleft.lonDec - bottomright.lonDec) * pixelsPerLon ;
+		double pixelsX = -(topleft.lonDec - bottomright.lonDec) * pixelsPerLon;
 
-		//border sizes around given area and overlapping between tiles
-		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
-		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		// border sizes around given area and overlapping between tiles
+		// int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		// int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
 		int borderX = overlapping;
 		int borderY = overlapping;
 
-		numMapsY = (int) java.lang.Math.ceil( (pixelsY + borderY) / (size.y - borderY) );
-		numMapsX = (int) java.lang.Math.ceil( (pixelsX + borderX) / (size.x - borderX) );
+		numMapsY = (int) java.lang.Math.ceil((pixelsY + borderY) / (size.y - borderY));
+		numMapsX = (int) java.lang.Math.ceil((pixelsX + borderX) / (size.x - borderX));
 
-		//increments calulated from pixel offset of tiles
+		// increments calulated from pixel offset of tiles
 		latinc = -(size.y - borderY) / pixelsPerLat;
 		loninc = (size.x - borderX) / pixelsPerLon;
 
-		//calculation of centre of first tile
+		// calculation of centre of first tile
 
-		//additional size for borders and rounding
+		// additional size for borders and rounding
 		double oversizeX = (numMapsX * (size.x - borderX) + borderX) - pixelsX;
 		double oversizeY = (numMapsY * (size.y - borderY) + borderY) - pixelsY;
 
-		//offset for upper left corner
-		double offsetLat = -( (size.y - oversizeY) / 2.0 ) / pixelsPerLat;
-		double offsetLon = ( (size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		// offset for upper left corner
+		double offsetLat = -((size.y - oversizeY) / 2.0) / pixelsPerLat;
+		double offsetLon = ((size.x - oversizeX) / 2.0) / pixelsPerLon;
 
 		topleft.latDec += offsetLat;
 		topleft.lonDec += offsetLon;
@@ -231,48 +241,53 @@
 			lon = topleft.lonDec;
 			for (int col = 1; col &lt;= numMapsX; col++) {
 				center.set(lat, lon);
-				if (!fetchOnlyMapWithCache || hasCache(center,latinc,loninc)) {
+				if (!fetchOnlyMapWithCache || hasCache(center, latinc, loninc)) {
 					if (progressInfobox != null)
-						progressInfobox.setInfo(MyLocale.getMsg(4802, &quot;Downloading calibrated (georeferenced) \n map image \n '&quot;) + currentOnlineMapService.getName()+MyLocale.getMsg(4803, &quot;' \n Downloading tile \n row&quot;)+&quot; &quot;+row+&quot; / &quot;+numMapsY+MyLocale.getMsg(4804, &quot; column&quot;)+&quot; &quot;+ col + &quot; / &quot;+numMapsX);
+						progressInfobox.setInfo(MyLocale.getMsg(4802, &quot;Downloading calibrated (georeferenced) \n map image \n '&quot;) + currentOnlineMapService.getName() + MyLocale.getMsg(4803, &quot;' \n Downloading tile \n row&quot;) + &quot; &quot; + row + &quot; / &quot; + numMapsY
+								+ MyLocale.getMsg(4804, &quot; column&quot;) + &quot; &quot; + col + &quot; / &quot; + numMapsX);
 					try {
 						downloadMap(center, tileScale, tilesSize, tilesPath);
 					} catch (Exception e) {
-						this.progressInfobox.addWarning(MyLocale.getMsg(4805, &quot;Tile&quot;)+&quot; &quot; + row + &quot;/&quot; + col + MyLocale.getMsg(4806, &quot;: Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+						this.progressInfobox.addWarning(MyLocale.getMsg(4805, &quot;Tile&quot;) + &quot; &quot; + row + &quot;/&quot; + col + MyLocale.getMsg(4806, &quot;: Ignoring error:&quot;) + &quot; &quot; + e.getMessage() + &quot;\n&quot;);
 					}
-					if (progressInfobox.isClosed) return;
+					if (progressInfobox.isClosed)
+						return;
 				}
 				lon += loninc;
 			}
 			lat += latinc;
 		}
 	}
+
 	private boolean hasCache(CWPoint center, double latinc, double loninc) {
 		double lat = center.latDec - (latinc / 2.0);
 		double lon = center.lonDec - (loninc / 2.0);
-		CWPoint tl = new CWPoint(lat,lon);
+		CWPoint tl = new CWPoint(lat, lon);
 		lat = center.latDec + (latinc / 2.0);
 		lon = center.lonDec + (loninc / 2.0);
-		CWPoint br = new CWPoint(lat,lon);
-		Area maparea = new Area(tl,br);
+		CWPoint br = new CWPoint(lat, lon);
+		Area maparea = new Area(tl, br);
 		CacheDB cacheDB = Global.getProfile().cacheDB;
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			CacheHolder ch = cacheDB.get(i);
-			if (maparea.isInBound(ch.pos)) {
+			if (maparea.isInBound(ch.getPos())) {
 				return true;
 			}
 		}
 		return false;
 	}
 
-	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+	public void setProgressInfoBox(InfoBox progrssInfoboxi) {
 		progressInfobox = progrssInfoboxi;
 	}
+
 	/**
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
-	 * @param path must include trailing &quot;/&quot;
+	 * @param path
+	 *            must include trailing &quot;/&quot;
 	 * @throws Exception
 	 */
 	public void downloadMap(CWPoint center, float scale, Point pixelsize, String path) throws Exception {
@@ -284,26 +299,24 @@
 		String fName = path + imagename + imagetype;
 		FileBugfix fn = new FileBugfix(path + imagename + &quot;.wfl&quot;);
 		FileBugfix fn1 = new FileBugfix(fName);
-		if (!fn.exists() || fn.length()==0 || !fn1.exists() || fn1.length()==0) {
+		if (!fn.exists() || fn.length() == 0 || !fn1.exists() || fn1.length() == 0) {
 			if (currentOnlineMapService instanceof ExpediaMapService) {
-				downloadImage(url, path+imagename+imagetype);
-			}
-			else {
+				downloadImage(url, path + imagename + imagetype);
+			} else {
 				WebMapService wms = (WebMapService) currentOnlineMapService;
 				if (wms.requestUrlPart.startsWith(&quot;REQUEST&quot;)) {
-					downloadImage(url, path+imagename+imagetype);
-				}
-				else {
+					downloadImage(url, path + imagename + imagetype);
+				} else {
 					Area maparea = wms.CenterScaleToArea(center, scale, pixelsize);
-					CWPoint bottomleft = new CWPoint (maparea.bottomright.latDec, maparea.topleft.lonDec);
-					CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.bottomright.lonDec);
+					CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+					CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 
-					String mapProgramPath = wms.versionUrlPart+&quot;/&quot;;
+					String mapProgramPath = wms.versionUrlPart + &quot;/&quot;;
 					mapProgramPath = mapProgramPath.replace('/', FileBase.separatorChar);
-					String mapProgram = mapProgramPath+wms.MainUrl;
-					File f=new FileBugfix(mapProgram);
+					String mapProgram = mapProgramPath + wms.MainUrl;
+					File f = new FileBugfix(mapProgram);
 					if (!f.exists() || !f.canRead()) {
-						MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1834,&quot;Please enter the correct path to Kosmos.Console.exe into the wms-file.&quot;),ewe.ui.MessageBox.OKB);
+						MessageBox mb = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1834, &quot;Please enter the correct path to Kosmos.Console.exe into the wms-file.&quot;), ewe.ui.MessageBox.OKB);
 						mb.execute();
 						return;
 					}
@@ -312,68 +325,59 @@
 
 					if (wms.requestUrlPart.equalsIgnoreCase(&quot;Kosmos&quot;)) {
 						// minx miny maxx maxy + pixelsize.x
-						mapProgramParams=&quot;bitmapgen&quot; +
-							&quot; \&quot;&quot;+FileBase.getProgramDirectory().replace('/',File.separatorChar)+&quot;\\&quot;+wms.serviceTypeUrlPart+&quot;\&quot;&quot;+
-							&quot; \&quot;&quot;+path.replace('/', File.separatorChar)+imagename+imagetype+&quot;\&quot;&quot;+
-							&quot; -mb &quot; +
-							bottomleft.toString(TransformCoordinates.LAT_LON).replace(',',' ') + &quot; &quot; +
-							topright.toString(TransformCoordinates.LAT_LON).replace(',',' ') +
-							&quot; -w &quot;+pixelsize.x;
+						mapProgramParams = &quot;bitmapgen&quot; + &quot; \&quot;&quot; + FileBase.getProgramDirectory().replace('/', File.separatorChar) + &quot;\\&quot; + wms.serviceTypeUrlPart + &quot;\&quot;&quot; + &quot; \&quot;&quot; + path.replace('/', File.separatorChar) + imagename + imagetype + &quot;\&quot;&quot;
+								+ &quot; -mb &quot; + bottomleft.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + &quot; &quot; + topright.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + &quot; -w &quot; + pixelsize.x;
 						Vm.exec(mapProgram, mapProgramParams, 0, true);
-					}
-					else {
+					} else {
 						if (wms.requestUrlPart.equalsIgnoreCase(&quot;Maperitive&quot;)) {
 							// Maperitive runs on Windows and Linux
 							// generating scriptfile for Maperitive from wmsfile
-							String cwPath = FileBase.getProgramDirectory().replace('/',FileBase.separatorChar) + FileBase.separatorChar;
+							String cwPath = FileBase.getProgramDirectory().replace('/', FileBase.separatorChar) + FileBase.separatorChar;
 							String scriptFileName = cwPath + &quot;maperitive.script&quot;;
 
-							PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(scriptFileName)));
+							PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(scriptFileName)));
 							outp.println(&quot;use-ruleset alias=default&quot;);
 							outp.println(&quot;clear-map&quot;);
 
 							if (wms.serviceTypeUrlPart.equals(&quot;&quot;)) {
 								outp.println(&quot;add-web-map&quot;);
-							}
-							else {
+							} else {
 								outp.println(&quot;add-web-map provider=&quot; + wms.serviceTypeUrlPart);
 							}
 
 							if (!wms.stylesUrlPart.equals(&quot;&quot;)) {
-								String myrules = mapProgramPath + wms.stylesUrlPart.replace('/',FileBase.separatorChar);
+								String myrules = mapProgramPath + wms.stylesUrlPart.replace('/', FileBase.separatorChar);
 								outp.println(&quot;use-ruleset location=&quot; + myrules);
 								// outp.println(&quot;apply-ruleset&quot;);
 							}
 							if (!wms.layersUrlPart.equals(&quot;&quot;)) {
 								outp.println(&quot;clear-map&quot;);
-								outp.println(&quot;load-source &quot; + mapProgramPath + wms.layersUrlPart.replace('/',FileBase.separatorChar));
+								outp.println(&quot;load-source &quot; + mapProgramPath + wms.layersUrlPart.replace('/', FileBase.separatorChar));
 								// implicit does apply-ruleset
 							}
 
 							String koords = bottomleft.toString(TransformCoordinates.LON_LAT) + &quot;,&quot; + topright.toString(TransformCoordinates.LON_LAT);
-							outp.println(&quot;bounds-set &quot;+koords);
+							outp.println(&quot;bounds-set &quot; + koords);
 							outp.println(&quot;zoom-bounds&quot;);
-							if ( path.indexOf(':') == 1) {
+							if (path.indexOf(':') == 1) {
 								outp.print(&quot;export-bitmap file=&quot; + &quot;\&quot;&quot; + fName + &quot;\&quot;&quot;);
-							}
-							else {
+							} else {
 								outp.print(&quot;export-bitmap file=&quot; + fName);
 							}
-							outp.print(&quot; bounds=&quot;+ koords);
-							String pxSize = &quot; width=&quot;+pixelsize.x + &quot; height=&quot;+pixelsize.y;
+							outp.print(&quot; bounds=&quot; + koords);
+							String pxSize = &quot; width=&quot; + pixelsize.x + &quot; height=&quot; + pixelsize.y;
 							outp.print(pxSize);
 							outp.println(&quot; kml=false&quot;);
 							outp.close();
 							// executing the generated script
 							if (mapProgram.indexOf(':') == 1) {
 								mapProgramParams = &quot;-exitafter &quot; + &quot;\&quot;&quot; + scriptFileName + &quot;\&quot;&quot;;
-							}
-							else {
+							} else {
 								mapProgramParams = &quot;-exitafter &quot; + scriptFileName;
 							}
 							Vm.exec(mapProgram, mapProgramParams, 0, true);
 							// preparation for generating wfl from the ozi map-file
-							Vector GCPs = map2wfl(path+imagename);
+							Vector GCPs = map2wfl(path + imagename);
 							mio.evalGCP(GCPs, pixelsize.x, pixelsize.y);
 							// can not supress genaration of pgw,jgw-file
 							FileBugfix pgwFile = new FileBugfix(path + imagename + &quot;.pgw&quot;); // seems to bee for png
@@ -391,54 +395,62 @@
 	private Vector map2wfl(String pathAndImageName) {
 		Vector GCPs = new Vector();
 		File mapFile = new File(pathAndImageName + &quot;.map&quot;);
-		if(mapFile.exists()){
+		if (mapFile.exists()) {
 			GCPoint gcp1 = new GCPoint();
 			GCPoint gcp2 = new GCPoint();
 			GCPoint gcp3 = new GCPoint();
 			GCPoint gcp4 = new GCPoint();
 			GCPoint gcpG = new GCPoint();
-			String line=&quot;&quot;;
+			String line = &quot;&quot;;
 			String[] parts;
 			try {
 				FileReader inMap = new FileReader(pathAndImageName + &quot;.map&quot;);
-				while((line = inMap.readLine()) != null){
-					if(line.equals(&quot;MMPNUM,4&quot;)){
+				while ((line = inMap.readLine()) != null) {
+					if (line.equals(&quot;MMPNUM,4&quot;)) {
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp1.bitMapX = Convert.toInt(parts[2]);
 						gcp1.bitMapY = Convert.toInt(parts[3]);
-						if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
-						if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+						if (gcp1.bitMapX == 0)
+							gcp1.bitMapX = 1;
+						if (gcp1.bitMapY == 0)
+							gcp1.bitMapY = 1;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp2.bitMapX = Convert.toInt(parts[2]);
 						gcp2.bitMapY = Convert.toInt(parts[3]);
-						if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
-						if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+						if (gcp2.bitMapX == 0)
+							gcp2.bitMapX = 1;
+						if (gcp2.bitMapY == 0)
+							gcp2.bitMapY = 1;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp3.bitMapX = Convert.toInt(parts[2]);
 						gcp3.bitMapY = Convert.toInt(parts[3]);
-						if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
-						if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
-						//imageWidth = gcp3.bitMapX;
-						//imageHeight = gcp3.bitMapY;
+						if (gcp3.bitMapX == 0)
+							gcp3.bitMapX = 1;
+						if (gcp3.bitMapY == 0)
+							gcp3.bitMapY = 1;
+						// imageWidth = gcp3.bitMapX;
+						// imageHeight = gcp3.bitMapY;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp4.bitMapX = Convert.toInt(parts[2]);
 						gcp4.bitMapY = Convert.toInt(parts[3]);
-						if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
-						if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+						if (gcp4.bitMapX == 0)
+							gcp4.bitMapX = 1;
+						if (gcp4.bitMapY == 0)
+							gcp4.bitMapY = 1;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp1.bitMapX;
@@ -447,9 +459,9 @@
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp2.bitMapX;
@@ -458,9 +470,9 @@
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp3.bitMapX;
@@ -469,9 +481,9 @@
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp4.bitMapX;
@@ -480,9 +492,9 @@
 					} // if
 				} // while
 				inMap.close();
-			} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+			} catch (IllegalArgumentException ex) { // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
 				Global.getPref().log(MyLocale.getMsg(4117, &quot;Error while importing .map-file: &quot;), ex);
-			} catch(IOException ex){
+			} catch (IOException ex) {
 				Global.getPref().log(MyLocale.getMsg(4118, &quot;IO-Error while reading or writing calibration file&quot;), ex);
 			}
 			mapFile.delete();
@@ -493,17 +505,18 @@
 	}
 
 	public String createFilename(CWPoint center, float scale) {
-		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem()+&quot;_s&quot;+Common.DoubleToString(scale,0,1)
-				+ &quot;_c&quot; + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
+		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem() + &quot;_s&quot; + Common.DoubleToString(scale, 0, 1) + &quot;_c&quot; + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
 		return filename;
 	}
 
 	/**
-	 * @param url usual URL. If a redirect is requiered (as in the case of
-	 * Expedia, add an &quot;R&quot; before &quot;<A HREF="http://">http://</A>&quot; --&gt; Don't download the url, retry until getting a http-redirect
-	 * this is necessary for expedia as it delivers the image only after a http-redirect
-	 * and sometimes doesn't send a redirect on the first try
-	 * @param datei path and name of file to save to
+	 * @param url
+	 *            usual URL. If a redirect is requiered (as in the case of
+	 *            Expedia, add an &quot;R&quot; before &quot;<A HREF="http://">http://</A>&quot; --&gt; Don't download the url, retry until getting a http-redirect
+	 *            this is necessary for expedia as it delivers the image only after a http-redirect
+	 *            and sometimes doesn't send a redirect on the first try
+	 * @param datei
+	 *            path and name of file to save to
 	 */
 	public void downloadImage(String url, String datei) throws IOException {
 		String realurl;
@@ -516,19 +529,20 @@
 			realurl = url;
 		}
 		File dateiF = new FileBugfix(datei);
-		if(!dateiF.exists()){
-			if (forceredirect) UrlFetcher.setForceRedirect();
+		if (!dateiF.exists()) {
+			if (forceredirect)
+				UrlFetcher.setForceRedirect();
 			UrlFetcher.fetchDataFile(realurl, datei);
-			String ct=null;
+			String ct = null;
 			try {
-				ct = (String) UrlFetcher.getDocumentProperties().getValue(&quot;content-type&quot;,&quot;no-content-type provided&quot;);
+				ct = (String) UrlFetcher.getDocumentProperties().getValue(&quot;content-type&quot;, &quot;no-content-type provided&quot;);
 			} catch (Exception e) {
-				ct=&quot;document property content-type does not exist!&quot;;
+				ct = &quot;document property content-type does not exist!&quot;;
 			}
-			if (!ct.substring(0, 5).equalsIgnoreCase(&quot;image&quot;) )  {
+			if (!ct.substring(0, 5).equalsIgnoreCase(&quot;image&quot;)) {
 				dateiF = new FileBugfix(datei);
 				dateiF.delete();
-				throw new IOException(MyLocale.getMsg(4808, &quot;downloadImage: content-type:&quot;)+&quot; &quot; + ct + MyLocale.getMsg(4809, &quot; is not an image, begin of content:&quot;)+&quot; (deleted)&quot;);
+				throw new IOException(MyLocale.getMsg(4808, &quot;downloadImage: content-type:&quot;) + &quot; &quot; + ct + MyLocale.getMsg(4809, &quot; is not an image, begin of content:&quot;) + &quot; (deleted)&quot;);
 			}
 		}
 	}
@@ -541,7 +555,7 @@
 	String mapType;
 	/** Esentially the same as name, but used for the file system. It will be part of the names of the downloaded images */
 	String filename;
-	String MainUrl; //<A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS</A>
+	String MainUrl; // <A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS</A>
 	/** including &quot;.&quot; */
 	String imageFileExt; // &quot;.gif&quot;, &quot;.jpg&quot;...
 	double recommendedScales[];
@@ -554,7 +568,7 @@
 	 * This method is used in case the online map service provides only certain steps of
 	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
 	 * will be used instead of the wished scale.
-	 *
+	 * 
 	 * @param scale
 	 * @return
 	 */
@@ -568,6 +582,7 @@
 
 	/**
 	 * Overlaod this to integrate name of layers
+	 * 
 	 * @return friendly service name
 	 */
 	public String getName() {
@@ -578,6 +593,7 @@
 	 * This method is called to get a name of the
 	 * online map service which will be part of the filename
 	 * used for the downloaded image
+	 * 
 	 * @return friendly service name
 	 */
 	public String getNameForFileSystem() {
@@ -587,10 +603,12 @@
 	public String getMapType() {
 		return mapType;
 	}
+
 	/**
 	 * Overload this and return the URL to the map image, don't call super
 	 * Alternatively overload getUrlForBoundingBoxInternal
 	 * You must overload either this method or getUrlForBoundingBox
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -606,6 +624,7 @@
 	 * This is made protected and named &quot;...Internal&quot; because a lot of services
 	 * don't work correctly when a map is requested, that is not exactly quadratic
 	 * --&gt; alway use getUrlForCenter...
+	 * 
 	 * @param surArea
 	 * @param pixelsize
 	 * @return
@@ -617,6 +636,7 @@
 	/**
 	 * overload this if your map service uses a special projection
 	 * an return an Area that is quadratic in that projection
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -624,19 +644,19 @@
 	 */
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
-		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y)/2 * scale / 1000;
+		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y) / 2 * scale / 1000;
 		bbox.topleft = center.project(-45, halfdiagonal);
 		bbox.bottomright = center.project(135, halfdiagonal);
 		return bbox;
 	}
 
-
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
 		throw new IllegalArgumentException(MyLocale.getMsg(4811, &quot;OnlineMapService: getMapInfoObjectInternal(Area maparea, Point pixelsize):\n This method must be overloaded in order to be able to use it&quot;));
 	}
 
 	/**
 	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -654,9 +674,9 @@
 class WebMapService extends OnlineMapService {
 	String layersUrlPart; //
 	String versionUrlPart; // VERSION=1.1.0
-	String serviceTypeUrlPart; //&quot;SERVICE=WMS&quot;
+	String serviceTypeUrlPart; // &quot;SERVICE=WMS&quot;
 	int coordinateReferenceSystem[]; // WGS84: 4326, German GK: 31466 /
-	String coordinateReferenceSystemUrlPart[]; //&amp;SRS=EPSG:31466
+	String coordinateReferenceSystemUrlPart[]; // &amp;SRS=EPSG:31466
 	public String requestUrlPart;
 	String imageFormatUrlPart; // FORMAT=image/png
 	String stylesUrlPart; // STYLES=
@@ -664,12 +684,13 @@
 	double maxscaleWMS;
 
 	/**
-	 *
-	 * @param filename without file extension
+	 * 
+	 * @param filename
+	 *            without file extension
 	 * @throws IOException
 	 * @throws IllegalArgumentException
 	 */
-	public WebMapService (String filename_) throws IOException, IllegalArgumentException{
+	public WebMapService(String filename_) throws IOException, IllegalArgumentException {
 		FileInputStream in = new FileInputStream(filename_);
 		Properties wms = new Properties();
 		wms.load(in);
@@ -677,65 +698,80 @@
 		String tmp = FileBase.getFileExt(filename_);
 		this.filename = tmp.substring(0, tmp.lastIndexOf('.'));
 		name = wms.getProperty(&quot;Name&quot;, &quot;&quot;).trim();
-		if (name == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4812, &quot;WebMapService: property &gt;Name:&lt; missing in file:\n&quot;) + filename);
-		MainUrl = wms.getProperty(&quot;MainUrl&quot;, &quot;&quot;).trim();;
-		if (MainUrl == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4813, &quot;WebMapService: property &gt;MainUrl:&lt; missing in file:\n&quot;) + filename);
+		if (name == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4812, &quot;WebMapService: property &gt;Name:&lt; missing in file:\n&quot;) + filename);
+		MainUrl = wms.getProperty(&quot;MainUrl&quot;, &quot;&quot;).trim();
+		;
+		if (MainUrl == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4813, &quot;WebMapService: property &gt;MainUrl:&lt; missing in file:\n&quot;) + filename);
 		mapType = wms.getProperty(&quot;MapType&quot;, &quot;maptype_unknown&quot;).trim();
 		serviceTypeUrlPart = wms.getProperty(&quot;ServiceTypeUrlPart&quot;, &quot;SERVICE=WMS&quot;).trim();
-		layersUrlPart = wms.getProperty(&quot;LayersUrlPart&quot;, &quot;&quot;).trim();;
-		versionUrlPart = wms.getProperty(&quot;VersionUrlPart&quot;, &quot;&quot;).trim();;
+		layersUrlPart = wms.getProperty(&quot;LayersUrlPart&quot;, &quot;&quot;).trim();
+		;
+		versionUrlPart = wms.getProperty(&quot;VersionUrlPart&quot;, &quot;&quot;).trim();
+		;
 		tmp = wms.getProperty(&quot;CoordinateReferenceSystemCacheWolf&quot;, &quot;&quot;).trim();
-		if (tmp.equals(&quot;&quot;)) throw new IllegalArgumentException(MyLocale.getMsg(4814, &quot;WebMapService: no CoordinateReferenceSystemCacheWolf given&quot;));
+		if (tmp.equals(&quot;&quot;))
+			throw new IllegalArgumentException(MyLocale.getMsg(4814, &quot;WebMapService: no CoordinateReferenceSystemCacheWolf given&quot;));
 		String[] tmp2 = mString.split(tmp, ' ');
 		coordinateReferenceSystem = new int[tmp2.length];
 		for (int i = 0; i &lt; tmp2.length; i++) {
 			coordinateReferenceSystem[i] = Common.parseInt(tmp2[i].trim());
-			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i])) throw new IllegalArgumentException(MyLocale.getMsg(4815, &quot;Coordinate reference system not supported by CacheWolf:\n&quot;) + coordinateReferenceSystem[i]);
+			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i]))
+				throw new IllegalArgumentException(MyLocale.getMsg(4815, &quot;Coordinate reference system not supported by CacheWolf:\n&quot;) + coordinateReferenceSystem[i]);
 		}
 		tmp = wms.getProperty(&quot;CoordinateReferenceSystemUrlPart&quot;, &quot;&quot;).trim();
-		if (tmp == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4816, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; missing in file:\n&quot;) + filename);
+		if (tmp == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4816, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; missing in file:\n&quot;) + filename);
 		tmp2 = mString.split(tmp, ' ');
-		if (tmp2.length != coordinateReferenceSystem.length) throw new IllegalArgumentException(MyLocale.getMsg(4817, &quot;number of strings in CoordinateReferenceSystemUrlPart (&quot;)+tmp2.length+MyLocale.getMsg(4818, &quot;) must match the number of codes in CoordinateReferenceSystemCacheWolf (&quot;)+coordinateReferenceSystem.length+MyLocale.getMsg(4819, &quot;) use normal space as separator&quot;));
+		if (tmp2.length != coordinateReferenceSystem.length)
+			throw new IllegalArgumentException(MyLocale.getMsg(4817, &quot;number of strings in CoordinateReferenceSystemUrlPart (&quot;) + tmp2.length + MyLocale.getMsg(4818, &quot;) must match the number of codes in CoordinateReferenceSystemCacheWolf (&quot;)
+					+ coordinateReferenceSystem.length + MyLocale.getMsg(4819, &quot;) use normal space as separator&quot;));
 		coordinateReferenceSystemUrlPart = new String[tmp2.length];
 		for (int i = 0; i &lt; tmp2.length; i++) {
 			coordinateReferenceSystemUrlPart[i] = tmp2[i].trim();
-			if (coordinateReferenceSystemUrlPart[i] == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4820, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; incorrect in file:\n&quot;) + filename);
+			if (coordinateReferenceSystemUrlPart[i] == &quot;&quot;)
+				throw new IllegalArgumentException(MyLocale.getMsg(4820, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; incorrect in file:\n&quot;) + filename);
 		}
 		requestUrlPart = wms.getProperty(&quot;RequestUrlPart&quot;, &quot;REQUEST=GetMap&quot;).trim();
 		imageFormatUrlPart = wms.getProperty(&quot;ImageFormatUrlPart&quot;, &quot;&quot;).trim();
 		stylesUrlPart = wms.getProperty(&quot;StylesUrlPart&quot;, &quot;&quot;).trim();
 		String topleftS = wms.getProperty(&quot;BoundingBoxTopLeftWGS84&quot;, &quot;&quot;).trim();
 		String bottomrightS = wms.getProperty(&quot;BoundingBoxBottomRightWGS84&quot;);
-		//To be backward-compatible with mispelled property-name: Don't remove these lines until all wms-Files has been changed
-		if (bottomrightS == null){
-		    bottomrightS = wms.getProperty(&quot;BoundingBoxButtomRightWGS84&quot;, &quot;&quot;);
+		// To be backward-compatible with mispelled property-name: Don't remove these lines until all wms-Files has been changed
+		if (bottomrightS == null) {
+			bottomrightS = wms.getProperty(&quot;BoundingBoxButtomRightWGS84&quot;, &quot;&quot;);
 		}
 		bottomrightS.trim();
 		CWPoint topleft = new CWPoint(topleftS);
 		CWPoint bottomright = new CWPoint(bottomrightS);
-		if (!topleft.isValid()) topleft.set(90, -180);
-		if (!bottomright.isValid()) bottomright.set(-90, 180);
-		boundingBox = new Area (topleft, bottomright);
+		if (!topleft.isValid())
+			topleft.set(90, -180);
+		if (!bottomright.isValid())
+			bottomright.set(-90, 180);
+		boundingBox = new Area(topleft, bottomright);
 		minscaleWMS = Common.parseDouble(wms.getProperty(&quot;MinScale&quot;, &quot;0&quot;).trim());
 		maxscaleWMS = Common.parseDouble(wms.getProperty(&quot;MaxScale&quot;, Convert.toString(java.lang.Double.MAX_VALUE)).trim());
 		minscale = minscaleWMS / Math.sqrt(2); // in WMS scale is measured diagonal while in CacheWolf it is measured vertical
 		maxscale = maxscaleWMS / Math.sqrt(2);
 		imageFileExt = wms.getProperty(&quot;ImageFileExtension&quot;, &quot;&quot;).trim();
-		if (imageFileExt == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4821, &quot;WebMapService: property &gt;ImageFileExtension:&lt; missing in file:\n&quot;) + filename);
-		String [] recommendedScalesStr = mString.split(wms.getProperty(&quot;RecommendedScale&quot;, &quot;5&quot;).trim(), ' ');
+		if (imageFileExt == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4821, &quot;WebMapService: property &gt;ImageFileExtension:&lt; missing in file:\n&quot;) + filename);
+		String[] recommendedScalesStr = mString.split(wms.getProperty(&quot;RecommendedScale&quot;, &quot;5&quot;).trim(), ' ');
 		// convert recommended scales to doube[], sort them and set preselected recommended scale
 		if (recommendedScalesStr.length &gt; 0) {
 			double preselected = Common.parseDouble(recommendedScalesStr[0]);
 			Double[] recommendedScalesObj = new Double[recommendedScalesStr.length];
-			for (int i=0; i &lt; recommendedScalesObj.length; i++) {
+			for (int i = 0; i &lt; recommendedScalesObj.length; i++) {
 				recommendedScalesObj[i] = new Double();
 				recommendedScalesObj[i].set(Common.parseDouble(recommendedScalesStr[i].replace(',', '.')));
 			}
 			Utils.sort(recommendedScalesObj, new StandardComparer(), false);
 			recommendedScales = new double[recommendedScalesStr.length];
-			for (int i=0; i &lt; recommendedScales.length; i++) {
+			for (int i = 0; i &lt; recommendedScales.length; i++) {
 				recommendedScales[i] = recommendedScalesObj[i].value;
-				if (recommendedScales[i] == preselected) preselectedRecScaleIndex = i;
+				if (recommendedScales[i] == preselected)
+					preselectedRecScaleIndex = i;
 			}
 		}
 	}
@@ -744,36 +780,40 @@
 	private static final int BOTTOMRIGHT_INDEX = 1;
 	private static final int TOPRIGHT_INDEX = 2;
 	private static final int BOTTOMLEFT_INDEX = 3;
+
 	/**
-	 *
+	 * 
 	 * @param maparea
 	 * @return [0] = topleft, [1] = bottomright, [2] = topright, [3] = bottomleft
 	 */
 	private ProjectedPoint[] getGkArea(Area maparea) {
 		ProjectedPoint[] ret = new ProjectedPoint[4];
-	//	CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
-	//	CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		// CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+		// CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
 		int crs = getCrs(maparea.getCenter());
 		// FIXME region is never read. Needed?
 		// int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[crs]);
 		ret[TOPLEFT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.topleft, coordinateReferenceSystem[crs]);
 		ret[BOTTOMRIGHT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.bottomright, coordinateReferenceSystem[crs]);
-		ret[TOPRIGHT_INDEX] =  ret[BOTTOMRIGHT_INDEX].cloneIt();
-		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BOTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
+		ret[TOPRIGHT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
+		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BOTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
 		ret[BOTTOMLEFT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
-		ret[BOTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BOTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
-		//ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
-		//ret[3] = TransformCoordinates.wgs84ToGermanGk(bottomleft, coordinateReferenceSystem[crs]);
+		ret[BOTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BOTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
+		// ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
+		// ret[3] = TransformCoordinates.wgs84ToGermanGk(bottomleft, coordinateReferenceSystem[crs]);
 		return ret;
 	}
+
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if (region &gt; 0 ) {
+		if (region &gt; 0) {
 			int epsg = coordinateReferenceSystem[getCrs(center)];
 			ProjectedPoint cgk = TransformCoordinates.wgs84ToEpsg(center, epsg);
 			ProjectedPoint tlgk = cgk.cloneIt();
-			tlgk.shift(- pixelsize.x * scale / 2, 1);
+			tlgk.shift(-pixelsize.x * scale / 2, 1);
 			tlgk.shift(pixelsize.y * scale / 2, 0);
 			ProjectedPoint brgk = cgk.cloneIt();
 			brgk.shift(pixelsize.x * scale / 2, 1);
@@ -791,21 +831,25 @@
 				bbox.bottomright.shift(pixelsize.x * scale / 2, 1);
 				bbox.bottomright.shift(-pixelsize.y * scale / 2, 0);
 				break;
-			default: throw new IllegalArgumentException(&quot;CenterScaleToArea: epsg: &quot; + coordinateReferenceSystem[0] + &quot; not supported&quot;);
+			default:
+				throw new IllegalArgumentException(&quot;CenterScaleToArea: epsg: &quot; + coordinateReferenceSystem[0] + &quot; not supported&quot;);
 			}
 		}
 		return bbox;
 	}
 
 	protected String getUrlForBoundingBoxInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;)+&quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;)+&quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;)+&quot; &quot; + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;) + &quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;) + &quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;) + &quot; &quot; + boundingBox.toString());
 		// <A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png</A>
-		CWPoint bottomleft = new CWPoint (maparea.bottomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.bottomright.lonDec);
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 		double scaleh = maparea.bottomright.getDistance(bottomleft) * 1000 / pixelsize.x;
 		double scalev = maparea.topleft.getDistance(topright) * 1000 / pixelsize.y;
 		double scale = Math.sqrt(scaleh * scaleh + scalev * scalev); // meters per pixel measured diagonal
-		if ( scale &lt; minscaleWMS || scale &gt; maxscaleWMS ) throw new IllegalArgumentException(MyLocale.getMsg(4825, &quot;scale&quot;)+&quot; &quot; + scale / Math.sqrt(2)+ MyLocale.getMsg(4826, &quot; not supported by online map service, supported scale range:&quot;)+&quot; &quot; + minscale + &quot; - &quot; + maxscale + MyLocale.getMsg(4827, &quot; (measured in meters per pixel vertically)&quot;));
+		if (scale &lt; minscaleWMS || scale &gt; maxscaleWMS)
+			throw new IllegalArgumentException(MyLocale.getMsg(4825, &quot;scale&quot;) + &quot; &quot; + scale / Math.sqrt(2) + MyLocale.getMsg(4826, &quot; not supported by online map service, supported scale range:&quot;) + &quot; &quot; + minscale + &quot; - &quot; + maxscale
+					+ MyLocale.getMsg(4827, &quot; (measured in meters per pixel vertically)&quot;));
 		int crs = 0;
 		String bbox = &quot;BBOX=&quot;;
 		int localsystem = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
@@ -817,12 +861,11 @@
 			bbox += TransformCoordinates.wgs84ToEpsg(bottomleft, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;);
 			bbox += &quot;,&quot; + TransformCoordinates.wgs84ToEpsg(topright, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;);
 		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84)
-			bbox += bottomleft.toString(TransformCoordinates.LON_LAT)  + &quot;,&quot; + topright.toString(TransformCoordinates.LON_LAT);
-		else throw new IllegalArgumentException(MyLocale.getMsg(4828, &quot;Coordinate system not supported by cachewolf:&quot;)+&quot; &quot; + coordinateReferenceSystem.toString());
-		String ret = MainUrl + serviceTypeUrlPart + &quot;&amp;&quot; + versionUrlPart + &quot;&amp;&quot; + requestUrlPart + &quot;&amp;&quot; +
-		coordinateReferenceSystemUrlPart[crs] + &quot;&amp;&quot; + bbox +
-		&quot;&amp;WIDTH=&quot; + pixelsize.x + &quot;&amp;HEIGHT=&quot; + pixelsize.y + &quot;&amp;&quot; +
-		layersUrlPart + &quot;&amp;&quot; + stylesUrlPart + &quot;&amp;&quot; + imageFormatUrlPart;
+			bbox += bottomleft.toString(TransformCoordinates.LON_LAT) + &quot;,&quot; + topright.toString(TransformCoordinates.LON_LAT);
+		else
+			throw new IllegalArgumentException(MyLocale.getMsg(4828, &quot;Coordinate system not supported by cachewolf:&quot;) + &quot; &quot; + coordinateReferenceSystem.toString());
+		String ret = MainUrl + serviceTypeUrlPart + &quot;&amp;&quot; + versionUrlPart + &quot;&amp;&quot; + requestUrlPart + &quot;&amp;&quot; + coordinateReferenceSystemUrlPart[crs] + &quot;&amp;&quot; + bbox + &quot;&amp;WIDTH=&quot; + pixelsize.x + &quot;&amp;HEIGHT=&quot; + pixelsize.y + &quot;&amp;&quot; + layersUrlPart + &quot;&amp;&quot; + stylesUrlPart
+				+ &quot;&amp;&quot; + imageFormatUrlPart;
 		Global.getPref().log(ret + &quot; WGS84: Bottom left: &quot; + bottomleft.toString(TransformCoordinates.DD) + &quot;top right: &quot; + topright.toString(TransformCoordinates.DD));
 		return ret;
 	}
@@ -832,7 +875,9 @@
 	 * a) if only one is in the array 0 is returned
 	 * b) if there are more, find out which one matches the correct zone (e.g. Gau&#223;-K&#252;ger stripe)
 	 * Call this routine with center of the area (use Area.getcenter())
-	 * @param p Point for which the epsg code is searched for
+	 * 
+	 * @param p
+	 *            Point for which the epsg code is searched for
 	 * @return
 	 */
 	private int getCrs(TrackPoint p) {
@@ -842,33 +887,38 @@
 			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau&#223;-Kr&#252;ger stripe?
 			int wantepsg = gkbl.getEpsgCode();
 			for (crsindex = 0; crsindex &lt; coordinateReferenceSystem.length; crsindex++) {
-				if (coordinateReferenceSystem[crsindex] == wantepsg) break;
+				if (coordinateReferenceSystem[crsindex] == wantepsg)
+					break;
 			}
 			if (crsindex &gt;= coordinateReferenceSystem.length) { // not match
 				for (crsindex = 0; crsindex &lt; coordinateReferenceSystem.length; crsindex++) {
-					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1) break; // accept 1 zone deviation
+					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1)
+						break; // accept 1 zone deviation
 				}
-				if (crsindex &gt;= coordinateReferenceSystem.length) crsindex = -1;
+				if (crsindex &gt;= coordinateReferenceSystem.length)
+					crsindex = -1;
 
 			}
-			if (crsindex &lt; 0) throw new IllegalArgumentException(MyLocale.getMsg(4829, &quot;getUrlForBoundingBox: Point:&quot;)+&quot; &quot; + gkbl.toString() + MyLocale.getMsg(4830, &quot;no matching Gau&#223;-Kr&#252;ger-Stripe in the EPSG-code list in the .wms&quot;));
+			if (crsindex &lt; 0)
+				throw new IllegalArgumentException(MyLocale.getMsg(4829, &quot;getUrlForBoundingBox: Point:&quot;) + &quot; &quot; + gkbl.toString() + MyLocale.getMsg(4830, &quot;no matching Gau&#223;-Kr&#252;ger-Stripe in the EPSG-code list in the .wms&quot;));
 		}
 		return crsindex;
 	}
 
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;)+&quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;)+&quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;)+&quot; &quot; + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;) + &quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;) + &quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;) + &quot; &quot; + boundingBox.toString());
 		Vector georef = new Vector(4);
 
 		// calculate a rectangle in the according coordinate reference system
-		CWPoint bottomleft = new CWPoint (maparea.bottomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.bottomright.lonDec);
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 		CWPoint topleft = new CWPoint(maparea.topleft);
 		CWPoint bottomright = new CWPoint(maparea.bottomright);
-		double metersperpixalhorizontal = ( bottomright.getDistance(bottomleft) + topleft.getDistance(topright))/2 * 1000 / pixelsize.x;
-		double metersperpixalvertical = ( bottomright.getDistance(topright) + topleft.getDistance(bottomleft))/2 * 1000 / pixelsize.y;
+		double metersperpixalhorizontal = (bottomright.getDistance(bottomleft) + topleft.getDistance(topright)) / 2 * 1000 / pixelsize.x;
+		double metersperpixalvertical = (bottomright.getDistance(topright) + topleft.getDistance(bottomleft)) / 2 * 1000 / pixelsize.y;
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if ( region &gt; 0) {
+		if (region &gt; 0) {
 			ProjectedPoint[] gk = getGkArea(maparea);
 			// bounding box in WMS is defined around the pixels, not exactly on the pixels --&gt; the bounding box must be reduced on all edges by half a pixel
 			gk[TOPLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
@@ -890,9 +940,10 @@
 			topleft.shift(-metersperpixalvertical / 2, 0);
 			bottomright.shift(-metersperpixalhorizontal, 1);
 			bottomright.shift(metersperpixalhorizontal, 0);
-			topright = new CWPoint (topleft.latDec, bottomright.lonDec);
-			bottomleft = new CWPoint (bottomright.latDec, topleft.lonDec);
-		} else throw new IllegalArgumentException(MyLocale.getMsg(4831, &quot;getMapInfoObject: Coordinate system not supported by cachewolf:&quot;)+&quot; &quot; + coordinateReferenceSystem);
+			topright = new CWPoint(topleft.latDec, bottomright.lonDec);
+			bottomleft = new CWPoint(bottomright.latDec, topleft.lonDec);
+		} else
+			throw new IllegalArgumentException(MyLocale.getMsg(4831, &quot;getMapInfoObject: Coordinate system not supported by cachewolf:&quot;) + &quot; &quot; + coordinateReferenceSystem);
 		georef.add(new GCPoint(topleft, new Point(0, 0)));
 		georef.add(new GCPoint(bottomright, new Point(pixelsize.x, pixelsize.y)));
 		georef.add(new GCPoint(topright, new Point(pixelsize.x, 0)));
@@ -906,25 +957,26 @@
 
 class ExpediaMapService extends OnlineMapService {
 	/*
-	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
+	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir
+	 * gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
 	 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&amp;ID=3XNsF.&amp;CenP={0,number,#.########},{1,number,#.########}&amp;Lang=EUR0809&amp;Alti={2,number,#}&amp;Size={3,number,#},{4,number,#}&amp;Offs=0.000000,0.000000\&amp;BCheck=1
 	 * download.map.url.expedia_east.title=Url of Expedia Europe
 	 * download.map.scale_factor.expedia_east=3950
 	 */
 	final static float downloadMapScaleFactorExpedia_east = 3950;
-	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f / 2817.947378f;
 	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL;
 
 	public ExpediaMapService() {
 		name = &quot;Expedia&quot;;
 		filename = &quot;expedia&quot;;
-		MainUrl = &quot;<A HREF="Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.">Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.</A>&quot;; //&quot;<A HREF="Rhttp://">Rhttp://</A>&quot; forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
+		MainUrl = &quot;<A HREF="Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.">Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.</A>&quot;; // &quot;<A HREF="Rhttp://">Rhttp://</A>&quot; forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
 		imageFileExt = &quot;.gif&quot;;
 		mapType = &quot;expedia&quot;;
-		recommendedScales = new double[]{5};
+		recommendedScales = new double[] { 5 };
 		minscale = getMetersPerPixel(0.00000000000000000000001f);
-		maxscale = getMetersPerPixel((float)new CWPoint(0,0).getDistance(new CWPoint(0,180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -&gt; m. /1000 because we have 1000x1000 Pixel usually
-		boundingBox = new Area(new CWPoint(90,-180), new CWPoint(-90,180));
+		maxscale = getMetersPerPixel((float) new CWPoint(0, 0).getDistance(new CWPoint(0, 180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -&gt; m. /1000 because we have 1000x1000 Pixel usually
+		boundingBox = new Area(new CWPoint(90, -180), new CWPoint(-90, 180));
 	}
 
 	public float getMetersPerPixel(float scale) {
@@ -932,24 +984,25 @@
 	}
 
 	private int getZoomlevel(float scale) {
-		return (int)(Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
+		return (int) (Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
 	}
 
 	public String getUrlForCenterScale(CWPoint center, float scale, Point pixelsize) {
 		int zoomlevel = getZoomlevel(scale);
 		String zone;
-		if (     (center.lonDec &lt;= -30   &amp;&amp; center.lonDec &gt;= -170) ||
-				( center.lonDec &gt; 360-30 &amp;&amp; center.lonDec &lt;= 360-170) ) zone = &quot;USA0409&quot;; // TODO test which zone-code ist best for asia
-		else zone = &quot;EUR0809&quot;;
+		if ((center.lonDec &lt;= -30 &amp;&amp; center.lonDec &gt;= -170) || (center.lonDec &gt; 360 - 30 &amp;&amp; center.lonDec &lt;= 360 - 170))
+			zone = &quot;USA0409&quot;; // TODO test which zone-code ist best for asia
+		else
+			zone = &quot;EUR0809&quot;;
 		String quelle = MainUrl + &quot;&amp;CenP=&quot; + center.toString(TransformCoordinates.LAT_LON);
-		quelle = quelle + &quot;&amp;Alti=&quot;+Convert.toString(zoomlevel)+&quot;&amp;Lang=&quot;+zone+&quot;&amp;Size=&quot;+Convert.toString(pixelsize.x)+&quot;,&quot;+Convert.toString(pixelsize.y)+&quot;&amp;Offs=0,0&amp;MapS=0&quot;; //&amp;Pins=|&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.') + &quot;|5|&quot;;
+		quelle = quelle + &quot;&amp;Alti=&quot; + Convert.toString(zoomlevel) + &quot;&amp;Lang=&quot; + zone + &quot;&amp;Size=&quot; + Convert.toString(pixelsize.x) + &quot;,&quot; + Convert.toString(pixelsize.y) + &quot;&amp;Offs=0,0&amp;MapS=0&quot;; // &amp;Pins=|&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.') + &quot;|5|&quot;;
 		return quelle;
 	}
 
 	public MapInfoObject getMapInfoObject(CWPoint center, float scale, Point pixelsize) {
 		float metersPerPixel2 = getMetersPerPixel(scale);
 		float metersPerPixel = metersPerPixel2;
-		MapInfoObject cal = new MapInfoObject(metersPerPixel, center,  pixelsize.x, pixelsize.y, name);
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, center, pixelsize.x, pixelsize.y, name);
 		return cal;
 	}
 

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -60,47 +60,47 @@
 
 /**
  * @author pfeffer
- * This Class is the Dialog for Download calibrated from expedia.com
- * is called from
- *  * start offset for language file: 1800
+ *         This Class is the Dialog for Download calibrated from expedia.com
+ *         is called from
+ *         * start offset for language file: 1800
  */
 
 public class MapLoaderGui extends Form {
 	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
-    Preferences pref = Global.getPref ();
+	Preferences pref = Global.getPref();
 	mTabbedPanel mTab = new mTabbedPanel();
 	CellPanel pnlTiles = new CellPanel();
 	CellPanel pnlPerCache = new CellPanel();
 
-	final String descString = MyLocale.getMsg(1802,&quot;Download georeferenced maps\n Select online service:&quot;);
+	final String descString = MyLocale.getMsg(1802, &quot;Download georeferenced maps\n Select online service:&quot;);
 	mChoice mapServiceChoice;
-	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803,&quot;for&quot;));
-	mChoice forSelectedChkBox = new mChoice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 0);
-	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 1);
-	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806,&quot;caches&quot;));
+	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803, &quot;for&quot;));
+	mChoice forSelectedChkBox = new mChoice(new String[] { MyLocale.getMsg(1804, &quot;all&quot;), MyLocale.getMsg(1805, &quot;selected&quot;) }, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] { MyLocale.getMsg(1804, &quot;all&quot;), MyLocale.getMsg(1805, &quot;selected&quot;) }, 1);
+	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806, &quot;caches&quot;));
 	mInput distanceInput;
 	mLabel distLbl;
 	mLabel km = new mLabel(&quot;km&quot;);
 	mLabel coosLbl;
 	mButton coosBtn;
-	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807,&quot;Approx. m per pixel:&quot;));
+	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807, &quot;Approx. m per pixel:&quot;));
 	mComboBox scaleInput = new mComboBox();
 	mComboBox scaleInputPerCache = new mComboBox();
-	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808,&quot;overlapping in pixel:&quot;));
-    mInput overlappingInput = new mInput(&quot;&quot;+pref.mapOverlapping);
-	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));	
-	mCheckBox fetchOnlyMapWithCacheChkBox = new mCheckBox(MyLocale.getMsg(165,&quot;only for caches&quot;));	
-	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
-    mCheckBox smallTiles = new mCheckBox (MyLocale.getMsg (4280, &quot;Small Tiles&quot;));
-    mCheckBox bigTiles = new mCheckBox (MyLocale.getMsg (4282, &quot;BigTiles&quot;));
-    CheckBoxGroup tileSize = new CheckBoxGroup ();
+	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808, &quot;overlapping in pixel:&quot;));
+	mInput overlappingInput = new mInput(&quot;&quot; + pref.mapOverlapping);
+	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809, &quot;download an overview map&quot;));
+	mCheckBox fetchOnlyMapWithCacheChkBox = new mCheckBox(MyLocale.getMsg(165, &quot;only for caches&quot;));
+	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809, &quot;download an overview map&quot;));
+	mCheckBox smallTiles = new mCheckBox(MyLocale.getMsg(4280, &quot;Small Tiles&quot;));
+	mCheckBox bigTiles = new mCheckBox(MyLocale.getMsg(4282, &quot;BigTiles&quot;));
+	CheckBoxGroup tileSize = new CheckBoxGroup();
 
-    /**
-     * Inputfields for width an height of tile size
-     */
-    private mInput tileWidthInput = new mInput ();
-    private mInput tileHeightInput = new mInput();
-    MapLoader mapLoader;
+	/**
+	 * Inputfields for width an height of tile size
+	 */
+	private mInput tileWidthInput = new mInput();
+	private mInput tileHeightInput = new mInput();
+	MapLoader mapLoader;
 	String[] unsortedMapServices;
 	String[] sortedmapServices;
 	int[] sortingMapServices;
@@ -124,19 +124,19 @@
 		this.title = MyLocale.getMsg(1800, &quot;Download georeferenced maps&quot;);
 		center = new CWPoint(pref.getCurCentrePt());
 		tileWidth = pref.tilewidth;
-		tileHeight=pref.tileheight;
+		tileHeight = pref.tileheight;
 		if (tileWidth == 0 || tileHeight == 0) {
-			tileWidth = pref.myAppWidth &gt; 200?pref.myAppWidth:200;
-			tileHeight = pref.myAppHeight &gt; 175?pref.myAppHeight:175;
+			tileWidth = pref.myAppWidth &gt; 200 ? pref.myAppWidth : 200;
+			tileHeight = pref.myAppHeight &gt; 175 ? pref.myAppHeight : 175;
 		}
-		pref.tilewidth=tileWidth;
-		pref.tileheight=tileHeight;
+		pref.tilewidth = tileWidth;
+		pref.tileheight = tileHeight;
 		// ist das wirklich so gewollt?
-		pref.tilewidth=1000;
-		pref.tileheight=1000;
+		pref.tilewidth = 1000;
+		pref.tileheight = 1000;
 		initTileInputfields();
 		cacheDB = cacheDBi;
-		mapLoader = new MapLoader(FileBase.getProgramDirectory()+&quot;/&quot;+&quot;webmapservices&quot;);
+		mapLoader = new MapLoader(FileBase.getProgramDirectory() + &quot;/&quot; + &quot;webmapservices&quot;);
 
 		// sort the items in the list of services in a way that services which cover the current center point.
 		unsortedMapServices = mapLoader.getAvailableOnlineMapServices();
@@ -151,20 +151,20 @@
 		pnlTiles.addNext(forCachesChkBox);
 		pnlTiles.addNext(forSelectedChkBox);
 		pnlTiles.addLast(cachesLbl);
-		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810,&quot;Within a rectangle of:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810, &quot;Within a rectangle of:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		distanceInput = new mInput();
 		int tmp = Convert.toInt((Global.getProfile().getDistOC()));
 		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().getDistGC())));
 		distanceInput.setText(Convert.toString((tmp &gt; 0 ? tmp : 15)));
-		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, &quot;around the centre:&quot;)+&quot; &quot;));
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, &quot;around the centre:&quot;) + &quot; &quot;));
 		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
 		pnlTiles.addNext(scaleLbl);
 		mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 		this.focusFirst();
 		pnlTiles.addLast(scaleInput);
-		//	pnlTiles.addLast(resolutionLbl);
+		// pnlTiles.addLast(resolutionLbl);
 		pnlTiles.addNext(overlappingLbl);
 		pnlTiles.addLast(overlappingInput);
 		overviewChkBox.setState(false);
@@ -174,15 +174,15 @@
 		pnlTiles.addNext(smallTiles);
 		pnlTiles.addLast(bigTiles);
 		smallTiles.setGroup(tileSize);
-                bigTiles.setGroup(tileSize);
+		bigTiles.setGroup(tileSize);
 		tileSize.selectIndex(pref.mapTileSize);
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB = new mButton(MyLocale.getMsg(1604, &quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okBtiles = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		pnlTiles.addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605, &quot;OK&quot;));
 		okBtiles.setHotKey(0, IKeys.ACTION);
 		okBtiles.setHotKey(0, IKeys.ENTER);
-		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(okBtiles, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		updateForCachesState();
 		mTab.addCard(pnlTiles, MyLocale.getMsg(1812, &quot;Tiles&quot;), MyLocale.getMsg(1812, &quot;Tiles&quot;));
 
@@ -191,20 +191,20 @@
 		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addLast(new mLabel(MyLocale.getMsg(1806, &quot;caches&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1807, &quot;Approx. m per pixel&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-		pnlPerCache.addNext (new mLabel(MyLocale.getMsg(1835, &quot;Tilesize&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		CellPanel pnl = new CellPanel();		
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1835, &quot;Tilesize&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		CellPanel pnl = new CellPanel();
 		tileHeightInput.columns = tileWidthInput.columns = 5;
-		pnl.addNext (tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addNext (new mLabel(&quot;x&quot;), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addLast (tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-        pnlPerCache.addLast(pnl,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-        cancelBPerCache = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		pnl.addNext(tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addNext(new mLabel(&quot;x&quot;), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addLast(tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnlPerCache.addLast(pnl, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604, &quot;Cancel&quot;));
 		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
 		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		okBPerCache = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBPerCache = new mButton(MyLocale.getMsg(1605, &quot;OK&quot;));
 		okBPerCache.setHotKey(0, IKeys.ACTION);
 		okBPerCache.setHotKey(0, IKeys.ENTER);
 		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
@@ -219,9 +219,9 @@
 		tileHeightInput.setText(Integer.toString(pref.tileheight));
 	}
 
-	private void setRecommScaleInput(){
+	private void setRecommScaleInput() {
 		String[] recScales = new String[mapLoader.currentOnlineMapService.recommendedScales.length];
-		for (int i=0; i&lt;recScales.length; i++) {
+		for (int i = 0; i &lt; recScales.length; i++) {
 			recScales[i] = Convert.toString(mapLoader.currentOnlineMapService.recommendedScales[i]);
 		}
 		scaleInput.choice.set(recScales, mapLoader.currentOnlineMapService.preselectedRecScaleIndex);
@@ -234,70 +234,72 @@
 	 * sort the map services in order to have the services, which cover
 	 * the current center first in the list
 	 * this sets inbound[], sortedMapServices[] and sortingmapServices[]
-	 *
+	 * 
 	 */
 	private void sortMapServices() {
-		sortingMapServices = new int[unsortedMapServices.length+1];
+		sortingMapServices = new int[unsortedMapServices.length + 1];
 		inbound = new boolean[unsortedMapServices.length];
-		int j=0;
-		for (int i=0; i &lt; sortingMapServices.length-1; i++) {
-			if( ((OnlineMapService)mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
+		int j = 0;
+		for (int i = 0; i &lt; sortingMapServices.length - 1; i++) {
+			if (((OnlineMapService) mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
 				sortingMapServices[j] = i;
 				j++;
 				inbound[i] = true;
-			} else inbound[i] = false;
+			} else
+				inbound[i] = false;
 		}
-		int k=j;
-		sortedmapServices = new String[unsortedMapServices.length+1];
-		for (int i=0; i &lt; sortedmapServices.length-1; i++) {
+		int k = j;
+		sortedmapServices = new String[unsortedMapServices.length + 1];
+		for (int i = 0; i &lt; sortedmapServices.length - 1; i++) {
 			if (!inbound[i]) {
 				sortingMapServices[j] = i;
 				j++;
 			}
-			sortedmapServices[i] = ((OnlineMapService)mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
+			sortedmapServices[i] = ((OnlineMapService) mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
 		}
-		sortedmapServices[j]=sortedmapServices[k];
-		sortedmapServices[k]=&quot;===== ===== ===== ===== ===== ===== =====&quot;;
-		sortingMapServices[j]=sortingMapServices[k];
-		sortingMapServices[k]=-1;
+		sortedmapServices[j] = sortedmapServices[k];
+		sortedmapServices[k] = &quot;===== ===== ===== ===== ===== ===== =====&quot;;
+		sortingMapServices[j] = sortingMapServices[k];
+		sortingMapServices[k] = -1;
 	}
 
 	private int getSortedMapServiceIndex(int originalindex) {
 		for (int i = 0; i &lt; sortingMapServices.length; i++) {
-			if (sortingMapServices[i] == originalindex) return i;
+			if (sortingMapServices[i] == originalindex)
+				return i;
 		}
-		throw new IllegalStateException(MyLocale.getMsg(1818, &quot;getSortedMapServiceIndex: index&quot;)+&quot; &quot; + originalindex + MyLocale.getMsg(1819, &quot;not found&quot;));
+		throw new IllegalStateException(MyLocale.getMsg(1818, &quot;getSortedMapServiceIndex: index&quot;) + &quot; &quot; + originalindex + MyLocale.getMsg(1819, &quot;not found&quot;));
 	}
 
 	public String getMapsDir() {
 		String ret = Global.getPref().getMapDownloadSavePath(mapLoader.currentOnlineMapService.getMapType());
-		Global.getPref().saveCustomMapsPath(getLeadingPath(ret,Global.getPref().getMapLoadPath()));
+		Global.getPref().saveCustomMapsPath(getLeadingPath(ret, Global.getPref().getMapLoadPath()));
 		// Global.getPref().saveCustomMapsPath(ret);
 		// eigentlich d&#252;rft das erst gespeichert werden, wenn erfolgreich heruntergeladen wurde
 		return ret;
 	}
 
-	private String getLeadingPath(String newPath , String oldPath) {
-		String LeadingPath=&quot;&quot;;
-		int StartPos=0;
+	private String getLeadingPath(String newPath, String oldPath) {
+		String LeadingPath = &quot;&quot;;
+		int StartPos = 0;
 		int EndPos;
-		int LastPos = java.lang.Math.min(newPath.length(),oldPath.length());
+		int LastPos = java.lang.Math.min(newPath.length(), oldPath.length());
 		do {
-			EndPos=java.lang.Math.min(newPath.indexOf(&quot;/&quot;, StartPos),LastPos);
-			if (newPath.substring(StartPos,EndPos).equals(oldPath.substring(StartPos, EndPos))) {
-				LeadingPath=LeadingPath.concat(newPath.substring(StartPos,EndPos+1));
-				StartPos=EndPos+1;
-			}
-			else {
+			EndPos = java.lang.Math.min(newPath.indexOf(&quot;/&quot;, StartPos), LastPos);
+			if (newPath.substring(StartPos, EndPos).equals(oldPath.substring(StartPos, EndPos))) {
+				LeadingPath = LeadingPath.concat(newPath.substring(StartPos, EndPos + 1));
+				StartPos = EndPos + 1;
+			} else {
 				break;
 			}
-		} while (StartPos&lt;LastPos);
+		} while (StartPos &lt; LastPos);
 		return LeadingPath;
 	}
 
 	public void downloadTiles() {
 		String mapsDir = getMapsDir();
-		if (mapsDir == null) return;
+		if (mapsDir == null)
+			return;
 		InfoBox progressBox = new InfoBox(MyLocale.getMsg(1815, &quot;Downloading georeferenced maps&quot;), MyLocale.getMsg(1816, &quot;Downloading georeferenced maps\n \n \n \n \n&quot;), InfoBox.PROGRESS_WITH_WARNINGS);
 		progressBox.setPreferredSize(220, 300);
 		progressBox.setInfoHeight(160);
@@ -306,16 +308,16 @@
 		mapLoader.setProgressInfoBox(progressBox);
 		Vm.showWait(true);
 		int length;
-        	switch (tileSize.getSelectedIndex()){
-		    //Perhaps introduce a medium size??
+		switch (tileSize.getSelectedIndex()) {
+		// Perhaps introduce a medium size??
 		case 0:
-		    length=500;
-		    break;
+			length = 500;
+			break;
 		default:
-		    length=1000;
+			length = 1000;
 		}
-		//Override size if one tile for each cache is wanted
-			Point size = new Point(length, length);
+		// Override size if one tile for each cache is wanted
+		Point size = new Point(length, length);
 		if (perCache) {
 			length = 1000;
 			size = new Point(tileWidth, tileHeight);
@@ -328,9 +330,8 @@
 				progressBox.close(0);
 				return;
 			}
-			mapLoader.setTiles(surArea.topleft, surArea.bottomright, scale, size, overlapping );
-		} else
-		{ // calculate from centre point an radius
+			mapLoader.setTiles(surArea.topleft, surArea.bottomright, scale, size, overlapping);
+		} else { // calculate from centre point an radius
 			mapLoader.setTiles(center, radius * 1000, scale, size, overlapping);
 		}
 		if (overviewmap) {
@@ -339,33 +340,28 @@
 			try {
 				mapLoader.downloadMap(center, overviewScale, size, mapsDir);
 			} catch (Exception e) {
-				progressBox.addWarning(MyLocale.getMsg(1825, &quot;Overview map: Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+				progressBox.addWarning(MyLocale.getMsg(1825, &quot;Overview map: Ignoring error:&quot;) + &quot; &quot; + e.getMessage() + &quot;\n&quot;);
 			}
 		}
-		if (!perCache){  // download tiles
+		if (!perCache) { // download tiles
 			mapLoader.setProgressInfoBox(progressBox);
 			mapLoader.setFetchOnlyMapWithCache(fetchOnlyMapWithCacheChkBox.getState());
 			mapLoader.downlaodTiles(mapsDir);
 		} else { // per cache
 			CacheHolder ch;
-			CWPoint tmpca = new CWPoint();
 			int numdownloaded = 0;
 			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
 			int numCaches = Global.getProfile().numCachesInArea;
-			for (int i=cacheDB.size()-1; i &gt;= 0; i--) {
+			for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 				ch = cacheDB.get(i);
 				if (!this.onlySelected || ch.is_Checked) {
-					if (ch.pos == null) { // this can not happen
-						tmpca.set(ch.getLatLon());
-						ch.pos = new CWPoint(tmpca);
-					}
-					if (ch.pos.isValid() &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos &#252;berall korrekt ist
+					if (ch.getPos().isValid() &amp;&amp; ch.getPos().latDec != 0 &amp;&amp; ch.getPos().lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos &#252;berall korrekt ist
 						numdownloaded++;
-						progressBox.setInfo(MyLocale.getMsg(1820, &quot;Downloading map '&quot;)+mapLoader.currentOnlineMapService.getName()+&quot;'\n&quot;+numdownloaded+&quot; / &quot;+numCaches+MyLocale.getMsg(1821, &quot;\n for cache:\n&quot;)+ch.getCacheName());
+						progressBox.setInfo(MyLocale.getMsg(1820, &quot;Downloading map '&quot;) + mapLoader.currentOnlineMapService.getName() + &quot;'\n&quot; + numdownloaded + &quot; / &quot; + numCaches + MyLocale.getMsg(1821, &quot;\n for cache:\n&quot;) + ch.getCacheName());
 						try {
-							mapLoader.downloadMap(ch.pos, scale, size, mapsDir);
+							mapLoader.downloadMap(ch.getPos(), scale, size, mapsDir);
 						} catch (Exception e) {
-							progressBox.addWarning(MyLocale.getMsg(1822, &quot;Cache:&quot;)+&quot; &quot; + ch.getCacheName() + &quot;(&quot; + ch.getWayPoint() + &quot;) &quot;+MyLocale.getMsg(1823, &quot;Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+							progressBox.addWarning(MyLocale.getMsg(1822, &quot;Cache:&quot;) + &quot; &quot; + ch.getCacheName() + &quot;(&quot; + ch.getWayPoint() + &quot;) &quot; + MyLocale.getMsg(1823, &quot;Ignoring error:&quot;) + &quot; &quot; + e.getMessage() + &quot;\n&quot;);
 						}
 					}
 				}
@@ -376,20 +372,19 @@
 		progressBox.addOkButton();
 		progressBox.waitUntilClosed();
 		mapLoader.setProgressInfoBox(null);
-		//progressBox.close(0);
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
-		//	(new MessageBox(&quot;Download maps&quot;, &quot;Downloaded and calibrated the maps successfully&quot;, MessageBox.OKB)).execute();
+		// progressBox.close(0);
+		if (Global.mainTab.mm != null)
+			Global.mainTab.mm.mapsloaded = false;
+		// (new MessageBox(&quot;Download maps&quot;, &quot;Downloaded and calibrated the maps successfully&quot;, MessageBox.OKB)).execute();
 	}
 
-
 	private void updateForCachesState() {
 		int a, b;
 		if (forCachesChkBox.getState()) {
 			// create map rectangle from caches
 			a = 0;
 			b = ControlConstants.Disabled;
-		}
-		else { // use centre and distance input
+		} else { // use centre and distance input
 			a = ControlConstants.Disabled;
 			b = 0;
 		}
@@ -399,28 +394,29 @@
 		distLbl.modify(b, a);
 		coosBtn.modify(b, a);
 		coosLbl.modify(b, a);
-		km.modify(b,a);
+		km.modify(b, a);
 		repaintNow();
 
 	}
 
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB || ev.target == cancelBPerCache){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB || ev.target == cancelBPerCache) {
 				this.close(FormBase.IDCANCEL);
-			}
-			else if (ev.target == okBtiles || ev.target == okBPerCache){
+			} else if (ev.target == okBtiles || ev.target == okBPerCache) {
 				if (sortingMapServices[mapServiceChoice.selectedIndex] == -1) {
 					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1833, &quot;Please don't select the separator line in the wms service option&quot;), FormBase.OKB)).execute();
 				}
 				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 				if (ev.target == okBtiles) { // get tiles
 					perCache = false;
-					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;)))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBox.getState();
-					radius = (float)CacheWolf.Common.parseDouble(distanceInput.getText());
-					scale = (float)CacheWolf.Common.parseDouble(scaleInput.getText());
+					radius = (float) CacheWolf.Common.parseDouble(distanceInput.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInput.getText());
 					overlapping = Convert.toInt(overlappingInput.getText());
 					if (!forCachesChkBox.getState()) {
 						if (radius &lt;= 0) {
@@ -438,41 +434,43 @@
 					}
 				} else { // per cache
 					perCache = true;
-					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;)))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBoxPerCache.getState();
-					scale = (float)CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
 					tileWidth = CacheWolf.Common.parseInt(tileWidthInput.getText());
 					tileHeight = CacheWolf.Common.parseInt(tileHeightInput.getText());
 					if (tileWidth &lt;= 0) {
 						new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1836, &quot;Width of tiles must be greater 0.&quot;), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					if (tileHeight &lt;= 0) {
 						new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1837, &quot;Height of tiles must be greater 0.&quot;), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					// If width and height has been valid, set them in preferences also:
-					pref.tileheight=tileHeight;
-					pref.tilewidth=tileWidth;
+					pref.tileheight = tileHeight;
+					pref.tilewidth = tileWidth;
 				}
 				if (scale &lt; mapLoader.currentOnlineMapService.minscale || scale &gt; mapLoader.currentOnlineMapService.maxscale) {
 					if (scale &lt; mapLoader.currentOnlineMapService.minscale) {
 						scaleInput.setText(Convert.toString(mapLoader.currentOnlineMapService.minscale));
-						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale*100)/100));
+						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale * 100) / 100));
 					} else {
-						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale*100)/100));
+						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale * 100) / 100));
 						scaleInputPerCache.setText(Convert.toString(mapLoader.currentOnlineMapService.maxscale));
 					}
-					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), &quot;! &quot; + scale + &quot;\n&quot; + MyLocale.getMsg(1830, &quot;The selected online map service provides map in the scale from&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.minscale + MyLocale.getMsg(1831, &quot; to&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, &quot;\n please adjust 'Approx. meter pro pixel' accordingly&quot;), FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), &quot;! &quot; + scale + &quot;\n&quot; + MyLocale.getMsg(1830, &quot;The selected online map service provides map in the scale from&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.minscale
+							+ MyLocale.getMsg(1831, &quot; to&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, &quot;\n please adjust 'Approx. meter pro pixel' accordingly&quot;), FormBase.OKB)).execute();
 					return;
 				}
 				this.close(FormBase.IDOK);
 				this.downloadTiles();
-			}
-			else if (ev.target == coosBtn) {
+			} else if (ev.target == coosBtn) {
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(center, TransformCoordinates.CW);
 				if (cs.execute() != FormBase.IDCANCEL) {
@@ -482,32 +480,29 @@
 					sortMapServices();
 					mapServiceChoice.set(sortedmapServices, (!inbound[tmp] ? 0 : getSortedMapServiceIndex((tmp))));
 				}
-			}
-			else if (ev.target == forCachesChkBox) {
+			} else if (ev.target == forCachesChkBox) {
 				updateForCachesState();
+			} else if (ev.target == tileSize) {
+				switch (tileSize.getSelectedIndex()) {
+				case 0:
+					overlappingInput.setText(&quot;10&quot;);
+					pref.mapTileSize = 0;
+					pref.mapOverlapping = 10;
+					break;
+				default:
+					overlappingInput.setText(&quot;100&quot;);
+					pref.mapTileSize = 1;
+					pref.mapOverlapping = 100;
+				}
 			}
-			else if (ev.target == tileSize){
-			    switch (tileSize.getSelectedIndex()){
-			    case 0:
-			    overlappingInput.setText (&quot;10&quot;);
-			    pref.mapTileSize=0;
-			    pref.mapOverlapping=10;
-			    break;
-			    default:
-			    overlappingInput.setText (&quot;100&quot;);
-			    pref.mapTileSize=1;
-			    pref.mapOverlapping=100;
-			    }
-			}
 		} // end of &quot;if controllEvent...&quot;
-		if (ev instanceof DataChangeEvent){
-		    if (ev.target == mapServiceChoice) {
-			mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
-			setRecommScaleInput();
-		    }
-		    else if (ev.target == overlappingInput){
-			pref.mapOverlapping = Convert.toInt(overlappingInput.getText ());
-		    }
+		if (ev instanceof DataChangeEvent) {
+			if (ev.target == mapServiceChoice) {
+				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
+				setRecommScaleInput();
+			} else if (ev.target == overlappingInput) {
+				pref.mapOverlapping = Convert.toInt(overlappingInput.getText());
+			}
 		}
 		super.onEvent(ev);
 	}

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1016,7 +1016,7 @@
 	}
 
 	public void destChanged(CacheHolder ch) {
-		final CWPoint d = new CWPoint(ch.pos);
+		final CWPoint d = new CWPoint(ch.getPos());
 		if (!running || (gotoPos != null &amp;&amp; gotoPos.where.equals(d)))
 			return;
 		removeMapSymbol(&quot;goto&quot;);
@@ -1190,18 +1190,18 @@
 		final Area screenArea = new Area(ScreenXY2LatLon(0, 0), ScreenXY2LatLon(width, height));
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
-			if (screenArea.isInBound(ch.pos)) {
+			if (screenArea.isInBound(ch.getPos())) {
 				// because visible and valid don't change while showing map
 				// --&gt;need no remove
-				if (ch.isVisible() &amp;&amp; ch.pos.isValid()) {
+				if (ch.isVisible() &amp;&amp; ch.getPos().isValid()) {
 					if (pref.showCachesOnMap) {
 						if (addSymbolIsNecessary(ch.getWayPoint())) {
-							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
+							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
 						}
 					} else {
 						if (ch.is_Checked || ch == cacheDB.get(Global.mainTab.tbP.getSelectedCache())) {
 							if (addSymbolIsNecessary(ch.getWayPoint())) {
-								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
+								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
 							}
 						} else {
 							removeMapSymbol(ch);
@@ -1223,9 +1223,9 @@
 				gotoPosCH = (CacheHolder) gotoPos.mapObject;
 			}
 			if (gotoPosCH != null) {
-				if (screenArea.isInBound(gotoPosCH.pos)) {
+				if (screenArea.isInBound(gotoPosCH.getPos())) {
 					if (!pref.showCachesOnMap) {
-						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.pos);
+						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.getPos());
 					}
 					addSymbolIfNecessary(&quot;goto&quot;, gotoPosCH, imgGoto, gotoPos.where);
 				}
@@ -1235,8 +1235,8 @@
 		removeMapSymbol(&quot;selectedCache&quot;);
 		ch = cacheDB.get(Global.mainTab.tbP.getSelectedCache());
 		if (ch != null) {
-			if (screenArea.isInBound(ch.pos)) {
-				addSymbolIfNecessary(&quot;selectedCache&quot;, ch, imgSelectedCache, ch.pos);
+			if (screenArea.isInBound(ch.getPos())) {
+				addSymbolIfNecessary(&quot;selectedCache&quot;, ch, imgSelectedCache, ch.getPos());
 			}
 		}
 	}
@@ -2864,8 +2864,7 @@
 					if (action == newWayPointMenuItem) {
 						leaveMovingMap();
 						final CacheHolder newWP = new CacheHolder();
-						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						newWP.setLatLon(newWP.pos.toString());
+						newWP.setPos(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 						Global.mainTab.newWaypoint(newWP);
 					}
 					if (action == addCachetoListMenuItem) {

Modified: trunk/src/CacheWolf/navi/Navigate.java
===================================================================
--- trunk/src/CacheWolf/navi/Navigate.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/Navigate.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,30 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
- 
+
 import net.ax86.GPS;
 import net.ax86.GPSException;
 
@@ -46,13 +46,13 @@
 import ewe.ui.MessageBox;
 import ewe.util.mString;
 
-
 /**
  * Non-Gui Class to handle all things regarding navigation
  * (GPS, Sun direction etc.)
  * start offset in localisation file: 4400
+ * 
  * @author Pfeffer
- *
+ * 
  */
 public class Navigate {
 	public CWPoint destination = new CWPoint();
@@ -60,7 +60,7 @@
 	public boolean destinationIsCache = false;
 	public CWGPSPoint gpsPos = new CWGPSPoint();
 	public Track curTrack = null;
-	public Color trackColor = new Color(255,0,0); // red
+	public Color trackColor = new Color(255, 0, 0); // red
 	public CWPoint skyOrientationDir = new CWPoint();
 	public int luminary = SkyOrientation.SUN;
 
@@ -78,160 +78,167 @@
 	public void setGotoPanel(GotoPanel gp) {
 		gotoPanel = gp;
 	}
-	public void setMovingMap (MovingMap mm) {
+
+	public void setMovingMap(MovingMap mm) {
 		movingMap = mm;
-		if (gpsRunning) mm.gpsStarted();
+		if (gpsRunning)
+			mm.gpsStarted();
 	}
 
 	public void startGps(boolean loggingOn, int loggingIntervall) {
 		lograw = loggingOn;
 		logIntervall = loggingIntervall; // TODO switch on and off during serthread running
-		
-		switch(Global.getPref().useGPSD) {
-			// Tblue&gt; TODO: NEW vs. OLD: This is ugly! The only line that's
-			//        different is the one where the object is created!
-			case Preferences.GPSD_FORMAT_NEW:
-				try {
-					gpsdThread = new GpsdThread(gpsPos);
-					gpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-						MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;)
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;),
-						FormBase.OKB)).execute();
-				} catch( Exception e ) {
-					// Other error (JSON/GPS).
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-						MyLocale.getMsg(99999, &quot;Could not initialize GPSD connection: &quot;) 
-						+ e.getMessage(),
-						FormBase.OKB)).execute();
-				}
-				break;
 
-			case Preferences.GPSD_FORMAT_OLD:
-				try {
-					oldGpsdThread = new OldGpsdThread(gpsPos);
-					oldGpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-						MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;)
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;),
-						FormBase.OKB)).execute();
-				}
-				break;
+		switch (Global.getPref().useGPSD) {
+		// Tblue&gt; TODO: NEW vs. OLD: This is ugly! The only line that's
+		// different is the one where the object is created!
+		case Preferences.GPSD_FORMAT_NEW:
+			try {
+				gpsdThread = new GpsdThread(gpsPos);
+				gpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;) + e.getMessage() + MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;), FormBase.OKB))
+						.execute();
+			} catch (Exception e) {
+				// Other error (JSON/GPS).
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(99999, &quot;Could not initialize GPSD connection: &quot;) + e.getMessage(), FormBase.OKB)).execute();
+			}
+			break;
 
-			case Preferences.GPSD_DISABLED:
-			default:
-				if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
-				try {
-					serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : &quot;&quot;));
-					if (pref.forwardGPS &amp;&amp; !serThread.tcpForward) {
-						(new MessageBox(MyLocale.getMsg(4400, &quot;Warning&quot;),
-								MyLocale.getMsg(4401, &quot;Ignoring error:\n could not forward GPS data to host:\n&quot;)
-								+ pref.forwardGpsHost+&quot;\n&quot; + serThread.lastError
-								+ MyLocale.getMsg(4402, &quot;\nstop and start GPS to retry&quot;), FormBase.OKB)).exec();
-					}
-					serThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-							MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
-							+ e.getMessage()
-							+ MyLocale.getMsg(4405, &quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;),
-							FormBase.OKB)).execute();
-				} catch (UnsatisfiedLinkError e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-							MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
-							+ MyLocale.getMsg(4406, &quot;Please copy jave_ewe.dll into the directory of the cachewolf program&quot;),
-							FormBase.OKB)).execute();
+		case Preferences.GPSD_FORMAT_OLD:
+			try {
+				oldGpsdThread = new OldGpsdThread(gpsPos);
+				oldGpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;) + e.getMessage() + MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;), FormBase.OKB))
+						.execute();
+			}
+			break;
+
+		case Preferences.GPSD_DISABLED:
+		default:
+			if (serThread != null)
+				if (serThread.isAlive())
+					return; // TODO use gpsRunning
+			try {
+				serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : &quot;&quot;));
+				if (pref.forwardGPS &amp;&amp; !serThread.tcpForward) {
+					(new MessageBox(MyLocale.getMsg(4400, &quot;Warning&quot;), MyLocale.getMsg(4401, &quot;Ignoring error:\n could not forward GPS data to host:\n&quot;) + pref.forwardGpsHost + &quot;\n&quot; + serThread.lastError
+							+ MyLocale.getMsg(4402, &quot;\nstop and start GPS to retry&quot;), FormBase.OKB)).exec();
 				}
-				break;
+				serThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;) + e.getMessage()
+						+ MyLocale.getMsg(4405, &quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;), FormBase.OKB)).execute();
+			} catch (UnsatisfiedLinkError e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
+						+ MyLocale.getMsg(4406, &quot;Please copy jave_ewe.dll into the directory of the cachewolf program&quot;), FormBase.OKB)).execute();
+			}
+			break;
 		}
 	}
+
 	public void startDisplayTimer() {
 		tickerThread = new UpdateThread(this, 1000);
 		tickerThread.start();
 	}
 
-	public void stopDisplayTimer(){
-		if (tickerThread != null) tickerThread.stop();
+	public void stopDisplayTimer() {
+		if (tickerThread != null)
+			tickerThread.stop();
 	}
 
 	public void stopGps() {
-		if(serThread!=null)	serThread.stop();
-		if(gpsdThread!=null) gpsdThread.stop();
-		if(oldGpsdThread!=null) oldGpsdThread.stop();
+		if (serThread != null)
+			serThread.stop();
+		if (gpsdThread != null)
+			gpsdThread.stop();
+		if (oldGpsdThread != null)
+			oldGpsdThread.stop();
 		stopDisplayTimer();
 		gpsPos.stopLog();
 		gpsRunning = false;
-		if (gotoPanel != null) gotoPanel.gpsStoped();
-		if (movingMap != null) movingMap.gpsStoped();
+		if (gotoPanel != null)
+			gotoPanel.gpsStoped();
+		if (movingMap != null)
+			movingMap.gpsStoped();
 	}
 
 	public boolean isGpsPosValid() {
-		return ((serThread != null &amp;&amp; serThread.isAlive()) ||
-		       (gpsdThread != null &amp;&amp; gpsdThread.isAlive()) ||
-		       (oldGpsdThread != null &amp;&amp; oldGpsdThread.isAlive()))
-		        &amp;&amp; gpsPos.isValid() ; // &amp;&amp; gpsPos.getfiex();
+		return ((serThread != null &amp;&amp; serThread.isAlive()) || (gpsdThread != null &amp;&amp; gpsdThread.isAlive()) || (oldGpsdThread != null &amp;&amp; oldGpsdThread.isAlive())) &amp;&amp; gpsPos.isValid(); // &amp;&amp; gpsPos.getfiex();
 	}
 
-
 	public void setDestination(String LatLon) {
 		setDestination(new CWPoint(LatLon));
 	}
 
-
 	public void setDestination(CWPoint d) {
 		destinationIsCache = false;
-		destination = new CWPoint (d);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(destination);
+		destination = new CWPoint(d);
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(destination);
 	}
 
 	public void setDestination(CacheHolder ch) {
 		destinationIsCache = true;
-		destinationCache=ch;
-		destination = new CWPoint (ch.pos);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(ch);
+		destinationCache = ch;
+		destination = new CWPoint(ch.getPos());
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(ch);
 	}
 
 	/**
 	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * 
 	 * @param lu
 	 */
 	public void setLuminary(int lu) {
 		luminary = lu;
 	}
+
 	public void ticked() {
 		int fix = gpsPos.getFix();
-		if (fix &gt; 0 &amp;&amp; (gpsPos.getSats()&gt;= 0)) {
-			if (curTrack == null) curTrack = new Track(trackColor);
+		if (fix &gt; 0 &amp;&amp; (gpsPos.getSats() &gt;= 0)) {
+			if (curTrack == null)
+				curTrack = new Track(trackColor);
 			try {
 				curTrack.add(gpsPos);
 			} catch (IndexOutOfBoundsException e) { // track full -&gt; create a new one
 				curTrack = new Track(trackColor);
 				curTrack.add(gpsPos);
-				if (movingMap != null) movingMap.addTrack(curTrack);
+				if (movingMap != null)
+					movingMap.addTrack(curTrack);
 			}
 			try {
 				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
@@ -245,14 +252,14 @@
 			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
 		}
 		gotoPanel.updateGps(fix);
-		if (movingMap != null) movingMap.updateGps(fix);
+		if (movingMap != null)
+			movingMap.updateGps(fix);
 	}
 }
 
-
 /**
  * Thread for reading data from gpsd.
- *
+ * 
  * @author Tilman Blumenbach
  */
 class GpsdThread extends mThread {
@@ -260,27 +267,24 @@
 	CWGPSPoint myGPS;
 	boolean run;
 
-
 	public GpsdThread(CWGPSPoint GPSPoint) throws IOException, JSONException, GPSException {
 		JSONObject response;
 		int proto_major;
 
 		myGPS = GPSPoint;
 		gpsObj = new GPS(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
-		gpsObj.stream( GPS.WATCH_ENABLE );
+		gpsObj.stream(GPS.WATCH_ENABLE);
 
 		// Check major protocol version:
 		response = gpsObj.read();
 
-		if( ! response.getString( &quot;class&quot; ).equals( &quot;VERSION&quot; ) ) {
-			throw new GPSException( &quot;Expected VERSION object at connect.&quot; );
-		} else if( ( proto_major = response.getInt( &quot;proto_major&quot; ) ) != 3 ) {
-			throw new GPSException( &quot;Invalid protocol API version; got &quot; +
-					proto_major + &quot;, want 3.&quot; );
+		if (!response.getString(&quot;class&quot;).equals(&quot;VERSION&quot;)) {
+			throw new GPSException(&quot;Expected VERSION object at connect.&quot;);
+		} else if ((proto_major = response.getInt(&quot;proto_major&quot;)) != 3) {
+			throw new GPSException(&quot;Invalid protocol API version; got &quot; + proto_major + &quot;, want 3.&quot;);
 		}
 	}
 
-
 	public void run() {
 		JSONObject response;
 		String respClass;
@@ -290,46 +294,46 @@
 
 		run = true;
 		while (run) {
-			if( gpsObj != null ) {
+			if (gpsObj != null) {
 				gotValidData = false;
 
 				try {
-					/* Tblue&gt; This is ugly, but BufferedReader::ready() seems to
-					 *        be broken in Ewe, so instead of only polling when
-					 *        there is no data from gpsd (by checking the return
-					 *        value of GPS::waiting(), we poll on every iteration.
-					 *        Not ideal, but works for now.
+					/*
+					 * Tblue&gt; This is ugly, but BufferedReader::ready() seems to
+					 * be broken in Ewe, so instead of only polling when
+					 * there is no data from gpsd (by checking the return
+					 * value of GPS::waiting(), we poll on every iteration.
+					 * Not ideal, but works for now.
 					 */
 					gpsObj.poll();
 
-					/* Tblue&gt; TODO: I think this call should not block, but
-					 *              my GPS class does not yet support non-blocking
-					 *              reads...
+					/*
+					 * Tblue&gt; TODO: I think this call should not block, but
+					 * my GPS class does not yet support non-blocking
+					 * reads...
 					 */
-					response  = gpsObj.read();
-					
+					response = gpsObj.read();
+
 					// If we get here we have got some data:
 					noData = 0;
 
-					respClass = response.getString( &quot;class&quot; );
-					if( respClass.equals( &quot;DEVICE&quot; ) &amp;&amp; response.has( &quot;activated&quot; ) &amp;&amp;
-						response.getDouble( &quot;activated&quot; ) != 0 )
-					{	// This is a new device, we need to tell gpsd we want to watch it:
-						Global.getPref().log( &quot;New GPS device, sending WATCH command.&quot; );
-						gpsObj.stream( GPS.WATCH_ENABLE );
-					} else if( respClass.equals( &quot;POLL&quot; ) ) {
+					respClass = response.getString(&quot;class&quot;);
+					if (respClass.equals(&quot;DEVICE&quot;) &amp;&amp; response.has(&quot;activated&quot;) &amp;&amp; response.getDouble(&quot;activated&quot;) != 0) { // This is a new device, we need to tell gpsd we want to watch it:
+						Global.getPref().log(&quot;New GPS device, sending WATCH command.&quot;);
+						gpsObj.stream(GPS.WATCH_ENABLE);
+					} else if (respClass.equals(&quot;POLL&quot;)) {
 						gotValidData = myGPS.examineGpsd(response);
-					} else if( respClass.equals( &quot;ERROR&quot; ) ) {
+					} else if (respClass.equals(&quot;ERROR&quot;)) {
 						// Global.getPref().log( &quot;Ignored gpsd error: &quot; + response.getString( &quot;message&quot; ) );
 					}
-				} catch( Exception e ) {
+				} catch (Exception e) {
 					// Something bad happened, will just ignore this JSON
 					// object:
 					// Ignored Exception&quot;, e, true);
 					gotValidData = false;
 				}
 
-				if( gotValidData ) {
+				if (gotValidData) {
 					notInterpreted = 0;
 				} else {
 					notInterpreted++;
@@ -354,18 +358,16 @@
 		myGPS.noData();
 	}
 
-
 	public void stop() {
 		run = false;
 
-		if( gpsObj != null ) {
+		if (gpsObj != null) {
 			gpsObj.cleanup();
 		}
 	}
 }
 
-
-class OldGpsdThread extends mThread{
+class OldGpsdThread extends mThread {
 	Socket gpsdSocket;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -373,7 +375,7 @@
 	String lastError = new String();
 
 	public OldGpsdThread(CWGPSPoint GPSPoint) throws IOException {
-		try{
+		try {
 			gpsdSocket = new Socket(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
 		} catch (IOException e) {
 			throw new IOException(Global.getPref().gpsdHost);
@@ -386,33 +388,36 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(900);
 				noData++;
-				if (noData &gt; 5) { myGPS.noDataError(); }
+				if (noData &gt; 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 			}
-			if (gpsdSocket != null)	{
+			if (gpsdSocket != null) {
 				gpsResult = getGpsdData(&quot;ADPQTV\r\n&quot;);
-				if (gpsResult!=null) {
+				if (gpsResult != null) {
 					noData = 0;
 					if (myGPS.examineOldGpsd(gpsResult))
 						notinterpreted = 0;
 					else
 						notinterpreted++;
-					if (notinterpreted &gt; 22) myGPS.noInterpretableData();
+					if (notinterpreted &gt; 22)
+						myGPS.noInterpretableData();
 				}
 			}
 
-			//myGPS.printAll();
+			// myGPS.printAll();
 		} // while
 		myGPS.noData();
 	}
 
 	private String getGpsdData(String command) {
-		byte[] rcvBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+		byte[] rcvBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 		int rcvLength = 0;
 		try {
 			gpsdSocket.write(command.getBytes());
@@ -430,7 +435,7 @@
 			Global.getPref().log(&quot;Socket exception&quot;, e, true);
 		}
 		String str = null;
-		if (rcvLength &gt; 0)	{
+		if (rcvLength &gt; 0) {
 			str = mString.fromAscii(rcvBuff, 0, rcvLength);
 		}
 		return str;
@@ -438,18 +443,18 @@
 
 	public void stop() {
 		run = false;
-		if (gpsdSocket != null) gpsdSocket.close();
+		if (gpsdSocket != null)
+			gpsdSocket.close();
 	}
 }
 
-
 /**
  * Thread for reading data from COM-port
- *
+ * 
  */
-class SerialThread extends mThread{
+class SerialThread extends mThread {
 	SerialPort comSp;
-	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	byte[] comBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 	int comLength = 0;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -457,18 +462,22 @@
 	String lastError = new String();
 
 	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
-		try{
+		try {
 			spo.portName = CacheWolf.Common.fixSerialPortName(spo.portName);
 			comSp = new SerialPort(spo);
 		} catch (IOException e) {
 			throw new IOException(spo.portName);
 		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm
-		if (forwardIP.length()&gt;0) {
+		if (forwardIP.length() &gt; 0) {
 			try {
 				tcpConn = new Socket(forwardIP, 23);
 				tcpForward = true;
-			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-			} catch (IOException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (ewe.net.UnknownHostException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
+			} catch (IOException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
 			}
 		}
 		myGPS = GPSPoint;
@@ -478,26 +487,34 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(1000);
 				noData++;
-				if (noData &gt; 5) { myGPS.noDataError(); }
+				if (noData &gt; 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 			}
-			if (comSp != null)	{
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-				if (comLength &gt; 0)	{
+			if (comSp != null) {
+				comLength = comSp.nonBlockingRead(comBuff, 0, comBuff.length);
+				if (comLength &gt; 0) {
 					noData = 0;
 					String str = mString.fromAscii(comBuff, 0, comLength);
 					if (tcpForward) {
 						try {
 							tcpConn.write(comBuff, 0, comLength);
-						} catch (IOException e) { tcpForward = false; }
+						} catch (IOException e) {
+							tcpForward = false;
+						}
 					}
-					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
-					if (notinterpreted &gt; 22) myGPS.noInterpretableData();
+					if (myGPS.examine(str))
+						notinterpreted = 0;
+					else
+						notinterpreted++;
+					if (notinterpreted &gt; 22)
+						myGPS.noInterpretableData();
 				}
 			}
 		} // while
@@ -507,7 +524,8 @@
 
 	public void stop() {
 		run = false;
-		if (comSp != null) comSp.close();
+		if (comSp != null)
+			comSp.close();
 	}
 }
 
@@ -522,16 +540,21 @@
 	public int calldelay;
 	public Navigate ticked;
 
-	public UpdateThread (Navigate gp, int cd) {
+	public UpdateThread(Navigate gp, int cd) {
 		ticked = gp;
 		calldelay = cd;
 	}
 
-	public void run () {
+	public void run() {
 		run = true;
 		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {	}
-			try { ticked.ticked();} catch (Exception e) {
+			try {
+				sleep(calldelay);
+			} catch (InterruptedException e) {
+			}
+			try {
+				ticked.ticked();
+			} catch (Exception e) {
 				// Global.getPref().log(&quot;Navigate.UpdateThread.run(): Ignored Exception. There should not be an Exception, so please report it in the cachewolf forum at www.geoclub.de&quot;, e, true);
 			}
 		}
@@ -541,6 +564,3 @@
 		run = false;
 	}
 }
-
-
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003035.html">[Cachewolf-svn] r3044 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="003034.html">[Cachewolf-svn] r3043 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3036">[ date ]</a>
              <a href="thread.html#3036">[ thread ]</a>
              <a href="subject.html#3036">[ subject ]</a>
              <a href="author.html#3036">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
