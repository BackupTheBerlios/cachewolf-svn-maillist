<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r2995 - in trunk: res_noewe src/CacheWolf	src/CacheWolf/imp src/CacheWolf/navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-May/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2995%20-%20in%20trunk%3A%20res_noewe%20src/CacheWolf%0A%09src/CacheWolf/imp%20src/CacheWolf/navi&In-Reply-To=%3C20110506151139.F36404812A2%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002985.html">
   <LINK REL="Next"  HREF="002987.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r2995 - in trunk: res_noewe src/CacheWolf	src/CacheWolf/imp src/CacheWolf/navi</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2995%20-%20in%20trunk%3A%20res_noewe%20src/CacheWolf%0A%09src/CacheWolf/imp%20src/CacheWolf/navi&In-Reply-To=%3C20110506151139.F36404812A2%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r2995 - in trunk: res_noewe src/CacheWolf	src/CacheWolf/imp src/CacheWolf/navi">araber95 at mail.berlios.de
       </A><BR>
    <I>Fri May  6 05:11:39 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002985.html">[Cachewolf-svn] r2994 - trunk/res_noewe/webmapservices
</A></li>
        <LI>Next message: <A HREF="002987.html">[Cachewolf-svn] r2996 - in trunk: res_noewe src/CacheWolf	src/CacheWolf/imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2986">[ date ]</a>
              <a href="thread.html#2986">[ thread ]</a>
              <a href="subject.html#2986">[ subject ]</a>
              <a href="author.html#2986">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-05-06 17:11:39 +0200 (Fri, 06 May 2011)
New Revision: 2995

Modified:
   trunk/res_noewe/spider.def
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
Log:
 first adaption of gc-changes : 
 1. using userID cause login with https not yet implemented.
 2. update import definitions. (spider.def)
 3. using new map for &quot;quick import&quot;
smal corrt in mapInfoObject

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/res_noewe/spider.def	2011-05-06 15:11:39 UTC (rev 2995)
@@ -53,7 +53,8 @@
 # * When entering spaces into a string ensure to escape them or write them as \\u0020
 # * Be sure that you have no hidden spaces at the end of a line or the patterns will not match!
 #------------------------------------------------------------
-loginPage          = <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
+#loginPage          = <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
+loginPage          = <A HREF="https://www.geocaching.com/login/default.aspx">https://www.geocaching.com/login/default.aspx</A>
 loginSuccess       = You\ are\ logged\ in\ as
 nextPage           = /login/default.aspx
 waypoint           = <A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>
@@ -67,8 +68,8 @@
 maxDistance        = &amp;dist=
 nextListPage       = /seek/nearest.aspx
 # Regex to search for cachenames
-listBlockRex       = &lt;table id=&quot;ctl00_ContentBody_dlResults&quot;((?s).*?)&lt;/table&gt;
-lineRex            = &lt;tr\ bgcolor='#.{6}'\\s*class=&quot;Data\ BorderTop&quot;&gt;((?s).*?)&lt;/tr&gt;
+listBlockRex       = &lt;table\ class=&quot;SearchResultsTable\ Table&quot;&gt;((?s).*?)&lt;/table&gt;
+lineRex            = Data\ BorderTop&quot;&gt;((?s).*?)&lt;/tr&gt;
 logDateRex         = &lt;td valign=&quot;top&quot;&gt;\\s*(.*?)&lt;br\ /&gt;
 availableRex       = class=&quot;lnk\ \ Strike&quot;&gt;
 archivedRex        = class=&quot;lnk\ OldWarning\ Strike\ Strike&quot;&gt;
@@ -78,7 +79,7 @@
 distRex            = (.*?)(?:km|mi|ft)
 DTSRex             = v=(.*?)&quot;
 DTSCodeKey         = hbM9fjmrxy7z42LFD58BkKgPGdHscvCqNnw3ptO6lJ
-waypointRex        = \\(GC(.*?)\\)&lt;br\ /&gt;
+waypointRex        = \\|\\s+GC(.*?)\\s+
 TypeRex            = www.geocaching.com/images/wpttypes/sm/(.*?)\\.gif
 found              = class=&quot;Success&quot;
 own                = /WptTypes/name_tag.gif
@@ -109,9 +110,8 @@
 cacheArchived      = class=&quot;OldWarning&quot;&gt;&lt;li&gt;This\ cache\ has\ been\ archived
 premiumCachepage   = class=&quot;Warning&quot;&gt;listing\ visible\ to\ Premium
 latLonRex          = tBody_LatLon&quot;\ style=&quot;font-weight:bold;&quot;&gt;((?s).*?)&lt;/span&gt;
-#latLonRex          = tBody_LatLon&quot;&gt;&lt;b&gt;((?s).*?)&lt;/b&gt;&lt;/span&gt;
 shortDescRex       = tBody_ShortDescription&quot;&gt;((?s).*?)&lt;/span&gt;
-longDescRex        = tBody_LongDescription&quot;&gt;((?s).*?)&lt;td\ valign=&quot;top&quot;\ width=&quot;10%&quot;&gt;\\s*&nbsp;\\s*&lt;/td
+longDescRex        = tBody_LongDescription&quot;&gt;((?s).*?)&lt;/span&gt;\\s+&lt;/div&gt;
 cacheNameRex       = tBody_CacheName&quot;&gt;((?s).*?)&lt;/span&gt;
 cacheOwnerRex      = &amp;wid(?:(?s).*?)&gt;((?s).*?)&lt;
 dateHiddenRex      = (?:Hidden|Event\ Date)\\s*:\\s*((?s).*?)&lt;
@@ -126,7 +126,7 @@
 #Section2a: Logs
 #--------------------------------------
 # blockRex extrahiert zun&#228;chst aus der gesamten Seite den Logbereich
-blockRex           = &lt;table class=&quot;LogsTable Table&quot;&gt;((?s).*?)&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
+blockRex           = &lt;table class=&quot;LogsTable&quot;&gt;((?s).*?)&lt;/table&gt;\\s+&lt;p&gt;\\s+&lt;/p&gt;
 # singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
 singleLogExStart   = &gt;&lt;strong&gt;&lt;img src=
 singleLogExEnd     = &lt;small&gt;&lt;a\ href=&quot;
@@ -161,8 +161,8 @@
 bugLinkEnd         = &quot;\ class=&quot;lnk&quot;&gt;
 bugNameExStart     = &lt;span&gt;
 bugNameExEnd       = &lt;/span&gt;
-bugDetailsStart    = &quot;og:description&quot;\ content=&quot;
-bugDetailsEnd      = &quot;\ property=&quot;og:desc
+bugDetailsStart    = &lt;meta\ name=&quot;og:description&quot;\ content=&quot;
+bugDetailsEnd      = &quot;\ property=&quot;og:description&quot;
 getBugByName       = <A HREF="http://www.geocaching.com/track/search.aspx?k=">http://www.geocaching.com/track/search.aspx?k=</A>
 getBugByGuid       = <A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>
 getBugById         = <A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/Preferences.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -51,30 +51,28 @@
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Map.MapEntry;
 import ewe.util.StringTokenizer;
 import ewe.util.Utils;
-import ewe.util.Map.MapEntry;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	A class to hold the preferences that were loaded upon start up of CacheWolf.
- *	This class is also capable of parsing the prefs.xml file as well as
- *	saving the current settings of preferences.
+ * A class to hold the preferences that were loaded upon start up of CacheWolf. This class is also capable of parsing the prefs.xml file as well as saving the current settings of preferences.
  */
-public class Preferences extends MinML{
+public class Preferences extends MinML {
 
-	public final int DEFAULT_MAX_LOGS_TO_SPIDER=250;
-	public final int DEFAULT_LOGS_PER_PAGE=5;
-	public final int DEFAULT_INITIAL_HINT_HEIGHT=10;
-	public final int DEFAULT_GPSD_PORT=2947;
-	public static final int GPSD_DISABLED   = 0; // do not use gpsd
+	public final int DEFAULT_MAX_LOGS_TO_SPIDER = 250;
+	public final int DEFAULT_LOGS_PER_PAGE = 5;
+	public final int DEFAULT_INITIAL_HINT_HEIGHT = 10;
+	public final int DEFAULT_GPSD_PORT = 2947;
+	public static final int GPSD_DISABLED = 0; // do not use gpsd
 	public static final int GPSD_FORMAT_OLD = 1; // use old protocol
 	public static final int GPSD_FORMAT_NEW = 2; // use new protocol (JSON)
 	public static final int YES = 0;
 	public static final int NO = 1;
 	public static final int ASK = 2;
-	public static String NEWLINE=&quot;\n&quot;;
+	public static String NEWLINE = &quot;\n&quot;;
 	// Hashtable is saving filter data objects the user wants to save
 	private Hashtable filterList = new Hashtable(15);
 	/** screen is big enough to hold additional information like cache notes */
@@ -83,12 +81,13 @@
 	// TODO: make this configurable via pref.xml
 	public boolean useBigIcons;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-    // Constructor
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Constructor
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Singleton pattern - return reference to Preferences
+	 * 
 	 * @return Singleton Preferences object
 	 */
 	public static Preferences getPrefObject() {
@@ -104,81 +103,75 @@
 
 	/**
 	 * Call this method to set the path of the config file &lt;br&gt;
-	 * If you call it with null it defaults to [program-dir]/pref.xml
-	 * if p is a directory &quot;pref.xml&quot; will automatically appended
+	 * If you call it with null it defaults to [program-dir]/pref.xml if p is a directory &quot;pref.xml&quot; will automatically appended
+	 * 
 	 * @param p
 	 */
 	public void setPathToConfigFile(String p) {
 		String p_;
 		if (p == null) {
 			/*
-			String test;
-			test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
-			log(&quot;Vm.getenv(APPDATA: &quot; + test); // this works also in win32.exe (ewe-vm on win xp)
-			test = Vm.getenv(&quot;HOME&quot;, &quot;/&quot;); // This should return on *nix system the home dir
-			log(&quot;Vm.getenv(HOME: &quot; + test);
-			test = System.getProperty(&quot;user.dir&quot;); // return in java-vm on win xp: &lt;working dir&gt; or maybe &lt;program dir&gt;
-			log(&quot;System.getProperty(user.dir: &quot; + test); // in win32.exe -&gt; null
-			test = System.getProperty(&quot;user.home&quot;); // in MS-java-VM env variable $HOME is ignored and always &lt;windir&gt;\java returned, see <A HREF="http://support.microsoft.com/kb/177181/en-us/">http://support.microsoft.com/kb/177181/en-us/</A>
-			log(&quot;System.getProperty(user.home: &quot; + test); // in win32.exe -&gt; null
-			// &quot;user.dir&quot;              User's current working directory
-			// &quot;user.home&quot;             User home directory (taken from <A HREF="http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html">http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html</A> )
+			 * String test; test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt; log(&quot;Vm.getenv(APPDATA: &quot; + test); // this works also in win32.exe (ewe-vm on win xp) test =
+			 * Vm.getenv(&quot;HOME&quot;, &quot;/&quot;); // This should return on *nix system the home dir log(&quot;Vm.getenv(HOME: &quot; + test); test = System.getProperty(&quot;user.dir&quot;); // return in java-vm on win xp: &lt;working dir&gt; or maybe &lt;program dir&gt;
+			 * log(&quot;System.getProperty(user.dir: &quot; + test); // in win32.exe -&gt; null test = System.getProperty(&quot;user.home&quot;); // in MS-java-VM env variable $HOME is ignored and always &lt;windir&gt;\java returned, see
+			 * <A HREF="http://support.microsoft.com/kb/177181/en-us/">http://support.microsoft.com/kb/177181/en-us/</A> log(&quot;System.getProperty(user.home: &quot; + test); // in win32.exe -&gt; null // &quot;user.dir&quot; User's current working directory // &quot;user.home&quot; User home directory (taken from
+			 * <A HREF="http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html">http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html</A> )
 			 */
 			p_ = FileBase.makePath(FileBase.getProgramDirectory(), &quot;pref.xml&quot;);
+		} else {
+			if (new FileBugfix(p).isDirectory())
+				p_ = FileBase.makePath(p, &quot;pref.xml&quot;);
+			else
+				p_ = p;
 		}
-		else {
-			if (new FileBugfix(p).isDirectory()) p_ = FileBase.makePath(p, &quot;pref.xml&quot;);
-			else p_ = p;
-		}
 		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is necessary in case that the root dir is the dir where the pref.xml is stored
 		pathToConfigFile = pathToConfigFile.replace('\\', '/');
-		p=System.getProperty(&quot;os.name&quot;);
-		if (p==null || p.indexOf(&quot;indows&quot;)!=-1) {
+		p = System.getProperty(&quot;os.name&quot;);
+		if (p == null || p.indexOf(&quot;indows&quot;) != -1) {
 			NEWLINE = &quot;\r\n&quot;;
-		} 
+		}
 	}
 
 	/**
 	 * Constructor is private for a singleton object
 	 */
-	private Preferences(){
+	private Preferences() {
 		mySPO.bits = 8;
 		mySPO.parity = SerialPort.NOPARITY;
 		mySPO.stopBits = 1;
 		mySPO.baudRate = 4800;
-		if ( ((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0))).height &gt; 400) {
+		if (((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new ewe.fx.Rect(), 0))).height &gt; 400) {
 			if (Vm.getPlatform().equals(&quot;Unix&quot;))
 				fontSize = 12;
-			else{
+			else {
 				// Default on VGA-PDAs: fontSize 21 + adjust ColWidth
-				if (Vm.isMobile()){
+				if (Vm.isMobile()) {
 					fontSize = 21;
-					listColWidth=&quot;20,20,30,30,92,177,144,83,60,105,50,104,22,30,30&quot;;
-				}
-				else
+					listColWidth = &quot;20,20,30,30,92,177,144,83,60,105,50,104,22,30,30&quot;;
+				} else
 					fontSize = 16;
 			}
 		} else
 			fontSize = 11;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	/** The base directory contains one subdirectory for each profile*/
+	/** The base directory contains one subdirectory for each profile */
 	private String baseDir = &quot;&quot;;
 	public String absoluteBaseDir = &quot;&quot;;
 	/** Name of last used profile */
-	public String lastProfile=&quot;&quot;;
+	public String lastProfile = &quot;&quot;;
 	/** If true, the last profile is reloaded automatically without a dialogue */
-	public boolean autoReloadLastProfile=false;
-	/** If true current cetre will be set from gps position	 */
-	public boolean setCurrentCentreFromGPSPosition=true;
+	public boolean autoReloadLastProfile = false;
+	/** If true current cetre will be set from gps position */
+	public boolean setCurrentCentreFromGPSPosition = true;
 	/** This is the login alias for geocaching.com and opencaching.de */
 	public String myAlias = &quot;&quot;;
 	/** Optional password */
-	public String password=&quot;&quot;;
+	public String password = &quot;&quot;;
 	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs) */
 	public String myAlias2 = &quot;&quot;;
 	/** The path to the browser */
@@ -188,7 +181,7 @@
 	/** HTTP proxy port when spidering */
 	public String myproxyport = &quot;&quot;;
 	/** Flag whether proxy is to be used */
-	public boolean proxyActive=false;
+	public boolean proxyActive = false;
 	/** Serial port name and baudrate */
 	public SerialPortOptions mySPO = new SerialPortOptions();
 	/** True if the GPS data should be forwarded to an IP address */
@@ -210,65 +203,67 @@
 	public String fontName;
 	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
 	/** True if the menu is to be displayed at the top of the screen */
-	public boolean menuAtTop=true;
+	public boolean menuAtTop = true;
 	/** True if the tabs are to be displayed at the top of the screen */
-	public boolean tabsAtTop=true;
+	public boolean tabsAtTop = true;
 	/** True if the status bar is to be displayed (hidden if false) */
-	public boolean showStatus=true;
-	//public boolean noTabs=false;
-	/** True if the application can be closed by clicking on the close button in the top line.
-	 * This can be set to avoid accidental closing of the application */
-	public boolean hasCloseButton=true;
+	public boolean showStatus = true;
+	// public boolean noTabs=false;
+	/**
+	 * True if the application can be closed by clicking on the close button in the top line. This can be set to avoid accidental closing of the application
+	 */
+	public boolean hasCloseButton = true;
 	/** True if the SIP is always visible */
 	public boolean fixSIP = false;
 	/** The list of visible columns in the list view */
-	public String listColMap=&quot;0,1,2,3,4,5,6,7,8,9,10,11,12&quot;;
+	public String listColMap = &quot;0,1,2,3,4,5,6,7,8,9,10,11,12&quot;;
 	/** The widths for each column in list view */
-	public String listColWidth=&quot;15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30&quot;;
+	public String listColWidth = &quot;15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30&quot;;
 	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
-	public String travelbugColMap=&quot;1,4,5,6,8,9,10,7&quot;;
+	public String travelbugColMap = &quot;1,4,5,6,8,9,10,7&quot;;
 	/** The column widths for the travelbug journeys. */
-	public String travelbugColWidth=&quot;212,136,62,90,50,56,90,38,50,50,94,50&quot;;
+	public String travelbugColWidth = &quot;212,136,62,90,50,56,90,38,50,50,94,50&quot;;
 	/** If this flag is true, only non-logged travelbug journeys will be shown */
-	public boolean travelbugShowOnlyNonLogged=false;
+	public boolean travelbugShowOnlyNonLogged = false;
 	/** If this is true, deleted images are shown with a ? in the imagepanel */
-	public boolean showDeletedImages=true;
+	public boolean showDeletedImages = true;
 	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
-	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
+	public int logsPerPage = DEFAULT_LOGS_PER_PAGE;
 	/** Initial height of hints field (set to 0 to hide them initially) */
-	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT;
+	public int initialHintHeight = DEFAULT_INITIAL_HINT_HEIGHT;
 	/** Maximum logs to spider */
 	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
 	/** True if the Solver should ignore the case of variables */
-	public boolean solverIgnoreCase=true;
+	public boolean solverIgnoreCase = true;
 	/** True if the solver expects arguments for trigonometric functions in degrees */
-	public boolean solverDegMode=true;
+	public boolean solverDegMode = true;
 	/** True if the description panel should show images */
-	public boolean descShowImg=true;
+	public boolean descShowImg = true;
 	/** The type of connection which GPSBABEL uses: com1 OR usb. */
-	public String garminConn=&quot;com1&quot;;
+	public String garminConn = &quot;com1&quot;;
 	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
-	public String garminGPSBabelOptions=&quot;&quot;;
+	public String garminGPSBabelOptions = &quot;&quot;;
 	/** Max. length for Garmin waypoint names (for etrex which can only accept 6 chars) */
-	public int garminMaxLen=0;
+	public int garminMaxLen = 0;
 	/** OC true = alle neu Laden false = wenn &#196;nderungsdatum neuer */
 	public boolean downloadAllOC = false;
-	public String lastOCSite=OC.OCSites[0][OC.OC_HOSTNAME];
-	/** The currently used centre point, can be different from the profile's centrepoint. This is used
-	 *  for spidering */
-	private CWPoint curCentrePt=new CWPoint();
+	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
+	/**
+	 * The currently used centre point, can be different from the profile's centrepoint. This is used for spidering
+	 */
+	private CWPoint curCentrePt = new CWPoint();
 	/** True if a login screen is displayed on each spider operation */
-	public boolean forceLogin=true;
+	public boolean forceLogin = true;
 	/** True if the goto panel is North centered */
 	public boolean northCenteredGoto = true;
 	/** If not null, a customs map path has been specified by the user */
-	private String customMapsPath=null;
+	private String customMapsPath = null;
 	/** Number of CacheHolder details that are kept in memory */
-	public int maxDetails=50;
+	public int maxDetails = 50;
 	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
-	public int deleteDetails=5;
+	public int deleteDetails = 5;
 	/** The locale code (DE, EN, ...) */
-	public String language=&quot;&quot;;
+	public String language = &quot;&quot;;
 	/** The metric system to use */
 	public int metricSystem = Metrics.METRIC;
 	/** Load updated caches while spidering */
@@ -282,26 +277,27 @@
 	/** The own GC member ID */
 	public String gcMemberId = &quot;&quot;;
 	/** Premium Member ? */
-	public boolean isPremium=true;
+	public boolean isPremium = true;
 	/** The maximum number of logs to export */
 	public int numberOfLogsToExport = 5;
 	/** Add Travelbugs when exporting */
 	public boolean exportTravelbugs = false;
 	/** Try to make a MyFinds GPX when exporting to GPX */
 	public boolean exportGpxAsMyFinds = true;
-	/** Check if lastFound is newer than saved log*/
-	public boolean checkLog=false;
-	/** Check if presence of TBs changed*/
-	public boolean checkTBs=true;
-	/** Check if presence of DTS changed*/
-	public boolean checkDTS=true;
-	/** menu of spider along a route exists*/
-	public boolean spiderRoute=false;
+	/** Check if lastFound is newer than saved log */
+	public boolean checkLog = false;
+	/** Check if presence of TBs changed */
+	public boolean checkTBs = true;
+	/** Check if presence of DTS changed */
+	public boolean checkDTS = true;
+	/** menu of spider along a route exists */
+	public boolean spiderRoute = false;
 	/** Download images when loading cache data */
 	public boolean downloadPics = true;
 	/** Download TB information when loading cache data */
 	public boolean downloadTBs = true;
-	/** Last mode select in the DataMover for processing cache*/
+	public String userID = &quot;&quot;;
+	/** Last mode select in the DataMover for processing cache */
 	public int processorMode = 0;
 	/** maximum number of logs to store in cache details */
 	public int maxLogsToKeep = DEFAULT_MAX_LOGS_TO_SPIDER;
@@ -309,46 +305,49 @@
 	public boolean alwaysKeepOwnLogs = true;
 
 	/** Determines whether to fill the white areas on the map */
-	public boolean fillWhiteArea=false;
+	public boolean fillWhiteArea = false;
 
-    /** Selected Size of map tiles */
-    public int mapTileSize=1;
-    /** How many should maptiles overlap */
-    public int mapOverlapping=100;
-    /** Width and height of free defined tile size */
-    public int tilewidth;
-    public int tileheight;
-    
-    /** ShowCachesOnMap */
-    public boolean showCachesOnMap=true;
+	/** Selected Size of map tiles */
+	public int mapTileSize = 1;
+	/** How many should maptiles overlap */
+	public int mapOverlapping = 100;
+	/** Width and height of free defined tile size */
+	public int tilewidth;
+	public int tileheight;
 
-    /** SortingGroupedByCache */
-    public boolean SortingGroupedByCache=true;
+	/** ShowCachesOnMap */
+	public boolean showCachesOnMap = true;
 
-    /** useOwnSymbols */
-    public boolean useOwnSymbols=true;
+	/** SortingGroupedByCache */
+	public boolean SortingGroupedByCache = true;
 
-    /** TRUE if we want automatic sorting **/
-    public boolean sortAutomatic = true;
+	/** useOwnSymbols */
+	public boolean useOwnSymbols = true;
 
-	//////////////////////////////////////////////
-	/** The debug switch (Can be used to activate dormant code) by adding
-	 * the line: &lt;pre&gt;&lt;debug value=&quot;true&quot; /&gt;&lt;/pre&gt;
+	/** TRUE if we want automatic sorting **/
+	public boolean sortAutomatic = true;
+
+	// ////////////////////////////////////////////
+	/**
+	 * The debug switch (Can be used to activate dormant code) by adding the line:
+	 * 
+	 * &lt;pre&gt;
+	 * &lt;debug value=&quot;true&quot; /&gt;
+	 * &lt;/pre&gt;
+	 * 
 	 * to the pref.xml file.
 	 */
 	public boolean debug = false;
-	//////////////////////////////////////////////
+	// ////////////////////////////////////////////
 
 	/**
-	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms.
-	 * It can only be set in the Preference-File directly, not by user-interaction now.
-	 * Add  &lt;MobileGui value=&quot;true&quot;/&gt; to your pref.xml
+	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms. It can only be set in the Preference-File directly, not by user-interaction now. Add &lt;MobileGui value=&quot;true&quot;/&gt; to your pref.xml
 	 */
 	public boolean mobileGUI = false;
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields not stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields not stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/** The height of the application */
 	public int myAppHeight = 600;
@@ -359,28 +358,27 @@
 
 	private String pathToProfile;
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Read pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Read pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
-	 * Method to open and parse the config file (pref.xml). Results are stored in the
-	 * public variables of this class.
-	 * If you want to specify a non default config file call setPathToConfigFile() first.
+	 * Method to open and parse the config file (pref.xml). Results are stored in the public variables of this class. If you want to specify a non default config file call setPathToConfigFile() first.
 	 */
-	public void readPrefFile(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
+	public void readPrefFile() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
 			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(pathToConfigFile));
 			parse(r);
 			r.close();
-		}catch(IOException e){
+		} catch (IOException e) {
 			log(&quot;IOException reading config file: &quot; + pathToConfigFile, e, true);
 			browser = getDefaultBrowser();
 			(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), MyLocale.getMsg(176, &quot;First start - using default preferences \n For experts only: \n Could not read preferences file:\n&quot;) + pathToConfigFile, FormBase.OKB)).execute();
-		}catch(Exception e){
+		} catch (Exception e) {
 			if (e instanceof NullPointerException)
-				log(&quot;Error reading pref.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+				log(&quot;Error reading pref.xml: NullPointerException in Element &quot; + lastName + &quot;. Wrong attribute?&quot;, e, true);
 			else
 				log(&quot;Error reading pref.xml: &quot;, e);
 		}
@@ -388,37 +386,33 @@
 		isBigScreen = (MyLocale.getScreenWidth() &gt;= 400) &amp;&amp; (MyLocale.getScreenHeight() &gt;= 600);
 	}
 
-/**
- * Tries to find a executable browser
- * return &quot;&quot; if no browser found
- * @return
- */
+	/**
+	 * Tries to find a executable browser return &quot;&quot; if no browser found
+	 * 
+	 * @return
+	 */
 	private String getDefaultBrowser() {
 		String pf = Vm.getPlatform();
 		String testlist[] = null;
 		if (pf.equals(&quot;Java&quot;) || pf.equals(&quot;Win32&quot;)) {
 			String progdir = Vm.getenv(&quot;ProgramFiles&quot;, null); // at least in java-Win XP this is set
-			String homedir=Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
+			String homedir = Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
 			if (progdir != null) {
-				String test[] = {
-						homedir+&quot;/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe&quot;,
-						progdir+&quot;/Firefox/firefox.exe&quot;,
-						progdir+&quot;/Opera/opera.exe&quot;,
-						progdir+&quot;/Internet Explorer/iexplore.exe&quot;};
+				String test[] = { homedir + &quot;/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe&quot;, progdir + &quot;/Firefox/firefox.exe&quot;, progdir + &quot;/Opera/opera.exe&quot;, progdir + &quot;/Internet Explorer/iexplore.exe&quot; };
 				testlist = test;
 			} else {
 				String test[] = { // this part is not tested
-						&quot;/opt/firefox/firefox&quot;, // default path in ubuntu
-						&quot;/usr/bin/firefox&quot;};
+				&quot;/opt/firefox/firefox&quot;, // default path in ubuntu
+						&quot;/usr/bin/firefox&quot; };
 				testlist = test;
 			}
 		}
 		if (pf.equals(&quot;WinCE&quot;)) {
-			String test[] = {&quot;/windows/iexplore.exe&quot;};
+			String test[] = { &quot;/windows/iexplore.exe&quot; };
 			testlist = test;
 		}
 		if (testlist != null) {
-			for (int i=0; i &lt; testlist.length; i++)
+			for (int i = 0; i &lt; testlist.length; i++)
 				if ((new FileBugfix(testlist[i])).exists()) {
 					return testlist[i];
 				}
@@ -427,10 +421,11 @@
 	}
 
 	/** Helper variables for XML parser */
-	private StringBuffer collectElement=null;
+	private StringBuffer collectElement = null;
 	private String lastName; // The string to the last XML that was processed
+
 	private long getLongAttr(AttributeList atts, String name) {
-		String stmp=atts.getValue(name);
+		String stmp = atts.getValue(name);
 		long ret = 0l;
 		if (stmp != null) {
 			ret = Convert.parseLong(stmp);
@@ -441,182 +436,181 @@
 	/**
 	 * Method that gets called when a new element has been identified in pref.xml
 	 */
-	public void startElement(String name, AttributeList atts){
-		lastName=name;
+	public void startElement(String name, AttributeList atts) {
+		lastName = name;
 		String tmp;
-		if(name.equals(&quot;browser&quot;)) {
+		if (name.equals(&quot;browser&quot;)) {
 			browser = atts.getValue(&quot;name&quot;);
-			if (browser == null || browser.length() == 0) browser = getDefaultBrowser();
-		}
-		else if(name.equals(&quot;fixedsip&quot;)) {
-			if(atts.getValue(&quot;state&quot;).equals(&quot;true&quot;)) {
+			if (browser == null || browser.length() == 0)
+				browser = getDefaultBrowser();
+		} else if (name.equals(&quot;fixedsip&quot;)) {
+			if (atts.getValue(&quot;state&quot;).equals(&quot;true&quot;)) {
 				fixSIP = true;
 			}
-		}
-		else if(name.equals(&quot;font&quot;)) {
+		} else if (name.equals(&quot;font&quot;)) {
 			fontSize = Convert.toInt(atts.getValue(&quot;size&quot;));
 			fontName = atts.getValue(&quot;name&quot;);
-			if (fontName == null) fontName=mApp.findFont(&quot;gui&quot;).getName();
-		}
-		else if(name.equals(&quot;alias&quot;)) {
+			if (fontName == null)
+				fontName = mApp.findFont(&quot;gui&quot;).getName();
+		} else if (name.equals(&quot;alias&quot;)) {
 			myAlias = SafeXML.cleanback(atts.getValue(&quot;name&quot;));
 			tmp = SafeXML.cleanback(atts.getValue(&quot;password&quot;));
-			if (tmp != null) password=tmp;
-		}
-		else if(name.equals(&quot;alias2&quot;)) myAlias2 = SafeXML.cleanback(atts.getValue(&quot;name&quot;));
-		else if(name.equals(&quot;gcmemberid&quot;)) {
+			if (tmp != null)
+				password = tmp;
+		} else if (name.equals(&quot;alias2&quot;))
+			myAlias2 = SafeXML.cleanback(atts.getValue(&quot;name&quot;));
+		else if (name.equals(&quot;gcmemberid&quot;)) {
 			gcMemberId = atts.getValue(&quot;name&quot;);
-			tmp=atts.getValue(&quot;Premium&quot;);
-			if (tmp != null) isPremium=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if(name.equals(&quot;location&quot;)){
-			curCentrePt.set(atts.getValue(&quot;lat&quot;)+&quot; &quot;+atts.getValue(&quot;long&quot;));
-		}
-		else if(name.equals(&quot;port&quot;)){
+			tmp = atts.getValue(&quot;Premium&quot;);
+			if (tmp != null)
+				isPremium = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;location&quot;)) {
+			curCentrePt.set(atts.getValue(&quot;lat&quot;) + &quot; &quot; + atts.getValue(&quot;long&quot;));
+		} else if (name.equals(&quot;port&quot;)) {
 			mySPO.portName = atts.getValue(&quot;portname&quot;);
 			mySPO.baudRate = Convert.toInt(atts.getValue(&quot;baud&quot;));
-		}
-		else if(name.equals(&quot;portforward&quot;)) {
+		} else if (name.equals(&quot;portforward&quot;)) {
 			forwardGPS = Convert.toBoolean(atts.getValue(&quot;active&quot;));
 			forwardGpsHost = atts.getValue(&quot;destinationHost&quot;);
-		}
-		else if(name.equals(&quot;gpsd&quot;)) {
+		} else if (name.equals(&quot;gpsd&quot;)) {
 			useGPSD = Convert.toInt(atts.getValue(&quot;active&quot;));
 			gpsdHost = atts.getValue(&quot;host&quot;);
 			gpsdPort = Convert.toInt(atts.getValue(&quot;port&quot;));
-		}
-		else if(name.equals(&quot;portlog&quot;)) {
+		} else if (name.equals(&quot;portlog&quot;)) {
 			logGPS = Convert.toBoolean(atts.getValue(&quot;active&quot;));
 			logGPSTimer = atts.getValue(&quot;logTimer&quot;);
-		}
-		else if (name.equals(&quot;lastprofile&quot;)) {
-			collectElement=new StringBuffer(50);
-			if (atts.getValue(&quot;autoreload&quot;).equals(&quot;true&quot;)) autoReloadLastProfile=true;
-		}
-		else if (name.equals(&quot;CurrentCentre&quot;)) {
-			setCurrentCentreFromGPSPosition=Boolean.valueOf(atts.getValue(&quot;FromGPSPosition&quot;)).booleanValue();
-		}
-		else if(name.equals(&quot;basedir&quot;)) {
+		} else if (name.equals(&quot;lastprofile&quot;)) {
+			collectElement = new StringBuffer(50);
+			if (atts.getValue(&quot;autoreload&quot;).equals(&quot;true&quot;))
+				autoReloadLastProfile = true;
+		} else if (name.equals(&quot;CurrentCentre&quot;)) {
+			setCurrentCentreFromGPSPosition = Boolean.valueOf(atts.getValue(&quot;FromGPSPosition&quot;)).booleanValue();
+		} else if (name.equals(&quot;basedir&quot;)) {
 			setBaseDir(atts.getValue(&quot;dir&quot;));
-		}
-		else if (name.equals(&quot;opencaching&quot;)) {
-			tmp=atts.getValue(&quot;lastSite&quot;);
-			if (!(tmp == null) &amp;&amp; OC.getSiteIndex(tmp)&gt;=0 ) lastOCSite=tmp;
-			tmp=atts.getValue(&quot;downloadMissing&quot;);
-			if (!(tmp == null)) downloadAllOC = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;listview&quot;)) {
-			listColMap=atts.getValue(&quot;colmap&quot;);
-			listColWidth=atts.getValue(&quot;colwidths&quot;);
-			while ((new StringTokenizer(listColWidth,&quot;,&quot;)).countTokens()&lt;myTableModel.N_COLUMNS) listColWidth+=&quot;,30&quot;; // for older versions
-		}
-		else if(name.equals(&quot;proxy&quot;)) {
+		} else if (name.equals(&quot;opencaching&quot;)) {
+			tmp = atts.getValue(&quot;lastSite&quot;);
+			if (!(tmp == null) &amp;&amp; OC.getSiteIndex(tmp) &gt;= 0)
+				lastOCSite = tmp;
+			tmp = atts.getValue(&quot;downloadMissing&quot;);
+			if (!(tmp == null))
+				downloadAllOC = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;listview&quot;)) {
+			listColMap = atts.getValue(&quot;colmap&quot;);
+			listColWidth = atts.getValue(&quot;colwidths&quot;);
+			while ((new StringTokenizer(listColWidth, &quot;,&quot;)).countTokens() &lt; myTableModel.N_COLUMNS)
+				listColWidth += &quot;,30&quot;; // for older versions
+		} else if (name.equals(&quot;proxy&quot;)) {
 			myproxy = atts.getValue(&quot;prx&quot;);
 			myproxyport = atts.getValue(&quot;prt&quot;);
 			tmp = atts.getValue(&quot;active&quot;);
-			if (tmp != null) proxyActive=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;garmin&quot;)) {
-			garminConn=atts.getValue(&quot;connection&quot;);
+			if (tmp != null)
+				proxyActive = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;garmin&quot;)) {
+			garminConn = atts.getValue(&quot;connection&quot;);
 			tmp = atts.getValue(&quot;GPSBabelOptions&quot;);
-			if (tmp != null) garminGPSBabelOptions=tmp;
+			if (tmp != null)
+				garminGPSBabelOptions = tmp;
 			tmp = atts.getValue(&quot;MaxWaypointLength&quot;);
-			if (tmp != null) garminMaxLen=Convert.toInt(tmp);
+			if (tmp != null)
+				garminMaxLen = Convert.toInt(tmp);
 			tmp = atts.getValue(&quot;addDetailsToWaypoint&quot;);
-			if (tmp != null) addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue(&quot;addDetailsToName&quot;);
-			if (tmp != null) addDetailsToName = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;imagepanel&quot;)) {
+			if (tmp != null)
+				addDetailsToName = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;imagepanel&quot;)) {
 			showDeletedImages = Boolean.valueOf(atts.getValue(&quot;showdeletedimages&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;descpanel&quot;)) {
+		} else if (name.equals(&quot;descpanel&quot;)) {
 			descShowImg = Boolean.valueOf(atts.getValue(&quot;showimages&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;screen&quot;)) {
-			menuAtTop=Boolean.valueOf(atts.getValue(&quot;menuattop&quot;)).booleanValue();
-			tabsAtTop=Boolean.valueOf(atts.getValue(&quot;tabsattop&quot;)).booleanValue();
-			showStatus=Boolean.valueOf(atts.getValue(&quot;showstatus&quot;)).booleanValue();
-			if (atts.getValue(&quot;hasclosebutton&quot;)!=null)
-				hasCloseButton=Boolean.valueOf(atts.getValue(&quot;hasclosebutton&quot;)).booleanValue();
-			if (atts.getValue(&quot;h&quot;)!=null) {
-				myAppHeight=Convert.toInt(atts.getValue(&quot;h&quot;));
-				myAppWidth=Convert.toInt(atts.getValue(&quot;w&quot;));
+		} else if (name.equals(&quot;screen&quot;)) {
+			menuAtTop = Boolean.valueOf(atts.getValue(&quot;menuattop&quot;)).booleanValue();
+			tabsAtTop = Boolean.valueOf(atts.getValue(&quot;tabsattop&quot;)).booleanValue();
+			showStatus = Boolean.valueOf(atts.getValue(&quot;showstatus&quot;)).booleanValue();
+			if (atts.getValue(&quot;hasclosebutton&quot;) != null)
+				hasCloseButton = Boolean.valueOf(atts.getValue(&quot;hasclosebutton&quot;)).booleanValue();
+			if (atts.getValue(&quot;h&quot;) != null) {
+				myAppHeight = Convert.toInt(atts.getValue(&quot;h&quot;));
+				myAppWidth = Convert.toInt(atts.getValue(&quot;w&quot;));
 			}
-		}
-		else if (name.equals(&quot;hintlogpanel&quot;)) {
+		} else if (name.equals(&quot;hintlogpanel&quot;)) {
 			logsPerPage = Convert.parseInt(atts.getValue(&quot;logsperpage&quot;));
-			String strInitialHintHeight=atts.getValue(&quot;initialhintheight&quot;);
-			if (strInitialHintHeight!=null) initialHintHeight=Convert.parseInt(strInitialHintHeight);
-			String strMaxLogsToSpider=atts.getValue(&quot;maxspiderlogs&quot;);
-			if (strMaxLogsToSpider!=null) maxLogsToSpider=Convert.parseInt(strMaxLogsToSpider);
-		}
-		else if (name.equals(&quot;solver&quot;)) {
-			solverIgnoreCase=Boolean.valueOf(atts.getValue(&quot;ignorevariablecase&quot;)).booleanValue();
+			String strInitialHintHeight = atts.getValue(&quot;initialhintheight&quot;);
+			if (strInitialHintHeight != null)
+				initialHintHeight = Convert.parseInt(strInitialHintHeight);
+			String strMaxLogsToSpider = atts.getValue(&quot;maxspiderlogs&quot;);
+			if (strMaxLogsToSpider != null)
+				maxLogsToSpider = Convert.parseInt(strMaxLogsToSpider);
+		} else if (name.equals(&quot;solver&quot;)) {
+			solverIgnoreCase = Boolean.valueOf(atts.getValue(&quot;ignorevariablecase&quot;)).booleanValue();
 			tmp = atts.getValue(&quot;degMode&quot;);
-			if (tmp != null) solverDegMode=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;mapspath&quot;)) {
-			customMapsPath=SafeXML.cleanback(atts.getValue(&quot;dir&quot;)).replace('\\', '/');
-		}
-		else if (name.equals(&quot;debug&quot;)) debug=Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
+			if (tmp != null)
+				solverDegMode = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;mapspath&quot;)) {
+			customMapsPath = SafeXML.cleanback(atts.getValue(&quot;dir&quot;)).replace('\\', '/');
+		} else if (name.equals(&quot;debug&quot;))
+			debug = Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
 
-		else if (name.equals(&quot;expPath&quot;)){
-			exporterPaths.put(atts.getValue(&quot;key&quot;),atts.getValue(&quot;value&quot;));
-		}
-		else if (name.equals(&quot;impPath&quot;)) {
+		else if (name.equals(&quot;expPath&quot;)) {
+			exporterPaths.put(atts.getValue(&quot;key&quot;), atts.getValue(&quot;value&quot;));
+		} else if (name.equals(&quot;impPath&quot;)) {
 			importerPaths.put(atts.getValue(&quot;key&quot;), atts.getValue(&quot;value&quot;));
-		}
-		else if (name.equals(&quot;travelbugs&quot;)) {
-			travelbugColMap=atts.getValue(&quot;colmap&quot;);
-			travelbugColWidth=atts.getValue(&quot;colwidths&quot;);
-			travelbugShowOnlyNonLogged=Boolean.valueOf(atts.getValue(&quot;shownonlogged&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;gotopanel&quot;)) {
+		} else if (name.equals(&quot;travelbugs&quot;)) {
+			travelbugColMap = atts.getValue(&quot;colmap&quot;);
+			travelbugColWidth = atts.getValue(&quot;colwidths&quot;);
+			travelbugShowOnlyNonLogged = Boolean.valueOf(atts.getValue(&quot;shownonlogged&quot;)).booleanValue();
+		} else if (name.equals(&quot;gotopanel&quot;)) {
 			northCenteredGoto = Boolean.valueOf(atts.getValue(&quot;northcentered&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;spider&quot;)) {
+		} else if (name.equals(&quot;spider&quot;)) {
 			forceLogin = Boolean.valueOf(atts.getValue(&quot;forcelogin&quot;)).booleanValue();
-			checkLog = Boolean.valueOf(atts.getValue(&quot;checkLog&quot;)).booleanValue();      
+			checkLog = Boolean.valueOf(atts.getValue(&quot;checkLog&quot;)).booleanValue();
 			tmp = atts.getValue(&quot;checkTBs&quot;);
-			if (tmp != null) checkTBs=Boolean.valueOf(atts.getValue(&quot;checkTBs&quot;)).booleanValue();
+			if (tmp != null)
+				checkTBs = Boolean.valueOf(atts.getValue(&quot;checkTBs&quot;)).booleanValue();
 			tmp = atts.getValue(&quot;checkDTS&quot;);
-			if (tmp != null) checkDTS=Boolean.valueOf(atts.getValue(&quot;checkDTS&quot;)).booleanValue();
+			if (tmp != null)
+				checkDTS = Boolean.valueOf(atts.getValue(&quot;checkDTS&quot;)).booleanValue();
 			spiderRoute = Boolean.valueOf(atts.getValue(&quot;spiderRoute&quot;)).booleanValue();
 			tmp = atts.getValue(&quot;spiderUpdates&quot;);
-			if (tmp != null) spiderUpdates=Convert.parseInt(tmp);
+			if (tmp != null)
+				spiderUpdates = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;maxSpiderNumber&quot;);
-			if (tmp != null) maxSpiderNumber=Convert.parseInt(tmp);
+			if (tmp != null)
+				maxSpiderNumber = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;downloadPics&quot;);
-			if (tmp != null) downloadPics=Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				downloadPics = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue(&quot;downloadTBs&quot;);
-			if (tmp != null) downloadTBs=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;details&quot;)) {
-			maxDetails=Common.parseInt(atts.getValue(&quot;cacheSize&quot;));
-			deleteDetails=Common.parseInt(atts.getValue(&quot;delete&quot;));
-			if (maxDetails&lt;2) maxDetails=2;
-			if (deleteDetails&lt;1) deleteDetails=1;
-		}
-		else if (name.equals(&quot;metric&quot;)) {
-			metricSystem=Common.parseInt(atts.getValue(&quot;type&quot;));
-			if (metricSystem != Metrics.METRIC &amp;&amp;
-					metricSystem != Metrics.IMPERIAL) {
+			if (tmp != null)
+				downloadTBs = Boolean.valueOf(tmp).booleanValue();
+			userID = atts.getValue(&quot;UserID&quot;);
+			if (userID == null)
+				userID = &quot;&quot;;
+		} else if (name.equals(&quot;details&quot;)) {
+			maxDetails = Common.parseInt(atts.getValue(&quot;cacheSize&quot;));
+			deleteDetails = Common.parseInt(atts.getValue(&quot;delete&quot;));
+			if (maxDetails &lt; 2)
+				maxDetails = 2;
+			if (deleteDetails &lt; 1)
+				deleteDetails = 1;
+		} else if (name.equals(&quot;metric&quot;)) {
+			metricSystem = Common.parseInt(atts.getValue(&quot;type&quot;));
+			if (metricSystem != Metrics.METRIC &amp;&amp; metricSystem != Metrics.IMPERIAL) {
 				metricSystem = Metrics.METRIC;
 			}
-		}
-		else if (name.equals(&quot;export&quot;)) {
+		} else if (name.equals(&quot;export&quot;)) {
 			tmp = atts.getValue(&quot;numberOfLogsToExport&quot;);
-			if (tmp != null) numberOfLogsToExport=Convert.parseInt(tmp);
+			if (tmp != null)
+				numberOfLogsToExport = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;exportTravelbugs&quot;);
-			if (tmp != null) exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue(&quot;exportGpxAsMyFinds&quot;);
-			if (tmp != null) exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;locale&quot;)) {
+			if (tmp != null)
+				exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;locale&quot;)) {
 			language = atts.getValue(&quot;language&quot;);
-		}
-		else if (name.equals(&quot;FILTERDATA&quot;)) {
+		} else if (name.equals(&quot;FILTERDATA&quot;)) {
 			// Creating a filter object and reading the saved data
 			String id = SafeXML.cleanback(atts.getValue(&quot;id&quot;));
 			FilterData data = new FilterData();
@@ -627,7 +621,7 @@
 			data.setFilterDiff(atts.getValue(&quot;diff&quot;));
 			data.setFilterTerr(atts.getValue(&quot;terr&quot;));
 			data.setFilterSize(atts.getValue(&quot;size&quot;));
-			long[] filterAttr = { 0l,0l,0l,0l };
+			long[] filterAttr = { 0l, 0l, 0l, 0l };
 			filterAttr[0] = getLongAttr(atts, &quot;attributesYes&quot;);
 			filterAttr[1] = getLongAttr(atts, &quot;attributesYes1&quot;);
 			filterAttr[2] = getLongAttr(atts, &quot;attributesNo&quot;);
@@ -638,95 +632,93 @@
 			data.setUseRegexp(Boolean.valueOf(atts.getValue(&quot;useRegexp&quot;)).booleanValue());
 			tmp = atts.getValue(&quot;noCoord&quot;);
 			if (tmp != null) {
-			  data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
-      } else {
-			  data.setFilterNoCoord(true);
-      }
+				data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
+			} else {
+				data.setFilterNoCoord(true);
+			}
 			// Filter object is remembered under the given ID
 			this.addFilter(id, data);
-		}
-		else if (name.equals (&quot;datamover&quot;)){
+		} else if (name.equals(&quot;datamover&quot;)) {
 			tmp = atts.getValue(&quot;processorMode&quot;);
-			if (tmp != null){
-				processorMode=Convert.parseInt(tmp);
+			if (tmp != null) {
+				processorMode = Convert.parseInt(tmp);
 			}
-		}
-		else if (name.equals(&quot;logkeeping&quot;)) {
+		} else if (name.equals(&quot;logkeeping&quot;)) {
 			tmp = atts.getValue(&quot;maximum&quot;);
 			if (tmp != null)
 				maxLogsToKeep = Convert.parseInt(tmp);
-			if (maxLogsToKeep &lt; 0) maxLogsToKeep = 0;
+			if (maxLogsToKeep &lt; 0)
+				maxLogsToKeep = 0;
 
 			tmp = atts.getValue(&quot;keepown&quot;);
 			if (tmp != null)
 				alwaysKeepOwnLogs = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;fillWhiteArea&quot;)){
+		} else if (name.equals(&quot;fillWhiteArea&quot;)) {
 			tmp = atts.getValue(&quot;on&quot;);
 			fillWhiteArea = tmp != null &amp;&amp; tmp.equalsIgnoreCase(&quot;true&quot;);
-		}
-		else if (name.equals(&quot;mapLoader&quot;)){
-			     tmp = atts.getValue(&quot;tileSize&quot;);
-			     if (tmp == null || tmp.length() == 0) tmp = &quot;1&quot;;
-			     mapTileSize = Convert.parseInt(tmp);
-                 tmp = atts.getValue(&quot;overlapping&quot;);
-			     if (tmp == null || tmp.length() == 0) tmp = &quot;100&quot;;
-			     mapOverlapping = Convert.parseInt(tmp);
-			     tmp = atts.getValue(&quot;tilewidth&quot;);
-			     tilewidth= (tmp != null &amp;&amp; tmp.length() &gt; 0)?Convert.parseInt(tmp):0;
-			     tmp = atts.getValue(&quot;tileheight&quot;);
-			     tileheight= (tmp != null &amp;&amp; tmp.length() &gt; 0)?Convert.parseInt(tmp):0;			    	 
-		}
-		else if (name.equals(&quot;showCachesOnMap&quot;)){
+		} else if (name.equals(&quot;mapLoader&quot;)) {
+			tmp = atts.getValue(&quot;tileSize&quot;);
+			if (tmp == null || tmp.length() == 0)
+				tmp = &quot;1&quot;;
+			mapTileSize = Convert.parseInt(tmp);
+			tmp = atts.getValue(&quot;overlapping&quot;);
+			if (tmp == null || tmp.length() == 0)
+				tmp = &quot;100&quot;;
+			mapOverlapping = Convert.parseInt(tmp);
+			tmp = atts.getValue(&quot;tilewidth&quot;);
+			tilewidth = (tmp != null &amp;&amp; tmp.length() &gt; 0) ? Convert.parseInt(tmp) : 0;
+			tmp = atts.getValue(&quot;tileheight&quot;);
+			tileheight = (tmp != null &amp;&amp; tmp.length() &gt; 0) ? Convert.parseInt(tmp) : 0;
+		} else if (name.equals(&quot;showCachesOnMap&quot;)) {
 			tmp = atts.getValue(&quot;on&quot;);
 			showCachesOnMap = tmp != null &amp;&amp; tmp.equalsIgnoreCase(&quot;true&quot;);
-		}
-		else if (name.equals(&quot;SortingGroupedByCache&quot;)){
+		} else if (name.equals(&quot;SortingGroupedByCache&quot;)) {
 			tmp = atts.getValue(&quot;on&quot;);
 			SortingGroupedByCache = tmp != null &amp;&amp; tmp.equalsIgnoreCase(&quot;true&quot;);
-		}
-		else if (name.equals(&quot;Symbols&quot;)) {
-			useOwnSymbols=Boolean.valueOf(atts.getValue(&quot;useOwnSymbols&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;MobileGui&quot;)) mobileGUI=Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
+		} else if (name.equals(&quot;Symbols&quot;)) {
+			useOwnSymbols = Boolean.valueOf(atts.getValue(&quot;useOwnSymbols&quot;)).booleanValue();
+		} else if (name.equals(&quot;MobileGui&quot;))
+			mobileGUI = Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
 	}
 
-	public void characters( char ch[], int start, int length ) {
-		if (collectElement!=null) {
-			collectElement.append(ch,start,length); // Collect the name of the last profile
+	public void characters(char ch[], int start, int length) {
+		if (collectElement != null) {
+			collectElement.append(ch, start, length); // Collect the name of the last profile
 		}
 	}
 
 	/**
 	 * Method that gets called when the end of an element has been identified in pref.xml
 	 */
-	public void endElement(String tag){
+	public void endElement(String tag) {
 		if (tag.equals(&quot;lastprofile&quot;)) {
-			if (collectElement!=null) lastProfile=collectElement.toString();
+			if (collectElement != null)
+				lastProfile = collectElement.toString();
 		}
-		collectElement=null;
+		collectElement = null;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Write pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Write pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Method to save current preferences in the pref.xml file
 	 */
-	public void savePreferences(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
+	public void savePreferences() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
 			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;);
 			outp.print(&quot;&lt;preferences&gt;\n&quot;);
 			outp.print(&quot;    &lt;locale language=\&quot;&quot; + SafeXML.clean(language) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;basedir dir = \&quot;&quot; + SafeXML.clean(getBaseDir()) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;lastprofile autoreload=\&quot;&quot; + SafeXML.strxmlencode(autoReloadLastProfile) + &quot;\&quot;&gt;&quot; + SafeXML.clean(lastProfile) + &quot;&lt;/lastprofile&gt;\n&quot;); //RB
+			outp.print(&quot;    &lt;lastprofile autoreload=\&quot;&quot; + SafeXML.strxmlencode(autoReloadLastProfile) + &quot;\&quot;&gt;&quot; + SafeXML.clean(lastProfile) + &quot;&lt;/lastprofile&gt;\n&quot;); // RB
 			outp.print(&quot;    &lt;CurrentCentre FromGPSPosition=\&quot;&quot; + SafeXML.clean(Convert.toString(setCurrentCentreFromGPSPosition)) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;alias name =\&quot;&quot;+ SafeXML.clean(myAlias) +&quot;\&quot; password=\&quot;&quot;+SafeXML.clean(password)+&quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;alias2 name =\&quot;&quot;+ SafeXML.clean(myAlias2) +&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;gcmemberid name =\&quot;&quot;+ SafeXML.clean(gcMemberId) + &quot;\&quot;&quot; + &quot; Premium =\&quot;&quot;+ SafeXML.strxmlencode(isPremium) +&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;alias name =\&quot;&quot; + SafeXML.clean(myAlias) + &quot;\&quot; password=\&quot;&quot; + SafeXML.clean(password) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;alias2 name =\&quot;&quot; + SafeXML.clean(myAlias2) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;gcmemberid name =\&quot;&quot; + SafeXML.clean(gcMemberId) + &quot;\&quot;&quot; + &quot; Premium =\&quot;&quot; + SafeXML.strxmlencode(isPremium) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;browser name = \&quot;&quot; + SafeXML.clean(browser) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;proxy prx = \&quot;&quot; + SafeXML.clean(myproxy) + &quot;\&quot; prt = \&quot;&quot; + SafeXML.clean(myproxyport) + &quot;\&quot; active = \&quot;&quot; + SafeXML.strxmlencode(proxyActive) + &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;port portname = \&quot;&quot; + SafeXML.clean(mySPO.portName) + &quot;\&quot; baud = \&quot;&quot; + SafeXML.strxmlencode(mySPO.baudRate) + &quot;\&quot;/&gt;\n&quot;);
@@ -734,8 +726,7 @@
 			outp.print(&quot;    &lt;gpsd active= \&quot;&quot; + SafeXML.strxmlencode(useGPSD) + &quot;\&quot; host = \&quot;&quot; + SafeXML.clean(gpsdHost) + &quot;\&quot; port = \&quot;&quot; + SafeXML.strxmlencode(gpsdPort) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;portlog active= \&quot;&quot; + SafeXML.clean(Convert.toString(logGPS)) + &quot;\&quot; logTimer = \&quot;&quot; + SafeXML.clean(logGPSTimer) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;font name=\&quot;&quot; + fontName + &quot;\&quot; size=\&quot;&quot; + SafeXML.strxmlencode(fontSize) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;screen menuattop=\&quot;&quot;+menuAtTop+&quot;\&quot; tabsattop=\&quot;&quot;+tabsAtTop+&quot;\&quot; showstatus=\&quot;&quot;+showStatus+&quot;\&quot; hasclosebutton=\&quot;&quot;+hasCloseButton+
-	                &quot;\&quot; h=\&quot;&quot;+myAppHeight+&quot;\&quot; w=\&quot;&quot;+myAppWidth+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;screen menuattop=\&quot;&quot; + menuAtTop + &quot;\&quot; tabsattop=\&quot;&quot; + tabsAtTop + &quot;\&quot; showstatus=\&quot;&quot; + showStatus + &quot;\&quot; hasclosebutton=\&quot;&quot; + hasCloseButton + &quot;\&quot; h=\&quot;&quot; + myAppHeight + &quot;\&quot; w=\&quot;&quot; + myAppWidth + &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;fixedsip state = \&quot;&quot; + SafeXML.strxmlencode(fixSIP) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;listview colmap=\&quot;&quot; + SafeXML.clean(listColMap) + &quot;\&quot; colwidths=\&quot;&quot; + SafeXML.clean(listColWidth) + &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;travelbugs colmap=\&quot;&quot; + SafeXML.clean(travelbugColMap) + &quot;\&quot; colwidths=\&quot;&quot; + SafeXML.clean(travelbugColWidth) + &quot;\&quot; shownonlogged=\&quot;&quot; + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + &quot;\&quot; /&gt;\n&quot;);
@@ -743,85 +734,83 @@
 			outp.print(&quot;    &lt;imagepanel showdeletedimages=\&quot;&quot; + SafeXML.strxmlencode(showDeletedImages) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;hintlogpanel logsperpage=\&quot;&quot; + SafeXML.strxmlencode(logsPerPage) + &quot;\&quot; initialhintheight=\&quot;&quot; + SafeXML.strxmlencode(initialHintHeight) + &quot;\&quot;  maxspiderlogs=\&quot;&quot; + SafeXML.strxmlencode(maxLogsToSpider) + &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;solver ignorevariablecase=\&quot;&quot; + SafeXML.strxmlencode(solverIgnoreCase) + &quot;\&quot; degMode=\&quot;&quot; + SafeXML.strxmlencode(solverDegMode) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;garmin connection = \&quot;&quot; + SafeXML.clean(garminConn) + &quot;\&quot; GPSBabelOptions = \&quot;&quot; + SafeXML.clean(garminGPSBabelOptions) + &quot;\&quot; MaxWaypointLength = \&quot;&quot; + SafeXML.strxmlencode(garminMaxLen) +
-					        &quot;\&quot; addDetailsToWaypoint = \&quot;&quot; + SafeXML.strxmlencode(addDetailsToWaypoint) + &quot;\&quot; addDetailsToName = \&quot;&quot; + SafeXML.strxmlencode(addDetailsToName) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;opencaching lastSite=\&quot;&quot;+lastOCSite+&quot;\&quot; downloadMissing=\&quot;&quot; + SafeXML.strxmlencode(downloadAllOC) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;garmin connection = \&quot;&quot; + SafeXML.clean(garminConn) + &quot;\&quot; GPSBabelOptions = \&quot;&quot; + SafeXML.clean(garminGPSBabelOptions) + &quot;\&quot; MaxWaypointLength = \&quot;&quot; + SafeXML.strxmlencode(garminMaxLen) + &quot;\&quot; addDetailsToWaypoint = \&quot;&quot;
+					+ SafeXML.strxmlencode(addDetailsToWaypoint) + &quot;\&quot; addDetailsToName = \&quot;&quot; + SafeXML.strxmlencode(addDetailsToName) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;opencaching lastSite=\&quot;&quot; + lastOCSite + &quot;\&quot; downloadMissing=\&quot;&quot; + SafeXML.strxmlencode(downloadAllOC) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;location lat = \&quot;&quot; + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + &quot;\&quot; long = \&quot;&quot; + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;spider&quot;+
-					&quot; forcelogin=\&quot;&quot; + SafeXML.strxmlencode(forceLogin) + &quot;\&quot;&quot;+
-					&quot; spiderUpdates=\&quot;&quot; + SafeXML.strxmlencode(spiderUpdates) + &quot;\&quot;&quot;+
-					&quot; checkLog=\&quot;&quot; + SafeXML.strxmlencode(checkLog) + &quot;\&quot;&quot;+
-					&quot; checkTBs=\&quot;&quot; + SafeXML.strxmlencode(checkTBs) + &quot;\&quot;&quot;+
-					&quot; checkDTS=\&quot;&quot; + SafeXML.strxmlencode(checkDTS) + &quot;\&quot;&quot;+
-					&quot; spiderRoute=\&quot;&quot; + SafeXML.strxmlencode(spiderRoute) + &quot;\&quot;&quot;+
-					&quot; maxSpiderNumber=\&quot;&quot; + SafeXML.strxmlencode(maxSpiderNumber) + &quot;\&quot;&quot;+
-					&quot; downloadPics=\&quot;&quot; + SafeXML.strxmlencode(downloadPics) + &quot;\&quot;&quot;+
-					&quot; downloadTBs=\&quot;&quot; + SafeXML.strxmlencode(downloadTBs) +&quot;\&quot;&quot;+
-					&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;spider&quot; + &quot; forcelogin=\&quot;&quot; + SafeXML.strxmlencode(forceLogin) + &quot;\&quot;&quot; + &quot; spiderUpdates=\&quot;&quot; + SafeXML.strxmlencode(spiderUpdates) + &quot;\&quot;&quot; + &quot; checkLog=\&quot;&quot; + SafeXML.strxmlencode(checkLog) + &quot;\&quot;&quot; + &quot; checkTBs=\&quot;&quot;
+					+ SafeXML.strxmlencode(checkTBs) + &quot;\&quot;&quot; + &quot; checkDTS=\&quot;&quot; + SafeXML.strxmlencode(checkDTS) + &quot;\&quot;&quot; + &quot; spiderRoute=\&quot;&quot; + SafeXML.strxmlencode(spiderRoute) + &quot;\&quot;&quot; + &quot; maxSpiderNumber=\&quot;&quot; + SafeXML.strxmlencode(maxSpiderNumber) + &quot;\&quot;&quot;
+					+ &quot; downloadPics=\&quot;&quot; + SafeXML.strxmlencode(downloadPics) + &quot;\&quot;&quot; + &quot; downloadTBs=\&quot;&quot; + SafeXML.strxmlencode(downloadTBs) + &quot;\&quot;&quot; + &quot; UserID=\&quot;&quot; + SafeXML.clean(userID) + &quot;\&quot;&quot; + &quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;gotopanel northcentered=\&quot;&quot; + SafeXML.strxmlencode(northCenteredGoto) + &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;details cacheSize=\&quot;&quot; + SafeXML.strxmlencode(maxDetails) + &quot;\&quot; delete=\&quot;&quot; + SafeXML.strxmlencode(deleteDetails) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;metric type=\&quot;&quot; + SafeXML.strxmlencode(metricSystem) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;export numberOfLogsToExport=\&quot;&quot; + SafeXML.strxmlencode(numberOfLogsToExport) + &quot;\&quot; exportTravelbugs=\&quot;&quot; + SafeXML.strxmlencode(exportTravelbugs) + &quot;\&quot; exportGpxAsMyFinds=\&quot;&quot; + SafeXML.strxmlencode(exportGpxAsMyFinds) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;export numberOfLogsToExport=\&quot;&quot; + SafeXML.strxmlencode(numberOfLogsToExport) + &quot;\&quot; exportTravelbugs=\&quot;&quot; + SafeXML.strxmlencode(exportTravelbugs) + &quot;\&quot; exportGpxAsMyFinds=\&quot;&quot; + SafeXML.strxmlencode(exportGpxAsMyFinds)
+					+ &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;datamover processorMode=\&quot;&quot; + SafeXML.strxmlencode(processorMode) + &quot;\&quot; /&gt;\n&quot;);
-			if (customMapsPath!=null) outp.print(&quot;    &lt;mapspath dir = \&quot;&quot; + SafeXML.clean(customMapsPath.replace('\\','/')) + &quot;\&quot;/&gt;\n&quot;);
+			if (customMapsPath != null)
+				outp.print(&quot;    &lt;mapspath dir = \&quot;&quot; + SafeXML.clean(customMapsPath.replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
 			// Saving filters
 			String[] filterIDs = this.getFilterIDs();
-			for (int i=0; i&lt;filterIDs.length; i++){
+			for (int i = 0; i &lt; filterIDs.length; i++) {
 				outp.print(this.getFilter(filterIDs[i]).toXML(filterIDs[i]));
 			}
-			if (debug) outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the debug switch if it is set
+			if (debug)
+				outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the debug switch if it is set
 			// save last path of different exporters
 			Iterator itPath = exporterPaths.entries();
 			MapEntry entry;
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
 				outp.print(&quot;    &lt;expPath key = \&quot;&quot; + SafeXML.clean(entry.getKey().toString()) + &quot;\&quot; value = \&quot;&quot; + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
 			}
 			itPath = importerPaths.entries();
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
 				outp.print(&quot;    &lt;impPath key = \&quot;&quot; + SafeXML.clean(entry.getKey().toString()) + &quot;\&quot; value = \&quot;&quot; + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
 			}
-			outp.print(&quot;    &lt;logkeeping maximum=\&quot;&quot;+SafeXML.strxmlencode(maxLogsToKeep)+&quot;\&quot; keepown=\&quot;&quot;+SafeXML.strxmlencode(alwaysKeepOwnLogs)+&quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;fillWhiteArea on=\&quot;&quot;+SafeXML.strxmlencode(fillWhiteArea)+&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;mapLoader tileSize=\&quot;&quot;+SafeXML.strxmlencode(mapTileSize)+&quot;\&quot; overlapping=\&quot;&quot;+SafeXML.strxmlencode(mapOverlapping)+&quot;\&quot; tilewidth=\&quot;&quot;+SafeXML.strxmlencode(tilewidth)+&quot;\&quot; tileheight=\&quot;&quot;+SafeXML.strxmlencode(tileheight)+&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;showCachesOnMap on=\&quot;&quot;+SafeXML.strxmlencode(showCachesOnMap)+&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;SortingGroupedByCache on=\&quot;&quot;+SafeXML.strxmlencode(SortingGroupedByCache)+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;logkeeping maximum=\&quot;&quot; + SafeXML.strxmlencode(maxLogsToKeep) + &quot;\&quot; keepown=\&quot;&quot; + SafeXML.strxmlencode(alwaysKeepOwnLogs) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;fillWhiteArea on=\&quot;&quot; + SafeXML.strxmlencode(fillWhiteArea) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;mapLoader tileSize=\&quot;&quot; + SafeXML.strxmlencode(mapTileSize) + &quot;\&quot; overlapping=\&quot;&quot; + SafeXML.strxmlencode(mapOverlapping) + &quot;\&quot; tilewidth=\&quot;&quot; + SafeXML.strxmlencode(tilewidth) + &quot;\&quot; tileheight=\&quot;&quot;
+					+ SafeXML.strxmlencode(tileheight) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;showCachesOnMap on=\&quot;&quot; + SafeXML.strxmlencode(showCachesOnMap) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;SortingGroupedByCache on=\&quot;&quot; + SafeXML.strxmlencode(SortingGroupedByCache) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;Symbols useOwnSymbols=\&quot;&quot; + SafeXML.strxmlencode(useOwnSymbols) + &quot;\&quot;/&gt;\n&quot;);
-			if (mobileGUI) outp.print(&quot;    &lt;MobileGui value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the vmgui switch if it is set
+			if (mobileGUI)
+				outp.print(&quot;    &lt;MobileGui value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the vmgui switch if it is set
 			outp.print(&quot;&lt;/preferences&gt;&quot;);
 			outp.close();
 		} catch (Exception e) {
-			log(&quot;Problem saving: &quot; +pathToConfigFile,e,true);
+			log(&quot;Problem saving: &quot; + pathToConfigFile, e, true);
 		}
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Maps
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Maps
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	private static final String mapsPath = &quot;maps/standard&quot;;
 
 	/**
 	 * custom = set by the user
+	 * 
 	 * @return custom Maps Path, null if not set
 	 */
 	public String getCustomMapsPath() {
-	   String rCMP = Global.getProfile().getRelativeCustomMapsPath();
-	   if (rCMP.equals(&quot;&quot;)) {
-		   return customMapsPath;
+		String rCMP = Global.getProfile().getRelativeCustomMapsPath();
+		if (rCMP.equals(&quot;&quot;)) {
+			return customMapsPath;
 		} else {
-			return absoluteBaseDir+&quot;maps&quot;+rCMP;
+			return absoluteBaseDir + &quot;maps&quot; + rCMP;
 		}
 	}
 
 	public void saveCustomMapsPath(String mapspath_) {
 		if (customMapsPath == null || !customMapsPath.equals(mapspath_)) {
-			customMapsPath=new String(mapspath_).replace('\\', '/');
+			customMapsPath = new String(mapspath_).replace('\\', '/');
 			savePreferences();
-			String s = absoluteBaseDir+&quot;maps&quot;;
-			if (customMapsPath.indexOf(s)==0) {
-				String t=customMapsPath.substring(s.length(), customMapsPath.length());
+			String s = absoluteBaseDir + &quot;maps&quot;;
+			if (customMapsPath.indexOf(s) == 0) {
+				String t = customMapsPath.substring(s.length(), customMapsPath.length());
 				Global.getProfile().setRelativeCustomMapsPath(t);
 			} else {
 				Global.getProfile().setRelativeCustomMapsPath(&quot;&quot;);
@@ -830,34 +819,37 @@
 	}
 
 	private myTableModel tableMod;
-	public void setMyTableModel(myTableModel myTableModel) {tableMod=myTableModel;}
-	public CWPoint getCurCentrePt() {return curCentrePt;}
+
+	public void setMyTableModel(myTableModel myTableModel) {
+		tableMod = myTableModel;
+	}
+
+	public CWPoint getCurCentrePt() {
+		return curCentrePt;
+	}
+
 	public void setCurCentrePt(CWPoint newCentre) {
 		Vm.showWait(true);
 		curCentrePt.set(newCentre);
 		Global.getProfile().updateBearingDistance();
 		if (tableMod != null) {
 			// corresponding column for &quot;distance&quot; is column 10
-			if (tableMod.sortedBy == 10) tableMod.isSorted = false;
+			if (tableMod.sortedBy == 10)
+				tableMod.isSorted = false;
 			if (tableMod.sortedBy == 10 &amp;&amp; this.sortAutomatic) {
 				tableMod.sortTable(tableMod.sortedBy, tableMod.sortAscending);
 				// or ??? TablePanel.refreshTable();
-			}
-			else tableMod.tcControl.repaint();
+			} else
+				tableMod.tcControl.repaint();
 		}
 		Vm.showWait(false);
 	}
 
 	/**
-	 * gets the path to the calibrated maps
-	 * it first tries if there are manually imported maps
-	 * in &lt;baseDir&gt;/maps/standard then it tries
-	 * the legacy dir: &lt;program-dir&gt;/maps
-	 * In case in both locations are no .wfl-files
-	 * it returns  &lt;baseDir&gt;/maps/expedia - the place where
-	 * the automatically downloaded maps are placed.
-	 *
-	 *
+	 * gets the path to the calibrated maps it first tries if there are manually imported maps in &lt;baseDir&gt;/maps/standard then it tries the legacy dir: &lt;program-dir&gt;/maps In case in both locations are no .wfl-files it returns &lt;baseDir&gt;/maps/expedia - the
+	 * place where the automatically downloaded maps are placed.
+	 * 
+	 * 
 	 */
 	public String getMapLoadPath() {
 		saveCustomMapsPath(getMapLoadPathInternal());
@@ -868,18 +860,21 @@
 		// here could also a list of map-types displayed...
 		// standard dir
 		String ret = getCustomMapsPath();
-		if (ret != null) return ret;
+		if (ret != null)
+			return ret;
 		ret = getMapManuallySavePath(false);
 		File t = new FileBugfix(ret);
 		String[] f = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
-		if (f != null &amp;&amp; f.length &gt; 0) return  absoluteBaseDir + mapsPath;
+		if (f != null &amp;&amp; f.length &gt; 0)
+			return absoluteBaseDir + mapsPath;
 		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_DIRECTORIES_ONLY | FileBase.LIST_ALWAYS_INCLUDE_DIRECTORIES);
 		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of &lt;baseDir&gt;/maps/standard are .wfl files
 			String[] f2;
-			for (int i = 0; i&lt; f.length; i++) {
-				t.set(null, ret+&quot;/&quot;+f[i]);
+			for (int i = 0; i &lt; f.length; i++) {
+				t.set(null, ret + &quot;/&quot; + f[i]);
 				f2 = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
-				if (f2 != null &amp;&amp; f2.length &gt; 0) return  ret;
+				if (f2 != null &amp;&amp; f2.length &gt; 0)
+					return ret;
 			}
 		}
 		// lagacy dir
@@ -887,45 +882,47 @@
 		t.set(null, ret);
 		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
 		if (f != null &amp;&amp; f.length &gt; 0) {
-			MessageBox inf = new MessageBox(&quot;Information&quot;, &quot;The directory for calibrated maps \nhas moved in this program version\n to '&lt;profiles directory&gt;/maps/standard'\n Do you want to move your calibrated maps there now?&quot;, FormBase.YESB | FormBase.NOB);
+			MessageBox inf = new MessageBox(&quot;Information&quot;, &quot;The directory for calibrated maps \nhas moved in this program version\n to '&lt;profiles directory&gt;/maps/standard'\n Do you want to move your calibrated maps there now?&quot;, FormBase.YESB
+					| FormBase.NOB);
 			if (inf.execute() == FormBase.IDYES) {
 				String sp = getMapManuallySavePath(false);
 				FileBugfix spF = new FileBugfix(sp);
-				if (!spF.exists()) spF.mkdirs();
+				if (!spF.exists())
+					spF.mkdirs();
 				String image;
 				String lagacypath = ret;
-				for (int i=0; i&lt;f.length; i++) {
-					t.set(null, lagacypath+f[i]);
-					spF.set(null, sp+&quot;/&quot;+f[i]);
+				for (int i = 0; i &lt; f.length; i++) {
+					t.set(null, lagacypath + f[i]);
+					spF.set(null, sp + &quot;/&quot; + f[i]);
 					t.move(spF);
-					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(&quot;.&quot;)));
+					image = Common.getImageName(lagacypath + f[i].substring(0, f[i].lastIndexOf(&quot;.&quot;)));
 					t.set(null, image);
-					spF.set(null, sp+&quot;/&quot;+t.getFileExt());
+					spF.set(null, sp + &quot;/&quot; + t.getFileExt());
 					t.move(spF);
 				}
 				t.set(null, lagacypath);
 				t.delete();
 				return sp;
-			}
-			else return  ret;
+			} else
+				return ret;
 		}
 		// expedia dir
 		// return getMapExpediaLoadPath();
 
-		//whole maps directory
+		// whole maps directory
 		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps&quot;;
 	}
 
 	/**
-	 * @param create if true the directory if it doesn't exist will be created
-	 * @return the path where manually imported maps should be stored
-	 * this should be adjustable in preferences...
+	 * @param create
+	 *            if true the directory if it doesn't exist will be created
+	 * @return the path where manually imported maps should be stored this should be adjustable in preferences...
 	 */
 	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = absoluteBaseDir + mapsPath;
 		if (create &amp;&amp; !(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
 			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation failed?
-				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+mapsDir, FormBase.OKB)).exec();
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + mapsDir, FormBase.OKB)).exec();
 				return null;
 			}
 		}
@@ -937,11 +934,12 @@
 	 */
 	public String getMapDownloadSavePath(String mapkind) {
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().absoluteBaseDir.length()).replace('\\', '/');
-		String mapsDir = Global.getPref().absoluteBaseDir + &quot;maps/&quot; + Common.ClearForFileName(mapkind)+ &quot;/&quot; + subdir;
+		String mapsDir = Global.getPref().absoluteBaseDir + &quot;maps/&quot; + Common.ClearForFileName(mapkind) + &quot;/&quot; + subdir;
 		if (!(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
 			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation failed?
-			{(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
-			return null;
+			{
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
+				return null;
 			}
 		}
 		return mapsDir;
@@ -951,18 +949,17 @@
 		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps/expedia&quot;; // baseDir has trailing /
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Profile Selector
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Profile Selector
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
-	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
-	static protected final int PROFILE_SELECTOR_ONOROFF=2;
+	static protected final int PROFILE_SELECTOR_FORCED_ON = 0;
+	static protected final int PROFILE_SELECTOR_FORCED_OFF = 1;
+	static protected final int PROFILE_SELECTOR_ONOROFF = 2;
 
 	/**
-	 * tries to get the home data dir of the user
-	 * e.g. &quot;c:\documents and...\&lt;user&gt;\my documents&quot; or &quot;/home/&lt;user&gt;&quot; in linux
-	 * if none could be identified, &quot;/&quot; is returned.
+	 * tries to get the home data dir of the user e.g. &quot;c:\documents and...\&lt;user&gt;\my documents&quot; or &quot;/home/&lt;user&gt;&quot; in linux if none could be identified, &quot;/&quot; is returned.
+	 * 
 	 * @return
 	 */
 	public String getHomeDir() {
@@ -971,79 +968,83 @@
 		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in win32.exe (ewe-vm on win xp)
 		test += Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
 		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in win32.exe (ewe-vm on win xp)
-		if (test.length() == 0)	test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;); // This should return on *nix system the home dir
-		if (test.length() == 0)	test = &quot;/&quot;;
+		if (test.length() == 0)
+			test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;); // This should return on *nix system the home dir
+		if (test.length() == 0)
+			test = &quot;/&quot;;
 		return test;
 	}
 
 	private void checkAbsoluteBaseDir() {
 		// If datadir is empty, ask for one
-		if (absoluteBaseDir.length()==0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
+		if (absoluteBaseDir.length() == 0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
 			do {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, getHomeDir());
-				fc.title = MyLocale.getMsg(170,&quot;Select base directory for cache data&quot;);
+				fc.title = MyLocale.getMsg(170, &quot;Select base directory for cache data&quot;);
 				// If no base directory given, terminate
-				if (fc.execute() == FormBase.IDCANCEL) ewe.sys.Vm.exit(0);
+				if (fc.execute() == FormBase.IDCANCEL)
+					ewe.sys.Vm.exit(0);
 				setBaseDir(fc.getChosenFile().toString());
-			}while (!(new FileBugfix(absoluteBaseDir)).exists());
+			} while (!(new FileBugfix(absoluteBaseDir)).exists());
 		}
 	}
 
 	/**
 	 * Open Profile selector screen
+	 * 
 	 * @param prof
 	 * @param showProfileSelector
 	 * @return True if a profile was selected
 	 */
 	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
 		checkAbsoluteBaseDir();
-		boolean profileExists=true;  // Assume that the profile exists
+		boolean profileExists = true; // Assume that the profile exists
 		do {
-			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) ||
-					(showProfileSelector==PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)){ // Ask for the profile
-				ProfilesForm f = new ProfilesForm(absoluteBaseDir,lastProfile,!profileExists || hasNewButton ? 0 : 1);
+			if (!profileExists || (showProfileSelector == PROFILE_SELECTOR_FORCED_ON) || (showProfileSelector == PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)) { // Ask for the profile
+				ProfilesForm f = new ProfilesForm(absoluteBaseDir, lastProfile, !profileExists || hasNewButton ? 0 : 1);
 				int code = f.execute();
 				// If no profile chosen (includes a new one), terminate
-				if (code==-1) return false; // Cancel pressed
+				if (code == -1)
+					return false; // Cancel pressed
 				CWPoint savecenter = new CWPoint(prof.centre);
 				prof.clearProfile();
 				prof.setCenterCoords(savecenter);
-				//prof.hasUnsavedChanges = true;
-				//curCentrePt.set(0,0); // No centre yet
-				lastProfile=f.newSelectedProfile;
+				// prof.hasUnsavedChanges = true;
+				// curCentrePt.set(0,0); // No centre yet
+				lastProfile = f.newSelectedProfile;
 			}
-			profileExists=(new FileBugfix(absoluteBaseDir+lastProfile)).exists();
-			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
-					           MyLocale.getMsg(171,&quot;Profile does not exist: &quot;)+lastProfile,FormBase.MBOK)).execute();
-		} while (profileExists==false);
+			profileExists = (new FileBugfix(absoluteBaseDir + lastProfile)).exists();
+			if (!profileExists)
+				(new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(171, &quot;Profile does not exist: &quot;) + lastProfile, FormBase.MBOK)).execute();
+		} while (profileExists == false);
 		// Now we are sure that baseDir exists and basDir+profile exists
-		prof.name=lastProfile;
-		prof.dataDir=absoluteBaseDir+lastProfile;
-		prof.dataDir=prof.dataDir.replace('\\','/');
-		if (!prof.dataDir.endsWith(&quot;/&quot;)) prof.dataDir+='/';
-		pathToProfile=prof.dataDir;
+		prof.name = lastProfile;
+		prof.dataDir = absoluteBaseDir + lastProfile;
+		prof.dataDir = prof.dataDir.replace('\\', '/');
+		if (!prof.dataDir.endsWith(&quot;/&quot;))
+			prof.dataDir += '/';
+		pathToProfile = prof.dataDir;
 		savePreferences();
 		return true;
 	}
 
 	static public boolean deleteDirectory(FileBugfix path) {
-	    if( path.exists() ) {
-	    	String[] files = path.list();
-	    	for(int i=0; i&lt;files.length; i++) {
-	    		FileBugfix f = new FileBugfix(path.getFullPath() + &quot;/&quot; + files[i]);
-		        if(f.isDirectory()) {
-		        	deleteDirectory(f);
-		        }
-		        else {
-		        	f.delete();
-		        }
-		     }
-		    }
-	    return( path.delete() );
+		if (path.exists()) {
+			String[] files = path.list();
+			for (int i = 0; i &lt; files.length; i++) {
+				FileBugfix f = new FileBugfix(path.getFullPath() + &quot;/&quot; + files[i]);
+				if (f.isDirectory()) {
+					deleteDirectory(f);
+				} else {
+					f.delete();
+				}
+			}
+		}
+		return (path.delete());
 	}
 
 	static public boolean renameDirectory(FileBugfix OldPath, FileBugfix NewPath) {
-	    return OldPath.renameTo(NewPath);
+		return OldPath.renameTo(NewPath);
 	}
 
 	/*
@@ -1052,147 +1053,165 @@
 	public void editProfile(int operation, int ErrorMsgActive, int ErrorMsg) {
 		checkAbsoluteBaseDir(); // perhaps not necessary
 		// select profile
-		ProfilesForm f = new ProfilesForm(absoluteBaseDir,&quot;&quot;,operation);
-		if (f.execute()==-1) return ; // no select
+		ProfilesForm f = new ProfilesForm(absoluteBaseDir, &quot;&quot;, operation);
+		if (f.execute() == -1)
+			return; // no select
 		// check selection
 		if (lastProfile.equals(f.newSelectedProfile)) {
 			// aktives Profil kann nicht gel&#246;scht / umbenannt werden;
-			new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(ErrorMsgActive,&quot;[Profile active...]&quot;),FormBase.MBOK).execute();
-		}
-		else {
-			boolean err=true;
-			if (operation==3) {
-				String newName = new InputBox(&quot;Bitte neuen Verzeichnisnamen eingeben : &quot;).input(&quot;&quot;,50);
+			new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(ErrorMsgActive, &quot;[Profile active...]&quot;), FormBase.MBOK).execute();
+		} else {
+			boolean err = true;
+			if (operation == 3) {
+				String newName = new InputBox(&quot;Bitte neuen Verzeichnisnamen eingeben : &quot;).input(&quot;&quot;, 50);
 				if (!newName.equals(null)) {
-					err=!renameDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile),new FileBugfix(absoluteBaseDir+newName));
+					err = !renameDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile), new FileBugfix(absoluteBaseDir + newName));
 				}
-			}
-			else
-			if (operation==2){
+			} else if (operation == 2) {
 				Profile p = new Profile();
-				p.dataDir=absoluteBaseDir+f.newSelectedProfile+&quot;/&quot;;
+				p.dataDir = absoluteBaseDir + f.newSelectedProfile + &quot;/&quot;;
 				p.readIndex();
-				String mapsPath=absoluteBaseDir+&quot;maps&quot;+p.getRelativeCustomMapsPath();
-				int answer=new MessageBox(&quot;&quot;,mapsPath+&quot; &quot;+MyLocale.getMsg(143,&quot;l&#246;schen ?&quot;),FormBase.MBYESNO).execute();
-				if (answer==1) {
+				String mapsPath = absoluteBaseDir + &quot;maps&quot; + p.getRelativeCustomMapsPath();
+				int answer = new MessageBox(&quot;&quot;, mapsPath + &quot; &quot; + MyLocale.getMsg(143, &quot;l&#246;schen ?&quot;), FormBase.MBYESNO).execute();
+				if (answer == 1) {
 					deleteDirectory(new FileBugfix(mapsPath));
 				}
-				err=!deleteDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile));
+				err = !deleteDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile));
 				// ? wait until deleted ?
 			}
-			if (err) {new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(ErrorMsg,&quot;[Profile Error...]&quot;),FormBase.MBOK).execute();}
+			if (err) {
+				new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(ErrorMsg, &quot;[Profile Error...]&quot;), FormBase.MBOK).execute();
+			}
 		}
 	}
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Log functions
-	//////////////////////////////////////////////////////////////////////////////////////
 
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Log functions
+	// ////////////////////////////////////////////////////////////////////////////////////
+
 	// FIXME: should use path to config file instead of program directory
 	/** Log file is in program directory and called log.txt */
-	private final String LOGFILENAME=FileBase.getProgramDirectory()+&quot;/log.txt&quot;;
+	private final String LOGFILENAME = FileBase.getProgramDirectory() + &quot;/log.txt&quot;;
 
 	/**
-	 * Method to delete an existing log file. Called on every SpiderGC.
-	 * The log file is also cleared when Preferences is created and the filesize &gt; 60KB
+	 * Method to delete an existing log file. Called on every SpiderGC. The log file is also cleared when Preferences is created and the filesize &gt; 60KB
 	 */
-	public void logInit(){
+	public void logInit() {
 		File logFile = new FileBugfix(LOGFILENAME);
 		logFile.delete();
-		log(&quot;CW Version &quot;+Version.getReleaseDetailed(),null,true);
-		
-		if (System.getProperty(&quot;os.name&quot;)!=null) log(&quot;Operating system: &quot;+System.getProperty(&quot;os.name&quot;)+&quot;/&quot;+System.getProperty(&quot;os.arch&quot;),null,true);
-		if (System.getProperty(&quot;java.vendor&quot;)!=null) log(&quot;Java: &quot;+System.getProperty(&quot;java.vendor&quot;)+&quot;/&quot;+System.getProperty(&quot;java.version&quot;),null,true);
-		
+		log(&quot;CW Version &quot; + Version.getReleaseDetailed(), null, true);
+
+		if (System.getProperty(&quot;os.name&quot;) != null)
+			log(&quot;Operating system: &quot; + System.getProperty(&quot;os.name&quot;) + &quot;/&quot; + System.getProperty(&quot;os.arch&quot;), null, true);
+		if (System.getProperty(&quot;java.vendor&quot;) != null)
+			log(&quot;Java: &quot; + System.getProperty(&quot;java.vendor&quot;) + &quot;/&quot; + System.getProperty(&quot;java.version&quot;), null, true);
+
 	}
 
 	boolean forceLog = false;
-	
+
 	/**
-	 * Method to log messages to a file called log.txt
-	 * It will always append to an existing file.
-	 * To show the message on the console, the global variable debug must be set.
-	 * This can be done by adding
-	 * &lt;pre&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/pre&gt;
+	 * Method to log messages to a file called log.txt It will always append to an existing file. To show the message on the console, the global variable debug must be set. This can be done by adding
+	 * 
+	 * &lt;pre&gt;
+	 * &lt;debug value=&quot;true&quot;&gt;
+	 * &lt;/pre&gt;
+	 * 
 	 * to the pref.xml file
-	 * @param text to log
+	 * 
+	 * @param text
+	 *            to log
 	 */
-	public void log(String text){
+	public void log(String text) {
 		if (debug || forceLog) {
-			if (debug) Vm.debug(text);
+			if (debug)
+				Vm.debug(text);
 			Time dtm = new Time();
 			dtm.getTime();
 			dtm.setFormat(&quot;dd.MM.yyyy'/'HH:mm:ss.SSS&quot;);
-			text = dtm.toString()+ &quot;: &quot;+ text;
+			text = dtm.toString() + &quot;: &quot; + text;
 			FileWriter logFile = null;
-			try{
+			try {
 				logFile = new FileWriter(LOGFILENAME, true);
-				//Stream strout = null;
-				//strout = logFile.toWritableStream(true);
-				logFile.print(text+NEWLINE);
-			}catch(Exception ex){
+				// Stream strout = null;
+				// strout = logFile.toWritableStream(true);
+				logFile.print(text + NEWLINE);
+			} catch (Exception ex) {
 				Vm.debug(&quot;Error writing to log file!&quot;);
-			}finally{
-				if (logFile != null) try {logFile.close(); } catch (IOException ioe) {
-					// log(&quot;Ignored Exception&quot;, ioe, true);
-				}
+			} finally {
+				if (logFile != null)
+					try {
+						logFile.close();
+					} catch (IOException ioe) {
+						// log(&quot;Ignored Exception&quot;, ioe, true);
+					}
 			}
 		}
 	}
 
-	/** Log an exception to the log file with or without a stack trace
-	 *
-	 * @param text Optional message (Can be empty string)
-	 * @param e The exception
-	 * @param withStackTrace If true and the debug switch is true, the stack trace is appended to the log
-	 * The debug switch can be set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file
-	 * or by manually setting it (i.e. in BE versions or RC versions) by including the line
-	 * &lt;pre&gt;Global.getPref().debug=true;&lt;/pre&gt;
-	 * in Version.getRelease()
+	/**
+	 * Log an exception to the log file with or without a stack trace
+	 * 
+	 * @param text
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
+	 * @param withStackTrace
+	 *            If true and the debug switch is true, the stack trace is appended to the log The debug switch can be set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file or by manually setting it (i.e. in BE
+	 *            versions or RC versions) by including the line
+	 * 
+	 *            &lt;pre&gt;
+	 * Global.getPref().debug = true;
+	 * &lt;/pre&gt;
+	 * 
+	 *            in Version.getRelease()
 	 */
-	public void log(String text,Throwable e, boolean withStackTrace) {
-		if (e!=null) {
-			text+=Preferences.NEWLINE;
+	public void log(String text, Throwable e, boolean withStackTrace) {
+		if (e != null) {
+			text += Preferences.NEWLINE;
 			if (withStackTrace)
-				text+=ewe.sys.Vm.getAStackTrace(e);
+				text += ewe.sys.Vm.getAStackTrace(e);
 			else
-				text+=e.toString();
+				text += e.toString();
 		}
-		forceLog=true;
+		forceLog = true;
 		log(text);
-		forceLog=false;
+		forceLog = false;
 	}
 
-	/** Log an exception to the log file without a stack trace, i.e.
-	 * where a stack trace is not needed because the location/cause of the error is clear
-	 *
-	 * @param message Optional message (Can be empty string)
-	 * @param e The exception
+	/**
+	 * Log an exception to the log file without a stack trace, i.e. where a stack trace is not needed because the location/cause of the error is clear
+	 * 
+	 * @param message
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
 	 */
-	public void log(String message,Exception e) {
-		log (message,e,false);
+	public void log(String message, Exception e) {
+		log(message, e, false);
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Exporter path functions
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Exporter path functions
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/** Hashtable for storing the last export path */
 	private Hashtable exporterPaths = new Hashtable();
 
-	public void setExportPath(String exporter,String path){
+	public void setExportPath(String exporter, String path) {
 		exporterPaths.put(exporter, path);
 		savePreferences();
 	}
 
-	public void setExportPathFromFileName(String exporter,String filename){
-		File tmpfile = new FileBugfix (filename);
+	public void setExportPathFromFileName(String exporter, String filename) {
+		File tmpfile = new FileBugfix(filename);
 		exporterPaths.put(exporter, tmpfile.getPath());
 		savePreferences();
 	}
 
-	public String getExportPath(String exporter){
+	public String getExportPath(String exporter) {
 		String dir = (String) exporterPaths.get(exporter);
-		if (dir == null){
+		if (dir == null) {
 			dir = Global.getProfile().dataDir;
 		}
 		return dir;
@@ -1207,14 +1226,16 @@
 
 	public String getImporterPath(String importer) {
 		String dir = (String) importerPaths.get(importer);
-		if (null == dir) dir = Global.getProfile().dataDir;
+		if (null == dir)
+			dir = Global.getProfile().dataDir;
 		return dir;
 	}
 
 	/**
-	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is
-	 * saved in the preferences.
-	 * @param filterID ID of the filter to check
+	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is saved in the preferences.
+	 * 
+	 * @param filterID
+	 *            ID of the filter to check
 	 * @return True or false
 	 */
 	public boolean hasFilter(String filterID) {
@@ -1222,29 +1243,33 @@
 	}
 
 	/**
-	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object,
-	 * so it may be resaved under another ID.
-	 * @param filterID ID of the FilterData object
+	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, so it may be resaved under another ID.
+	 * 
+	 * @param filterID
+	 *            ID of the FilterData object
 	 * @return FilterData object
 	 */
 	public FilterData getFilter(String filterID) {
-		return (FilterData)this.filterList.get(filterID);
+		return (FilterData) this.filterList.get(filterID);
 	}
 
 	/**
-	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the
-	 * given ID, the old object is removed and the new one is set at its place.
-	 * @param filterID ID to associate with the filter object
-	 * @param filter FilterData object
+	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the given ID, the old object is removed and the new one is set at its place.
+	 * 
+	 * @param filterID
+	 *            ID to associate with the filter object
+	 * @param filter
+	 *            FilterData object
 	 */
 	public void addFilter(String filterID, FilterData filter) {
 		this.filterList.put(filterID, filter);
 	}
 
 	/**
-	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object
-	 * exists, nothing happens.
-	 * @param filterID ID of FilterData object to remove
+	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object exists, nothing happens.
+	 * 
+	 * @param filterID
+	 *            ID of FilterData object to remove
 	 */
 	public void removeFilter(String filterID) {
 		this.filterList.remove(filterID);
@@ -1252,13 +1277,14 @@
 
 	/**
 	 * Returns a alphabetically sorted array of ID of saved FilterData objects.
+	 * 
 	 * @return Array of IDs
 	 */
 	public String[] getFilterIDs() {
 		String[] result;
 		result = new String[this.filterList.size()];
 		Enumeration en = this.filterList.keys();
-		int i=0;
+		int i = 0;
 		while (en.hasMoreElements()) {
 			result[i++] = (String) en.nextElement();
 		}
@@ -1275,26 +1301,28 @@
 	public String gpsbabel = null;
 
 	public void setgpsbabel() {
-		try{
+		try {
 			ewe.sys.Process p = Vm.exec(&quot;gpsbabel -V&quot;);
 			p.waitFor();
-			gpsbabel=&quot;gpsbabel&quot;;
-		}catch(IOException ioex){
+			gpsbabel = &quot;gpsbabel&quot;;
+		} catch (IOException ioex) {
 			// Most of the time there will be an exception, so don't complain
 		}
-		if ( gpsbabel == null ) {
-			try{
+		if (gpsbabel == null) {
+			try {
 				ewe.sys.Process p = Vm.exec(&quot;gpsbabel.exe -V&quot;);
 				p.waitFor();
 				gpsbabel = &quot;gpsbabel.exe&quot;;
-			}catch(IOException ioex){
+			} catch (IOException ioex) {
 				// Most of the time there will be an exception, so don't complain
 			}
 		}
 	}
 
-	/** get directory where pref.xml is stored&lt;br&gt;
-	 *  use this if you need a path where the user has sufficient rights to create a file */
+	/**
+	 * get directory where pref.xml is stored&lt;br&gt;
+	 * use this if you need a path where the user has sufficient rights to create a file
+	 */
 	public String getPathToConfigFile() {
 		return pathToConfigFile;
 	}
@@ -1305,11 +1333,13 @@
 
 	public void setBaseDir(String dir) {
 		baseDir = dir;
-		baseDir=baseDir.replace('\\','/');
-		if (!baseDir.endsWith(&quot;/&quot;)) baseDir+=&quot;/&quot;;
+		baseDir = baseDir.replace('\\', '/');
+		if (!baseDir.endsWith(&quot;/&quot;))
+			baseDir += &quot;/&quot;;
 		absoluteBaseDir = new FileBugfix(baseDir).getAbsolutePath();
-		absoluteBaseDir=absoluteBaseDir.replace('\\','/');
-		if (!absoluteBaseDir.endsWith(&quot;/&quot;)) absoluteBaseDir+=&quot;/&quot;;
+		absoluteBaseDir = absoluteBaseDir.replace('\\', '/');
+		if (!absoluteBaseDir.endsWith(&quot;/&quot;))
+			absoluteBaseDir += &quot;/&quot;;
 	}
 
 }

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -54,351 +54,326 @@
 import ewe.ui.mTabbedPanel;
 
 /**
-*	This class displays a user interface allowing the user to change and set
-*	preferences. It also provides a method to save the changed preferences that
-*	are saved immediatly when the user presses &quot;Apply&quot;.
-*	Class ID=600
-*/
+ * This class displays a user interface allowing the user to change and set preferences. It also provides a method to save the changed preferences that are saved immediatly when the user presses &quot;Apply&quot;. Class ID=600
+ */
 public class PreferencesScreen extends Form {
 	mButton cancelB, applyB, brwBt, gpsB;
 	mChoice inpLanguage, inpMetric, inpSpiderUpdates;
-	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, 
-	       inpLogsPerPage,inpMaxLogsToSpider,inpPassword,inpGcMemberID;
-	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus,chkHasCloseButton,
-	          chkSynthShort,chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, 
-	          chkSetCurrentCentreFromGPSPosition,chkSortingGroupedByCache,chkuseOwnSymbols,chkDebug,chkPM;
+	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, inpLogsPerPage, inpMaxLogsToSpider, inpPassword, inpGcMemberID, inpUserID;
+	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, chkSetCurrentCentreFromGPSPosition,
+			chkSortingGroupedByCache, chkuseOwnSymbols, chkDebug, chkPM;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
 	mLabel lblGarmin;
-	TableColumnChooser tccBugs,tccList;
-	
+	TableColumnChooser tccBugs, tccList;
+
 	Preferences pref;
-	
+
 	CellPanel pnlGeneral = new CellPanel();
 	CellPanel pnlDisplay = new CellPanel();
 	CellPanel pnlMore = new CellPanel();
 	CellPanel pnlTB = new CellPanel();
 
 	// ScrollBarPanel scp;
-	String [] garminPorts= new String[]{&quot;com1&quot;,&quot;com2&quot;,&quot;com3&quot;,&quot;com4&quot;,&quot;com5&quot;,&quot;com6&quot;,&quot;com7&quot;,&quot;usb&quot;};
-	
-	public PreferencesScreen (Preferences p){
+	String[] garminPorts = new String[] { &quot;com1&quot;, &quot;com2&quot;, &quot;com3&quot;, &quot;com4&quot;, &quot;com5&quot;, &quot;com6&quot;, &quot;com7&quot;, &quot;usb&quot; };
+
+	public PreferencesScreen(Preferences p) {
 		int sw = MyLocale.getScreenWidth();
 		int sh = MyLocale.getScreenHeight();
 
-		mTab=new mTabbedPanel();
-		
+		mTab = new mTabbedPanel();
+
 		pref = p;
-		this.title = MyLocale.getMsg(600,&quot;Preferences&quot;);
+		this.title = MyLocale.getMsg(600, &quot;Preferences&quot;);
 		if ((sw &gt; 240) &amp;&amp; (sh &gt; 240))
 			this.resizable = true;
-		//this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		// this.moveable = true;
+		// this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 
 		// set dialog-width according to fontsize
-		if((pref.fontSize &lt;= 13)||(sw &lt;= 240)||(sh &lt;= 240)){
-			setPreferredSize(240,240);
-		}
-		else if(pref.fontSize &lt;= 28){
+		if ((pref.fontSize &lt;= 13) || (sw &lt;= 240) || (sh &lt;= 240)) {
+			setPreferredSize(240, 240);
+		} else if (pref.fontSize &lt;= 28) {
 			// was for &lt;=16 setPreferredSize(288,252);
-			setPreferredSize(pref.fontSize*20,pref.fontSize*18);
+			setPreferredSize(pref.fontSize * 20, pref.fontSize * 18);
+		} else if (pref.fontSize &lt;= 20) {
+			setPreferredSize(352, 302);
+		} else if (pref.fontSize &lt;= 24) {
+			setPreferredSize(420, 350);
+		} else if (pref.fontSize &lt;= 28) {
+			setPreferredSize(480, 390);
+		} else {
+			setPreferredSize(576, 512);
 		}
-		else if(pref.fontSize &lt;= 20){
-			setPreferredSize(352,302);
-		}
-		else if(pref.fontSize &lt;= 24){
-			setPreferredSize(420,350);
-		}
-		else if(pref.fontSize &lt;= 28){
-			setPreferredSize(480,390);
-		}
-		else{
-			setPreferredSize(576,512);
-		}
-		
-		//scp = new ScrollBarPanel(pnlGeneral);
-		
-		/////////////////////////////////////////////////////////
+
+		// scp = new ScrollBarPanel(pnlGeneral);
+
+		// ///////////////////////////////////////////////////////
 		// First panel - General
-		/////////////////////////////////////////////////////////
-		CellPanel cpDataDir=new CellPanel();
-		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603,&quot;Data Directory:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		// ///////////////////////////////////////////////////////
+		CellPanel cpDataDir = new CellPanel();
+		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603, &quot;Data Directory:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		DataDir = new mInput();
 		DataDir.setText(pref.getBaseDir());
-		cpDataDir.addNext(DataDir,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.LEFT));
-		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604,&quot;Browse&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629,&quot;Autoload last profile&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
-		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646,&quot;centre from GPS&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		if (pref.setCurrentCentreFromGPSPosition) chkSetCurrentCentreFromGPSPosition.setState(true);
-		pnlGeneral.addLast(separator(cpDataDir),HSTRETCH,HFILL);
-		
-		CellPanel cpBrowser=new CellPanel();
-		cpBrowser.addNext(new mLabel(&quot;Browser:&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addLast(Browser = new mInput(pref.browser),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601,&quot;Your Alias:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		cpBrowser.addNext(Alias = new mInput(pref.myAlias),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594,&quot;Pwd&quot;)));
-		cpBrowser.addLast(inpPassword=new mInput(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		inpPassword.setToolTip(MyLocale.getMsg(593,&quot;Password is optional here.\nEnter only if you want to store it in pref.xml&quot;));
-		inpPassword.isPassword=true;
-		cpBrowser.addNext(chkPM=new mCheckBox(&quot;PM&quot;));
-		if (pref.isPremium) chkPM.setState(true);
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650,&quot;GcMemberID:&quot;)));
-		cpBrowser.addLast(inpGcMemberID=new mInput(pref.gcMemberId),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		pnlGeneral.addLast(separator(cpBrowser),HSTRETCH,HFILL);
-		
-		CellPanel cpGPS=new CellPanel();
-		cpGPS.addNext(new mLabel(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600,&quot;Preferences&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		// &quot;GPS: &quot; + (pref.useGPSD ? &quot;gpsd &quot; + pref.gpsdHost : pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate) 
-		pnlGeneral.addLast(separator(cpGPS),HSTRETCH,HFILL);
+		cpDataDir.addNext(DataDir, CellConstants.STRETCH, (CellConstants.FILL | CellConstants.LEFT));
+		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604, &quot;Browse&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629, &quot;Autoload last profile&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		if (pref.autoReloadLastProfile)
+			chkAutoLoad.setState(true);
+		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646, &quot;centre from GPS&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		if (pref.setCurrentCentreFromGPSPosition)
+			chkSetCurrentCentreFromGPSPosition.setState(true);
+		pnlGeneral.addLast(separator(cpDataDir), HSTRETCH, HFILL);
 
+		CellPanel cpBrowser = new CellPanel();
+		cpBrowser.addNext(new mLabel(&quot;Browser:&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addLast(Browser = new mInput(pref.browser), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601, &quot;Your Alias:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(Alias = new mInput(pref.myAlias), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594, &quot;Pwd&quot;)));
+		cpBrowser.addLast(inpPassword = new mInput(pref.password), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		inpPassword.setToolTip(MyLocale.getMsg(593, &quot;Password is optional here.\nEnter only if you want to store it in pref.xml&quot;));
+		inpPassword.isPassword = true;
+		cpBrowser.addNext(chkPM = new mCheckBox(&quot;PM&quot;));
+		if (pref.isPremium)
+			chkPM.setState(true);
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650, &quot;GcMemberID:&quot;)));
+		cpBrowser.addLast(inpGcMemberID = new mInput(pref.gcMemberId), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(&quot;UserID&quot;));
+		cpBrowser.addLast(inpUserID = new mInput(pref.userID), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+
+		pnlGeneral.addLast(separator(cpBrowser), HSTRETCH, HFILL);
+
+		CellPanel cpGPS = new CellPanel();
+		cpGPS.addNext(new mLabel(&quot;GPS: &quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600, &quot;Preferences&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		// &quot;GPS: &quot; + (pref.useGPSD ? &quot;gpsd &quot; + pref.gpsdHost : pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate)
+		pnlGeneral.addLast(separator(cpGPS), HSTRETCH, HFILL);
+
 		// Garmin and GPSBabel
-		CellPanel cpBabel=new CellPanel();
-		cpBabel.addNext(lblGarmin=new mLabel(MyLocale.getMsg(173,&quot;Garmin:  PC Port:&quot;)),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chcGarminPort=new mChoice(garminPorts,0),DONTSTRETCH,RIGHT);
+		CellPanel cpBabel = new CellPanel();
+		cpBabel.addNext(lblGarmin = new mLabel(MyLocale.getMsg(173, &quot;Garmin:  PC Port:&quot;)), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chcGarminPort = new mChoice(garminPorts, 0), DONTSTRETCH, RIGHT);
 		chcGarminPort.selectItem(pref.garminConn);
-		cpBabel.addLast(chkSynthShort=new mCheckBox(MyLocale.getMsg(174,&quot;Short Names&quot;)),STRETCH,LEFT);
+		cpBabel.addLast(chkSynthShort = new mCheckBox(MyLocale.getMsg(174, &quot;Short Names&quot;)), STRETCH, LEFT);
 		chkSynthShort.setState(!pref.garminGPSBabelOptions.equals(&quot;&quot;));
-		cpBabel.addNext(new mLabel(MyLocale.getMsg(643,&quot;Append cache details to:&quot;)),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chkAddDetailsToWaypoint=new mCheckBox(MyLocale.getMsg(644,&quot;waypoints&quot;)),DONTSTRETCH,RIGHT);
+		cpBabel.addNext(new mLabel(MyLocale.getMsg(643, &quot;Append cache details to:&quot;)), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chkAddDetailsToWaypoint = new mCheckBox(MyLocale.getMsg(644, &quot;waypoints&quot;)), DONTSTRETCH, RIGHT);
 		chkAddDetailsToWaypoint.setState(pref.addDetailsToWaypoint);
-		cpBabel.addLast(chkAddDetailsToName=new mCheckBox(MyLocale.getMsg(645,&quot;names&quot;)),STRETCH,LEFT);
+		cpBabel.addLast(chkAddDetailsToName = new mCheckBox(MyLocale.getMsg(645, &quot;names&quot;)), STRETCH, LEFT);
 		chkAddDetailsToName.setState(pref.addDetailsToName);
-		pnlGeneral.addLast(cpBabel,HSTRETCH,HFILL);
-		
-		/////////////////////////////////////////////////////////
+		pnlGeneral.addLast(cpBabel, HSTRETCH, HFILL);
+
+		// ///////////////////////////////////////////////////////
 		// Second panel - Screen
-		/////////////////////////////////////////////////////////
-		
-		CellPanel pnlScreen=new CellPanel();
-		Frame frmScreen=new Frame();
-		frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER;
-		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625,&quot;Screen (needs restart):&quot;)));
-		pnlScreen.addNext(new mLabel(&quot;Font&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlScreen.addNext(fontName = new mInput(),CellConstants.STRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		fontName.maxLength=50;
+		// ///////////////////////////////////////////////////////
+
+		CellPanel pnlScreen = new CellPanel();
+		Frame frmScreen = new Frame();
+		frmScreen.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER;
+		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625, &quot;Screen (needs restart):&quot;)));
+		pnlScreen.addNext(new mLabel(&quot;Font&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlScreen.addNext(fontName = new mInput(), CellConstants.STRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontName.maxLength = 50;
 		fontName.setText(pref.fontName);
-		pnlScreen.addLast(fontSize = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		fontSize.maxLength=2;
-		fontSize.setPreferredSize(2*pref.fontSize,-1);
+		pnlScreen.addLast(fontSize = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontSize.maxLength = 2;
+		fontSize.setPreferredSize(2 * pref.fontSize, -1);
 		fontSize.setText(Convert.toString(pref.fontSize));
-		frmScreen.addLast(pnlScreen,HSTRETCH,HFILL);
-		
-		frmScreen.addLast(chkHasCloseButton=new mCheckBox(MyLocale.getMsg(631,&quot;PDA has close Button&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
-    	//lblTitle.setTag(INSETS,new Insets(2,0,0,0));
-        chkHasCloseButton.setState(pref.hasCloseButton);
-		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,&quot;Menu top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkMenuAtTop.setTag(INSETS,new Insets(0,0,2,0));
+		frmScreen.addLast(pnlScreen, HSTRETCH, HFILL);
+
+		frmScreen.addLast(chkHasCloseButton = new mCheckBox(MyLocale.getMsg(631, &quot;PDA has close Button&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		// lblTitle.setTag(INSETS,new Insets(2,0,0,0));
+		chkHasCloseButton.setState(pref.hasCloseButton);
+		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626, &quot;Menu top&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkMenuAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
 		chkMenuAtTop.setState(pref.menuAtTop);
-		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,&quot;Tabs top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627, &quot;Tabs top&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkTabsAtTop.setState(pref.tabsAtTop);
-		chkTabsAtTop.setTag(INSETS,new Insets(0,0,2,0));
-		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,&quot;Status&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		chkTabsAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
+		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628, &quot;Status&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkShowStatus.setState(pref.showStatus);
-		chkShowStatus.setTag(INSETS,new Insets(0,0,2,0));
-		pnlDisplay.addLast(frmScreen,CellConstants.HSTRETCH,CellConstants.FILL);
-		
-		Frame frmImages=new Frame();
-		frmImages.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP|UIConstants.BF_BOTTOM;
-		//frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,&quot;Show deleted images&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkShowDeletedImg.setTag(INSETS,new Insets(2,0,0,0));
-		if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
-		//mLabel dummy;
-		//frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		//dummy.setTag(INSETS,new Insets(0,0,2,0));
-		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638,&quot;Show pictures in description&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		chkDescShowImg.setTag(INSETS,new Insets(0,0,2,0));
-		if (pref.descShowImg) chkDescShowImg.setState(true);
-		pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+		chkShowStatus.setTag(INSETS, new Insets(0, 0, 2, 0));
+		pnlDisplay.addLast(frmScreen, CellConstants.HSTRETCH, CellConstants.FILL);
 
-		Frame frmHintLog=new Frame();
-		//frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630,&quot;HintLogPanel:  Logs per page &quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpLogsPerPage=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		Frame frmImages = new Frame();
+		frmImages.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_TOP | UIConstants.BF_BOTTOM;
+		// frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624, &quot;Show deleted images&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkShowDeletedImg.setTag(INSETS, new Insets(2, 0, 0, 0));
+		if (pref.showDeletedImages)
+			chkShowDeletedImg.setState(true);
+		// mLabel dummy;
+		// frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
+		// dummy.setTag(INSETS,new Insets(0,0,2,0));
+		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638, &quot;Show pictures in description&quot;)), CellConstants.VSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT | CellConstants.NORTH));
+		chkDescShowImg.setTag(INSETS, new Insets(0, 0, 2, 0));
+		if (pref.descShowImg)
+			chkDescShowImg.setState(true);
+		pnlDisplay.addLast(frmImages, CellConstants.STRETCH, CellConstants.FILL);
+
+		Frame frmHintLog = new Frame();
+		// frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630, &quot;HintLogPanel:  Logs per page &quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpLogsPerPage = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
-		inpLogsPerPage.setPreferredSize(40,-1);
-		//inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
-		//lblHlP.setTag(INSETS,new Insets(6,0,2,0));
+		inpLogsPerPage.setPreferredSize(40, -1);
+		// inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
+		// lblHlP.setTag(INSETS,new Insets(6,0,2,0));
 
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633,&quot;Max. logs to spider&quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpMaxLogsToSpider=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633, &quot;Max. logs to spider&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpMaxLogsToSpider = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpMaxLogsToSpider.setText(Convert.toString(pref.maxLogsToSpider));
-		inpMaxLogsToSpider.setPreferredSize(40,-1);
-		
-		String [] spiderUpdateOptions = { MyLocale.getMsg(640,&quot;Yes&quot;), MyLocale.getMsg(641,&quot;No&quot;), MyLocale.getMsg(642,&quot;Ask&quot;) };
-		frmHintLog.addNext(new mLabel( MyLocale.getMsg(639,&quot;Update caches when spidering?&quot;) ),DONTSTRETCH,DONTFILL|LEFT);
-		frmHintLog.addLast(inpSpiderUpdates=new mChoice(spiderUpdateOptions, pref.spiderUpdates),DONTSTRETCH,DONTFILL|LEFT);
-		pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
+		inpMaxLogsToSpider.setPreferredSize(40, -1);
 
-		/////////////////////////////////////////////////////////
+		String[] spiderUpdateOptions = { MyLocale.getMsg(640, &quot;Yes&quot;), MyLocale.getMsg(641, &quot;No&quot;), MyLocale.getMsg(642, &quot;Ask&quot;) };
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(639, &quot;Update caches when spidering?&quot;)), DONTSTRETCH, DONTFILL | LEFT);
+		frmHintLog.addLast(inpSpiderUpdates = new mChoice(spiderUpdateOptions, pref.spiderUpdates), DONTSTRETCH, DONTFILL | LEFT);
+		pnlDisplay.addLast(frmHintLog, CellConstants.STRETCH, CellConstants.FILL);
+
+		// ///////////////////////////////////////////////////////
 		// Third panel - More
-		/////////////////////////////////////////////////////////
-		CellPanel pnlProxy=new CellPanel();
-		pnlProxy.addNext(new mLabel(&quot;Proxy&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(Proxy = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT)).setTag(SPAN,new Dimension(2,1));
+		// ///////////////////////////////////////////////////////
+		CellPanel pnlProxy = new CellPanel();
+		pnlProxy.addNext(new mLabel(&quot;Proxy&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(Proxy = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT)).setTag(SPAN, new Dimension(2, 1));
 		Proxy.setText(pref.myproxy);
-		pnlProxy.addNext(new mLabel(&quot;Port&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		pnlProxy.addNext(new mLabel(&quot;Port&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(ProxyPort = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		ProxyPort.setText(pref.myproxyport);
-		pnlProxy.addNext(new mLabel(&quot;&quot;),HSTRETCH,HFILL);
-		pnlProxy.addLast(chkProxyActive=new mCheckBox(MyLocale.getMsg(634,&quot;use Proxy&quot;)));
+		pnlProxy.addNext(new mLabel(&quot;&quot;), HSTRETCH, HFILL);
+		pnlProxy.addLast(chkProxyActive = new mCheckBox(MyLocale.getMsg(634, &quot;use Proxy&quot;)));
 		chkProxyActive.setState(pref.proxyActive);
-		pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(592,&quot;Language (needs restart)&quot;)),DONTSTRETCH,DONTFILL|LEFT);
-		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory()+&quot;/languages&quot;).list(&quot;*.cfg&quot;, FileBase.LIST_FILES_ONLY)); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
-		if (tmp == null) tmp = new String[0];
-		String [] langs = new String[tmp.length +1];
+		pnlMore.addLast(pnlProxy, HSTRETCH, HFILL);
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(592, &quot;Language (needs restart)&quot;)), DONTSTRETCH, DONTFILL | LEFT);
+		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory() + &quot;/languages&quot;).list(&quot;*.cfg&quot;, FileBase.LIST_FILES_ONLY)); // &quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		if (tmp == null)
+			tmp = new String[0];
+		String[] langs = new String[tmp.length + 1];
 		langs[0] = &quot;auto&quot;;
 		int curlang = 0;
 		for (int i = 0; i &lt; tmp.length; i++) {
-			langs[i+1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
-			if (langs[i+1].equalsIgnoreCase(MyLocale.language)) curlang = i+1 ;
+			langs[i + 1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
+			if (langs[i + 1].equalsIgnoreCase(MyLocale.language))
+				curlang = i + 1;
 		}
-		//ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
-		pnlMore.addLast(inpLanguage=new mChoice(langs, curlang),DONTSTRETCH,DONTFILL|LEFT);
-		//inpLanguage.setPreferredSize(20,-1);
-		inpLanguage.setToolTip(MyLocale.getMsg(591,&quot;Select \&quot;auto\&quot; for system language or select your preferred language, e.g. DE or EN&quot;));
-		String [] metriken = {MyLocale.getMsg(589, &quot;Metric (km)&quot;), 
-				              MyLocale.getMsg(590, &quot;Imperial (mi)&quot;)};
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, &quot;Length units&quot;)),DONTSTRETCH,DONTFILL|LEFT);
+		// ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
+		pnlMore.addLast(inpLanguage = new mChoice(langs, curlang), DONTSTRETCH, DONTFILL | LEFT);
+		// inpLanguage.setPreferredSize(20,-1);
+		inpLanguage.setToolTip(MyLocale.getMsg(591, &quot;Select \&quot;auto\&quot; for system language or select your preferred language, e.g. DE or EN&quot;));
+		String[] metriken = { MyLocale.getMsg(589, &quot;Metric (km)&quot;), MyLocale.getMsg(590, &quot;Imperial (mi)&quot;) };
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, &quot;Length units&quot;)), DONTSTRETCH, DONTFILL | LEFT);
 		int currMetrik = pref.metricSystem == Metrics.METRIC ? 0 : 1;
-		pnlMore.addLast(inpMetric=new mChoice(metriken, currMetrik),DONTSTRETCH,DONTFILL|LEFT);
-		pnlMore.addLast(chkSortingGroupedByCache=new mCheckBox(MyLocale.getMsg(647,&quot;Sorting grouped by Cache&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(inpMetric = new mChoice(metriken, currMetrik), DONTSTRETCH, DONTFILL | LEFT);
+		pnlMore.addLast(chkSortingGroupedByCache = new mCheckBox(MyLocale.getMsg(647, &quot;Sorting grouped by Cache&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkSortingGroupedByCache.setState(pref.SortingGroupedByCache);
-		pnlMore.addLast(chkuseOwnSymbols=new mCheckBox(MyLocale.getMsg(649,&quot;use own symbols&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkuseOwnSymbols = new mCheckBox(MyLocale.getMsg(649, &quot;use own symbols&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkuseOwnSymbols.setState(pref.useOwnSymbols);
-		pnlMore.addLast(chkDebug=new mCheckBox(MyLocale.getMsg(648,&quot;Debug Mode&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkDebug = new mCheckBox(MyLocale.getMsg(648, &quot;Debug Mode&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkDebug.setState(pref.debug);
 
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 		// Fourth/Fifth panel - Listview and Travelbugs
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 
-        mTab.addCard(pnlGeneral,MyLocale.getMsg(621,&quot;General&quot;),null);
-		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,&quot;Screen&quot;),null);
-		mTab.addCard(pnlMore,MyLocale.getMsg(632,&quot;More&quot;),null);
-		mTab.addCard(tccList=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(599,&quot;checkbox&quot;),
-				MyLocale.getMsg(598,&quot;type&quot;),
-				MyLocale.getMsg(606,&quot;Difficulty&quot;),
-				MyLocale.getMsg(607,&quot;Terrain&quot;),
-				MyLocale.getMsg(597,&quot;waypoint&quot;),
-				MyLocale.getMsg(596,&quot;name&quot;),
-				MyLocale.getMsg(608,&quot;Location&quot;),
-				MyLocale.getMsg(609,&quot;Owner&quot;),
-				MyLocale.getMsg(610,&quot;Hidden&quot;),
-				MyLocale.getMsg(611,&quot;Status&quot;),
-				MyLocale.getMsg(612,&quot;Distance&quot;),
-				MyLocale.getMsg(613,&quot;Bearing&quot;),
-				MyLocale.getMsg(635,&quot;Size&quot;),
-				MyLocale.getMsg(636,&quot;OC Empfehlungen&quot;),
-				MyLocale.getMsg(637,&quot;OC Index&quot;),
-				MyLocale.getMsg(1039,&quot;Solver exists&quot;),
-				MyLocale.getMsg(1041,&quot;Note exists&quot;),
-				MyLocale.getMsg(1046,&quot;# Additionals&quot;),
-				MyLocale.getMsg(1048, &quot;# DNF Logs&quot;),
-				MyLocale.getMsg(1051, &quot;Last sync date&quot;)
-				},pref.listColMap),MyLocale.getMsg(595,&quot;List&quot;),null);
+		mTab.addCard(pnlGeneral, MyLocale.getMsg(621, &quot;General&quot;), null);
+		mTab.addCard(pnlDisplay, MyLocale.getMsg(622, &quot;Screen&quot;), null);
+		mTab.addCard(pnlMore, MyLocale.getMsg(632, &quot;More&quot;), null);
+		mTab.addCard(tccList = new TableColumnChooser(new String[] { MyLocale.getMsg(599, &quot;checkbox&quot;), MyLocale.getMsg(598, &quot;type&quot;), MyLocale.getMsg(606, &quot;Difficulty&quot;), MyLocale.getMsg(607, &quot;Terrain&quot;), MyLocale.getMsg(597, &quot;waypoint&quot;),
+				MyLocale.getMsg(596, &quot;name&quot;), MyLocale.getMsg(608, &quot;Location&quot;), MyLocale.getMsg(609, &quot;Owner&quot;), MyLocale.getMsg(610, &quot;Hidden&quot;), MyLocale.getMsg(611, &quot;Status&quot;), MyLocale.getMsg(612, &quot;Distance&quot;), MyLocale.getMsg(613, &quot;Bearing&quot;),
+				MyLocale.getMsg(635, &quot;Size&quot;), MyLocale.getMsg(636, &quot;OC Empfehlungen&quot;), MyLocale.getMsg(637, &quot;OC Index&quot;), MyLocale.getMsg(1039, &quot;Solver exists&quot;), MyLocale.getMsg(1041, &quot;Note exists&quot;), MyLocale.getMsg(1046, &quot;# Additionals&quot;),
+				MyLocale.getMsg(1048, &quot;# DNF Logs&quot;), MyLocale.getMsg(1051, &quot;Last sync date&quot;) }, pref.listColMap), MyLocale.getMsg(595, &quot;List&quot;), null);
 
-		mTab.addCard(tccBugs=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(6000,&quot;Guid&quot;),
-				MyLocale.getMsg(6001,&quot;Name&quot;),
-				MyLocale.getMsg(6002,&quot;track#&quot;),
-				MyLocale.getMsg(6003,&quot;Mission&quot;),
-				MyLocale.getMsg(6004,&quot;From Prof&quot;),
-				MyLocale.getMsg(6005,&quot;From Wpt&quot;),
-				MyLocale.getMsg(6006,&quot;From Date&quot;),
-				MyLocale.getMsg(6007,&quot;From Log&quot;),
-				MyLocale.getMsg(6008,&quot;To Prof&quot;),
-				MyLocale.getMsg(6009,&quot;To Wpt&quot;),
-				MyLocale.getMsg(6010,&quot;To Date&quot;),
-				MyLocale.getMsg(6011,&quot;To Log&quot;)},pref.travelbugColMap),&quot;T-bugs&quot;,null);
-		
+		mTab.addCard(tccBugs = new TableColumnChooser(new String[] { MyLocale.getMsg(6000, &quot;Guid&quot;), MyLocale.getMsg(6001, &quot;Name&quot;), MyLocale.getMsg(6002, &quot;track#&quot;), MyLocale.getMsg(6003, &quot;Mission&quot;), MyLocale.getMsg(6004, &quot;From Prof&quot;),
+				MyLocale.getMsg(6005, &quot;From Wpt&quot;), MyLocale.getMsg(6006, &quot;From Date&quot;), MyLocale.getMsg(6007, &quot;From Log&quot;), MyLocale.getMsg(6008, &quot;To Prof&quot;), MyLocale.getMsg(6009, &quot;To Wpt&quot;), MyLocale.getMsg(6010, &quot;To Date&quot;),
+				MyLocale.getMsg(6011, &quot;To Log&quot;) }, pref.travelbugColMap), &quot;T-bugs&quot;, null);
+
 		this.addLast(mTab);
-		cancelB = new mButton(MyLocale.getMsg(614,&quot;Cancel&quot;));
+		cancelB = new mButton(MyLocale.getMsg(614, &quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		applyB = new mButton(MyLocale.getMsg(615,&quot;Apply&quot;));
+		addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		applyB = new mButton(MyLocale.getMsg(615, &quot;Apply&quot;));
 		applyB.setHotKey(0, IKeys.ACTION);
-		addLast(applyB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		addLast(applyB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 	}
-	
+
 	private CellPanel separator(CellPanel pnl) {
 		CellPanel outerPnl = new CellPanel();
-		pnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
-		outerPnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.addLast(pnl,HSTRETCH,HFILL);
+		pnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_BOTTOM;
+		outerPnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.addLast(pnl, HSTRETCH, HFILL);
 		return outerPnl;
 	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB) {
 				this.close(0);
 			}
-			if (ev.target == applyB){
+			if (ev.target == applyB) {
 				pref.setBaseDir(DataDir.getText());
 				pref.fontSize = Convert.toInt(fontSize.getText());
-				if (pref.fontSize&lt;6) pref.fontSize=11;
-				pref.fontName=fontName.getText();
-				pref.logsPerPage=Common.parseInt(inpLogsPerPage.getText());
-				if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
-				pref.maxLogsToSpider=Common.parseInt(inpMaxLogsToSpider.getText());
-				if (pref.maxLogsToSpider==0) pref.maxLogsToSpider=pref.DEFAULT_MAX_LOGS_TO_SPIDER;
-				
+				if (pref.fontSize &lt; 6)
+					pref.fontSize = 11;
+				pref.fontName = fontName.getText();
+				pref.logsPerPage = Common.parseInt(inpLogsPerPage.getText());
+				if (pref.logsPerPage == 0)
+					pref.logsPerPage = pref.DEFAULT_LOGS_PER_PAGE;
+				pref.maxLogsToSpider = Common.parseInt(inpMaxLogsToSpider.getText());
+				if (pref.maxLogsToSpider == 0)
+					pref.maxLogsToSpider = pref.DEFAULT_MAX_LOGS_TO_SPIDER;
+
 				Font defaultGuiFont = mApp.findFont(&quot;gui&quot;);
 				int sz = (pref.fontSize);
-				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 
-				mApp.addFont(newGuiFont, &quot;gui&quot;); 
+				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+				mApp.addFont(newGuiFont, &quot;gui&quot;);
 				mApp.fontsChanged();
 				mApp.mainApp.font = newGuiFont;
-				
+
 				pref.myAlias = Alias.getText().trim();
-				pref.password= inpPassword.getText().trim();
-				pref.gcMemberId=inpGcMemberID.getText().trim();
-				MyLocale.saveLanguage(MyLocale.language=inpLanguage.getText().toUpperCase().trim());
+				pref.password = inpPassword.getText().trim();
+				pref.gcMemberId = inpGcMemberID.getText().trim();
+				pref.userID = inpUserID.getText().trim();
+				MyLocale.saveLanguage(MyLocale.language = inpLanguage.getText().toUpperCase().trim());
 				pref.browser = Browser.getText();
 				pref.myproxy = Proxy.getText();
 				pref.myproxyport = ProxyPort.getText();
-				pref.proxyActive=chkProxyActive.getState();
+				pref.proxyActive = chkProxyActive.getState();
 				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
-				pref.autoReloadLastProfile=chkAutoLoad.getState();
-				pref.isPremium=chkPM.getState();
-				pref.setCurrentCentreFromGPSPosition=chkSetCurrentCentreFromGPSPosition.getState();
-				pref.showDeletedImages=chkShowDeletedImg.getState();
-				pref.garminConn=chcGarminPort.getSelectedItem().toString();
-				pref.garminGPSBabelOptions=chkSynthShort.state?&quot;-s&quot;:&quot;&quot;;
-				pref.menuAtTop=chkMenuAtTop.getState();
-				pref.tabsAtTop=chkTabsAtTop.getState();
-				pref.showStatus=chkShowStatus.getState();
-				pref.hasCloseButton=chkHasCloseButton.getState();
-				pref.travelbugColMap=tccBugs.getSelectedCols();
-				pref.listColMap=tccList.getSelectedCols();
-				pref.descShowImg=chkDescShowImg.getState();
+				pref.autoReloadLastProfile = chkAutoLoad.getState();
+				pref.isPremium = chkPM.getState();
+				pref.setCurrentCentreFromGPSPosition = chkSetCurrentCentreFromGPSPosition.getState();
+				pref.showDeletedImages = chkShowDeletedImg.getState();
+				pref.garminConn = chcGarminPort.getSelectedItem().toString();
+				pref.garminGPSBabelOptions = chkSynthShort.state ? &quot;-s&quot; : &quot;&quot;;
+				pref.menuAtTop = chkMenuAtTop.getState();
+				pref.tabsAtTop = chkTabsAtTop.getState();
+				pref.showStatus = chkShowStatus.getState();
+				pref.hasCloseButton = chkHasCloseButton.getState();
+				pref.travelbugColMap = tccBugs.getSelectedCols();
+				pref.listColMap = tccList.getSelectedCols();
+				pref.descShowImg = chkDescShowImg.getState();
 				Global.mainTab.tbP.myMod.setColumnNamesAndWidths();
 				pref.metricSystem = inpMetric.getInt() == 0 ? Metrics.METRIC : Metrics.IMPERIAL;
 				pref.spiderUpdates = inpSpiderUpdates.getInt();
 				pref.addDetailsToWaypoint = chkAddDetailsToWaypoint.getState();
 				pref.addDetailsToName = chkAddDetailsToName.getState();
-				pref.SortingGroupedByCache=chkSortingGroupedByCache.getState();
-				pref.useOwnSymbols=chkuseOwnSymbols.getState();
-				pref.debug=chkDebug.getState();
+				pref.SortingGroupedByCache = chkSortingGroupedByCache.getState();
+				pref.useOwnSymbols = chkuseOwnSymbols.getState();
+				pref.debug = chkDebug.getState();
 
 				pref.savePreferences();
 				pref.dirty = true; // Need to update table in case columns were enabled/disabled
 				this.close(0);
 			}
-			if(ev.target == brwBt){
+			if (ev.target == brwBt) {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getBaseDir());
-				fc.setTitle(MyLocale.getMsg(616,&quot;Select directory&quot;));
-				if(fc.execute() != FormBase.IDCANCEL)	DataDir.setText(fc.getChosen()+&quot;/&quot;);
+				fc.setTitle(MyLocale.getMsg(616, &quot;Select directory&quot;));
+				if (fc.execute() != FormBase.IDCANCEL)
+					DataDir.setText(fc.getChosen() + &quot;/&quot;);
 			}
-			if (ev.target == gpsB){
+			if (ev.target == gpsB) {
 				GPSPortOptions gpo = new GPSPortOptions();
 				gpo.portName = pref.mySPO.portName;
 				gpo.baudRate = pref.mySPO.baudRate;
@@ -406,36 +381,36 @@
 				gpo.forwardGpsChkB.setState(pref.forwardGPS);
 				gpo.inputBoxForwardHost.setText(pref.forwardGpsHost);
 				gpo.chcUseGpsd.select(pref.useGPSD);
-				if(pref.gpsdPort!=pref.DEFAULT_GPSD_PORT){
+				if (pref.gpsdPort != pref.DEFAULT_GPSD_PORT) {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost + &quot;:&quot; + Convert.toString(pref.gpsdPort));
-				}else{
+				} else {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost);
 				}
 				gpo.logGpsChkB.setState(pref.logGPS);
 				gpo.inputBoxLogTimer.setText(pref.logGPSTimer);
 				Gui.setOKCancel(s);
-				if (s.execute()== FormBase.IDOK) {
-					pref.mySPO.portName = gpo.portName; 
+				if (s.execute() == FormBase.IDOK) {
+					pref.mySPO.portName = gpo.portName;
 					pref.mySPO.baudRate = gpo.baudRate;
 					pref.forwardGPS = gpo.forwardGpsChkB.getState();
 					pref.forwardGpsHost = gpo.inputBoxForwardHost.getText();
 					pref.useGPSD = gpo.chcUseGpsd.getInt();
-					String gpsdHostString = gpo.inputBoxGpsdHost.getText();	// hostname[:port]
+					String gpsdHostString = gpo.inputBoxGpsdHost.getText(); // hostname[:port]
 					int posColon = gpsdHostString.indexOf(':');
-					if(posColon&gt;=0){
-						pref.gpsdHost=gpsdHostString.substring(0,posColon);
-						pref.gpsdPort=Convert.toInt(gpsdHostString.substring(posColon+1));
-					}else{
-						pref.gpsdHost=gpsdHostString;
-						pref.gpsdPort=pref.DEFAULT_GPSD_PORT;
+					if (posColon &gt;= 0) {
+						pref.gpsdHost = gpsdHostString.substring(0, posColon);
+						pref.gpsdPort = Convert.toInt(gpsdHostString.substring(posColon + 1));
+					} else {
+						pref.gpsdHost = gpsdHostString;
+						pref.gpsdPort = pref.DEFAULT_GPSD_PORT;
 					}
 					pref.logGPS = gpo.logGpsChkB.getState();
 					pref.logGPSTimer = gpo.inputBoxLogTimer.getText();
-					gpsB.setText(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
+					gpsB.setText(&quot;GPS: &quot; + pref.mySPO.portName + &quot;/&quot; + pref.mySPO.baudRate);
 				}
 			}
 		}
 		super.onEvent(ev);
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.data.PropertyList;
@@ -31,7 +31,6 @@
 import ewe.io.FileOutputStream;
 import ewe.io.IOException;
 import ewe.io.JavaUtf8Codec;
-import ewe.net.URL;
 import ewe.util.ByteArray;
 import ewe.util.CharArray;
 
@@ -40,103 +39,136 @@
 	static int maxRedirections = 5;
 	static PropertyList requestorProperties = null;
 	static PropertyList permanentRequestorProperties = null;
-	static String postData=null;
-	static String urltmp=null;
-	static String realUrl=null;
-	static boolean forceRedirect=false;
-	
+	static String postData = null;
+	static String urltmp = null;
+	static String realUrl = null;
+	static boolean forceRedirect = false;
+
 	public static PropertyList getDocumentProperties() {
-		if (conn != null) 
+		if (conn != null)
 			return conn.documentProperties;
-		else return null;
+		else
+			return null;
 	}
-	public static String getRealUrl() { return realUrl; };
-	public static void setMaxRedirections(int value) { maxRedirections=value; };
-	public static void setForceRedirect() { forceRedirect=true; };
-	public static void setRequestorProperties(PropertyList value) { requestorProperties=value; };
+
+	public static String getRealUrl() {
+		return realUrl;
+	};
+
+	public static void setMaxRedirections(int value) {
+		maxRedirections = value;
+	};
+
+	public static void setForceRedirect() {
+		forceRedirect = true;
+	};
+
+	public static void setRequestorProperties(PropertyList value) {
+		requestorProperties = value;
+	};
+
 	public static void setRequestorProperty(String name, String property) {
-		if (requestorProperties == null) requestorProperties = new PropertyList();
-		requestorProperties.set(name,property);
+		if (requestorProperties == null)
+			requestorProperties = new PropertyList();
+		requestorProperties.set(name, property);
 	}
+
 	private static void initPermanentRequestorProperty() {
 		permanentRequestorProperties = new PropertyList();
 		permanentRequestorProperties.add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-		permanentRequestorProperties.add(&quot;Connection&quot;, &quot;keep-alive&quot;);		
+		permanentRequestorProperties.add(&quot;Connection&quot;, &quot;keep-alive&quot;);
 	}
+
 	public static void setPermanentRequestorProperty(String name, String property) {
-		if (permanentRequestorProperties == null) initPermanentRequestorProperty();
-		if (property != null) 
-			permanentRequestorProperties.set(name,property);
+		if (permanentRequestorProperties == null)
+			initPermanentRequestorProperty();
+		if (property != null)
+			permanentRequestorProperties.set(name, property);
 		else {
 			int index = permanentRequestorProperties.find(name);
-			if ( index &gt;= 0 ) permanentRequestorProperties.del(index);			
+			if (index &gt;= 0)
+				permanentRequestorProperties.del(index);
 		}
 	}
-	public static void setpostData(String value) { 
-		postData=value;
+
+	public static void setpostData(String value) {
+		postData = value;
 	};
+
 	public static String fetch(String address) throws IOException {
 		ByteArray daten = fetchByteArray(address);
 		JavaUtf8Codec codec = new JavaUtf8Codec();
 		CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
 		return c_data.toString();
-	}	
+	}
+
 	public static ByteArray fetchData(String address) throws IOException {
 		return fetchByteArray(address);
 	}
+
 	public static void fetchDataFile(String address, String target) throws IOException {
-		FileOutputStream outp =  new FileOutputStream(new File(target));
+		FileOutputStream outp = new FileOutputStream(new File(target));
 		outp.write(fetchByteArray(address).toBytes());
 		outp.close();
 	}
+
 	/**
 	 * @param url
 	 * @return ByteArray
 	 * @throws IOException
 	 */
-	public static ByteArray fetchByteArray(String url) throws IOException {	
-		int i=0;
-		conn = new HttpConnection(url); //todo reuse: don#t reuse, some params are not correctly reset with SetUrl		
+	public static ByteArray fetchByteArray(String url) throws IOException {
+		int i = 0;
+		conn = new HttpConnection(url); // todo reuse: don#t reuse, some params are not correctly reset with SetUrl
 		urltmp = url;
-		do  { // allow max 5 redirections (http 302 location)
+		do { // allow max 5 redirections (http 302 location)
 			i++;
 			if (urltmp == null) {
-				// hack for expedia, doing the original url again. 
+				// hack for expedia, doing the original url again.
 				// expedia always must redirect &gt;=1 time, but sometimes that is missed
 				// see also: <A HREF="http://www.geoclub.de/viewtopic.php?p=305071#305071">http://www.geoclub.de/viewtopic.php?p=305071#305071</A>
-				urltmp=url;
-				i=i-1;
+				urltmp = url;
+				i = i - 1;
 			}
-			realUrl=urltmp;
+			realUrl = urltmp;
 			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
-			if (permanentRequestorProperties == null) initPermanentRequestorProperty();
+			if (permanentRequestorProperties == null)
+				initPermanentRequestorProperty();
 			if (postData != null) {
 				conn.setPostData(postData);
-				conn.setRequestorProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
+				conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
 			}
 			conn.setRequestorProperty(permanentRequestorProperties);
-			if (requestorProperties != null) conn.setRequestorProperty(requestorProperties);
+			if (requestorProperties != null)
+				conn.setRequestorProperty(requestorProperties);
 			conn.connect();
-			if (conn.responseCode &gt;= 400) throw new IOException(&quot;URL: &quot;+ urltmp + &quot;\nhttp response code: &quot; + conn.responseCode);
+			if (conn.responseCode &gt;= 400) {
+				maxRedirections = 5;
+				requestorProperties = null;
+				postData = null;
+				forceRedirect = false;
+				throw new IOException(&quot;URL: &quot; + urltmp + &quot;\nhttp response code: &quot; + conn.responseCode);
+			}
 			urltmp = conn.getRedirectTo();
-			if(urltmp!=null){
+			if (urltmp != null) {
 				conn.disconnect();
-				conn=conn.getRedirectedConnection(urltmp);
-				forceRedirect=false; // one time or more redirected
+				conn = conn.getRedirectedConnection(urltmp);
+				forceRedirect = false; // one time or more redirected
 			}
-		} while (((urltmp != null) || (urltmp == null) &amp;&amp; forceRedirect) &amp;&amp; i &lt;= maxRedirections );	
-		if (i &gt; maxRedirections) throw new IOException(&quot;too many http redirections while trying to fetch: &quot;+url + &quot; only &quot;+maxRedirections+&quot; are allowed&quot;);
+		} while (((urltmp != null) || (urltmp == null) &amp;&amp; forceRedirect) &amp;&amp; i &lt;= maxRedirections);
+		if (i &gt; maxRedirections)
+			throw new IOException(&quot;too many http redirections while trying to fetch: &quot; + url + &quot; only &quot; + maxRedirections + &quot; are allowed&quot;);
 		ByteArray daten;
 		if (conn.isOpen()) {
 			daten = conn.readData();
 			conn.disconnect();
-		}
-		else daten=null;
+		} else
+			daten = null;
 		maxRedirections = 5;
 		requestorProperties = null;
-		postData=null;
-		forceRedirect=false;
+		postData = null;
+		forceRedirect = false;
 		return daten;
 	}
 
@@ -145,26 +177,23 @@
 	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false otherwise
 	 */
 	private static boolean isUrlEncoded(String url) {
-		final String allowed = new String (&quot;-_.~!*'();:@&amp;=+$,/?%#[]&quot;);
-		char [] src = ewe.sys.Vm.getStringChars(url);
+		final String allowed = new String(&quot;-_.~!*'();:@&amp;=+$,/?%#[]&quot;);
+		char[] src = ewe.sys.Vm.getStringChars(url);
 		char c;
-		for (int i = 0; i&lt;src.length; i++){
+		for (int i = 0; i &lt; src.length; i++) {
 			c = src[i];
-			if (       (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') 
-					|| (c &gt;= 'a' &amp;&amp; c &lt;= 'z') 
-					|| (c &gt;= '0' &amp;&amp; c &lt;= '9')
-					|| (allowed.indexOf(c) &gt;= 0)
-			) continue;
-			else return false;
+			if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || (allowed.indexOf(c) &gt;= 0))
+				continue;
+			else
+				return false;
 		}
 		return true;
 	}
+
 	/**
-	 * This method encodes an URL containing special characters
-	 * using the UTF-8 codec in %nn%nn notation&lt;br&gt;
-	 * Note that the encoding for URLs is not generally defined. Usually
-	 * cp1252 or UTF-8 is used. It depends on what the server expects,
-	 * what encoding you must use.
+	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation&lt;br&gt;
+	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the server expects, what encoding you must use.
+	 * 
 	 * @param cc
 	 * @return
 	 * @throws IOException
@@ -178,34 +207,36 @@
 		asciicod.decodeText(utf8.data, 0, utf8.length, true, utf8bytes);
 		return encodeURL(utf8bytes.toString(), false);
 	}
-	
+
 	final static String hex = ewe.util.TextEncoder.hex;
+
 	/**
-	 * Encode the URL using %## notation.
-	 * Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine
-	 * assumes all chars to be &lt; 127.
-	 * This method is mainly copied from there
-	 * @param url The unencoded URL.
-	 * @param spaceToPlus true if you wish a space to be encoded as a '+', false to encode it as %20
+	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all chars to be &lt; 127. This method is mainly copied from there
+	 * 
+	 * @param url
+	 *            The unencoded URL.
+	 * @param spaceToPlus
+	 *            true if you wish a space to be encoded as a '+', false to encode it as %20
 	 * @return The encoded URL.
 	 */
-	//===================================================================
-	private static String encodeURL(String url, boolean spaceToPlus)
-	//===================================================================
+	// ===================================================================
+	public static String encodeURL(String url, boolean spaceToPlus)
+	// ===================================================================
 	{
-		char [] what = ewe.sys.Vm.getStringChars(url);
+		char[] what = ewe.sys.Vm.getStringChars(url);
 		int max = what.length;
-		char [] dest = new char[max+max/2];
+		char[] dest = new char[max + max / 2];
 		char d = 0;
-		for (int i = 0; i&lt;max; i++){
-			if (d &gt;= dest.length-2) {
-				char [] n = new char[dest.length+dest.length/2+3];
-				ewe.sys.Vm.copyArray(dest,0,n,0,d);
+		for (int i = 0; i &lt; max; i++) {
+			if (d &gt;= dest.length - 2) {
+				char[] n = new char[dest.length + dest.length / 2 + 3];
+				ewe.sys.Vm.copyArray(dest, 0, n, 0, d);
 				dest = n;
 			}
 			char c = what[i];
-			if (spaceToPlus &amp;&amp; c == ' ') c = '+';
-			else if (c &lt;= ' ' || c &gt;= 127 || c == '+' || c == '&amp;' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}'){
+			if (spaceToPlus &amp;&amp; c == ' ')
+				c = '+';
+			else if (c &lt;= ' ' || c &gt;= 127 || c == '+' || c == '&amp;' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
 				dest[d++] = hex.charAt(c &amp; 0xf);
@@ -213,7 +244,7 @@
 			}
 			dest[d++] = c;
 		}
-		return new String(dest,0,d);
+		return new String(dest, 0, d);
 	}
 
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -109,11 +109,11 @@
 	/**
 	 * This is the pattern for inlined smilies
 	 */
-	private static final String 		string = &quot;&lt;img src=\&quot;/images/icons/&quot;;
+	private static final String string = &quot;&lt;img src=\&quot;/images/icons/&quot;;
 
 	private static int ERR_LOGIN = -10;
 	private static Preferences pref;
-	private Profile profile;
+	private final Profile profile;
 
 	private static String cookie = &quot;&quot;;
 	private static double minDistance = 0;
@@ -121,8 +121,8 @@
 	private static String direction = &quot;&quot;;
 	private static String[] directions;
 
-	private CacheDB cacheDB;
-	private Vector cachesToLoad = new Vector();
+	private final CacheDB cacheDB;
+	private final Vector cachesToLoad = new Vector();
 	private InfoBox infB;
 	private static SpiderProperties p = null;
 	// following filled at doit
@@ -136,13 +136,23 @@
 	private byte restrictedCacheType = 0;
 	private String fileName = &quot;&quot;;
 	private String userToken = &quot;&quot;;
+	private String sessionToken = &quot;&quot;;
 
 	private static String propFirstPage;
 	private static String propFirstPage2;
 	private static String propFirstPageFinds;
 	private static String gotoNextPage = &quot;ctl00$ContentBody$pgrTop$ctl08&quot;;
-	private static String gotoNextBlock = &quot;ctl00$ContentBody$pgrTop$ctl06&quot;;  // change to the block (10pages) of the wanted page
-	private static String gotoPage = &quot;ctl00$ContentBody$pgrTop$lbGoToPage_&quot;; // add pagenumber
+	private static String gotoNextBlock = &quot;ctl00$ContentBody$pgrTop$ctl06&quot;; // change
+																			// to
+																			// the
+																			// block
+																			// (10pages)
+																			// of
+																			// the
+																			// wanted
+																			// page
+	private static String gotoPage = &quot;ctl00$ContentBody$pgrTop$lbGoToPage_&quot;; // add
+																				// pagenumber
 	private static String propMaxDistance;
 	private static String propShowOnlyFound;
 	private static Regex RexPropListBlock;
@@ -202,15 +212,17 @@
 	public void doIt(boolean _spiderAllFinds) {
 		cachesToLoad.clear();
 		spiderAllFinds = _spiderAllFinds;
-		origin = pref.getCurCentrePt(); // No need to copy curCentrePt as it is only read and not written
+		origin = pref.getCurCentrePt(); // No need to copy curCentrePt as it is
+										// only read and not written
 		if (!spiderAllFinds &amp;&amp; !origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
 			return;
 		}
 
-		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
+		// Reset states for all caches when spidering
+		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
@@ -221,30 +233,23 @@
 			infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502, &quot;Fetching first page...&quot;));
 			infB.exec();
 
-			pref.log( &quot;ListPages Properties : &quot; + Preferences.NEWLINE
-					+ &quot;minDistance          : &quot; + minDistance + Preferences.NEWLINE
-					+ &quot;maxDistance          : &quot; + maxDistance + Preferences.NEWLINE
-					+ &quot;directions           : &quot; + direction + Preferences.NEWLINE
-					+ &quot;maxNew               : &quot; + pref.maxSpiderNumber + Preferences.NEWLINE
-					+ &quot;maxUpdate            : &quot; + maxUpdate + Preferences.NEWLINE
-					+ &quot;with Founds          : &quot; + (doNotgetFound ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE 
-					+ &quot;alias is premium memb: &quot;	+ (!pref.isPremium ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE
-					+ &quot;Update if new Log    : &quot; + (pref.checkLog ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE
-					+ &quot;Update if TB changed : &quot; + (pref.checkTBs ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE
-					+ &quot;Update if DTS changed: &quot; + (pref.checkDTS ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE
-					, null);
+			pref.log(&quot;ListPages Properties : &quot; + Preferences.NEWLINE + &quot;minDistance          : &quot; + minDistance + Preferences.NEWLINE + &quot;maxDistance          : &quot; + maxDistance + Preferences.NEWLINE + &quot;directions           : &quot; + direction
+					+ Preferences.NEWLINE + &quot;maxNew               : &quot; + pref.maxSpiderNumber + Preferences.NEWLINE + &quot;maxUpdate            : &quot; + maxUpdate + Preferences.NEWLINE + &quot;with Founds          : &quot; + (doNotgetFound ? &quot;no&quot; : &quot;yes&quot;)
+					+ Preferences.NEWLINE + &quot;alias is premium memb: &quot; + (!pref.isPremium ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE + &quot;Update if new Log    : &quot; + (pref.checkLog ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE + &quot;Update if TB changed : &quot;
+					+ (pref.checkTBs ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE + &quot;Update if DTS changed: &quot; + (pref.checkDTS ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE, null);
 
 			Hashtable cachesToUpdate = new Hashtable(cacheDB.size());
 
-			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate,
-					maxDistance, minDistance, directions, cachesToUpdate);
-			if (cachesToUpdate == null) { cachesToUpdate = new Hashtable(); };
+			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate, maxDistance, minDistance, directions, cachesToUpdate);
+			if (cachesToUpdate == null) {
+				cachesToUpdate = new Hashtable();
+			}
+			;
 			if (!infB.isClosed) {
-				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;)
-						+ cachesToLoad.size()
-						+ MyLocale.getMsg(5512, &quot; caches&quot;));
+				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512, &quot; caches&quot;));
 			}
-			// continue to update index to changed cache.xml things (size,terrain,difficulty,...?) 
+			// continue to update index to changed cache.xml things
+			// (size,terrain,difficulty,...?)
 
 			// =======
 			// Now ready to spider each cache in the lists
@@ -256,7 +261,7 @@
 					cachesToUpdate.clear();
 					break;
 				case Preferences.ASK:
-					MessageBox mBox = new MessageBox(MyLocale.getMsg(5517,&quot;Spider Updates?&quot;), cachesToUpdate.size() + MyLocale.getMsg(5518,&quot; caches in database need an update. Update now?&quot;) , FormBase.IDYES |FormBase.IDNO);
+					final MessageBox mBox = new MessageBox(MyLocale.getMsg(5517, &quot;Spider Updates?&quot;), cachesToUpdate.size() + MyLocale.getMsg(5518, &quot; caches in database need an update. Update now?&quot;), FormBase.IDYES | FormBase.IDNO);
 					if (mBox.execute() != FormBase.IDOK) {
 						cachesToUpdate.clear();
 					}
@@ -265,17 +270,10 @@
 			}
 
 			int spiderErrors = 0;
-			int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
-			boolean loadAllLogs = (pref.maxLogsToSpider &gt; 5) || spiderAllFinds;
-			pref.log(&quot;Download properties : &quot; + Preferences.NEWLINE
-					+ &quot;maxLogs: &quot;
-					+ (loadAllLogs ? &quot;completepage &quot; : &quot;shortpage&quot;) + &quot;nr.:&quot;
-					+ pref.maxLogsToSpider + Preferences.NEWLINE
-					+ &quot;with pictures     : &quot;
-					+ (!pref.downloadPics ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE
-					+ &quot;with tb           : &quot;
-					+ (!pref.downloadTBs ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE,
-					null);
+			final int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
+			final boolean loadAllLogs = (pref.maxLogsToSpider &gt; 5) || spiderAllFinds;
+			pref.log(&quot;Download properties : &quot; + Preferences.NEWLINE + &quot;maxLogs: &quot; + (loadAllLogs ? &quot;completepage &quot; : &quot;shortpage&quot;) + &quot;nr.:&quot; + pref.maxLogsToSpider + Preferences.NEWLINE + &quot;with pictures     : &quot; + (!pref.downloadPics ? &quot;no&quot; : &quot;yes&quot;)
+					+ Preferences.NEWLINE + &quot;with tb           : &quot; + (!pref.downloadTBs ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE, null);
 
 			if (Global.mainTab.statBar != null)
 				Global.mainTab.statBar.updateDisplay(&quot;&quot;);
@@ -286,14 +284,11 @@
 			}
 
 			if (spiderErrors &gt; 0) {
-				new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), spiderErrors + MyLocale.getMsg(5516, &quot; cache descriptions%0acould not be loaded.&quot;), FormBase.DEFOKB).execute();
 			}
 			if (maxNumberAbort) {
-				new MessageBox(MyLocale.getMsg(5519, &quot;Information&quot;),
-						MyLocale.getMsg(5520,&quot;Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated.&quot;),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5519, &quot;Information&quot;), MyLocale.getMsg(5520, &quot;Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated.&quot;), FormBase.DEFOKB)
+						.execute();
 			}
 			Global.getProfile().restoreFilter();
 			Global.getProfile().saveIndex(Global.getPref(), true);
@@ -308,62 +303,65 @@
 	public void doItAlongARoute() {
 		Area sq;
 		Vector points = null;
-		Navigate nav=Global.mainTab.nav;
-		MovingMap mm=Global.mainTab.mm;
+		final Navigate nav = Global.mainTab.nav;
+		MovingMap mm = Global.mainTab.mm;
 
 		if (!doDownloadGui(1))
 			return;
 
 		CWPoint startPos = pref.getCurCentrePt();
 		if (!fileName.equals(&quot;&quot;)) {
-			RouteImporter ri = new RouteImporter(fileName);
-			points = ri.doIt();			
+			final RouteImporter ri = new RouteImporter(fileName);
+			points = ri.doIt();
 			if (points.size() &gt; 0) {
-				if (nav!=null) {
-					if (mm==null) {
+				if (nav != null) {
+					if (mm == null) {
 						Global.mainTab.mm = new MovingMap(nav, profile.cacheDB);
-						mm=Global.mainTab.mm;
+						mm = Global.mainTab.mm;
 						nav.setMovingMap(Global.mainTab.mm);
 					}
 					if (nav.curTrack == null) {
-						nav.curTrack=new Track(nav.trackColor);
+						nav.curTrack = new Track(nav.trackColor);
 						mm.addTrack(nav.curTrack);
 					}
 					for (int i = 0; i &lt; points.size(); i++) {
 						try {
 							nav.curTrack.add((TrackPoint) points.get(i));
-						} catch (IndexOutOfBoundsException e) { // track full -&gt; create a new one
-							nav.curTrack=new Track(nav.trackColor);
+						} catch (final IndexOutOfBoundsException e) { // track
+																		// full
+																		// -&gt;
+																		// create
+																		// a new
+																		// one
+							nav.curTrack = new Track(nav.trackColor);
 							nav.curTrack.add((TrackPoint) points.get(i));
-							if (mm != null) mm.addTrack(nav.curTrack);
+							if (mm != null)
+								mm.addTrack(nav.curTrack);
 						}
 
 					}
 				}
-				TrackPoint tp = (TrackPoint) points.get(0);
+				final TrackPoint tp = (TrackPoint) points.get(0);
 				startPos = new CWPoint(tp.latDec, tp.lonDec);
 			} else
 				startPos = null;
 		}
 
-		int answer = new MessageBox(MyLocale.getMsg(651, &quot;Question&quot;),
-				MyLocale.getMsg(652,&quot;Update caches with all details?&quot;),
-				MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
-		boolean complete = answer == MessageBox.YESB;
-		if ( answer == MessageBox.IDCANCEL) {
-			if (startPos != null) pref.setCurCentrePt(startPos);
+		final int answer = new MessageBox(MyLocale.getMsg(651, &quot;Question&quot;), MyLocale.getMsg(652, &quot;Update caches with all details?&quot;), MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
+		final boolean complete = answer == MessageBox.YESB;
+		if (answer == MessageBox.IDCANCEL) {
+			if (startPos != null)
+				pref.setCurCentrePt(startPos);
 			return;
 		}
 
 		if (startPos != null &amp;&amp; !startPos.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB))
-					.execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
 			return; //
 		}
 
 		Vm.showWait(true);
-		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502,&quot;Fetching pages...&quot;));
+		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502, &quot;Fetching pages...&quot;));
 		infB.exec();
 
 		if (!loggedIn || pref.forceLogin) {
@@ -374,15 +372,14 @@
 		// Reset states for all caches when spidering
 		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
 		double lateralDistance = maxDistance; // Seitenabstand in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 		cachesToLoad.clear();
 
@@ -394,9 +391,8 @@
 				nextPos = nextRoutePoint(startPos, lateralDistance);
 			} else {
 				double tmpDistance = 0;
-				while (tmpDistance &lt; lateralDistance
-						&amp;&amp; pointsIndex &lt; points.size()) {
-					TrackPoint tp = (TrackPoint) points.get(pointsIndex);
+				while (tmpDistance &lt; lateralDistance &amp;&amp; pointsIndex &lt; points.size()) {
+					final TrackPoint tp = (TrackPoint) points.get(pointsIndex);
 					nextPos = new CWPoint(tp.latDec, tp.lonDec);
 					tmpDistance = nextPos.getDistance(startPos);
 					pointsIndex++;
@@ -405,33 +401,24 @@
 					nextPos = null;
 				else {
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot;
-								+ page_number + &quot; Caches added to CW: &quot;
-								+ num_added + &quot; at &quot;
-								+ pointsIndex+&quot;(&quot;+points.size()+&quot;)&quot;
-								+ nextPos
-								);
+						Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot; + page_number + &quot; Caches added to CW: &quot; + num_added + &quot; at &quot; + pointsIndex + &quot;(&quot; + points.size() + &quot;)&quot; + nextPos);
 				}
 			}
 
-
 			if (nextPos != null) {
 				sq = getSquare(startPos, lateralDistance);
-				getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-						sq.bottomright.latDec, sq.bottomright.lonDec, complete);
+				getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 				// pref.log(&quot;next WP = &quot; + startPos.toString(), null);
 
-				double degrees = startPos.getBearing(nextPos);
-				double distanceToNextCache = startPos.getDistance(nextPos);
-				double anzCheckPoints = distanceToNextCache / lateralDistance;
+				final double degrees = startPos.getBearing(nextPos);
+				final double distanceToNextCache = startPos.getDistance(nextPos);
+				final double anzCheckPoints = distanceToNextCache / lateralDistance;
 				for (int i = 1; i &lt; anzCheckPoints; i++) {
-					CWPoint nextCheckPoint = startPos.project(degrees,
-							lateralDistance);
+					final CWPoint nextCheckPoint = startPos.project(degrees, lateralDistance);
 					startPos = nextCheckPoint;
 					origin = nextCheckPoint;
 					sq = getSquare(origin, lateralDistance);
-					getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-							sq.bottomright.latDec, sq.bottomright.lonDec, complete);
+					getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 					// pref.log(&quot;next CP = &quot; + origin.toString(), null);
 					if (infB.isClosed) {
 						break;
@@ -444,42 +431,36 @@
 			}
 		}
 		sq = getSquare(startPos, lateralDistance);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec,
-				sq.bottomright.lonDec, complete);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 		// pref.log(&quot;last WP = &quot; + startPos.toString(), null);
 		if (infB.isClosed) {
 			Vm.showWait(false);
 			return;
 		} // or ask for download of intermediate result
-		
+
 		int spiderErrors = 0;
 		if (complete) {
 			for (int i = 0; i &lt; cachesToLoad.size(); i++) {
 				String wpt = (String) cachesToLoad.get(i);
-				boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
+				final boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
 				if (is_found)
 					wpt = wpt.substring(0, wpt.indexOf(&quot;found&quot;));
-				int j = cacheDB.getIndex(wpt);
+				final int j = cacheDB.getIndex(wpt);
 				if (j != -1)
 					cacheDB.removeElementAt(j);
 			}
 			spiderErrors = downloadCaches(cachesToLoad, spiderErrors, cachesToLoad.size(), true);
 
+		} else {
 		}
-		else {
-		}
 
 		infB.close(0);
 		Vm.showWait(false);
 		if (spiderErrors &gt; 0) {
-			new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), spiderErrors + MyLocale.getMsg(5516, &quot; cache descriptions%0acould not be loaded.&quot;), FormBase.DEFOKB).execute();
 		}
 		if (maxNumberAbort) {
-			new MessageBox(MyLocale.getMsg(5519,&quot;Information&quot;),
-					MyLocale.getMsg(5520,&quot;Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated.&quot;),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5519, &quot;Information&quot;), MyLocale.getMsg(5520, &quot;Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated.&quot;), FormBase.DEFOKB).execute();
 		}
 		Global.getProfile().restoreFilter();
 		Global.getProfile().saveIndex(Global.getPref(), true);
@@ -494,8 +475,8 @@
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (ch.is_Checked &amp;&amp; ch.pos.isValid()) {
-				CWPoint tmpPos = ch.pos;
-				double tmpDistance = tmpPos.getDistance(startPos);
+				final CWPoint tmpPos = ch.pos;
+				final double tmpDistance = tmpPos.getDistance(startPos);
 				if (nextDistance == 0) {
 					// Startwert
 					index = i;
@@ -523,12 +504,12 @@
 	}
 
 	private Area getSquare(CWPoint centre, double halfSideLengthKm) {
-		int north = 0;
-		int east = 1;
-		int south = 2;
-		int west = 3;
-		double halfSideLength = halfSideLengthKm * 1000.0; // in meters
-		Area ret = new Area();
+		final int north = 0;
+		final int east = 1;
+		final int south = 2;
+		final int west = 3;
+		final double halfSideLength = halfSideLengthKm * 1000.0; // in meters
+		final Area ret = new Area();
 		ret.topleft.latDec = centre.latDec;
 		ret.topleft.lonDec = centre.lonDec;
 		ret.topleft.shift(halfSideLength, north);
@@ -542,13 +523,11 @@
 		return ret;
 	}
 
-	public void doItQuickFillFromMapList() {
+	public void doItQuickFillFromOldMapList() {
 
-		CWPoint origin = pref.getCurCentrePt();
+		final CWPoint origin = pref.getCurCentrePt();
 		if (!origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
 			return; //
 		}
 		if (!doDownloadGui(2))
@@ -561,15 +540,15 @@
 		// Reset states for all caches when spidering
 		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl&#228;nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance; // halbe Seitenl&#228;nge eines Quadrats
+												// ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 
 		if (!loggedIn || pref.forceLogin) {
@@ -580,9 +559,8 @@
 		page_number = 0;
 		num_added = 0;
 
-		Area sq = getSquare(origin, halfSideLength);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec,
-				sq.bottomright.lonDec, false);
+		final Area sq = getSquare(origin, halfSideLength);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, false);
 
 		if (!infB.isClosed)
 			infB.close(0);
@@ -593,26 +571,24 @@
 
 	}
 
-	private void getCaches(double north, double west, double south,
-			double east, boolean setCachesToLoad) {
+	private void getCaches(double north, double west, double south, double east, boolean setCachesToLoad) {
 		if (infB.isClosed)
 			return;
-		double lm = (north + south) / 2.0;
-		CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
-		CWPoint rm = new CWPoint(lm, east);
-		double len = middle.getDistance(rm) * 2.0;
+		final double lm = (north + south) / 2.0;
+		final CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
+		final CWPoint rm = new CWPoint(lm, east);
+		final double len = middle.getDistance(rm) * 2.0;
 		page_number++;
-		String listPage = getMapListPage(middle, north, west, south, east);
-		int i = listPage.indexOf(&quot;\&quot;count\\\&quot;:&quot;); // \&quot;count\&quot;:
-		if (i==-1) {
-			pref.log(&quot;[getCaches:getMapListPage]got nothing!&quot;+listPage,null);
+		final String listPage = getMapListPage(middle, north, west, south, east);
+		final int i = listPage.indexOf(&quot;\&quot;count\\\&quot;:&quot;); // \&quot;count\&quot;:
+		if (i == -1) {
+			pref.log(&quot;[getCaches:getMapListPage]got nothing!&quot; + listPage, null);
 			return;
 		}
 		pref.log(&quot;&quot; + north + &quot; &quot; + west + &quot; &quot; + south + &quot; &quot; + east + &quot; &quot; + listPage.substring(i) + &quot;\n len=&quot; + len);
-		if ((listPage.indexOf(&quot;\&quot;count\\\&quot;:501&quot;) &gt; -1)
-		||  (listPage.indexOf(&quot;\&quot;count\\\&quot;:0&quot;) &gt; -1 &amp;&amp; len &gt; 30)) {
-			double northsouthmiddle = (north + south) / 2.0;
-			double westeastmiddle = (west + east) / 2.0;
+		if ((listPage.indexOf(&quot;\&quot;count\\\&quot;:501&quot;) &gt; -1) || (listPage.indexOf(&quot;\&quot;count\\\&quot;:0&quot;) &gt; -1 &amp;&amp; len &gt; 30)) {
+			final double northsouthmiddle = (north + south) / 2.0;
+			final double westeastmiddle = (west + east) / 2.0;
 			getCaches(north, west, northsouthmiddle, westeastmiddle, setCachesToLoad);
 			getCaches(north, westeastmiddle, northsouthmiddle, east, setCachesToLoad);
 			getCaches(northsouthmiddle, west, south, westeastmiddle, setCachesToLoad);
@@ -623,48 +599,52 @@
 	}
 
 	private void addCaches(String listPage, boolean setCachesToLoad) {
-		String[] caches = mString.split(listPage, '{');
-		//int posId=0;        //id egal
-		//int posName=1;      //nn
-		
-		//positions decreased by 2, because we cut away the name to prevent parsing errors
-		int posWP=0;        //gc 
-		int posLat=1;       //lat
-		int posLon=2;       //lon
-		int posType=3;      //ctid
-		int posFound=4;     //f
-		int posOwn=5;       //o
-		int posAvailable=6; //ia
+		final String[] caches = mString.split(listPage, '{');
+		// int posId=0; //id egal
+		// int posName=1; //nn
+
+		// positions decreased by 2, because we cut away the name to prevent
+		// parsing errors
+		final int posWP = 0; // gc
+		final int posLat = 1; // lat
+		final int posLon = 2; // lon
+		final int posType = 3; // ctid
+		final int posFound = 4; // f
+		final int posOwn = 5; // o
+		final int posAvailable = 6; // ia
 		// ignoring first 3 lines
 		for (int i = 4; i &lt; caches.length; i++) {
-			if (infB.isClosed) return;
-			
-			//cut away name to prevent parsing errors			
-			int WpIndex = caches[i].indexOf(&quot;\&quot;gc\\\&quot;&quot;);
-			String elements[] = mString.split(caches[i].substring(WpIndex), ',');
-			
-			boolean found = (elements[posFound].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
-			if (found &amp;&amp; doNotgetFound)	continue;
-			
-			byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
+			if (infB.isClosed)
+				return;
+
+			// cut away name to prevent parsing errors
+			final int WpIndex = caches[i].indexOf(&quot;\&quot;gc\\\&quot;&quot;);
+			final String elements[] = mString.split(caches[i].substring(WpIndex), ',');
+
+			final boolean found = (elements[posFound].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
+			if (found &amp;&amp; doNotgetFound)
+				continue;
+
+			final byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
 			if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
-				if (restrictedCacheType != cacheType) continue;
+				if (restrictedCacheType != cacheType)
+					continue;
 			}
 
 			String wp = mString.split(elements[posWP], '\&quot;')[3];
-			wp=wp.substring(0, wp.length()-1);
+			wp = wp.substring(0, wp.length() - 1);
 			CacheHolder ch = cacheDB.get(wp);
 			if (ch == null) {
 
-				String lat = mString.split(elements[posLat], ':')[1];
-				String lon = mString.split(elements[posLon], ':')[1];
-				String own = mString.split(elements[posOwn], ':')[1];
-				boolean available = (elements[posAvailable].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
-				
-				int NameIndex = caches[i].indexOf(&quot;\&quot;nn\\\&quot;&quot;);
-				String cacheName = caches[i].substring (NameIndex + 8, WpIndex - 4 );
-				cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot; );
+				final String lat = mString.split(elements[posLat], ':')[1];
+				final String lon = mString.split(elements[posLon], ':')[1];
+				final String own = mString.split(elements[posOwn], ':')[1];
+				final boolean available = (elements[posAvailable].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
 
+				final int NameIndex = caches[i].indexOf(&quot;\&quot;nn\\\&quot;&quot;);
+				String cacheName = caches[i].substring(NameIndex + 8, WpIndex - 4);
+				cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
+
 				ch = new CacheHolder();
 				ch.setWayPoint(wp);
 				ch.setLatLon(lat + &quot; &quot; + lon);
@@ -684,13 +664,11 @@
 				if (setCachesToLoad) {
 					cachesToLoad.add(wp + &quot;found&quot;);
 				} else {
-					ch.getCacheDetails(false).URL=&quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+wp;
+					ch.getCacheDetails(false).URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + wp;
 					ch.save();
 				}
 				if (Global.mainTab.statBar != null)
-					Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot;
-							+ page_number + &quot; Caches added to CW: &quot;
-							+ num_added);
+					Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot; + page_number + &quot; Caches added to CW: &quot; + num_added);
 			} else {
 			}
 		}
@@ -701,13 +679,8 @@
 		OCXMLImporterScreen options;
 		direction = &quot;&quot;;
 		if (menu == 0 &amp;&amp; spiderAllFinds) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(217,
-					&quot;Spider all finds from geocaching.com&quot;),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER
-							| OCXMLImporterScreen.MAXUPDATE
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.MAXLOGS);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(217, &quot;Spider all finds from geocaching.com&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.IMAGES
+					| OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS);
 			// setting defaults for input
 			options.maxNumberUpdates.setText(&quot;0&quot;);
 			// doing the input
@@ -718,16 +691,8 @@
 			maxDistance = 1.0;
 			minDistance = 0.0;
 		} else if (menu == 0) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(131,
-					&quot;Download from geocaching.com&quot;), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.MAXNUMBER
-					| OCXMLImporterScreen.MAXUPDATE
-					| OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.DIRECTION
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.IMAGES
-					| OCXMLImporterScreen.TRAVELBUGS
-					| OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(131, &quot;Download from geocaching.com&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
+					| OCXMLImporterScreen.DIRECTION | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
 			// setting defaults for input
 			if (pref.spiderUpdates == Preferences.NO) {
 				options.maxNumberUpdates.setText(&quot;0&quot;);
@@ -738,27 +703,20 @@
 			}
 			// setting default values for options not used (if necessary)
 
-			String minDist = options.minDistanceInput.getText();
+			final String minDist = options.minDistanceInput.getText();
 			minDistance = Common.parseDouble(minDist);
 			profile.setMinDistGC(Double.toString(minDistance).replace(',', '.'));
 
 			direction = options.directionInput.getText();
 			directions = mString.split(direction, '-');
-			
+
 			doNotgetFound = options.foundCheckBox.getState();
 			profile.setDirectionGC(direction);
 
 		} else if (menu == 1) { // menu = 1 input values for get Caches along a
 								// route
-			options = new OCXMLImporterScreen(MyLocale.getMsg(137,
-					&quot;Download along a Route from geocaching.com&quot;),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST
-							| OCXMLImporterScreen.INCLUDEFOUND
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.MAXLOGS
-							| OCXMLImporterScreen.FILENAME
-							| OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(137, &quot;Download along a Route from geocaching.com&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TRAVELBUGS
+					| OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.FILENAME | OCXMLImporterScreen.TYPE);
 			// setting defaults for input
 			// doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
@@ -770,11 +728,7 @@
 			maxUpdate = 0;
 			fileName = options.fileName;
 		} else { // if (menu == 2) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(138,
-					&quot;Qick Import&quot;), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(138, &quot;Qick Import&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TYPE);
 			// setting defaults for input doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
 				return false;
@@ -785,7 +739,7 @@
 		if (menu == 0) {
 
 			int maxNew = -1;
-			String maxNumberString = options.maxNumberInput.getText();
+			final String maxNumberString = options.maxNumberInput.getText();
 			if (maxNumberString.length() != 0) {
 				maxNew = Common.parseInt(maxNumberString);
 			}
@@ -798,7 +752,7 @@
 			}
 
 			maxUpdate = -1;
-			String maxUpdateString = options.maxNumberUpdates.getText();
+			final String maxUpdateString = options.maxNumberUpdates.getText();
 			if (maxUpdateString.length() != 0) {
 				maxUpdate = Common.parseInt(maxUpdateString);
 			}
@@ -809,10 +763,13 @@
 		// options for all
 
 		if (options.maxDistanceInput != null) {
-			String maxDist = options.maxDistanceInput.getText();
+			final String maxDist = options.maxDistanceInput.getText();
 			maxDistance = Common.parseDouble(maxDist);
-			if (maxDistance == 0) return false;
-			if (maxDistance &lt; 0.5) maxDistance = 0.5; // zur Sicherheit bei &quot;along the route&quot; mindenstens 500 meter Umkreis
+			if (maxDistance == 0)
+				return false;
+			if (maxDistance &lt; 0.5)
+				maxDistance = 0.5; // zur Sicherheit bei &quot;along the route&quot;
+									// mindenstens 500 meter Umkreis
 			profile.setDistGC(Double.toString(maxDistance));
 		}
 
@@ -826,9 +783,7 @@
 
 	}
 
-	private Hashtable fillDownloadLists(int maxNew, int maxUpdate,
-			double toDistance, double fromDistance, String[] directions,
-			Hashtable cExpectedForUpdate) {
+	private Hashtable fillDownloadLists(int maxNew, int maxUpdate, double toDistance, double fromDistance, String[] directions, Hashtable cExpectedForUpdate) {
 		if (!loggedIn || pref.forceLogin) {
 			if (login() != FormBase.IDOK)
 				return null;
@@ -836,18 +791,18 @@
 
 		int numFinds;
 		int startPage = 1;
-		// get pagenumber of page with fromDistance , to skip reading of pages &lt; fromDistance
+		// get pagenumber of page with fromDistance , to skip reading of pages &lt;
+		// fromDistance
 		if (fromDistance &gt; 0) {
 			// distance in miles for URL
 			int fromDistanceInMiles = (int) java.lang.Math.ceil(fromDistance);
 			if (pref.metricSystem != Metrics.IMPERIAL) {
-				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics
-						.convertUnit(fromDistance, Metrics.KILOMETER,
-								Metrics.MILES));
+				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(fromDistance, Metrics.KILOMETER, Metrics.MILES));
 			}
 			// - a mile to be save to get a page with fromDistance
 			getFirstListPage(java.lang.Math.max(fromDistanceInMiles - 1, 1));
-			numFinds = getNumFound(htmlListPage); // Number of caches from gc Listpage
+			numFinds = getNumFound(htmlListPage); // Number of caches from gc
+													// Listpage
 			// calc the number of the startpage
 			startPage = (int) java.lang.Math.ceil(numFinds / 20);
 		}
@@ -855,13 +810,14 @@
 		// max distance in miles for URL, so we can get more than 80km
 		int toDistanceInMiles = (int) java.lang.Math.ceil(toDistance);
 		if (pref.metricSystem != Metrics.IMPERIAL) {
-			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(
-					toDistance, Metrics.KILOMETER, Metrics.MILES));
+			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(toDistance, Metrics.KILOMETER, Metrics.MILES));
 		}
-		// add a mile to be save from different distance calculations in CW and at GC
+		// add a mile to be save from different distance calculations in CW and
+		// at GC
 		toDistanceInMiles++;
 		getFirstListPage(toDistanceInMiles);
-		numFinds = getNumFound(htmlListPage); // Number of caches from gc first Listpage
+		numFinds = getNumFound(htmlListPage); // Number of caches from gc first
+												// Listpage
 
 		if (fromDistance &gt; 0) {
 			// skip (most of) the pages with distance &lt; fromDistance
@@ -875,9 +831,7 @@
 		int numFoundInDB = 0; // Number of GC-founds already in this profile
 		if (spiderAllFinds) {
 			numFoundInDB = getFoundInDB();
-			pref.log((spiderAllFinds ? &quot;all Finds (DB/GC)&quot; + numFoundInDB + &quot;/&quot;
-					+ numFinds : &quot;new and update Caches&quot;)
-					+ Preferences.NEWLINE, null);
+			pref.log((spiderAllFinds ? &quot;all Finds (DB/GC)&quot; + numFoundInDB + &quot;/&quot; + numFinds : &quot;new and update Caches&quot;) + Preferences.NEWLINE, null);
 			maxNew = java.lang.Math.min(numFinds - numFoundInDB, maxNew);
 			if (maxUpdate == 0 &amp;&amp; maxNew == 0) {
 				Vm.showWait(false);
@@ -889,40 +843,37 @@
 		if (maxUpdate &gt; 0) {
 			double distanceInKm = toDistance;
 			if (pref.metricSystem == Metrics.IMPERIAL) {
-				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES,
-						Metrics.KILOMETER);
+				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES, Metrics.KILOMETER);
 			}
 			// expecting all are changed (archived caches remain always)
 			for (int i = 0; i &lt; cacheDB.size(); i++) {
-				CacheHolder ch = cacheDB.get(i);
+				final CacheHolder ch = cacheDB.get(i);
 				if (spiderAllFinds) {
-					if ((ch.getWayPoint().substring(0, 2)
-							.equalsIgnoreCase(&quot;GC&quot;))
-							&amp;&amp; !ch.is_black()) {
+					if ((ch.getWayPoint().substring(0, 2).equalsIgnoreCase(&quot;GC&quot;)) &amp;&amp; !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				} else {
-					if ((!ch.is_archived())
-							&amp;&amp; (ch.kilom &lt;= distanceInKm)
-							&amp;&amp; !(doNotgetFound &amp;&amp; (ch.is_found() || ch
-									.is_owned()))
-							&amp;&amp; (ch.getWayPoint().substring(0, 2)
-									.equalsIgnoreCase(&quot;GC&quot;))
-							&amp;&amp; ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch
-									.getType() == restrictedCacheType))
-							&amp;&amp; !ch.is_black()) {
+					if ((!ch.is_archived()) &amp;&amp; (ch.kilom &lt;= distanceInKm) &amp;&amp; !(doNotgetFound &amp;&amp; (ch.is_found() || ch.is_owned())) &amp;&amp; (ch.getWayPoint().substring(0, 2).equalsIgnoreCase(&quot;GC&quot;))
+							&amp;&amp; ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch.getType() == restrictedCacheType)) &amp;&amp; !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				}
 			}
 		}
-		int startSize = cExpectedForUpdate.size(); // for save reasons
+		final int startSize = cExpectedForUpdate.size(); // for save reasons
 
-		Hashtable cFoundForUpdate = new Hashtable(cacheDB.size()); // for don't loose the already done work
+		final Hashtable cFoundForUpdate = new Hashtable(cacheDB.size()); // for
+																			// don't
+																			// loose
+																			// the
+																			// already
+																			// done
+																			// work
 		page_number = 1;
 		int found_on_page = 0;
 		try {
-			// Loop pages till maximum distance has been found or no more caches are in the list
+			// Loop pages till maximum distance has been found or no more caches
+			// are in the list
 			while (toDistance &gt; 0) {
 				RexPropListBlock.search(htmlListPage);
 				String tableOfHtmlListPage;
@@ -941,29 +892,28 @@
 					}
 					found_on_page++;
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay(&quot;working &quot;
-								+ page_number + &quot; / &quot; + found_on_page);
-					String CacheDescriptionGC = RexPropLine.stringMatched(1);
-					double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
+						Global.mainTab.statBar.updateDisplay(&quot;working &quot; + page_number + &quot; / &quot; + found_on_page);
+					final String CacheDescriptionGC = RexPropLine.stringMatched(1);
+					final double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
 					String chWaypoint = getWP(CacheDescriptionGC);
 					if (DistanceAndDirection[0] &lt;= toDistance) {
-						CacheHolder ch = cacheDB.get(chWaypoint);
+						final CacheHolder ch = cacheDB.get(chWaypoint);
 						if (ch == null) { // not in DB
-							if (DistanceAndDirection[0] &gt;= fromDistance
-									&amp;&amp; directionOK(directions, DistanceAndDirection[1])
-									&amp;&amp; doPMCache(chWaypoint, CacheDescriptionGC)
-									&amp;&amp; cachesToLoad.size() &lt; maxNew) {
-								if (CacheDescriptionGC.indexOf(propFound) != -1) chWaypoint = chWaypoint + &quot;found&quot;;
-								if (!cachesToLoad.contains(chWaypoint)) { cachesToLoad.add(chWaypoint);	}
+							if (DistanceAndDirection[0] &gt;= fromDistance &amp;&amp; directionOK(directions, DistanceAndDirection[1]) &amp;&amp; doPMCache(chWaypoint, CacheDescriptionGC) &amp;&amp; cachesToLoad.size() &lt; maxNew) {
+								if (CacheDescriptionGC.indexOf(propFound) != -1)
+									chWaypoint = chWaypoint + &quot;found&quot;;
+								if (!cachesToLoad.contains(chWaypoint)) {
+									cachesToLoad.add(chWaypoint);
+								}
 							} else {
-								// pref.log(&quot;no load of (Premium Cache/other direction/short Distance ?) &quot; + chWaypoint);
+								// pref.log(&quot;no load of (Premium Cache/other direction/short Distance ?) &quot;
+								// + chWaypoint);
 								cExpectedForUpdate.remove(chWaypoint);
 							}
 						} else {
 							if (maxUpdate &gt; 0) { // regardless of fromDistance
 								if (!ch.is_black()) {
-									if (doPMCache(chWaypoint, CacheDescriptionGC)
-										&amp;&amp; updateExists(ch, CacheDescriptionGC)) {
+									if (doPMCache(chWaypoint, CacheDescriptionGC) &amp;&amp; updateExists(ch, CacheDescriptionGC)) {
 										if (cFoundForUpdate.size() &lt; maxUpdate) {
 											cFoundForUpdate.put(chWaypoint, ch);
 										} else
@@ -979,33 +929,32 @@
 								toDistance = 0;
 								cExpectedForUpdate.clear();
 							} else {
-								if (cExpectedForUpdate.size() &lt;= cFoundForUpdate
-										.size()) {
+								if (cExpectedForUpdate.size() &lt;= cFoundForUpdate.size()) {
 									toDistance = 0;
 								}
 							}
 						}
 					} else
 						toDistance = 0; // finish listing
-					// get next row of table (next Cache Description) of this htmlListPage
-					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine
-							.matchedTo());
+					// get next row of table (next Cache Description) of this
+					// htmlListPage
+					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine.matchedTo());
 					if (infB.isClosed) {
 						toDistance = 0;
 						break;
 					}
 				} // next Cache
-				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;)
-						+ cachesToLoad.size() + &quot; / &quot; + cFoundForUpdate.size()
-						+ MyLocale.getMsg(5512, &quot; caches&quot;));
+				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;) + cachesToLoad.size() + &quot; / &quot; + cFoundForUpdate.size() + MyLocale.getMsg(5512, &quot; caches&quot;));
 				if (found_on_page &lt; 20) {
 					if (spiderAllFinds) {
-						// check all pages ( seen a gc-account with found_on_page less 20 and not on end )
+						// check all pages ( seen a gc-account with
+						// found_on_page less 20 and not on end )
 						if (((page_number - 1) * 20 + found_on_page) &gt;= numFinds) {
 							toDistance = 0;
 						}
 					} else
-						toDistance = 0; // last page (has less than 20 entries!?) to check reached
+						toDistance = 0; // last page (has less than 20
+										// entries!?) to check reached
 				}
 				if (toDistance &gt; 0) {
 					getAListPage(toDistanceInMiles, gotoNextPage);
@@ -1014,53 +963,42 @@
 				}
 			} // loop pages
 		} // try
-		catch (Exception ex) {
+		catch (final Exception ex) {
 			pref.log(&quot;Download error : &quot;, ex, true);
 			infB.close(0);
 			Vm.showWait(false);
 			cExpectedForUpdate.clear();
 		}
-		pref.log(&quot;Checked &quot; + page_number + &quot; pages&quot;+Preferences.NEWLINE+
-				&quot;with &quot; + ((page_number-1)*20+found_on_page) + &quot; caches&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + cachesToLoad.size() + &quot; new caches&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + cExpectedForUpdate.size() + &quot;/&quot; + cFoundForUpdate.size() + &quot; caches for update&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + numAvailableUpdates + &quot; caches with changed available status.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + numLogUpdates + &quot; caches with new found in log.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + (cExpectedForUpdate.size()-numAvailableUpdates-numLogUpdates) + &quot; caches possibly archived.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + cFoundForUpdate.size() + &quot; ?= &quot; + (numFoundUpdates+numArchivedUpdates+numAvailableUpdates+numArchivedUpdates) + &quot; caches to update.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + numPrivate + &quot; Premium Caches (for non Premium Member.)&quot;,null);
-		if(spiderAllFinds){
-			pref.log(&quot;Found &quot; + numFoundUpdates + &quot; caches with no found in profile.&quot;+Preferences.NEWLINE+
-			&quot;Found &quot; + numArchivedUpdates + &quot; caches with changed archived status.&quot;+Preferences.NEWLINE,null);
+		pref.log(&quot;Checked &quot; + page_number + &quot; pages&quot; + Preferences.NEWLINE + &quot;with &quot; + ((page_number - 1) * 20 + found_on_page) + &quot; caches&quot; + Preferences.NEWLINE + &quot;Found &quot; + cachesToLoad.size() + &quot; new caches&quot; + Preferences.NEWLINE + &quot;Found &quot;
+				+ cExpectedForUpdate.size() + &quot;/&quot; + cFoundForUpdate.size() + &quot; caches for update&quot; + Preferences.NEWLINE + &quot;Found &quot; + numAvailableUpdates + &quot; caches with changed available status.&quot; + Preferences.NEWLINE + &quot;Found &quot; + numLogUpdates
+				+ &quot; caches with new found in log.&quot; + Preferences.NEWLINE + &quot;Found &quot; + (cExpectedForUpdate.size() - numAvailableUpdates - numLogUpdates) + &quot; caches possibly archived.&quot; + Preferences.NEWLINE + &quot;Found &quot; + cFoundForUpdate.size() + &quot; ?= &quot;
+				+ (numFoundUpdates + numArchivedUpdates + numAvailableUpdates + numArchivedUpdates) + &quot; caches to update.&quot; + Preferences.NEWLINE + &quot;Found &quot; + numPrivate + &quot; Premium Caches (for non Premium Member.)&quot;, null);
+		if (spiderAllFinds) {
+			pref.log(&quot;Found &quot; + numFoundUpdates + &quot; caches with no found in profile.&quot; + Preferences.NEWLINE + &quot;Found &quot; + numArchivedUpdates + &quot; caches with changed archived status.&quot; + Preferences.NEWLINE, null);
 		}
 
 		if (cExpectedForUpdate.size() == startSize)
 			cExpectedForUpdate.clear(); // there must be something wrong
-		if (cExpectedForUpdate.size() == 0
-				|| cExpectedForUpdate.size() &gt; maxUpdate)
+		if (cExpectedForUpdate.size() == 0 || cExpectedForUpdate.size() &gt; maxUpdate)
 			cExpectedForUpdate = cFoundForUpdate;
 		return cExpectedForUpdate;
 
 	}
 
-	private int downloadCaches(Vector cachesToLoad, int spiderErrors,
-			int totalCachesToLoad, boolean loadAllLogs) {
+	private int downloadCaches(Vector cachesToLoad, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		for (int i = 0; i &lt; cachesToLoad.size(); i++) {
 			if (infB.isClosed)
 				break;
 			String wpt = (String) cachesToLoad.get(i);
-			boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
+			final boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
 			if (is_found)
 				wpt = wpt.substring(0, wpt.indexOf(&quot;found&quot;));
 			// Get only caches not already available in the DB
 			if (cacheDB.getIndex(wpt) == -1) {
-				infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + wpt + &quot; (&quot;
-						+ (i + 1) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
-				CacheHolder holder = new CacheHolder();
+				infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + wpt + &quot; (&quot; + (i + 1) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
+				final CacheHolder holder = new CacheHolder();
 				holder.setWayPoint(wpt);
-				int test = getCacheByWaypointName(holder, false,
-						pref.downloadPics, pref.downloadTBs, doNotgetFound,
-						loadAllLogs || is_found |!doNotgetFound);
+				final int test = getCacheByWaypointName(holder, false, pref.downloadPics, pref.downloadTBs, doNotgetFound, loadAllLogs || is_found | !doNotgetFound);
 				if (test == SPIDER_CANCEL) {
 					infB.close(0);
 					break;
@@ -1078,18 +1016,15 @@
 
 	private int updateCaches(Hashtable cachesToUpdate, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		int j = 1;
-		for (Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
+		for (final Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
 			if (infB.isClosed)
 				break;
-			CacheHolder ch = (CacheHolder) e.nextElement();
-			infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + ch.getWayPoint()
-					+ &quot; (&quot; + (cachesToLoad.size() + j) + &quot; / &quot;
-					+ totalCachesToLoad + &quot;)&quot;);
-			int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
+			final CacheHolder ch = (CacheHolder) e.nextElement();
+			infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + ch.getWayPoint() + &quot; (&quot; + (cachesToLoad.size() + j) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
+			final int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
 			if (test == SPIDER_CANCEL) {
 				break;
-			} 
-			else {
+			} else {
 				if (test == SPIDER_ERROR) {
 					spiderErrors++;
 					pref.log(&quot;[updateCaches] could not spider &quot; + ch.getWayPoint(), null);
@@ -1102,17 +1037,14 @@
 	}
 
 	/**
-	 * Method to spider a single cache. It assumes a login has already been
-	 * performed!
+	 * Method to spider a single cache. It assumes a login has already been performed!
 	 * 
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing
-	 *         the infobox, 0 error, but continue with next cache
+	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
 	 */
-	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin,
-			boolean loadAllLogs) {
+	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin, boolean loadAllLogs) {
 		int ret = -1;
 		this.infB = pInfB;
-		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
+		final CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
 		ch.setWayPoint(cacheDB.get(number).getWayPoint());
 		if (ch.isAddiWpt())
 			return -1; // No point re-spidering an addi waypoint, comes with
@@ -1126,11 +1058,10 @@
 		}
 		try {
 			// Read the cache data from GC.COM and compare to old data
-			ret = getCacheByWaypointName(ch, true, pref.downloadPics,
-					pref.downloadTBs, false, loadAllLogs);
+			ret = getCacheByWaypointName(ch, true, pref.downloadPics, pref.downloadTBs, false, loadAllLogs);
 			// Save the spidered data
 			if (ret == SPIDER_OK) {
-				CacheHolder cacheInDB = cacheDB.get(number);
+				final CacheHolder cacheInDB = cacheDB.get(number);
 				cacheInDB.initStates(false);
 				if (cacheInDB.is_found() &amp;&amp; !ch.is_found() &amp;&amp; !loadAllLogs) {
 					// If the number of logs to spider is 5 or less, then the
@@ -1144,18 +1075,15 @@
 				ch.setNumRecommended(cacheInDB.getNumRecommended());
 				if (pref.downloadPics) {
 					// delete obsolete images when we have current set
-					CacheImages.cleanupOldImages(cacheInDB
-							.getCacheDetails(true).images, ch
-							.getCacheDetails(false).images);
+					CacheImages.cleanupOldImages(cacheInDB.getCacheDetails(true).images, ch.getCacheDetails(false).images);
 				} else {
 					// preserve images if not downloaded
-					ch.getCacheDetails(false).images = cacheInDB
-							.getCacheDetails(true).images;
+					ch.getCacheDetails(false).images = cacheInDB.getCacheDetails(true).images;
 				}
 				cacheInDB.update(ch);
 				cacheInDB.save();
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[spiderSingle] Error spidering &quot; + ch.getWayPoint() + &quot; in spiderSingle&quot;, ex);
 		}
 		return ret;
@@ -1178,13 +1106,13 @@
 				return &quot;&quot;;
 			}
 		}
-		InfoBox localInfB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
+		final InfoBox localInfB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
 		localInfB.exec();
 		try {
-			String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
+			final String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
 			completeWebPage = UrlFetcher.fetch(doc);
 			pref.log(&quot;Fetched &quot; + wayPoint);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
 			pref.log(&quot;[getCacheCoordinates] Could not fetch &quot; + wayPoint, ex);
 			return &quot;&quot;;
@@ -1192,34 +1120,43 @@
 		localInfB.close(0);
 		try {
 			return getLatLon(completeWebPage);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			return &quot;????&quot;;
 		}
 	} // getCacheCoordinates
 
 	/**
-	 * Method to login the user to gc.com It will request a password and use the
-	 * alias defined in preferences If the login page cannot be fetched, the
-	 * password is cleared. If the login fails, an appropriate message is
-	 * displayed.
+	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
 	 */
 	private int login() {
-		if (cookie.length() &gt; 0) 
-			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
-		else
+		if (pref.userID.length() &gt; 0) {
 			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
+			loggedIn = switchToEnglish();
+			if (loggedIn)
+				return FormBase.IDOK;
+			else {
+				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences| Einstellungen.&quot;, FormBase.OKB)).execute();
+				return ERR_LOGIN;
+			}
+		} else {
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
+			if (true) {
+				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences| Einstellungen.&quot;, FormBase.OKB)).execute();
+				return ERR_LOGIN; // until SSL/https works
+			}
+		}
 		loggedIn = false;
 		String loginPage, loginPageUrl, loginSuccess;
 		try {
 			loginPageUrl = p.getProp(&quot;loginPage&quot;);
 			loginSuccess = p.getProp(&quot;loginSuccess&quot;);
-		} catch (Exception ex) { // Tag not found in spider.def
+		} catch (final Exception ex) { // Tag not found in spider.def
 			return ERR_LOGIN;
 		}
 
 		// **0 Get password
 		String passwort = pref.password;
-		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, &quot;Password&quot;),MyLocale.getMsg(5505, &quot;Enter Password&quot;), InfoBox.INPUT);
+		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, &quot;Password&quot;), MyLocale.getMsg(5505, &quot;Enter Password&quot;), InfoBox.INPUT);
 		localInfB.feedback.setText(passwort);
 		localInfB.feedback.isPassword = true;
 		int code = FormBase.IDOK;
@@ -1228,8 +1165,9 @@
 			passwort = localInfB.getInput();
 		}
 		localInfB.close(0);
-		if (code != FormBase.IDOK) return code;
-		
+		if (code != FormBase.IDOK)
+			return code;
+
 		// **1 now we have user and password for login
 		localInfB = new InfoBox(MyLocale.getMsg(5507, &quot;Status&quot;), MyLocale.getMsg(5508, &quot;Logging in...&quot;));
 		localInfB.exec();
@@ -1237,48 +1175,40 @@
 			loginPage = UrlFetcher.fetch(loginPageUrl); // <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
 			if (loginPage.equals(&quot;&quot;)) {
 				localInfB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 				pref.log(&quot;[login]:Could not fetch: gc.com login page &quot; + loginPageUrl, null);
 				return ERR_LOGIN;
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
 			return ERR_LOGIN;
 		}
-		
+
 		// **2 now we can check the loginpage if logged in else log in
 		if (!localInfB.isClosed) {
-			if (loginPage.indexOf(loginSuccess) &gt; 0)  {
+			if (loginPage.indexOf(loginSuccess) &gt; 0) {
 				if (loginPage.indexOf(pref.myAlias) &gt; 0) {
 					loggedIn = true;
 					// assume language is already set to EN
 					pref.log(&quot;[login]:Already logged in as &quot; + pref.myAlias);
-				}
-				else {
+				} else {
 					// it is another user, whom we should logout
 					try {
-						loginPage = UrlFetcher.fetch(&quot;<A HREF="http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y">http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y</A>&quot;);						
-					} catch (Exception ex) {
+						loginPage = UrlFetcher.fetch(&quot;<A HREF="http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y">http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y</A>&quot;);
+					} catch (final Exception ex) {
 						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-								MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;),
-								FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 						pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
 						return ERR_LOGIN;
 					}
-					
+
 				}
 			}
-			if (!loggedIn)
-				{
+			if (!loggedIn) {
 				try {
-					Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+					final Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
 					String viewstate = &quot;&quot;;
 					rexViewstate.search(loginPage);
 					if (rexViewstate.didMatch()) {
@@ -1286,15 +1216,16 @@
 					} else {
 						localInfB.close(0);
 						pref.log(&quot;[login]:__VIEWSTATE not found (before login): no login possible.&quot;, null);
-						// we need the __VIEWSTATE for sending loginData, so we should abort here
+						// we need the __VIEWSTATE for sending loginData, so we
+						// should abort here
 						return ERR_LOGIN;
 					}
-					StringBuffer sb = new StringBuffer(1000);
-					sb.append(&quot;__VIEWSTATE=&quot;+URL.encodeURL(viewstate, false));
+					final StringBuffer sb = new StringBuffer(1000);
+					sb.append(&quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false));
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(&quot;myUsername=&quot;+encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
+					sb.append(&quot;myUsername=&quot; + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(&quot;myPassword=&quot;+encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
+					sb.append(&quot;myPassword=&quot; + encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
 					sb.append(&quot;cookie=on&quot;);
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
@@ -1303,83 +1234,56 @@
 					loginPage = UrlFetcher.fetch(loginPageUrl);
 					if (loginPage.indexOf(loginSuccess) &gt; 0) {
 						pref.log(&quot;Login successful: &quot; + pref.myAlias);
-						// **3 now we are logged in and get the Cookie (there are two)
-						PropertyList pl = UrlFetcher.getDocumentProperties();
+						// **3 now we are logged in and get the Cookie (there
+						// are two)
+						final PropertyList pl = UrlFetcher.getDocumentProperties();
 						String docprops = &quot;&quot;;
 						for (int i = 0; i &lt; pl.size(); i++) {
-							Property p = (Property) pl.get(i);
+							final Property p = (Property) pl.get(i);
 							if (p.name.equalsIgnoreCase(&quot;Set-Cookie&quot;)) {
-								docprops+=p.value;
+								docprops += p.value;
 							}
 						}
-						Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
+						final Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
 						rexCookieSession.search(docprops);
 						if (rexCookieSession.didMatch()) {
 							cookie = &quot;ASP.NET_SessionId=&quot; + rexCookieSession.stringMatched(1);
-						} 
-						else {
+						} else {
 							localInfB.close(0);
 							pref.log(&quot;[login]:SessionID not found.&quot;, null);
 							return ERR_LOGIN;
 						}
-						Regex rexCookieID = new Regex(&quot;(?i)userid=(.*?);.*&quot;);
+						final Regex rexCookieID = new Regex(&quot;(?i)userid=(.*?);.*&quot;);
 						rexCookieID.search(docprops);
 						if (rexCookieID.didMatch()) {
 							cookie += &quot;; userid=&quot; + rexCookieID.stringMatched(1);
-						} 
-						else {
+						} else {
 							localInfB.close(0);
 							pref.log(&quot;[login]:userID not found.&quot;, null);
 							return ERR_LOGIN;
 						}
 						UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
-
-						// **4 change language to EN 
-						rexViewstate.search(loginPage);
-						if (rexViewstate.didMatch()) {
-							viewstate = rexViewstate.stringMatched(1);
-						} 
-						else {
-							localInfB.close(0);
-							pref.log(&quot;[login]:__VIEWSTATE not found (before Language=EN): can't change language.&quot;, null);
-							return ERR_LOGIN;
-						}
-						String strEnglishPage = &quot;ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem&quot;;
-						String postStr = &quot;__EVENTTARGET=&quot;+ URL.encodeURL(strEnglishPage, false)
-										+ &quot;&amp;__EVENTARGUMENT=&quot;
-										+ &quot;&amp;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false);
-						try {
-							UrlFetcher.setpostData(postStr);
-							loginPage = UrlFetcher.fetch(loginPageUrl);
-							// there is no real check if switched
-							pref.log(&quot;Switched to English&quot;);
-						} catch (Exception ex) {
-							pref.log(&quot;Error switching to English: check/n&quot; + loginPageUrl + &quot;/n&quot; + postStr, ex);
-						}
-					}
-					else {
+					} else {
 						pref.log(&quot;Login failed. Wrong Account or Password? &quot; + pref.myAlias, null);
 						pref.log(&quot;[login.url]:&quot; + loginPageUrl, null);
 						pref.log(&quot;[login.postData]:&quot; + sb.toString(), null);
 						pref.log(&quot;[login.Answer]:&quot; + loginPage, null);
 						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-								MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;),
-								FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
 						return ERR_LOGIN;
 					}
-				} catch (Exception ex) {
+					if (!this.switchToEnglish())
+						return ERR_LOGIN;
+				} catch (final Exception ex) {
 					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
 					localInfB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-							MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;),
-							FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
 					return ERR_LOGIN;
 				}
 			}
 		}
-		
-		boolean loginAborted = localInfB.isClosed;
+
+		final boolean loginAborted = localInfB.isClosed;
 		localInfB.close(0);
 		if (loginAborted)
 			return FormBase.IDCANCEL;
@@ -1388,6 +1292,77 @@
 			return FormBase.IDOK;
 		}
 	}
+
+	private boolean switchToEnglish() {
+		// change language to EN , further operations relay on English
+		String url = &quot;<A HREF="http://www.geocaching.com/my/default.aspx">http://www.geocaching.com/my/default.aspx</A>&quot;;
+		String page = &quot;&quot;;
+		String loggedInEnglish = &quot;Sign Out&quot;;
+		String userID = &quot;userid=&quot; + pref.userID;
+		try {
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, userID);
+			page = UrlFetcher.fetch(url); // getting the sessionid
+			if (page.length() == 0)
+				return false;
+		} catch (final Exception ex) {
+			return false;
+		}
+		final PropertyList pl = UrlFetcher.getDocumentProperties();
+		String docprops = &quot;&quot;;
+		for (int i = 0; i &lt; pl.size(); i++) {
+			final Property p = (Property) pl.get(i);
+			if (p.name.equalsIgnoreCase(&quot;Set-Cookie&quot;)) {
+				docprops += p.value;
+			}
+		}
+		final Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
+		rexCookieSession.search(docprops);
+		if (rexCookieSession.didMatch()) {
+			cookie = &quot;ASP.NET_SessionId=&quot; + rexCookieSession.stringMatched(1) + &quot;; &quot; + userID;
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
+		} else {
+			pref.log(&quot;[switchToEnglish]:SessionID not found.&quot;, null);
+			return false;
+		}
+		try {
+			page = UrlFetcher.fetch(url);
+			if (page.length() == 0)
+				return false;
+		} catch (IOException e) {
+			return false;
+		}
+		if (page.indexOf(loggedInEnglish) &gt; -1) {
+			pref.log(&quot;already English&quot;);
+			return true;
+		}
+		// todo next doesn't work correct don't know why
+		// switch to english now goes into profile (is permanent, must be reset)
+		final Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+		String viewstate = &quot;&quot;;
+		rexViewstate.search(page);
+		if (rexViewstate.didMatch()) {
+			viewstate = rexViewstate.stringMatched(1);
+		} else
+			return false;
+		final String strEnglishPage = &quot;ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem&quot;;
+		final String postStr = &quot;__EVENTTARGET=&quot; + UrlFetcher.encodeURL(strEnglishPage, false) + &quot;&amp;__EVENTARGUMENT=&quot; + &quot;&amp;__VIEWSTATE=&quot; + UrlFetcher.encodeURL(viewstate, false);
+		try {
+			UrlFetcher.setpostData(postStr);
+			page = UrlFetcher.fetch(url);
+			if (page.indexOf(loggedInEnglish) &gt; -1) {
+				pref.log(&quot;Switched to English&quot;);
+				return true;
+			} else {
+				pref.log(page, null);
+				return false;
+			}
+		} catch (final Exception ex) {
+			pref.log(&quot;Error switching to English: check/n&quot; + url + &quot;/n&quot; + postStr, ex);
+			return false;
+		}
+
+	}
+
 	/*
 	 *
 	 */
@@ -1426,7 +1401,7 @@
 			icon_camera = p.getProp(&quot;icon_camera&quot;);
 			icon_attended = p.getProp(&quot;icon_attended&quot;);
 			RexCacheType = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;Error fetching Properties.&quot;, ex);
 		}
 	}
@@ -1441,25 +1416,20 @@
 		if (spiderAllFinds) {
 			url = propFirstPageFinds + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias));
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
-		
+
 		try {
 			htmlListPage = UrlFetcher.fetch(url);
 			pref.log(&quot;[getFirstListPage] Got first page &quot; + url);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getFirstListPage] Error fetching first list page &quot; + url, ex, true);
 			Vm.showWait(false);
 			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), 
-					MyLocale.getMsg(5503, &quot;Error fetching first list page.&quot;),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5503, &quot;Error fetching first list page.&quot;), FormBase.OKB)).execute();
 			return;
 		}
 	}
@@ -1472,16 +1442,13 @@
 		if (spiderAllFinds) {
 			url = propFirstPage;
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
 
-		Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+		final Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
 		String viewstate;
 		rexViewstate.search(htmlListPage);
 		if (rexViewstate.didMatch()) {
@@ -1491,7 +1458,7 @@
 			pref.log(&quot;[getAListPage] check rexViewstate in SpiderGC.java&quot; + Preferences.NEWLINE + htmlListPage);
 		}
 
-		Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+		final Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
 		String viewstate1;
 		rexViewstate1.search(htmlListPage);
 		if (rexViewstate1.didMatch()) {
@@ -1501,16 +1468,13 @@
 			pref.log(&quot;[getAListPage] check rexViewstate1 in SpiderGC.java&quot; + Preferences.NEWLINE + htmlListPage);
 		}
 
-		String postData = &quot;__EVENTTARGET=&quot; + URL.encodeURL(whatPage, false) + &quot;&amp;&quot; +
-						  &quot;__EVENTARGUMENT=&quot; + &quot;&amp;&quot; +
-						  &quot;__VIEWSTATEFIELDCOUNT=2&quot; + &quot;&amp;&quot; +
-						  &quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false) + &quot;&amp;&quot; +
-						  &quot;__VIEWSTATE1=&quot; + URL.encodeURL(viewstate1, false);
+		final String postData = &quot;__EVENTTARGET=&quot; + URL.encodeURL(whatPage, false) + &quot;&amp;&quot; + &quot;__EVENTARGUMENT=&quot; + &quot;&amp;&quot; + &quot;__VIEWSTATEFIELDCOUNT=2&quot; + &quot;&amp;&quot; + &quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false) + &quot;&amp;&quot; + &quot;__VIEWSTATE1=&quot;
+				+ URL.encodeURL(viewstate1, false);
 		try {
 			UrlFetcher.setpostData(postData);
 			htmlListPage = UrlFetcher.fetch(url);
 			pref.log(&quot;[getAListPage] Got list page: &quot; + url);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getAListPage] Error getting a list page&quot; + url, ex);
 		}
 	}
@@ -1518,47 +1482,294 @@
 	/* */
 	private String getMapListPage(CWPoint middle, double north, double west, double south, double east) {
 		String ret;
-		
-		String referer = &quot;<A HREF="http://www.geocaching.com/map/default.aspx">http://www.geocaching.com/map/default.aspx</A>&quot; + 
-		&quot;?lat=&quot;	+ middle.getLatDeg(TransformCoordinates.DD) + 
-		&quot;&amp;lng=&quot;	+ middle.getLonDeg(TransformCoordinates.DD);
 
+		final String referer = &quot;<A HREF="http://www.geocaching.com/map/default.aspx">http://www.geocaching.com/map/default.aspx</A>&quot; + &quot;?lat=&quot; + middle.getLatDeg(TransformCoordinates.DD) + &quot;&amp;lng=&quot; + middle.getLonDeg(TransformCoordinates.DD);
+
 		if (userToken.equals(&quot;&quot;)) {
 			try {
 				ret = UrlFetcher.fetch(referer);
-			} catch (IOException e) {
-				ret=&quot;&quot;;
+			} catch (final IOException e) {
+				ret = &quot;&quot;;
 			}
 			int i = ret.indexOf(&quot;userToken = '&quot;);
-			i=i+13;
-			int j = ret.indexOf(&quot;'&quot;, i);
-			userToken = ret.substring(i,j);
+			i = i + 13;
+			final int j = ret.indexOf(&quot;'&quot;, i);
+			userToken = ret.substring(i, j);
 		}
-		
-		String url = &quot;<A HREF="http://www.geocaching.com/map/default.aspx/MapAction">http://www.geocaching.com/map/default.aspx/MapAction</A>&quot;;
 
-		String strLeft = MyLocale.formatDouble(west, &quot;#0.00000&quot;).replace(',','.');
-		String strUp = MyLocale.formatDouble(north, &quot;#0.00000&quot;).replace(',','.');
-		String strRight = MyLocale.formatDouble(east, &quot;#0.00000&quot;).replace(',','.');
-		String strDown = MyLocale.formatDouble(south, &quot;#0.00000&quot;).replace(',','.');
-		String param1 = &quot;{\&quot;dto\&quot;:{\&quot;data\&quot;:{\&quot;c\&quot;:1,\&quot;m\&quot;:\&quot;\&quot;,\&quot;d\&quot;:\&quot;&quot;;
-		String param2 = strUp + &quot;|&quot; + strDown + &quot;|&quot; + strRight + &quot;|&quot; + strLeft;
-		String param3 = &quot;\&quot;},\&quot;ut\&quot;:\&quot;&quot;;
-		String param4 = &quot;\&quot;}}&quot;;
-		String postData = param1+param2+param3+userToken+param4;
+		final String url = &quot;<A HREF="http://www.geocaching.com/map/default.aspx/MapAction">http://www.geocaching.com/map/default.aspx/MapAction</A>&quot;;
 
+		final String strLeft = MyLocale.formatDouble(west, &quot;#0.00000&quot;).replace(',', '.');
+		final String strUp = MyLocale.formatDouble(north, &quot;#0.00000&quot;).replace(',', '.');
+		final String strRight = MyLocale.formatDouble(east, &quot;#0.00000&quot;).replace(',', '.');
+		final String strDown = MyLocale.formatDouble(south, &quot;#0.00000&quot;).replace(',', '.');
+		final String param1 = &quot;{\&quot;dto\&quot;:{\&quot;data\&quot;:{\&quot;c\&quot;:1,\&quot;m\&quot;:\&quot;\&quot;,\&quot;d\&quot;:\&quot;&quot;;
+		final String param2 = strUp + &quot;|&quot; + strDown + &quot;|&quot; + strRight + &quot;|&quot; + strLeft;
+		final String param3 = &quot;\&quot;},\&quot;ut\&quot;:\&quot;&quot;;
+		final String param4 = &quot;\&quot;}}&quot;;
+		final String postData = param1 + param2 + param3 + userToken + param4;
+
 		try {
 			UrlFetcher.setpostData(postData);
 			UrlFetcher.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
-			ret=UrlFetcher.fetch(url);			
+			ret = UrlFetcher.fetch(url);
 
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			ret = &quot;&quot;;
 			pref.log(&quot;[SpiderGC:getMapListPage] Error getting map Cachepage&quot; + url + postData, ex);
 		}
 		return ret;
- 	}
+	}
 
+	/* */
+	public void doItQuickFillFromMapList() {
+
+		final CWPoint origin = pref.getCurCentrePt();
+		if (!origin.isValid()) {
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
+			return; //
+		}
+		if (!doDownloadGui(2))
+			return;
+
+		Vm.showWait(true);
+		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(1609, &quot;getting the caches.&quot;));
+		infB.exec();
+
+		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
+			final CacheHolder ch = cacheDB.get(i);
+			if (ch.mainCache == null)
+				ch.initStates(false);
+		}
+
+		double halfSideLength = maxDistance; // halbe Seitenl&#228;nge eines Quadrats ums Zentrum in km
+		if (pref.metricSystem == Metrics.IMPERIAL) {
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
+		}
+
+		if (!loggedIn || pref.forceLogin) {
+			if (login() != FormBase.IDOK)
+				return;
+		}
+
+		page_number = 0;
+		num_added = 0;
+
+		final Area sq = getSquare(origin, halfSideLength);
+
+		getCachesNewMap(sq, false);
+
+		if (!infB.isClosed)
+			infB.close(0);
+		Vm.showWait(false);
+
+		Global.getProfile().restoreFilter();
+		Global.getProfile().saveIndex(Global.getPref(), true);
+
+	}
+
+	private void getCachesNewMap(Area square, boolean setCachesToLoad) {
+
+		if (userToken.equals(&quot;&quot;)) {
+			String url;
+			String ret;
+			try {
+				page_number++;
+				url = &quot;<A HREF="http://www.geocaching.com/map/beta/default.aspx">http://www.geocaching.com/map/beta/default.aspx</A>&quot; + &quot;?lat=&quot; + square.topleft.getLatDeg(TransformCoordinates.DD) + &quot;&amp;lng=&quot; + square.topleft.getLonDeg(TransformCoordinates.DD) + &quot;&amp;z=15&quot;;
+				ret = UrlFetcher.fetch(url);
+			} catch (final IOException e) {
+				ret = &quot;&quot;;
+			}
+			int i = ret.indexOf(&quot;GSPK.UserSession('&quot;);
+			i = i + 18;
+			int j = ret.indexOf(&quot;'&quot;, i);
+			userToken = ret.substring(i, j);
+			i = ret.indexOf(&quot;sessionToken:'&quot;, i);
+			i = i + 14;
+			j = ret.indexOf(&quot;'&quot;, i);
+			sessionToken = ret.substring(i, j);
+		}
+		TrackPoint tl;
+		TrackPoint br;
+		int lonmin;
+		int lonmax;
+		int latmin;
+		int latmax;
+		int scale = 19;
+		do {
+			scale = scale - 1;
+			tl = getKachelLatLon(square.topleft, scale);
+			br = getKachelLatLon(square.bottomright, scale);
+			lonmin = (int) tl.lonDec;
+			lonmax = (int) br.lonDec;
+			latmin = (int) tl.latDec;
+			latmax = (int) br.latDec;
+		} while ((lonmax - lonmin &gt; 1) &amp;&amp; (latmax - latmin &gt; 1) &amp;&amp; (scale &gt; 16));
+
+		String cachelist;
+
+		for (int i = lonmin; i &lt;= lonmax; i++) {
+			for (int j = latmin; j &lt;= latmax; j++) {
+				cachelist = getNewMapListPage(&quot;&quot; + j, &quot;&quot; + i, scale);
+				if (cachelist.length() &gt; 0) {
+					final String[] caches = mString.split(cachelist, '{');
+					final double baseX = Common.parseDouble(caches[1].substring(8, caches[1].indexOf(',')));
+					final double baseY = Common.parseDouble(caches[1].substring(caches[1].indexOf(',') + 1, caches[1].indexOf(']')));
+					for (int k = 2; k &lt; caches.length; k++) {
+						final String[] cacheInfos = mString.split(STRreplace.replace(caches[k], &quot;\\\&quot;&quot;, &quot;&quot;), '\&quot;');
+						final String cacheID = cacheInfos[3];
+						final String cacheXY = cacheInfos[10];
+						final String[] xy = mString.split(cacheXY, ',');
+						final int cacheX = Common.parseInt(xy[0].substring(2));
+						final int cacheY = Common.parseInt(xy[1].substring(0, xy[1].indexOf(']')));
+						final CWPoint p = getLatLon(baseX, baseY, cacheX, cacheY, scale);
+						if (square.isInBound(p)) {
+							String cachePage = getCacheInfoNewMap(cacheID);
+							addCacheNewMap(cachePage, p, setCachesToLoad);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	private TrackPoint getKachelLatLon(CWPoint p, int scale) {
+		double lat = p.latDec;
+		double lon = p.lonDec;
+		if (lon &gt; 180.0) {
+			lon -= 360.0;
+		}
+		lat = 0.5 - Math.log(Math.tan((Math.PI / 4.0) + ((Math.PI * lat) / (2.0 * 180.0)))) / (2.0 * Math.PI);
+		lon = (180.0 + lon) / 360.0;
+
+		final int f = 1 &lt;&lt; scale; // 2**scale
+		lat = lat * f;
+		lon = lon * f;
+		return new TrackPoint(lat, lon); // TrackPoint only for returning values
+	}
+
+	private CWPoint getLatLon(double basex, double basey, int offsetx, int offsety, int scale) {
+
+		double anzPixelX = basex + offsetx;
+		double anzPixelY = basey + offsety;
+
+		final CWPoint p = new CWPoint();
+
+		final double maxPixels = 1 &lt;&lt; (scale + 8); // 2**scale*256
+		final double gpp = 360.0 / maxPixels; // Grad pro Pixel
+		final double leftLon = (anzPixelX * gpp); // Grad
+		p.lonDec = leftLon - 180.0; // 0 ist bei greenwich
+
+		final double lat = 1.0 / maxPixels;
+		final double latM = Math.PI * (1.0 + 2.0 * anzPixelY * lat);
+		p.latDec = (180.0 / Math.PI) * ((2.0 * Math.atan(Math.exp(latM))) - (Math.PI / 2.0));
+
+		return p;
+	}
+
+	private String getNewMapListPage(String strLat, String strLon, int scale) {
+		String ret;
+		String url = &quot;&quot;;
+
+		try {
+			page_number++;
+			url = &quot;<A HREF="http://www.geocaching.com/map/beta/map.info?">http://www.geocaching.com/map/beta/map.info?</A>&quot; + &quot;x=&quot; + strLon + &quot;&amp;y=&quot; + strLat + &quot;&amp;z=&quot; + scale + &quot;&amp;k=&quot; + userToken + &quot;&amp;st=&quot; + sessionToken + &quot;&amp;ep=1&quot;;
+			UrlFetcher.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = &quot;&quot;;
+			pref.log(&quot;[SpiderGC:getMapListPage] Error getting map Cachepage&quot; + url + ex);
+		}
+		return ret;
+	}
+
+	private String getCacheInfoNewMap(String cacheID) {
+		String ret;
+		String url = &quot;&quot;;
+
+		try {
+			page_number++;
+			url = &quot;<A HREF="http://www.geocaching.com/map/beta/map.details?">http://www.geocaching.com/map/beta/map.details?</A>&quot; + &quot;wptid=&quot; + cacheID + &quot;&amp;k=&quot; + userToken + &quot;&amp;st=&quot; + sessionToken + &quot;&amp;ep=1&quot;;
+			UrlFetcher.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = &quot;&quot;;
+			pref.log(&quot;[SpiderGC:getCacheInfoNewMap] Error getting map Cachepage&quot; + url + ex);
+		}
+		return ret;
+	}
+
+	private void addCacheNewMap(String page, CWPoint p, boolean setCachesToLoad) {
+
+		final int WpIndex = page.indexOf(&quot;\&quot;gc\&quot;:&quot;);
+		final String[] elements = mString.split(page.substring(WpIndex), '\&quot;');
+
+		final int posWP = 3; // gc
+		final int posDisabled = 6; // disabled
+		final int posDiff = 10; // difficulty
+		final int posTerr = 18; // terrain
+		final int posHidden = 25; // hidden date
+		final int posSize = 31; // size
+		final int posType = 44; // type
+		final int posOwner = 49; // owner
+		final int posGUID = 53; // guid
+
+		// final boolean found = (elements[posFound].indexOf(&quot;true&quot;) &gt; -1 ? true
+		// : false);
+		// if (found &amp;&amp; doNotgetFound) return;
+
+		final byte cacheType = CacheType.gcSpider2CwType(elements[posType].substring(1, elements[posType].length() - 2));
+		if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
+			if (restrictedCacheType != cacheType)
+				return;
+		}
+
+		String wp = elements[posWP];
+		CacheHolder ch = cacheDB.get(wp);
+		if (ch == null) {
+
+			ch = new CacheHolder();
+			ch.setWayPoint(wp);
+			ch.pos = p;
+			final String owner = elements[posOwner];
+			ch.setCacheOwner(owner);
+			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
+			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
+				ch.setOwned(true);
+			} else {
+				if (false) {
+					ch.setFound(true);
+					ch.setCacheStatus(ch.getFoundText());
+				}
+			}
+
+			final int NameIndex = page.indexOf(&quot;\&quot;name\&quot;:\&quot;&quot;);
+			String cacheName = page.substring(NameIndex + 8, WpIndex - 2);
+			cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
+			ch.setCacheName(cacheName);
+			ch.setAvailable((elements[posDisabled].indexOf(&quot;true&quot;) &gt; -1 ? false : true));
+			ch.setDateHidden(DateFormat.MDY2YMD(elements[posHidden]));
+			ch.setHard(CacheTerrDiff.v1Converter(elements[posDiff].substring(1, elements[posDiff].length() - 1)));
+			ch.setTerrain(CacheTerrDiff.v1Converter(elements[posTerr].substring(1, elements[posTerr].length() - 1)));
+			ch.setCacheSize(CacheSize.gcGpxString2Cw(elements[posSize]));
+			ch.setType(cacheType);
+			num_added++;
+			cacheDB.add(ch);
+			if (setCachesToLoad) {
+				cachesToLoad.add(wp + &quot;found&quot;);
+			} else {
+				ch.getCacheDetails(false).URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + wp;
+				ch.save();
+			}
+			if (Global.mainTab.statBar != null)
+				Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot; + page_number + &quot; Caches added to CW: &quot; + num_added);
+		} else {
+		}
+	}
+
 	/**
 	 * check if new Update exists
 	 * 
@@ -1573,7 +1784,7 @@
 		boolean save = false;
 		boolean is_archived_GC = false;
 		boolean is_found_GC = false;
-		CacheHolderDetail chd = ch.getCacheDetails(false);
+		final CacheHolderDetail chd = ch.getCacheDetails(false);
 		if (spiderAllFinds) {
 			if (!ch.is_found()) {
 				ch.setFound(true);
@@ -1599,8 +1810,7 @@
 		if (ch.is_found() &amp;&amp; chd.OwnLogId.equals(&quot;&quot;)) {
 			ret = true;
 		} // missing ownLogID
-		boolean is_available_GC = !is_archived_GC
-				&amp;&amp; CacheDescription.indexOf(propAvailable) == -1;
+		final boolean is_available_GC = !is_archived_GC &amp;&amp; CacheDescription.indexOf(propAvailable) == -1;
 		if (is_available_GC != ch.is_available()) {
 			ch.setAvailable(is_available_GC);
 			save = true;
@@ -1612,9 +1822,9 @@
 			ret = true;
 		}
 		if (pref.checkDTS) {
-			String dts[]=mString.split(getDTS(CacheDescription),'/');
+			final String dts[] = mString.split(getDTS(CacheDescription), '/');
 			if (dts.length == 3) {
-				if (difficultyChanged(ch,  CacheTerrDiff.v1Converter(dts[0]))) {
+				if (difficultyChanged(ch, CacheTerrDiff.v1Converter(dts[0]))) {
 					save = true;
 					ret = true;
 					pref.log(&quot;difficultyChanged&quot;);
@@ -1629,12 +1839,11 @@
 					ret = true;
 					pref.log(&quot;sizeChanged&quot;);
 				}
-			}
-			else {
+			} else {
 				pref.log(&quot;check DTS calculation&quot;, null);
 			}
 		}
-		if (newFoundExists(ch,  CacheDescription)) {
+		if (newFoundExists(ch, CacheDescription)) {
 			numLogUpdates++;
 			ret = true;
 		}
@@ -1658,8 +1867,7 @@
 		if (RexNumFinds.didMatch()) {
 			return Common.parseInt(RexNumFinds.stringMatched(1));
 		} else {
-			pref.log(&quot;check RexNumFinds in SpiderGC.java / initialiseProperties&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check RexNumFinds in SpiderGC.java / initialiseProperties&quot; + Preferences.NEWLINE + doc);
 			return 0;
 		}
 	}
@@ -1676,53 +1884,58 @@
 		}
 		return counter;
 	}
-	
+
 	private String decodeXor(String input, String key) {
-	  byte ctmp[] = input.getBytes();
-		byte ckey[] = key.getBytes();
-		int codeLength = input.length();
-		int keyLength = key.length();
-		for (int i=0; i&lt;codeLength; i++) {
-		  ctmp[i]^=ckey[i%keyLength];
-    }
+		final byte ctmp[] = input.getBytes();
+		final byte ckey[] = key.getBytes();
+		final int codeLength = input.length();
+		final int keyLength = key.length();
+		for (int i = 0; i &lt; codeLength; i++) {
+			ctmp[i] ^= ckey[i % keyLength];
+		}
 		return new String(ctmp);
-  }
+	}
+
 	private double[] getDistanceAndDirection(String doc) {
-		double[] distanceAndDirection={(0.0),(0.0)};
-		if (spiderAllFinds) return distanceAndDirection;
+		final double[] distanceAndDirection = { (0.0), (0.0) };
+		if (spiderAllFinds)
+			return distanceAndDirection;
 		RexPropDistanceCode.search(doc);
 		if (!RexPropDistanceCode.didMatch()) {
 			pref.log(&quot;check distRex&quot; + Preferences.NEWLINE + doc);
-			distanceAndDirection[0]=-1.0; // Abbruch
+			distanceAndDirection[0] = -1.0; // Abbruch
 			return distanceAndDirection;
 		}
-		String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-		String ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
-		RexPropDistance.search(ret); // km oder mi oder ft		
+		final String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+		String ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
+		RexPropDistance.search(ret); // km oder mi oder ft
 		if (!RexPropDistance.didMatch()) {
-			if (ret.indexOf(&quot;ere&quot;) &gt; -1) return distanceAndDirection; // zur Zeit &quot; Here -1&quot;
+			if (ret.indexOf(&quot;ere&quot;) &gt; -1)
+				return distanceAndDirection; // zur Zeit &quot; Here -1&quot;
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
 			// da dieser von gc mal wieder ge&#228;ndert wurde.
-			// todo Ben&#246;tigt ev noch weitere Anpassungen: | am Anfang, and calc of keylength
+			// todo Ben&#246;tigt ev noch weitere Anpassungen: | am Anfang, and calc
+			// of keylength
 
 			// String thereitis=&quot;|0.34 km|102.698&quot;;
-			// String page = fetchText(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1">http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1</A>&quot;,false);
-			String thereitis=&quot;|0.08 km|223.968&quot;;
+			// String page =
+			// fetchText(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1">http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1</A>&quot;,false);
+			final String thereitis = &quot;|0.08 km|223.968&quot;;
 			String page;
 			try {
-				page = UrlFetcher.fetch(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=45.29152&amp;lng=-122.41262&amp;dist=1">http://www.geocaching.com/seek/nearest.aspx?lat=45.29152&amp;lng=-122.41262&amp;dist=1</A>&quot;);
-			} catch (IOException e) {
-				page=&quot;&quot;;
+				page = UrlFetcher.fetch(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=45.292&amp;lng=-122.41262&amp;dist=1">http://www.geocaching.com/seek/nearest.aspx?lat=45.292&amp;lng=-122.41262&amp;dist=1</A>&quot;);
+			} catch (final IOException e) {
+				page = &quot;&quot;;
 			}
-			//  
+			//
 			RexPropListBlock.search(page);
-			String table=&quot;&quot;;
+			String table = &quot;&quot;;
 			if (RexPropListBlock.didMatch()) {
 				table = RexPropListBlock.stringMatched(1);
 			}
-			
+
 			RexPropLine.search(table);
-			String row=&quot;&quot;;
+			String row = &quot;&quot;;
 			if (RexPropLine.didMatch()) {
 				row = RexPropLine.stringMatched(1);
 			}
@@ -1732,11 +1945,12 @@
 				pref.log(&quot;Didn't get DistanceCodeKey automaticly.&quot; + Preferences.NEWLINE);
 				return distanceAndDirection;
 			}
-			String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-			String newkey=decodeXor(coded,thereitis);
-			int keylength=13; // wenn nicht 13 dann newkey auf wiederholung pr&#252;fen
-			DistanceCodeKey=newkey.substring(0, keylength);
-			ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
+			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+			final String newkey = decodeXor(coded, thereitis);
+			final int keylength = 13; // wenn nicht 13 dann newkey auf
+										// wiederholung pr&#252;fen
+			DistanceCodeKey = newkey.substring(0, keylength);
+			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
 			pref.log(&quot;Automatic key: &quot; + DistanceCodeKey + &quot; result: &quot; + ret + Preferences.NEWLINE);
 			RexPropDistance.search(ret); // km oder mi
 		}
@@ -1744,23 +1958,31 @@
 		if (RexPropDistance.didMatch()) {
 			if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1).replace('.', ','));
-				String r = RexPropDistance.right(1).substring(3);  //3 expexts 2 char which are at moment &quot;km&quot; or &quot;mi&quot;
+				final String r = RexPropDistance.right(1).substring(3); // 3
+																		// expexts
+																		// 2
+																		// char
+																		// which
+																		// are
+																		// at
+																		// moment
+																		// &quot;km&quot;
+																		// or
+																		// &quot;mi&quot;
 				distanceAndDirection[1] = Convert.toDouble(r.replace('.', ','));
-			}
-			else {
-				distanceAndDirection[0] =  Convert.toDouble(RexPropDistance.stringMatched(1));
-				String r = RexPropDistance.right(1).substring(3);
+			} else {
+				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1));
+				final String r = RexPropDistance.right(1).substring(3);
 				distanceAndDirection[1] = Convert.toDouble(r);
 			}
-			if (ret.indexOf(&quot;ft&quot;)&gt;0) {
+			if (ret.indexOf(&quot;ft&quot;) &gt; 0) {
 				// Umrechnung in miles
-				distanceAndDirection[0]=distanceAndDirection[0] / 5280.0;				
+				distanceAndDirection[0] = distanceAndDirection[0] / 5280.0;
 			}
-		}
-		else {
+		} else {
 			pref.log(&quot;(gc Code change ?) check distCodeKey in spider.def&quot; + Preferences.NEWLINE + doc);
 		}
-		
+
 		return distanceAndDirection;
 	}
 
@@ -1791,7 +2013,7 @@
 		} else {
 			numPrivate = numPrivate + 1;
 			if (spiderAllFinds) {
-				pref.log(chWaypoint+&quot; is private.&quot;,null);
+				pref.log(chWaypoint + &quot; is private.&quot;, null);
 			}
 			return false;
 		}
@@ -1818,169 +2040,79 @@
 		pref.log(&quot;check TypeRex in spider.def&quot; + Preferences.NEWLINE + toCheck);
 		return false;
 	}
-	
+
 	private String getDTS(String toCheck) {
 		RexPropDTS.search(toCheck);
 		if (RexPropDTS.didMatch()) {
-			String code=RexPropDTS.stringMatched(1);
+			final String code = RexPropDTS.stringMatched(1);
 			/* */
-			String address = &quot;<A HREF="http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=">http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=</A>&quot;+code;
+			final String address = &quot;<A HREF="http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=">http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=</A>&quot; + code;
 			ByteArray doc;
 			try {
 				doc = UrlFetcher.fetchData(address);
-			} catch (IOException e) {
+			} catch (final IOException e) {
 				return &quot;&quot;;
 			}
-			Image idoc = new Image(doc,0,null,0,0);
+			final Image idoc = new Image(doc, 0, null, 0, 0);
 			/*
-			FileOutputStream fos;
-			try {
-				fos = new FileOutputStream(new File(&quot;temp.png&quot;));
-				fos.write(doc.toBytes());
-				fos.close();
-			} catch (IOException e) {
-			}
-			finally {
-			}
-			*/
-			String ret = getDTfromImage(idoc) + &quot;/&quot; + getSizeFromImage(idoc);
-			return ret; 
-			//*/
+			 * FileOutputStream fos; try { fos = new FileOutputStream(new File(&quot;temp.png&quot;)); fos.write(doc.toBytes()); fos.close(); } catch (IOException e) { } finally { }
+			 */
+			final String ret = getDTfromImage(idoc) + &quot;/&quot; + getSizeFromImage(idoc);
+			return ret;
+			// */
 
 			/*
-			int decoded = 0;
-			int pwr = 1;
-			for (int i = code.length()-1 ; i &gt;= 0; i--) {
-				decoded = decoded + DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr;
-				pwr = pwr * 42;
-			}
-			decoded = (decoded - 131586) % 16777216;
-			// size 0=not choosen 1=Micro 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small
-			int sizecode = decoded / 74088; // 42 ^ 3
-			int sizeremove;
-			byte size;
-			switch (sizecode) {
-			case 0: size=CacheSize.CW_SIZE_NOTCHOSEN; sizeremove=0; break;
-			case 1: size=CacheSize.CW_SIZE_MICRO; sizeremove=131072; break;
-			case 3: size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break;
-			case 5: size=CacheSize.CW_SIZE_LARGE; sizeremove=393217; break;
-			case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break;
-			case 8: size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break;
-			case 12: size=CacheSize.CW_SIZE_SMALL; sizeremove=917504; break;
-			default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break;
-			}
-			decoded = decoded - sizeremove;
-			int terraincode = decoded / 252;
-			// terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String terrain = &quot;&quot; + (1 + terraincode / 2.0 ); 
-			// difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String difficulty = &quot;&quot; + (1+((decoded % 42) - (terraincode * 4)) / 2.0);
-			if (difficulty.equals(&quot;0.5&quot;)) {
-				difficulty = &quot;5&quot;;
-			}
-			return difficulty+&quot;/&quot;+terrain+&quot;/&quot;+size;
-			*/
+			 * int decoded = 0; int pwr = 1; for (int i = code.length()-1 ; i &gt;= 0; i--) { decoded = decoded + DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr; pwr = pwr * 42; } decoded = (decoded - 1386) % 16777216; // size 0=not choosen 1=Micro
+			 * 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small int sizecode = decoded / 74088; // 42 ^ 3 int sizeremove; byte size; switch (sizecode) { case 0: size=CacheSize.CW_SIZE_NOTCHOSEN; sizeremove=0; break; case 1: size=CacheSize.CW_SIZE_MICRO;
+			 * sizeremove=131072; break; case 3: size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break; case 5: size=CacheSize.CW_SIZE_LARGE; sizeremove=393217; break; case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break; case 8:
+			 * size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break; case 12: size=CacheSize.CW_SIZE_SMALL; sizeremove=917504; break; default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break; } decoded = decoded - sizeremove; int terraincode =
+			 * decoded / 252; // terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5 String terrain = &quot;&quot; + (1 + terraincode / 2.0 ); // difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5 String difficulty = &quot;&quot; + (1+((decoded % 42) - (terraincode *
+			 * 4)) / 2.0); if (difficulty.equals(&quot;0.5&quot;)) { difficulty = &quot;5&quot;; } return difficulty+&quot;/&quot;+terrain+&quot;/&quot;+size;
+			 */
 		}
 		pref.log(&quot;check DTSRex in spider.def&quot; + Preferences.NEWLINE + toCheck);
 		return &quot;&quot;;
 	}
 
 	static Hashtable validChars = new Hashtable();
-	
+
 	static {
-		validChars.put(&quot;.&quot;, new int[][] {
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 1, 0 },
-				{0, 1, 0 }
-		});
-		validChars.put(&quot;/&quot;, new int[][] {
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0}
-		});
-		validChars.put(&quot;1&quot;, new int[][] {
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put(&quot;2&quot;, new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put(&quot;3&quot;, new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
-		validChars.put(&quot;4&quot;, new int[][] {
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 1, 0},
-				{0, 0, 1, 0, 1, 0},
-				{0, 1, 0, 0, 1, 0},
-				{1, 0, 0, 0, 1, 0},
-				{1, 1, 1, 1, 1, 1},
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 0, 1, 0}
-		});
-		validChars.put(&quot;5&quot;, new int[][] {
-				{1, 1, 1, 1, 1},
-				{1, 0, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
+		validChars.put(&quot;.&quot;, new int[][] { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 1, 0 }, { 0, 1, 0 } });
+		validChars.put(&quot;/&quot;, new int[][] { { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 } });
+		validChars.put(&quot;1&quot;, new int[][] { { 0, 0, 1, 0, 0 }, { 1, 1, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put(&quot;2&quot;, new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put(&quot;3&quot;, new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
+		validChars.put(&quot;4&quot;, new int[][] { { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 1, 0 }, { 0, 0, 1, 0, 1, 0 }, { 0, 1, 0, 0, 1, 0 }, { 1, 0, 0, 0, 1, 0 }, { 1, 1, 1, 1, 1, 1 }, { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 0, 1, 0 } });
+		validChars.put(&quot;5&quot;, new int[][] { { 1, 1, 1, 1, 1 }, { 1, 0, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
 	}
 
 	private static byte getSizeFromImage(Image bild) {
 		int[] argb = bild.getPixels(null, 0, 5, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_MICRO;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_MICRO;
 		argb = bild.getPixels(null, 0, 10, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_SMALL;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_SMALL;
 		argb = bild.getPixels(null, 0, 17, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_REGULAR;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_REGULAR;
 		argb = bild.getPixels(null, 0, 26, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_LARGE;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_LARGE;
 		argb = bild.getPixels(null, 0, 40, 23, 1, 1, 0);
-		if (argb[0] == -6735302) return CacheSize.CW_SIZE_NOTCHOSEN;
+		if (argb[0] == -6735302)
+			return CacheSize.CW_SIZE_NOTCHOSEN;
 		argb = bild.getPixels(null, 0, 41, 24, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_OTHER;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_OTHER;
 		return CacheSize.CW_SIZE_ERROR;
 	}
 
 	private static String getDTfromImage(Image bild) {
-		StringBuffer sb = new StringBuffer();
+		final StringBuffer sb = new StringBuffer();
 		for (int startX = 0; startX &lt; bild.getWidth(); startX++) {
-			for (Enumeration e = validChars.keys(); e.hasMoreElements();) {
-				String key=(String) e.nextElement();
+			for (final Enumeration e = validChars.keys(); e.hasMoreElements();) {
+				final String key = (String) e.nextElement();
 				if (testValidChar(bild, startX, 4, (int[][]) validChars.get(key))) {
 					sb.append(key);
 				}
@@ -1991,17 +2123,18 @@
 
 	private static boolean testValidChar(Image bild, int startX, int startY, int[][] validChar) {
 		for (int y = 0; y &lt; validChar.length; y++) {
-			if (bild.getHeight() &gt; startY+y) {
+			if (bild.getHeight() &gt; startY + y) {
 				for (int x = 0; x &lt; validChar[0].length; x++) {
-					if (bild.getWidth() &gt; startX+x) {
-						// int[] alpha = bild.getAlphaRaster().getPixel(startX+x, startY+y, new int[1]);
-						int[] argb = bild.getPixels(null, 0, startX+x, startY+y, 1, 1, 0);
-						if ((argb[0] == 0 &amp;&amp; validChar[y][x] == 0) ||
-								(argb[0] != 0 &amp;&amp; validChar[y][x] &gt; 0)) {
+					if (bild.getWidth() &gt; startX + x) {
+						// int[] alpha =
+						// bild.getAlphaRaster().getPixel(startX+x, startY+y,
+						// new int[1]);
+						final int[] argb = bild.getPixels(null, 0, startX + x, startY + y, 1, 1, 0);
+						if ((argb[0] == 0 &amp;&amp; validChar[y][x] == 0) || (argb[0] != 0 &amp;&amp; validChar[y][x] &gt; 0)) {
 							// matches
 						} else {
 							return false;
-						} 
+						}
 					} else {
 						return false;
 					}
@@ -2024,6 +2157,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed Terrain
 	 */
@@ -2035,6 +2169,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed CacheSize
 	 */
@@ -2053,18 +2188,21 @@
 	private boolean directionOK(String[] directions, double toCheck) {
 		if (directions == null || directions.length == 0)
 			return true; // nothing means all
-		int lowerLimit = Common.parseInt(directions[0]);
-		int upperLimit = Common.parseInt(directions[1]);
+		final int lowerLimit = Common.parseInt(directions[0]);
+		final int upperLimit = Common.parseInt(directions[1]);
 		if (lowerLimit &lt;= upperLimit) {
-			if ((toCheck&gt;=lowerLimit) &amp;&amp; (toCheck&lt;=upperLimit))
-			{return true;}
-			else {return false;}
+			if ((toCheck &gt;= lowerLimit) &amp;&amp; (toCheck &lt;= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
+		} else {
+			if ((toCheck &gt;= lowerLimit) || (toCheck &lt;= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
 		}
-		else {
-			if ((toCheck&gt;=lowerLimit) || (toCheck&lt;=upperLimit))
-			{return true;}
-			else {return false;}
-		}
 	}
 
 	/*
@@ -2075,18 +2213,18 @@
 	 * @return boolean newLogExists
 	 */
 	private boolean newFoundExists(CacheHolder ch, String cacheDescription) {
-		if (!pref.checkLog || pref.maxLogsToSpider==0)
+		if (!pref.checkLog || pref.maxLogsToSpider == 0)
 			return false;
-		Time lastLogCW = new Time();
-		Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
+		final Time lastLogCW = new Time();
+		final Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
 		if (lastLog == null)
 			return true;
-		String slastLogCW = lastLog.getDate();
+		final String slastLogCW = lastLog.getDate();
 		if (slastLogCW.equals(&quot;&quot;) || slastLogCW.equals(&quot;1900-00-00&quot;))
 			return true; // or check cacheDescGC also no log?
 		lastLogCW.parse(slastLogCW, &quot;yyyy-MM-dd&quot;);
 
-		Time lastLogGC = new Time(); // is current time
+		final Time lastLogGC = new Time(); // is current time
 		lastLogGC.hour = 0;
 		lastLogGC.minute = 0;
 		lastLogGC.second = 0;
@@ -2102,13 +2240,11 @@
 		}
 		if (stmp.indexOf(&quot;day&quot;) &gt; 0) {
 			// simplyfied (update if not newer than last week)
-			lastLogGC.setTime(lastLogGC.getTime() - 691200000L); 
+			lastLogGC.setTime(lastLogGC.getTime() - 691200000L);
 		} else if (stmp.equals(&quot;&quot;)) {
 			return false; // no log yet
 		} else {
-			final String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;,
-					&quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;,
-					&quot;October&quot;, &quot;November&quot;, &quot;December&quot; };
+			final String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };
 			SDate = mString.split(stmp, ' ');
 			lastLogGC.day = Common.parseInt(SDate[0]);
 			for (int m = 0; m &lt; 12; m++) {
@@ -2119,57 +2255,44 @@
 			}
 			lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
 		}
-		boolean ret = lastLogCW.compareTo(lastLogGC) &lt; 0;
+		final boolean ret = lastLogCW.compareTo(lastLogGC) &lt; 0;
 		return ret;
 	}
+
 	private boolean TBchanged(CacheHolder ch, String cacheDescription) {
-		// simplified Version: only presence is checked 
-		if (pref.downloadTBs &amp;&amp; pref.checkTBs ) {
-			boolean hasTB=cacheDescription.indexOf(&quot;data-tbcount&quot;) &gt; -1;
+		// simplified Version: only presence is checked
+		if (pref.downloadTBs &amp;&amp; pref.checkTBs) {
+			final boolean hasTB = cacheDescription.indexOf(&quot;data-tbcount&quot;) &gt; -1;
 			return ch.has_bugs() != (hasTB);
 		}
 		return false;
 	}
 
 	/**
-	 * Read a complete cachepage from geocaching.com including all logs. This is
-	 * used both when updating already existing caches (via spiderSingle) and
-	 * when spidering around a centre. It is also used when reading a GPX file
-	 * and fetching the images.
+	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file and fetching the images.
 	 * 
 	 * This is the workhorse function of the spider.
 	 * 
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
-	 * @param boolean isUpdate True if an existing cache is being updated, false
-	 *        if it is a new cache
+	 * @param boolean isUpdate True if an existing cache is being updated, false if it is a new cache
 	 * @param boolean fetchImages True if the pictures are to be fetched
 	 * @param boolean fetchTBs True if the TBs are to be fetched
-	 * @param boolean doNotGetFound True if the cache is not to be spidered if
-	 *        it has already been found
-	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding
-	 *        option '&amp;logs=y' to command line). This is normally false when
-	 *        spidering from GPXImport as the logs are part of the GPX file, and
-	 *        true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was
-	 *         an error (continue with next cache), 1 if everything ok
+	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
+	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line). This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
 	 */
-	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate,
-			boolean fetchImages, boolean fetchTBs, boolean doNotGetFound,
-			boolean fetchAllLogs) {
+	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean fetchTBs, boolean doNotGetFound, boolean fetchAllLogs) {
 		int ret = SPIDER_OK; // initialize value;
 		while (true) { // retry even if failure
 			pref.log(&quot;&quot;); // new line for more overview
 			String completeWebPage;
 			int spiderTrys = 0;
-			int MAX_SPIDER_TRYS = 3;
+			final int MAX_SPIDER_TRYS = 3;
 			while (spiderTrys++ &lt; MAX_SPIDER_TRYS) {
 				ret = SPIDER_OK; // initialize value;
 				try {
-					String doc = p.getProp(&quot;getPageByName&quot;)
-							+ ch.getWayPoint()
-							+ ((fetchAllLogs || ch.is_found()) ? p
-									.getProp(&quot;fetchAllLogs&quot;) : &quot;&quot;);
+					final String doc = p.getProp(&quot;getPageByName&quot;) + ch.getWayPoint() + ((fetchAllLogs || ch.is_found()) ? p.getProp(&quot;fetchAllLogs&quot;) : &quot;&quot;);
 					completeWebPage = UrlFetcher.fetch(doc);
 					pref.log(&quot;Fetched: &quot; + ch.getWayPoint());
 					if (completeWebPage.equals(&quot;&quot;)) {
@@ -2181,7 +2304,7 @@
 							return SPIDER_CANCEL;
 						}
 					}
-				} catch (Exception ex) {
+				} catch (final Exception ex) {
 					pref.log(&quot;Could not fetch &quot; + ch.getWayPoint(), ex);
 					if (!infB.isClosed) {
 						continue;
@@ -2198,7 +2321,7 @@
 
 						// first check if coordinates are available to prevent
 						// deleting existing coordinates
-						String latLon = getLatLon(completeWebPage);
+						final String latLon = getLatLon(completeWebPage);
 						if (latLon.equals(&quot;???&quot;)) {
 							if (completeWebPage.indexOf(p.getProp(&quot;premiumCachepage&quot;)) &gt; 0) {
 								// Premium cache spidered by non premium member
@@ -2223,10 +2346,8 @@
 						ch.addiWpts.clear();
 						ch.getCacheDetails(false).images.clear();
 
-						ch.setAvailable(!(completeWebPage.indexOf(p
-								.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0));
-						ch.setArchived(completeWebPage.indexOf(p
-								.getProp(&quot;cacheArchived&quot;)) &gt;= 0);
+						ch.setAvailable(!(completeWebPage.indexOf(p.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0));
+						ch.setArchived(completeWebPage.indexOf(p.getProp(&quot;cacheArchived&quot;)) &gt;= 0);
 						// ==========
 						// Logs first (for check early for break)
 						// ==========
@@ -2247,27 +2368,21 @@
 						ch.setLatLon(latLon);
 						pref.log(&quot;LatLon: &quot; + ch.getLatLon());
 
-						String longDesc = getLongDesc(completeWebPage);
+						final String longDesc = getLongDesc(completeWebPage);
 						ch.getCacheDetails(false).setLongDescription(longDesc);
 						pref.log(&quot;Got description&quot;);
 
-						ch.setCacheName(SafeXML
-								.cleanback(getName(completeWebPage)));
+						ch.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
 						pref.log(&quot;Name: &quot; + ch.getCacheName());
 
-						String location = getLocation(completeWebPage);
+						final String location = getLocation(completeWebPage);
 						if (location.length() != 0) {
-							int countryStart = location.indexOf(&quot;,&quot;);
+							final int countryStart = location.indexOf(&quot;,&quot;);
 							if (countryStart &gt; -1) {
-								ch.getCacheDetails(false).Country = SafeXML
-										.cleanback(location.substring(
-												countryStart + 1).trim());
-								ch.getCacheDetails(false).State = SafeXML
-										.cleanback(location.substring(0,
-												countryStart).trim());
+								ch.getCacheDetails(false).Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
+								ch.getCacheDetails(false).State = SafeXML.cleanback(location.substring(0, countryStart).trim());
 							} else {
-								ch.getCacheDetails(false).Country = location
-										.trim();
+								ch.getCacheDetails(false).Country = location.trim();
 								ch.getCacheDetails(false).State = &quot;&quot;;
 							}
 							pref.log(&quot;Got location (country/state)&quot;);
@@ -2279,31 +2394,23 @@
 						String owner = getOwner(completeWebPage);
 						owner = SafeXML.cleanback(owner).trim();
 						ch.setCacheOwner(owner);
-						if (ch.getCacheOwner().equals(pref.myAlias)
-							|| (pref.myAlias2.length() &gt; 0 &amp;&amp; ch.getCacheOwner().equals(pref.myAlias2)))
+						if (ch.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length() &gt; 0 &amp;&amp; ch.getCacheOwner().equals(pref.myAlias2)))
 							ch.setOwned(true);
-						pref.log(&quot;Owner: &quot; + ch.getCacheOwner()
-								+ &quot;; is_owned = &quot; + ch.is_owned()
-								+ &quot;;  alias1,2 = [&quot; + pref.myAlias + &quot;|&quot;
-								+ pref.myAlias2 + &quot;]&quot;);
+						pref.log(&quot;Owner: &quot; + ch.getCacheOwner() + &quot;; is_owned = &quot; + ch.is_owned() + &quot;;  alias1,2 = [&quot; + pref.myAlias + &quot;|&quot; + pref.myAlias2 + &quot;]&quot;);
 
-						ch.setDateHidden(DateFormat
-								.MDY2YMD(getDateHidden(completeWebPage)));
+						ch.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
 						pref.log(&quot;Hidden: &quot; + ch.getDateHidden());
 
-						ch.getCacheDetails(false).setHints(
-								getHints(completeWebPage));
+						ch.getCacheDetails(false).setHints(getHints(completeWebPage));
 						pref.log(&quot;Hints: &quot; + ch.getCacheDetails(false).Hints);
 
-						ch.setCacheSize(CacheSize
-								.gcSpiderString2Cw(getSize(completeWebPage)));
+						ch.setCacheSize(CacheSize.gcSpiderString2Cw(getSize(completeWebPage)));
 						pref.log(&quot;Size: &quot; + ch.getCacheSize());
 
 						ch.setHard(CacheTerrDiff.v1Converter(getDiff(completeWebPage)));
 						pref.log(&quot;Hard: &quot; + ch.getHard());
 
-						ch.setTerrain(CacheTerrDiff
-								.v1Converter(getTerr(completeWebPage)));
+						ch.setTerrain(CacheTerrDiff.v1Converter(getTerr(completeWebPage)));
 						pref.log(&quot;Terr: &quot; + ch.getTerrain());
 
 						ch.setType(getType(completeWebPage));
@@ -2313,27 +2420,24 @@
 						// ==========
 						if (fetchTBs)
 							getBugs(ch.getCacheDetails(false), completeWebPage);
-						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs
-								.size() &gt; 0);
+						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs.size() &gt; 0);
 						pref.log(&quot;Got TBs&quot;);
 						// ==========
 						// Images
 						// ==========
 						if (fetchImages) {
-							getImages(completeWebPage, ch.getCacheDetails(false),true);
+							getImages(completeWebPage, ch.getCacheDetails(false), true);
 							pref.log(&quot;Got images&quot;);
 						}
 						// ==========
 						// Addi waypoints
 						// ==========
-						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch
-								.is_found());
+						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch.is_found());
 						pref.log(&quot;Got additional waypoints&quot;);
 						// ==========
 						// Attributes
 						// ==========
-						getAttributes(completeWebPage, ch
-								.getCacheDetails(false));
+						getAttributes(completeWebPage, ch.getCacheDetails(false));
 						pref.log(&quot;Got attributes&quot;);
 						// ==========
 						// Last sync date
@@ -2342,7 +2446,7 @@
 						ch.setIncomplete(false);
 						pref.log(&quot;ready &quot; + ch.getWayPoint() + &quot; : &quot; + ch.getLastSync());
 						break;
-					} catch (Exception ex) {
+					} catch (final Exception ex) {
 						pref.log(&quot;[getCacheByWaypointName: ]Error reading cache: &quot; + ch.getWayPoint(), ex);
 					}
 				} else {
@@ -2351,10 +2455,7 @@
 			} // spiderTrys
 			if ((spiderTrys &gt;= MAX_SPIDER_TRYS) &amp;&amp; (ret == SPIDER_OK)) {
 				pref.log(&quot;&gt;&gt;&gt; Failed to spider cache. Number of retrys exhausted.&quot;, null);
-				int decision = (new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(5515,&quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;),
-						FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB))
-						.execute();
+				final int decision = (new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(55, &quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;), FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB)).execute();
 				if (decision == FormBase.IDOK) {
 					continue; // retry even if failure
 				} else if (decision == FormBase.IDNO) {
@@ -2380,11 +2481,10 @@
 	 * @return Cache coordinates
 	 */
 	private String getLatLon(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check latLonRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check latLonRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2401,13 +2501,13 @@
 	 */
 	private String getLongDesc(String doc) throws Exception {
 		String res = &quot;&quot;;
-		Regex shortDescRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
-		Regex longDescRex = new Regex(p.getProp(&quot;longDescRex&quot;));
+		final Regex shortDescRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
+		final Regex longDescRex = new Regex(p.getProp(&quot;longDescRex&quot;));
 		shortDescRex.search(doc);
 		if (!shortDescRex.didMatch()) {
 			if (shortDescRex_not_yet_found)
 				pref.log(&quot;no shortDesc or check shortDescRex in spider.def&quot;);
-				//		+ Preferences.NEWLINE + doc);
+			// + Preferences.NEWLINE + doc);
 		} else {
 			res = shortDescRex.stringMatched(1);
 			shortDescRex_not_yet_found = false;
@@ -2415,12 +2515,11 @@
 		res += &quot;&lt;br&gt;&quot;;
 		longDescRex.search(doc);
 		if (!longDescRex.didMatch()) {
-			pref.log(&quot;check longDescRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check longDescRex in spider.def&quot; + Preferences.NEWLINE + doc);
 		} else {
 			res += longDescRex.stringMatched(1);
 		}
-		int spanEnd = res.lastIndexOf(&quot;&lt;/span&gt;&quot;);
+		final int spanEnd = res.lastIndexOf(&quot;&lt;/span&gt;&quot;);
 		if (spanEnd &gt;= 0) {
 			res = res.substring(0, spanEnd);
 		}
@@ -2437,11 +2536,10 @@
 	 * @return the location (country and state) of the cache
 	 */
 	private String getLocation(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;cacheLocationRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;cacheLocationRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check cacheLocationRex in spider.def&quot;
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check cacheLocationRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2455,11 +2553,10 @@
 	 * @return the name of the cache
 	 */
 	private String getName(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check cacheNameRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check cacheNameRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2473,11 +2570,10 @@
 	 * @return the cache owner
 	 */
 	private String getOwner(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check cacheOwnerRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check cacheOwnerRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2491,11 +2587,10 @@
 	 * @return Hidden date
 	 */
 	private String getDateHidden(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check dateHiddenRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check dateHiddenRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2509,11 +2604,10 @@
 	 * @return Cachehints
 	 */
 	private String getHints(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check hintsRex in spider.def&quot;
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check hintsRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2527,13 +2621,12 @@
 	 * @return Cache size
 	 */
 	private String getSize(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log(&quot;check sizeRex in spider.def&quot;
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check sizeRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;None&quot;;
 		}
 	}
@@ -2546,13 +2639,12 @@
 	 * @return The cache difficulty
 	 */
 	private String getDiff(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log(&quot;check difficultyRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check difficultyRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;-1&quot;;
 		}
 	}
@@ -2565,13 +2657,12 @@
 	 * @return Terrain rating
 	 */
 	private String getTerr(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log(&quot;check terrainRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check terrainRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return &quot;-1&quot;;
 		}
 	}
@@ -2588,8 +2679,7 @@
 		if (RexCacheType.didMatch())
 			return CacheType.gcSpider2CwType(RexCacheType.stringMatched(1));
 		else {
-			pref.log(&quot;check cacheTypeRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;check cacheTypeRex in spider.def&quot; + Preferences.NEWLINE + doc);
 			return 0;
 		}
 	}
@@ -2603,19 +2693,18 @@
 	 *            Cache Details
 	 * @return A HTML string containing the logs
 	 */
-	private void getLogs(String completeWebPage, CacheHolderDetail chD)
-			throws Exception {
+	private void getLogs(String completeWebPage, CacheHolderDetail chD) throws Exception {
 		String icon = &quot;&quot;;
 		String name = &quot;&quot;;
 		String logText = &quot;&quot;;
 		String logId = &quot;&quot;;
 		String singleLog = &quot;&quot;;
-		LogList reslts = chD.CacheLogs;
+		final LogList reslts = chD.CacheLogs;
 		RexLogBlock.search(completeWebPage);
 		if (!RexLogBlock.didMatch()) {
 			pref.log(&quot;check blockRex in spider.def&quot; + Preferences.NEWLINE + completeWebPage);
 		}
-		String LogBlock = RexLogBlock.stringMatched(1);
+		final String LogBlock = RexLogBlock.stringMatched(1);
 		exSingleLog.setSource(LogBlock);
 		singleLog = exSingleLog.findNext();
 		exIcon.setSource(singleLog);
@@ -2630,18 +2719,19 @@
 			// pref.log(singleLog);
 			nLogs++;
 			icon = exIcon.findNext();
-			icon=icon.substring(0, icon.length() - 1); // ' changes to &quot; in UMTS-connection! first char in iconExEnd.
+			icon = icon.substring(0, icon.length() - 1); // ' changes to &quot; in
+															// UMTS-connection!
+															// first char in
+															// iconExEnd.
 			name = exName.findNext();
 			logText = exLog.findNext();
-			logText = correctSmilies (logText);
+			logText = correctSmilies(logText);
 			logId = exLogId.findNext();
-			String ed=exDate.findNext();
-			String d = DateFormat.logdate2YMD(ed);
+			final String ed = exDate.findNext();
+			final String d = DateFormat.logdate2YMD(ed);
 			// pref.log(&quot;Lognr:&quot;+nLogs+&quot;|&quot;+icon+&quot;|&quot;+name+&quot;-|-&quot;+SafeXML.clean(pref.myAlias)+&quot;|&quot;+logId,null);
 			// if this log says this Cache is found by me
-			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended))	&amp;&amp;
-					(name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) ||
-					( pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
+			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) &amp;&amp; (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);
 				chD.getParent().setCacheStatus(d);
 				chD.OwnLogId = logId;
@@ -2674,14 +2764,15 @@
 
 	/**
 	 * This methods cleans up the path for inlined smilies in logtexts.
+	 * 
 	 * @param logText
 	 * @return
 	 */
 	private String correctSmilies(String logText) {
 		int indexOf = logText.indexOf(string);
 		while (indexOf &gt;= 0) {
-			String prefix = logText.substring(0, indexOf);
-			String postFix = logText.substring(indexOf + string.length());
+			final String prefix = logText.substring(0, indexOf);
+			final String postFix = logText.substring(indexOf + string.length());
 			logText = prefix + &quot;&lt;img src=\&quot;&quot; + postFix;
 			indexOf = logText.indexOf(string);
 		}
@@ -2689,59 +2780,41 @@
 	}
 
 	/**
-	 * Read the travelbug names from a previously fetched Cache page and then
-	 * read the travelbug purpose for each travelbug
+	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each travelbug
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
 	 */
 	public void getBugs(CacheHolderDetail chD, String doc) throws Exception {
-		Extractor exBlock = new Extractor(doc, 
-				p.getProp(&quot;blockExStart&quot;), 
-				p.getProp(&quot;blockExEnd&quot;), 
-				0, Extractor.EXCLUDESTARTEND);
-		String bugBlock = exBlock.findNext();
-		Extractor exBug = new Extractor(bugBlock, 
-				p.getProp(&quot;bugExStart&quot;), 
-				p.getProp(&quot;bugExEnd&quot;), 
-				0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBlock = new Extractor(doc, p.getProp(&quot;blockExStart&quot;), p.getProp(&quot;blockExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
+		final String bugBlock = exBlock.findNext();
+		final Extractor exBug = new Extractor(bugBlock, p.getProp(&quot;bugExStart&quot;), p.getProp(&quot;bugExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 		String link, bug, linkPlusBug, bugDetails;
-		String oldInfoBox = infB.getInfo();
+		final String oldInfoBox = infB.getInfo();
 		chD.Travelbugs.clear();
 		while (!exBug.endOfSearch()) {
 			if (infB.isClosed)
 				break; // Allow user to cancel by closing progress form
 			linkPlusBug = exBug.findNext();
-			int idx = linkPlusBug.indexOf(p.getProp(&quot;bugLinkEnd&quot;));
+			final int idx = linkPlusBug.indexOf(p.getProp(&quot;bugLinkEnd&quot;));
 			if (idx &lt; 0)
 				break; // No link/bug pair found
 			link = linkPlusBug.substring(0, idx);
-			Extractor exBugName = new Extractor(linkPlusBug, 
-					p.getProp(&quot;bugNameExStart&quot;), 
-					p.getProp(&quot;bugNameExEnd&quot;), 
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exBugName = new Extractor(linkPlusBug, p.getProp(&quot;bugNameExStart&quot;), p.getProp(&quot;bugNameExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			bug = exBugName.findNext();
 			if (bug.length() &gt; 0) { // Found a bug, get its details
-				Travelbug tb = new Travelbug(bug);
+				final Travelbug tb = new Travelbug(bug);
 				try {
-					infB.setInfo(oldInfoBox
-							+ MyLocale.getMsg(5514, &quot;\nGetting bug: &quot;)
-							+ SafeXML.cleanback(bug));
+					infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, &quot;\nGetting bug: &quot;) + SafeXML.cleanback(bug));
 					bugDetails = UrlFetcher.fetch(link);
 					pref.log(&quot;[getBugs] Fetched TB details: &quot; + bug);
-					Extractor exDetails = new Extractor(bugDetails, p
-							.getProp(&quot;bugDetailsStart&quot;), p
-							.getProp(&quot;bugDetailsEnd&quot;),
-							0, Extractor.EXCLUDESTARTEND);
+					final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 					tb.setMission(exDetails.findNext());
-					Extractor exGuid = new Extractor(bugDetails,
-							&quot;action=\&quot;details.aspx?guid=&quot;,
-							&quot;\&quot; id=\&quot;aspnetForm&quot;,
-							0, Extractor.EXCLUDESTARTEND);
+					final Extractor exGuid = new Extractor(bugDetails, &quot;action=\&quot;details.aspx?guid=&quot;, &quot;\&quot; id=\&quot;aspnetForm&quot;, 0, Extractor.EXCLUDESTARTEND);
 					tb.setGuid(exGuid.findNext());
 					chD.Travelbugs.add(tb);
-				} catch (Exception ex) {
+				} catch (final Exception ex) {
 					pref.log(&quot;[getBugs] Could not fetch bug details&quot;, ex);
 				}
 			}
@@ -2750,9 +2823,7 @@
 	}
 
 	/**
-	 * Get the images for a previously fetched cache page. Images are extracted
-	 * from two areas: The long description and the pictures section (including
-	 * the spoiler)
+	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and the pictures section (including the spoiler)
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
@@ -2763,14 +2834,14 @@
 		int imgCounter = 0;
 		int spiderCounter = 0;
 		String fileName, imgName, imgType, imgUrl, imgComment;
-		Vector spideredUrls = new Vector(15);
+		final Vector spideredUrls = new Vector();
 		ImageInfo imageInfo = null;
 		Extractor exImgBlock, exImgComment;
 		int idxUrl; // Index of already spidered Url in list of spideredUrls
 		CacheImages lastImages = null;
 
 		// First: Get current image object of waypoint before spidering images.
-		CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
+		final CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
 		if (oldCh != null) {
 			lastImages = oldCh.getCacheDetails(false).images;
 		}
@@ -2785,7 +2856,7 @@
 			longDesc = STRreplace.replace(longDesc, &quot;src=&quot;, &quot;SRC=&quot;);
 			longDesc = STRreplace.replace(longDesc, &quot;'&quot;, &quot;\&quot;&quot;);
 			exImgBlock = new Extractor(longDesc, p.getProp(&quot;imgBlockExStart&quot;), p.getProp(&quot;imgBlockExEnd&quot;), 0, false);
-		} catch (Exception ex) {// Missing property in spider.def
+		} catch (final Exception ex) {// Missing property in spider.def
 			return;
 		}
 		String tst;
@@ -2794,27 +2865,22 @@
 		while (exImgBlock.endOfSearch() == false) {
 			imgUrl = exImgSrc.findNext();
 			if (imgUrl.length() &gt; 0) {
-				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for better caching purposes)
+				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
+				// better caching purposes)
 				imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
 				try {
 					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
 					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(&quot;.png&quot;)
-							|| imgType.startsWith(&quot;.jpg&quot;)
-							|| imgType.startsWith(&quot;.gif&quot;)) {
+					if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
 						// Check whether image was already spidered for this
 						// cache
 						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + &quot;_&quot;
-								+ Convert.toString(imgCounter);
+						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
 						imageInfo = null;
 						if (idxUrl &lt; 0) { // New image
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ &quot;_&quot; + Convert.toString(spiderCounter);
+							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
 							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl,
-										fileName + imgType);
+								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
 							}
 							if (imageInfo == null) {
 								imageInfo = new ImageInfo();
@@ -2828,9 +2894,7 @@
 							spideredUrls.add(imgUrl);
 							spiderCounter++;
 						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ &quot;_&quot; + Convert.toString(idxUrl);
+							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
 							pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
 							imageInfo = new ImageInfo();
 							imageInfo.setFilename(fileName + imgType);
@@ -2841,7 +2905,7 @@
 						imgCounter++;
 						chD.images.add(imageInfo);
 					}
-				} catch (IndexOutOfBoundsException e) {
+				} catch (final IndexOutOfBoundsException e) {
 					pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 				}
 			}
@@ -2857,7 +2921,7 @@
 			exImgName = new Extractor(tst, p.getProp(&quot;imgNameExStart&quot;), p.getProp(&quot;imgNameExEnd&quot;), 0, true);
 			exImgSrc = new Extractor(tst, p.getProp(&quot;imgSrcExStart&quot;), p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
 			exImgComment = new Extractor(tst, p.getProp(&quot;imgCommentExStart&quot;), p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			return;
 		}
 		while (!exImgSrc.endOfSearch()) {
@@ -2866,12 +2930,9 @@
 			if (imgUrl.length() &gt; 0) {
 				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
 				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
 					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(&quot;.png&quot;)
-							|| imgType.startsWith(&quot;.jpg&quot;)
-							|| imgType.startsWith(&quot;.gif&quot;)) {
+					if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
 						// Check whether image was already spidered for this
 						// cache
 						idxUrl = spideredUrls.find(imgUrl);
@@ -2908,7 +2969,7 @@
 						imageInfo.setComment(imgComment);
 						chD.images.add(imageInfo);
 					}
-				} catch (IndexOutOfBoundsException e) {
+				} catch (final IndexOutOfBoundsException e) {
 					pref.log(&quot;[getImages] IndexOutOfBoundsException in image span. imgURL:&quot; + imgUrl, e);
 				}
 			}
@@ -2916,23 +2977,21 @@
 		// ========
 		// Final sweep to check for images in hrefs
 		// ========
-		Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		final Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
 		while (!exFinal.endOfSearch()) {
 			imgUrl = exFinal.findNext();
 			if (imgUrl.length() &gt; 0) {
-				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for better caching purposes)
+				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
+				// better caching purposes)
 				imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
 				try {
 					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
 					// imgType is now max 4 chars, starting with . Delete
 					// characters in URL after the image extension
-					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.')
-							+ imgType.length());
-					if (imgType.startsWith(&quot;.jpg&quot;)
-							|| imgType.startsWith(&quot;.bmp&quot;)
-							|| imgType.startsWith(&quot;.png&quot;)
-							|| imgType.startsWith(&quot;.gif&quot;)) {
-						// Check whether image was already spidered for this cache
+					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
+					if (imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+						// Check whether image was already spidered for this
+						// cache
 						idxUrl = spideredUrls.find(imgUrl);
 						if (idxUrl &lt; 0) { // New image
 							imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
@@ -2956,7 +3015,7 @@
 							chD.images.add(imageInfo);
 						}
 					}
-				} catch (IndexOutOfBoundsException e) {
+				} catch (final IndexOutOfBoundsException e) {
 					pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 				}
 			}
@@ -2974,11 +3033,11 @@
 	private void spiderImage(String address, String fn) {
 		try {
 			UrlFetcher.fetchDataFile(address, profile.dataDir + fn);
-		} catch (UnknownHostException e) {
+		} catch (final UnknownHostException e) {
 			pref.log(&quot;[spiderImage] Host not there...&quot;, e);
-		} catch (IOException ioex) {
+		} catch (final IOException ioex) {
 			pref.log(&quot;[spiderImage] File not found!&quot;, ioex);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[spiderImage] Some other problem while fetching image&quot;, ex);
 		} finally {
 			// Continue with the spider
@@ -2993,61 +3052,44 @@
 	 * @param wayPoint
 	 *            The name of the cache
 	 * @param is_found
-	 *            Found status of the cached (is inherited by the additional
-	 *            waypoints)
+	 *            Found status of the cached (is inherited by the additional waypoints)
 	 */
 	boolean koords_not_yet_found = true;
 
-	private void getAddWaypoints(String doc, String wayPoint, boolean is_found)
-			throws Exception {
-		Extractor exWayBlock = new Extractor(doc, 
-				p.getProp(&quot;wayBlockExStart&quot;),
-				p.getProp(&quot;wayBlockExEnd&quot;), 
-				0, false);
+	private void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception {
+		final Extractor exWayBlock = new Extractor(doc, p.getProp(&quot;wayBlockExStart&quot;), p.getProp(&quot;wayBlockExEnd&quot;), 0, false);
 		String wayBlock = &quot;&quot;;
 		String rowBlock = &quot;&quot;;
 		wayBlock = exWayBlock.findNext();
-		Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
-		Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
-		Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
-		Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
+		final Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
+		final Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
+		final Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
+		final Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
 		int counter = 0;
-		if (!exWayBlock.endOfSearch()
-				&amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;) &lt; 0) {
-			Extractor exRowBlock = new Extractor(wayBlock, 
-					p.getProp(&quot;rowBlockExStart&quot;), 
-					p.getProp(&quot;rowBlockExEnd&quot;),
-					0, false);
+		if (!exWayBlock.endOfSearch() &amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;) &lt; 0) {
+			final Extractor exRowBlock = new Extractor(wayBlock, p.getProp(&quot;rowBlockExStart&quot;), p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
 			rowBlock = exRowBlock.findNext();
 			rowBlock = exRowBlock.findNext();
 			while (!exRowBlock.endOfSearch()) {
 				CacheHolder hd = null;
 
 				/*
-				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int
-				 * linePrefix=8; if(AddiBlock.length &lt; linePrefix + 1) { (new
-				 * MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),
-				 * &quot;GC changed table output \nCW must be changed too!&quot;,
-				 * FormBase.OKB)).execute(); break; } String
-				 * prefix=AddiBlock[linePrefix].trim();
+				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int linePrefix=8; if(AddiBlock.length &lt; linePrefix + 1) { (new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), &quot;GC changed table output \nCW must be changed too!&quot;, FormBase.OKB)).execute();
+				 * break; } String prefix=AddiBlock[linePrefix].trim();
 				 */
 
 				// Extractor exPrefix=new
 				// Extractor(AddiBlock[linePrefix].trim(),p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
-				Extractor exPrefix = new Extractor(rowBlock, 
-						p.getProp(&quot;prefixExStart&quot;),
-						p.getProp(&quot;prefixExEnd&quot;), 
-						0, true);
-				String prefix = exPrefix.findNext();
+				final Extractor exPrefix = new Extractor(rowBlock, p.getProp(&quot;prefixExStart&quot;), p.getProp(&quot;prefixExEnd&quot;), 0, true);
+				final String prefix = exPrefix.findNext();
 
 				String adWayPoint;
 				if (prefix.length() == 2)
 					adWayPoint = prefix + wayPoint.substring(2);
 				else
-					adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;)
-							+ wayPoint.substring(2);
+					adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
 				counter++;
-				int idx = profile.getCacheIndex(adWayPoint);
+				final int idx = profile.getCacheIndex(adWayPoint);
 				if (idx &gt;= 0) {
 					// Creating new CacheHolder, but accessing old cache.xml
 					// file
@@ -3064,8 +3106,7 @@
 				if (nameRex.didMatch()) {
 					hd.setCacheName(nameRex.stringMatched(1));
 				} else {
-					pref.log(&quot;check nameRex in spider.def&quot;
-							+ Preferences.NEWLINE + rowBlock);
+					pref.log(&quot;check nameRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
 				}
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
@@ -3073,25 +3114,22 @@
 					hd.setLatLon(koordRex.stringMatched(1));
 					koords_not_yet_found = false;
 				} else {
-					if (koords_not_yet_found)
-						pref.log(&quot;check koordRex in spider.def&quot;
-								+ Preferences.NEWLINE + rowBlock);
+					if (koords_not_yet_found) {
+						koords_not_yet_found = false;
+						pref.log(&quot;check koordRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					}
 				}
 				if (typeRex.didMatch()) {
-					hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot;
-							+ typeRex.stringMatched(1)));
+					hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot; + typeRex.stringMatched(1)));
 				} else {
-					pref.log(&quot;check typeRex in spider.def&quot;
-							+ Preferences.NEWLINE + rowBlock);
+					pref.log(&quot;check typeRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
 				}
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
 				if (descRex.didMatch()) {
-					hd.getCacheDetails(false).setLongDescription(
-							descRex.stringMatched(1).trim());
+					hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
 				} else {
-					pref.log(&quot;check descRex in spider.def&quot;
-							+ Preferences.NEWLINE + rowBlock);
+					pref.log(&quot;check descRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
 				}
 				hd.setFound(is_found);
 				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
@@ -3101,8 +3139,8 @@
 					cacheDB.add(hd);
 					hd.save();
 				} else {
-					CacheHolder cx = cacheDB.get(idx);
-					boolean checked = cx.is_Checked;
+					final CacheHolder cx = cacheDB.get(idx);
+					final boolean checked = cx.is_Checked;
 					cx.initStates(false);
 					cx.update(hd);
 					cx.is_Checked = checked;
@@ -3114,13 +3152,10 @@
 		}
 	}
 
-	public void getAttributes(String doc, CacheHolderDetail chD)
-			throws Exception {
-		Extractor attBlock = new Extractor(doc, p.getProp(&quot;attBlockExStart&quot;), 
-				p.getProp(&quot;attBlockExEnd&quot;), 0, true);
-		String atts = attBlock.findNext();
-		Extractor attEx = new Extractor(atts, p.getProp(&quot;attExStart&quot;), 
-				p.getProp(&quot;attExEnd&quot;), 0, true);
+	public void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
+		final Extractor attBlock = new Extractor(doc, p.getProp(&quot;attBlockExStart&quot;), p.getProp(&quot;attBlockExEnd&quot;), 0, true);
+		final String atts = attBlock.findNext();
+		final Extractor attEx = new Extractor(atts, p.getProp(&quot;attExStart&quot;), p.getProp(&quot;attExEnd&quot;), 0, true);
 		String attribute = attEx.findNext();
 		chD.attributes.clear();
 		while (!attEx.endOfSearch()) {
@@ -3133,14 +3168,14 @@
 	final static String hex = ewe.util.TextEncoder.hex;
 
 	public String encodeUTF8URL(byte[] what) {
-		int max = what.length;
-		char[] dest = new char[6 * max]; // Assume each char is a UTF char and
-											// encoded into 6 chars
+		final int max = what.length;
+		final char[] dest = new char[6 * max]; // Assume each char is a UTF char
+												// and
+												// encoded into 6 chars
 		char d = 0;
 		for (int i = 0; i &lt; max; i++) {
-			char c = (char) what[i];
-			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '='
-					|| c == '|' || c == '{' || c == '}' || c &gt; 0x7f) {
+			final char c = (char) what[i];
+			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c &gt; 0x7f) {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
 				dest[d++] = hex.charAt(c &amp; 0xf);
@@ -3151,9 +3186,7 @@
 	}
 
 	/**
-	 * Load the bug id for a given name. This method is not ideal, as there are
-	 * sometimes several bugs with identical names but different IDs. Normally
-	 * the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
+	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
 	 * Note that each bug has both an ID and a GUID.
 	 * 
 	 * @param name
@@ -3166,40 +3199,30 @@
 			// infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
 			bugList = UrlFetcher.fetch(p.getProp(&quot;getBugByName&quot;) + STRreplace.replace(SafeXML.clean(name), &quot; &quot;, &quot;+&quot;));
 			pref.log(&quot;[getBugId] Fetched bugId: &quot; + name);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugId] Could not fetch bug list&quot; + name, ex);
 			bugList = &quot;&quot;;
 		}
 		try {
-			if (bugList.equals(&quot;&quot;)
-					|| bugList.indexOf(p.getProp(&quot;bugNotFound&quot;)) &gt;= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), 
-						MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;),
-						FormBase.OKB)).execute();
+			if (bugList.equals(&quot;&quot;) || bugList.indexOf(p.getProp(&quot;bugNotFound&quot;)) &gt;= 0) {
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
 				return &quot;&quot;;
 			}
 			if (bugList.indexOf(p.getProp(&quot;bugTotalRecords&quot;)) &lt; 0) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(6021, &quot;More than one travelbug found. Specify name more precisely.&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(6021, &quot;More than one travelbug found. Specify name more precisely.&quot;), FormBase.OKB)).execute();
 				return &quot;&quot;;
 			}
-			Extractor exGuid = new Extractor(bugList, 
-					p.getProp(&quot;bugGuidExStart&quot;), 
-					p.getProp(&quot;bugGuidExEnd&quot;), 
-					0, Extractor.EXCLUDESTARTEND); 
+			final Extractor exGuid = new Extractor(bugList, p.getProp(&quot;bugGuidExStart&quot;), p.getProp(&quot;bugGuidExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			// TODO Replace with spider.def
 			return exGuid.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugId] Error getting TB&quot;, ex);
 			return &quot;&quot;;
 		}
 	}
 
 	/**
-	 * Fetch a bug's mission for a given GUID or ID. If the guid String is
-	 * longer than 10 characters it is assumed to be a GUID, otherwise it is an
-	 * ID.
+	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be a GUID, otherwise it is an ID.
 	 * 
 	 * @param guid
 	 *            the guid or id of the travelbug
@@ -3214,23 +3237,18 @@
 			else
 				bugDetails = UrlFetcher.fetch(p.getProp(&quot;getBugById&quot;) + guid);
 			pref.log(&quot;[getBugMissionByGuid] Fetched TB detailsById: &quot; + guid);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByGuid] Could not fetch TB details &quot; + guid, ex);
 			bugDetails = &quot;&quot;;
 		}
 		try {
 			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;)) &gt;= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
 				return &quot;&quot;;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp(&quot;bugDetailsStart&quot;), 
-					p.getProp(&quot;bugDetailsEnd&quot;),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByGuid] Error getting TB &quot; + guid, ex);
 			return &quot;&quot;;
 		}
@@ -3248,7 +3266,7 @@
 		try {
 			bugDetails = UrlFetcher.fetch(p.getProp(&quot;getBugByTrackNr&quot;) + trackNr);
 			pref.log(&quot;[getBugMissionByTrackNr] Fetched bug detailsByTrackNr: &quot; + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByTrackNr] getBugByTrackNr &quot; + trackNr, ex);
 			bugDetails = &quot;&quot;;
 		}
@@ -3260,12 +3278,9 @@
 				// MessageBox.OKB)).execute();
 				return &quot;&quot;;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp(&quot;bugDetailsStart&quot;), 
-					p.getProp(&quot;bugDetailsEnd&quot;),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByTrackNr] TB Details, bugNotFound &quot; + trackNr, ex);
 			return &quot;&quot;;
 		}
@@ -3280,11 +3295,11 @@
 	 */
 	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
 		String bugDetails;
-		String trackNr = TB.getTrackingNo();
+		final String trackNr = TB.getTrackingNo();
 		try {
 			bugDetails = UrlFetcher.fetch(p.getProp(&quot;getBugByTrackNr&quot;) + trackNr);
 			pref.log(&quot;[getBugMissionAndNameByTrackNr] Fetched TB getBugByTrackNr: &quot; + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionAndNameByTrackNr] Could not fetch bug details: &quot; + trackNr, ex);
 			bugDetails = &quot;&quot;;
 		}
@@ -3296,16 +3311,12 @@
 				// MessageBox.OKB)).execute();
 				return false;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			TB.setMission(exDetails.findNext());
-			Extractor exName = new Extractor(bugDetails, 
-					p.getProp(&quot;bugNameStart&quot;), p.getProp(&quot;bugNameEnd&quot;), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exName = new Extractor(bugDetails, p.getProp(&quot;bugNameStart&quot;), p.getProp(&quot;bugNameEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			TB.setName(exName.findNext());
 			return true;
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionAndNameByTrackNr] TB Details, bugNotFound: &quot; + trackNr, ex);
 			return false;
 		}
@@ -3316,11 +3327,9 @@
 			super();
 			try {
 				load(new FileInputStream(FileBase.getProgramDirectory() + &quot;/spider.def&quot;));
-			} catch (Exception ex) {
+			} catch (final Exception ex) {
 				pref.log(&quot;Failed to load spider.def from &quot; + FileBase.getProgramDirectory(), ex);
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), 
-						MyLocale.getMsg(5504, &quot;Could not load 'spider.def'&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5504, &quot;Could not load 'spider.def'&quot;), FormBase.OKB)).execute();
 			}
 		}
 
@@ -3334,11 +3343,9 @@
 		 *             When a key is requested which doesn't exist
 		 */
 		public String getProp(String key) throws Exception {
-			String s = super.getProperty(key);
+			final String s = super.getProperty(key);
 			if (s == null) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(5497, &quot;Error missing tag in spider.def&quot;)+ &quot;: &quot; + key,
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5497, &quot;Error missing tag in spider.def&quot;) + &quot;: &quot; + key, FormBase.OKB)).execute();
 				pref.log(&quot;Missing tag in spider.def: &quot; + key);
 				throw new Exception(&quot;Missing tag in spider.def: &quot; + key);
 			}
@@ -3372,16 +3379,16 @@
 				parse(r);
 				r.close();
 				rFIS.close();
-			} catch (Exception e) {
+			} catch (final Exception e) {
 			}
 			return _routePoints;
 		}
 
 		public void startElement(String name, AttributeList atts) {
-			if (name.equals(&quot;trkpt&quot;)|| name.equals(&quot;rtept&quot;)|| name.equals(&quot;gpxx:rpt&quot;)) {
-				double lat = Common.parseDouble(atts.getValue(&quot;lat&quot;));
-				double lon = Common.parseDouble(atts.getValue(&quot;lon&quot;));
-				TrackPoint tp = new TrackPoint(lat, lon);
+			if (name.equals(&quot;trkpt&quot;) || name.equals(&quot;rtept&quot;) || name.equals(&quot;gpxx:rpt&quot;)) {
+				final double lat = Common.parseDouble(atts.getValue(&quot;lat&quot;));
+				final double lon = Common.parseDouble(atts.getValue(&quot;lon&quot;));
+				final TrackPoint tp = new TrackPoint(lat, lon);
 				if (tp.isValid())
 					_routePoints.add(tp);
 				return;
@@ -3393,4 +3400,3 @@
 		}
 	}
 }
-

Modified: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -40,16 +40,14 @@
 import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 
-
 /**
- * class to read, save and do the calculations for calibrated and 
- * calibrating maps
- * start offset for language file: 4300
+ * class to read, save and do the calculations for calibrated and calibrating maps start offset for language file: 4300
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapInfoObject extends Area {
-	//World file:
+	// World file:
 	// x scale
 	// y scale
 	// x rotation
@@ -59,89 +57,95 @@
 	// lon of lower right corner of image
 	// lat of lower right corner of image
 
-	private double[] affine = {0,0,0,0};
+	private final double[] affine = { 0, 0, 0, 0 };
 	private CWPoint affineTopleft = new CWPoint();;
-	private double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	// this are needed for the inervers calculation from lat/lon to x/y
+	private double transLatX, transLatY, transLonX, transLonY;
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
-	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
-	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
-	public Point shift = new Point (0,0);
-	public CWPoint origAffineUpperLeft; // this is only valid after zooming 
+	// in meters per pixel, note: it is assumed that this scale identifying the scale of the map,
+	// automatically adjusted when zooming
+	public float scale;
+	// if the image is zoomed, direct after laoding always 1
+	public float zoomFactor = 1;
+	public Point shift = new Point(0, 0);
+	public CWPoint origAffineUpperLeft; // this is only valid after zooming
 	public float rotationRad; // contains the rotation of the map == north direction in rad
-	/** full path to the respective worldfile, including &quot;.wfl&quot;*/
+	/** full path to the respective worldfile, including &quot;.wfl&quot; */
 	public String fileNameWFL = &quot;&quot;;
 	/** filename wihout directory */
-//	public String fileName = new String();
-	/** name of the map, introduced to allow 'maps' without an image (empty maps) */ 
+	// public String fileName = new String();
+	/**
+	 * name of the map, introduced to allow 'maps' without an image (empty maps)
+	 */
 	public String mapName = &quot;&quot;;
-	//private Character digSep = new Character(' ');
+	// private Character digSep = new Character(' ');
 	static private String digSep = MyLocale.getDigSeparator();
-	private int coordTrans = 0; 
+	private int coordTrans = 0;
 
 	public MapInfoObject() { // Public constructor
 	}
 
 	public MapInfoObject(MapInfoObject map) {
-		super (map.topleft, map.bottomright);
+		super(map.topleft, map.bottomright);
 		mapName = map.mapName;
 		affine[0] = map.affine[0];
 		affine[1] = map.affine[1];
 		affine[2] = map.affine[2];
 		affine[3] = map.affine[3];
-		origAffineUpperLeft = new CWPoint (map.origAffineUpperLeft);
+		origAffineUpperLeft = new CWPoint(map.origAffineUpperLeft);
 		affineTopleft = new CWPoint(map.affineTopleft);
 		zoomFactor = map.zoomFactor;
 		shift.set(map.shift);
 		coordTrans = map.coordTrans;
-		//	fileName = new String(map.fileName);
+		// fileName = new String(map.fileName);
 		fileNameWFL = new String(map.fileNameWFL);
 		mapName = new String(mapName);
 		doCalculations();
 	}
 
 	/**
-	 * constructes an MapInfoObject without an associated map
-	 * but with 1 Pixel = scale meters
+	 * constructes an MapInfoObject without an associated map but with 1 Pixel = scale meters
 	 */
 	public MapInfoObject(double scalei, double lat) {
-		super(new CWPoint(1,0), new CWPoint(0,1));
-		mapName=MyLocale.getMsg(4300, &quot;empty 1 Pixel = &quot;) + scalei + MyLocale.getMsg(4301,&quot;meters&quot;);
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deg / java.lang.Math.cos(lat*java.lang.Math.PI / 180); //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=1; //top
-		topleft.lonDec=0; //left
-		bottomright.latDec = 0; //bottom
-		bottomright.lonDec = 1; //right
+		super(new CWPoint(1, 0), new CWPoint(0, 1));
+		mapName = MyLocale.getMsg(4300, &quot;empty 1 Pixel = &quot;) + scalei + MyLocale.getMsg(4301, &quot;meters&quot;);
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deg / java.lang.Math.cos(lat * java.lang.Math.PI / 180); // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = 1; // top
+		topleft.lonDec = 0; // left
+		bottomright.latDec = 0; // bottom
+		bottomright.lonDec = 1; // right
 		affineTopleft.set(topleft);
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 	}
 
 	/**
-	 * constructs an MapInfoObject with an associated map
-	 * with 1 Pixel = scale meters, centre and width, hight in pixels
-	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 * constructs an MapInfoObject with an associated map with 1 Pixel = scale meters, centre and width, hight in pixels
+	 * 
+	 * @param name
+	 *            path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
 	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
 		super();
-		mapName = name+&quot;.wfl&quot;;
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deghorizontal; //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=center.latDec + hight / 2 *pixel2deg; //top
-		topleft.lonDec=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		mapName = name + &quot;.wfl&quot;;
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		final double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec * java.lang.Math.PI / 180);
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deghorizontal; // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = center.latDec + hight / 2 * pixel2deg; // top
+		topleft.lonDec = center.lonDec - width / 2 * pixel2deghorizontal; // left
 		affineTopleft.set(topleft);
-		bottomright.latDec = center.latDec - hight / 2 *pixel2deg; //bottom
-		bottomright.lonDec = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		bottomright.latDec = center.latDec - hight / 2 * pixel2deg; // bottom
+		bottomright.lonDec = center.lonDec + width / 2 * pixel2deghorizontal; // right
 		fileNameWFL = name;
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 		doCalculations();
@@ -154,42 +158,51 @@
 
 	/**
 	 * 
-	 * @param path including trailing &quot;/&quot;
-	 * @param n without &quot;.wfl&quot;
+	 * @param path
+	 *            including trailing &quot;/&quot;
+	 * @param n
+	 *            without &quot;.wfl&quot;
 	 * @return name of the map including fast-find-prefix
 	 */
 	public String setName(String path, String n) {
-		String pref = getFfPrefix();
+		final String pref = getFfPrefix();
 		mapName = pref + n;
 		fileNameWFL = path + pref + mapName + &quot;.wfl&quot;;
 		return mapName;
 	}
 
-	/** 
+	/**
 	 * @return the filename of the associated map image, &quot;&quot; if no file is associated, null if associated file could not be found
 	 */
 	public String getImageFilename() {
-		// if (fileName == null || fileName.length() &gt; 0) return fileName; 
-		if (fileNameWFL.length() == 0) return &quot;&quot;; // no image associated (empty map)
-		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
+		// if (fileName == null || fileName.length() &gt; 0) return fileName;
+		if (fileNameWFL.length() == 0)
+			return &quot;&quot;; // no image associated (empty map)
+		final String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
 		return Common.getImageName(CacheWolf.STRreplace.replace(n, &quot;//&quot;, &quot;/&quot;));
 	}
 
 	/**
 	 * Method to load a .wfl-file
-	 * @param mapsPath path to the map inclunding / at the end
-	 * @param thisMap name of the map without extension
-	 * @throws IOException when there was a problem reading .wfl-file
-	 * @throws IOException when lat/lon were out of range
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @param mapsPath
+	 *            path to the map inclunding / at the end
+	 * @param thisMap
+	 *            name of the map without extension
+	 * @throws IOException
+	 *             when there was a problem reading .wfl-file
+	 * @throws IOException
+	 *             when lat/lon were out of range
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
-		FileInputStream instream = new FileInputStream (CacheWolf.STRreplace.replace(mapsPath + thisMap + &quot;.wfl&quot;, &quot;//&quot;, &quot;/&quot;));
-		InputStreamReader in = new InputStreamReader(instream);
-		
+		final FileInputStream instream = new FileInputStream(CacheWolf.STRreplace.replace(mapsPath + thisMap + &quot;.wfl&quot;, &quot;//&quot;, &quot;/&quot;));
+		final InputStreamReader in = new InputStreamReader(instream);
+
 		String line = &quot;&quot;;
 		try {
-			for(int i = 0; i&lt;4;i++){
+			for (int i = 0; i &lt; 4; i++) {
 				line = in.readLine();
 				affine[i] = Common.parseDoubleException(line);
 			}
@@ -201,20 +214,28 @@
 			bottomright.latDec = Common.parseDoubleException(line);
 			line = in.readLine();
 			bottomright.lonDec = Common.parseDoubleException(line);
-			line = in.readLine(); // readLine returns null, if End of File reached
-			if (line != null) coordTrans = Common.parseInt(line);
-			else coordTrans = 0;
+			line = in.readLine(); // readLine returns null, if End of File
+									// reached
+			if (line != null)
+				coordTrans = Common.parseInt(line);
+			else
+				coordTrans = 0;
 			fileNameWFL = mapsPath + thisMap + &quot;.wfl&quot;;
-//			fileName = &quot;&quot;; //mapsPath + thisMap + &quot;.png&quot;;
+			// fileName = &quot;&quot;; //mapsPath + thisMap + &quot;.png&quot;;
 			mapName = thisMap;
 			in.close();
-			if( !bottomright.isValid() ) {
-				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; 
+			if (!bottomright.isValid()) {
+				affine[0] = 0;
+				affine[1] = 0;
+				affine[2] = 0;
+				affine[3] = 0;
 				topleft.makeInvalid();
-				throw (new IOException(MyLocale.getMsg(4301, &quot;Lat/Lon out of range while reading &quot;)+mapsPath + thisMap + &quot;.wfl&quot;));
+				throw (new IOException(MyLocale.getMsg(4301, &quot;Lat/Lon out of range while reading &quot;) + mapsPath + thisMap + &quot;.wfl&quot;));
 			}
-		} catch (NullPointerException e) { // in.readline liefert null zur&#252;ck, wenn keine Daten mehr vorhanden sind
-			throw (new IOException(MyLocale.getMsg(4303, &quot;not enough lines in file &quot;)+mapsPath + thisMap + &quot;.wfl&quot;));
+		} catch (final NullPointerException e) { // in.readline liefert null
+													// zur&#252;ck, wenn keine Daten
+													// mehr vorhanden sind
+			throw (new IOException(MyLocale.getMsg(4303, &quot;not enough lines in file &quot;) + mapsPath + thisMap + &quot;.wfl&quot;));
 		}
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
@@ -223,24 +244,30 @@
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
 		evalGCP(GCPs, imageWidth, imageHeight, 0);
 	}
-		/**
-	 *	Method to evaluate ground control points (georeferenced points) and identify the parameters
-	 *	for the affine transformation
-	 *  @throws IllegalArgumentException when less than 3 georeferenced points were given in GCPs
+
+	/**
+	 * Method to evaluate ground control points (georeferenced points) and identify the parameters for the affine transformation
+	 * 
+	 * @throws IllegalArgumentException
+	 *             when less than 3 georeferenced points were given in GCPs
 	 */
 
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight, int epsg_code) throws IllegalArgumentException {
-		//N 48 16.000 E 11 32.000
-		//N 48 16.000 E 11 50.000
-		//N 48 9.000 E 11 32.000
-		if (GCPs.size() &lt; 3 ) throw new IllegalArgumentException(MyLocale.getMsg(4304, &quot;not enough points to calibrate the map&quot;));
+		// N 48 16.000 E 11 32.000
+		// N 48 16.000 E 11 50.000
+		// N 48 9.000 E 11 32.000
+		if (GCPs.size() &lt; 3)
+			throw new IllegalArgumentException(MyLocale.getMsg(4304, &quot;not enough points to calibrate the map&quot;));
 		GCPoint gcp = new GCPoint();
-		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
-		Matrix X = new Matrix(GCPs.size(),3);
-		Matrix trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i &lt; GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+		// Calculate parameters for latitutde affine transformation (affine
+		// 0,2,4)
+		Matrix X = new Matrix(GCPs.size(), 3);
+		Matrix trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i &lt; GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
 			trg.matrix[i][0] = gcp.latDec;
 		}
 		Matrix Xtran = new Matrix(X);
@@ -256,11 +283,12 @@
 		affine[2] = beta.matrix[2][0];
 		affineTopleft.latDec = beta.matrix[0][0];
 
-		//Calculate parameters for longitude affine transformation (affine 1,3,5)
-		X = new Matrix(GCPs.size(),3);
-		trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i &lt; GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
+		// Calculate parameters for longitude affine transformation (affine
+		// 1,3,5)
+		X = new Matrix(GCPs.size(), 3);
+		trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i &lt; GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
 			X.matrix[i][0] = 1;
 			X.matrix[i][1] = gcp.bitMapX;
 			X.matrix[i][2] = gcp.bitMapY;
@@ -285,56 +313,71 @@
 
 	/**
 	 * calculates centre, diagonal size of the map and inverse to affine transformation
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 
 	private void doCalculations() throws ArithmeticException {
 		try {
 			topleft.set(calcLatLon(0, 0));
-			center.set((bottomright.latDec + topleft.latDec)/2,(bottomright.lonDec + topleft.lonDec)/2);
-			sizeKm = java.lang.Math.abs((float)center.getDistance(bottomright)) *2;
+			center.set((bottomright.latDec + topleft.latDec) / 2, (bottomright.lonDec + topleft.lonDec) / 2);
+			sizeKm = java.lang.Math.abs((float) center.getDistance(bottomright)) * 2;
 
-			//calculate reverse affine
-			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
-			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
-			transLonX = -affine[2]/nenner;
-			transLatY = -affine[1]/nenner;
-			transLonY = affine[0]/nenner;
+			// calculate reverse affine
+			final double nenner = (-affine[1] * affine[2] + affine[0] * affine[3]);
+			transLatX = affine[3] / nenner; // nenner == 0 cannot happen as long
+											// als affine is correct
+			transLonX = -affine[2] / nenner;
+			transLatY = -affine[1] / nenner;
+			transLonY = affine[0] / nenner;
 
 			// calculate north direction
-			Point c = calcMapXY(center);
-			int heightpixel = c.y * 2;
+			final Point c = calcMapXY(center);
+			final int heightpixel = c.y * 2;
 			c.y -= 1000;
-			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);  // note: the direction of nord can vary across the image. In Gau&#223;-Kr&#252;ger Projection it does change about 1 degree per 10km! //(float)java.lang.Math.atan(rotationX2y);
-			if (rotationRad &gt; Math.PI) rotationRad -= 2* Math.PI;
+			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);
+			// note: the direction of nord can vary across the image.
+			// In Gau&#223;-Kr&#252;ger Projection it does change about 1 degree per 10km!
+			// (float)java.lang.Math.atan(rotationX2y);
+			if (rotationRad &gt; Math.PI)
+				rotationRad -= 2 * Math.PI;
 
 			// calculate scale in meters per pixel
-			double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
+			final double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
 			scale = (float) (heightkm * 1000 / heightpixel);
-		} catch (ArithmeticException ex) { throw new ArithmeticException(MyLocale.getMsg(4305, &quot;Not allowed values in affine\n (matrix cannot be inverted)\n in file \n&quot;) + fileNameWFL); }
+		} catch (final ArithmeticException ex) {
+			throw new ArithmeticException(MyLocale.getMsg(4305, &quot;Not allowed values in affine\n (matrix cannot be inverted)\n in file \n&quot;) + fileNameWFL);
+		}
 	}
 
 	public void saveWFL() throws IOException, IllegalArgumentException {
-		File dateiF = new FileBugfix(fileNameWFL);
-		String tmp = dateiF.getDrivePath(); // contains the name and the extension
+		final File dateiF = new FileBugfix(fileNameWFL);
+		final String tmp = dateiF.getDrivePath(); // contains the name and the
+													// extension
 		saveWFL(tmp, mapName);
 	}
 
 	/**
-	 *	Method to save a world file (.wfl)
-	 * @param mapsPath without &quot;/&quot; at the end
-	 * @param mapFileName without file extension
-	 * @throws IOException when there was a problem writing .wfl-file
-	 * @throws IllegalArgumentException when affine[x] for all x == 0 (&quot;map not calibrated&quot;).
+	 * Method to save a world file (.wfl)
+	 * 
+	 * @param mapsPath
+	 *            without &quot;/&quot; at the end
+	 * @param mapFileName
+	 *            without file extension
+	 * @throws IOException
+	 *             when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException
+	 *             when affine[x] for all x == 0 (&quot;map not calibrated&quot;).
 	 */
 	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
 		if (mapsPath.endsWith(&quot;/&quot;)) {
-			mapsPath=mapsPath.substring(0, mapsPath.length()-1);
+			mapsPath = mapsPath.substring(0, mapsPath.length() - 1);
 		}
-		if (affine[0]==0 &amp;&amp; affine[1]==0 &amp;&amp; affine[2]==0 &amp;&amp; affine[3]==0 &amp;&amp; 
-				!topleft.isValid()) throw (new IllegalArgumentException(MyLocale.getMsg(4306, &quot;map not calibrated&quot;)));
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;)));
-		StringBuffer towriteB=new StringBuffer(400);
+		if (affine[0] == 0 &amp;&amp; affine[1] == 0 &amp;&amp; affine[2] == 0 &amp;&amp; affine[3] == 0 &amp;&amp; !topleft.isValid())
+			throw (new IllegalArgumentException(MyLocale.getMsg(4306, &quot;map not calibrated&quot;)));
+		final PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;)));
+		final StringBuffer towriteB = new StringBuffer(400);
 		towriteB.append(Convert.toString(affine[0])).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(affine[1])).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(affine[2])).append(&quot;\n&quot;);
@@ -343,69 +386,77 @@
 		towriteB.append(Convert.toString(affineTopleft.lonDec)).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(bottomright.latDec)).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(bottomright.lonDec)).append(&quot;\n&quot;);
-		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? &quot;&quot; : Convert.toString(coordTrans)+&quot;\n&quot;));
+		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? &quot;&quot; : Convert.toString(coordTrans) + &quot;\n&quot;));
 		String towrite = towriteB.toString();
-		if (digSep.equals(&quot;,&quot;)) towrite=towrite.replace(',', '.');
+		if (digSep.equals(&quot;,&quot;))
+			towrite = towrite.replace(',', '.');
 		outp.print(towrite);
 		outp.close();
-//		this.fileName = &quot;&quot;; // this will be set in getImageFilenam //mapsPath + &quot;/&quot; + mapFileName + &quot;.png&quot;;
+		// this.fileName = &quot;&quot;; // this will be set in getImageFilenam //mapsPath
+		// + &quot;/&quot; + mapFileName + &quot;.png&quot;;
 		this.fileNameWFL = mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;;
 		this.mapName = mapFileName;
 	}
 
-
 	/**
 	 * zoom in / out
-	 * @param zf zf &gt; 1 == zoom in, zoom is relative to original unscaled image
-	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * 
+	 * @param zf
+	 *            zf &gt; 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX
+	 *            shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
 	 * @param diffY
 	 */
 	public void zoom(float zf, int diffX, int diffY) {
 		// restore original values to calculate corret shift (upperleft)
 		affineTopleft.latDec = origAffineUpperLeft.latDec;
 		affineTopleft.lonDec = origAffineUpperLeft.lonDec;
-		affine[0] = affine[0] * zoomFactor; 
-		affine[1] = affine[1] * zoomFactor; 
+		affine[0] = affine[0] * zoomFactor;
+		affine[1] = affine[1] * zoomFactor;
 		affine[2] = affine[2] * zoomFactor;
 		affine[3] = affine[3] * zoomFactor;
 		TrackPoint upperleft = calcLatLon(diffX, diffY);
-		if (coordTrans != 0) upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
-		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken affineTopleft
+		if (coordTrans != 0)
+			upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
+		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken
+													// affineTopleft
 		affineTopleft.lonDec = upperleft.lonDec;
-		affine[0] = affine[0] / zf ; 
-		affine[1] = affine[1] / zf ; 
-		affine[2] = affine[2] / zf ; 
-		affine[3] = affine[3] / zf ; 
-		zoomFactor = zf ;
+		affine[0] = affine[0] / zf;
+		affine[1] = affine[1] / zf;
+		affine[2] = affine[2] / zf;
+		affine[3] = affine[3] / zf;
+		zoomFactor = zf;
 		shift.x = diffX;
 		shift.y = diffY;
 		doCalculations(); // TODO lowlat neu berechnen?
 	}
 
 	/**
-	 * Method to calculate bitmap x,y of the current map using
-	 * lat and lon target coordinates. There ist no garanty that
-	 * the returned coordinates are inside of the map. They can be negative.
+	 * Method to calculate bitmap x,y of the current map using lat and lon target coordinates. There ist no garanty that the returned coordinates are inside of the map. They can be negative.
+	 * 
 	 * @param lat
 	 * @param lon
 	 */
-	public Point calcMapXY(TrackPoint ll){
+	public Point calcMapXY(TrackPoint ll) {
 		TrackPoint t;
-		if (coordTrans != 0) t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
-		else t = ll;
-		Point coords = new Point();
+		if (coordTrans != 0)
+			t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
+		else
+			t = ll;
+		final Point coords = new Point();
 		double b0, b1;
 		b0 = t.latDec - affineTopleft.latDec;
 		b1 = t.lonDec - affineTopleft.lonDec;
-		double mapx = transLatX * b0 + transLonX * b1;
-		double mapy = transLatY * b0 + transLonY * b1;
-		coords.x = (int)Math.round(mapx);
-		coords.y = (int)Math.round(mapy);
+		final double mapx = transLatX * b0 + transLonX * b1;
+		final double mapy = transLatY * b0 + transLonY * b1;
+		coords.x = (int) Math.round(mapx);
+		coords.y = (int) Math.round(mapy);
 		return coords;
 	}
 
 	/**
 	 * gives back lat/lon from x, y in map
+	 * 
 	 * @param x
 	 * @param y
 	 * @return
@@ -418,51 +469,49 @@
 			ll = TransformCoordinatesProperties.toWgs84(ll, coordTrans);
 		return ll;
 	}
-	
+
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);
 	}
 
 	/**
-	 * Get the prefix used for easy and fast finding of the best map
-	 * The filname of the .wfl and respective image should start with this
-	 * prefix in order to make finding the best map much faster 
+	 * Get the prefix used for easy and fast finding of the best map The filname of the .wfl and respective image should start with this prefix in order to make finding the best map much faster
+	 * 
 	 * @return
 	 */
 	public String getFfPrefix() {
-		return &quot;FF1&quot;+getEasyFindString()+&quot;E-&quot;;
+		return &quot;FF1&quot; + getEasyFindString() + &quot;E-&quot;;
 	}
 }
 
-	/**
-	 *	Class based on CWPoint but intended to handle bitmap x and y
-	 *	Used for georeferencing bitmaps.
-	 */
-	class GCPoint extends CWPoint{
-		public int bitMapX = 0;
-		public int bitMapY = 0;
+/**
+ * Class based on CWPoint but intended to handle bitmap x and y Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint {
+	public int bitMapX = 0;
+	public int bitMapY = 0;
 
-		public GCPoint(){ // Public constructor
-		}
+	public GCPoint() { // Public constructor
+	}
 
-		public GCPoint(CWPoint p) {
-			super(p);
-		}
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
 
-		/**
-		 * If you are using Gau&#223;-Kr&#252;ger, put lat = northing, lon = easting 
-		 * @param lat
-		 * @param lon
-		 */
-		public GCPoint(double lat, double lon){
-			this.latDec = lat;
-			this.lonDec = lon;
-		}
-		
-		public GCPoint(CWPoint ll, Point px) {
-			super(ll);
-			bitMapX = px.x;
-			bitMapY = px.y;
-		}
+	/**
+	 * If you are using Gau&#223;-Kr&#252;ger, put lat = northing, lon = easting
+	 * 
+	 * @param lat
+	 * @param lon
+	 */
+	public GCPoint(double lat, double lon) {
+		this.latDec = lat;
+		this.lonDec = lon;
 	}
-	
\ No newline at end of file
+
+	public GCPoint(CWPoint ll, Point px) {
+		super(ll);
+		bitMapX = px.x;
+		bitMapY = px.y;
+	}
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002985.html">[Cachewolf-svn] r2994 - trunk/res_noewe/webmapservices
</A></li>
	<LI>Next message: <A HREF="002987.html">[Cachewolf-svn] r2996 - in trunk: res_noewe src/CacheWolf	src/CacheWolf/imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2986">[ date ]</a>
              <a href="thread.html#2986">[ thread ]</a>
              <a href="subject.html#2986">[ subject ]</a>
              <a href="author.html#2986">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
