<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3008 - in trunk: res_noewe/symbols resources	src/CacheWolf src/CacheWolf/navi src/CacheWolf/navi/touchControls
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-May/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3008%20-%20in%20trunk%3A%20res_noewe/symbols%20resources%0A%09src/CacheWolf%20src/CacheWolf/navi%20src/CacheWolf/navi/touchControls&In-Reply-To=%3C20110520164625.3392A4813EA%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002997.html">
   <LINK REL="Next"  HREF="003000.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3008 - in trunk: res_noewe/symbols resources	src/CacheWolf src/CacheWolf/navi src/CacheWolf/navi/touchControls</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3008%20-%20in%20trunk%3A%20res_noewe/symbols%20resources%0A%09src/CacheWolf%20src/CacheWolf/navi%20src/CacheWolf/navi/touchControls&In-Reply-To=%3C20110520164625.3392A4813EA%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3008 - in trunk: res_noewe/symbols resources	src/CacheWolf src/CacheWolf/navi src/CacheWolf/navi/touchControls">araber95 at mail.berlios.de
       </A><BR>
    <I>Fri May 20 06:46:24 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002997.html">[Cachewolf-svn] r3006 - trunk/res_noewe
</A></li>
        <LI>Next message: <A HREF="003000.html">[Cachewolf-svn] r3009 - trunk/src/CacheWolf/view/pda
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2999">[ date ]</a>
              <a href="thread.html#2999">[ thread ]</a>
              <a href="subject.html#2999">[ subject ]</a>
              <a href="author.html#2999">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-05-20 18:46:24 +0200 (Fri, 20 May 2011)
New Revision: 3008

Added:
   trunk/resources/archived.png
   trunk/resources/bonus.png
   trunk/resources/disabled.png
   trunk/resources/dnf.png
   trunk/resources/owned.png
   trunk/resources/solved.png
Removed:
   trunk/res_noewe/symbols/2foundsize.png
Modified:
   trunk/res_noewe/symbols/readme.htm
   trunk/resources/found.png
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheType.java
   trunk/src/CacheWolf/GuiImageBroker.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/navi/MapImage.java
   trunk/src/CacheWolf/navi/MapSymbol.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
   trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
Log:
Cachesymbol -Overlays introduced: found, dnf, archived, disabled, own, solved, bonus

Deleted: trunk/res_noewe/symbols/2foundsize.png
===================================================================
(Binary files differ)

Modified: trunk/res_noewe/symbols/readme.htm
===================================================================
--- trunk/res_noewe/symbols/readme.htm	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/res_noewe/symbols/readme.htm	2011-05-20 16:46:24 UTC (rev 3008)
@@ -14,16 +14,16 @@
  &lt;o:DocumentProperties&gt;
   &lt;o:Author&gt;.&lt;/o:Author&gt;
   &lt;o:LastAuthor&gt;Franz&lt;/o:LastAuthor&gt;
-  &lt;o:Revision&gt;7&lt;/o:Revision&gt;
+  &lt;o:Revision&gt;8&lt;/o:Revision&gt;
   &lt;o:Created&gt;2009-10-23T21:05:00Z&lt;/o:Created&gt;
-  &lt;o:LastSaved&gt;2011-04-16T14:48:00Z&lt;/o:LastSaved&gt;
+  &lt;o:LastSaved&gt;2011-05-20T16:42:00Z&lt;/o:LastSaved&gt;
   &lt;o:Pages&gt;1&lt;/o:Pages&gt;
-  &lt;o:Words&gt;256&lt;/o:Words&gt;
-  &lt;o:Characters&gt;1615&lt;/o:Characters&gt;
+  &lt;o:Words&gt;390&lt;/o:Words&gt;
+  &lt;o:Characters&gt;2458&lt;/o:Characters&gt;
   &lt;o:Company&gt;CF Computer&lt;/o:Company&gt;
-  &lt;o:Lines&gt;13&lt;/o:Lines&gt;
-  &lt;o:Paragraphs&gt;3&lt;/o:Paragraphs&gt;
-  &lt;o:CharactersWithSpaces&gt;1868&lt;/o:CharactersWithSpaces&gt;
+  &lt;o:Lines&gt;20&lt;/o:Lines&gt;
+  &lt;o:Paragraphs&gt;5&lt;/o:Paragraphs&gt;
+  &lt;o:CharactersWithSpaces&gt;2843&lt;/o:CharactersWithSpaces&gt;
   &lt;o:Version&gt;10.6870&lt;/o:Version&gt;
  &lt;/o:DocumentProperties&gt;
 &lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
@@ -84,7 +84,7 @@
 	font-family:&quot;Times New Roman&quot;;}
 &lt;/style&gt;
 &lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
- &lt;o:shapedefaults v:ext=&quot;edit&quot; spidmax=&quot;6146&quot;/&gt;
+ &lt;o:shapedefaults v:ext=&quot;edit&quot; spidmax=&quot;7170&quot;/&gt;
 &lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
  &lt;o:shapelayout v:ext=&quot;edit&quot;&gt;
   &lt;o:idmap v:ext=&quot;edit&quot; data=&quot;1&quot;/&gt;
@@ -97,7 +97,7 @@
 
 &lt;p class=MsoNormal&gt;In diesem Verzeichnis vorhandene .&lt;span class=SpellE&gt;png-Dateien&lt;/span&gt;
 werden als alternative Symbole in den Cachewolf geladen, falls in den
-Einstellungen/Tab mehr eingeschaltet.&lt;/p&gt;
+Einstellungen/Tab Mehr/nutze eigene Symbole eingeschaltet.&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;Dabei sollte es sich um &lt;span class=SpellE&gt;PNGs&lt;/span&gt; der
 Gr&#246;&#223;e 16x16 handeln oder kleiner.&lt;/p&gt;
@@ -106,13 +106,38 @@
 Symbole angezeigt, falls sie existieren und der Dateiname auf &lt;span
 class=SpellE&gt;size&lt;/span&gt; endet.&lt;/p&gt;
 
-&lt;p class=MsoNormal&gt;F&#252;r &lt;span class=GramE&gt;gefundene&lt;/span&gt; Cache k&#246;nnen auf der
-Karte entsprechende Symbole angezeigt werden. Der Dateiname muss daf&#252;r auf &lt;span
-class=SpellE&gt;foundsize&lt;/span&gt; enden.&lt;/p&gt;
+&lt;p class=MsoNormal&gt;F&#252;r folgende &lt;span class=SpellE&gt;Stati&lt;/span&gt; kann ein extra
+Symbol auf der Kartenansicht &#252;berlagert werden: &lt;/p&gt;
 
-&lt;p class=MsoNormal&gt;Es m&#252;ssen nur die Dateien erstellt werden, die ersetzt
-werden sollen.&lt;/p&gt;
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;&lt;span class=GramE&gt;found.png&lt;/span&gt;&lt;/span&gt;&lt;span
+class=GramE&gt; :&lt;/span&gt; habe den Cache schon gefunden.&lt;/p&gt;
 
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;dnf.png&lt;/span&gt;: habe den Cache nicht
+gefunden:&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;&lt;span class=GramE&gt;archived.png&lt;/span&gt;&lt;/span&gt;&lt;span
+class=GramE&gt; :&lt;/span&gt; der Cache ist archiviert.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;disabled.png&lt;/span&gt;: Der Cache ist
+vor&#252;bergehend nicht &lt;span class=SpellE&gt;suchbar&lt;/span&gt;.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;owned.png&lt;/span&gt;: Den Cache habe ich
+selber platziert.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;solved.png&lt;/span&gt;: Du hast dem Cache den
+Status &#132;gel&#246;st&#147; gegeben, d.h. an den Koordinaten ist der Cache zu finden.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;bonus.png&lt;/span&gt;: Das ist ein Bonuscache.
+Die Koordinaten ergeben sich durch Suchen eines anderen Cache.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;Das &#252;berlagernde Symbol &lt;span class=SpellE&gt;mu&#223;&lt;/span&gt;
+kleiner oder gleich gro&#223; sein wie das Cachesymbol.&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;Es m&#252;ssen nur die Dateien erstellt werden, die ersetzt werden
+sollen.&lt;/p&gt;
+
 &lt;p class=MsoNormal&gt;Ist keine entsprechende Datei vorhanden, wird das
 Cachewolf-interne Symbol beibehalten.&lt;/p&gt;
 
@@ -122,9 +147,8 @@
 &lt;p class=MsoNormal&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;.&lt;span
-class=SpellE&gt;png&lt;/span&gt;-files in this directory will be loaded as customized
-symbols into &lt;span class=SpellE&gt;Cachewolf&lt;/span&gt; if checked in preferences tab
-more.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+class=SpellE&gt;png&lt;/span&gt;-files in this directory will be loaded as customized symbols
+into &lt;span class=SpellE&gt;Cachewolf&lt;/span&gt; if checked in preferences tab more.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;They're
 supposed to be 16x16 &lt;span class=SpellE&gt;PNGs&lt;/span&gt; or less.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
@@ -132,9 +156,26 @@
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;On the map
 larger symbols are shown, if they exist and the filename ends on size.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;Incorrectly
-named files will be ignored.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;For&nbsp;the
+following&nbsp;states, an&nbsp;extra&nbsp;symbol is&nbsp;superimposed&nbsp;on&nbsp;the&nbsp;map&lt;span
+class=GramE&gt;:&lt;/span&gt;&lt;br&gt;
+&lt;span class=SpellE&gt;found.png&lt;/span&gt;:&nbsp;the&nbsp;cache&nbsp;had&nbsp;been&nbsp;found.&lt;br&gt;
+&lt;span class=SpellE&gt;dnf.png&lt;/span&gt;:&nbsp;the&nbsp;cache&nbsp;was&nbsp;not found&lt;span
+class=GramE&gt;:&lt;/span&gt;&lt;br&gt;
+&lt;span class=SpellE&gt;archived.png&lt;/span&gt;:&nbsp;the cache&nbsp;is&nbsp;archived.&lt;br&gt;
+&lt;span class=SpellE&gt;disabled.png&lt;/span&gt;: The&nbsp;cache&nbsp;is&nbsp;temporarily
+not searchable.&lt;br&gt;
+&lt;span class=SpellE&gt;owned.png&lt;/span&gt;:&nbsp;the&nbsp;cache&nbsp;I&nbsp;have myself
+placed.&lt;br&gt;
+&lt;span class=SpellE&gt;solved.png&lt;/span&gt;: You&nbsp;have&nbsp;the&nbsp;cache&nbsp;status
+&quot;solved&quot;&nbsp;if&nbsp;i.e.&nbsp;at coordinates cache can be&nbsp;found.&lt;br&gt;
+&lt;span class=SpellE&gt;bonus.png&lt;/span&gt;: This is&nbsp;a&nbsp;bonus.&nbsp;The Coordinates&nbsp;result&nbsp;from&nbsp;searching
+another&nbsp;cache.&lt;br&gt;
+The&nbsp;superimposed&nbsp;image&nbsp;must be smaller&nbsp;or be&nbsp;the same
+size&nbsp;as&nbsp;the&nbsp;icon&nbsp;cache.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
+&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;You only
 have to create images for those symbols you want customized.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 

Added: trunk/resources/archived.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/archived.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/bonus.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/bonus.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/disabled.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/disabled.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/dnf.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/dnf.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/resources/found.png
===================================================================
(Binary files differ)

Added: trunk/resources/owned.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/owned.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/solved.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/solved.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1517,7 +1517,7 @@
 		if (level != iconAndTextWPLevel || iconAndTextWP == null || !iconAndTextWP.text.equals(wayPoint)) {
 			switch (level) {
 			case 4:
-				iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm);
+				iconAndTextWP = new IconAndText(CacheType.getTypeImage(CacheType.CW_TYPE_ERROR), wayPoint, fm);
 				break;
 			case 3:
 				iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm);
@@ -1542,7 +1542,6 @@
 		if (!cacheStatus.equals(this.cacheStatus)) {
 			this.cacheStatus = cacheStatus;
 			Global.getProfile().notifyUnsavedChanges(true);
-			this.cacheStatus = cacheStatus;
 			if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null)) {
 				this.mainCache.setCacheStatus(this.getCacheStatus());
 				// change the addi's in setFound

Modified: trunk/src/CacheWolf/CacheType.java
===================================================================
--- trunk/src/CacheWolf/CacheType.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/CacheType.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Image;
@@ -47,11 +47,11 @@
 	public int _FilterPattern; // 2**BitNr in Filter int (does not correspond with BitNr in String)
 	public Image _iconImage;
 	public Image _mapImage;
-	public Image _foundImage;
-	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider,
-			String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName,
-			String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos, int filterPattern) {
+	public Image[] _modImage = { null, null, null, null, null, null, null };
 
+	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos,
+			int filterPattern) {
+
 		_cwMappedCType = cwMappedCType;
 		_cwCType = cwCType;
 		_cwCGroup = cwCGroup;
@@ -70,19 +70,17 @@
 		_FilterStringPos = filterStringPos;
 		_FilterPattern = filterPattern;
 		if (!_imageName.equals(&quot;&quot;)) {
-			_iconImage=new Image(_imageName);
-			_mapImage=_iconImage;
-			_foundImage=new Image(&quot;found.png&quot;);
+			_iconImage = new Image(_imageName);
+			_mapImage = _iconImage;
 		}
 	}
 }
 
-
 /**
  * Handles all aspects of converting cache type information
  * from and to the various im- and exporters ...
  * converting legacy profiles to current standard
- *
+ * 
  * Do not instantiate this class, only use it in a static way
  */
 public final class CacheType {
@@ -112,7 +110,7 @@
 	public static final byte CW_TYPE_WEBCAM = 11;
 	/** locationless cache (GC) */
 	public static final byte CW_TYPE_LOCATIONLESS = 12;
-	/** CITO cache (GC)*/
+	/** CITO cache (GC) */
 	public static final byte CW_TYPE_CITO = 13;
 	/** Mega Event Cache (GC) */
 	public static final byte CW_TYPE_MEGA_EVENT = 100;
@@ -134,88 +132,103 @@
 	public static final byte CW_TYPE_REFERENCE = 55;
 	/** unrecognized cache type or missing information */
 	public static final byte CW_TYPE_ERROR = -1;
-	String[] ggpx={&quot;Geocache|Custom&quot;,&quot;Custom&quot;,&quot;Custom&quot;,&quot;&quot;};
+	String[] ggpx = { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; };
+	private static final byte found = 0;
+	private static final byte archived = 1;
+	private static final byte disabled = 2;
+	private static final byte solved = 3;
+	private static final byte bonus = 4;
+	private static final byte owned = 5;
+	private static final byte dnf = 6;
+	//
 	private static final CTyp[] cTypRef = {
-		// custom waypoints
-		new CTyp(CW_TYPE_CUSTOM,CW_TYPE_CUSTOM,'P',&quot;0&quot;,&quot;&quot;,&quot;&quot;,(byte) -128,'C',&quot;typeCustom.png&quot;,new String[] {&quot;Geocache|Custom&quot;,&quot;Custom&quot;,&quot;Custom&quot;,&quot;&quot;},1,0,10,0x000100),
-		// Cache waypoints
-		new CTyp(CW_TYPE_TRADITIONAL,CW_TYPE_TRADITIONAL,'C',&quot;2&quot;,&quot;2&quot;,&quot;2&quot;,(byte) -126,'T',&quot;typeTradi.png&quot;,new String[] {&quot;Geocache|Traditional Cache&quot;,&quot;Geocache&quot;,&quot;Traditional Cache&quot;,&quot;Traditional|Classic&quot;},2,1,0,0x000001),
-		new CTyp(CW_TYPE_MULTI,CW_TYPE_MULTI,'C',&quot;3&quot;,&quot;3&quot;,&quot;3&quot;,(byte) -125,'M',&quot;typeMulti.png&quot;,new String[] {&quot;Geocache|Multi-cache&quot;,&quot;Geocache&quot;,&quot;Multi-cache&quot;,&quot;Multi|Offset&quot;},3,2,1,0x000002),
-		new CTyp(CW_TYPE_VIRTUAL,CW_TYPE_VIRTUAL,'C',&quot;4&quot;,&quot;4&quot;,&quot;4&quot;,(byte) -124,'V',&quot;typeVirtual.png&quot;,new String[] {&quot;Geocache|Virtual Cache&quot;,&quot;Geocache&quot;,&quot;Virtual Cache&quot;,&quot;Virtual&quot;},4,3,2,0x000004),
-		new CTyp(CW_TYPE_LETTERBOX,CW_TYPE_LETTERBOX,'C',&quot;5&quot;,&quot;5&quot;,&quot;&quot;,(byte) -123,'L',&quot;typeLetterbox.png&quot;,new String[] {&quot;Geocache|Letterbox Hybrid&quot;,&quot;Geocache&quot;,&quot;Letterbox Hybrid&quot;,&quot;Letterbox&quot;},5,4,3,0x000008),
-		new CTyp(CW_TYPE_EVENT,CW_TYPE_EVENT,'C',&quot;6&quot;,&quot;6&quot;,&quot;6&quot;,(byte) -122,'X',&quot;typeEvent.png&quot;,new String[] {&quot;Geocache|Event Cache&quot;,&quot;Geocache&quot;,&quot;Event Cache&quot;,&quot;Event&quot;},6,5,4,0x000010),
-		new CTyp(CW_TYPE_MEGA_EVENT,CW_TYPE_MEGA_EVENT,'C',&quot;453&quot;,&quot;453&quot;,&quot;&quot;,(byte) 101,'X',&quot;typeMegaevent.png&quot;,new String[] {&quot;Geocache|Mega-Event Cache&quot;,&quot;Geocache&quot;,&quot;Mega-Event Cache&quot;,&quot;Mega&quot;},14,6,9,0x000200),
-		new CTyp(CW_TYPE_WEBCAM,CW_TYPE_WEBCAM,'C',&quot;11&quot;,&quot;11&quot;,&quot;5&quot;,(byte) -117,'W',&quot;typeWebcam.png&quot;,new String[] {&quot;Geocache|Webcam Cache&quot;,&quot;Geocache&quot;,&quot;Webcam Cache&quot;,&quot;Webcam&quot;},11,7,5,0x000020),
-		new CTyp(CW_TYPE_UNKNOWN,CW_TYPE_UNKNOWN,'C',&quot;8&quot;,&quot;8&quot;,&quot;&quot;,(byte) -120,'U',&quot;typeUnknown.png&quot;,new String[] {&quot;Geocache|Unknown Cache&quot;,&quot;Geocache&quot;,&quot;Unknown Cache&quot;,&quot;Mystery&quot;},8,8,6,0x000040),
-		new CTyp(CW_TYPE_LOCATIONLESS,CW_TYPE_LOCATIONLESS,'C',&quot;12&quot;,&quot;12&quot;,&quot;&quot;,(byte) -116,'O',&quot;typeLocless.png&quot;,new String[] {&quot;Geocache|Locationless (Reverse) Cache&quot;,&quot;Geocache&quot;,&quot;Locationless (Reverse) Cache&quot;,&quot;Locationless&quot;},12,9,8,0x000080),
-		new CTyp(CW_TYPE_CITO,CW_TYPE_CITO,'C',&quot;13&quot;,&quot;13&quot;,&quot;&quot;,(byte) -115,'X',&quot;typeCito.png&quot;,new String[] {&quot;Geocache|Cache In Trash Out Event&quot;,&quot;Geocache&quot;,&quot;Cache In Trash Out Event&quot;,&quot;CITO&quot;},13,10,17,0x020000),
-		new CTyp(CW_TYPE_EARTH,CW_TYPE_EARTH,'C',&quot;137&quot;,&quot;137&quot;,&quot;&quot;,(byte) 9,'E',&quot;typeEarth.png&quot;,new String[] {&quot;Geocache|Earthcache&quot;,&quot;Geocache&quot;,&quot;Earthcache&quot;,&quot;Earth&quot;},18,11,7,0x000400),
-		new CTyp(CW_TYPE_WHEREIGO,CW_TYPE_WHEREIGO,'C',&quot;1858&quot;,&quot;1858&quot;,&quot;&quot;,(byte) 100,'G',&quot;typeWhereigo.png&quot;,new String[] {&quot;Geocache|Wherigo Cache&quot;,&quot;Geocache&quot;,&quot;Wherigo Cache&quot;,&quot;Wherigo&quot;},15,12,18,0x040000),
-		// additional waypoints
-		new CTyp(CW_TYPE_PARKING,CW_TYPE_PARKING,'A',&quot;50&quot;,&quot;&quot;,&quot;&quot;,(byte) -78,'P',&quot;typeParking.png&quot;,new String[] {&quot;Waypoint|Parking Area&quot;,&quot;Parking Area&quot;,&quot;Parking Area&quot;,&quot;&quot;},50,13,11,0x000800),
-		new CTyp(CW_TYPE_STAGE,CW_TYPE_STAGE,'A',&quot;51&quot;,&quot;&quot;,&quot;&quot;,(byte) -77,'S',&quot;typeStage.png&quot;,new String[] {&quot;Waypoint|Stages of a Multicache&quot;,&quot;Stages of a Multicache&quot;,&quot;Stages of a Multicache&quot;,&quot;&quot;},51,14,12,0x001000),
-		new CTyp(CW_TYPE_QUESTION,CW_TYPE_QUESTION,'A',&quot;52&quot;,&quot;&quot;,&quot;&quot;,(byte) -76,'Q',&quot;typeQuestion.png&quot;,new String[] {&quot;Waypoint|Question to Answer&quot;,&quot;Question to Answer&quot;,&quot;Question to Answer&quot;,&quot;&quot;},52,15,13,0x002000),
-		new CTyp(CW_TYPE_FINAL,CW_TYPE_FINAL,'A',&quot;53&quot;,&quot;&quot;,&quot;&quot;,(byte) -75,'F',&quot;typeFinal.png&quot;,new String[] {&quot;Waypoint|Final Location&quot;,&quot;Final Location&quot;,&quot;Final Location&quot;,&quot;&quot;},53,16,14,0x004000),
-		new CTyp(CW_TYPE_TRAILHEAD,CW_TYPE_TRAILHEAD,'A',&quot;54&quot;,&quot;&quot;,&quot;&quot;,(byte) -74,'H',&quot;typeTrailhead.png&quot;,new String[] {&quot;Waypoint|Trailhead&quot;,&quot;Trailhead&quot;,&quot;Trailhead&quot;,&quot;&quot;},54,17,15,0x008000),
-		new CTyp(CW_TYPE_REFERENCE,CW_TYPE_REFERENCE,'A',&quot;55&quot;,&quot;&quot;,&quot;&quot;,(byte) -73,'R',&quot;typeReference.png&quot;,new String[] {&quot;Waypoint|Reference Point&quot;,&quot;Reference Point&quot;,&quot;Reference Point&quot;,&quot;&quot;},55,18,16,0x010000),
-		// error on waypoint
-		new CTyp(CW_TYPE_ERROR,CW_TYPE_ERROR,'E',&quot;&quot;,&quot;&quot;,&quot;&quot;,(byte) -1,'-',&quot;guiError.png&quot;,new String[] {&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},49,-1,-1,0),
-        // mapped types (recognized on input from gpx or download-spider / or cw - version)
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 1,'C',&quot;&quot;,&quot;&quot;,&quot;1&quot;,(byte) -1,'U',&quot;&quot;,new String[] {&quot;Geocache|Other&quot;,&quot;Geocache&quot;,&quot;Other&quot;,&quot;Other&quot;},21,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 7,'C',&quot;7&quot;,&quot;&quot;,&quot;7&quot;,(byte) -121,'U',&quot;&quot;,new String[] {&quot;Geocache|Quiz&quot;,&quot;Geocache&quot;,&quot;Quiz&quot;,&quot;Quiz&quot;},7,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 9,'C',&quot;9&quot;,&quot;&quot;,&quot;9&quot;,(byte) -119,'U',&quot;&quot;,new String[] {&quot;Geocache|Moving&quot;,&quot;Geocache&quot;,&quot;Moving&quot;,&quot;Moving&quot;},9,-1,-1,0),
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 10,'C',&quot;10&quot;,&quot;&quot;,&quot;10&quot;,(byte) -118,'U',&quot;&quot;,new String[] {&quot;Geocache|DriveIn&quot;,&quot;Geocache&quot;,&quot;DriveIn&quot;,&quot;DriveIn&quot;},10,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 14,'C',&quot;&quot;,&quot;3653&quot;,&quot;&quot;,(byte) -1,'X',&quot;&quot;,new String[] {&quot;Geocache|Lost and Found Event Cache&quot;,&quot;Geocache&quot;,&quot;Lost and Found Event Cache&quot;,&quot;&quot;},6,-1,-1,0),
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 102,'C',&quot;&quot;,&quot;9&quot;,&quot;&quot;,(byte) -1,'T',&quot;&quot;,new String[] {&quot;Geocache|Project APE Cache&quot;,&quot;Geocache&quot;,&quot;Project APE Cache&quot;,&quot;APE&quot;},16,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 103,'C',&quot;&quot;,&quot;1304&quot;,&quot;&quot;,(byte) -1,'X',&quot;&quot;,new String[] {&quot;Geocache|GPS Adventures Exhibit&quot;,&quot;Geocache&quot;,&quot;GPS Adventures Exhibit&quot;,&quot;MAZE&quot;},17,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 108,'C',&quot;&quot;,&quot;&quot;,&quot;8&quot;,(byte) -1,'U',&quot;&quot;,new String[] {&quot;only on OC download&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},19,-1,-1,0),
-		new CTyp(CW_TYPE_WHEREIGO,(byte) 15,'C',&quot;&quot;,&quot;&quot;,&quot;&quot;,(byte) -62,'G',&quot;&quot;,new String[] {&quot;Hack for V2 Typ&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},-1,-1,-1,0),
-	};
+			// custom waypoints
+			new CTyp(CW_TYPE_CUSTOM, CW_TYPE_CUSTOM, 'P', &quot;0&quot;, &quot;&quot;, &quot;&quot;, (byte) -128, 'C', &quot;typeCustom.png&quot;, new String[] { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; }, 1, 0, 10, 0x000100),
+			// Cache waypoints
+			new CTyp(CW_TYPE_TRADITIONAL, CW_TYPE_TRADITIONAL, 'C', &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, (byte) -126, 'T', &quot;typeTradi.png&quot;, new String[] { &quot;Geocache|Traditional Cache&quot;, &quot;Geocache&quot;, &quot;Traditional Cache&quot;, &quot;Traditional|Classic&quot; }, 2, 1, 0, 0x000001),
+			new CTyp(CW_TYPE_MULTI, CW_TYPE_MULTI, 'C', &quot;3&quot;, &quot;3&quot;, &quot;3&quot;, (byte) -125, 'M', &quot;typeMulti.png&quot;, new String[] { &quot;Geocache|Multi-cache&quot;, &quot;Geocache&quot;, &quot;Multi-cache&quot;, &quot;Multi|Offset&quot; }, 3, 2, 1, 0x000002),
+			new CTyp(CW_TYPE_VIRTUAL, CW_TYPE_VIRTUAL, 'C', &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, (byte) -124, 'V', &quot;typeVirtual.png&quot;, new String[] { &quot;Geocache|Virtual Cache&quot;, &quot;Geocache&quot;, &quot;Virtual Cache&quot;, &quot;Virtual&quot; }, 4, 3, 2, 0x000004),
+			new CTyp(CW_TYPE_LETTERBOX, CW_TYPE_LETTERBOX, 'C', &quot;5&quot;, &quot;5&quot;, &quot;&quot;, (byte) -123, 'L', &quot;typeLetterbox.png&quot;, new String[] { &quot;Geocache|Letterbox Hybrid&quot;, &quot;Geocache&quot;, &quot;Letterbox Hybrid&quot;, &quot;Letterbox&quot; }, 5, 4, 3, 0x000008),
+			new CTyp(CW_TYPE_EVENT, CW_TYPE_EVENT, 'C', &quot;6&quot;, &quot;6&quot;, &quot;6&quot;, (byte) -122, 'X', &quot;typeEvent.png&quot;, new String[] { &quot;Geocache|Event Cache&quot;, &quot;Geocache&quot;, &quot;Event Cache&quot;, &quot;Event&quot; }, 6, 5, 4, 0x000010),
+			new CTyp(CW_TYPE_MEGA_EVENT, CW_TYPE_MEGA_EVENT, 'C', &quot;453&quot;, &quot;453&quot;, &quot;&quot;, (byte) 101, 'X', &quot;typeMegaevent.png&quot;, new String[] { &quot;Geocache|Mega-Event Cache&quot;, &quot;Geocache&quot;, &quot;Mega-Event Cache&quot;, &quot;Mega&quot; }, 14, 6, 9, 0x000200),
+			new CTyp(CW_TYPE_WEBCAM, CW_TYPE_WEBCAM, 'C', &quot;11&quot;, &quot;11&quot;, &quot;5&quot;, (byte) -117, 'W', &quot;typeWebcam.png&quot;, new String[] { &quot;Geocache|Webcam Cache&quot;, &quot;Geocache&quot;, &quot;Webcam Cache&quot;, &quot;Webcam&quot; }, 11, 7, 5, 0x000020),
+			new CTyp(CW_TYPE_UNKNOWN, CW_TYPE_UNKNOWN, 'C', &quot;8&quot;, &quot;8&quot;, &quot;&quot;, (byte) -120, 'U', &quot;typeUnknown.png&quot;, new String[] { &quot;Geocache|Unknown Cache&quot;, &quot;Geocache&quot;, &quot;Unknown Cache&quot;, &quot;Mystery&quot; }, 8, 8, 6, 0x000040),
+			new CTyp(CW_TYPE_LOCATIONLESS, CW_TYPE_LOCATIONLESS, 'C', &quot;12&quot;, &quot;12&quot;, &quot;&quot;, (byte) -116, 'O', &quot;typeLocless.png&quot;, new String[] { &quot;Geocache|Locationless (Reverse) Cache&quot;, &quot;Geocache&quot;, &quot;Locationless (Reverse) Cache&quot;, &quot;Locationless&quot; }, 12, 9, 8,
+					0x000080),
+			new CTyp(CW_TYPE_CITO, CW_TYPE_CITO, 'C', &quot;13&quot;, &quot;13&quot;, &quot;&quot;, (byte) -115, 'X', &quot;typeCito.png&quot;, new String[] { &quot;Geocache|Cache In Trash Out Event&quot;, &quot;Geocache&quot;, &quot;Cache In Trash Out Event&quot;, &quot;CITO&quot; }, 13, 10, 17, 0x020000),
+			new CTyp(CW_TYPE_EARTH, CW_TYPE_EARTH, 'C', &quot;137&quot;, &quot;137&quot;, &quot;&quot;, (byte) 9, 'E', &quot;typeEarth.png&quot;, new String[] { &quot;Geocache|Earthcache&quot;, &quot;Geocache&quot;, &quot;Earthcache&quot;, &quot;Earth&quot; }, 18, 11, 7, 0x000400),
+			new CTyp(CW_TYPE_WHEREIGO, CW_TYPE_WHEREIGO, 'C', &quot;1858&quot;, &quot;1858&quot;, &quot;&quot;, (byte) 100, 'G', &quot;typeWhereigo.png&quot;, new String[] { &quot;Geocache|Wherigo Cache&quot;, &quot;Geocache&quot;, &quot;Wherigo Cache&quot;, &quot;Wherigo&quot; }, 15, 12, 18, 0x040000),
+			// additional waypoints
+			new CTyp(CW_TYPE_PARKING, CW_TYPE_PARKING, 'A', &quot;50&quot;, &quot;&quot;, &quot;&quot;, (byte) -78, 'P', &quot;typeParking.png&quot;, new String[] { &quot;Waypoint|Parking Area&quot;, &quot;Parking Area&quot;, &quot;Parking Area&quot;, &quot;&quot; }, 50, 13, 11, 0x000800),
+			new CTyp(CW_TYPE_STAGE, CW_TYPE_STAGE, 'A', &quot;51&quot;, &quot;&quot;, &quot;&quot;, (byte) -77, 'S', &quot;typeStage.png&quot;, new String[] { &quot;Waypoint|Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;&quot; }, 51, 14, 12, 0x001000),
+			new CTyp(CW_TYPE_QUESTION, CW_TYPE_QUESTION, 'A', &quot;52&quot;, &quot;&quot;, &quot;&quot;, (byte) -76, 'Q', &quot;typeQuestion.png&quot;, new String[] { &quot;Waypoint|Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;&quot; }, 52, 15, 13, 0x002000),
+			new CTyp(CW_TYPE_FINAL, CW_TYPE_FINAL, 'A', &quot;53&quot;, &quot;&quot;, &quot;&quot;, (byte) -75, 'F', &quot;typeFinal.png&quot;, new String[] { &quot;Waypoint|Final Location&quot;, &quot;Final Location&quot;, &quot;Final Location&quot;, &quot;&quot; }, 53, 16, 14, 0x004000),
+			new CTyp(CW_TYPE_TRAILHEAD, CW_TYPE_TRAILHEAD, 'A', &quot;54&quot;, &quot;&quot;, &quot;&quot;, (byte) -74, 'H', &quot;typeTrailhead.png&quot;, new String[] { &quot;Waypoint|Trailhead&quot;, &quot;Trailhead&quot;, &quot;Trailhead&quot;, &quot;&quot; }, 54, 17, 15, 0x008000),
+			new CTyp(CW_TYPE_REFERENCE, CW_TYPE_REFERENCE, 'A', &quot;55&quot;, &quot;&quot;, &quot;&quot;, (byte) -73, 'R', &quot;typeReference.png&quot;, new String[] { &quot;Waypoint|Reference Point&quot;, &quot;Reference Point&quot;, &quot;Reference Point&quot;, &quot;&quot; }, 55, 18, 16, 0x010000),
+			// error on waypoint
+			new CTyp(CW_TYPE_ERROR, CW_TYPE_ERROR, 'E', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -1, '-', &quot;guiError.png&quot;, new String[] { &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 49, -1, -1, 0),
+			// mapped types (recognized on input from gpx or download-spider / or cw - version)
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 1, 'C', &quot;&quot;, &quot;&quot;, &quot;1&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;Geocache|Other&quot;, &quot;Geocache&quot;, &quot;Other&quot;, &quot;Other&quot; }, 21, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 7, 'C', &quot;7&quot;, &quot;&quot;, &quot;7&quot;, (byte) -121, 'U', &quot;&quot;, new String[] { &quot;Geocache|Quiz&quot;, &quot;Geocache&quot;, &quot;Quiz&quot;, &quot;Quiz&quot; }, 7, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 9, 'C', &quot;9&quot;, &quot;&quot;, &quot;9&quot;, (byte) -119, 'U', &quot;&quot;, new String[] { &quot;Geocache|Moving&quot;, &quot;Geocache&quot;, &quot;Moving&quot;, &quot;Moving&quot; }, 9, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 10, 'C', &quot;10&quot;, &quot;&quot;, &quot;10&quot;, (byte) -118, 'U', &quot;&quot;, new String[] { &quot;Geocache|DriveIn&quot;, &quot;Geocache&quot;, &quot;DriveIn&quot;, &quot;DriveIn&quot; }, 10, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 14, 'C', &quot;&quot;, &quot;3653&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|Lost and Found Event Cache&quot;, &quot;Geocache&quot;, &quot;Lost and Found Event Cache&quot;, &quot;&quot; }, 6, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 102, 'C', &quot;&quot;, &quot;9&quot;, &quot;&quot;, (byte) -1, 'T', &quot;&quot;, new String[] { &quot;Geocache|Project APE Cache&quot;, &quot;Geocache&quot;, &quot;Project APE Cache&quot;, &quot;APE&quot; }, 16, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 103, 'C', &quot;&quot;, &quot;1304&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|GPS Adventures Exhibit&quot;, &quot;Geocache&quot;, &quot;GPS Adventures Exhibit&quot;, &quot;MAZE&quot; }, 17, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 108, 'C', &quot;&quot;, &quot;&quot;, &quot;8&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;only on OC download&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 19, -1, -1, 0),
+			new CTyp(CW_TYPE_WHEREIGO, (byte) 15, 'C', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -62, 'G', &quot;&quot;, new String[] { &quot;Hack for V2 Typ&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, -1, -1, -1, 0), };
 	// public static final int anzCacheTyps=cTypRef.length;
-	public static final byte maxCWCType=110;
-    static final byte[] Ref_Index = new byte[maxCWCType];
+	public static final byte maxCWCType = 110;
+	static final byte[] Ref_Index = new byte[maxCWCType];
 	static {
 		// +1 cause error is -1 and array starts at 0
-	  for (byte i = (byte) (cTypRef.length - 1); i&gt;=0; i--) {
-		  Ref_Index[1 + cTypRef[i]._cwCType]= i;
-	   }
+		for (byte i = (byte) (cTypRef.length - 1); i &gt;= 0; i--) {
+			Ref_Index[1 + cTypRef[i]._cwCType] = i;
+		}
 	}
+
 	public static byte Ref_Index(final byte type) {
-		final byte ret=Ref_Index[cTypRef[Ref_Index[type+1]]._cwMappedCType + 1];
+		final byte ret = Ref_Index[cTypRef[Ref_Index[type + 1]]._cwMappedCType + 1];
 		return ret;
 	}
 
-
-
 	/**
 	 * check if a given waypoint type is an additional waypoint
-	 * @param type waypoint type to check
+	 * 
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an additional waypoint, false otherwise
 	 */
 	public static boolean isAddiWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'A';
 	}
+
 	/**
 	 * check if a given waypoint type is an cache waypoint
-	 * @param type waypoint type to check
+	 * 
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Cache waypoint, false otherwise
 	 */
 	public static boolean isCacheWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'C';
 	}
+
 	/**
 	 * check if a given waypoint type is an Custom waypoint
-	 * @param type waypoint type to check
+	 * 
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Custom waypint, false otherwise
 	 */
 	public static boolean isCustomWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'P';
 	}
 
-
 	// done for DetailsPanel.java and KML- and TomTom-Exporter
 	/**
 	 * create list of cache types to be shown in GUI drop down lists
+	 * 
 	 * @return list of cache types to be shown in GUI drop down list
 	 * @see guiSelect2Cw
 	 * @see cw2GuiSelect
@@ -224,36 +237,47 @@
 		int j = 0;
 		for (int i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder &gt; j) {
-				j=cTypRef[i]._GUIOrder;
+				j = cTypRef[i]._GUIOrder;
 			}
 		}
-		final String[] ret = new String[j+1];
+		final String[] ret = new String[j + 1];
 		for (int i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder &gt; -1) {
-				ret[cTypRef[i]._GUIOrder]=MyLocale.getMsg(cTypRef[i]._msgNrCTypeName,&quot;&quot;);
+				ret[cTypRef[i]._GUIOrder] = MyLocale.getMsg(cTypRef[i]._msgNrCTypeName, &quot;&quot;);
 			}
 		}
 		return ret;
 	}
+
 	/**
 	 * translate GUI drop down index selection back to internally stored type
-	 * @param selection index value from drop down list
+	 * 
+	 * @param selection
+	 *            index value from drop down list
 	 * @return internal type
-	 * @throws IllegalArgumentException if &lt;code&gt;selection&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;selection&lt;/code&gt; can not be matched
 	 * @see guiTypeStrings
 	 * @see cw2GuiSelect
 	 */
 	public static byte guiSelect2Cw(final int selection) {
-		for (byte i=0; i&lt;cTypRef.length; i++) {
-			if (cTypRef[i]._GUIOrder == selection) {return cTypRef[i]._cwCType;};
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._GUIOrder == selection) {
+				return cTypRef[i]._cwCType;
+			}
+			;
 		}
 		return -1;
 	}
+
 	/**
 	 * translate cache type to position of index to highlight in GUI cache type drop down list
-	 * @param typeId internal id of cache type
+	 * 
+	 * @param typeId
+	 *            internal id of cache type
 	 * @return index of the cache type in GUI list
-	 * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;id&lt;/code&gt; can not be matched
 	 * @see guiTypeStrings
 	 * @see guiSelect2Cw
 	 */
@@ -261,25 +285,32 @@
 		return cTypRef[Ref_Index(typeId)]._GUIOrder;
 	}
 
-
-
 	/**
 	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
-	 * @param gpxType type information found in GPX
+	 * 
+	 * @param gpxType
+	 *            type information found in GPX
 	 * @return internal cache type
 	 */
 	public static byte gpxType2CwType(final String gpxType) throws IllegalArgumentException {
-		for (byte i=0; i&lt;cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
-		for (byte i=0; i&lt;cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
 		final String lowerCaseGPXType = gpxType.toLowerCase();
-		for (byte i=0; i&lt;cTypRef.length; i++) {
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._gpxAlternativeWptTypTags.toLowerCase().indexOf(lowerCaseGPXType) != -1) {
 				return cTypRef[i]._cwMappedCType;
-			};
+			}
+			;
 		}
 		// TODO extend definition of _gpxAlternativeWptTypTags for all cases of Mystery
 		// old code was : if (!(gpxType.indexOf(&quot;Mystery&quot;)==-1)) return CW_TYPE_UNKNOWN;
@@ -288,9 +319,12 @@
 
 	/**
 	 * convert the cache type information from an OC XML import to internal cache type
-	 * @param ocType cache type found in OC XML
+	 * 
+	 * @param ocType
+	 *            cache type found in OC XML
 	 * @return internal cache type
-	 * @throws IllegalArgumentException if &lt;code&gt;ocType&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;ocType&lt;/code&gt; can not be matched
 	 */
 	public static byte ocType2CwType(final String ocType) {
 		for (int i = 0; i &lt; cTypRef.length; i++) {
@@ -300,11 +334,15 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert type information discovered by GC spider to internal type information
-	 * @param gcType type information from GC spider
+	 * 
+	 * @param gcType
+	 *            type information from GC spider
 	 * @return internal representation of cache type
-	 * @throws IllegalArgumentException if &lt;code&gt;gcType&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;gcType&lt;/code&gt; can not be matched
 	 */
 	public static byte gcSpider2CwType(final String gcType) {
 		for (int i = 0; i &lt; cTypRef.length; i++) {
@@ -314,9 +352,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version1 type information to current values
-	 * @param type version1 cache type information
+	 * 
+	 * @param type
+	 *            version1 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v1 file version compatibility is abandoned
 	 */
@@ -328,9 +369,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version2 type information to current values
-	 * @param type version2 cache type information
+	 * 
+	 * @param type
+	 *            version2 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v2 file version compatibility is abandoned
 	 */
@@ -343,128 +387,218 @@
 		return -1;
 	}
 
-
-
 	/**
 	 * translate cache type to a short version for compact exporters or &quot;smart&quot; cache names.
-	 * @param typeId CacheWolf internal type information
+	 * 
+	 * @param typeId
+	 *            CacheWolf internal type information
 	 * @return abbreviation of cache type
 	 */
 	public static String getExportShortId(final byte typeId) {
-		return &quot;&quot;+cTypRef[Ref_Index(typeId)]._gpxShortCType;
+		return &quot;&quot; + cTypRef[Ref_Index(typeId)]._gpxShortCType;
 	}
+
 	/**
 	 * map cache types to images
-	 * @param typeId internal cache type id
+	 * 
+	 * @param typeId
+	 *            internal cache type id
 	 * @return non qualified name of image
 	 */
 	public static String typeImageForId(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._imageName;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com &lt;type&gt; GPX format
 	 */
 	public static String type2TypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptTypeTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return symb information in GC.com &lt;sym&gt; GPX format
 	 */
 	public static String type2SymTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptSymTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com &lt;groundspeak:type&gt; GPX format
 	 */
 	public static String type2GSTypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptGCextensionTypTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return Gui - string for type
 	 */
 	public static String type2Gui(final byte typeId) {
-		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName,&quot;&quot;);
+		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName, &quot;&quot;);
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 * 
+	 * @param typeId
+	 *            internal cache type id
 	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
 	 */
 	public static Image getTypeImage(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 * 
+	 * @param typeId
+	 *            internal cache type id
 	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
 	 */
-	public static Image getMapImage(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._mapImage;
+	public static Image getMapImage(CacheHolder ch) {
+		byte typeId = ch.getType();
+		Image im = cTypRef[Ref_Index(typeId)]._mapImage;
+		if (ch.is_found()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[found] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[found] = newOverlayedImage(im, GuiImageBroker.found);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[found];
+		} else if (ch.is_archived()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[archived] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[archived] = newOverlayedImage(im, GuiImageBroker.archived);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[archived];
+		} else if (!ch.is_available()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[disabled] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[disabled] = newOverlayedImage(im, GuiImageBroker.disabled);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[disabled];
+		} else if (ch.is_owned()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[owned] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[owned] = newOverlayedImage(im, GuiImageBroker.owned);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[owned];
+		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(362, &quot;solved&quot;))) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[solved] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[solved] = newOverlayedImage(im, GuiImageBroker.solved);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[solved];
+		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(319, &quot;Not Found&quot;))) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[dnf] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[dnf] = newOverlayedImage(im, GuiImageBroker.dnf);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[dnf];
+		} else if (ch.getCacheName().toLowerCase().indexOf(&quot;bonus&quot;) &gt; -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[bonus] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[bonus] = newOverlayedImage(im, GuiImageBroker.bonus);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[bonus];
+		}
+		return im;
 	}
 
-	public static Image getFoundImage(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._foundImage;
-	}
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 * 
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setTypeImage(final byte id, final Image iconImage) {
 		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._iconImage.free();
-		cTypRef[Ref_Index(id)]._iconImage=iconImage;
+		cTypRef[Ref_Index(id)]._iconImage = iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 * 
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setMapImage(final byte id, final Image mapImage) {
 		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._mapImage.free();
-		cTypRef[Ref_Index(id)]._mapImage=mapImage;
+		cTypRef[Ref_Index(id)]._mapImage = mapImage;
 	}
-	public static void setFoundImage(final byte id, final Image foundImage) {
-		cTypRef[Ref_Index(id)]._foundImage=foundImage;
-	}
 
-
 	// TODO do it better in Version 4
 	public static int getCacheTypePattern(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._FilterPattern;
 	}
+
 	public static int Type_FilterString2Type_FilterPattern(final String Type_FilterString) {
 		int typeMatchPattern = 0;
 		for (int i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._FilterStringPos &gt; -1) {
 				if (Type_FilterString.charAt(cTypRef[i]._FilterStringPos) == '1') {
-					typeMatchPattern|=cTypRef[i]._FilterPattern;
+					typeMatchPattern |= cTypRef[i]._FilterPattern;
 				}
 			}
 		}
 		return typeMatchPattern;
 	}
+
 	public static boolean hasTypeMatchPattern(final int typeMatchPattern) {
 		return typeMatchPattern != 0;
 	}
+
 	public static boolean hasMainTypeMatchPattern(final int typeMatchPattern) {
 		int TYPE_MAIN = 0;
 		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P' ) {
-				TYPE_MAIN|=cTypRef[i]._FilterPattern;
+			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P') {
+				TYPE_MAIN |= cTypRef[i]._FilterPattern;
 			}
 		}
 		return (typeMatchPattern &amp; TYPE_MAIN) != 0;
 	}
 
+	private static Image newOverlayedImage(Image imsrc, Image imovl) {
+		// Overlay added at topleft
+		int srcWidth = imsrc.getWidth();
+		int srcHeight = imsrc.getHeight();
+		int ovlWidth = imovl.getWidth();
+		int ovlHeight = imovl.getHeight();
+		if (srcWidth &lt; ovlWidth || srcHeight &lt; ovlHeight)
+			return imsrc;
+		int[] srcPixels = imsrc.getPixels(null, 0, 0, 0, srcWidth, srcHeight, 0);
+		int[] ovlPixels = imovl.getPixels(null, 0, 0, 0, ovlWidth, ovlHeight, 0);
+		int offsrc;
+		int offovl = 0;
+		for (int y = 0; y &lt; ovlHeight; y++) { // top down
+			offsrc = y * srcWidth;
+			for (int x = 0; x &lt; ovlWidth; x++) {
+				int alphaval = (ovlPixels[offovl] &gt;&gt; 24) &amp; 0xff;
+				if (alphaval &gt; 0) {
+					srcPixels[offsrc] = ovlPixels[offovl];
+				}
+				offovl++;
+				offsrc++;
+			}
+		}
+		Image modImage = new Image(imsrc, 0);
+		modImage.setPixels(srcPixels, 0, 0, 0, srcWidth, srcHeight, 0);
+		return modImage;
+	}
+
 	// TODO it for OCXMLImporterScreen and FilterScreen ?
 }

Modified: trunk/src/CacheWolf/GuiImageBroker.java
===================================================================
--- trunk/src/CacheWolf/GuiImageBroker.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/GuiImageBroker.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -31,43 +31,23 @@
 
 /**
  * hold preloaded versions of GUI images in a single place
- *
+ * 
  * Do not instantiate this class, only use it in a static way.
  */
 
 public final class GuiImageBroker {
+	public static Image found = new Image(&quot;found.png&quot;);
+	public static Image disabled = new Image(&quot;disabled.png&quot;); // available
+	public static Image archived = new Image(&quot;archived.png&quot;);
+	public static Image solved = new Image(&quot;solved.png&quot;);
+	public static Image bonus = new Image(&quot;bonus.png&quot;);
+	public static Image owned = new Image(&quot;selected.png&quot;);
+	public static Image dnf = new Image(&quot;dnf.png&quot;);
 
-	// TODO: check with Image and mImage
-
-	/** image to be displayed in case of error */
-	public static Image imageError = new Image(&quot;guiError.png&quot;);
-
-	/**
-	 * images to be displayed for cache types in GUI
-	 * @see getTypeImage
-	 * @see CacheTypes
-	 */
-
-	/** thou shallst not instantiate this object */
 	private GuiImageBroker() {
 		// Noting to do
 	}
 
-	public static Image getTypeImage(byte typeId,boolean map, boolean found) {
-		if (!map) {
-			return CacheType.getTypeImage(typeId);
-		}
-		else {
-			if (found) {
-				return CacheType.getFoundImage(typeId);
-			}
-			else {
-				return CacheType.getMapImage(typeId);
-			}
-		}
-	}
-
-
 	/**
 	 * Replaces the build-in symbols by images stored in /symbols:
 	 * If the sub directory symbols exists in CW-directory *.png-files
@@ -78,47 +58,56 @@
 	 * Images are NOT checked for size etc.
 	 */
 	public static void customizedSymbols() {
-		final String sdir=&quot;/symbols/&quot;;
-		final FileBugfix dir=new FileBugfix(FileBase.getProgramDirectory()+sdir);
-		if (dir.isDirectory()){
+		final String sdir = &quot;/symbols/&quot;;
+		final FileBugfix dir = new FileBugfix(FileBase.getProgramDirectory() + sdir);
+		if (dir.isDirectory()) {
 			int id;
-			boolean size=false;
-			boolean found=false;
+			boolean size = false;
 			String name = &quot;&quot;;
-			String [] pngFiles;
-			pngFiles=dir.list(&quot;*.png&quot;,0);
-			Global.getPref().log(&quot;Nr. of own symbols (png-files) : &quot;+pngFiles.length);
-			for (int i=0; i&lt;pngFiles.length; i++) {
-				name = pngFiles[i].substring(0,pngFiles[i].length()-4);
-				if (name.toLowerCase().endsWith(&quot;size&quot;)){
-					size=true;
-					name=name.substring(0,name.length()-4);
+			String[] pngFiles;
+			pngFiles = dir.list(&quot;*.png&quot;, FileBase.LIST_FILES_ONLY);
+			Global.getPref().log(&quot;Nr. of own symbols (png-files) : &quot; + pngFiles.length);
+			for (int i = 0; i &lt; pngFiles.length; i++) {
+				name = pngFiles[i].substring(0, pngFiles[i].length() - 4).toLowerCase();
+				if (name.endsWith(&quot;size&quot;)) {
+					size = true;
+					name = name.substring(0, name.length() - 4);
+				} else {
+					if (name.equals(&quot;disabled&quot;)) {
+						disabled = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;archived&quot;)) {
+						archived = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;solved&quot;)) {
+						solved = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;bonus&quot;)) {
+						bonus = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;owned&quot;)) {
+						owned = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;dnf&quot;)) {
+						dnf = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;found&quot;)) {
+						found = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
 				}
-				if (name.toLowerCase().endsWith(&quot;found&quot;)){
-					found=true;
-					name=name.substring(0,name.length()-5);
-				}
 				try {
 					id = Integer.parseInt(name);
+				} catch (final Exception E) {
+					id = -1; // filename invalid for symbols
 				}
-				catch (final Exception E){
-					id = -1; //filename invalid for symbols
-				}
-				if (0&lt;=id &amp;&amp; id&lt;=CacheType.maxCWCType){
-					final String s=FileBase.getProgramDirectory()+sdir+pngFiles[i];
-					Global.getPref().log(&quot;own symbol: &quot;+(i+1)+&quot; = &quot;+pngFiles[i]);
-					if (size){
-						if (found) {
-							CacheType.setFoundImage((byte) id, new Image(s));
-						}
-						else {
-							CacheType.setMapImage((byte) id, new Image(s));
-						}
-						size=false;
-						found=false;
+				if (0 &lt;= id &amp;&amp; id &lt;= CacheType.maxCWCType) {
+					final String s = FileBase.getProgramDirectory() + sdir + pngFiles[i];
+					Global.getPref().log(&quot;own symbol: &quot; + (i + 1) + &quot; = &quot; + pngFiles[i]);
+					if (size) {
+						CacheType.setMapImage((byte) id, new Image(s));
+						size = false;
 
-					}
-					else{
+					} else {
 						CacheType.setTypeImage((byte) id, new Image(s));
 					}
 				}

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/RadarPanel.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Font;
@@ -40,16 +41,16 @@
 import ewe.ui.mButton;
 
 /**
-*	The radar panel. Displays the caches around a centre point.&lt;br&gt;
-*	Handles scaling as well as toggling the different views in the radar panel.&lt;br&gt;
-*	Also handles clicking on a cache.&lt;br&gt;
-*	Class ID=500
-*/
-public class RadarPanel extends CellPanel{
+ * The radar panel. Displays the caches around a centre point.&lt;br&gt;
+ * Handles scaling as well as toggling the different views in the radar panel.&lt;br&gt;
+ * Also handles clicking on a cache.&lt;br&gt;
+ * Class ID=500
+ */
+public class RadarPanel extends CellPanel {
 	mButton btMinus = new mButton(&quot;   -   &quot;);
 	mButton btToggle = new mButton(&quot;Toggle&quot;);
 	mButton btPlus = new mButton(&quot;   +   &quot;);
-	int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
+	int toggleMod = 0; // 0 = cacheicons, 1= cacheWP, 2 = cacheNames
 	Preferences pref;
 	CacheDB cacheDB;
 	myInteractivePanel iActP;
@@ -60,54 +61,55 @@
 	CacheHolder selectedWaypoint = null;
 	MainTab mt;
 	boolean penMoving = false;
-	int x1,y1,x2,y2 = 0;
-	boolean reCenterImage=true;
+	int x1, y1, x2, y2 = 0;
+	boolean reCenterImage = true;
+
 	/**
-	* Constructor for the radar panel.
-	* Loads images, sets up the interactive panel and
-	* &quot;navigation&quot; buttons.
-	*/
-	public RadarPanel(){
+	 * Constructor for the radar panel.
+	 * Loads images, sets up the interactive panel and
+	 * &quot;navigation&quot; buttons.
+	 */
+	public RadarPanel() {
 		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		final CellPanel cp = new CellPanel();
-		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
-		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
-		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
+		cp.addNext(btMinus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.WEST));
+		cp.addNext(btToggle, CellConstants.HSTRETCH, CellConstants.FILL);
+		cp.addLast(btPlus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.EAST));
 		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
 	}
 
-	public void setMainTab(MainTab tb){
+	public void setMainTab(MainTab tb) {
 		mt = tb;
 		iActP.setMainTab(tb);
 	}
 
 	/**
-	* Informs the radar panel on preferences and currently loaded cache
-	* database. It also calculates the maximum size available for drawing
-	* the radar.
-	*/
-	public void setParam(Preferences p, CacheDB db, CacheHolder sWp){
+	 * Informs the radar panel on preferences and currently loaded cache
+	 * database. It also calculates the maximum size available for drawing
+	 * the radar.
+	 */
+	public void setParam(Preferences p, CacheDB db, CacheHolder sWp) {
 		selectedWaypoint = sWp;
 		pref = p;
 		cacheDB = db;
-		height = (pref.myAppHeight)*6/5; // add 10% each at top/bottom
-		width = (pref.myAppWidth)*6/5;
+		height = (pref.myAppHeight) * 6 / 5; // add 10% each at top/bottom
+		width = (pref.myAppWidth) * 6 / 5;
 	}
 
 	// Call this after the centre has changed to re-center the radar panel
 	public void recenterRadar() {
-		reCenterImage=true;
+		reCenterImage = true;
 	}
 
 	/**
-	* Public method to draw the different caches and the
-	* radar background
-	*/
-	public void drawThePanel(){
+	 * Public method to draw the different caches and the
+	 * radar background
+	 */
+	public void drawThePanel() {
 		// If there are any images remove them!
 		final int anz = iActP.images.size();
-		for(int i = 0; i&lt;anz;i++){
-			iActP.removeImage((AniImage)iActP.images.get(0));
+		for (int i = 0; i &lt; anz; i++) {
+			iActP.removeImage((AniImage) iActP.images.get(0));
 		}
 		iActP.refresh();
 		drawBackground();
@@ -116,157 +118,163 @@
 		if (reCenterImage) {
 			// Hack to scroll to left origin for a defined position for subsequent
 			// scroll which centers the image
-			iActP.scroll(-1000,-1000);
-			final Dimension dispSize=getDisplayedSize(null);
-			iActP.scroll((width-dispSize.width)/2,(height-dispSize.height+btMinus.getSize(null).height)/2);
-			reCenterImage=false;
+			iActP.scroll(-1000, -1000);
+			final Dimension dispSize = getDisplayedSize(null);
+			iActP.scroll((width - dispSize.width) / 2, (height - dispSize.height + btMinus.getSize(null).height) / 2);
+			reCenterImage = false;
 		}
 	}
 
 	/**
-	* Private method to draw the caches.
-	*/
-	private void drawCaches(){
-		final Font radarFont = new Font(&quot;Gui&quot;, Font.BOLD,Global.getPref().fontSize);
+	 * Private method to draw the caches.
+	 */
+	private void drawCaches() {
+		final Font radarFont = new Font(&quot;Gui&quot;, Font.BOLD, Global.getPref().fontSize);
 		final FontMetrics fm = getFontMetrics(radarFont);
 		AniImage aImg;
 		RadarPanelImage rpi;
-		int drX,drY = 0;
+		int drX, drY = 0;
 		CacheHolder holder;
 		double degrees;
-		final double pi180=java.lang.Math.PI / 180.0;
-		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+		final double pi180 = java.lang.Math.PI / 180.0;
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			holder = cacheDB.get(i);
-			if(holder.isVisible() &amp;&amp; holder.pos.isValid()) {
+			if (holder.isVisible() &amp;&amp; holder.pos.isValid()) {
 				degrees = holder.degrees * pi180;
-				drX =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
-				drY = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
-				if(centerX+drX&gt;=0 &amp;&amp; centerY+drY&gt;=0 &amp;&amp; centerX+drX&lt;=width &amp;&amp; centerY+drY &lt;= height){
-					if (toggleMod&gt;0) {
+				drX = new Float(holder.kilom / scale * java.lang.Math.sin(degrees)).intValue();
+				drY = -new Float(holder.kilom / scale * java.lang.Math.cos(degrees)).intValue();
+				if (centerX + drX &gt;= 0 &amp;&amp; centerY + drY &gt;= 0 &amp;&amp; centerX + drX &lt;= width &amp;&amp; centerY + drY &lt;= height) {
+					if (toggleMod &gt; 0) {
 						String s;
-						if (toggleMod==1)
-							s=holder.getWayPoint();
+						if (toggleMod == 1)
+							s = holder.getWayPoint();
 						else
-							s=holder.getCacheName();
-						if (s.length()&gt;0) {
+							s = holder.getCacheName();
+						if (s.length() &gt; 0) {
 							int tw;
-							final Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
+							final Image img = new Image(tw = fm.getTextWidth(s), fm.getHeight());
 							final Graphics g = new Graphics(img);
 							g.setFont(radarFont);
 							g.setColor(Color.Black);
-							g.fillRect(0,0,tw, fm.getHeight());
+							g.fillRect(0, 0, tw, fm.getHeight());
 							g.setColor(Color.White);
-							g.drawText(s, 0,0);
+							g.drawText(s, 0, 0);
 							aImg = new AniImage(img);
-							aImg.setLocation(centerX+drX+5,centerY+drY);
+							aImg.setLocation(centerX + drX + 5, centerY + drY);
 							aImg.transparentColor = Color.Black;
 							aImg.properties = mImage.IsNotHot;
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=GuiImageBroker.getTypeImage(holder.getType(),true, holder.is_found());
-					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=GuiImageBroker.getTypeImage(CacheType.CW_TYPE_UNKNOWN,true,false);
+					Image imgCache = CacheType.getMapImage(holder);
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;
 					final int dx = imgCache.getWidth();
 					final int dy = imgCache.getHeight();
-					rpi.setLocation(centerX+drX-dx/2,centerY+drY-dy/2);
+					rpi.setLocation(centerX + drX - dx / 2, centerY + drY - dy / 2);
 					iActP.addImage(rpi);
-					if(holder == selectedWaypoint){ // Draw red circle around selected wpt
-						final int diag = (int) (java.lang.Math.sqrt(dx*dx+dy*dy)+0.5);
+					if (holder == selectedWaypoint) { // Draw red circle around selected wpt
+						final int diag = (int) (java.lang.Math.sqrt(dx * dx + dy * dy) + 0.5);
 						final Image imgCircle = new Image(diag, diag);
 						final Graphics gCircle = new Graphics(imgCircle);
 						gCircle.setColor(Color.Black);
-						gCircle.fillRect(0,0,diag,diag);
-						gCircle.setColor(new Color(255,0,0));
-						gCircle.drawEllipse(0,0, diag,diag);
+						gCircle.fillRect(0, 0, diag, diag);
+						gCircle.setColor(new Color(255, 0, 0));
+						gCircle.drawEllipse(0, 0, diag, diag);
 						aImg = new AniImage(imgCircle);
-						aImg.setLocation(centerX+drX-diag/2,centerY+drY-diag/2);
-						aImg.transparentColor = new Color(0,0,0);
+						aImg.setLocation(centerX + drX - diag / 2, centerY + drY - diag / 2);
+						aImg.transparentColor = new Color(0, 0, 0);
 						aImg.properties = mImage.IsNotHot;
 						iActP.addImage(aImg);
 					}
-				}//if center...
+				}// if center...
 			}// if is_black...
 		}
 	}
 
 	/**
-	* Private method to draw the black background and green radar.
-	* Also calculates some other parameters.
-	* Always call this before calling drawCaches().
-	*/
-	private void drawBackground(){
+	 * Private method to draw the black background and green radar.
+	 * Also calculates some other parameters.
+	 * Always call this before calling drawCaches().
+	 */
+	private void drawBackground() {
 		final Rect r = new Rect(new Dimension(width, height));
 		iActP.virtualSize = r;
 		iActP.refresh();
 		final Image img = new Image(width, height);
 		final Graphics g = new Graphics(img);
 		g.setColor(Color.Black);
-		g.fillRect(0,0,width, height);
+		g.fillRect(0, 0, width, height);
 
-
-		if(width &lt; height) {
-			scale = (double)scaleKm / (double)height;
+		if (width &lt; height) {
+			scale = (double) scaleKm / (double) height;
 		} else {
-			scale = (double)scaleKm / (double)width;
+			scale = (double) scaleKm / (double) width;
 		}
 		centerX = (width / 2);
 		centerY = (height / 2);
-		//centerY = (int)(centerY-centerY*0.15);
-		g.setColor(new Color(0,255,0));
-		int radstep= 0, steps=0, radius = 0;
+		// centerY = (int)(centerY-centerY*0.15);
+		g.setColor(new Color(0, 255, 0));
+		int radstep = 0, steps = 0, radius = 0;
 
-		if(width &gt; height){
-			radstep = (int)(10 / scale);
+		if (width &gt; height) {
+			radstep = (int) (10 / scale);
 			steps = (width / radstep);
-		}else{
-			radstep = (int)(10 / scale);
+		} else {
+			radstep = (int) (10 / scale);
 			steps = (height / radstep);
 		}
-		for(int i = 1; i &lt;= steps; i++){
-			radius = (radstep * i)*2;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		for (int i = 1; i &lt;= steps; i++) {
+			radius = (radstep * i) * 2;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 		}
-		g.drawLine(centerX,0,centerX,height);
-		g.drawLine(0,centerY,width,centerY);
+		g.drawLine(centerX, 0, centerX, height);
+		g.drawLine(0, centerY, width, centerY);
 
 		// Show 1 KM radius only if we have zoomed in (useful for cities with high density of caches)
-		if (scaleKm&lt;=20) {
-			g.setColor(new Color(255,255,0)); // Yellow for 1km circle
-			radius = radstep/5;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		if (scaleKm &lt;= 20) {
+			g.setColor(new Color(255, 255, 0)); // Yellow for 1km circle
+			radius = radstep / 5;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 			g.free();
 		}
 		final AniImage aImg = new AniImage(img);
-		//iActP.addImage(aImg);
+		// iActP.addImage(aImg);
 		iActP.backgroundImage = img;
-		final int xPos = (pref.myAppWidth/2 - width/2);
-		aImg.setLocation(xPos,0);
+		final int xPos = (pref.myAppWidth / 2 - width / 2);
+		aImg.setLocation(xPos, 0);
 		aImg.refresh();
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == btPlus){
-				if (scaleKm&gt;10) scaleKm = scaleKm - 10;
-				else if (scaleKm==10) scaleKm=5;
-				else if (scaleKm==5) scaleKm=2;
-				else scaleKm=1;
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == btPlus) {
+				if (scaleKm &gt; 10)
+					scaleKm = scaleKm - 10;
+				else if (scaleKm == 10)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 2;
+				else
+					scaleKm = 1;
 				drawThePanel();
 			}
-			if (ev.target == btMinus){
-				if (scaleKm==1) scaleKm=2;
-				else if(scaleKm==2) scaleKm=5;
-				else if(scaleKm==5) scaleKm=10;
-				else scaleKm = scaleKm + 10;
+			if (ev.target == btMinus) {
+				if (scaleKm == 1)
+					scaleKm = 2;
+				else if (scaleKm == 2)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 10;
+				else
+					scaleKm = scaleKm + 10;
 				drawThePanel();
 			}
-			if (ev.target == btToggle){
+			if (ev.target == btToggle) {
 				toggleMod++;
-				if(toggleMod &gt; 2) toggleMod = 0;
+				if (toggleMod &gt; 2)
+					toggleMod = 0;
 				drawThePanel();
 			}
 		}

Modified: trunk/src/CacheWolf/navi/MapImage.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImage.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/MapImage.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Image;
@@ -35,45 +36,52 @@
 import ewe.graphics.AniImage;
 import ewe.io.FileInputStream;
 import ewe.io.IOException;
-/** 
+
+/**
  * class that can be used with any x and any y
- * it will save taht location and make itself automatically
- * invisible if it is not on the screen. Call setscreensize to
- * set the screensize
+ * it will save that location and
+ * make itself automatically invisible if it is not on the screen.
+ * Call setscreensize to set the screensize
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapImage extends AniImage {
 	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
 	public static Dimension screenDim;
 	boolean hidden = false;
+
 	public MapImage() {
 		super();
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	public MapImage(String f) throws ImageDecodingException, UnsupportedImageFormatException, ImageNotFoundException, ewe.sys.SystemResourceException {
-		if (screenDim == null) screenDim = new Dimension(0,0);
-		//super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
+		// super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
 		ewe.io.File file = ewe.sys.Vm.newFileObject();
 		file.set(null, f);
 		try {
-		//ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
-		setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super() 
-		freeSource(); // copied from super()
-		} catch (IOException e) { 
-			throw new ImageNotFoundException(f); // in order to behave the same way as super would have 
+			// ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides
+			// getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
+			setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super()
+			freeSource(); // copied from super()
+		} catch (IOException e) {
+			throw new ImageNotFoundException(f); // in order to behave the same way as super would have
 		}
 	}
 
 	public MapImage(mImage im) {
 		super(im);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	/**
 	 * Best you call this routine before you make any instance of MapImage
-	 * If the windows size changes after instantiation call  screenDimChanged()
+	 * If the windows size changes after instantiation call screenDimChanged()
 	 * for every symbol.
 	 * 
 	 */
@@ -83,13 +91,14 @@
 
 	public void setImage(Image im, Color c) {
 		super.setImage(im, c);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
-	public void setLocation (int x, int y) {
+	public void setLocation(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden &amp;&amp; isOnScreen()) { 
+		if (!hidden &amp;&amp; isOnScreen()) {
 			super.setLocation(x, y);
 			properties &amp;= ~mImage.IsInvisible;
 		} else {
@@ -98,10 +107,10 @@
 		}
 	}
 
-	public void move (int x, int y) {
+	public void move(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden &amp;&amp; isOnScreen()) { 
+		if (!hidden &amp;&amp; isOnScreen()) {
 			super.move(x, y);
 			properties &amp;= ~mImage.IsInvisible;
 		} else {
@@ -110,23 +119,24 @@
 		}
 	}
 
-	public boolean isOnScreen() { 
-		if ( (locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp; 
-				(locAlways.y + location.height &gt; 0 &amp;&amp; locAlways.y &lt; screenDim.height) ) return true;
-		else return false;
+	public boolean isOnScreen() {
+		if ((locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp; (locAlways.y + location.height &gt; 0 &amp;&amp; locAlways.y &lt; screenDim.height))
+			return true;
+		else
+			return false;
 	}
 
 	public void screenDimChanged() {
 		move(locAlways.x, locAlways.y);
-		//if (!hidden &amp;&amp; isOnScreen()) properties &amp;= ~AniImage.IsInvisible;
-		//else properties |= AniImage.IsInvisible;
+		// if (!hidden &amp;&amp; isOnScreen()) properties &amp;= ~AniImage.IsInvisible;
+		// else properties |= AniImage.IsInvisible;
 	}
 
-
 	public void hide() {
 		hidden = true;
 		properties |= mImage.IsInvisible;
 	}
+
 	public void unhide() {
 		hidden = false;
 		move(locAlways.x, locAlways.y);

Modified: trunk/src/CacheWolf/navi/MapSymbol.java
===================================================================
--- trunk/src/CacheWolf/navi/MapSymbol.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/MapSymbol.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,26 +33,30 @@
 	String name;
 	String filename;
 	CWPoint where;
-	
+
 	public MapSymbol(String namei, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 		mapObject = mapObjecti;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, Image fromIm, CWPoint where_) {
 		name = namei;
 		where = where_;
 		mapObject = mapObjecti;
 		setImage(fromIm);
 	}
-	public void loadImage(){
-		setImage(new Image(filename),0); freeSource();;
-		//properties = AniImage.AlwaysOnTop;
+
+	public void loadImage() {
+		setImage(new Image(filename), 0);
+		freeSource();
+		// properties = AniImage.AlwaysOnTop;
 	}
 }

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,7 +33,6 @@
 import CacheWolf.CacheType;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import CacheWolf.GuiImageBroker;
 import CacheWolf.InfoBox;
 import CacheWolf.MainTab;
 import CacheWolf.MyLocale;
@@ -86,17 +85,16 @@
 import ewe.util.Vector;
 
 /**
- *	Class to handle a moving map.
+ * Class to handle a moving map.
  */
 public final class MovingMap extends Form implements ICommandListener {
-	public final static int gotFix = 4; //green
-	public final static int lostFix = 3; //yellow
+	public final static int gotFix = 4; // green
+	public final static int lostFix = 3; // yellow
 	public final static int noGPSData = 2; // red
 	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
 	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
 
 	public MapSymbol gotoPos = null;
-	CacheHolder markedCache = null;
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
@@ -107,7 +105,7 @@
 	CWPoint TrackOverlaySetCenterTopLeft;
 	Vector tracks;
 	MapInfoObject currentMap = null;
-	//String mapPath;
+	// String mapPath;
 	Navigate myNavigation;
 	boolean running = false;
 
@@ -117,9 +115,10 @@
 	AniImage statusImageNoSignal;
 	AniImage statusImageNoGps;
 	MapSymbol posCircle;
-	String MARK_CACHE_IMAGE;
+	final static Image imgSelectedCache = new Image(&quot;mark_cache.png&quot;);
+	final static Image imgGoto = new Image(&quot;goto_map.png&quot;);
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
-	//double posCircleLat, posCircleLon;
+	// double posCircleLat, posCircleLon;
 	FontMetrics fm;
 
 	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
@@ -130,8 +129,8 @@
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
 	public boolean mapsloaded = false;
-	boolean additionalOverlaysDeleted=true;
-	protected boolean paintPosDestLine=true;
+	boolean additionalOverlaysDeleted = true;
+	protected boolean paintPosDestLine = true;
 	Point lastRepaintMapPos = null;
 	double lastDistance = -1;
 
@@ -143,7 +142,7 @@
 	public static final int tileWidth = 100;
 	public static final int tileHeight = 100;
 
-	//Needed by updatePosition to decide if a recalculation of map-tiles is needed:
+	// Needed by updatePosition to decide if a recalculation of map-tiles is needed:
 	private int lastXPos;
 	private int lastYPos;
 	private int lastWidth;
@@ -157,11 +156,9 @@
 	public void setFillWhiteArea(boolean fillWhiteArea) {
 		pref.fillWhiteArea = fillWhiteArea;
 		if (!fillWhiteArea) { // remove tiles from panel
-			for (int i = mmp.images.size() -1; i &gt;= 0; i--) {
+			for (int i = mmp.images.size() - 1; i &gt;= 0; i--) {
 				final AniImage im = (AniImage) mmp.images.get(i);
-				if ((im instanceof MapImage)
-						&amp;&amp; (!((im instanceof MapSymbol)
-								|| (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+				if ((im instanceof MapImage) &amp;&amp; (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
 					mmp.images.remove(im);
 				}
 			}
@@ -170,7 +167,7 @@
 
 	public void setShowCachesOnMap(boolean value) {
 		if (value != pref.showCachesOnMap) {
-			pref.showCachesOnMap=value;
+			pref.showCachesOnMap = value;
 		}
 		if (!value) {
 			removeAllMapSymbols();
@@ -178,7 +175,6 @@
 
 	}
 
-
 	public boolean isMobileVga() {
 		return mobileVGA;
 	}
@@ -191,41 +187,41 @@
 		return controlsLayer;
 	}
 
-	public MovingMap(Navigate nav, CacheDB cacheDB){
+	public MovingMap(Navigate nav, CacheDB cacheDB) {
 		this.cacheDB = cacheDB;
 		this.myNavigation = nav;
 		this.pref = Global.getPref();
-		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)	this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
-//      The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
-//      when MovingMap was started with maximized CacheWolf-Window
-//		this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
+		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)
+			this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
+		// The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
+		// when MovingMap was started with maximized CacheWolf-Window
+		// this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
 		this.hasTopBar = false;
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-//		this.setPreferredSize(240,320);
+		// this.setPreferredSize(240,320);
 		this.title = &quot;Moving Map&quot;;
-		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.backGround = new Color(254, 254, 254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
 
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 
 		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400)
 			mobileVGA = true;
-		String imagesize=&quot;&quot;;
-		if(mobileVGA) imagesize=&quot;_vga&quot;;
+		String imagesize = &quot;&quot;;
+		if (mobileVGA)
+			imagesize = &quot;_vga&quot;;
 
-
-		statusImageHaveSignal = new AniImage(&quot;position_green&quot;+imagesize+&quot;.png&quot;);
-		statusImageNoSignal = new AniImage(&quot;position_yellow&quot;+imagesize+&quot;.png&quot;);
-		statusImageNoGps = new AniImage(&quot;position_red&quot;+imagesize+&quot;.png&quot;);
-		posCircle = new MapSymbol(&quot;position_green&quot;+imagesize+&quot;.png&quot;, &quot;gps-position&quot;, new CWPoint());
-		MARK_CACHE_IMAGE = &quot;mark_cache.png&quot;;
-		//directionArrows
+		statusImageHaveSignal = new AniImage(&quot;position_green&quot; + imagesize + &quot;.png&quot;);
+		statusImageNoSignal = new AniImage(&quot;position_yellow&quot; + imagesize + &quot;.png&quot;);
+		statusImageNoGps = new AniImage(&quot;position_red&quot; + imagesize + &quot;.png&quot;);
+		posCircle = new MapSymbol(&quot;position_green&quot; + imagesize + &quot;.png&quot;, &quot;gps-position&quot;, new CWPoint());
+		// directionArrows
 		directionArrows.properties = mImage.AlwaysOnTop;
 		mmp.addImage(directionArrows);
-		//target distance
-		final int fontSize = ( 3 * pref.fontSize ) / 2;
-		final Font imageFont = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize );
+		// target distance
+		final int fontSize = (3 * pref.fontSize) / 2;
+		final Font imageFont = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize);
 		fm = getFontMetrics(imageFont);
 		setGpsStatus(noGPS);
 		posCircle.properties = mImage.AlwaysOnTop;
@@ -237,42 +233,49 @@
 		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 		lastHighestResolutionGPSDestScale = -1;
 
-		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+		lastRepaintMapPos = new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
 
 		controlsLayer = new MovingMapControls(this);
 
-
 	}
 
-	public void resizeTo(int w,int h) {
+	public void resizeTo(int w, int h) {
 		super.resizeTo(w, h);
 		updateFormSize(w, h);
 	}
 
 	public void updateFormSize(int w, int h) {
 		MapImage.setScreenSize(w, h);
-		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
-		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged();
-		if (posCircle != null) posCircle.screenDimChanged();
-		if (tracks != null) rebuildOverlaySet();
+		directionArrows.setLocation(w / 2 - directionArrows.getWidth() / 2, 10);
+		if (mmp.mapImage != null)
+			mmp.mapImage.screenDimChanged();
+		if (posCircle != null)
+			posCircle.screenDimChanged();
+		if (tracks != null)
+			rebuildOverlaySet();
 		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
-			for (int i = symbols.size() -1; i &gt;= 0; i-- ) {
-				((MapSymbol)symbols.get(i)).screenDimChanged();
+			for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+				((MapSymbol) symbols.get(i)).screenDimChanged();
 			}
 		}
-		if (controlsLayer!=null) {
+		if (controlsLayer != null) {
 			controlsLayer.updateFormSize(w, h);
 		}
 	}
 
 	boolean loadingMapList = false;
+
 	/**
 	 * loads the list of maps
-	 * @param mapsPath must not have a trailing end &quot;/&quot;
-	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 * 
+	 * @param mapsPath
+	 *            must not have a trailing end &quot;/&quot;
+	 * @param lat
+	 *            used to create empty maps with correct conversion from lon to meters the latitude must be known
 	 */
-	public void loadMaps(String mapsPath, double lat){
-		if (loadingMapList) return;
+	public void loadMaps(String mapsPath, double lat) {
+		if (loadingMapList)
+			return;
 		loadingMapList = true;
 		final InfoBox inf = new InfoBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(4203, &quot;Loading list of maps...&quot;));
 		Vm.showWait(this, true);
@@ -283,9 +286,11 @@
 		dontUpdatePos = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
-			(new MessageBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4204, &quot;No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4204, &quot;No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated&quot;),
+					FormBase.OKB)).execute();
 			noMapsAvailable = true;
-		} else noMapsAvailable = false;
+		} else
+			noMapsAvailable = false;
 		maps.addEmptyMaps(lat); // the empty maps must be added last, otherwise in method setBestMap, when no map is available, a malfunction will happen, see there
 		maps.onCompletedRead();
 		dontUpdatePos = saveGpsIgnoreStatus;
@@ -297,8 +302,7 @@
 
 	public void updateScale() {
 
-		if (currentMap != null)
-		{
+		if (currentMap != null) {
 			double lineLengthMeters = 40 * currentMap.scale;
 
 			final int metricSystem = pref.metricSystem;
@@ -312,7 +316,7 @@
 				smallUnit = Metrics.FEET;
 				threshold = 501;
 
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, smallUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, smallUnit);
 			} else {
 				bigUnit = Metrics.KILOMETER;
 				smallUnit = Metrics.METER;
@@ -323,48 +327,44 @@
 
 			int currentUnit = smallUnit;
 
-			float digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-			localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			float digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+			localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 
-			if (localizedLineLength &gt;= threshold)
-			{
+			if (localizedLineLength &gt;= threshold) {
 				currentUnit = bigUnit;
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, currentUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, currentUnit);
 
-				digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-				localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+				digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+				localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 			}
 
 			String lineLengthString = Convert.toString((int) localizedLineLength) + Metrics.getUnit(currentUnit);
 
-			if	(digits &lt; 0){
+			if (digits &lt; 0) {
 				final Double tmp = new Double();
 				tmp.set(localizedLineLength);
 
-				final int decimals = (int)(-1 * digits);
+				final int decimals = (int) (-1 * digits);
 
-				lineLengthString = tmp.toString(decimals+2,decimals,0) + Metrics.getUnit(currentUnit);
-//				lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) + Metrics.getUnit(currentUnit);
+				lineLengthString = tmp.toString(decimals + 2, decimals, 0) + Metrics.getUnit(currentUnit);
+				// lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) + Metrics.getUnit(currentUnit);
 			}
 
-			lineLengthMeters = Metrics.convertUnit( localizedLineLength, currentUnit, Metrics.METER);
+			lineLengthMeters = Metrics.convertUnit(localizedLineLength, currentUnit, Metrics.METER);
 
-			final int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+			final int lineLengthPixels = (int) java.lang.Math.round(lineLengthMeters / currentMap.scale);
 
 			controlsLayer.updateContent(&quot;scale&quot;, lineLengthString, lineLengthPixels);
-		}
-		else{
+		} else {
 
-		controlsLayer.updateContent(&quot;scale&quot;, &quot;no map&quot;, 20);
+			controlsLayer.updateContent(&quot;scale&quot;, &quot;no map&quot;, 20);
 		}
 	}
 
 	public void updateDistance(boolean repaint) {
-		if (gotoPos != null &amp;&amp; posCircle.where.isValid())
-		{
+		if (gotoPos != null &amp;&amp; posCircle.where.isValid()) {
 			final double currentDistance = gotoPos.where.getDistance(posCircle.where);
-			if (currentDistance != lastDistance)
-			{
+			if (currentDistance != lastDistance) {
 				lastDistance = currentDistance;
 				final ewe.sys.Double dd = new ewe.sys.Double();
 				String d;
@@ -388,19 +388,17 @@
 					localizedDistance = currentDistance;
 				}
 				dd.set(localizedDistance);
-				if (dd.value &gt;= threshold){
-					d = MyLocale.formatDouble(dd,&quot;0.000&quot;) + Metrics.getUnit(bigUnit);
+				if (dd.value &gt;= threshold) {
+					d = MyLocale.formatDouble(dd, &quot;0.000&quot;) + Metrics.getUnit(bigUnit);
 				} else {
 					dd.set(Metrics.convertUnit(dd.value, bigUnit, smallUnit));
-					d = dd.toString(3,0,0) + Metrics.getUnit(smallUnit);
+					d = dd.toString(3, 0, 0) + Metrics.getUnit(smallUnit);
 				}
 
 				controlsLayer.updateContent(&quot;distance&quot;, d);
 
 			}
-		}
-		else
-		{
+		} else {
 			controlsLayer.updateContent(&quot;distance&quot;, &quot;&quot;);
 		}
 	}
@@ -414,16 +412,17 @@
 		final FormFrame ret = exec();
 		running = true;
 		// disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
-		if (forceCenter) setGpsStatus(noGPS);
+		if (forceCenter)
+			setGpsStatus(noGPS);
 		// to load maplist + place a map on screen otherwise no symbol can be placed
-		ignoreGps=true; // else overlay symbols are removed on started gps
+		ignoreGps = true; // else overlay symbols are removed on started gps
 
 		rebuildOverlaySet(); // show tracks , even if reentering map
 
 		updatePosition(centerTo);
 		setCenterOfScreen(centerTo, false);
 
-		if (getControlsLayer()!=null) {
+		if (getControlsLayer() != null) {
 			getControlsLayer().changeRoleState(MovingMapControls.ROLE_MENU, false);
 		}
 
@@ -431,50 +430,38 @@
 		if (Global.getProfile().selectionChanged) {
 			// this means marking has changed
 			Global.getProfile().selectionChanged = false;
-			if (pref.showCachesOnMap) removeAllMapSymbols(); // not really needed: hopefully removed by showCachesOnMap
+			if (pref.showCachesOnMap)
+				removeAllMapSymbols(); // not really needed: hopefully removed by showCachesOnMap
 		}
-		setMarkedCache(Global.mainTab.ch); // this is the selected one (not necessary marked)
 		showCachesOnMap();
 
 		if (myNavigation.destinationIsCache) {
 			destChanged(myNavigation.destinationCache);
-		}
-		else {
+		} else {
 			destChanged(myNavigation.destination);
 		}
 
 		repaint();
-		ignoreGps=false;
+		ignoreGps = false;
 
 		return ret;
 	}
 
-	public void setMarkedCache(CacheHolder ch) {
-		if (ch == markedCache) return;
-		if (markedCache != null) {
-			removeMapSymbol(&quot;selectedCache&quot;);
-			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
-		}
-		if (ch != null) {
-			if ( ch.pos.isValid()) {
-				addSymbol(&quot;selectedCache&quot;, MARK_CACHE_IMAGE, ch.pos);
-				addSymbolIfNecessary(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
-				markedCache = ch;
-			}
-		}
-	}
-
 	public void addTrack(Track tr) {
-		if (tr == null) return;
-		if (tracks == null) tracks = new Vector();
-		if (tracks.find(tr) &gt;= 0 ) return; // track already in list
+		if (tr == null)
+			return;
+		if (tracks == null)
+			tracks = new Vector();
+		if (tracks.find(tr) &gt;= 0)
+			return; // track already in list
 		tracks.add(tr);
 		rebuildOverlaySet();
 	}
 
 	public void addTracks(Track[] trs) {
-		if (trs==null || trs.length == 0) return;
-		for (int i=0; i&lt;trs.length; i++) {
+		if (trs == null || trs.length == 0)
+			return;
+		for (int i = 0; i &lt; trs.length; i++) {
 			addTrack(trs[i]);
 		}
 		rebuildOverlaySet();
@@ -482,26 +469,28 @@
 
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
-	 *
+	 * 
 	 * add tracks with addtrack(track) before
 	 */
 
 	public void addOverlaySet() {
-		if (tracks == null) return; // no tracks
+		if (tracks == null)
+			return; // no tracks
 		try {
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 			addMissingOverlays();
 		} catch (final NullPointerException e) {
 			// hapens if currentmap == null or PosCircle not valid
+		} catch (final IllegalArgumentException e) {
+			// happens if screensize is still not known ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
 		}
-		catch (final IllegalArgumentException e) {
-			// happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
-		}
 	}
 
 	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
-			for (int i=0; i&lt; TrackOverlays.length; i++) {	destroyOverlay(i);	}
+			for (int i = 0; i &lt; TrackOverlays.length; i++) {
+				destroyOverlay(i);
+			}
 		}
 		Vm.getUsedMemory(true); // call garbage collection
 		Vm.gc();
@@ -513,7 +502,8 @@
 	}
 
 	public void addMissingOverlays() {
-		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0)
+			return; // height == 0 happens if this is called before the form ist displayed on the screen
 		if (TrackOverlays == null) {
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
@@ -521,16 +511,16 @@
 		final boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
 		dontUpdatePos = true;
 		final Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
-		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
-		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		// upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
+		// upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
 		int i;
-		for (int yi=0; yi&lt;3; yi++) {
-			for (int xi=0; xi&lt;3; xi++) {
-				i = yi*3+xi;
-				if (TrackOverlays[i]==null) {
+		for (int yi = 0; yi &lt; 3; yi++) {
+			for (int xi = 0; xi &lt; 3; xi++) {
+				i = yi * 3 + xi;
+				if (TrackOverlays[i] == null) {
 					pref.log(&quot;addMissingOverlays: widht: &quot; + width + &quot;, height: &quot; + height);
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap);
-					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
+					TrackOverlays[i] = new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x + (xi - 1) * width, upperleftOf4.y + (yi - 1) * height), width, height, currentMap);
+					TrackOverlays[i].setLocation(width + 1, height + 1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -538,29 +528,32 @@
 			}
 		}
 		updateOverlayOnlyPos();
-		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		if (mmp.mapImage != null)
+			mmp.images.moveToBack(mmp.mapImage);
 		dontUpdatePos = saveGPSIgnoreStatus;
 	}
 
 	private void destroyOverlay(int ov) {
-		if (TrackOverlays[ov] == null) return;
+		if (TrackOverlays[ov] == null)
+			return;
 		mmp.removeImage(TrackOverlays[ov]);
 		TrackOverlays[ov].free();
-		TrackOverlays[ov]=null;
+		TrackOverlays[ov] = null;
 	}
+
 	public void rearangeOverlays() {
 		final Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
-			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2 * height));
 			destroyOverlay(6);
 			destroyOverlay(7);
 			destroyOverlay(8);
 			mmp.removeImage(TrackOverlays[0]);
 			mmp.removeImage(TrackOverlays[1]);
 			mmp.removeImage(TrackOverlays[2]);
-			TrackOverlays[6]=TrackOverlays[0];
-			TrackOverlays[7]=TrackOverlays[1];
-			TrackOverlays[8]=TrackOverlays[2];
+			TrackOverlays[6] = TrackOverlays[0];
+			TrackOverlays[7] = TrackOverlays[1];
+			TrackOverlays[8] = TrackOverlays[2];
 			mmp.addImage(TrackOverlays[6]);
 			mmp.addImage(TrackOverlays[7]);
 			mmp.addImage(TrackOverlays[8]);
@@ -572,16 +565,16 @@
 			destroyOverlay(5);
 		} else {
 			if (TrackOverlays[3].isOnScreen()) { // links raus
-				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y));
 				destroyOverlay(2);
 				destroyOverlay(5);
 				destroyOverlay(8);
 				mmp.removeImage(TrackOverlays[0]);
 				mmp.removeImage(TrackOverlays[3]);
 				mmp.removeImage(TrackOverlays[6]);
-				TrackOverlays[2]=TrackOverlays[0];
-				TrackOverlays[5]=TrackOverlays[3];
-				TrackOverlays[8]=TrackOverlays[6];
+				TrackOverlays[2] = TrackOverlays[0];
+				TrackOverlays[5] = TrackOverlays[3];
+				TrackOverlays[8] = TrackOverlays[6];
 				mmp.addImage(TrackOverlays[2]);
 				mmp.addImage(TrackOverlays[5]);
 				mmp.addImage(TrackOverlays[8]);
@@ -593,16 +586,16 @@
 				destroyOverlay(7);
 			} else {
 				if (TrackOverlays[5].isOnScreen()) { // rechts raus
-					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y));
 					destroyOverlay(0);
 					destroyOverlay(3);
 					destroyOverlay(6);
 					mmp.removeImage(TrackOverlays[2]);
 					mmp.removeImage(TrackOverlays[5]);
 					mmp.removeImage(TrackOverlays[8]);
-					TrackOverlays[0]=TrackOverlays[2];
-					TrackOverlays[3]=TrackOverlays[5];
-					TrackOverlays[6]=TrackOverlays[8];
+					TrackOverlays[0] = TrackOverlays[2];
+					TrackOverlays[3] = TrackOverlays[5];
+					TrackOverlays[6] = TrackOverlays[8];
 					mmp.addImage(TrackOverlays[0]);
 					mmp.addImage(TrackOverlays[3]);
 					mmp.addImage(TrackOverlays[6]);
@@ -614,16 +607,16 @@
 					destroyOverlay(7);
 				} else {
 					if (TrackOverlays[7].isOnScreen()) { // unten raus
-						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2 * height));
 						destroyOverlay(0);
 						destroyOverlay(1);
 						destroyOverlay(2);
 						mmp.removeImage(TrackOverlays[6]);
 						mmp.removeImage(TrackOverlays[7]);
 						mmp.removeImage(TrackOverlays[8]);
-						TrackOverlays[0]=TrackOverlays[6];
-						TrackOverlays[1]=TrackOverlays[7];
-						TrackOverlays[2]=TrackOverlays[8];
+						TrackOverlays[0] = TrackOverlays[6];
+						TrackOverlays[1] = TrackOverlays[7];
+						TrackOverlays[2] = TrackOverlays[8];
 						mmp.addImage(TrackOverlays[0]);
 						mmp.addImage(TrackOverlays[1]);
 						mmp.addImage(TrackOverlays[2]);
@@ -634,11 +627,11 @@
 						destroyOverlay(4);
 						destroyOverlay(5);
 					} else { // it is important to test for diagonal only if the other didn't match
-						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
-							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+						if (TrackOverlays[0].isOnScreen()) { // links oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y - 2 * height));
 							destroyOverlay(8);
 							mmp.removeImage(TrackOverlays[0]);
-							TrackOverlays[8]=TrackOverlays[0];
+							TrackOverlays[8] = TrackOverlays[0];
 							mmp.addImage(TrackOverlays[8]);
 							TrackOverlays[0] = null;
 							destroyOverlay(1);
@@ -650,10 +643,10 @@
 							destroyOverlay(7);
 						} else {
 							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
-								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y - 2 * height));
 								destroyOverlay(6);
 								mmp.removeImage(TrackOverlays[2]);
-								TrackOverlays[6]=TrackOverlays[2];
+								TrackOverlays[6] = TrackOverlays[2];
 								mmp.addImage(TrackOverlays[6]);
 								TrackOverlays[2] = null;
 								destroyOverlay(0);
@@ -665,10 +658,10 @@
 								destroyOverlay(8);
 							} else {
 								if (TrackOverlays[6].isOnScreen()) { // links unten raus
-									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y + 2 * height));
 									destroyOverlay(2);
 									mmp.removeImage(TrackOverlays[6]);
-									TrackOverlays[2]=TrackOverlays[6];
+									TrackOverlays[2] = TrackOverlays[6];
 									mmp.addImage(TrackOverlays[2]);
 									TrackOverlays[6] = null;
 									destroyOverlay(0);
@@ -680,10 +673,10 @@
 									destroyOverlay(8);
 								} else {
 									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
-										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y + 2 * height));
 										destroyOverlay(0);
 										mmp.removeImage(TrackOverlays[8]);
-										TrackOverlays[0]=TrackOverlays[8];
+										TrackOverlays[0] = TrackOverlays[8];
 										mmp.addImage(TrackOverlays[0]);
 										TrackOverlays[8] = null;
 										destroyOverlay(1);
@@ -693,49 +686,58 @@
 										destroyOverlay(5);
 										destroyOverlay(6);
 										destroyOverlay(7);
-									}else
-										for (int i=0; i&lt;TrackOverlays.length; i++) {
+									} else
+										for (int i = 0; i &lt; TrackOverlays.length; i++) {
 											destroyOverlay(i);
 											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 										} // this happens if a position jump occured
-								}}}}}}} // close all IFs
+								}
+							}
+						}
+					}
+				}
+			}
+		} // close all IFs
 		Vm.gc(); // call garbage collection
 	}
 
 	public void ShowLastAddedPoint(Track tr) {
-		if (TrackOverlays == null || tr == null) return;
-		for (int i=0; i&lt;TrackOverlays.length; i++){
+		if (TrackOverlays == null || tr == null)
+			return;
+		for (int i = 0; i &lt; TrackOverlays.length; i++) {
 			TrackOverlays[i].paintLastAddedPoint(tr);
 		}
 	}
 
 	public void updateOverlayOnlyPos() {
-		if (TrackOverlays == null || TrackOverlays[4] == null) return;
-		//	Point upperleft = getMapXYPosition();
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			return;
+		// Point upperleft = getMapXYPosition();
 		Point posOnScreen;
 		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft);
 		final Dimension ws = mmp.getSize(null);
 		final int ww = ws.width;
 		final int wh = ws.height;
-		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		// Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
 		int num, pX, pY;
-		for (int yi=0; yi&lt;3; yi++) {
-			for (int xi=0; xi&lt;3; xi++) {
-				num = yi*3+xi;
-				pX = posOnScreen.x+(xi-1)*ww;
-				pY = posOnScreen.y+(yi-1)*wh;
+		for (int yi = 0; yi &lt; 3; yi++) {
+			for (int xi = 0; xi &lt; 3; xi++) {
+				num = yi * 3 + xi;
+				pX = posOnScreen.x + (xi - 1) * ww;
+				pY = posOnScreen.y + (yi - 1) * wh;
 				TrackOverlays[num].setLocation(pX, pY);
 			}
 		}
 	}
 
 	public void updateOverlayPos() {
-		if (tracks == null || tracks.size() == 0) return;
-		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		if (tracks == null || tracks.size() == 0)
+			return;
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			addMissingOverlays();
 		else {
 			updateOverlayOnlyPos();
-			if (TrackOverlays[0].locAlways.x &gt; 0 || TrackOverlays[2].locAlways.x &lt; 0
-					|| TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
+			if (TrackOverlays[0].locAlways.x &gt; 0 || TrackOverlays[2].locAlways.x &lt; 0 || TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
 				rearangeOverlays();
 				addMissingOverlays();
 				// updateOverlayOnlyPos(); is called from addMissingOverlays
@@ -745,54 +747,58 @@
 
 	/**
 	 * move posCircle to the Centre of the Screen
-	 *
+	 * 
 	 */
 	public void resetCenterOfMap() {
 		if (width != 0) {
-			posCircleX = width /2;
-			posCircleY = height /2;
+			posCircleX = width / 2;
+			posCircleY = height / 2;
 		} else {
-			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-			posCircleY = pref.myAppHeight/2;
+			posCircleX = pref.myAppWidth / 2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight / 2;
 		}
 		posCircle.hidden = false;
-		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -&gt; hiding the posCircle in some situation
+		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2); // posCircle.setLocation caused a problem -&gt; hiding the posCircle in some situation
 	}
 
 	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
 		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
 	}
 
-	public void setCenterOfScreen (CWPoint c, boolean repaint) {
-		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	public void setCenterOfScreen(CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(this.width / 2, this.height / 2), c, repaint);
 	}
 
 	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
 		final Point mappos = getMapPositionOnScreen();
 		final Point onscreenpos = getXYonScreen(c);
-		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
 		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-		if (repaint) mmp.repaintNow();
+		if (repaint)
+			mmp.repaintNow();
 	}
 
-	/** call this if the map moved on the screen (by dragging)
+	/**
+	 * call this if the map moved on the screen (by dragging)
 	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * 
 	 * @param diffX
 	 * @param diffY
 	 */
 	public void mapMoved(int diffX, int diffY) {
 		final int w = posCircle.getWidth();
 		final int h = posCircle.getHeight();
-		final int npx = posCircleX-w/2+diffX;
-		final int npy = posCircleY-h/2+diffY;
+		final int npx = posCircleX - w / 2 + diffX;
+		final int npy = posCircleY - h / 2 + diffY;
 		posCircle.move(npx, npy);
-		posCircleX = posCircleX+diffX;
-		posCircleY = posCircleY+diffY;
-		if (posCircle.where.isValid()){
+		posCircleX = posCircleX + diffX;
+		posCircleY = posCircleY + diffY;
+		if (posCircle.where.isValid()) {
 			dontUpdatePos = false;
 			updatePosition(posCircle.where);
-		}
-		else updateSymbolPositions(); // will also be done in updatePosition
+		} else
+			updateSymbolPositions(); // will also be done in updatePosition
 		updateOverlayPos();
 	}
 
@@ -802,194 +808,222 @@
 	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
 	 * returns the same as mmp.mapImage.getLocation(mapPos);
 	 * but also works if mmp == null and is used to move the map to the correct point
+	 * 
 	 * @return
 	 */
 	public Point getMapPositionOnScreen() {
 		if (currentMap == null || !posCircle.where.isValid())
-			return new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+			return new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
 		// in case no calculation is possible return somthing outside of the screen
 		final Point mapPos = new Point();
-		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-		//else {
+		// if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		// else {
 		final Point mapposint = currentMap.calcMapXY(posCircle.where);
 		mapPos.x = posCircleX - mapposint.x;
 		mapPos.y = posCircleY - mapposint.y;
-		//}
+		// }
 		return mapPos;
 	}
 
 	/**
-	 *
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
 	 */
-	public Point getXYonScreen(TrackPoint ll){
-		if (currentMap == null) return null;
+	public Point getXYonScreen(TrackPoint ll) {
+		if (currentMap == null)
+			return null;
 		final Point coords = currentMap.calcMapXY(ll);
 		final Point mapPos = getMapPositionOnScreen();
 		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 	}
 
-	public CWPoint ScreenXY2LatLon (int px, int py){
+	public CWPoint ScreenXY2LatLon(int px, int py) {
 		final Point mapPos = getMapPositionOnScreen();
 		return currentMap.calcLatLon(px - mapPos.x, py - mapPos.y);
 	}
 
-
 	public void updateSymbolPositions() {
-		if (symbols == null) return;
+		if (symbols == null)
+			return;
 		Point pOnScreen;
 		MapSymbol symb;
 		int w, h;
 		showCachesOnMap();
-		for (int i=symbols.size()-1; i&gt;=0; i--) {
-			symb = (MapSymbol)symbols.get(i);
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			symb = (MapSymbol) symbols.get(i);
 			pOnScreen = getXYonScreen(symb.where);
-			w=symb.getWidth();
-			h=symb.getHeight();
-			symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+			w = symb.getWidth();
+			h = symb.getHeight();
+			symb.move(pOnScreen.x - w / 2, pOnScreen.y - h / 2);
 		}
 	}
 
 	public MapSymbol addSymbol(String pName, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
+		if (symbols == null)
+			symbols = new Vector();
 		final MapSymbol ms = new MapSymbol(pName, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
 		final Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
 	public MapSymbol addSymbol(String pName, Object mapObject, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
+		if (symbols == null)
+			symbols = new Vector();
 		final MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
 		final Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
-	public void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
-		if (findMapSymbol(pName) &gt;= 0) return;
-		else addSymbol(pName, mapObject, imSymb, where);
+	private boolean addSymbolIsNecessary(String pName) {
+		if (findMapSymbol(pName) &gt;= 0)
+			return false;
+		else
+			return true;
 	}
 
+	private void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
+		if (findMapSymbol(pName) &gt;= 0)
+			return;
+		else
+			addSymbol(pName, mapObject, imSymb, where);
+	}
+
 	public void addSymbolOnTop(String pName, Object mapObject, String filename, CWPoint where) {
-		removeMapSymbol(pName); // Object possibly removes another picture from screen
-		addSymbol(pName,mapObject,filename, where);
+		removeMapSymbol(mapObject);
+		addSymbol(pName, mapObject, filename, where);
 	}
 
 	public void addSymbol(String pName, Object mapObject, Image imSymb, CWPoint ll) {
-		if (symbols==null) symbols=new Vector();
+		if (symbols == null)
+			symbols = new Vector();
 		final MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
 		ms.properties = mImage.AlwaysOnTop;
 		final Point pOnScreen = getXYonScreen(ll);
-		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		if (pOnScreen != null)
+			ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 	}
 
 	public void destChanged(CWPoint d) {
-		if(!running || (d == null &amp;&amp; gotoPos == null) ||
-				(d != null &amp;&amp; gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
+		if (!running || (d == null &amp;&amp; gotoPos == null) || (d != null &amp;&amp; gotoPos != null &amp;&amp; gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol(&quot;goto&quot;);
-		if (d == null || !d.isValid() ) return;
+		if (d == null || !d.isValid())
+			return;
 		gotoPos = addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, d);
 		forceMapLoad = true;
 		// dirty hack: if this.width == 0, then the symbols are not on the screen
 		// and get hidden by updateSymbolPositions
-		if (this.width != 0) updatePosition(posCircle.where);
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
 	public void destChanged(CacheHolder ch) {
-		final CWPoint d = new CWPoint (ch.pos);
-		if(!running || (gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
+		final CWPoint d = new CWPoint(ch.pos);
+		if (!running || (gotoPos != null &amp;&amp; gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol(&quot;goto&quot;);
-		if (!d.isValid() ) return;
+		if (!d.isValid())
+			return;
 		gotoPos = addSymbol(&quot;goto&quot;, ch, &quot;goto_map.png&quot;, d);
 		forceMapLoad = true;
 		// dirty hack: if this.width == 0, then the symbols are not on the screen
 		// and get hidden by updateSymbolPositions
-		if (this.width != 0) updatePosition(posCircle.where);
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
-	public CWPoint getGotoPos(){
-		if (gotoPos == null) return null;
+	public CWPoint getGotoPos() {
+		if (gotoPos == null)
+			return null;
 		return new CWPoint(gotoPos.where);
 	}
 
-	public void removeAllMapSymbols(){
-		if (symbols == null) return;
-		for (int i = symbols.size()-1; i &gt;= 0; i--) {
-			mmp.removeImage((MapSymbol)symbols.get(i));
+	public void removeAllMapSymbols() {
+		if (symbols == null)
+			return;
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			mmp.removeImage((MapSymbol) symbols.get(i));
 		}
 		symbols.removeAllElements();
 	}
 
 	public void removeMapSymbol(String pName) {
 		final int symbNr = findMapSymbol(pName);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(Object obj) {
 		final int symbNr = findMapSymbol(obj);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(int SymNr) {
-		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		mmp.removeImage(((MapSymbol) symbols.get(SymNr)));
 		symbols.removeElementAt(SymNr);
 	}
 
 	public int findMapSymbol(String pName) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == pName) return i;
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.name == pName)
+				return i;
 		}
 		return -1;
 	}
 
 	public int findMapSymbol(Object obj) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.mapObject == obj) return i;
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.mapObject == obj)
+				return i;
 		}
 		return -1;
 	}
 
 	/**
 	 * Move the map so that the posCircle is at lat/lon
-	 *
+	 * 
 	 * @param
 	 */
-	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
+	public void updateOnlyPosition(CWPoint where, boolean updateOverlay) {
 		posCircle.where.set(where);
 		final Point mapPos = getMapPositionOnScreen();
-		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1))
-		{
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1)) {
 			lastRepaintMapPos = mapPos;
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			if (mmp.mapImage != null)
+				mmp.mapImage.move(mapPos.x, mapPos.y);
 			updateSymbolPositions();
 			updateDistance(false);
-			if (updateOverlay ) updateOverlayPos(); // &amp;&amp; TrackOverlays != null
+			if (updateOverlay)
+				updateOverlayPos(); // &amp;&amp; TrackOverlays != null
 			repaint(); // don't wait
-		}
-		else
-		{
+		} else {
 			updateDistance(true);
 		}
 	}
+
 	private void loadBestMap(CWPoint where) {
 		if (!mapsloaded || !this.maps.getMapsPath().equals(pref.getCustomMapsPath())) {
 			loadMaps(pref.getCustomMapsPath(), where.latDec);
@@ -1000,46 +1034,44 @@
 			forceMapLoad = false;
 		}
 	}
+
 	/**
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
 	 */
-	public void updatePosition(CWPoint where){
-		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+	public void updatePosition(CWPoint where) {
+		if (dontUpdatePos || loadingMapList)
+			return; // avoid multi-threading problems
 		loadBestMap(where);
-		if (width==0 || height==0) { pref.log(&quot;[MovingMap:updatePosition]no window shown&quot;); return; } // why is this called with these values
+		if (width == 0 || height == 0) {
+			pref.log(&quot;[MovingMap:updatePosition]no window shown&quot;);
+			return;
+		} // why is this called with these values
 		updateOnlyPosition(where, true);
 		final Point mapPos = getMapPositionOnScreen();
-		final boolean screenNotCompletlyCovered = (mmp.mapImage == null)
-				|| (mmp.mapImage != null &amp;&amp; (
-				   mapPos.y &gt; 0                                      || mapPos.x                           &gt; 0
-				|| mapPos.y + mmp.mapImage.getHeight() &lt; this.height || mapPos.x + mmp.mapImage.getWidth() &lt; this.width));
-		//if screendimensions changed also force reload of map
+		final boolean screenNotCompletlyCovered = (mmp.mapImage == null) || (mmp.mapImage != null &amp;&amp; (mapPos.y &gt; 0 || mapPos.x &gt; 0 || mapPos.y + mmp.mapImage.getHeight() &lt; this.height || mapPos.x + mmp.mapImage.getWidth() &lt; this.width));
+		// if screendimensions changed also force reload of map
 		forceMapLoad |= lastWidth != width || lastHeight != height;
 		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) { // if force || want || map doesn't cover the screen completly
-			if (forceMapLoad ||
-				(java.lang.Math.abs(lastCompareX - mapPos.x) &gt; this.width / 10 ||
-				 java.lang.Math.abs(lastCompareY - mapPos.y) &gt; this.height / 10)) {
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX - mapPos.x) &gt; this.width / 10 || java.lang.Math.abs(lastCompareY - mapPos.y) &gt; this.height / 10)) {
 				// more then 1/10 of screen moved since last time we tried to find a better map
 				if (autoSelectMap) {
 					setBestMap(where, screenNotCompletlyCovered);
 					forceMapLoad = false;
 				}
-				if (isFillWhiteArea()) { fillWhiteArea(screenNotCompletlyCovered); }
+				if (isFillWhiteArea()) {
+					fillWhiteArea(screenNotCompletlyCovered);
+				}
 				lastCompareX = mapPos.x;
 				lastCompareY = mapPos.y;
-			}
-			else{
+			} else {
 				final int deltaX = mapPos.x - lastXPos;
 				final int deltaY = mapPos.y - lastYPos;
-				for(int i = mmp.images.size() -1; i &gt;= 0; i--){
+				for (int i = mmp.images.size() - 1; i &gt;= 0; i--) {
 					final AniImage im = (AniImage) mmp.images.get(i);
-					if ((im instanceof MapImage)
-						&amp;&amp; (!((im instanceof MapSymbol)
-							|| (im instanceof TrackOverlay)
-							|| mmp.mapImage == im))) {
-						//locAlways contains the real coordinates while
-						//location is only correct if the image is on the screen.
-						final Point p = ((MapImage)im).locAlways;
+					if ((im instanceof MapImage) &amp;&amp; (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+						// locAlways contains the real coordinates while
+						// location is only correct if the image is on the screen.
+						final Point p = ((MapImage) im).locAlways;
 						p.x += deltaX;
 						p.y += deltaY;
 						im.setLocation(p.x, p.y);
@@ -1057,33 +1089,28 @@
 	private void showCachesOnMap() {
 		// if (width == 0 || height == 0) return;
 		CacheHolder ch;
-		final Area screenArea = new Area(ScreenXY2LatLon(0,0), ScreenXY2LatLon(width,height));
+		final Area screenArea = new Area(ScreenXY2LatLon(0, 0), ScreenXY2LatLon(width, height));
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
 			if (screenArea.isInBound(ch.pos)) {
 				// because visible and valid don't change while showing map --&gt;need no remove
 				if (ch.isVisible() &amp;&amp; ch.pos.isValid()) {
 					if (pref.showCachesOnMap) {
-						addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
-					}
-					else {
-						if (ch.is_Checked) {
-							addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
+						if (addSymbolIsNecessary(ch.getWayPoint())) {
+							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
 						}
-						else {
+					} else {
+						if (ch.is_Checked || ch == Global.mainTab.ch) {
+							if (addSymbolIsNecessary(ch.getWayPoint())) {
+								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
+							}
+						} else {
 							removeMapSymbol(ch);
 						}
 					}
 				}
-			}else{
-				if (ch.cacheName.equals(&quot;&quot;)) {
-					removeMapSymbol(ch);
-				}
-				else {
-					// remove the right one , as
-					// possibly more than one picture associated with ch (target,selected ..)
-					removeMapSymbol(ch.cacheName);
-				}
+			} else {
+				removeMapSymbol(ch);
 			}
 		}
 		// adding target and selected
@@ -1098,182 +1125,175 @@
 			if (gotoPosCH != null) {
 				if (screenArea.isInBound(gotoPosCH.pos)) {
 					if (!pref.showCachesOnMap) {
-						addSymbolIfNecessary(gotoPosCH.cacheName, gotoPosCH, GuiImageBroker.getTypeImage(gotoPosCH.getType(),true,gotoPosCH.is_found()), gotoPosCH.pos);
+						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.pos);
 					}
-					addSymbolOnTop(&quot;goto&quot;, gotoPosCH, &quot;goto_map.png&quot;, gotoPos.where);
+					addSymbolIfNecessary(&quot;goto&quot;, gotoPosCH, imgGoto, gotoPos.where);
 				}
 			}
 		}
-		// show Selected
-		if (markedCache != null) {
-			if (screenArea.isInBound(markedCache.pos)) {
-				addSymbolIfNecessary(markedCache.cacheName, markedCache, GuiImageBroker.getTypeImage(markedCache.getType(),true, false), markedCache.pos);
-				addSymbolOnTop(&quot;selectedCache&quot;, markedCache, MARK_CACHE_IMAGE, markedCache.pos);
+		// mark Selected
+		ch = cacheDB.get(Global.mainTab.tbP.getSelectedCache());
+		if (ch != null) {
+			if (screenArea.isInBound(ch.pos)) {
+				addSymbolIfNecessary(&quot;selectedCache&quot;, ch, imgSelectedCache, ch.pos);
 			}
 		}
 	}
-	boolean reflectResourceException=true;
+
+	boolean reflectResourceException = true;
+
 	private void fillWhiteArea(boolean screenNotCompletlyCovered) {
-		if (mmp.mapImage == null) return; // if error at map load
+		if (mmp.mapImage == null)
+			return; // if error at map load
 		// Clean up any additional images, tiles will removed and any
 		// other item be added again later
 		final Vector icons = new Vector(mmp.images.size());
 		try {
-		Vm.showWait(true);
-		dontUpdatePos=true; // no new Position while filling
+			Vm.showWait(true);
+			dontUpdatePos = true; // no new Position while filling
 
-		final int s = mmp.images.size(); // avoid calling size() in each iteration
-		for (int i = 0; i &lt; s ;  i++) {
-			final AniImage im = (AniImage) mmp.images.get(i);
-			if (!(im instanceof MapImage) ||
-				(im instanceof MapSymbol) ||
-				(im instanceof TrackOverlay) ||
-				mmp.mapImage == im) {
-				icons.add(im);
+			final int s = mmp.images.size(); // avoid calling size() in each iteration
+			for (int i = 0; i &lt; s; i++) {
+				final AniImage im = (AniImage) mmp.images.get(i);
+				if (!(im instanceof MapImage) || (im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im) {
+					icons.add(im);
+				}
 			}
-		}
-		mmp.images.clear();
-		// Mark all tiles as dirty
-		MovingMapCache.getCache().clearUsedFlags();
+			mmp.images.clear();
+			// Mark all tiles as dirty
+			MovingMapCache.getCache().clearUsedFlags();
 
-		// Holds areas not filled by currentmap and/or used tiles
-		final Vector rectangles = new Vector();
-		// calculate areas which will not drawn
-		final Point mapPosx = getMapPositionOnScreen();
-		if ( screenNotCompletlyCovered &amp;&amp; ( // screen not completely covered is only used, because it is already calculated
-				mapPosx.x &gt; this.width || mapPosx.y &gt; this.height // map doesn't overlap with the screen
-				|| mapPosx.x + mmp.mapImage.getWidth() &lt; 0 || mapPosx.y + mmp.mapImage.getHeight() &lt; 0) ) {
-			rectangles.add(new Rect(0,0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
-		} else {
-			final Rect whiteArea = new Rect((-width/10), (-height/10), (int)(width*1.1), (int)(height*1.1));
-			final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
-			calculateRectangles(blackArea, whiteArea, rectangles);
-		}
-		// I've sometimes experienced an endless loop which might be
-		// caused by a bug in getBestMap. Therefore i will stop the loop
-		// after 30 runs
-		int count = 0;
-		while (isFillWhiteArea() &amp;&amp; currentMap.zoomFactor == 1.0
-				&amp;&amp; !mapHidden &amp;&amp; !rectangles.isEmpty() &amp;&amp; count &lt; 30) {
-			count++;
-			try {
-				updateTileForWhiteArea(rectangles);
+			// Holds areas not filled by currentmap and/or used tiles
+			final Vector rectangles = new Vector();
+			// calculate areas which will not drawn
+			final Point mapPosx = getMapPositionOnScreen();
+			if (screenNotCompletlyCovered &amp;&amp; ( // screen not completely covered is only used, because it is already calculated
+					mapPosx.x &gt; this.width || mapPosx.y &gt; this.height // map doesn't overlap with the screen
+							|| mapPosx.x + mmp.mapImage.getWidth() &lt; 0 || mapPosx.y + mmp.mapImage.getHeight() &lt; 0)) {
+				rectangles.add(new Rect(0, 0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
+			} else {
+				final Rect whiteArea = new Rect((-width / 10), (-height / 10), (int) (width * 1.1), (int) (height * 1.1));
+				final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
+				calculateRectangles(blackArea, whiteArea, rectangles);
 			}
-			catch (final ewe.sys.SystemResourceException sre) {
-				// next time there may be no problem, and ask only once
-				if (reflectResourceException) {
-					if (new MessageBox(
-							&quot;Error&quot;,
-							&quot;Not enough ressources to fill white ares, disabling this&quot;,
-							MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
-						setFillWhiteArea(false);
-						reflectResourceException=true;
+			// I've sometimes experienced an endless loop which might be
+			// caused by a bug in getBestMap. Therefore i will stop the loop
+			// after 30 runs
+			int count = 0;
+			while (isFillWhiteArea() &amp;&amp; currentMap.zoomFactor == 1.0 &amp;&amp; !mapHidden &amp;&amp; !rectangles.isEmpty() &amp;&amp; count &lt; 30) {
+				count++;
+				try {
+					updateTileForWhiteArea(rectangles);
+				} catch (final ewe.sys.SystemResourceException sre) {
+					// next time there may be no problem, and ask only once
+					if (reflectResourceException) {
+						if (new MessageBox(&quot;Error&quot;, &quot;Not enough ressources to fill white ares, disabling this&quot;, MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
+							setFillWhiteArea(false);
+							reflectResourceException = true;
+						} else {
+							reflectResourceException = false;
+						}
 					}
-					else {
-						reflectResourceException=false;
-					}
 				}
 			}
-		}
-		}
-		finally {
+		} finally {
 			// Remove all tiles not needed from the cache to reduce memory
 			MovingMapCache.getCache().cleanCache();
 			// At Last redraw all icons on the map
 			mmp.images.addAll(icons);
 			Vm.showWait(false);
-			dontUpdatePos=false; // do next Position
+			dontUpdatePos = false; // do next Position
 			repaint();
 		}
 	}
+
 	private void updateTileForWhiteArea(Vector rectangles) {
 		Rect blackArea;
 		final Rect r = (Rect) rectangles.get(0);
 		rectangles.removeElementAt(0);
-		//calculate the center of the rectangle and try to get an map for it
-		final int middlewidth = r.x + (r.width)/2;
-		final int middleheight = r.y + (r.height)/2;
+		// calculate the center of the rectangle and try to get an map for it
+		final int middlewidth = r.x + (r.width) / 2;
+		final int middleheight = r.y + (r.height) / 2;
 		final CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
-		final Rect screen = new Rect ();
-		screen.height = r.height ;//- r.y;
-		screen.width = r.width ;//- r.x;
-		final MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true,false);
-		if (bestMap == null){
-			//No map found, area must be left white
+		final Rect screen = new Rect();
+		screen.height = r.height;// - r.y;
+		screen.width = r.width;// - r.x;
+		final MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true, false);
+		if (bestMap == null) {
+			// No map found, area must be left white
 			return;
 		}
-		//A map was found, but it does not contain the previously calculated center
-		if (!(bestMap.bottomright.latDec &lt;= centerPoint.latDec &amp;&amp; centerPoint.latDec &lt;= bestMap.topleft.latDec)){
+		// A map was found, but it does not contain the previously calculated center
+		if (!(bestMap.bottomright.latDec &lt;= centerPoint.latDec &amp;&amp; centerPoint.latDec &lt;= bestMap.topleft.latDec)) {
 			return;
 		}
-		if (!(bestMap.topleft.lonDec &lt;= centerPoint.lonDec &amp;&amp; centerPoint.lonDec &lt;= bestMap.bottomright.lonDec)){
+		if (!(bestMap.topleft.lonDec &lt;= centerPoint.lonDec &amp;&amp; centerPoint.lonDec &lt;= bestMap.bottomright.lonDec)) {
 			return;
 		}
-		//Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
-		//For me, showing a message seems better than throwing the NPE
+		// Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
+		// For me, showing a message seems better than throwing the NPE
 		final String imagefilename = bestMap.getImageFilename();
-		if (imagefilename == null){
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, FormBase.OKB)).execute();
+		if (imagefilename == null) {
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;) + currentMap.fileNameWFL, FormBase.OKB)).execute();
 			return;
 		}
 
 		if (!imagefilename.equals(currentMap.getImageFilename())) {
 			final String filename = bestMap.getImageFilename();
 			if (filename.length() &gt; 0) {
-				//calculate position of the new map on the screen
+				// calculate position of the new map on the screen
 				final Point mapPos = new Point();
 				final Point mapposint = bestMap.calcMapXY(posCircle.where);
 				mapPos.x = posCircleX - mapposint.x;
 				mapPos.y = posCircleY - mapposint.y;
 				final Point mapDimension = bestMap.calcMapXY(bestMap.bottomright);
-				blackArea = new Rect (mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
-				//Are there any white areas left?
+				blackArea = new Rect(mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
+				// Are there any white areas left?
 				calculateRectangles(blackArea, r, rectangles);
-				//Not all maps have the dimension 1000x1000 Pixels, we cache this information:
-				Dimension rect2 = MovingMapCache.getCache().getDimension (filename);
+				// Not all maps have the dimension 1000x1000 Pixels, we cache this information:
+				Dimension rect2 = MovingMapCache.getCache().getDimension(filename);
 				MapImage fullImage = null;
-				if (rect2 == null){
+				if (rect2 == null) {
 					fullImage = new MapImage(filename);
-					rect2 = new Dimension (fullImage.getHeight(), fullImage.getWidth());
-					MovingMapCache.getCache ().putDimension (filename, rect2);
+					rect2 = new Dimension(fullImage.getHeight(), fullImage.getWidth());
+					MovingMapCache.getCache().putDimension(filename, rect2);
 				}
 				generateTiles(blackArea, filename, mapPos, rect2, fullImage);
 			}
 		}
 	}
 
-	private void generateTiles(Rect blackArea, String filename, Point mapPos,
-			Dimension rect2, MapImage fullImage) {
-		//Generate tiles from the map
-		final int numRows = ((rect2.height-1)/tileHeight)+1;
-		final int numCols = ((rect2.width-1)/tileWidth)+1;
+	private void generateTiles(Rect blackArea, String filename, Point mapPos, Dimension rect2, MapImage fullImage) {
+		// Generate tiles from the map
+		final int numRows = ((rect2.height - 1) / tileHeight) + 1;
+		final int numCols = ((rect2.width - 1) / tileWidth) + 1;
 		for (int row = 0; row &lt; numRows; row++) {
 			for (int column = 0; column &lt; numCols; column++) {
-				//Tile is not needed, don't process
+				// Tile is not needed, don't process
 				if (!isCoveredByBlackArea(mapPos, row, column, blackArea, rect2)) {
 					continue;
 				}
-				//Get tile from cache or if not found, put all tiles for this image into the cache.
+				// Get tile from cache or if not found, put all tiles for this image into the cache.
 				MapImage im = MovingMapCache.getCache().get(filename, row, column);
 				if (im == null) {
-					if (fullImage == null){
+					if (fullImage == null) {
 						fullImage = new MapImage(filename);
 					}
 					putImageIntoCache(filename, fullImage, mapPos, blackArea);
 					im = MovingMapCache.getCache().get(filename, row, column);
 				}
-				//If a tile has been found, draw it on the screen
+				// If a tile has been found, draw it on the screen
 				if (im != null) {
-					//Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
-					boolean added=false;
-					for(int i=mmp.images.size()-1; i &gt;= 0; i--) {
-						final MapImage m=(MapImage) mmp.images.get(i);
-						if (m == im){
-							added=true;
+					// Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
+					boolean added = false;
+					for (int i = mmp.images.size() - 1; i &gt;= 0; i--) {
+						final MapImage m = (MapImage) mmp.images.get(i);
+						if (m == im) {
+							added = true;
 							break;
 						}
 					}
-					if(!added){
+					if (!added) {
 						im.setLocation(mapPos.x + (column * tileWidth), mapPos.y + (row * tileHeight));
 						mmp.addImage(im);
 					}
@@ -1284,13 +1304,13 @@
 
 	private void putImageIntoCache(String filename, MapImage fullImage, Point mapPos, Rect blackArea) {
 		MapImage im;
-		final int numRows = (fullImage.getHeight()-1)/tileHeight + 1;
-		final int numCols = (fullImage.getWidth()-1)/tileWidth + 1;
+		final int numRows = (fullImage.getHeight() - 1) / tileHeight + 1;
+		final int numCols = (fullImage.getWidth() - 1) / tileWidth + 1;
 		for (int row2 = 0; row2 &lt; numRows; row2++) {
 			for (int column2 = 0; column2 &lt; numCols; column2++) {
-				final int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth*column2));
-				final int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight*row2));
-				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))){
+				final int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth * column2));
+				final int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight * row2));
+				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))) {
 					continue;
 				}
 				final Image image2 = new Image(realWidth, realHeight);
@@ -1305,54 +1325,57 @@
 		}
 	}
 
-	private boolean isCoveredByBlackArea (Point mapPos, int row,int column,Rect blackArea, Dimension mapDimension){
-		final int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth*column));
-		final int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight*row));
+	private boolean isCoveredByBlackArea(Point mapPos, int row, int column, Rect blackArea, Dimension mapDimension) {
+		final int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth * column));
+		final int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight * row));
 		final int left = mapPos.x + column * tileWidth;
 		final int right = left + realWidth;
 		final int top = mapPos.y + row * tileHeight;
-		final int bottom = top +realHeight;
-		if (right &lt; blackArea.x || bottom &lt; blackArea.y){
+		final int bottom = top + realHeight;
+		if (right &lt; blackArea.x || bottom &lt; blackArea.y) {
 			return false;
 		}
-		if (left &gt; blackArea.x + blackArea.width || top &gt; blackArea.y + blackArea.height){
+		if (left &gt; blackArea.x + blackArea.width || top &gt; blackArea.y + blackArea.height) {
 			return false;
 		}
 		return true;
 	}
+
 	/*
-	private String SRect(Rect r){
-		String OL, UR ;
-		OL= &quot; (&quot;+String.valueOf(r.x)+&quot;,&quot;+String.valueOf(r.y)+&quot;)&quot;;
-		UR= &quot; (&quot;+String.valueOf(r.x+r.width)+&quot;,&quot;+String.valueOf(r.y+r.height)+&quot;) &quot;;
-		return OL+&quot; :&quot;+UR;
-	}
-	*/
+	 * private String SRect(Rect r){
+	 * String OL, UR ;
+	 * OL= &quot; (&quot;+String.valueOf(r.x)+&quot;,&quot;+String.valueOf(r.y)+&quot;)&quot;;
+	 * UR= &quot; (&quot;+String.valueOf(r.x+r.width)+&quot;,&quot;+String.valueOf(r.y+r.height)+&quot;) &quot;;
+	 * return OL+&quot; :&quot;+UR;
+	 * }
+	 */
 	private void calculateRectangles(Rect blackArea, Rect whiteArea, Vector rectangles) {
-		if (width == 0 || height == 0) return;
-		final int offsetX = width/10;
-		final int offsetY = height/10;
-		final int width=this.width+offsetX;
-		final int height=this.height+offsetY;
-		if (whiteArea.x &gt;= width || whiteArea.y &gt;= height) return;
+		if (width == 0 || height == 0)
+			return;
+		final int offsetX = width / 10;
+		final int offsetY = height / 10;
+		final int width = this.width + offsetX;
+		final int height = this.height + offsetY;
+		if (whiteArea.x &gt;= width || whiteArea.y &gt;= height)
+			return;
 
-		if (blackArea.x &lt; -offsetX){
+		if (blackArea.x &lt; -offsetX) {
 			blackArea.width += blackArea.x + offsetX;
 			blackArea.x = -offsetX;
 		}
-		if (blackArea.y &lt; -offsetY){
+		if (blackArea.y &lt; -offsetY) {
 			blackArea.height += blackArea.y + offsetY;
 			blackArea.y = -offsetY;
 		}
-		if (blackArea.x + blackArea.width &gt; width){
+		if (blackArea.x + blackArea.width &gt; width) {
 			blackArea.width = width - blackArea.x;
 		}
-		if (blackArea.y + blackArea.height &gt; height){
+		if (blackArea.y + blackArea.height &gt; height) {
 			blackArea.height = height - blackArea.y;
 		}
 
 		if (blackArea.x &gt; whiteArea.x) {
-			final Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = -offsetX;
 			r.y = whiteArea.y;
 			r.width = blackArea.x + offsetX;
@@ -1360,23 +1383,23 @@
 			rectangles.add(r);
 		}
 		if (blackArea.y &gt; whiteArea.y) {
-			final Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = -offsetY;
 			r.width = whiteArea.width;
 			r.height = blackArea.y + offsetY;
 			rectangles.add(r);
 		}
-		if ((blackArea.y + blackArea.height) &lt;  whiteArea.y + whiteArea.height) {
-			final Rect r= new Rect ();
+		if ((blackArea.y + blackArea.height) &lt; whiteArea.y + whiteArea.height) {
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = blackArea.y + blackArea.height;
 			r.width = whiteArea.width;
 			r.height = (whiteArea.y + whiteArea.height) - r.y;
 			rectangles.add(r);
 		}
-		if ((blackArea.x + blackArea.width)&lt;  whiteArea.x + whiteArea.width) {
-			final Rect r= new Rect ();
+		if ((blackArea.x + blackArea.width) &lt; whiteArea.x + whiteArea.width) {
+			final Rect r = new Rect();
 			r.x = blackArea.x + blackArea.width;
 			r.y = whiteArea.y;
 			r.width = (whiteArea.x + whiteArea.width) - r.x;
@@ -1386,18 +1409,20 @@
 	}
 
 	public void updateGps(int fix) {
-		if (!running || ignoreGps) return;
+		if (!running || ignoreGps)
+			return;
 		// runMovingMap neccessary in case of multi-threaded Java-VM:
 		// ticked could be called during load of mmp
-		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
-			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
-					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) { // TODO is getSats really necessary?
+			directionArrows.setDirections((float) myNavigation.gpsPos.getBearing(myNavigation.destination), (float) myNavigation.skyOrientationDir.lonDec, (float) myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos);
 			ShowLastAddedPoint(myNavigation.curTrack);
 		}
-		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
-		if (fix &lt; 0 )	setGpsStatus(MovingMap.noGPSData);
+		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats() == 0)
+			setGpsStatus(MovingMap.lostFix);
+		if (fix &lt; 0)
+			setGpsStatus(MovingMap.noGPSData);
 		controlsLayer.updateContent(&quot;hdop&quot;, Convert.toString(myNavigation.gpsPos.getHDOP()));
 		controlsLayer.updateContent(&quot;sats&quot;, Convert.toString(myNavigation.gpsPos.getSats()) + &quot;/&quot; + Convert.toString(myNavigation.gpsPos.getSatsInView()));
 	}
@@ -1406,6 +1431,7 @@
 		addTrack(myNavigation.curTrack);
 		ignoreGps = false;
 	}
+
 	public void gpsStoped() {
 		setGpsStatus(MovingMap.noGPS);
 	}
@@ -1413,7 +1439,8 @@
 	int mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 	float scaleWanted;
 	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
-	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the
+														// wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
 	public final static int HIGHEST_RESOLUTION = 2;
 	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
 	boolean inBestMap = false; // to avoid multi-threading problems
@@ -1426,18 +1453,19 @@
 	 * but anyway the map will be adjusted (moved) relativ to posCircle
 	 * when a better map was found the called method updateposition will set
 	 * posCirleLat/-Lon to lat/lon.
-	 *
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @param loadIfSameScale
-	 * 			false: will not change the map if the better map has the same scale as the current
-	 * 			  - this is used not to change the map if it covers already the screen completely
-	 * 			true: willchange the map, regardless of change in scale
+	 *            false: will not change the map if the better map has the same scale as the current
+	 *            - this is used not to change the map if it covers already the screen completely
+	 *            true: willchange the map, regardless of change in scale
 	 */
 	public void setBestMap(CWPoint where, boolean loadIfSameScale) {
-		if (inBestMap) return;
+		if (inBestMap)
+			return;
 		inBestMap = true;
-		final Object [] s = getRectForMapChange(where);
+		final Object[] s = getRectForMapChange(where);
 		final CWPoint cll = (CWPoint) s[0];
 		final Rect screen = (Rect) s[1];
 		final boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
@@ -1446,41 +1474,46 @@
 		switch (mapChangeModus) {
 		case NORMAL_KEEP_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, scaleWanted, false,true);
-			if (newmap == null) newmap = currentMap;
-			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			newmap = maps.getBestMap(cll, screen, scaleWanted, false, true);
+			if (newmap == null)
+				newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap))
+				wantMapTest = false;
 			break;
 		case HIGHEST_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+			newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			break;
 		case HIGHEST_RESOLUTION_GPS_DEST:
-			if (gotoPos!= null &amp;&amp; GpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
-				if ( ( !posCircleOnScreen ) &amp;&amp; ( lastHighestResolutionGPSDestScale &gt; 0 ) ) {
-					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+			if (gotoPos != null &amp;&amp; GpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
+				if ((!posCircleOnScreen) &amp;&amp; (lastHighestResolutionGPSDestScale &gt; 0)) {
+					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 				} else {
 					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
-					if (newmap == null)	newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false,true); // use map with most available overview if no map containing PosCircle and GotoPos is available
+					if (newmap == null)
+						newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false, true); // use map with most available overview if no map containing PosCircle and GotoPos is available
 
 					if (newmap != null) {
 						lastHighestResolutionGPSDestScale = newmap.scale;
 
 						if (!posCircleOnScreen) {
-							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 						}
 					}
 				}
 			}
-			//	either Goto-Pos or GPS-Pos not set
+			// either Goto-Pos or GPS-Pos not set
 			else {
 				lastHighestResolutionGPSDestScale = -1;
-				newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+				newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			}
 			break;
-		default: (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, FormBase.OKB)).execute(); break;
+		default:
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, FormBase.OKB)).execute();
+			break;
 		}
-		if ( newmap != null &amp;&amp; (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
-			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+		if (newmap != null &amp;&amp; (currentMap == null || !currentMap.mapName.equals(newmap.mapName))) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap)) {
 				// better map found
 				setMap(newmap, where);
 				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
@@ -1492,31 +1525,37 @@
 			// F?r die aktuelle Position steht keine Karte zur Verf?ng
 			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
 			try {
-				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
-			} catch (final IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec(); }
+				setMap(((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec();
+			}
 			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
 				mmp.chooseMap(); // force the user to select a scale
-				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
+				if (currentMap == null)
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
 			}
 		}
 		inBestMap = false;
 	}
 
-	public void setResModus (int modus) {
+	public void setResModus(int modus) {
 		scaleWanted = currentMap.scale;
-		if (mapChangeModus == modus) return;
+		if (mapChangeModus == modus)
+			return;
 		mapChangeModus = modus;
 		lastHighestResolutionGPSDestScale = -1;
 		if (modus != NORMAL_KEEP_RESOLUTION) {
 			setBestMap(posCircle.where, true);
 		}
 	}
+
 	/**
 	 * method to get a point on the screen which must be included in the map
 	 * the map methods are looking for. If the poscircle is on the screen this will be
 	 * that point. If it is outside then the centre of the screen will be used.
-	 *
+	 * 
 	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
@@ -1530,12 +1569,13 @@
 		if (posCircleX &gt;= 0 &amp;&amp; posCircleX &lt;= w &amp;&amp; posCircleY &gt;= 0 &amp;&amp; posCircleY &lt;= h &amp;&amp; ll.isValid()) {
 			posCircleOnScreen = java.lang.Boolean.TRUE;
 			pX = posCircleX; // posCircle is inside the screen
-			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn vorher PosCircle nicht auf dem
+								// SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
 		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
-			cll = ScreenXY2LatLon(w/2, h/2);
-			pX = w/2;
-			pY = h/2;
+			cll = ScreenXY2LatLon(w / 2, h / 2);
+			pX = w / 2;
+			pY = h / 2;
 		}
 		final Object[] ret = new Object[3];
 		ret[0] = cll;
@@ -1545,18 +1585,19 @@
 	}
 
 	/**
-	 *
-	 * @param betterOverview true: getmap with better overview
+	 * 
+	 * @param betterOverview
+	 *            true: getmap with better overview
 	 * @return
 	 */
-	public void loadMoreDetailedMap(boolean betterOverview){
+	public void loadMoreDetailedMap(boolean betterOverview) {
 		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
 		final int h = (height != 0 ? height : pref.myAppHeight);
-		final Rect screen = new Rect(w/2, h/2, w, h);
+		final Rect screen = new Rect(w / 2, h / 2, w, h);
 
 		CWPoint cll;
 		if (currentMap != null) {
-			cll = ScreenXY2LatLon(w/2, h/2);
+			cll = ScreenXY2LatLon(w / 2, h / 2);
 		} else {
 			cll = new CWPoint(posCircle.where);
 		}
@@ -1571,37 +1612,36 @@
 				fillWhiteArea(true);
 			}
 			dontUpdatePos = saveGpsIgnStatus;
-		}
-		else (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) +
-				(betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;) ) +
-				MyLocale.getMsg(4214, &quot; detailed map available&quot;),
-				FormBase.OKB)).execute();
+		} else
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) + (betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;)) + MyLocale.getMsg(4214, &quot; detailed map available&quot;), FormBase.OKB)).execute();
 	}
 
-	public void loadMapForAllCaches(){
+	public void loadMapForAllCaches() {
 		final Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
 			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#239;&#191;&#189;ckchen ausgew&#239;&#191;&#189;hlt&quot;), FormBase.OKB)).execute();
 			return;
 		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.bottomright);
-		if (newmap == null ) { // no map that includs all caches is available -&gt; load map with lowest resolution
-			final Object [] s = getRectForMapChange(posCircle.where);
+		if (newmap == null) { // no map that includs all caches is available -&gt; load map with lowest resolution
+			final Object[] s = getRectForMapChange(posCircle.where);
 			final CWPoint cll = (CWPoint) s[0];
 			final Rect screen = (Rect) s[1];
-			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false,true);
+			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE - 1, false, true);
 		}
 		if (newmap == null) { // no map is covering any area of the caches -&gt; zoom an empty map to cover all caches on screen
 			try {
-				final Object [] s = getRectForMapChange(posCircle.where);
-			//	CWPoint cll = (CWPoint) s[0];
+				final Object[] s = getRectForMapChange(posCircle.where);
+				// CWPoint cll = (CWPoint) s[0];
 				final Rect screen = (Rect) s[1];
-				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
-				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
-				newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width - 15)); // 15 for the size of the cache image
+				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height - 15)); // 15 for the size of the cache image
+				newmap = ((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
 				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex &gt; neededscaley ? neededscalex : neededscaley), 0, 0);
 				forceMapLoad = true;
-			} catch (final IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec(); }
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec();
+			}
 		}
 		final boolean saveGpsIgnStatus = dontUpdatePos;
 		dontUpdatePos = true;
@@ -1610,17 +1650,31 @@
 		dontUpdatePos = saveGpsIgnStatus;
 	}
 
-	public void setGpsStatus (int status) {
-		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+	public void setGpsStatus(int status) {
+		if (status == GpsStatus)
+			return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
 		GpsStatus = status;
 		dontUpdatePos = false;
 		ignoreGps = false;
 		switch (status) {
-		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		case noGPS: {
+			posCircle.change(null);
+			ignoreGps = true;
+			break;
 		}
+		case gotFix: {
+			posCircle.change(statusImageHaveSignal);
+			break;
+		}
+		case lostFix: {
+			posCircle.change(statusImageNoSignal);
+			break;
+		}
+		case noGPSData: {
+			posCircle.change(statusImageNoGps);
+			break;
+		}
+		}
 		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
 		posCircle.refreshNow();
 	}
@@ -1634,15 +1688,20 @@
 		autoSelectMap = true;
 		forceMapLoad = true;
 		// showMap(); why this?
-		if (myNavigation.gpsPos.Fix &lt;=0) updatePosition(posCircle.where);
-		else updateGps(myNavigation.gpsPos.getFix());
+		if (myNavigation.gpsPos.Fix &lt;= 0)
+			updatePosition(posCircle.where);
+		else
+			updateGps(myNavigation.gpsPos.getFix());
 	}
 
-	/** sets and displays the map
-	 *
+	/**
+	 * sets and displays the map
+	 * 
 	 * @param newmap
-	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
-	 * @param lon -361: don't adust to lat/lon
+	 * @param lat
+	 *            move map so that lat/lon is in the centre / -361: don't adust to lat/lon
+	 * @param lon
+	 *            -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, CWPoint where) {
 		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) {
@@ -1653,15 +1712,15 @@
 			Vm.showWait(true);
 			boolean saveIgnoreStatus;
 			saveIgnoreStatus = dontUpdatePos;
-			dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
-			pref.log(MyLocale.getMsg(4216, &quot;Loading map...&quot;)+newmap.mapName);
+			dontUpdatePos = true; // make updatePosition ignore calls during loading new map
+			pref.log(MyLocale.getMsg(4216, &quot;Loading map...&quot;) + newmap.mapName);
 			try {
 				this.currentMap = newmap;
 				this.title = currentMap.mapName;
 				// neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 				lastCompareX = Integer.MAX_VALUE;
 				lastCompareY = Integer.MAX_VALUE;
-				if (mmp.mapImage != null ) {
+				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
 					mmp.mapImage = null;
@@ -1671,23 +1730,23 @@
 				}
 				// give memory free before loading the new map to avoid out of memory error
 				final String ImageFilename = currentMap.getImageFilename();
-				if (ImageFilename == null ) {
+				if (ImageFilename == null) {
 					mmp.mapImage = new MapImage();
 					maps.remove(currentMap);
-					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, FormBase.OKB)).execute();
-				}
-				else {
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;) + currentMap.fileNameWFL, FormBase.OKB)).execute();
+				} else {
 					if (ImageFilename.length() &gt; 0) {
 						// attention: when running in native java-vm,
 						// no exception will be thrown, not even OutOfMemeoryError
 						mmp.mapImage = new MapImage(ImageFilename);
-					}
-					else mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
+					} else
+						mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
 				}
 				mapImage1to1 = mmp.mapImage;
 				mmp.mapImage.properties = mmp.mapImage.properties | mImage.IsMoveable;
-				if (mapHidden) mmp.mapImage.hide();
-				mmp.mapImage.move(0,0);
+				if (mapHidden)
+					mmp.mapImage.hide();
+				mmp.mapImage.move(0, 0);
 				mmp.addImage(mmp.mapImage);
 				mmp.images.moveToBack(mmp.mapImage);
 				rebuildOverlaySet();
@@ -1701,7 +1760,7 @@
 				dontUpdatePos = saveIgnoreStatus;
 			} catch (final IllegalArgumentException e) {
 				// thrown by new AniImage() in ewe-vm if file not found;
-				pref.log(&quot;[MovingMap:setMap]IllegalArgumentException&quot;,e,true);
+				pref.log(&quot;[MovingMap:setMap]IllegalArgumentException&quot;, e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
@@ -1710,10 +1769,10 @@
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;)+ newmap.getImageFilename(), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;) + newmap.getImageFilename(), FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
 			} catch (final OutOfMemoryError e) {
-				pref.log(&quot;[MovingMap:setMap]OutOfMemoryError&quot;,e,true);
+				pref.log(&quot;[MovingMap:setMap]OutOfMemoryError&quot;, e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
@@ -1722,13 +1781,11 @@
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;)
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;) + newmap.getImageFilename() + MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;), FormBase.OKB))
+						.execute();
 				dontUpdatePos = saveIgnoreStatus;
-			}catch (final SystemResourceException e) {
-				pref.log(&quot;[MovingMap:setMap]SystemResourceException&quot;,e,true);
+			} catch (final SystemResourceException e) {
+				pref.log(&quot;[MovingMap:setMap]SystemResourceException&quot;, e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
@@ -1736,15 +1793,13 @@
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
-				updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;)
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
+				updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to
+													// test: select a map with a much greater value of m per pixel manually
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;) + newmap.getImageFilename() + MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
 						FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
 			}
-		}
-		finally{
+		} finally {
 			Vm.showWait(false);
 		}
 	}
@@ -1757,17 +1812,18 @@
 		final Point centerOnMap = currentMap.calcMapXY(newCenter);
 		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
 		final int h = (height != 0 ? height : pref.myAppHeight);
-		final int mapPosX = w/2 - centerOnMap.x;
-		final int mapPosY = h/2 - centerOnMap.y;
+		final int mapPosX = w / 2 - centerOnMap.x;
+		final int mapPosY = h / 2 - centerOnMap.y;
 		final int newPosCircleX = mapPosX + circlePosOnMap.x;
 		final int newPosCircleY = mapPosY + circlePosOnMap.y;
 
-		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.move(mapPosX, mapPosY);
 
 		final int wCircle = posCircle.getWidth();
 		final int hCircle = posCircle.getHeight();
-		final int npx = newPosCircleX-wCircle/2;
-		final int npy = newPosCircleY-hCircle/2;
+		final int npx = newPosCircleX - wCircle / 2;
+		final int npy = newPosCircleY - hCircle / 2;
 		posCircle.move(npx, npy);
 		posCircleX = newPosCircleX;
 		posCircleY = newPosCircleY;
@@ -1778,9 +1834,9 @@
 	public void hideMap() {
 		if (mmp != null &amp;&amp; mmp.mapImage != null)
 			mmp.mapImage.hide();
-		for(final Iterator i=mmp.images.iterator(); i.hasNext ();){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
 			final AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)){
+			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)) {
 				((MapImage) image).hide();
 			}
 		}
@@ -1789,63 +1845,64 @@
 	}
 
 	public void showMap() {
-		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.unhide();
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.unhide();
 		mapHidden = false;
-		for(final Iterator i=mmp.images.iterator(); i.hasNext ();){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
 			final AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)){
+			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)) {
 				((MapImage) image).unhide();
 			}
 		}
 		repaintNow();
 	}
-/*
-	public void setZoomingMode() {
-		repaintNow();
-		zoomingMode = true;
-	}
-*/
+
+	/*
+	 * public void setZoomingMode() {
+	 * repaintNow();
+	 * zoomingMode = true;
+	 * }
+	 */
 	/**
 	 * zommes in if w&gt;0 and out if w&lt;0
+	 * 
 	 * @param firstclickpoint
 	 * @param w
 	 * @param h
 	 */
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
-		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
-		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		int newImageWidth = (int) (this.width * (this.width &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
+		int newImageHeight = (int) (this.height * (this.width &lt; 481 ? 2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
+		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w / 2, firstclickpoint.y + h / 2);
 		float zoomFactor;
 		if (h &lt; 0) {
 			h = java.lang.Math.abs(h);
 			firstclickpoint.y = firstclickpoint.y - h;
 		}
 		if (w &gt; 0) { // zoom in
-			zoomFactor = java.lang.Math.min((float)this.width / (float)w, (float)this.height / (float)h);
-		}
-		else { // zoom out
+			zoomFactor = java.lang.Math.min((float) this.width / (float) w, (float) this.height / (float) h);
+		} else { // zoom out
 			w = java.lang.Math.abs(w);
 			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
-			zoomFactor = java.lang.Math.max((float)w / (float)this.width, (float)h / (float)this.height);
+			zoomFactor = java.lang.Math.max((float) w / (float) this.width, (float) h / (float) this.height);
 		}
 		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
 		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
 		final Point mappos = getMapPositionOnScreen();
-		final int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-		final int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-		final Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
-		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
-		{
+		final int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w / 2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth / 2);
+		final int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h / 2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight / 2);
+		final Rect newImageRect = new Rect(xinunscaledimage, yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null) {
 			// try to avoid overlapping by shifting
 			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0; // align left if left overlapping
 			if (newImageRect.y &lt; 0)
 				newImageRect.y = 0;
 			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
-				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+				newImageRect.x = mapImage1to1.getWidth() - newImageWidth; // align right if right overlaping
 			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
-				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+				newImageRect.y = mapImage1to1.getHeight() - newImageHeight;
 			// crop if after shifting still overlapping
 			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0;
@@ -1854,14 +1911,13 @@
 			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
 				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
 			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
-				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+				newImageRect.height = mapImage1to1.getHeight() - newImageRect.y;
 		}
 		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
 	}
 
 	public void zoomin() {
-		zoomScreenRect(new Point(this.width / 4, this.height / 4),
-				this.width / 2, this.height / 2);
+		zoomScreenRect(new Point(this.width / 4, this.height / 4), this.width / 2, this.height / 2);
 	}
 
 	public void zoomout() {
@@ -1871,8 +1927,7 @@
 			zoomfactor = 1;
 		}
 		if (mapImage1to1 != null)
-			zoomFromUnscaled(zoomfactor, new Rect(0, 0,
-					mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+			zoomFromUnscaled(zoomfactor, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
 		else
 			zoomFromUnscaled(zoomfactor, new Rect(0, 0, 1, 1), center);
 	}
@@ -1882,18 +1937,23 @@
 	}
 
 	public void zoom1to1() {
-		final CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+		final CWPoint center = ScreenXY2LatLon(this.width / 2, this.height / 2);
+		if (mapImage1to1 != null)
+			zoomFromUnscaled(1, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else
+			zoomFromUnscaled(1, new Rect(0, 0, 1, 1), center);
 	}
 
 	/**
 	 * do the actual scaling
-	 * @param zoomFactor relative to original image
-	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * 
+	 * @param zoomFactor
+	 *            relative to original image
+	 * @param newImageRect
+	 *            Rect in the 1:1 image that contains the area to be zoomed into
 	 * @param center
 	 */
-	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+	public void zoomFromUnscaled(float zoomFactor, Rect newImageRect, CWPoint center) {
 		Vm.showWait(this, true);
 		final boolean savegpsstatus = dontUpdatePos;
 		if (mapImage1to1 != null) {
@@ -1907,31 +1967,35 @@
 				if (mmp.mapImage != mapImage1to1) {
 					mmp.mapImage.free();
 					mmp.mapImage = null;
-				} else tmp = mapImage1to1;
+				} else
+					tmp = mapImage1to1;
 			}
 			Vm.getUsedMemory(true);
 			try {
-				if (zoomFactor == 1) tmp = mapImage1to1;
-				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				if (zoomFactor == 1)
+					tmp = mapImage1to1;
+				else
+					tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width * zoomFactor), (int) (newImageRect.height * zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 			} catch (final OutOfMemoryError e) {
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;),
-						MyLocale.getMsg(4222, &quot;Out of memory error&quot;), FormBase.OKB)).execute();
-				//tmp = mapImage1to1;
-			} //if (tmp != null) currentMap.zoom();}
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4222, &quot;Out of memory error&quot;), FormBase.OKB)).execute();
+				// tmp = mapImage1to1;
+			} // if (tmp != null) currentMap.zoom();}
 			Vm.getUsedMemory(true);
 			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
-			if (mapHidden) mmp.mapImage.hide();
+			if (mapHidden)
+				mmp.mapImage.hide();
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
-			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
-			{
+			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null) {
 				final Point mappos = getMapPositionOnScreen();
-				mmp.mapImage.move(mappos.x,mappos.y);
+				mmp.mapImage.move(mappos.x, mappos.y);
 			}
 		} else // no map image loaded
-		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+		{
+			currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+		}
 		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
 		Vm.getUsedMemory(true); // call garbage collection
@@ -1943,15 +2007,11 @@
 		dontUpdatePos = savegpsstatus;
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
+	public void onEvent(Event ev) {
+		if (ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED)) {
 			running = false;
 		}
-		if( ev instanceof KeyEvent &amp;&amp;
-			ev.target == this &amp;&amp;
-			( (((KeyEvent)ev).key == IKeys.ESCAPE) ||
-			  (((KeyEvent)ev).key == IKeys.ENTER) ||
-			  (((KeyEvent)ev).key == IKeys.ACTION) ) ) {
+		if (ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; ((((KeyEvent) ev).key == IKeys.ESCAPE) || (((KeyEvent) ev).key == IKeys.ENTER) || (((KeyEvent) ev).key == IKeys.ACTION))) {
 			this.close(0);
 			ev.consumed = true;
 		}
@@ -1972,8 +2032,8 @@
 		if (CHANGE_MAP_DIR == actionCommand) {
 			final FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 			fc.addMask(&quot;*.wfl&quot;);
-			fc.setTitle(MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
-			if(fc.execute() != FormBase.IDCANCEL){
+			fc.setTitle(MyLocale.getMsg(4200, &quot;Select map directory:&quot;));
+			if (fc.execute() != FormBase.IDCANCEL) {
 				Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
 				loadMaps(Global.getPref().getCustomMapsPath(), posCircle.where.latDec);
 				forceMapLoad();
@@ -1982,27 +2042,27 @@
 		}
 		if (FILL_MAP == actionCommand) {
 			setFillWhiteArea(true);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (NO_FILL_MAP == actionCommand) {
 			setFillWhiteArea(false);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (SHOW_CACHES == actionCommand) {
 			setShowCachesOnMap(true);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (HIDE_CACHES == actionCommand) {
 			setShowCachesOnMap(false);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
@@ -2043,7 +2103,7 @@
 			return true;
 		}
 		if (MOVE_TO_DEST == actionCommand) {
-			if (gotoPos!=null) {
+			if (gotoPos != null) {
 				setCenterOfScreen(gotoPos.where, true);
 			}
 			return true;
@@ -2076,22 +2136,20 @@
 		return mapHidden;
 	}
 
-
 	public void setPaintPosDestLine(boolean paintPosDestLine) {
 		this.paintPosDestLine = paintPosDestLine;
 	}
 
-
 }
 
 /**
- *	Class to display the map bitmap and to select another bitmap to display.
+ * Class to display the map bitmap and to select another bitmap to display.
  */
 class MovingMapPanel extends InteractivePanel implements EventListener {
 	Menu kontextMenu;
 	MenuItem gotoMenuItem = new MenuItem(MyLocale.getMsg(4230, &quot;Goto here$g&quot;), 0, null);
 	MenuItem newWayPointMenuItem = new MenuItem(MyLocale.getMsg(4232, &quot;Create new Waypoint here$n&quot;), 0, null);;
-	MenuItem openCacheDescMenuItem,openCacheDetailMenuItem,addCachetoListMenuItem,gotoCacheMenuItem,hintMenuItem,missionMenuItem;
+	MenuItem openCacheDescMenuItem, openCacheDetailMenuItem, addCachetoListMenuItem, gotoCacheMenuItem, hintMenuItem, missionMenuItem;
 
 	MenuItem miLuminary[];
 
@@ -2103,45 +2161,49 @@
 	boolean paintingZoomArea;
 
 	ImageList saveImageList = null;
-	int lastZoomWidth , lastZoomHeight;
+	int lastZoomWidth, lastZoomHeight;
 
-	boolean ignoreNextDrag=false;
-	boolean onlyIfCache=false;
+	boolean ignoreNextDrag = false;
+	boolean onlyIfCache = false;
 
-	public MovingMapPanel(MovingMap f){
+	public MovingMapPanel(MovingMap f) {
 		this.mm = f;
 		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
-		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i &lt; SkyOrientation.LUMINARY_NAMES.length; i++) {
 			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
 		}
 		set(ControlConstants.WantHoldDown, true); // want to get simulated right-clicks
 	}
 
-	public boolean imageBeginDragged(AniImage which,Point pos) {
+	public boolean imageBeginDragged(AniImage which, Point pos) {
 		if (mm.zoomingMode == true) { // zoom
-//			saveMapLoc = pos;
-			//		saveGpsIgnoreStatus = mm.ignoreGps;
-			//	mm.ignoreGps = true;
+			// saveMapLoc = pos;
+			// saveGpsIgnoreStatus = mm.ignoreGps;
+			// mm.ignoreGps = true;
 			return false;
 		}
 		if (mm.getControlsLayer().imageBeginDragged(which, pos)) {
 			return false;
 		}
 		// move (drag) map
-		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		// if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.dontUpdatePos;
 		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
-		else return super.imageBeginDragged(null, pos);
+		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden)
+			return super.imageBeginDragged(mapImage, pos);
+		else
+			return super.imageBeginDragged(null, pos);
 	}
 
-	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+	public boolean imageNotDragged(ImageDragContext dc, Point pos) {
 		final boolean ret = super.imageNotDragged(dc, pos);
 		bringMaptoBack();
-		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		if (dc.image == null)
+			moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else
+			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 		mm.dontUpdatePos = saveGpsIgnoreStatus;
 		this.repaintNow();
 		return ret;
@@ -2150,64 +2212,71 @@
 	public void onPenEvent(PenEvent ev) {
 		if (ignoreNextDrag) {
 			// On PDA next event after a Kontext ist a drag, that will move the map unwanted
-			ignoreNextDrag=false;
-			if (ev.type == PenEvent.PEN_DRAG) return; // ignoring now
+			ignoreNextDrag = false;
+			if (ev.type == PenEvent.PEN_DRAG)
+				return; // ignoring now
 		}
 		if (ev.type == PenEvent.PEN_DOWN) {
 			if (mm.zoomingMode) {
 				saveGpsIgnoreStatus = mm.dontUpdatePos;
 				mm.dontUpdatePos = true;
-				saveMapLoc = new Point (ev.x, ev.y);
+				saveMapLoc = new Point(ev.x, ev.y);
 				paintingZoomArea = true;
 				mm.zoomingMode = true;
-			}
-			else {
-				saveMapLoc = new Point (ev.x, ev.y);
+			} else {
+				saveMapLoc = new Point(ev.x, ev.y);
 				if (ev.modifiers == PenEvent.RIGHT_BUTTON) {
 					// context penHeld is fired directly on PDA (cause WantHoldDown Control Modifier)
 					// but not on PC (Java) , therefor it is here
-					penHeld(new Point (ev.x, ev.y));
-				}
-				else {
+					penHeld(new Point(ev.x, ev.y));
+				} else {
 					// do it even on left klick
-					onlyIfCache=true;
-					penHeld(new Point (ev.x, ev.y));
+					onlyIfCache = true;
+					penHeld(new Point(ev.x, ev.y));
 				}
 			}
-		}
-		else {
+		} else {
 			if (mm.zoomingMode) {
-				if ( ev.type == PenEvent.PEN_UP ) {
+				if (ev.type == PenEvent.PEN_UP) {
 					paintingZoomArea = false;
 					mm.zoomingMode = false;
 					mm.getControlsLayer().changeRoleState(&quot;zoom_manually&quot;, false);
 					mm.dontUpdatePos = saveGpsIgnoreStatus;
-					if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15)  {
+					if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15) {
 						repaintNow();
 						return; // dont make to big zoom jumps - it is most probable not an intentional zoom
 					}
 					mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 				}
-				if (paintingZoomArea &amp;&amp;
-					(ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+				if (paintingZoomArea &amp;&amp; (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
 					int left, top;
 					final Graphics dr = this.getGraphics();
-					if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
+					if (lastZoomWidth &lt; 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight &lt; 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
 					left -= 2;
 					top -= 2;
-					if (top &lt; 0) top = 0;
-					if (left &lt; 0) left = 0;
-					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+					if (top &lt; 0)
+						top = 0;
+					if (left &lt; 0)
+						left = 0;
+					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth) + 4, java.lang.Math.abs(lastZoomHeight) + 4));
 					lastZoomWidth = ev.x - saveMapLoc.x;
-					lastZoomHeight =  ev.y - saveMapLoc.y;
-					if (lastZoomWidth &lt; 0) left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
-					dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+					lastZoomHeight = ev.y - saveMapLoc.y;
+					if (lastZoomWidth &lt; 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight &lt; 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
+					dr.setPen(new Pen(new Color(255, 0, 0), Pen.SOLID, 3));
 					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
 				}
 			}
@@ -2225,28 +2294,30 @@
 		images.removeAllElements();
 		images.add(mapImage);
 	}
+
 	private void bringMaptoBack() {
-		if (saveImageList == null) return;
+		if (saveImageList == null)
+			return;
 		images = saveImageList;
 		saveImageList = null;
 	}
 
 	public void moveMap(int diffX, int diffY) {
 		Point p = new Point();
-		if (mapImage!= null) {
+		if (mapImage != null) {
 			p = mapImage.locAlways;
-			mapImage.move(p.x+diffX,p.y+diffY);
-			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+			mapImage.move(p.x + diffX, p.y + diffY);
+			// if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
 
-	public void mapMoved(int diffX, int diffY){
+	public void mapMoved(int diffX, int diffY) {
 		mm.mapMoved(diffX, diffY);
 		this.repaintNow();
 	}
 
-	public void doPaint(Graphics g,Rect area) {
+	public void doPaint(Graphics g, Rect area) {
 		super.doPaint(g, area);
 		if (mm.gotoPos != null &amp;&amp; mm.paintPosDestLine) {
 			final Point dest = mm.getXYonScreen(mm.gotoPos.where);
@@ -2257,12 +2328,14 @@
 
 	public void chooseMap() {
 		CWPoint gpspos;
-		if (mm.myNavigation.gpsPos.Fix &gt; 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
-		else gpspos = null;
+		if (mm.myNavigation.gpsPos.Fix &gt; 0)
+			gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else
+			gpspos = null;
 		final ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
-		if(l.execute() == FormBase.IDOK){
+		if (l.execute() == FormBase.IDOK) {
 			mm.autoSelectMap = false;
-			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length()==0) {
+			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length() == 0) {
 				mm.setMap(l.selectedMap, mm.posCircle.where);
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.ignoreGps = false;
@@ -2273,24 +2346,24 @@
 				if (mm.currentMap.fileNameWFL.length() &gt; 0)
 					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
-				//mm.posCircleX = 0; // place map to the upper left corner of windows
-				//mm.posCircleY = 0;
-				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+				// Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				// double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
+				// mm.posCircleX = 0; // place map to the upper left corner of windows
+				// mm.posCircleY = 0;
+				// mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
 			}
 		}
 	}
 
 	/**
-	 *	Method to react to user.
+	 * Method to react to user.
 	 */
-	public void imageClicked(AniImage which, Point pos){
+	public void imageClicked(AniImage which, Point pos) {
 		mm.getControlsLayer().imageClicked(which);
 	}
 
-	public void penHeld(Point p){
-		ignoreNextDrag=true;
+	public void penHeld(Point p) {
+		ignoreNextDrag = true;
 		if (!mm.zoomingMode) {
 			kontextMenu = new Menu();
 			if (!onlyIfCache) {
@@ -2300,69 +2373,66 @@
 			}
 			final AniImage clickedOnImage = images.findHotImage(p);
 			if (clickedOnImage != null &amp;&amp; clickedOnImage instanceof MapSymbol) {
-				if ( ((MapSymbol)clickedOnImage).mapObject instanceof CacheHolder) {
-					clickedCache = (CacheHolder)( ((MapSymbol)clickedOnImage).mapObject);
+				if (((MapSymbol) clickedOnImage).mapObject instanceof CacheHolder) {
+					clickedCache = (CacheHolder) (((MapSymbol) clickedOnImage).mapObject);
 					// clickedCache == null can happen if clicked on the goto-symbol
 					if (clickedCache != null) {
-						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, &quot;Open Desctiption&quot;)+&quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$o&quot;);
+						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, &quot;Open Desctiption&quot;) + &quot; '&quot; + (clickedCache.getCacheName().length() &gt; 0 ? clickedCache.getCacheName() : clickedCache.getWayPoint()) + &quot;'$o&quot;);
 						kontextMenu.addItem(openCacheDescMenuItem);
-						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, &quot;Open Details&quot;)+&quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$e&quot;);
+						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, &quot;Open Details&quot;) + &quot; '&quot; + (clickedCache.getCacheName().length() &gt; 0 ? clickedCache.getCacheName() : clickedCache.getWayPoint()) + &quot;'$e&quot;);
 						kontextMenu.addItem(openCacheDetailMenuItem);
-						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, &quot;Goto&quot;)+ &quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$g&quot;);
+						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, &quot;Goto&quot;) + &quot; '&quot; + (clickedCache.getCacheName().length() &gt; 0 ? clickedCache.getCacheName() : clickedCache.getWayPoint()) + &quot;'$g&quot;);
 						kontextMenu.addItem(gotoCacheMenuItem);
 						if (Global.mainForm.cacheListVisible) {
-							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,&quot;Add to cachetour&quot;));
+							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199, &quot;Add to cachetour&quot;));
 							kontextMenu.addItem(addCachetoListMenuItem);
 						}
-						String stmp=clickedCache.getCacheDetails(false).Hints;
-						stmp=stmp.substring(0,Math.min(10,stmp.length())).trim();
-						if (!stmp.equals(&quot;&quot;)){
-							kontextMenu.addItem(hintMenuItem=new MenuItem(&quot;Hint: &quot;+stmp));
+						String stmp = clickedCache.getCacheDetails(false).Hints;
+						stmp = stmp.substring(0, Math.min(10, stmp.length())).trim();
+						if (!stmp.equals(&quot;&quot;)) {
+							kontextMenu.addItem(hintMenuItem = new MenuItem(&quot;Hint: &quot; + stmp));
 						}
 						if (clickedCache.getType() == CacheType.CW_TYPE_QUESTION) {
-							stmp=clickedCache.getCacheDetails(false).LongDescription;
+							stmp = clickedCache.getCacheDetails(false).LongDescription;
 							if (!stmp.equals(&quot;&quot;)) {
-								kontextMenu.addItem(missionMenuItem=new MenuItem(&quot;?: &quot;));
+								kontextMenu.addItem(missionMenuItem = new MenuItem(&quot;?: &quot;));
 							}
 						}
 						kontextMenu.addItem(new MenuItem(&quot;-&quot;));
-						kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint()+&quot; Info:&quot;));
-						kontextMenu.addItem(new MenuItem(&quot;Difficulty: &quot;+CacheTerrDiff.longDT(clickedCache.getHard())));
-						kontextMenu.addItem(new MenuItem(&quot;Terrain: &quot;+CacheTerrDiff.longDT(clickedCache.getTerrain())));
-						kontextMenu.addItem(new MenuItem(&quot;Size: &quot;+CacheSize.cw2ExportString(clickedCache.getCacheSize())));
+						kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint() + &quot; Info:&quot;));
+						kontextMenu.addItem(new MenuItem(&quot;Difficulty: &quot; + CacheTerrDiff.longDT(clickedCache.getHard())));
+						kontextMenu.addItem(new MenuItem(&quot;Terrain: &quot; + CacheTerrDiff.longDT(clickedCache.getTerrain())));
+						kontextMenu.addItem(new MenuItem(&quot;Size: &quot; + CacheSize.cw2ExportString(clickedCache.getCacheSize())));
 					}
 				}
 			}
 			/*
-			 *  this kontext will be replaced by the settings of the rose in the goto panel
-			 *
-			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
-			}
-			else {
-				for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
-					kontextMenu.addItem(miLuminary[i]);
-					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-					else miLuminary[i].modifiers &amp;= MenuItem.Checked;
-				}
-			}
-			*/
-			onlyIfCache=false;
-			if (kontextMenu.items.size()&gt;0) {
+			 * this kontext will be replaced by the settings of the rose in the goto panel
+			 * 
+			 * if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
+			 * }
+			 * else {
+			 * for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+			 * kontextMenu.addItem(miLuminary[i]);
+			 * if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+			 * else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+			 * }
+			 * }
+			 */
+			onlyIfCache = false;
+			if (kontextMenu.items.size() &gt; 0) {
 				kontextMenu.exec(this, new Point(p.x, p.y), this);
-			}
-			else kontextMenu=null;
+			} else
+				kontextMenu = null;
 		}
 	}
 
 	public boolean imageMovedOn(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
 				final CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
-				this.toolTip=ch.getWayPoint()+&quot;\n&quot;
-							+ ch.cacheName+&quot;\n&quot;
-							+ &quot;Difficulty: &quot;+CacheTerrDiff.longDT(ch.getHard())+&quot;\n&quot;
-							+ &quot;Terrain: &quot;+CacheTerrDiff.longDT(ch.getTerrain())+&quot;\n&quot;
-							+ &quot;Size: &quot;+CacheSize.cw2ExportString(ch.getCacheSize())+&quot;\n&quot;;
+				this.toolTip = ch.getWayPoint() + &quot;\n&quot; + ch.getCacheName() + &quot;\n&quot; + &quot;Difficulty: &quot; + CacheTerrDiff.longDT(ch.getHard()) + &quot;\n&quot; + &quot;Terrain: &quot; + CacheTerrDiff.longDT(ch.getTerrain()) + &quot;\n&quot; + &quot;Size: &quot;
+						+ CacheSize.cw2ExportString(ch.getCacheSize()) + &quot;\n&quot;;
 				if (ch.getType() == CacheType.CW_TYPE_QUESTION) {
 					this.toolTip = this.toolTip + ch.getCacheDetails(false).LongDescription;
 				}
@@ -2370,21 +2440,19 @@
 		}
 		return true;
 	}
+
 	public boolean imageMovedOff(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
-				this.toolTip=null;
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
+				this.toolTip = null;
 			}
 		}
 		return true;
 	}
 
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		// nothing selected in kontext
-		if (kontextMenu != null
-				&amp;&amp; ev instanceof PenEvent
-				&amp;&amp; ev.type == PenEvent.PEN_DOWN
-				&amp;&amp; ev.target == this) {
+		if (kontextMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {
 			kontextMenu.close();
 			kontextMenu = null;
 			return;
@@ -2392,7 +2460,7 @@
 		// something selected
 		if (ev instanceof MenuEvent) {
 			if (ev.target == kontextMenu) {
-				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+				if ((((MenuEvent) ev).type == MenuEvent.SELECTED)) {
 					final MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
 					if (action == gotoMenuItem) {
 						closeKontextMenu();
@@ -2402,9 +2470,9 @@
 						leaveMovingMap();
 						final MainTab mainT = Global.mainTab;
 						if (action == openCacheDescMenuItem)
-							mainT.openPanel(clickedCache,2);
+							mainT.openPanel(clickedCache, 2);
 						else
-							mainT.openPanel(clickedCache,1);
+							mainT.openPanel(clickedCache, 1);
 					}
 					if (action == gotoCacheMenuItem) {
 						closeKontextMenu();
@@ -2422,21 +2490,21 @@
 						Global.mainForm.cacheList.addCache(clickedCache.getWayPoint());
 					}
 					if (action == hintMenuItem) {
-						(new MessageBox(&quot;Hint&quot;, STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints),&quot;&lt;br&gt;&quot;,&quot;\n&quot;), FormBase.OKB)).execute();
+						(new MessageBox(&quot;Hint&quot;, STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints), &quot;&lt;br&gt;&quot;, &quot;\n&quot;), FormBase.OKB)).execute();
 					}
 					if (action == missionMenuItem) {
-						(new MessageBox(&quot;Mission&quot;, STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription,&quot;&lt;br&gt;&quot;,&quot;\n&quot;), FormBase.OKB)).execute();
+						(new MessageBox(&quot;Mission&quot;, STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription, &quot;&lt;br&gt;&quot;, &quot;\n&quot;), FormBase.OKB)).execute();
 					}
 					/*
-					for (int i=0; i&lt;miLuminary.length; i++) {
-						if (action == miLuminary[i]) {
-							kontextMenu.close();
-							mm.myNavigation.setLuminary(i);
-							mm.updateGps(mm.myNavigation.gpsPos.getFix());
-							miLuminary[i].modifiers |= MenuItem.Checked;
-						} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
-					}
-					*/
+					 * for (int i=0; i&lt;miLuminary.length; i++) {
+					 * if (action == miLuminary[i]) {
+					 * kontextMenu.close();
+					 * mm.myNavigation.setLuminary(i);
+					 * mm.updateGps(mm.myNavigation.gpsPos.getFix());
+					 * miLuminary[i].modifiers |= MenuItem.Checked;
+					 * } else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+					 * }
+					 */
 				}
 			} // if (ev.target == kontextMenu)
 		}
@@ -2447,12 +2515,13 @@
 		kontextMenu.close();
 		// for not to do an additional klick (before reacting on klicks)
 		final PenEvent pev = new PenEvent();
-		pev.target=this;
-		pev.type=PenEvent.PEN_DOWN;
+		pev.target = this;
+		pev.type = PenEvent.PEN_DOWN;
 		this.postEvent(pev);
-		pev.type=PenEvent.PEN_UP;
+		pev.type = PenEvent.PEN_UP;
 		this.postEvent(pev);
 	}
+
 	private void leaveMovingMap() {
 		closeKontextMenu();
 		final WindowEvent close = new WindowEvent();
@@ -2463,20 +2532,20 @@
 }
 
 /**
- *	Class to display maps to choose from
+ * Class to display maps to choose from
  */
-class ListBox extends Form{
+class ListBox extends Form {
 	public MapInfoObject selectedMap; // = new MapInfoObject();
 	mButton cancelButton, okButton;
-	mList list = new mList(4,1,false);
+	mList list = new mList(4, 1, false);
 	public boolean selected = false;
 	Vector maps;
 
-	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap) {
 		this.title = MyLocale.getMsg(4271, &quot;Maps&quot;);
 		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
 		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
-		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth() * 3 / 4, java.lang.Math.min(240, MyLocale.getScreenWidth())), MyLocale.getScreenHeight() * 3 / 4);
 		this.maps = maps;
 		MapInfoObject map;
 		MapListEntry ml;
@@ -2485,45 +2554,55 @@
 		boolean curMapFound = false;
 		final boolean[] inList = new boolean[maps.size()];
 		int row = -1;
-		if (curMap == null) curMapFound = true;
+		if (curMap == null)
+			curMapFound = true;
 		if (gotopos != null &amp;&amp; Gps != null) {
 			list.addItem(MyLocale.getMsg(4272, &quot;--- Maps containing GPS and goto pos. ---&quot;));
 			row++;
-			cmp = &quot;FF1&quot;+(new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
-			for(int i = 0; i&lt;maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = &quot;FF1&quot; + (new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
+			for (int i = 0; i &lt; maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (final IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound &amp;&amp; curMap != null &amp;&amp; map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
-				} else inList[i] = false;
+				} else
+					inList[i] = false;
 			}
 		}
 		if (Gps != null) {
 			list.addItem(MyLocale.getMsg(4273, &quot;--- Maps containing curr. position ---&quot;));
 			row++;
-			cmp = &quot;FF1&quot;+Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
-			for(int i = 0; i&lt;maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = &quot;FF1&quot; + Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
+			for (int i = 0; i &lt; maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (final IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound &amp;&amp; curMap != null &amp;&amp; map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2533,18 +2612,23 @@
 		if (gotopos != null) {
 			list.addItem(MyLocale.getMsg(4274, &quot;--- Karten des Ziels ---&quot;));
 			row++;
-			cmp = &quot;FF1&quot;+Area.getEasyFindString(gotopos, 30);
-			for(int i = 0; i&lt;maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = &quot;FF1&quot; + Area.getEasyFindString(gotopos, 30);
+			for (int i = 0; i &lt; maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (final IOException ex) {continue; } // could not read .wfl-file
-				if(map.isInBound(gotopos)) {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(gotopos)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound &amp;&amp; curMap != null &amp;&amp; map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2553,69 +2637,68 @@
 		}
 		list.addItem(MyLocale.getMsg(4275, &quot;--- andere Karten ---&quot;));
 		row++;
-		for(int i = 0; i&lt;maps.size();i++){
-			ml = (MapListEntry)maps.get(i);
-			if(!inList[i]) {
+		for (int i = 0; i &lt; maps.size(); i++) {
+			ml = (MapListEntry) maps.get(i);
+			if (!inList[i]) {
 				list.addItem(i + &quot;: &quot; + ml.filename);
 				row++;
-				if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; ml.filename.equals(curMap.mapName)) {
+				if (!curMapFound &amp;&amp; curMap != null &amp;&amp; ml.filename.equals(curMap.mapName)) {
 					oldmap = row;
 					curMapFound = true;
 				}
 			}
 		}
 		list.selectItem(oldmap, true);
-		this.addLast(new CacheWolf.MyScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new CacheWolf.MyScrollBarPanel(list), CellConstants.STRETCH, CellConstants.FILL);
 		cancelButton = new mButton(MyLocale.getMsg(4276, &quot;Cancel&quot;));
 		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(cancelButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton = new mButton(MyLocale.getMsg(4277, &quot;Select&quot;));
 		okButton.setHotKey(0, KeyEvent.getActionKey(true));
-		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(okButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton.takeFocus(0);
 	}
+
 	public void mapSelected() {
 		try {
 			selectedMap = null;
 			int mapNum = 0;
 			String it = new String();
 			it = list.getText();
-			if (it != &quot;&quot;){
-				it = it.substring(0,it.indexOf(':'));
+			if (it != &quot;&quot;) {
+				it = it.substring(0, it.indexOf(':'));
 				mapNum = Convert.toInt(it);
 				try {
-				selectedMap = ((MapListEntry)maps.get(mapNum)).getMap();
-				selected = true;
-				this.close(FormBase.IDOK);
+					selectedMap = ((MapListEntry) maps.get(mapNum)).getMap();
+					selected = true;
+					this.close(FormBase.IDOK);
 				} catch (final IOException e) {
-					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;)
-							+ ((MapListEntry)maps.get(mapNum)).filename, FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;) + ((MapListEntry) maps.get(mapNum)).filename, FormBase.OKB)).execute();
 				}
-			}
-			else {
+			} else {
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-		}catch (final NegativeArraySizeException e) {
+		} catch (final NegativeArraySizeException e) {
 			// happens in substring when a dividing line selected
 		}
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelButton){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelButton) {
 				selectedMap = null;
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+			if (ev.target == okButton || ev.target == list) { // ev.target == list is posted by mList if a selection was double clicked
 				mapSelected();
 			}
 		}
 		super.onEvent(ev);
 	}
 
-	public void  penDoubleClicked(Point where) {
+	public void penDoubleClicked(Point where) {
 		mapSelected();
 	}
 }
@@ -2627,13 +2710,13 @@
 
 	int minY;
 	Graphics draw;
-	private MapInfoObject map=null;
+	private MapInfoObject map = null;
 
-	Color moveDirColor = new Color(255,0,0); // RED
-	final static Color sunDirColor = new Color(255,255,0); // Yellow
-	//final static Color GREEN = new Color(0,255,0);
-	final static Color gotoDirColor = new Color(0,0,128); // dark blue
-	final static Color northDirColor = new Color(0,0,255); // Blue
+	Color moveDirColor = new Color(255, 0, 0); // RED
+	final static Color sunDirColor = new Color(255, 255, 0); // Yellow
+	// final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0, 0, 128); // dark blue
+	final static Color northDirColor = new Color(0, 0, 255); // Blue
 	Point[] sunDirArrow = null;
 	Point[] gotoDirArrow = null;
 	Point[] moveDirArrow = null;
@@ -2643,31 +2726,33 @@
 	int arrowThickness = imageSize / 28;
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public ArrowsOnMap(){
+	public ArrowsOnMap() {
 		super();
 		newImage();
-		//	setDirections(90, 180, -90);
+		// setDirections(90, 180, -90);
 	}
 
 	public void newImage() {
-		setImage(new Image(imageSize,imageSize), Color.White);
+		setImage(new Image(imageSize, imageSize), Color.White);
 		draw = new Graphics(image);
 	}
+
 	public void setMap(MapInfoObject m) {
 		map = m;
 		makeArrows();
 	}
 
-	public void setDirections(float gd, float sd, float md ) {
+	public void setDirections(float gd, float sd, float md) {
 		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
-				|| java.lang.Math.abs(sunDir - sd) &gt; 1
-				|| java.lang.Math.abs(moveDir - md) &gt; 1)
-		{
-			//dirsChanged = false;
+				|| java.lang.Math.abs(sunDir - sd) &gt; 1 || java.lang.Math.abs(moveDir - md) &gt; 1) {
+			// dirsChanged = false;
 			gotoDir = gd;
 			sunDir = sd;
 			moveDir = md;
@@ -2677,98 +2762,111 @@
 
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
-		if (map == null || g == null) return;
+	public void doDraw(Graphics g, int options) {
+		if (map == null || g == null)
+			return;
 		drawArrows(g);
 		return;
-/*		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
-			return;
-		}
-		dirsChanged = false;
-		//super.doDraw(g, options);
-		draw.setColor(Color.White);
-		draw.fillRect(0, 0, location.width, location.height);
-		minY = Integer.MAX_VALUE;
-		drawArrows(draw);
-		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
-		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-*/	}
+		/*
+		 * if (!dirsChanged) {
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
+		 * return;
+		 * }
+		 * dirsChanged = false;
+		 * //super.doDraw(g, options);
+		 * draw.setColor(Color.White);
+		 * draw.fillRect(0, 0, location.width, location.height);
+		 * minY = Integer.MAX_VALUE;
+		 * drawArrows(draw);
+		 * draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+		 */}
 
-	private void makeArrows(){
-			// draw only valid arrows
-			if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
-				if (moveDirArrow == null) moveDirArrow = new Point[2];
-				makeArrow(moveDirArrow, moveDir, 1.0f);
-			} else moveDirArrow = null;
-			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) {
-				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
-				makeArrow(gotoDirArrow, gotoDir, 1.0f);
-			} else gotoDirArrow = null;
-			if (sunDir &lt; 360 &amp;&amp; sunDir&gt; -360) {
-				if (sunDirArrow == null ) sunDirArrow = new Point[2];
-				makeArrow(sunDirArrow, sunDir, 0.75f);
-			} else sunDirArrow = null;
-			if (map != null &amp;&amp; java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
-				if (northDirArrow == null) northDirArrow = new Point[2];
-				makeArrow(northDirArrow, 0, 1.0f); // north direction
-			} else northDirArrow = null;
+	private void makeArrows() {
+		// draw only valid arrows
+		if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
+			if (moveDirArrow == null)
+				moveDirArrow = new Point[2];
+			makeArrow(moveDirArrow, moveDir, 1.0f);
+		} else
+			moveDirArrow = null;
+		if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) {
+			if (gotoDirArrow == null)
+				gotoDirArrow = new Point[2];
+			makeArrow(gotoDirArrow, gotoDir, 1.0f);
+		} else
+			gotoDirArrow = null;
+		if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) {
+			if (sunDirArrow == null)
+				sunDirArrow = new Point[2];
+			makeArrow(sunDirArrow, sunDir, 0.75f);
+		} else
+			sunDirArrow = null;
+		if (map != null &amp;&amp; java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI) { // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+			if (northDirArrow == null)
+				northDirArrow = new Point[2];
+			makeArrow(northDirArrow, 0, 1.0f); // north direction
+		} else
+			northDirArrow = null;
 
-			//select moveDirColor according to difference to gotoDir
-			moveDirColor = new Color(255,0,0); // red
+		// select moveDirColor according to difference to gotoDir
+		moveDirColor = new Color(255, 0, 0); // red
 
-			if (moveDirArrow != null &amp;&amp; gotoDirArrow != null)
-			{
-				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff &gt; 360)
-				{
-					diff -= 360.0f;
-				}
-				if (diff &gt; 180)
-				{
-					diff = 360.0f - diff;
-				}
+		if (moveDirArrow != null &amp;&amp; gotoDirArrow != null) {
+			float diff = java.lang.Math.abs(moveDir - gotoDir);
+			while (diff &gt; 360) {
+				diff -= 360.0f;
+			}
+			if (diff &gt; 180) {
+				diff = 360.0f - diff;
+			}
 
-				if (diff &lt;= 5.0)
-				{
-					moveDirColor = new Color(0,192,0);// darkgreen
-				}
-				else if (diff &lt;= 22.5)
-				{
-					moveDirColor = new Color(0,255,0);// green
-				}
-				else if (diff &lt;= 45.0)
-				{
-					moveDirColor = new Color(255,128,0);// orange
-				}
+			if (diff &lt;= 5.0) {
+				moveDirColor = new Color(0, 192, 0);// darkgreen
+			} else if (diff &lt;= 22.5) {
+				moveDirColor = new Color(0, 255, 0);// green
+			} else if (diff &lt;= 45.0) {
+				moveDirColor = new Color(255, 128, 0);// orange
 			}
 		}
+	}
 
 	/**
 	 * make (calculate) Pixel array for a single arrow
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
+	 * 
+	 * @param g
+	 *            handle for drawing
+	 * @param angle
+	 *            angle of arrow
+	 * @param col
+	 *            color of arrow
 	 */
 	private void makeArrow(Point[] arrow, float angle, float scale) {
-		if (map == null) return;
+		if (map == null)
+			return;
 
 		float angleRad;
-		final int centerX = location.width/2, centerY = location.height/2;
-		if (arrow[0] == null) arrow[0] = new Point();
-		if (arrow[1] == null) arrow[1] = new Point();
+		final int centerX = location.width / 2, centerY = location.height / 2;
+		if (arrow[0] == null)
+			arrow[0] = new Point();
+		if (arrow[1] == null)
+			arrow[1] = new Point();
 		arrow[0].x = centerX;
 		arrow[0].y = centerY;
-		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		angleRad = angle * (float) java.lang.Math.PI / 180 + map.rotationRad;
 		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
 		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
-		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
-		//	g.drawLine(centerX,centerY,x,y);
+		// g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		// g.drawLine(centerX,centerY,x,y);
 	}
 
 	public void drawArrows(Graphics g) {
@@ -2779,12 +2877,9 @@
 	}
 
 	public void drawArrow(Graphics g, Point[] arrow, Color col) {
-		if (arrow == null) return;
-		g.setPen(new Pen(col,Pen.SOLID,arrowThickness));
-		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+		if (arrow == null)
+			return;
+		g.setPen(new Pen(col, Pen.SOLID, arrowThickness));
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x, arrow[1].y);
 	}
 }
-
-
-
-

Modified: trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
===================================================================
--- trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
 import CacheWolf.Global;
@@ -87,25 +87,21 @@
 					offsetx = offsety;
 				}
 
-				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH,
-						0);
-				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW,
-						imageH, 0);
+				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH, 0);
+				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW, imageH, 0);
 
-				for (int line = 0; line &lt; imageH; line++) {
-					for (int pos = 0; pos &lt; imageW; pos++) {
+				for (int y = 0; y &lt; imageH; y++) {
+					for (int x = 0; x &lt; imageW; x++) {
 
-						if (line &gt;= offsety &amp;&amp; pos &gt;= offsetx
-								&amp;&amp; line &lt; offsety + iconH
-								&amp;&amp; pos &lt; offsetx + iconW) {
+						if (y &gt;= offsety &amp;&amp; x &gt;= offsetx &amp;&amp; y &lt; offsety + iconH &amp;&amp; x &lt; offsetx + iconW) {
 
-							int iconx = pos - offsetx;
-							int icony = line - offsety;
+							int iconx = x - offsetx;
+							int icony = y - offsety;
 
-							int index = line * imageW + pos;
+							int index = y * imageW + x;
 							int iconIndex = icony * iconW + iconx;
 							int alphaval = (iconPixels[iconIndex] &gt;&gt; 24) &amp; 0xff;
-							
+
 							if (alphaval &gt; 127) {
 								imagePixels[index] = iconPixels[iconIndex];
 							}
@@ -117,15 +113,14 @@
 				image.setPixels(imagePixels, 0, 0, 0, imageW, imageH, 0);
 
 			} else
-				Global.getPref().log(&quot;icon &quot; + iconSrc + &quot; is bigger than &quot; + source+ &quot;! Icon not loaded&quot;,null);
+				Global.getPref().log(&quot;icon &quot; + iconSrc + &quot; is bigger than &quot; + source + &quot;! Icon not loaded&quot;, null);
 
 		}
 
 		if (alpha &gt;= 0 &amp;&amp; alpha &lt; 256) {
 			alpha = alpha &lt;&lt; 24;
 
-			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(),
-					image.getHeight(), 0);
+			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			for (int i = 0; i &lt; imageBits.length; i++) {
 				if (imageBits[i] != 0) {
 					imageBits[i] &amp;= 0xffffff;
@@ -133,8 +128,7 @@
 				}
 
 			}
-			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image
-					.getHeight(), 0);
+			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			image.enableAlpha();
 		}
 
@@ -156,6 +150,7 @@
 	public String getContent() {
 		return null;
 	}
+
 	public String getText() {
 		return null;
 	}
@@ -209,7 +204,7 @@
 
 			Boolean thisElement = (Boolean) roles.get(nextKey);
 			if (!overallRoles.containsKey(nextKey)) {
-				Global.getPref().log(&quot;Lookup role &quot; + nextKey + &quot; not possible&quot;,null);
+				Global.getPref().log(&quot;Lookup role &quot; + nextKey + &quot; not possible&quot;, null);
 				return false;
 			}
 

Modified: trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
===================================================================
--- trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
-
 import ewe.fx.Image;
 import ewe.fx.mImage;
 import ewe.graphics.AniImage;
@@ -34,22 +33,20 @@
 
 	private int command;
 	private AniImageGrayScaled aniImage;
-	
-	public MovingMapControlItemButton(String source,String iconSrc, int actionCommand,
-			int alpha) {
+
+	public MovingMapControlItemButton(String source, String iconSrc, int actionCommand, int alpha) {
 		Image image = MovingMapControlItem.createImage(source, iconSrc, alpha);
 		aniImage = new AniImageGrayScaled(image);
 		aniImage.freeSource();
 		command = actionCommand;
-		aniImage.properties|= mImage.AlwaysOnTop;
-		xProperties|=IS_ICON_WITH_COMMAND;
+		aniImage.properties |= mImage.AlwaysOnTop;
+		xProperties |= IS_ICON_WITH_COMMAND;
 	}
 
 	public int getActionCommand() {
 		return command;
 	}
 
-	
 	public int getWidth() {
 		return aniImage.getWidth();
 	}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002997.html">[Cachewolf-svn] r3006 - trunk/res_noewe
</A></li>
	<LI>Next message: <A HREF="003000.html">[Cachewolf-svn] r3009 - trunk/src/CacheWolf/view/pda
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2999">[ date ]</a>
              <a href="thread.html#2999">[ thread ]</a>
              <a href="subject.html#2999">[ subject ]</a>
              <a href="author.html#2999">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
