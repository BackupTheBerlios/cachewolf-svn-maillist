<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3007 - in trunk/src/CacheWolf: . imp navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-May/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3007%20-%20in%20trunk/src/CacheWolf%3A%20.%20imp%20navi&In-Reply-To=%3C20110518140648.BF9A0481274%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002996.html">
   <LINK REL="Next"  HREF="002997.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3007 - in trunk/src/CacheWolf: . imp navi</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3007%20-%20in%20trunk/src/CacheWolf%3A%20.%20imp%20navi&In-Reply-To=%3C20110518140648.BF9A0481274%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3007 - in trunk/src/CacheWolf: . imp navi">araber95 at mail.berlios.de
       </A><BR>
    <I>Wed May 18 04:06:48 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002996.html">[Cachewolf-svn] r3005 - in trunk/src/CacheWolf: . imp view/ewe	view/pda
</A></li>
        <LI>Next message: <A HREF="002997.html">[Cachewolf-svn] r3006 - trunk/res_noewe
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2998">[ date ]</a>
              <a href="thread.html#2998">[ thread ]</a>
              <a href="subject.html#2998">[ subject ]</a>
              <a href="author.html#2998">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-05-18 16:06:48 +0200 (Wed, 18 May 2011)
New Revision: 3007

Modified:
   trunk/src/CacheWolf/Attributes.java
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/Extractor.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SafeXML.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/GPXImporter.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/navi/CWGPSPoint.java
Log:
1. extended error message on gpx import.
2. switch to english on login at gc and  back to original
3. corrected entity checking
4. corrected Url Text encoding
5. changed Extractor to easy work with quick import
6. make quick import work a bit more robust (gc changed output again) using Extractor

Modified: trunk/src/CacheWolf/Attributes.java
===================================================================
--- trunk/src/CacheWolf/Attributes.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/Attributes.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,133 +1,150 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 public class Attributes {
-	public Attributes(){} // Just a public constructor
-	public final static int MAXATTRIBS=12;
+	public Attributes() {
+	} // Just a public constructor
+
+	public final static int MAXATTRIBS = 12;
 	/**
 	 * The number of attributes for this cache (=number of array elements in use in attribs)
 	 */
-	private int _count=0;
+	private int _count = 0;
 	/**
 	 * The attributes as array of MAXATTRIBS Attribute
 	 */
-	private Attribute attribs[]=new Attribute[MAXATTRIBS];
+	private Attribute attribs[] = new Attribute[MAXATTRIBS];
 	/**
-	 * The attributes presence in Bit Representation 
+	 * The attributes presence in Bit Representation
 	 */
-	private long[] attrYes = {0l,0l};
-	private long[] attrNo = {0l,0l};	
+	private long[] attrYes = { 0l, 0l };
+	private long[] attrNo = { 0l, 0l };
+
 	/**
 	 * Get the number of attributes in the list
+	 * 
 	 * @return number of attributes
 	 */
-	public int count(){return _count;}	
+	public int count() {
+		return _count;
+	}
+
 	/**
-	 * getting an empty attributes list for this Cache 
+	 * getting an empty attributes list for this Cache
 	 */
 	public void clear() {
-		_count=0;
-		attrYes[0]=0l;
-		attrYes[1]=0l;
-		attrNo[0]=0l;
-		attrNo[1]=0l;
+		_count = 0;
+		attrYes[0] = 0l;
+		attrYes[1] = 0l;
+		attrNo[0] = 0l;
+		attrNo[1] = 0l;
 	}
+
 	/**
-	 *  Filling the Attributes from Cache.xml (CacheHolderDetail)
-	 *  todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
+	 * Filling the Attributes from Cache.xml (CacheHolderDetail)
+	 * todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public void XmlAttributesEnd(String elem){
+	public void XmlAttributesEnd(String elem) {
 		clear();
-		Extractor ex=new Extractor(elem,&quot;&lt;ATT&gt;&quot;,&quot;&lt;/ATT&gt;&quot;,0,true);
-		String dummy = ex.findNext();
-		while(ex.endOfSearch()==false){
+		Extractor ex = new Extractor(elem, &quot;&lt;ATT&gt;&quot;, &quot;&lt;/ATT&gt;&quot;, 0, true);
+		String dummy;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
 			add(dummy);
-			dummy = ex.findNext();
 		}
 	}
+
 	/**
-	 * Prepare for attributes to be written to cache.xml file 
-	 *  todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
+	 * Prepare for attributes to be written to cache.xml file
+	 * todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public String XmlAttributesWrite(){
-		StringBuffer sb=new StringBuffer(1000);
+	public String XmlAttributesWrite() {
+		StringBuffer sb = new StringBuffer(1000);
 		sb.append(&quot;&lt;ATTRIBUTES&gt;\n&quot;);
-		for (int i=0; i&lt;_count; i++) {
+		for (int i = 0; i &lt; _count; i++) {
 			sb.append(&quot;   &lt;ATT&gt;&quot;);
 			sb.append(attribs[i].getImageName());
 			sb.append(&quot;&lt;/ATT&gt;\n&quot;);
 		}
 		sb.append(&quot;&lt;/ATTRIBUTES&gt;\n&quot;);
 		return sb.toString();
-	}	
+	}
+
 	/**
 	 * Add a new attribute to the array by Name, meaning its icon picture name
+	 * 
 	 * @param attributeName
 	 */
-	public void add(String attributeName){
-		if (_count&lt;attribs.length) {
-			if ( !attributeName.equalsIgnoreCase( &quot;attribute-blank.gif&quot; ) ) {
+	public void add(String attributeName) {
+		if (_count &lt; attribs.length) {
+			if (!attributeName.equalsIgnoreCase(&quot;attribute-blank.gif&quot;)) {
 				Attribute attr = new Attribute(attributeName);
 				attribs[_count++] = attr;
-				attrYes=attr.getYesBit(attrYes);
-				attrNo=attr.getNoBit(attrNo);
+				attrYes = attr.getYesBit(attrYes);
+				attrNo = attr.getNoBit(attrNo);
 			}
 		}
 	}
+
 	/**
 	 * Add a new attribute to the array by ID and Inc as you get it from GC gpx-File
-	 * @param GC attribute ID
-	 * @param GC attribute Inc (attribute set = 0 ,attribute  not set = 1)
+	 * 
+	 * @param GC
+	 *            attribute ID
+	 * @param GC
+	 *            attribute Inc (attribute set = 0 ,attribute not set = 1)
 	 */
 	public void add(int attIdGC, String Yes1No0) {
-		if (_count&lt;attribs.length) {
+		if (_count &lt; attribs.length) {
 			Attribute attr = new Attribute(attIdGC, Yes1No0);
 			boolean doAdd = true;
-			int replace=0;
+			int replace = 0;
 			for (int i = 0; i &lt; _count; i++) {
-				if (attribs[i].getGCId().equals(attr.getGCId())){
-					doAdd=false;
-					replace=i;
+				if (attribs[i].getGCId().equals(attr.getGCId())) {
+					doAdd = false;
+					replace = i;
 					break;
 				}
 			}
 			if (doAdd) {
 				attribs[_count++] = attr;
-			}
-			else {
+			} else {
 				// free old attr ?
-				attribs[replace]=attr;
+				attribs[replace] = attr;
 			}
-			attrYes=attr.getYesBit(attrYes);
-			attrNo=attr.getNoBit(attrNo);			
+			attrYes = attr.getYesBit(attrYes);
+			attrNo = attr.getNoBit(attrNo);
 		}
 	}
+
 	/**
-	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download 
-	 * @param OC attribute ID
+	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download
+	 * 
+	 * @param OC
+	 *            attribute ID
 	 */
 	public void add(int attIdOC) {
 		Attribute attr = new Attribute(attIdOC);
@@ -136,30 +153,34 @@
 				return;
 			}
 		}
-		if (_count&lt;attribs.length) {
+		if (_count &lt; attribs.length) {
 			attribs[_count++] = attr;
-			attrYes=attr.getYesBit(attrYes);
+			attrYes = attr.getYesBit(attrYes);
 		}
 	}
+
 	/**
 	 * to get the Bit Representation of the Attributs of this Cache
+	 * 
 	 * @return the Long array representing the Attributes of this Cache
 	 */
 	public long[] getAttribsAsBits() {
 		long ret[] = new long[4];
-		ret[0]=attrYes[0];
-		ret[1]=attrYes[1];
-		ret[2]=attrNo[0];
-		ret[3]=attrNo[1];
+		ret[0] = attrYes[0];
+		ret[1] = attrYes[1];
+		ret[2] = attrNo[0];
+		ret[3] = attrNo[1];
 		return ret;
 	}
+
 	/**
 	 * Get the i-th attribute
-	 * @param i The number for which the attribute is to be retrieved
+	 * 
+	 * @param i
+	 *            The number for which the attribute is to be retrieved
 	 * @return The attribute
 	 */
 	public Attribute getAttribute(int i) {
 		return attribs[i];
 	}
 }
-

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -40,532 +40,555 @@
 import ewe.util.Vector;
 
 public class CacheHolderDetail {
-	  
-	  
-	 /** CacheHolder which holds the detail. &lt;b&gt;Only&lt;/b&gt; set by CacheHolder when creating detail! **/
-	  private CacheHolder parent = null;
-	  public String LongDescription = CacheHolder.EMPTY;
-	  public String LastUpdate = CacheHolder.EMPTY;
-	  public String Hints = CacheHolder.EMPTY;
-	  public LogList CacheLogs=new LogList();
-	  private String CacheNotes = CacheHolder.EMPTY;
-	  public CacheImages images = new CacheImages();
-	  public CacheImages logImages = new CacheImages();
-	  public CacheImages userImages = new CacheImages();
-	  public Attributes attributes=new Attributes();
-	  public Vector CacheIcons = new Vector();
-	  public TravelbugList Travelbugs=new TravelbugList();
-	  //public String Bugs = EMPTY; Superceded by Travelbugs
-	  public String URL = CacheHolder.EMPTY;
-	  private String Solver = CacheHolder.EMPTY;
-	  public String OwnLogId = CacheHolder.EMPTY;
-	  public Log OwnLog = null;
-	  public String Country = CacheHolder.EMPTY;
-	  public String State = CacheHolder.EMPTY;
-	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
-	   * If you want to save the changes automatically when the details are unloaded, set this to true */ 
-	  public boolean hasUnsavedChanges = false;
-	  
-	 public CacheHolderDetail(CacheHolder ch) {
-		 parent = ch;
-	 }
 
-	 public CacheHolder getParent() {
-		 return parent;
-	 }
-	 public void setLongDescription(String longDescription) {
-	 	if (LongDescription.equals(&quot;&quot;)) getParent().setNew(true);
-	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) getParent().setUpdated(true);
-	 	LongDescription = longDescription;
-	 }
-	 
-	 private String stripControlChars(String desc) {
-		 StringBuffer sb=new StringBuffer(desc.length());
-		 for (int i=0; i&lt;desc.length(); i++) {
-			char c=desc.charAt(i);
-			if (c&gt;' ') sb.append(c);
-		 }
-		 return sb.toString();
-	 }
-	 
-	 public void setHints(String hints) {
-	 	if (!Hints.equals(hints)) getParent().setUpdated(true);
-	 	Hints = hints;
-	 }
-	 
-	 public void setSolver(String solver) {
-		 if (!Solver.equals(solver)) getParent().setUpdated(true);
-		 getParent().setHasSolver(!solver.trim().equals(&quot;&quot;));
-		 Solver = solver;
-	 }
-	 
-	 public String getSolver() {
-		 return this.Solver;
-	 }
+	/** CacheHolder which holds the detail. &lt;b&gt;Only&lt;/b&gt; set by CacheHolder when creating detail! **/
+	private CacheHolder parent = null;
+	public String LongDescription = CacheHolder.EMPTY;
+	public String LastUpdate = CacheHolder.EMPTY;
+	public String Hints = CacheHolder.EMPTY;
+	public LogList CacheLogs = new LogList();
+	private String CacheNotes = CacheHolder.EMPTY;
+	public CacheImages images = new CacheImages();
+	public CacheImages logImages = new CacheImages();
+	public CacheImages userImages = new CacheImages();
+	public Attributes attributes = new Attributes();
+	public Vector CacheIcons = new Vector();
+	public TravelbugList Travelbugs = new TravelbugList();
+	// public String Bugs = EMPTY; Superceded by Travelbugs
+	public String URL = CacheHolder.EMPTY;
+	private String Solver = CacheHolder.EMPTY;
+	public String OwnLogId = CacheHolder.EMPTY;
+	public Log OwnLog = null;
+	public String Country = CacheHolder.EMPTY;
+	public String State = CacheHolder.EMPTY;
+	/**
+	 * For faster cache import (from opencaching) changes are only written when the details are freed from memory
+	 * If you want to save the changes automatically when the details are unloaded, set this to true
+	 */
+	public boolean hasUnsavedChanges = false;
 
-	 public void setCacheNotes(String notes) {
-		 if (!CacheNotes.equals(notes)) getParent().setUpdated(true);
-		 getParent().setHasNote(!notes.trim().equals(&quot;&quot;));
-		 CacheNotes = notes;
-	 }
-	 
-	 public String getCacheNotes() {
-		 return this.CacheNotes;
-	 }
-	 
-	 public void setCacheLogs(LogList newLogs) {
-		 int size=newLogs.size();
-		 for (int i=size-1; i&gt;=0; i--) { // Loop over all new logs, must start with oldest log
-			 if (CacheLogs.merge(newLogs.getLog(i))&gt;=0) getParent().setLog_updated(true);
-		 }
-		 if (CacheLogs.purgeLogs() &gt; 0) hasUnsavedChanges=true;
-		 getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
-	 }
+	public CacheHolderDetail(CacheHolder ch) {
+		parent = ch;
+	}
 
-	 
-	  /**
+	public CacheHolder getParent() {
+		return parent;
+	}
+
+	public void setLongDescription(String longDescription) {
+		if (LongDescription.equals(&quot;&quot;))
+			getParent().setNew(true);
+		else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription)))
+			getParent().setUpdated(true);
+		LongDescription = longDescription;
+	}
+
+	private String stripControlChars(String desc) {
+		StringBuffer sb = new StringBuffer(desc.length());
+		for (int i = 0; i &lt; desc.length(); i++) {
+			char c = desc.charAt(i);
+			if (c &gt; ' ')
+				sb.append(c);
+		}
+		return sb.toString();
+	}
+
+	public void setHints(String hints) {
+		if (!Hints.equals(hints))
+			getParent().setUpdated(true);
+		Hints = hints;
+	}
+
+	public void setSolver(String solver) {
+		if (!Solver.equals(solver))
+			getParent().setUpdated(true);
+		getParent().setHasSolver(!solver.trim().equals(&quot;&quot;));
+		Solver = solver;
+	}
+
+	public String getSolver() {
+		return this.Solver;
+	}
+
+	public void setCacheNotes(String notes) {
+		if (!CacheNotes.equals(notes))
+			getParent().setUpdated(true);
+		getParent().setHasNote(!notes.trim().equals(&quot;&quot;));
+		CacheNotes = notes;
+	}
+
+	public String getCacheNotes() {
+		return this.CacheNotes;
+	}
+
+	public void setCacheLogs(LogList newLogs) {
+		int size = newLogs.size();
+		for (int i = size - 1; i &gt;= 0; i--) { // Loop over all new logs, must start with oldest log
+			if (CacheLogs.merge(newLogs.getLog(i)) &gt;= 0)
+				getParent().setLog_updated(true);
+		}
+		if (CacheLogs.purgeLogs() &gt; 0)
+			hasUnsavedChanges = true;
+		getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
+	}
+
+	/**
 	 * Method to update an existing cache with new data. This is
 	 * necessary to avoid missing old logs. Called from GPX Importer
-	 * @param newCh new cache data
+	 * 
+	 * @param newCh
+	 *            new cache data
 	 * @return CacheHolder with updated data
 	 */
-	 public CacheHolderDetail update(CacheHolderDetail newCh) {
-			// flags
-			CacheHolder ch = getParent();
-			if (ch.is_found() &amp;&amp; ch.getCacheStatus().equals(&quot;&quot;)) {
-				ch.setCacheStatus(ch.getFoundText());
+	public CacheHolderDetail update(CacheHolderDetail newCh) {
+		// flags
+		CacheHolder ch = getParent();
+		if (ch.is_found() &amp;&amp; ch.getCacheStatus().equals(&quot;&quot;)) {
+			ch.setCacheStatus(ch.getFoundText());
+		}
+		// travelbugs:GPX-File contains all actual travelbugs but not the missions
+		// we need to check whether the travelbug is already in the existing list
+		getParent().setHas_bugs(newCh.Travelbugs.size() &gt; 0);
+		for (int i = newCh.Travelbugs.size() - 1; i &gt;= 0; i--) {
+			Travelbug tb = newCh.Travelbugs.getTB(i);
+			Travelbug oldTB = this.Travelbugs.find(tb.getName());
+			// If the bug is already in the cache, we keep it
+			if (oldTB != null) {
+				if (tb.getMission().length() &gt; 0)
+					oldTB.setMission(tb.getMission());
+				if (tb.getGuid().length() &gt; 0)
+					oldTB.setGuid(tb.getGuid());
+				newCh.Travelbugs.replace(i, oldTB);
 			}
-			//travelbugs:GPX-File contains all actual travelbugs but not the missions
-			// we need to check whether the travelbug is already in the existing list
-			getParent().setHas_bugs(newCh.Travelbugs.size()&gt;0);
-			for (int i=newCh.Travelbugs.size()-1; i&gt;=0; i--) {
-				Travelbug tb=newCh.Travelbugs.getTB(i);
-				Travelbug oldTB=this.Travelbugs.find(tb.getName());
-				// If the bug is already in the cache, we keep it
-				if (oldTB != null) {
-					if (tb.getMission().length() &gt; 0)
-						oldTB.setMission(tb.getMission());
-					if (tb.getGuid().length() &gt; 0)
-						oldTB.setGuid(tb.getGuid());
-					newCh.Travelbugs.replace(i,oldTB);
-				}
+		}
+		this.Travelbugs = newCh.Travelbugs;
+		if (newCh.attributes.count() &gt; 0)
+			this.attributes = newCh.attributes;
+		// URL
+		this.URL = newCh.URL;
+		// Images
+		this.images = newCh.images;
+		setLongDescription(newCh.LongDescription);
+		setHints(newCh.Hints);
+		setCacheLogs(newCh.CacheLogs);
+		if (newCh.OwnLogId.length() &gt; 0)
+			this.OwnLogId = newCh.OwnLogId;
+		if (newCh.OwnLog != null)
+			this.OwnLog = newCh.OwnLog;
+		if (newCh.Country.length() &gt; 0)
+			this.Country = newCh.Country;
+		if (newCh.State.length() &gt; 0)
+			this.State = newCh.State;
+		if (newCh.getSolver().length() &gt; 0)
+			this.setSolver(newCh.getSolver());
+		return this;
+	}
+
+	/**
+	 * Adds a user image to the cache data
+	 * 
+	 * @param profile
+	 */
+	public void addUserImage(Profile profile) {
+		File imgFile;
+		String imgDesc, imgDestName;
+
+		// Get Image and description
+		FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
+		fc.setTitle(&quot;Select image file:&quot;);
+		if (fc.execute() != FormBase.IDCANCEL) {
+			imgFile = fc.getChosenFile();
+			imgDesc = new InputBox(&quot;Description&quot;).input(&quot;&quot;, 10);
+			// Create Destination Filename
+			String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
+			imgDestName = getParent().getWayPoint() + &quot;_U_&quot; + (this.userImages.size() + 1) + ext;
+
+			ImageInfo userImageInfo = new ImageInfo();
+			userImageInfo.setFilename(imgDestName);
+			userImageInfo.setTitle(imgDesc);
+			this.userImages.add(userImageInfo);
+			// Copy File
+			DataMover.copy(imgFile.getFullPath(), profile.dataDir + imgDestName);
+			// Save Data
+			saveCacheDetails(profile.dataDir);
+		}
+	}
+
+	/**
+	 * Method to parse a specific cache.xml file.
+	 * It fills information on cache details, hints, logs, notes and
+	 * images.
+	 */
+	void readCache(String dir) throws IOException {
+		String dummy;
+		FileReader in = null;
+		ImageInfo imageInfo;
+		// If parent cache has empty waypoint then don't do anything. This might happen
+		// when a cache object is freshly created to serve as container for imported data
+		if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY))
+			return;
+		FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
+		if (cacheFile.exists()) {
+			try {
+				in = new FileReader(cacheFile.getAbsolutePath());
+			} catch (FileNotFoundException e) {
+				in = null; // exception is thrown again below, if file could not be found in upper case, too
 			}
-			this.Travelbugs = newCh.Travelbugs;
-			if (newCh.attributes.count() &gt; 0) this.attributes = newCh.attributes;
-			// URL
-			this.URL = newCh.URL;
-			// Images
-			this.images = newCh.images;
-			setLongDescription(newCh.LongDescription);
-			setHints(newCh.Hints);
-			setCacheLogs(newCh.CacheLogs);
-			if (newCh.OwnLogId.length()&gt;0) this.OwnLogId=newCh.OwnLogId;
-			if (newCh.OwnLog != null) this.OwnLog = newCh.OwnLog;
-			if (newCh.Country.length()&gt;0) this.Country=newCh.Country;
-			if (newCh.State.length()&gt;0) this.State=newCh.State;
-			if (newCh.getSolver().length()&gt;0) this.setSolver(newCh.getSolver());
-			return this;		
-	 }
-	  
-	  /**
-	   * Adds a user image to the cache data
-	   * @param profile
-	   */
-		public void addUserImage(Profile profile){
-		  File imgFile;
-		  String imgDesc, imgDestName;
-		  
-		  //Get Image and description
-			FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
-			fc.setTitle(&quot;Select image file:&quot;);
-			if(fc.execute() != FormBase.IDCANCEL){
-				imgFile = fc.getChosenFile();
-				imgDesc = new InputBox(&quot;Description&quot;).input(&quot;&quot;,10);
-				//Create Destination Filename
-				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
-				imgDestName = getParent().getWayPoint() + &quot;_U_&quot; + (this.userImages.size()+1) + ext;
-				
-				ImageInfo userImageInfo = new ImageInfo();
-				userImageInfo.setFilename(imgDestName);
-				userImageInfo.setTitle(imgDesc);
-				this.userImages.add(userImageInfo);
-				// Copy File
-				DataMover.copy(imgFile.getFullPath(),profile.dataDir + imgDestName);
-				// Save Data
-				saveCacheDetails(profile.dataDir);
+		}
+		if (in == null) {
+			cacheFile = new FileBugfix(dir + getParent().getWayPoint() + &quot;.xml&quot;);
+			if (cacheFile.exists()) {
+				in = new FileReader(cacheFile.getAbsolutePath());
 			}
-	  }
+		}
 
-	  
-		/**
-		*	Method to parse a specific cache.xml file.
-		*	It fills information on cache details, hints, logs, notes and
-		*	images.
-		*/
-		void readCache(String dir) throws IOException{
-			String dummy;
-			FileReader in = null;
-			ImageInfo imageInfo;
-			// If parent cache has empty waypoint then don't do anything. This might happen
-			// when a cache object is freshly created to serve as container for imported data
-			if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY)) return;
-			FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);			
-			if (cacheFile.exists()) {
-				try {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				} catch (FileNotFoundException e) {
-					in = null; //exception is thrown again below, if file could not be found in upper case, too
-				}
+		if (in == null)
+			throw new FileNotFoundException(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
+		Global.getPref().log(&quot;Reading file &quot; + getParent().getWayPoint() + &quot;.xml&quot;);
+		String text = in.readAll();
+		in.close();
+
+		Extractor ex = new Extractor(text, &quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/DETAILS&gt;&quot;, 0, true);
+		LongDescription = ex.findNext();
+
+		ex.set(text, &quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/COUNTRY&gt;&quot;, 0, true);
+		Country = ex.findNext();
+
+		ex.set(text, &quot;&lt;STATE&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/STATE&gt;&quot;, 0, true);
+		State = ex.findNext();
+
+		// Attributes
+		ex.set(text, &quot;&lt;ATTRIBUTES&gt;&quot;, &quot;&lt;/ATTRIBUTES&gt;&quot;, 0, true);
+		attributes.XmlAttributesEnd(ex.findNext());
+
+		ex.set(text, &quot;&lt;HINTS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/HINTS&gt;&quot;, 0, true);
+		Hints = ex.findNext();
+
+		ex.set(text, &quot;&lt;LOGS&gt;&quot;, &quot;&lt;/LOGS&gt;&quot;, 0, true);
+		dummy = ex.findNext();
+
+		ex.set(dummy, &quot;&lt;OWNLOGID&gt;&quot;, &quot;&lt;/OWNLOGID&gt;&quot;, 0, true);
+		OwnLogId = ex.findNext();
+
+		ex.set(dummy, &quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/OWNLOG&gt;&quot;, 0, true);
+		String ownLogText = ex.findNext();
+		if (ownLogText.length() &gt; 0) {
+			if (ownLogText.indexOf(&quot;&lt;img src='&quot;) &gt;= 0) {
+				OwnLog = new Log(ownLogText + &quot;]]&gt;&quot;);
+			} else {
+				OwnLog = new Log(&quot;icon_smile.gif&quot;, &quot;1900-01-01&quot;, Global.getPref().myAlias, ownLogText);
 			}
-			if (in == null) {
-				cacheFile = new FileBugfix(dir + getParent().getWayPoint() + &quot;.xml&quot;);			
-				if (cacheFile.exists()) {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				}
-			}
+		} else {
+			OwnLog = null;
+		}
 
-			if (in == null) throw new FileNotFoundException(dir+getParent().getWayPoint().toLowerCase()+&quot;.xml&quot;);
-			Global.getPref().log(&quot;Reading file &quot;+getParent().getWayPoint() + &quot;.xml&quot;);
-			String text= in.readAll();
-			in.close();
-			Extractor ex = new Extractor(text, &quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/DETAILS&gt;&quot;, 0, true);		
-			LongDescription = ex.findNext();
-			ex = new Extractor(text, &quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/COUNTRY&gt;&quot;, 0, true);
-			Country = ex.findNext();
-			ex = new Extractor(text, &quot;&lt;STATE&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/STATE&gt;&quot;, 0, true);
-			State = ex.findNext();
-			// Attributes
-			ex = new Extractor(text,&quot;&lt;ATTRIBUTES&gt;&quot;,&quot;&lt;/ATTRIBUTES&gt;&quot;,0,true);
-			attributes.XmlAttributesEnd(ex.findNext());
-			
-			ex = new Extractor(text, &quot;&lt;HINTS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/HINTS&gt;&quot;, 0, true);
-			Hints = ex.findNext();
-			ex = new Extractor(text, &quot;&lt;LOGS&gt;&quot;,&quot;&lt;/LOGS&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			ex = new Extractor(dummy, &quot;&lt;OWNLOGID&gt;&quot;,&quot;&lt;/OWNLOGID&gt;&quot;, 0, true);
-			OwnLogId = ex.findNext();
-			ex = new Extractor(dummy, &quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/OWNLOG&gt;&quot;, 0, true);
-			String ownLogText = ex.findNext();
-			if ( ownLogText.length() &gt; 0 ) {
-				if (ownLogText.indexOf(&quot;&lt;img src='&quot;) &gt;= 0) {
-					OwnLog = new Log( ownLogText + &quot;]]&gt;&quot; );
-				} else {
-					OwnLog = new Log( &quot;icon_smile.gif&quot;, &quot;1900-01-01&quot;, Global.getPref().myAlias, ownLogText );
-				}
+		CacheLogs.clear();
+		ex.set(dummy, &quot;&lt;LOG&gt;&quot;, &quot;&lt;/LOG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			CacheLogs.add(new Log(dummy));
+		}
+
+		ex.set(text, &quot;&lt;NOTES&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/NOTES&gt;&quot;, 0, true);
+		CacheNotes = ex.findNext();
+		images.clear();
+
+		ex.set(text, &quot;&lt;IMG&gt;&quot;, &quot;&lt;/IMG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = new ImageInfo();
+			int pos = dummy.indexOf(&quot;&lt;URL&gt;&quot;);
+			if (pos &gt; 0) {
+				imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0, pos)));
+				imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos + 5, dummy.indexOf(&quot;&lt;/URL&gt;&quot;)))));
 			} else {
-				OwnLog = null;
+				imageInfo.setFilename(SafeXML.cleanback(dummy));
 			}
-			CacheLogs.clear();
-			ex = new Extractor(dummy, &quot;&lt;LOG&gt;&quot;,&quot;&lt;/LOG&gt;&quot;, 0, true);
-			
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				CacheLogs.add(new Log(dummy));
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, &quot;&lt;NOTES&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/NOTES&gt;&quot;, 0, true);
-			CacheNotes = ex.findNext();
-			images.clear();
-			ex = new Extractor(text, &quot;&lt;IMG&gt;&quot;, &quot;&lt;/IMG&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				int pos=dummy.indexOf(&quot;&lt;URL&gt;&quot;);
-				if (pos&gt;0) {
-					imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0,pos)));
-					imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos+5,dummy.indexOf(&quot;&lt;/URL&gt;&quot;)))));
-				} else {
-					imageInfo.setFilename(SafeXML.cleanback(dummy));
-				}
-				this.images.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, &quot;&lt;IMGTEXT&gt;&quot;, &quot;&lt;/IMGTEXT&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			int imgNr = 0;
-			while(!ex.endOfSearch()){
-				if (imgNr &gt;= this.images.size()) {
-					images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the &lt;cache&gt;.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
-					Global.getPref().log(&quot;Error reading &quot; + this.getParent().getWayPoint() + &quot;More IMGTEXT tags than IMG tags&quot;);
-				}
-				imageInfo = this.images.get(imgNr);
-				int pos=dummy.indexOf(&quot;&lt;DESC&gt;&quot;);
-				if (pos&gt;0) {
-					imageInfo.setTitle(dummy.substring(0,pos));
-					imageInfo.setComment(dummy.substring(pos+6,dummy.indexOf(&quot;&lt;/DESC&gt;&quot;)));
-				} else {
-					imageInfo.setTitle(dummy);
-				}
-				dummy = ex.findNext();
-				imgNr = imgNr + 1;
-			}
-			// Logimages
-			logImages.clear();
-			ex = new Extractor(text, &quot;&lt;LOGIMG&gt;&quot;, &quot;&lt;/LOGIMG&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				logImages.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, &quot;&lt;LOGIMGTEXT&gt;&quot;, &quot;&lt;/LOGIMGTEXT&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = logImages.get(imgNr++);
-				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
-			}
+			this.images.add(imageInfo);
+		}
 
-			userImages.clear();
-			ex = new Extractor(text, &quot;&lt;USERIMG&gt;&quot;, &quot;&lt;/USERIMG&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				userImages.add(imageInfo);
-				dummy = ex.findNext();
+		ex.set(text, &quot;&lt;IMGTEXT&gt;&quot;, &quot;&lt;/IMGTEXT&gt;&quot;, 0, true);
+		int imgNr = 0;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			if (imgNr &gt;= this.images.size()) {
+				images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the &lt;cache&gt;.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
+				Global.getPref().log(&quot;Error reading &quot; + this.getParent().getWayPoint() + &quot;More IMGTEXT tags than IMG tags&quot;);
 			}
-			ex = new Extractor(text, &quot;&lt;USERIMGTEXT&gt;&quot;, &quot;&lt;/USERIMGTEXT&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = userImages.get(imgNr++);
+			imageInfo = this.images.get(imgNr);
+			int pos = dummy.indexOf(&quot;&lt;DESC&gt;&quot;);
+			if (pos &gt; 0) {
+				imageInfo.setTitle(dummy.substring(0, pos));
+				imageInfo.setComment(dummy.substring(pos + 6, dummy.indexOf(&quot;&lt;/DESC&gt;&quot;)));
+			} else {
 				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
 			}
+			imgNr = imgNr + 1;
+		}
 
-			ex = new Extractor(text, &quot;&lt;TRAVELBUGS&gt;&quot;, &quot;&lt;/TRAVELBUGS&gt;&quot;, 0, false);
-			dummy=ex.findNext();
-			if (ex.endOfSearch()) {
-				ex = new Extractor(text, &quot;&lt;BUGS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/BUGS&gt;&quot;, 0, true);
-				String Bugs = ex.findNext();
-				Travelbugs.addFromHTML(Bugs);
-			} else
-				Travelbugs.addFromXML(dummy);
-			
-			ex = new Extractor(text, &quot;&lt;URL&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/URL&gt;&quot;, 0, true);
-			// if no URL is stored, set default URL (at this time only possible for gc.com)
-			dummy = ex.findNext();
-			if (dummy.length() &gt; 10){
-				URL = dummy;
-				int logpos = URL.indexOf(&quot;&amp;&quot;); //&amp;Submit &amp;log=y
-				if (logpos &gt; 0) URL=URL.substring(0,logpos);
-			}
-			else {
-				if (getParent().getWayPoint().startsWith(&quot;GC&quot;)) {
-					URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+ getParent().getWayPoint();
-				}
-			}
-			ex = new Extractor(text, &quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/SOLVER&gt;&quot;, 0, true);
-			this.setSolver(ex.findNext());
+		logImages.clear();
+		ex.set(text, &quot;&lt;LOGIMG&gt;&quot;, &quot;&lt;/LOGIMG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			logImages.add(imageInfo);
 		}
-		public void deleteFile(String FileName) {	
-			//File exists?
-			boolean exists = (new File(FileName)).exists();
-			//yes: then delete
-			if (exists) {
-				boolean ok = (new File(FileName)).delete();
-				if(ok) ok = true;
-			}
-			boolean exists2 = (new File(FileName.toLowerCase())).exists();
-			//yes: delete
-			if (exists2) {
-				boolean ok2 = (new File(FileName.toLowerCase())).delete();
-				if(ok2) ok2=true;
-			}
+
+		ex.set(text, &quot;&lt;LOGIMGTEXT&gt;&quot;, &quot;&lt;/LOGIMGTEXT&gt;&quot;, 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = logImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
 		}
-		/**
-		*	Method to save a cache.xml file.
-		*/
-		public void saveCacheDetails(String dir){
-			PrintWriter detfile;
-			deleteFile(dir + getParent().getWayPoint() + &quot;.xml&quot;);
-			try{
-			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;).getAbsolutePath())));
-			} catch (Exception e) {
-				Global.getPref().log(&quot;Problem creating details file&quot;,e,true);
-				return;
-			}
-			try{
-				if(getParent().getWayPoint().length()&gt;0){
-				  detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;CACHEDETAILS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;VERSION value = \&quot;3\&quot;/&gt;\n&quot;);
-				  detfile.print(&quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;+LongDescription+&quot;]]&gt;&lt;/DETAILS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot;+Country+&quot;]]&gt;&lt;/COUNTRY&gt;\n&quot;);
-				  detfile.print(&quot;&lt;STATE&gt;&lt;![CDATA[&quot;+State+&quot;]]&gt;&lt;/STATE&gt;\n&quot;);
-				  detfile.print(attributes.XmlAttributesWrite());
-				  detfile.print(&quot;&lt;HINTS&gt;&lt;![CDATA[&quot;+Hints+&quot;]]&gt;&lt;/HINTS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;LOGS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;OWNLOGID&gt;&quot;+OwnLogId+&quot;&lt;/OWNLOGID&gt;\r\n&quot;);
-				  if ( OwnLog != null ) {
-					  detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot;+OwnLog.toHtml()+&quot;]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
-				  } else {
-					  detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
-				  }
-				  for(int i = 0; i &lt; CacheLogs.size(); i++){
-					  detfile.print(CacheLogs.getLog(i).toXML());
-				  }
-				  detfile.print(&quot;&lt;/LOGS&gt;\r\n&quot;);
-			
-				  detfile.print(&quot;&lt;NOTES&gt;&lt;![CDATA[&quot;+CacheNotes+&quot;]]&gt;&lt;/NOTES&gt;\n&quot;);
-				  detfile.print(&quot;&lt;IMAGES&gt;\n&quot;);
-				  String stbuf;
-				  for(int i = 0;i&lt;images.size();i++){
-						stbuf = images.get(i).getFilename();
-						String urlBuf = images.get(i).getURL();
-						if (urlBuf != null &amp;&amp; !urlBuf.equals(&quot;&quot;)) {
-							detfile.print(&quot;    &lt;IMG&gt;&quot;+SafeXML.clean(stbuf)+&quot;&lt;URL&gt;&quot;+SafeXML.clean(urlBuf)+&quot;&lt;/URL&gt;&lt;/IMG&gt;\n&quot;);
-						} else {
-							detfile.print(&quot;    &lt;IMG&gt;&quot;+SafeXML.clean(stbuf)+&quot;&lt;/IMG&gt;\n&quot;);
-						}
-				  }
-				  int iis = images.size();
-				  for(int i = 0;i&lt;iis;i++){
-						stbuf = images.get(i).getTitle();
-						if (i&lt; iis &amp;&amp; !images.get(i).getComment().equals(&quot;&quot;))
-							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;DESC&gt;&quot;+images.get(i).getComment()+&quot;&lt;/DESC&gt;&lt;/IMGTEXT&gt;\n&quot;);
-						else 
-							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;/IMGTEXT&gt;\n&quot;);
-				  }
 
-				  for(int i = 0;i&lt;logImages.size();i++){
-						stbuf = logImages.get(i).getFilename();
-						detfile.print(&quot;    &lt;LOGIMG&gt;&quot;+stbuf+&quot;&lt;/LOGIMG&gt;\n&quot;);
-				  }
-				  for(int i = 0;i&lt;logImages.size();i++){
-						stbuf = logImages.get(i).getTitle();
-						detfile.print(&quot;    &lt;LOGIMGTEXT&gt;&quot;+stbuf+&quot;&lt;/LOGIMGTEXT&gt;\n&quot;);
-				  }
-				  for(int i = 0;i&lt;userImages.size();i++){
-						stbuf = userImages.get(i).getFilename();
-						detfile.print(&quot;    &lt;USERIMG&gt;&quot;+stbuf+&quot;&lt;/USERIMG&gt;\n&quot;);
-				  }
-				  for(int i = 0;i&lt;userImages.size();i++){
-						stbuf = userImages.get(i).getTitle();
-						detfile.print(&quot;    &lt;USERIMGTEXT&gt;&quot;+stbuf+&quot;&lt;/USERIMGTEXT&gt;\n&quot;);
-				  }
+		userImages.clear();
+		ex.set(text, &quot;&lt;USERIMG&gt;&quot;, &quot;&lt;/USERIMG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			userImages.add(imageInfo);
+		}
 
+		ex.set(text, &quot;&lt;USERIMGTEXT&gt;&quot;, &quot;&lt;/USERIMGTEXT&gt;&quot;, 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = userImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
+		}
 
-				  detfile.print(&quot;&lt;/IMAGES&gt;\n&quot;);
-				  //detfile.print(&quot;&lt;BUGS&gt;&lt;![CDATA[\n&quot;);
-				  //detfile.print(Bugs+&quot;\n&quot;);
-				  //detfile.print(&quot;]]&gt;&lt;/BUGS&gt;\n&quot;);
-				  detfile.print(Travelbugs.toXML());
-				  detfile.print(&quot;&lt;URL&gt;&lt;![CDATA[&quot;+URL+&quot;]]&gt;&lt;/URL&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;+getSolver()+&quot;]]&gt;&lt;/SOLVER&gt;\r\n&quot;);
-				  detfile.print(getParent().toXML()); // This will allow restoration of index.xml
-				  detfile.print(&quot;&lt;/CACHEDETAILS&gt;\n&quot;);
-				  Global.getPref().log(&quot;Writing file: &quot;+getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
-				} // if length
-			} catch (Exception e){
-				Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;,e);
+		ex.set(text, &quot;&lt;TRAVELBUGS&gt;&quot;, &quot;&lt;/TRAVELBUGS&gt;&quot;, 0, false);
+		dummy = ex.findNext();
+		if (dummy.length() == 0) {
+			ex = new Extractor(text, &quot;&lt;BUGS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/BUGS&gt;&quot;, 0, true);
+			String Bugs = ex.findNext();
+			Travelbugs.addFromHTML(Bugs);
+		} else
+			Travelbugs.addFromXML(dummy);
+
+		ex.set(text, &quot;&lt;URL&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/URL&gt;&quot;, 0, true);
+		// if no URL is stored, set default URL (at this time only possible for gc.com)
+		dummy = ex.findNext();
+		if (dummy.length() &gt; 10) {
+			URL = dummy;
+			int logpos = URL.indexOf(&quot;&amp;&quot;); // &amp;Submit &amp;log=y
+			if (logpos &gt; 0)
+				URL = URL.substring(0, logpos);
+		} else {
+			if (getParent().getWayPoint().startsWith(&quot;GC&quot;)) {
+				URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + getParent().getWayPoint();
 			}
-			try{
-			  detfile.close();
-			} catch (Exception e){
-				Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;,e);
-			}
-			hasUnsavedChanges = false;
 		}
-				
-		/**
-		 * Return true if this cache has additional info for some pictures
-		 * @return true if cache has additional info, false otherwise
-		 */
-		public boolean hasImageInfo() {
-			for (int i=this.images.size()-1; i&gt;=0; i--)
-				if (!this.images.get(i).getComment().equals(&quot;&quot;)) return true;
-			return false;
+
+		ex.set(text, &quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/SOLVER&gt;&quot;, 0, true);
+		this.setSolver(ex.findNext());
+	}
+
+	public void deleteFile(String FileName) {
+		// File exists?
+		boolean exists = (new File(FileName)).exists();
+		// yes: then delete
+		if (exists) {
+			boolean ok = (new File(FileName)).delete();
+			if (ok)
+				ok = true;
 		}
+		boolean exists2 = (new File(FileName.toLowerCase())).exists();
+		// yes: delete
+		if (exists2) {
+			boolean ok2 = (new File(FileName.toLowerCase())).delete();
+			if (ok2)
+				ok2 = true;
+		}
+	}
 
-		/**
-		 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
-		 * @param newWptId new id of the waypoint
-		 * @return true on success, false for failure
-		 */
-		protected boolean rename(String newWptId) {
-			boolean success = false;
-			String profiledir = Global.getProfile().dataDir;
-			int oldWptLength = getParent().getWayPoint().length();
-			
-			// just in case ... (got the pun? ;) )
-			newWptId = newWptId.toUpperCase();
-			
-			// update image information
-			for(int i = 0;i&lt;images.size();i++){
-				String filename = images.get(i).getFilename();
-				String comment = images.get(i).getComment();
-				String title = images.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					images.get(i).setFilename(filename);
+	/**
+	 * Method to save a cache.xml file.
+	 */
+	public void saveCacheDetails(String dir) {
+		PrintWriter detfile;
+		deleteFile(dir + getParent().getWayPoint() + &quot;.xml&quot;);
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;).getAbsolutePath())));
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem creating details file&quot;, e, true);
+			return;
+		}
+		try {
+			if (getParent().getWayPoint().length() &gt; 0) {
+				detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;CACHEDETAILS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;VERSION value = \&quot;3\&quot;/&gt;\n&quot;);
+				detfile.print(&quot;&lt;DETAILS&gt;&lt;![CDATA[&quot; + LongDescription + &quot;]]&gt;&lt;/DETAILS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot; + Country + &quot;]]&gt;&lt;/COUNTRY&gt;\n&quot;);
+				detfile.print(&quot;&lt;STATE&gt;&lt;![CDATA[&quot; + State + &quot;]]&gt;&lt;/STATE&gt;\n&quot;);
+				detfile.print(attributes.XmlAttributesWrite());
+				detfile.print(&quot;&lt;HINTS&gt;&lt;![CDATA[&quot; + Hints + &quot;]]&gt;&lt;/HINTS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;LOGS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;OWNLOGID&gt;&quot; + OwnLogId + &quot;&lt;/OWNLOGID&gt;\r\n&quot;);
+				if (OwnLog != null) {
+					detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot; + OwnLog.toHtml() + &quot;]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
+				} else {
+					detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					images.get(i).setComment(comment);
+				for (int i = 0; i &lt; CacheLogs.size(); i++) {
+					detfile.print(CacheLogs.getLog(i).toXML());
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					images.get(i).setTitle(title);
+				detfile.print(&quot;&lt;/LOGS&gt;\r\n&quot;);
+
+				detfile.print(&quot;&lt;NOTES&gt;&lt;![CDATA[&quot; + CacheNotes + &quot;]]&gt;&lt;/NOTES&gt;\n&quot;);
+				detfile.print(&quot;&lt;IMAGES&gt;\n&quot;);
+				String stbuf;
+				for (int i = 0; i &lt; images.size(); i++) {
+					stbuf = images.get(i).getFilename();
+					String urlBuf = images.get(i).getURL();
+					if (urlBuf != null &amp;&amp; !urlBuf.equals(&quot;&quot;)) {
+						detfile.print(&quot;    &lt;IMG&gt;&quot; + SafeXML.clean(stbuf) + &quot;&lt;URL&gt;&quot; + SafeXML.clean(urlBuf) + &quot;&lt;/URL&gt;&lt;/IMG&gt;\n&quot;);
+					} else {
+						detfile.print(&quot;    &lt;IMG&gt;&quot; + SafeXML.clean(stbuf) + &quot;&lt;/IMG&gt;\n&quot;);
+					}
 				}
-			}
-			for(int i = 0;i&lt;logImages.size();i++){
-				String filename = logImages.get(i).getFilename();
-				String comment = logImages.get(i).getComment();
-				String title = logImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					logImages.get(i).setFilename(filename);
+				int iis = images.size();
+				for (int i = 0; i &lt; iis; i++) {
+					stbuf = images.get(i).getTitle();
+					if (i &lt; iis &amp;&amp; !images.get(i).getComment().equals(&quot;&quot;))
+						detfile.print(&quot;    &lt;IMGTEXT&gt;&quot; + stbuf + &quot;&lt;DESC&gt;&quot; + images.get(i).getComment() + &quot;&lt;/DESC&gt;&lt;/IMGTEXT&gt;\n&quot;);
+					else
+						detfile.print(&quot;    &lt;IMGTEXT&gt;&quot; + stbuf + &quot;&lt;/IMGTEXT&gt;\n&quot;);
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					logImages.get(i).setComment(comment);
+
+				for (int i = 0; i &lt; logImages.size(); i++) {
+					stbuf = logImages.get(i).getFilename();
+					detfile.print(&quot;    &lt;LOGIMG&gt;&quot; + stbuf + &quot;&lt;/LOGIMG&gt;\n&quot;);
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					logImages.get(i).setTitle(title);
+				for (int i = 0; i &lt; logImages.size(); i++) {
+					stbuf = logImages.get(i).getTitle();
+					detfile.print(&quot;    &lt;LOGIMGTEXT&gt;&quot; + stbuf + &quot;&lt;/LOGIMGTEXT&gt;\n&quot;);
 				}
-			}
-			for(int i = 0;i&lt;userImages.size();i++){
-				String filename = userImages.get(i).getFilename();
-				String comment = userImages.get(i).getComment();
-				String title = userImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					userImages.get(i).setFilename(filename);
+				for (int i = 0; i &lt; userImages.size(); i++) {
+					stbuf = userImages.get(i).getFilename();
+					detfile.print(&quot;    &lt;USERIMG&gt;&quot; + stbuf + &quot;&lt;/USERIMG&gt;\n&quot;);
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					userImages.get(i).setComment(comment);
+				for (int i = 0; i &lt; userImages.size(); i++) {
+					stbuf = userImages.get(i).getTitle();
+					detfile.print(&quot;    &lt;USERIMGTEXT&gt;&quot; + stbuf + &quot;&lt;/USERIMGTEXT&gt;\n&quot;);
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					userImages.get(i).setTitle(title);
-				}
+
+				detfile.print(&quot;&lt;/IMAGES&gt;\n&quot;);
+				// detfile.print(&quot;&lt;BUGS&gt;&lt;![CDATA[\n&quot;);
+				// detfile.print(Bugs+&quot;\n&quot;);
+				// detfile.print(&quot;]]&gt;&lt;/BUGS&gt;\n&quot;);
+				detfile.print(Travelbugs.toXML());
+				detfile.print(&quot;&lt;URL&gt;&lt;![CDATA[&quot; + URL + &quot;]]&gt;&lt;/URL&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;SOLVER&gt;&lt;![CDATA[&quot; + getSolver() + &quot;]]&gt;&lt;/SOLVER&gt;\r\n&quot;);
+				detfile.print(getParent().toXML()); // This will allow restoration of index.xml
+				detfile.print(&quot;&lt;/CACHEDETAILS&gt;\n&quot;);
+				Global.getPref().log(&quot;Writing file: &quot; + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
+			} // if length
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;, e);
+		}
+		try {
+			detfile.close();
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;, e);
+		}
+		hasUnsavedChanges = false;
+	}
+
+	/**
+	 * Return true if this cache has additional info for some pictures
+	 * 
+	 * @return true if cache has additional info, false otherwise
+	 */
+	public boolean hasImageInfo() {
+		for (int i = this.images.size() - 1; i &gt;= 0; i--)
+			if (!this.images.get(i).getComment().equals(&quot;&quot;))
+				return true;
+		return false;
+	}
+
+	/**
+	 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
+	 * 
+	 * @param newWptId
+	 *            new id of the waypoint
+	 * @return true on success, false for failure
+	 */
+	protected boolean rename(String newWptId) {
+		boolean success = false;
+		String profiledir = Global.getProfile().dataDir;
+		int oldWptLength = getParent().getWayPoint().length();
+
+		// just in case ... (got the pun? ;) )
+		newWptId = newWptId.toUpperCase();
+
+		// update image information
+		for (int i = 0; i &lt; images.size(); i++) {
+			String filename = images.get(i).getFilename();
+			String comment = images.get(i).getComment();
+			String title = images.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				images.get(i).setFilename(filename);
 			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				images.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				images.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i &lt; logImages.size(); i++) {
+			String filename = logImages.get(i).getFilename();
+			String comment = logImages.get(i).getComment();
+			String title = logImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				logImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				logImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				logImages.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i &lt; userImages.size(); i++) {
+			String filename = userImages.get(i).getFilename();
+			String comment = userImages.get(i).getComment();
+			String title = userImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				userImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				userImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				userImages.get(i).setTitle(title);
+			}
+		}
 
-			// rename the files
-			try {
-				// since we use *.* we do not need FileBugFix
-				String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat(&quot;*.*&quot;), ewe.io.FileBase.LIST_FILES_ONLY);
-				for (int i=0; i &lt; srcFiles.length;i++){
-					String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
-					File srcFile = new File(profiledir.concat(srcFiles[i]));
-					File dstFile = new File(profiledir.concat(newfile));
-					srcFile.move(dstFile);
-				}
-				success = true;
-			} catch (Exception e) {
-				Global.getPref().log(&quot;Error renaming waypoint details&quot;, e, true);
-				//TODO: any chance of a roll back?
-				//TODO: should we ignore a file not found?
+		// rename the files
+		try {
+			// since we use *.* we do not need FileBugFix
+			String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat(&quot;*.*&quot;), ewe.io.FileBase.LIST_FILES_ONLY);
+			for (int i = 0; i &lt; srcFiles.length; i++) {
+				String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
+				File srcFile = new File(profiledir.concat(srcFiles[i]));
+				File dstFile = new File(profiledir.concat(newfile));
+				srcFile.move(dstFile);
 			}
-			hasUnsavedChanges = true;
-			return success;
+			success = true;
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Error renaming waypoint details&quot;, e, true);
+			// TODO: any chance of a roll back?
+			// TODO: should we ignore a file not found?
 		}
+		hasUnsavedChanges = true;
+		return success;
+	}
 }
-
-

Modified: trunk/src/CacheWolf/Extractor.java
===================================================================
--- trunk/src/CacheWolf/Extractor.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/Extractor.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,104 +1,119 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+/**
+ * This is a powerfull class that is used very often. It is quicker than
+ * XML parsing and should be used whenever possible to find and extract
+ * parts of a string in a string.
+ */
+public class Extractor {
+	int _startOffset;
+	String _searchText;
+	String start;
+	String end;
+	boolean _betweenonly;
+	public static boolean INCLUDESTARTEND = false;
+	public static boolean EXCLUDESTARTEND = true;
 
-/**
-*	This is a powerfull class that is used very often. It is quicker than
-*	XML parsing and should be used whenever possible to find and extract
-*	parts of a string in a string.
-*/
-public class Extractor  {
-		int startOffset; // No initialisation needed, done in constructor
-		String searchText;
-		String start;
-		String end;
-		String tst;
-		boolean betweenonly;
-		public static boolean INCLUDESTARTEND = false;
-		public static boolean EXCLUDESTARTEND = true;
-		/**
-		*	Create an extractor.
-		*	sTxt = The string to search through.&lt;br&gt;
-		*	st = The string that denotes the start of the string to extract&lt;br&gt;
-		*	e = The string that denotes the end of the string to extract&lt;br&gt;
-		*	sOff = The beginning offset from which to start the search in sTxt&lt;br&gt;
-		*	only = if false the string returned will inlcude st and e; if true
-		*	it will not include st and e.
-		*
-		*/
-		public Extractor(String sTxt, String st, String e, int sOff, boolean only){
-			startOffset = sOff;
-			searchText = sTxt;
-			end = e;
-			start = st;
-			betweenonly = only;
-		}
-		
-		/**
-		 * Mehtod to set the source text to be searched through
-		 * 
-		 */
-		public void setSource(String sTxt){
-			searchText = sTxt;
-			startOffset = 0;
-		}
-		
-		/**
-		* Method that informs if the search has encountered the end of the string
-		* that is being searched through.
-		*/
-		public boolean endOfSearch(){
-			if(searchText == null || startOffset &gt;= searchText.length()) return true;
-			else return false;
-		}
-		
-		/**
-		*	Method to find the next occurance of a string that is enclosed by
-		*	that start (st) and end string (e). if end is not found the string
-		*	is returned til it's end.
-		*/
-		public String findNext(){
-			if (searchText == null) return new String(); //maby null should 
-			int idxStart = searchText.indexOf(start,startOffset);
-			int idxEnd = searchText.indexOf(end, idxStart+start.length());
-			if(idxEnd == -1) idxEnd = searchText.length(); //index counts from zero length from 1 but the last char is not included in substr and substr accepts length +1 (but not length+2)
-			startOffset = idxEnd;
-			tst = new String();
-			if(idxStart &gt; -1){
-				if(betweenonly == false){
-					if (idxEnd+end.length() &gt;= searchText.length()) 
-						 tst = searchText.substring(idxStart);
-					else tst = searchText.substring(idxStart,idxEnd+end.length());
-				}else{ 
-					tst = searchText.substring(idxStart+start.length(),idxEnd);
+	/**
+	 * Create an extractor.
+	 * searchText = The string to search through.&lt;br&gt;
+	 * st = The string that denotes the start of the string to extract&lt;br&gt;
+	 * e = The string that denotes the end of the string to extract&lt;br&gt;
+	 * startOffset = The beginning offset from which to start the search in sTxt&lt;br&gt;
+	 * betweenonly = if false the string returned will inlcude st and e;
+	 * if true it will not include st and e.
+	 * 
+	 */
+	public Extractor(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	/**
+	 * Mehtod to set the source text to be searched through
+	 * 
+	 */
+	public void set(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	public void set(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+	}
+
+	public String findFirst(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+		return findNext();
+	}
+
+	public String findNext(String startText) {
+		start = startText;
+		return findNext();
+	}
+
+	public String findNext(String startText, String endText) {
+		start = startText;
+		end = endText;
+		return findNext();
+	}
+
+	/**
+	 * Method to find the next occurance of a string that is enclosed by
+	 * that start (st) and end string (e).
+	 * if end is not found empty string is returned.
+	 */
+	public String findNext() {
+		String ret = &quot;&quot;;
+		if (_searchText != null &amp;&amp; _searchText.length() &gt; _startOffset + start.length() + end.length()) {
+			int idxStart = _searchText.indexOf(start, _startOffset);
+			int idxEnd = -1;
+			if (idxStart &gt; -1) {
+				idxEnd = _searchText.indexOf(end, idxStart + start.length());
+				if (idxEnd &gt; -1) {
+					_startOffset = idxEnd;
+					ret = _searchText.substring(idxStart + start.length(), idxEnd);
+					if (!this._betweenonly)
+						ret = start + ret + end;
 				}
-			} else {
-				startOffset = searchText.length();
 			}
-			return tst;
+			if (idxEnd == -1) {
+				_startOffset = _searchText.length(); // Schluss
+			}
 		}
+		return ret;
+	}
 }

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/Profile.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Area;
@@ -44,22 +44,25 @@
 
 /**
  * This class holds a profile, i.e. a group of caches with a centre location
- *
+ * 
  * @author salzkammergut
- *
+ * 
  */
 public class Profile {
 
-	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
-	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
+	/**
+	 * The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
+	 * this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
 	 */
-	public CacheDB cacheDB=new CacheDB();
+	public CacheDB cacheDB = new CacheDB();
 	/** The centre point of this group of caches. Read from ans stored to index.xml file */
-	public CWPoint centre=new CWPoint();
-	/** The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
-	 *  the index.xml and cache files live. (Excuse the English spelling of centre)     */
-	public String name=&quot;&quot;;
-	/** This is the directory for the profile. It contains a closing /.   	 */
+	public CWPoint centre = new CWPoint();
+	/**
+	 * The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
+	 * the index.xml and cache files live. (Excuse the English spelling of centre)
+	 */
+	public String name = &quot;&quot;;
+	/** This is the directory for the profile. It contains a closing /. */
 	public String dataDir = &quot;&quot;;
 
 	/** Last sync date for opencaching caches */
@@ -73,11 +76,11 @@
 	private String minDistGC = &quot;&quot;;
 	/** Direction for geocaching caches */
 	private String directionGC = &quot;&quot;;
-	
-	private String gpxStyle =new String(); 
-	private String gpxTarget =new String(); 
-	private String gpxId =new String(); 
 
+	private String gpxStyle = new String();
+	private String gpxTarget = new String();
+	private String gpxId = new String();
+
 	/** path to the maps of the profile relative to the maps root */
 	private String relativeCustomMapsPath = &quot;&quot;;
 
@@ -91,7 +94,8 @@
 	private boolean showSearchResult = false;
 
 	public boolean selectionChanged = true; // (&quot;H&#228;ckchen&quot;) used by movingMap to get to knao if it should update the caches in the map
-	/** True if the profile has been modified and not saved
+	/**
+	 * True if the profile has been modified and not saved
 	 * The following modifications set this flag: New profile centre, Change of waypoint data
 	 */
 	private boolean hasUnsavedChanges = false;
@@ -100,21 +104,19 @@
 	/** version number of current format for index.xml and waypoint.xml */
 	protected static int CURRENTFILEFORMAT = 3;
 
-	//TODO Add other settings, such as max. number of logs to spider
-	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
+	// TODO Add other settings, such as max. number of logs to spider
+	// TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 
 	/**
 	 * Constructor for a profile
-	 *
+	 * 
 	 */
-	public Profile(){ // public constructor
+	public Profile() { // public constructor
 	}
 
-
 	/**
-	 * Returns &lt;code&gt;true&lt;/code&gt; if profile needs to be changed when profile is left. Returns
-	 * &lt;code&gt;false&lt;/code&gt; if no relevant changes have been made.
-	 *
+	 * Returns &lt;code&gt;true&lt;/code&gt; if profile needs to be changed when profile is left. Returns &lt;code&gt;false&lt;/code&gt; if no relevant changes have been made.
+	 * 
 	 * @return hasUnsavedChanges
 	 */
 	public boolean hasUnsavedChanges() {
@@ -125,7 +127,7 @@
 	 * Remember that profile needs to be saved. Flag is set &lt;code&gt;true&lt;/code&gt; when parameter is
 	 * true, but it's not set to &lt;code&gt;false&lt;/code&gt; when parameter is &lt;code&gt;false&lt;/code&gt;.&lt;br&gt;
 	 * This is only done internally on saving the cache.
-	 *
+	 * 
 	 * @param hasUnsavedChanges
 	 *            the hasUnsavedChanges to set
 	 */
@@ -161,58 +163,58 @@
 	}
 
 	/**
-	 *	Method to save the index.xml file that holds the total information
-	 *	on available caches in the database. The database is nothing else
-	 *	than the collection of caches in a directory.
-	 *
-	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
-	 *
-	 *   Saves the index with the filter settings from Filter
+	 * Method to save the index.xml file that holds the total information
+	 * on available caches in the database. The database is nothing else
+	 * than the collection of caches in a directory.
+	 * 
+	 * Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
+	 * 
+	 * Saves the index with the filter settings from Filter
 	 */
-//	public void saveIndex(Preferences pref, boolean showprogress){
-//		saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
-//	}
+	// public void saveIndex(Preferences pref, boolean showprogress){
+	// saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
+	// }
 
-
 	/** Save index with filter settings given */
 	public void saveIndex(Preferences pref, boolean showprogress) {
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
-		if(showprogress){
-			pbf.showMainTask = true;//false;
-			pbf.setTask(h,&quot;Saving Index&quot;);
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
+		if (showprogress) {
+			pbf.showMainTask = true;// false;
+			pbf.setTask(h, &quot;Saving Index&quot;);
 			pbf.exec();
 		}
 		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
 		PrintWriter detfile;
 		CacheHolder ch;
 		try {
-			File backup=new File(dataDir+&quot;index.bak&quot;);
+			File backup = new File(dataDir + &quot;index.bak&quot;);
 			if (backup.exists()) {
 				backup.delete();
 			}
-			File index=new File(dataDir+&quot;index.xml&quot;);
+			File index = new File(dataDir + &quot;index.xml&quot;);
 			index.rename(&quot;index.bak&quot;);
 		} catch (Exception ex) {
 			pref.log(&quot;[Profile:saveIndex]Error deleting backup or renaming index.xml&quot;);
 		}
-		try{
+		try {
 			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dataDir + &quot;index.xml&quot;).getAbsolutePath())));
 		} catch (Exception e) {
-			pref.log(&quot;Problem creating index.xml &quot; + dataDir,e);
+			pref.log(&quot;Problem creating index.xml &quot; + dataDir, e);
 			return;
 		}
-		CWPoint savedCentre=centre;
-		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 &amp;&amp; savedCentre.lonDec==0.0)) savedCentre=pref.getCurCentrePt();
+		CWPoint savedCentre = centre;
+		if (centre == null || !centre.isValid() || (savedCentre.latDec == 0.0 &amp;&amp; savedCentre.lonDec == 0.0))
+			savedCentre = pref.getCurCentrePt();
 
-		try{
+		try {
 			detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;);
 			detfile.print(&quot;&lt;CACHELIST format=\&quot;decimal\&quot;&gt;\n&quot;);
 			detfile.print(&quot;    &lt;VERSION value = \&quot;3\&quot;/&gt;\n&quot;);
 			if (savedCentre.isValid())
-				detfile.print(&quot;    &lt;CENTRE lat=\&quot;&quot;+savedCentre.latDec+&quot;\&quot; lon=\&quot;&quot;+savedCentre.lonDec+&quot;\&quot;/&gt;\n&quot;);
-			if(getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith(&quot;null&quot;) || getLast_sync_opencaching().equals(&quot;&quot;)){
+				detfile.print(&quot;    &lt;CENTRE lat=\&quot;&quot; + savedCentre.latDec + &quot;\&quot; lon=\&quot;&quot; + savedCentre.lonDec + &quot;\&quot;/&gt;\n&quot;);
+			if (getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith(&quot;null&quot;) || getLast_sync_opencaching().equals(&quot;&quot;)) {
 				setLast_sync_opencaching(&quot;20050801000000&quot;);
 			}
 			if (getDistOC() == null || getDistOC().endsWith(&quot;null&quot;) || getDistOC().equals(&quot;&quot;)) {
@@ -232,15 +234,14 @@
 			// normal filter, because after loading there is no cache tour defined
 			// which could be used as filter criterium.
 			int activeFilterForSave;
-			if (getFilterActive()==Filter.FILTER_CACHELIST) {
+			if (getFilterActive() == Filter.FILTER_CACHELIST) {
 				activeFilterForSave = Filter.FILTER_ACTIVE;
 			} else {
 				activeFilterForSave = getFilterActive();
 			}
-			detfile.print(&quot;    &lt;FILTERCONFIG status = \&quot;&quot;+activeFilterForSave+
-					(isFilterInverted()?&quot;T&quot;:&quot;F&quot;)+&quot;\&quot; showBlacklist = \&quot;&quot;+showBlacklisted()+&quot;\&quot; /&gt;\n&quot;);
+			detfile.print(&quot;    &lt;FILTERCONFIG status = \&quot;&quot; + activeFilterForSave + (isFilterInverted() ? &quot;T&quot; : &quot;F&quot;) + &quot;\&quot; showBlacklist = \&quot;&quot; + showBlacklisted() + &quot;\&quot; /&gt;\n&quot;);
 			detfile.print(this.getCurrentFilter().toXML(&quot;&quot;));
-			detfile.print(&quot;    &lt;SYNCOC date = \&quot;&quot;+getLast_sync_opencaching()+&quot;\&quot; dist = \&quot;&quot;+getDistOC()+&quot;\&quot;/&gt;\n&quot;);
+			detfile.print(&quot;    &lt;SYNCOC date = \&quot;&quot; + getLast_sync_opencaching() + &quot;\&quot; dist = \&quot;&quot; + getDistOC() + &quot;\&quot;/&gt;\n&quot;);
 			detfile.print(&quot;    &lt;SPIDERGC dist = \&quot;&quot; + getDistGC() + &quot;\&quot; mindist = \&quot;&quot; + getMinDistGC() + &quot;\&quot; direction = \&quot;&quot; + getDirectionGC() + &quot;\&quot;/&gt;\n&quot;);
 			detfile.print(&quot;    &lt;EXPORT style = \&quot;&quot; + getGpxStyle() + &quot;\&quot; target = \&quot;&quot; + getGpxTarget() + &quot;\&quot; id = \&quot;&quot; + getGpxId() + &quot;\&quot;/&gt;\n&quot;);
 			detfile.print(&quot;    &lt;mapspath relativeDir = \&quot;&quot; + SafeXML.clean(relativeCustomMapsPath) + &quot;\&quot;/&gt;\n&quot;);
@@ -248,7 +249,8 @@
 			for (int i = 0; i &lt; size; i++) {
 				if (showprogress) {
 					h.progress = (float) i / (float) size;
-					if ((i%updFrequ)==0) h.changed();
+					if ((i % updFrequ) == 0)
+						h.changed();
 				}
 				ch = cacheDB.get(i);
 				if (ch.getWayPoint().length() &gt; 0) {
@@ -257,12 +259,14 @@
 			}
 			detfile.print(&quot;&lt;/CACHELIST&gt;\n&quot;);
 			detfile.close();
-			buildReferences(); //TODO Why is this needed here?
-			if(showprogress) pbf.exit(0);
-		}catch(Exception e){
-			pref.log(&quot;Problem writing to index file &quot;,e);
+			buildReferences(); // TODO Why is this needed here?
+			if (showprogress)
+				pbf.exit(0);
+		} catch (Exception e) {
+			pref.log(&quot;Problem writing to index file &quot;, e);
 			detfile.close();
-			if(showprogress) pbf.exit(0);
+			if (showprogress)
+				pbf.exit(0);
 		}
 		resetUnsavedChanges();
 	}
@@ -270,19 +274,20 @@
 	public void readIndex() {
 		readIndex(null);
 	}
+
 	/**
-	 *	Method to read the index.xml file that holds the total information
-	 *	on available caches in the database. The database in nothing else
-	 *	than the collection of caches in a directory.
+	 * Method to read the index.xml file that holds the total information
+	 * on available caches in the database. The database in nothing else
+	 * than the collection of caches in a directory.
 	 */
 	public void readIndex(InfoBox infoBox) {
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
 		try {
 			selectionChanged = true;
 			boolean fmtDec = false;
-			String mainInfoText = MyLocale.getMsg(5000,&quot;Loading Cache-List&quot;);
-			int wptNo=1;
-			int lastShownWpt=0;
+			String mainInfoText = MyLocale.getMsg(5000, &quot;Loading Cache-List&quot;);
+			int wptNo = 1;
+			int lastShownWpt = 0;
 			char decSep = MyLocale.getDigSeparator().charAt(0);
 			char notDecSep = decSep == '.' ? ',' : '.';
 			FileBugfix indexFile = new FileBugfix(dataDir + &quot;index.xml&quot;);
@@ -290,92 +295,106 @@
 			indexXmlVersion = 1; // Initial guess
 			in.readLine(); // &lt;?xml version= ...
 			String text = in.readLine(); // &lt;CACHELIST&gt;
-			if (text!=null &amp;&amp; text.indexOf(&quot;decimal&quot;)&gt;0) fmtDec=true;
+			if (text != null &amp;&amp; text.indexOf(&quot;decimal&quot;) &gt; 0)
+				fmtDec = true;
 			Extractor ex = new Extractor(null, &quot; = \&quot;&quot;, &quot;\&quot; &quot;, 0, true);
 
-			//ewe.sys.Time startT=new ewe.sys.Time();
+			// ewe.sys.Time startT=new ewe.sys.Time();
 			boolean convertWarningDisplayed = false;
-			while ((text = in.readLine()) != null){
+			while ((text = in.readLine()) != null) {
 				// Check for Line with cache data
-				if (text.indexOf(&quot;&lt;CACHE &quot;)&gt;=0){
+				if (text.indexOf(&quot;&lt;CACHE &quot;) &gt;= 0) {
 					if (indexXmlVersion &lt; CURRENTFILEFORMAT &amp;&amp; !convertWarningDisplayed) {
 						if (indexXmlVersion &lt; CURRENTFILEFORMAT) {
 							convertWarningDisplayed = true;
-							int res=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4407, &quot;The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done.&quot;), FormBase.YESB|FormBase.NOB).execute();
+							int res = new MessageBox(
+									MyLocale.getMsg(144, &quot;Warning&quot;),
+									MyLocale.getMsg(4407,
+											&quot;The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done.&quot;),
+									FormBase.YESB | FormBase.NOB).execute();
 							if (res == MessageBox.NOB) {
 								ewe.sys.Vm.exit(0);
 							}
 						}
 					}
-					if (infoBox!=null) {
+					if (infoBox != null) {
 						if (wptNo - updFrequ &gt;= lastShownWpt) {
-							infoBox.setInfo(mainInfoText+&quot;\n&quot;+String.valueOf(wptNo));
+							infoBox.setInfo(mainInfoText + &quot;\n&quot; + String.valueOf(wptNo));
 							lastShownWpt = wptNo;
 						}
 						wptNo++;
 					}
-					CacheHolder ch=new CacheHolder(text,indexXmlVersion);
+					CacheHolder ch = new CacheHolder(text, indexXmlVersion);
 					cacheDB.add(ch);
-				} else if (text.indexOf(&quot;&lt;CENTRE&quot;)&gt;=0) { // lat=  lon=
+				} else if (text.indexOf(&quot;&lt;CENTRE&quot;) &gt;= 0) { // lat= lon=
 					if (fmtDec) {
-						int start=text.indexOf(&quot;lat=\&quot;&quot;)+5;
-						String lat=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)).replace(notDecSep,decSep);
-						start=text.indexOf(&quot;lon=\&quot;&quot;)+5;
-						String lon=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)).replace(notDecSep,decSep);
-						centre.set(Convert.parseDouble(lat),Convert.parseDouble(lon));
+						int start = text.indexOf(&quot;lat=\&quot;&quot;) + 5;
+						String lat = text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)).replace(notDecSep, decSep);
+						start = text.indexOf(&quot;lon=\&quot;&quot;) + 5;
+						String lon = text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)).replace(notDecSep, decSep);
+						centre.set(Convert.parseDouble(lat), Convert.parseDouble(lon));
 					} else {
-						int start=text.indexOf(&quot;lat=\&quot;&quot;)+5;
-						String lat=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-						start=text.indexOf(&quot;long=\&quot;&quot;)+6;
-						String lon=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-						centre.set(lat+&quot; &quot;+lon,TransformCoordinates.CW); // Fast parse
+						int start = text.indexOf(&quot;lat=\&quot;&quot;) + 5;
+						String lat = SafeXML.cleanback(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+						start = text.indexOf(&quot;long=\&quot;&quot;) + 6;
+						String lon = SafeXML.cleanback(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+						centre.set(lat + &quot; &quot; + lon, TransformCoordinates.CW); // Fast parse
 					}
-				} else if (text.indexOf(&quot;&lt;VERSION&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;value = \&quot;&quot;)+9;
-					indexXmlVersion  = Integer.valueOf(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start))).intValue();
+				} else if (text.indexOf(&quot;&lt;VERSION&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;value = \&quot;&quot;) + 9;
+					indexXmlVersion = Integer.valueOf(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start))).intValue();
 					if (indexXmlVersion &gt; CURRENTFILEFORMAT) {
 						Global.getPref().log(&quot;[Profile:readIndex]unsupported file format&quot;);
 						clearProfile();
 						return;
 					}
-				} else if (text.indexOf(&quot;&lt;SYNCOC&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;date = \&quot;&quot;)+8;
-					setLast_sync_opencaching(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;dist = \&quot;&quot;)+8;
-					setDistOC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-				} else if (text.indexOf(&quot;mapspath&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;relativeDir = \&quot;&quot;)+15;
-					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start))).replace('\\','/'));
-				} else if (text.indexOf(&quot;&lt;SPIDERGC&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;dist = \&quot;&quot;)+8;
-					setDistGC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;mindist = \&quot;&quot;)+11;
-					if (start==10) {setMinDistGC(&quot;0&quot;);}
-					else setMinDistGC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;direction = \&quot;&quot;)+13;
-					if (start==12) {setDirectionGC(&quot;&quot;);}
-					else setDirectionGC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-				} else if (text.indexOf(&quot;&lt;EXPORT&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;style = \&quot;&quot;)+9;
-					if (start==8) {setGpxStyle(&quot;0&quot;);}
-					else setGpxStyle(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;target = \&quot;&quot;)+10;
-					if (start==9) {setGpxTarget(&quot;0&quot;);}
-					else setGpxTarget(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;id = \&quot;&quot;)+6;
-					if (start==5) {setGpxId(&quot;0&quot;);}
-					else setGpxId(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-				} else if (indexXmlVersion &lt;=2 &amp;&amp; text.indexOf(&quot;&lt;FILTER&quot;)&gt;=0){
+				} else if (text.indexOf(&quot;&lt;SYNCOC&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;date = \&quot;&quot;) + 8;
+					setLast_sync_opencaching(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;dist = \&quot;&quot;) + 8;
+					setDistOC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+				} else if (text.indexOf(&quot;mapspath&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;relativeDir = \&quot;&quot;) + 15;
+					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start))).replace('\\', '/'));
+				} else if (text.indexOf(&quot;&lt;SPIDERGC&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;dist = \&quot;&quot;) + 8;
+					setDistGC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;mindist = \&quot;&quot;) + 11;
+					if (start == 10) {
+						setMinDistGC(&quot;0&quot;);
+					} else
+						setMinDistGC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;direction = \&quot;&quot;) + 13;
+					if (start == 12) {
+						setDirectionGC(&quot;&quot;);
+					} else
+						setDirectionGC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+				} else if (text.indexOf(&quot;&lt;EXPORT&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;style = \&quot;&quot;) + 9;
+					if (start == 8) {
+						setGpxStyle(&quot;0&quot;);
+					} else
+						setGpxStyle(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;target = \&quot;&quot;) + 10;
+					if (start == 9) {
+						setGpxTarget(&quot;0&quot;);
+					} else
+						setGpxTarget(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;id = \&quot;&quot;) + 6;
+					if (start == 5) {
+						setGpxId(&quot;0&quot;);
+					} else
+						setGpxId(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+				} else if (indexXmlVersion &lt;= 2 &amp;&amp; text.indexOf(&quot;&lt;FILTER&quot;) &gt;= 0) {
 					// Read filter data of file versions 1 and 2. (Legacy code)
-					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTER&quot;)));
-					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
-					if (temp.length()==2) {
+					String temp = ex.findFirst(text.substring(text.indexOf(&quot;&lt;FILTER&quot;))); // Filter status is now first, need to deal with old versions which don't have filter status
+					if (temp.length() == 2) {
 						// Compatibility with previous versions
-						if (temp.charAt(0)=='T')
+						if (temp.charAt(0) == 'T')
 							setFilterActive(Filter.FILTER_ACTIVE);
 						else
-							setFilterActive(Common.parseInt(temp.substring(0,1)));
-						setFilterInverted(temp.charAt(1)=='T');
+							setFilterActive(Common.parseInt(temp.substring(0, 1)));
+						setFilterInverted(temp.charAt(1) == 'T');
 						setFilterRose(ex.findNext());
 					} else
 						setFilterRose(temp);
@@ -386,20 +405,19 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						filterAttr[2] = Convert.parseLong(attr);
 					attr = ex.findNext();
-					setFilterAttr(filterAttr);					
+					setFilterAttr(filterAttr);
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						setFilterAttrChoice(Convert.parseInt(attr));
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
-				} else if (text.indexOf(&quot;&lt;FILTERDATA&quot;)&gt;=0){
-					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTERDATA&quot;)));
-					setFilterRose(ex.findNext());
+				} else if (text.indexOf(&quot;&lt;FILTERDATA&quot;) &gt;= 0) {
+					setFilterRose(ex.findFirst(text.substring(text.indexOf(&quot;&lt;FILTERDATA&quot;))));
 					setFilterType(ex.findNext());
 					setFilterVar(ex.findNext());
 					setFilterDist(ex.findNext());
@@ -407,7 +425,7 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
@@ -418,69 +436,68 @@
 					setFilterAttrChoice(Convert.parseInt(attr));
 					setFilterStatus(SafeXML.cleanback(ex.findNext()));
 					setFilterUseRegexp(Boolean.valueOf(ex.findNext()).booleanValue());
-					attr = ex.findNext();					
-	  				if (attr != null &amp;&amp; !attr.equals(&quot;&quot;)) {
-	  					setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;)) {
+						setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
 
-	  				}
-	  				else {
-	  					setFilterNoCoord(true);
-	  				}
-	  				attr = ex.findNext();					
-	  				if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
-	  					filterAttr[1] = Convert.parseLong(attr);
-	  				attr = ex.findNext();
-	  				if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
-	  					filterAttr[3] = Convert.parseLong(attr);
-	  				setFilterAttr(filterAttr);
-				} else if (text.indexOf(&quot;&lt;FILTERCONFIG&quot;)&gt;=0){
-					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTERCONFIG&quot;)));
-					String temp=ex.findNext();
-					setFilterActive(Common.parseInt(temp.substring(0,1)));
-					setFilterInverted(temp.charAt(1)=='T');
+					} else {
+						setFilterNoCoord(true);
+					}
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						filterAttr[1] = Convert.parseLong(attr);
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						filterAttr[3] = Convert.parseLong(attr);
+					setFilterAttr(filterAttr);
+				} else if (text.indexOf(&quot;&lt;FILTERCONFIG&quot;) &gt;= 0) {
+					String temp = ex.findFirst(text.substring(text.indexOf(&quot;&lt;FILTERCONFIG&quot;)));
+					setFilterActive(Common.parseInt(temp.substring(0, 1)));
+					setFilterInverted(temp.charAt(1) == 'T');
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
 				}
 			}
 			in.close();
 			// Build references between caches and addi wpts
-			if (infoBox!=null) {
-				infoBox.setInfo(MyLocale.getMsg(5004,&quot;Building references...&quot;));
+			if (infoBox != null) {
+				infoBox.setInfo(MyLocale.getMsg(5004, &quot;Building references...&quot;));
 			}
 			buildReferences();
 			if (indexXmlVersion &lt; CURRENTFILEFORMAT) {
 				saveIndex(Global.getPref(), true);
 			}
 		} catch (FileNotFoundException e) {
-			Global.getPref().log(&quot;index.xml not found in directory &quot;+dataDir,e);
-		} catch (IOException e){
-			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot;+dataDir,e,true);
+			Global.getPref().log(&quot;index.xml not found in directory &quot; + dataDir, e);
+		} catch (IOException e) {
+			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot; + dataDir, e, true);
 		}
 		this.getCurrentFilter().normaliseFilters();
 		resetUnsavedChanges();
 	}
 
-	/** Restore the filter to the values stored in this profile
-	 *  Called from Main Form and MainMenu
-	 *  The values of Filter.isActive and Filter.isInactive are set by the filter
+	/**
+	 * Restore the filter to the values stored in this profile
+	 * Called from Main Form and MainMenu
+	 * The values of Filter.isActive and Filter.isInactive are set by the filter
 	 **/
 	public void restoreFilter() {
-		restoreFilter( true );
+		restoreFilter(true);
 	}
 
 	void restoreFilter(boolean clearIfInactive) {
-		boolean inverted=isFilterInverted(); // Save it as doFilter will clear filterInverted
-		Filter flt=new Filter();
-		if (getFilterActive()==Filter.FILTER_ACTIVE) {
+		boolean inverted = isFilterInverted(); // Save it as doFilter will clear filterInverted
+		Filter flt = new Filter();
+		if (getFilterActive() == Filter.FILTER_ACTIVE) {
 			flt.setFilter();
 			flt.doFilter();
 			if (inverted) {
 				flt.invertFilter();
 				setFilterInverted(true); // Needed because previous line inverts filterInverted
 			}
-		} else if (getFilterActive()==Filter.FILTER_CACHELIST) {
+		} else if (getFilterActive() == Filter.FILTER_CACHELIST) {
 			Global.mainForm.cacheList.applyCacheList();
-			//flt.filterActive=filterActive;
-		} else if (getFilterActive()==Filter.FILTER_INACTIVE) {
+			// flt.filterActive=filterActive;
+		} else if (getFilterActive() == Filter.FILTER_INACTIVE) {
 			if (clearIfInactive) {
 				flt.clearFilter();
 			}
@@ -507,8 +524,9 @@
 	}
 
 	/**
-	 *
-	 * @param forcache maincache
+	 * 
+	 * @param forcache
+	 *            maincache
 	 * @return
 	 */
 	public String getNewAddiWayPointName(String forcache) {
@@ -522,7 +540,7 @@
 
 	/**
 	 * Call this after getNewAddiWayPointName to set the references between main and addi correctly
-	 *
+	 * 
 	 * @param ch
 	 */
 	public void setAddiRef(CacheHolder ch) {
@@ -530,15 +548,15 @@
 		int mainindex = getCacheIndex(&quot;GC&quot; + mainwpt);
 		if (mainindex &lt; 0 || !cacheDB.get(mainindex).isCacheWpt()) {
 			for (int i = 0; i &lt; OC.OCSites.length; i++) {
-				mainindex=getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
-				if (mainindex &gt;= 0 &amp;&amp; cacheDB.get(mainindex).isCacheWpt()){
+				mainindex = getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
+				if (mainindex &gt;= 0 &amp;&amp; cacheDB.get(mainindex).isCacheWpt()) {
 					break;
 				}
 			}
 		}
 		if (mainindex &lt; 0 || !cacheDB.get(mainindex).isCacheWpt())
 			mainindex = getCacheIndex(&quot;CW&quot; + mainwpt);
-		if (mainindex &lt; 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */ )  {
+		if (mainindex &lt; 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */) {
 			ch.setIncomplete(true);
 		} else {
 			CacheHolder mainch = cacheDB.get(mainindex);
@@ -553,8 +571,7 @@
 	}
 
 	public String toString() {
-		return &quot;Profile: Name=&quot;+name+&quot;\nCentre=&quot;+centre.toString()+&quot;\ndataDir=&quot;+dataDir+&quot;\nlastSyncOC=&quot;+
-		getLast_sync_opencaching()+&quot;\ndistOC=&quot;+getDistOC()+&quot;\ndistGC=&quot;+getDistGC();
+		return &quot;Profile: Name=&quot; + name + &quot;\nCentre=&quot; + centre.toString() + &quot;\ndataDir=&quot; + dataDir + &quot;\nlastSyncOC=&quot; + getLast_sync_opencaching() + &quot;\ndistOC=&quot; + getDistOC() + &quot;\ndistGC=&quot; + getDistGC();
 	}
 
 	public void setSelectForAll(boolean selectStatus) {
@@ -570,7 +587,8 @@
 	public int numCachesInArea; // only valid after calling getSourroundingArea
 
 	public Area getSourroundingArea(boolean onlyOfSelected) {
-		if (cacheDB == null || cacheDB.size() == 0) return null;
+		if (cacheDB == null || cacheDB.size() == 0)
+			return null;
 		CacheHolder ch;
 		CWPoint topleft = null;
 		CWPoint bottomright = null;
@@ -584,15 +602,22 @@
 					tmpca.set(ch.getLatLon());
 					ch.pos = new CWPoint(tmpca);
 				}
-				if (ch.pos.isValid() ){ // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
+				if (ch.pos.isValid()) { // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
 					isAddi = ch.isAddiWpt();
-				if (!isAddi || (isAddi &amp;&amp; ch.mainCache != null &amp;&amp; ch.pos.getDistance(ch.mainCache.pos) &lt; 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -&gt; ignore it // &amp;&amp; ch.mainCache != null is only necessary because the data base may be corrupted
-						if (topleft == null) topleft = new CWPoint(ch.pos);
-						if (bottomright == null) bottomright = new CWPoint(ch.pos);
-						if (topleft.latDec &lt; ch.pos.latDec) topleft.latDec = ch.pos.latDec;
-						if (topleft.lonDec &gt; ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
-						if (bottomright.latDec &gt; ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
-						if (bottomright.lonDec &lt; ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
+					if (!isAddi || (isAddi &amp;&amp; ch.mainCache != null &amp;&amp; ch.pos.getDistance(ch.mainCache.pos) &lt; 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -&gt; ignore it //
+																														// &amp;&amp; ch.mainCache != null is only necessary because the data base may be corrupted
+						if (topleft == null)
+							topleft = new CWPoint(ch.pos);
+						if (bottomright == null)
+							bottomright = new CWPoint(ch.pos);
+						if (topleft.latDec &lt; ch.pos.latDec)
+							topleft.latDec = ch.pos.latDec;
+						if (topleft.lonDec &gt; ch.pos.lonDec)
+							topleft.lonDec = ch.pos.lonDec;
+						if (bottomright.latDec &gt; ch.pos.latDec)
+							bottomright.latDec = ch.pos.latDec;
+						if (bottomright.lonDec &lt; ch.pos.lonDec)
+							bottomright.lonDec = ch.pos.lonDec;
 						numCachesInArea++;
 					}
 				}
@@ -600,35 +625,38 @@
 		}
 		if (topleft != null &amp;&amp; bottomright != null)
 			return new Area(topleft, bottomright);
-		else return null;
+		else
+			return null;
 	}
 
 	/**
-	 *	Method to calculate bearing and distance of a cache in the index
-	 *	list.
-	 *	@see	CacheHolder
-	 *	@see	Extractor
+	 * Method to calculate bearing and distance of a cache in the index
+	 * list.
+	 * 
+	 * @see CacheHolder
+	 * @see Extractor
 	 */
-	public void updateBearingDistance(){
+	public void updateBearingDistance() {
 		CWPoint centerPoint = new CWPoint(Global.getPref().getCurCentrePt()); // Clone current centre to be sure
 		int anz = cacheDB.size();
 		CacheHolder ch;
 		// Jetzt durch die CacheDaten schleifen
-		while(--anz &gt;= 0){
+		while (--anz &gt;= 0) {
 			ch = cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 			ch.calcDistance(centerPoint);
 		}
 		// The following call is not very clean as it mixes UI with base classes
 		// However, calling it from here allows us to recenter the
 		// radar panel with only one call
-		if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
-	} //updateBearingDistance
+		if (Global.mainTab != null)
+			Global.mainTab.radarP.recenterRadar();
+	} // updateBearingDistance
 
 	/**
 	 * Method to build the reference between addi wpt
 	 * and main cache.
 	 */
-	public void buildReferences(){
+	public void buildReferences() {
 		CacheHolder ch;
 		MyComparer myComparer = new MyComparer();
 
@@ -752,6 +780,7 @@
 	/**
 	 * If &lt;code&gt;true&lt;/code&gt; then the cache list will only display the
 	 * caches that are result of a search.
+	 * 
 	 * @return &lt;code&gt;True&lt;/code&gt; if list should only display search results
 	 */
 	public boolean showSearchResult() {
@@ -761,10 +790,12 @@
 	/**
 	 * Sets parameter if cache list should only display the caches that are
 	 * results of a search.
-	 * @param showSearchResult &lt;code&gt;True&lt;/code&gt;: List should only display search
-	 * results.
+	 * 
+	 * @param showSearchResult
+	 *            &lt;code&gt;True&lt;/code&gt;: List should only display search
+	 *            results.
 	 */
-	public void setShowSearchResult(boolean showSearchResult){
+	public void setShowSearchResult(boolean showSearchResult) {
 		this.showSearchResult = showSearchResult;
 	}
 
@@ -787,31 +818,31 @@
 	}
 
 	public String getFilterStatus() {
-    	return currentFilter.getFilterStatus();
-    }
+		return currentFilter.getFilterStatus();
+	}
 
 	public void setFilterStatus(String filterStatus) {
 		this.notifyUnsavedChanges(filterStatus != this.getFilterStatus());
-    	this.currentFilter.setFilterStatus(filterStatus);
-    }
+		this.currentFilter.setFilterStatus(filterStatus);
+	}
 
 	public boolean getFilterUseRegexp() {
-    	return currentFilter.useRegexp();
-    }
+		return currentFilter.useRegexp();
+	}
 
 	public void setFilterUseRegexp(boolean useRegexp) {
 		this.notifyUnsavedChanges(useRegexp != this.getFilterUseRegexp());
-    	this.currentFilter.setUseRegexp(useRegexp);
-    }
+		this.currentFilter.setUseRegexp(useRegexp);
+	}
 
 	public boolean getFilterNoCoord() {
-    	return currentFilter.getFilterNoCoord();
-    }
+		return currentFilter.getFilterNoCoord();
+	}
 
 	public void setFilterNoCoord(boolean filterNoCoord) {
 		this.notifyUnsavedChanges(filterNoCoord != this.getFilterNoCoord());
-    	this.currentFilter.setFilterNoCoord(filterNoCoord);
-    }
+		this.currentFilter.setFilterNoCoord(filterNoCoord);
+	}
 
 	public String getLast_sync_opencaching() {
 		return last_sync_opencaching;
@@ -854,7 +885,8 @@
 	public int getGpxId() {
 		return Convert.toInt(gpxId);
 	}
-//
+
+	//
 	public void setMinDistGC(String minDistGC) {
 		this.notifyUnsavedChanges(!minDistGC.equals(this.minDistGC));
 		this.minDistGC = minDistGC;
@@ -893,23 +925,24 @@
 		this.notifyUnsavedChanges(!rCMPath.equals(this.relativeCustomMapsPath));
 		this.relativeCustomMapsPath = rCMPath;
 	}
+
 	/**
 	 * Returns the currently active FilterData object for the profile.
+	 * 
 	 * @return Object representing the setting of the filter
 	 */
 	public FilterData getCurrentFilter() {
-    	return currentFilter;
-    }
+		return currentFilter;
+	}
 
 	public void setCurrentFilter(FilterData currentFilter) {
-    	this.currentFilter = currentFilter;
-    }
+		this.currentFilter = currentFilter;
+	}
 
 	private class MyComparer implements ewe.util.Comparer {
 
 		public int compare(Object o1, Object o2) {
-			return ((CacheHolder) o1).getWayPoint().compareTo(
-			        ((CacheHolder) o2).getWayPoint());
+			return ((CacheHolder) o1).getWayPoint().compareTo(((CacheHolder) o2).getWayPoint());
 		}
 
 	}

Modified: trunk/src/CacheWolf/SafeXML.java
===================================================================
--- trunk/src/CacheWolf/SafeXML.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/SafeXML.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,155 +1,59 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
-*	A class to replace unsafe XML characters with characters that a user
-*	&quot;can read&quot;, and vice versa
-* 20061222: skg Modified cleanback to speed up the new index.xml reader
-*/
+ *	A class to replace unsafe XML characters with characters that a user
+ *	&quot;can read&quot;, and vice versa
+ * 20061222: skg Modified cleanback to speed up the new index.xml reader
+ */
 
 import ewe.util.Hashtable;
 
-public final class SafeXML{
+public final class SafeXML {
 	private static final char ENTITY_START = '&amp;';
 	private static final char ENTITY_END = ';';
-	
+
 	private final static Hashtable iso2htmlMappings = new Hashtable(300);
 	static {
 		final String[] mappingArray = new String[] {
-				&quot;&apos;&quot;,   &quot;'&quot;,		// Added 20061227 - not a valid HTML entity but used in XML
-				&quot;&quot;&quot;,   &quot;\&quot;&quot;,
-				&quot;&amp;&quot;,    &quot;&amp;&quot;,
-				&quot;&lt;&quot;,     &quot;&lt;&quot;,
-				&quot;&gt;&quot;,     &quot;&gt;&quot;,
-				&quot;&nbsp;&quot;,   &quot; &quot;,
-				&quot;&iexcl;&quot;,  &quot;&#161;&quot;,
-				&quot;&cent;&quot;,   &quot;&#162;&quot;,
-				&quot;&pound;&quot;,  &quot;&#163;&quot;,
-				&quot;&curren;&quot;, &quot;&#164;&quot;,
-				&quot;&yen;&quot;,    &quot;&#165;&quot;,
-				&quot;&brvbar;&quot;, &quot;&#166;&quot;,
-				&quot;&sect;&quot;,   &quot;&#167;&quot;,
-				&quot;&uml;&quot;,    &quot;&#168;&quot;,
-				&quot;&copy;&quot;,   &quot;&#169;&quot;,
-				&quot;&ordf;&quot;,   &quot;&#170;&quot;,
-				&quot;&laquo;&quot;,  &quot;&#171;&quot;,
-				&quot;&not;&quot;,    &quot;&#172;&quot;,
-				&quot;&shy;&quot;,    &quot;&#173;&quot;,
-				&quot;&reg;&quot;,    &quot;&#174;&quot;,
-				&quot;&macr;&quot;,   &quot;&#175;&quot;,
-				&quot;&deg;&quot;,    &quot;&#176;&quot;,
-				&quot;&plusmn;&quot;, &quot;&#177;&quot;,
-				&quot;&amp;sup2;&quot;,   &quot;&#178;&quot;,
-				&quot;&amp;sup3;&quot;,   &quot;&#179;&quot;,
-				&quot;&acute;&quot;,  &quot;&#180;&quot;,
-				&quot;&micro;&quot;,  &quot;&#181;&quot;,
-				&quot;&para;&quot;,   &quot;&#182;&quot;,
-				&quot;&middot;&quot;, &quot;&#183;&quot;,
-				&quot;&cedil;&quot;,  &quot;&#184;&quot;,
-				&quot;&amp;sup1;&quot;,   &quot;&#185;&quot;,
-				&quot;&ordm;&quot;,   &quot;&#186;&quot;,
-				&quot;&raquo;&quot;,  &quot;&#187;&quot;,
-				&quot;&amp;frac14;&quot;, &quot;&#188;&quot;,
-				&quot;&amp;frac12;&quot;, &quot;&#189;&quot;,
-				&quot;&amp;frac34;&quot;, &quot;&#190;&quot;,
-				&quot;&iquest;&quot;, &quot;&#191;&quot;,
-				&quot;&Agrave;&quot;, &quot;&#192;&quot;,
-				&quot;&Aacute;&quot;, &quot;&#193;&quot;,
-				&quot;&Acirc;&quot;,  &quot;&#194;&quot;,
-				&quot;&Atilde;&quot;, &quot;&#195;&quot;,
-				&quot;&Auml;&quot;,   &quot;&#196;&quot;,
-				&quot;&Aring;&quot;,  &quot;&#197;&quot;,
-				&quot;&AElig;&quot;,  &quot;&#198;&quot;,
-				&quot;&Ccedil;&quot;, &quot;&#199;&quot;,
-				&quot;&Egrave;&quot;, &quot;&#200;&quot;,
-				&quot;&Eacute;&quot;, &quot;&#201;&quot;,
-				&quot;&Ecirc;&quot;,  &quot;&#202;&quot;,
-				&quot;&Euml;&quot;,   &quot;&#203;&quot;,
-				&quot;&Igrave;&quot;, &quot;&#204;&quot;,
-				&quot;&Iacute;&quot;, &quot;&#205;&quot;,
-				&quot;&Icirc;&quot;,  &quot;&#206;&quot;,
-				&quot;&Iuml;&quot;,   &quot;&#207;&quot;,
-				&quot;&ETH;&quot;,    &quot;&#208;&quot;,
-				&quot;&Ntilde;&quot;, &quot;&#209;&quot;,
-				&quot;&Ograve;&quot;, &quot;&#210;&quot;,
-				&quot;&Oacute;&quot;, &quot;&#211;&quot;,
-				&quot;&Ocirc;&quot;,  &quot;&#212;&quot;,
-				&quot;&Otilde;&quot;, &quot;&#213;&quot;,
-				&quot;&Ouml;&quot;,   &quot;&#214;&quot;,
-				&quot;&times;&quot;,  &quot;&#215;&quot;,
-				&quot;&Oslash;&quot;, &quot;&#216;&quot;,
-				&quot;&Ugrave;&quot;, &quot;&#217;&quot;,
-				&quot;&Uacute;&quot;, &quot;&#218;&quot;,
-				&quot;&Ucirc;&quot;,  &quot;&#219;&quot;,
-				&quot;&Uuml;&quot;,   &quot;&#220;&quot;,
-				&quot;&Yacute;&quot;, &quot;&#221;&quot;,
-				&quot;&THORN;&quot;,  &quot;&#222;&quot;,
-				&quot;&szlig;&quot;,  &quot;&#223;&quot;,
-				&quot;&agrave;&quot;, &quot;&#224;&quot;,
-				&quot;&aacute;&quot;, &quot;&#225;&quot;,
-				&quot;&acirc;&quot;,  &quot;&#226;&quot;,
-				&quot;&atilde;&quot;, &quot;&#227;&quot;,
-				&quot;&auml;&quot;,   &quot;&#228;&quot;,
-				&quot;&aring;&quot;,  &quot;&#229;&quot;,
-				&quot;&aelig;&quot;,  &quot;&#230;&quot;,
-				&quot;&ccedil;&quot;, &quot;&#231;&quot;,
-				&quot;&egrave;&quot;, &quot;&#232;&quot;,
-				&quot;&eacute;&quot;, &quot;&#233;&quot;,
-				&quot;&ecirc;&quot;,  &quot;&#234;&quot;,
-				&quot;&euml;&quot;,   &quot;&#235;&quot;,
-				&quot;&igrave;&quot;, &quot;&#236;&quot;,
-				&quot;&iacute;&quot;, &quot;&#237;&quot;,
-				&quot;&icirc;&quot;,  &quot;&#238;&quot;,
-				&quot;&iuml;&quot;,   &quot;&#239;&quot;,
-				&quot;&eth;&quot;,    &quot;&#240;&quot;,
-				&quot;&ntilde;&quot;, &quot;&#241;&quot;,
-				&quot;&ograve;&quot;, &quot;&#242;&quot;,
-				&quot;&oacute;&quot;, &quot;&#243;&quot;,
-				&quot;&ocirc;&quot;,  &quot;&#244;&quot;,
-				&quot;&otilde;&quot;, &quot;&#245;&quot;,
-				&quot;&ouml;&quot;,   &quot;&#246;&quot;,
-				&quot;&divide;&quot;, &quot;&#247;&quot;,
-				&quot;&oslash;&quot;, &quot;&#248;&quot;,
-				&quot;&ugrave;&quot;, &quot;&#249;&quot;,
-				&quot;&uacute;&quot;, &quot;&#250;&quot;,
-				&quot;&ucirc;&quot;,  &quot;&#251;&quot;,
-				&quot;&uuml;&quot;,   &quot;&#252;&quot;,
-				&quot;&yacute;&quot;, &quot;&#253;&quot;,
-				&quot;&thorn;&quot;,  &quot;&#254;&quot;,
-				&quot;&yuml;&quot;,   &quot;&#255;&quot;,
-				&quot;&ndash;&quot;,  &quot;&#150;&quot;
-				};
+				&quot;&apos;&quot;,
+				&quot;'&quot;, // Added 20061227 - not a valid HTML entity but used in XML
+				&quot;&quot;&quot;, &quot;\&quot;&quot;, &quot;&amp;&quot;, &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&gt;&quot;, &quot;&nbsp;&quot;, &quot; &quot;, &quot;&iexcl;&quot;, &quot;&#161;&quot;, &quot;&cent;&quot;, &quot;&#162;&quot;, &quot;&pound;&quot;, &quot;&#163;&quot;, &quot;&curren;&quot;, &quot;&#164;&quot;, &quot;&yen;&quot;, &quot;&#165;&quot;, &quot;&brvbar;&quot;, &quot;&#166;&quot;, &quot;&sect;&quot;, &quot;&#167;&quot;, &quot;&uml;&quot;, &quot;&#168;&quot;, &quot;&copy;&quot;, &quot;&#169;&quot;, &quot;&ordf;&quot;, &quot;&#170;&quot;, &quot;&laquo;&quot;,
+				&quot;&#171;&quot;, &quot;&not;&quot;, &quot;&#172;&quot;, &quot;&shy;&quot;, &quot;&#173;&quot;, &quot;&reg;&quot;, &quot;&#174;&quot;, &quot;&macr;&quot;, &quot;&#175;&quot;, &quot;&deg;&quot;, &quot;&#176;&quot;, &quot;&plusmn;&quot;, &quot;&#177;&quot;, &quot;&amp;sup2;&quot;, &quot;&#178;&quot;, &quot;&amp;sup3;&quot;, &quot;&#179;&quot;, &quot;&acute;&quot;, &quot;&#180;&quot;, &quot;&micro;&quot;, &quot;&#181;&quot;, &quot;&para;&quot;, &quot;&#182;&quot;, &quot;&middot;&quot;, &quot;&#183;&quot;, &quot;&cedil;&quot;, &quot;&#184;&quot;, &quot;&amp;sup1;&quot;, &quot;&#185;&quot;, &quot;&ordm;&quot;, &quot;&#186;&quot;,
+				&quot;&raquo;&quot;, &quot;&#187;&quot;, &quot;&amp;frac14;&quot;, &quot;&#188;&quot;, &quot;&amp;frac12;&quot;, &quot;&#189;&quot;, &quot;&amp;frac34;&quot;, &quot;&#190;&quot;, &quot;&iquest;&quot;, &quot;&#191;&quot;, &quot;&Agrave;&quot;, &quot;&#192;&quot;, &quot;&Aacute;&quot;, &quot;&#193;&quot;, &quot;&Acirc;&quot;, &quot;&#194;&quot;, &quot;&Atilde;&quot;, &quot;&#195;&quot;, &quot;&Auml;&quot;, &quot;&#196;&quot;, &quot;&Aring;&quot;, &quot;&#197;&quot;, &quot;&AElig;&quot;, &quot;&#198;&quot;, &quot;&Ccedil;&quot;, &quot;&#199;&quot;, &quot;&Egrave;&quot;, &quot;&#200;&quot;,
+				&quot;&Eacute;&quot;, &quot;&#201;&quot;, &quot;&Ecirc;&quot;, &quot;&#202;&quot;, &quot;&Euml;&quot;, &quot;&#203;&quot;, &quot;&Igrave;&quot;, &quot;&#204;&quot;, &quot;&Iacute;&quot;, &quot;&#205;&quot;, &quot;&Icirc;&quot;, &quot;&#206;&quot;, &quot;&Iuml;&quot;, &quot;&#207;&quot;, &quot;&ETH;&quot;, &quot;&#208;&quot;, &quot;&Ntilde;&quot;, &quot;&#209;&quot;, &quot;&Ograve;&quot;, &quot;&#210;&quot;, &quot;&Oacute;&quot;, &quot;&#211;&quot;, &quot;&Ocirc;&quot;, &quot;&#212;&quot;, &quot;&Otilde;&quot;, &quot;&#213;&quot;, &quot;&Ouml;&quot;, &quot;&#214;&quot;, &quot;&times;&quot;,
+				&quot;&#215;&quot;, &quot;&Oslash;&quot;, &quot;&#216;&quot;, &quot;&Ugrave;&quot;, &quot;&#217;&quot;, &quot;&Uacute;&quot;, &quot;&#218;&quot;, &quot;&Ucirc;&quot;, &quot;&#219;&quot;, &quot;&Uuml;&quot;, &quot;&#220;&quot;, &quot;&Yacute;&quot;, &quot;&#221;&quot;, &quot;&THORN;&quot;, &quot;&#222;&quot;, &quot;&szlig;&quot;, &quot;&#223;&quot;, &quot;&agrave;&quot;, &quot;&#224;&quot;, &quot;&aacute;&quot;, &quot;&#225;&quot;, &quot;&acirc;&quot;, &quot;&#226;&quot;, &quot;&atilde;&quot;, &quot;&#227;&quot;, &quot;&auml;&quot;, &quot;&#228;&quot;, &quot;&aring;&quot;, &quot;&#229;&quot;,
+				&quot;&aelig;&quot;, &quot;&#230;&quot;, &quot;&ccedil;&quot;, &quot;&#231;&quot;, &quot;&egrave;&quot;, &quot;&#232;&quot;, &quot;&eacute;&quot;, &quot;&#233;&quot;, &quot;&ecirc;&quot;, &quot;&#234;&quot;, &quot;&euml;&quot;, &quot;&#235;&quot;, &quot;&igrave;&quot;, &quot;&#236;&quot;, &quot;&iacute;&quot;, &quot;&#237;&quot;, &quot;&icirc;&quot;, &quot;&#238;&quot;, &quot;&iuml;&quot;, &quot;&#239;&quot;, &quot;&eth;&quot;, &quot;&#240;&quot;, &quot;&ntilde;&quot;, &quot;&#241;&quot;, &quot;&ograve;&quot;, &quot;&#242;&quot;, &quot;&oacute;&quot;, &quot;&#243;&quot;,
+				&quot;&ocirc;&quot;, &quot;&#244;&quot;, &quot;&otilde;&quot;, &quot;&#245;&quot;, &quot;&ouml;&quot;, &quot;&#246;&quot;, &quot;&divide;&quot;, &quot;&#247;&quot;, &quot;&oslash;&quot;, &quot;&#248;&quot;, &quot;&ugrave;&quot;, &quot;&#249;&quot;, &quot;&uacute;&quot;, &quot;&#250;&quot;, &quot;&ucirc;&quot;, &quot;&#251;&quot;, &quot;&uuml;&quot;, &quot;&#252;&quot;, &quot;&yacute;&quot;, &quot;&#253;&quot;, &quot;&thorn;&quot;, &quot;&#254;&quot;, &quot;&yuml;&quot;, &quot;&#255;&quot;, &quot;&ndash;&quot;, &quot;&#150;&quot; };
 		for (int i = 0; i &lt; mappingArray.length; i = i + 2) {
-			iso2htmlMappings.put( mappingArray[i], mappingArray[i+1]);
+			iso2htmlMappings.put(mappingArray[i], mappingArray[i + 1]);
 		}
 	}
-		
-	
-	
+
 	/**
 	 * Converts a &lt;code&gt;String&lt;/code&gt; containing HTML entities to
 	 * a &lt;code&gt;String&lt;/code&gt; containing only ISO8859-1 characters.
@@ -158,47 +62,48 @@
 	 * 8859-1 table by Martin Ramsch&lt;/a&gt;.
 	 * 
 	 * @author &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ey at inweb.de</A>&quot;&gt;Christian Ey&lt;/a&gt;
-	 *
+	 * 
 	 * @version 1.0
-	 * @param htmlString The &lt;code&gt;String&lt;/code&gt; containing HTML
-	 * 	entities
+	 * @param htmlString
+	 *            The &lt;code&gt;String&lt;/code&gt; containing HTML
+	 *            entities
 	 * @return A &lt;code&gt;String&lt;/code&gt; containing only ISO8859-1
-	 * 	characters
+	 *         characters
 	 */
-	public final static String cleanback( String htmlString) {
+	public final static String cleanback(String htmlString) {
 		int indexStart;
 		// return immediately if string is null or does not contain &amp;
-		if (htmlString != null &amp;&amp; (indexStart = htmlString.indexOf( ENTITY_START))&gt;=0) {
+		if (htmlString != null &amp;&amp; (indexStart = htmlString.indexOf(ENTITY_START)) &gt;= 0) {
 			// copy everything from the beginning to entity start into buffer
-			StringBuffer isoBuffer = new StringBuffer( htmlString.substring( 0, indexStart));
+			StringBuffer isoBuffer = new StringBuffer(htmlString.substring(0, indexStart));
 			while (indexStart &gt;= 0) {
-				int indexEnd = htmlString.indexOf( ENTITY_END, indexStart + 1);
+				int indexEnd = htmlString.indexOf(ENTITY_END, indexStart + 1);
 				if (indexEnd &gt;= 0) {
-					int alternativeStart = htmlString.indexOf( ENTITY_START, indexStart + 1);
+					int alternativeStart = htmlString.indexOf(ENTITY_START, indexStart + 1);
 					if ((alternativeStart &gt; indexStart) &amp;&amp; (alternativeStart &lt; indexEnd)) {
 						// a second index start is found inbetween current index start
 						// and index end
-						
+
 						// flush the html string inbetween
-						isoBuffer.append( htmlString.substring( indexStart, alternativeStart));
-						
+						isoBuffer.append(htmlString.substring(indexStart, alternativeStart));
+
 						// use the second index start and loop again
 						indexStart = alternativeStart;
 					} else {
-						String entity = htmlString.substring( indexStart, indexEnd + 1);
-						appendEntityAsIsoChar(entity, isoBuffer); 
-						indexStart = htmlString.indexOf( ENTITY_START, indexEnd + 1);
+						String entity = htmlString.substring(indexStart, indexEnd + 1);
+						appendEntityAsIsoChar(entity, isoBuffer);
+						indexStart = htmlString.indexOf(ENTITY_START, indexEnd + 1);
 						if (indexStart &gt;= 0) {
 							// another entity start detected, flush the html string inbetween
-							isoBuffer.append( htmlString.substring( indexEnd + 1, indexStart));
+							isoBuffer.append(htmlString.substring(indexEnd + 1, indexStart));
 						} else {
 							// no further entity start detected, flush rest of html string
-							isoBuffer.append( htmlString.substring( indexEnd + 1));
+							isoBuffer.append(htmlString.substring(indexEnd + 1));
 						}
 					}
 				} else {
 					// entity start without matching entity end detected, ignore gracefully
-					isoBuffer.append( htmlString.substring( indexStart));
+					isoBuffer.append(htmlString.substring(indexStart));
 					break;
 				}
 			}
@@ -211,17 +116,18 @@
 
 	private final static void appendEntityAsIsoChar(String entity, StringBuffer addto) {
 		if (entity.startsWith(&quot;&amp;#&quot;)) {
-			try{
-				if (entity.charAt(2)== 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
-					addto.append((char)Integer.parseInt(entity.substring(3, entity.length()-1), 16)); 
-				else // number is decimal
-					addto.append((char)Integer.parseInt(entity.substring(2, entity.length()-1)));
+			try {
+				if (entity.charAt(2) == 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
+					addto.append((char) Integer.parseInt(entity.substring(3, entity.length() - 1), 16));
+				else
+					// number is decimal
+					addto.append((char) Integer.parseInt(entity.substring(2, entity.length() - 1)));
 			} catch (NumberFormatException e) {
 				addto.append(entity); // not a valid number, insert original text
 			}
 
 		} // number format exception
-		else { // entity with a name like &quot;&amp;quot&quot;						
+		else { // entity with a name like &quot;&amp;quot&quot;
 			String isoCharacter = (String) iso2htmlMappings.get(entity);
 			if (isoCharacter != null) {
 				// insert iso character instead of html entity
@@ -232,127 +138,136 @@
 			}
 		}
 	}
-	
+
 	/**
-     * convert a single char to its equivalent HTML entity. Ordinary chars are
-     * not changed. 160 -&gt; &nbsp;
-     *
-     * @param c Char to convert
-     *
-     * @return equivalent string eg. &amp;, null means leave char as is.
-     */
-    private final static String charToEntity( char c )
-        {
-        switch ( c ) {
-	        case '&quot;' : return &quot;&quot;&quot;;
-	        case '&amp;' : return &quot;&amp;&quot;;
-	        case '&lt;' : return &quot;&lt;&quot;;
-	        case '&gt;' : return &quot;&gt;&quot;;
-	        case '\'': return &quot;&apos;&quot;;
-            default :
-                if ( c &lt; 127 ) {
-                    // leave alone as equivalent string.
-                    return null;
-                    // faster than String.valueOf( c ).intern();
-                } else {
-                    // use the &amp;#nnn; form
-                    return &quot;&amp;#&quot; + Integer.toString( c ) + &quot;;&quot;;
-                }
-            } // end switch
-        } // end charToEntity
+	 * convert a single char to its equivalent HTML entity. Ordinary chars are
+	 * not changed. 160 -&gt; &nbsp;
+	 * 
+	 * @param c
+	 *            Char to convert
+	 * 
+	 * @return equivalent string eg. &amp;, null means leave char as is.
+	 */
+	private final static String charToEntity(char c) {
+		switch (c) {
+		case '&quot;':
+			return &quot;&quot;&quot;;
+		case '&amp;':
+			return &quot;&amp;&quot;;
+		case '&lt;':
+			return &quot;&lt;&quot;;
+		case '&gt;':
+			return &quot;&gt;&quot;;
+		case '\'':
+			return &quot;&apos;&quot;;
+		default:
+			if (c &lt; 127) {
+				// leave alone as equivalent string.
+				return null;
+				// faster than String.valueOf( c ).intern();
+			} else {
+				// use the &amp;#nnn; form
+				return &quot;&amp;#&quot; + Integer.toString(c) + &quot;;&quot;;
+			}
+		} // end switch
+	} // end charToEntity
 
-    /**
-     * Converts text to HTML by quoting dangerous characters. Text must not
-     * already contain entities. e.g. &quot; ==&gt; &quot; &lt; ==&gt; &lt; ordinary text
-     * passes unchanged. Does not convert space to &nbsp;
-     *
-     * @param text raw text to be processed. Must not be null.
-     *
-     * @return translated text, or null if input is null.
-     */
-    public final static String clean( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( originalTextLength * 110 / 100 );
-        int charsToAppend = 0;
-        for ( int i = 0; i &lt; originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = charToEntity( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
+	/**
+	 * Converts text to HTML by quoting dangerous characters. Text must not
+	 * already contain entities. e.g. &quot; ==&gt; &quot; &lt; ==&gt; &lt; ordinary text
+	 * passes unchanged. Does not convert space to &nbsp;
+	 * 
+	 * @param text
+	 *            raw text to be processed. Must not be null.
+	 * 
+	 * @return translated text, or null if input is null.
+	 */
+	public final static String clean(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(originalTextLength * 110 / 100);
+		int charsToAppend = 0;
+		for (int i = 0; i &lt; originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = charToEntity(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
 
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
-	
-	
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
 	/**
 	 * Converts a data string to something that is safe to use inside
 	 * an XML file (like prefs.xml) - entities like &amp; are *NOT*
 	 * valid XML unless declared specially, so we must use the numerical
 	 * values here.
-	 *
-	 * @param src (String) raw text to be processed
-	 *
+	 * 
+	 * @param src
+	 *            (String) raw text to be processed
+	 * 
 	 * @return (String) translated text, or null if input is null
 	 */
-	public final static String cleanGPX(String str){
-		String dummy = STRreplace.replace(str, &quot;&amp;&quot;,&quot;&amp;&quot;);
-		//&quot;&amp;#&quot; --&gt; &quot;&amp;#&quot;); //Darstellung Umlaute etc : siehe  <A HREF="http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796">http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796</A>
+	public final static String cleanGPX(String str) {
+		String dummy = STRreplace.replace(str, &quot;&amp;&quot;, &quot;&amp;&quot;);
+		// &quot;&amp;#&quot; --&gt; &quot;&amp;#&quot;); //Darstellung Umlaute etc : siehe <A HREF="http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796">http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796</A>
 		// aber so etwas nicht &quot;&amp;#entry15063&quot; --&gt; !!not!! &quot;&amp;#entry15063&quot; (Cache GCPB5P export -&gt; gpx, import -&gt; mapsource)
-		int pos=0;
-		while (pos&gt;-1) {
-			pos=dummy.indexOf(&quot;&amp;#&quot;,pos);
-			int pos1=dummy.indexOf(&quot;;&quot;,pos+6);
-			int k = pos1-pos; // wann kommt das ; als Ende eines numerischen entities?
-			if (pos&gt;-1) {
-				if ( k &lt; 12) {
-					String s = dummy.substring(pos+6,pos+8).toLowerCase();
-					char c=s.charAt(0);
-					char c1=s.charAt(1);
-					if ((c=='x' &amp;&amp; ((c1&gt;='0' &amp;&amp; c1&lt;='9') || (c1&gt;='a' &amp;&amp; c1&lt;='f'))) || (c&gt;='0' &amp;&amp; c&lt;='9')) {
-						dummy=dummy.substring(0, pos+1) + dummy.substring(pos+5, dummy.length());
+		int pos = 0;
+		while (pos &gt; -1) {
+			pos = dummy.indexOf(&quot;&amp;#&quot;, pos);
+			int pos1 = dummy.indexOf(&quot;;&quot;, pos + 6);
+			int k = pos1 - pos; // wann kommt das ; als Ende eines numerischen entities?
+			if (pos &gt; -1) {
+				if (pos1 &gt; -1) {
+					if (k &lt; 12) {
+						String s = dummy.substring(pos + 6, pos + 8).toLowerCase();
+						char c = s.charAt(0);
+						char c1 = s.charAt(1);
+						if ((c == 'x' &amp;&amp; ((c1 &gt;= '0' &amp;&amp; c1 &lt;= '9') || (c1 &gt;= 'a' &amp;&amp; c1 &lt;= 'f'))) || (c &gt;= '0' &amp;&amp; c &lt;= '9')) {
+							dummy = dummy.substring(0, pos + 1) + dummy.substring(pos + 5, dummy.length());
+						}
 					}
 				}
 				pos++;
 			}
 		}
-		dummy = STRreplace.replace(dummy, &quot;&amp;amp;&quot;,&quot;&amp;&quot;); //falls schon &amp; im str war 
-			
+		dummy = STRreplace.replace(dummy, &quot;&amp;amp;&quot;, &quot;&amp;&quot;); // falls schon &amp; im str war
+
 		dummy = STRreplace.replace(dummy, &quot;&lt;&quot;, &quot;&lt;&quot;);
 		dummy = STRreplace.replace(dummy, &quot;&gt;&quot;, &quot;&gt;&quot;);
 		dummy = STRreplace.replace(dummy, &quot;\&quot;&quot;, &quot;&quot;&quot;);
-		dummy = STRreplace.replace(dummy, &quot;'&quot;,&quot;&apos;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;'&quot;, &quot;&apos;&quot;);
 		// why
-		dummy = STRreplace.replace(dummy, &quot;\u0004&quot;,&quot;&quot;);
-		// this means changing content, 
+		dummy = STRreplace.replace(dummy, &quot;\u0004&quot;, &quot;&quot;);
+		// this means changing content,
 		// but it is the easiest way of avoiding ]]&gt; to be interpreted as endmark of CDATA-section
-		dummy = STRreplace.replace(dummy, &quot;]]&gt;&quot;,&quot;]] &gt;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;]]&gt;&quot;, &quot;]] &gt;&quot;);
 		// \ in gpx is not imported by mapsource, basecamp, garmin?...(there is no replacement)
-		dummy = STRreplace.replace(dummy, &quot;\\&quot;,&quot;BkSlsh;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;\\&quot;, &quot;BkSlsh;&quot;);
 
 		return dummy;
 	}
+
 	public final static String strxmlencode(boolean src) {
 		/* bools are always safe */
 		return (src ? &quot;true&quot; : &quot;false&quot;);
 	}
+
 	public final static String strxmlencode(int src) {
 		/* numbers are always safe */
 		return (Integer.toString(src));

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -255,11 +255,10 @@
 				dest = n;
 			}
 			char c = what[i];
-			// removed || c == '&amp;'
 			// added || c == '$' || c == '/' || c == ','
 			if (spaceToPlus &amp;&amp; c == ' ')
 				c = '+';
-			else if (c &lt;= ' ' || c &gt;= 127 || c == '+' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/' || c == ',') {
+			else if (c &lt;= ' ' || c &gt;= 127 || c == '+' || c == '&amp;' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/' || c == ',') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
 				dest[d++] = hex.charAt(c &amp; 0xf);

Modified: trunk/src/CacheWolf/imp/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/GPXImporter.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/imp/GPXImporter.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,32 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-import com.stevesoft.ewe_pat.Regex;
-
 import CacheWolf.Attribute;
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
@@ -49,6 +47,9 @@
 import CacheWolf.UrlFetcher;
 import CacheWolf.imp.SpiderGC.SpiderProperties;
 import CacheWolf.utils.FileBugfix;
+
+import com.stevesoft.ewe_pat.Regex;
+
 import ewe.io.File;
 import ewe.io.FileInputStream;
 import ewe.io.IOException;
@@ -66,12 +67,12 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
-*	Class to import Data from an GPX File. If cache data exists, the data from 
-*	the GPX-File is ignored.
-*	Class ID = 4000
-*/
+ * Class to import Data from an GPX File. If cache data exists, the data from
+ * the GPX-File is ignored.
+ * Class ID = 4000
+ */
 public class GPXImporter extends MinML {
-	
+
 	static Preferences pref;
 	Profile profile;
 	CacheDB cacheDB;
@@ -80,7 +81,7 @@
 	boolean inWpt, inCache, inLogs, inBug;
 	public XMLElement document;
 	private Vector files = new Vector();
-	private boolean debugGPX = false; 
+	private boolean debugGPX = false;
 	InfoBox infB;
 	boolean spiderOK = true;
 	boolean doSpider = false;
@@ -99,15 +100,14 @@
 	private String attID;
 	private String attInc;
 
-	public GPXImporter(Preferences p, Profile prof, String f )
-	{
-		profile=prof;
+	public GPXImporter(Preferences p, Profile prof, String f) {
+		profile = prof;
 		pref = p;
 		cacheDB = profile.cacheDB;
-		//file = f;
+		// file = f;
 		files.add(f);
 		saveDir = profile.dataDir;
-		//msgA = msgArea;
+		// msgA = msgArea;
 		inWpt = false;
 		inCache = false;
 		inLogs = false;
@@ -115,17 +115,19 @@
 		doitHow = DOIT_ASK;
 	}
 
-	public void doIt(int how){
+	public void doIt(int how) {
 		doitHow = how;
 		Filter flt = new Filter();
-		boolean wasFiltered = (profile.getFilterActive()==Filter.FILTER_ACTIVE);
+		boolean wasFiltered = (profile.getFilterActive() == Filter.FILTER_ACTIVE);
 		flt.clearFilter();
-		try{
+		try {
 			ewe.io.Reader r;
 			String file;
 			if (how == DOIT_ASK) {
-				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
-				if (options.execute() == FormBase.IDCANCEL) { return; }
+				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510, &quot;Spider Options&quot;), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ISGC);
+				if (options.execute() == FormBase.IDCANCEL) {
+					return;
+				}
 				doSpider = options.imagesCheckBox.getState();
 				options.close(0);
 			} else if (how == DOIT_NOSPOILER) {
@@ -139,23 +141,22 @@
 			} else {
 				doitHow = DOIT_NOSPOILER;
 			}
-			
+
 			Vm.showWait(true);
-			for (int i=0; i&lt;files.size();i++){
-				//Test for zip.file
-				file = (String)files.get(i);
-				if (file.indexOf(&quot;.zip&quot;) &gt; 0){
-					ZipFile zif = new ZipFile (file);
+			for (int i = 0; i &lt; files.size(); i++) {
+				// Test for zip.file
+				file = (String) files.get(i);
+				if (file.indexOf(&quot;.zip&quot;) &gt; 0) {
+					ZipFile zif = new ZipFile(file);
 					ZipEntry zipEnt;
 					Enumeration zipEnum = zif.entries();
 					// there could be more than one file in the archive
-					while (zipEnum.hasMoreElements())
-					{
+					while (zipEnum.hasMoreElements()) {
 						zipEnt = (ZipEntry) zipEnum.nextElement();
 						// skip over PRC-files
-						if (zipEnt.getName().endsWith(&quot;gpx&quot;)){
+						if (zipEnt.getName().endsWith(&quot;gpx&quot;)) {
 							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+							infB = new InfoBox(zipEnt.toString(), (MyLocale.getMsg(4000, &quot;Loaded caches: &quot;) + zaehlerGel));
 							infB.exec();
 							if (r.read() != 65279)
 								r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
@@ -165,11 +166,10 @@
 						}
 					}
 					zif.close();
-				}
-				else {
+				} else {
 					FileInputStream rFIS = new ewe.io.FileInputStream(file);
 					r = new ewe.io.InputStreamReader(rFIS);
-					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+					infB = new InfoBox(&quot;Info&quot;, (MyLocale.getMsg(4000, &quot;Loaded caches: &quot;) + zaehlerGel));
 					infB.show();
 					if (r.read() != 65279) {
 						r.close();
@@ -182,47 +182,60 @@
 					rFIS.close();
 					infB.close(0);
 				}
-				// save Index 
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				// save Index
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				infB.close(0);
 			}
-				Vm.showWait(false);
-			}catch(Exception e){
-				pref.log(&quot;[GPXImporter:DoIt]&quot;,e,true);
-				Vm.showWait(false);
+			Vm.showWait(false);
+		} catch (Exception e) {
+			if (holder.getWayPoint().length() &gt; 0) {
+				pref.log(&quot;[GPXImporter:DoIt] &quot; + holder.getWayPoint() + &quot; LogID=&quot; + logId, e, true);
+			} else {
+				pref.log(&quot;[GPXImporter:DoIt] &quot; + holder.getLatLon() + &quot; LogID=&quot; + logId, e, true);
 			}
-		if(wasFiltered){
+			infB.close(0);
+			Vm.showWait(false);
+		}
+		if (wasFiltered) {
 			flt.setFilter();
 			flt.doFilter();
 		}
 	}
-	public void startElement(String name, AttributeList atts){
-		strBuf=new StringBuffer(300);
-		if(infB.isClosed)  return;
-		if (name.equals(&quot;gpx&quot;)){
+
+	public void startElement(String name, AttributeList atts) {
+		strBuf = new StringBuffer(300);
+		if (infB.isClosed)
+			return;
+		if (name.equals(&quot;gpx&quot;)) {
 			// check for opencaching
-			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;)&gt; 0) fromOC = true;
-			else fromOC = false;
-			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;)) fromTC = true;
-			else fromTC = false;
+			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;) &gt; 0)
+				fromOC = true;
+			else
+				fromOC = false;
+			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;))
+				fromTC = true;
+			else
+				fromTC = false;
 
-			// if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
+			// if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001,
+			// &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
 			zaehlerGel = 0;
 		}
 		if (name.equals(&quot;wpt&quot;)) {
 			holder = new CacheHolder();
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
+			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;)));
 			holder.setLatLon(holder.pos.toString());
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
 			nameFound = false;
 			zaehlerGel++;
-			infB.setInfo(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel);
+			infB.setInfo(MyLocale.getMsg(4000, &quot;Loaded caches: &quot;) + zaehlerGel);
+			logId = &quot;&quot;;
 			return;
 		}
-		
-		if (name.equals(&quot;link&quot;)&amp;&amp; inWpt){
+
+		if (name.equals(&quot;link&quot;) &amp;&amp; inWpt) {
 			holder.getCacheDetails(false).URL = atts.getValue(&quot;href&quot;);
 			return;
 		}
@@ -231,7 +244,7 @@
 			inCache = true;
 			holder.setAvailable(atts.getValue(&quot;available&quot;).equals(&quot;True&quot;));
 			holder.setArchived(atts.getValue(&quot;archived&quot;).equals(&quot;True&quot;));
-			// OC now has GC - Format,  get CacheID -- missing p.ex. on GcTour gpx
+			// OC now has GC - Format, get CacheID -- missing p.ex. on GcTour gpx
 			for (int i = 0; i &lt; atts.getLength(); i++) {
 				if (atts.getName(i).equals(&quot;id&quot;)) {
 					holder.setOcCacheID(atts.getValue(&quot;id&quot;));
@@ -241,10 +254,10 @@
 			return;
 		}
 		// OC
-		if (name.equals(&quot;geocache&quot;)|| name.equals(&quot;cache&quot;)) {
+		if (name.equals(&quot;geocache&quot;) || name.equals(&quot;cache&quot;)) {
 			boolean available = false;
-			boolean archived  = false;
-			inCache=true;
+			boolean archived = false;
+			inCache = true;
 			// get CacheID -- missing p.ex. on GcTour gpx
 			for (int i = 0; i &lt; atts.getLength(); i++) {
 				if (atts.getName(i).equals(&quot;id&quot;)) {
@@ -254,25 +267,28 @@
 			}
 			// get status
 			String status = atts.getValue(&quot;status&quot;);
-			if (status.equals(&quot;Available&quot;)) available = true;
-			else if (status.equals(&quot;Unavailable&quot;)) available = false;
-			else if (status.equals(&quot;Draft&quot;)) available = false;
-			else if (status.equals(&quot;Archived&quot;)) archived = true;
+			if (status.equals(&quot;Available&quot;))
+				available = true;
+			else if (status.equals(&quot;Unavailable&quot;))
+				available = false;
+			else if (status.equals(&quot;Draft&quot;))
+				available = false;
+			else if (status.equals(&quot;Archived&quot;))
+				archived = true;
 			holder.setArchived(archived);
 			holder.setAvailable(available);
 			return;
 		}
-		
+
 		if (name.equals(&quot;terra:terracache&quot;)) {
-			inCache=true;
+			inCache = true;
 		}
 
-		
 		if (name.indexOf(&quot;long_description&quot;) &gt; -1) {
 			holder.setHTML(atts.getValue(&quot;html&quot;).toLowerCase().equals(&quot;true&quot;));
 		}
-		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;) ) {
-			//set HTML always to true if from oc.de or TC
+		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;)) {
+			// set HTML always to true if from oc.de or TC
 			holder.setHTML(true);
 		}
 
@@ -294,102 +310,103 @@
 			attID = atts.getValue(&quot;id&quot;);
 			attInc = atts.getValue(&quot;inc&quot;);
 			return;
-		}		
-		if (debugGPX){
+		}
+		if (debugGPX) {
 			for (int i = 0; i &lt; atts.getLength(); i++) {
-				pref.log(&quot;[GPXExporter:startElement]Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i),null);
+				pref.log(&quot;[GPXExporter:startElement]Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i), null);
 			}
 		}
 	}
-	
-	public void endElement(String name){
-		strData=strBuf.toString();
-		if(infB.isClosed) return;
+
+	public void endElement(String name) {
+		strData = strBuf.toString();
+		if (infB.isClosed)
+			return;
 		// logs
-		if (inLogs){
-			if (name.equals(&quot;groundspeak:date&quot;)|| name.equals(&quot;time&quot;)|| name.equals(&quot;date&quot;)|| name.equals(&quot;terra:date&quot;))  {
-				logDate = new String(strData.substring(0,10));
+		if (inLogs) {
+			if (name.equals(&quot;groundspeak:date&quot;) || name.equals(&quot;time&quot;) || name.equals(&quot;date&quot;) || name.equals(&quot;terra:date&quot;)) {
+				logDate = new String(strData.substring(0, 10));
 				return;
 			}
-			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)){
+			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)) {
 				logIcon = new String(Log.typeText2Image(strData));
 				return;
 			}
-			if (name.equals(&quot;groundspeak:finder&quot;)|| name.equals(&quot;geocacher&quot;)|| name.equals(&quot;finder&quot;)|| name.equals(&quot;terra:user&quot;)){
+			if (name.equals(&quot;groundspeak:finder&quot;) || name.equals(&quot;geocacher&quot;) || name.equals(&quot;finder&quot;) || name.equals(&quot;terra:user&quot;)) {
 				logFinder = new String(strData);
 				return;
 			}
-			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){ 
+			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)) {
 				logData = new String(strData);
 				return;
 			}
-			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;) ) {
-				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
-				if((logIcon.equals(&quot;icon_smile.gif&quot;) || logIcon.equals(&quot;icon_camera.gif&quot;) || logIcon.equals(&quot;icon_attended.gif&quot;)) &amp;&amp; 
-						  (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
-							holder.setCacheStatus(logDate);
-							holder.setFound(true);
-							holder.getCacheDetails(false).OwnLogId = logId;
-							holder.getCacheDetails(false).OwnLog = new Log(logIcon,logDate,logFinder,logData);
+			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;)) {
+				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon, logDate, logFinder, logData));
+				if ((logIcon.equals(&quot;icon_smile.gif&quot;) || logIcon.equals(&quot;icon_camera.gif&quot;) || logIcon.equals(&quot;icon_attended.gif&quot;))
+						&amp;&amp; (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() &gt; 0 &amp;&amp; SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
+					holder.setCacheStatus(logDate);
+					holder.setFound(true);
+					holder.getCacheDetails(false).OwnLogId = logId;
+					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData);
 				}
 				return;
 			}
 		}
-		
-		if (name.equals(&quot;wpt&quot;)){
-			
-			int index=cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){// Add cache Data only, if waypoint not already in database
+
+		if (name.equals(&quot;wpt&quot;)) {
+
+			int index = cacheDB.getIndex(holder.getWayPoint());
+			if (index == -1) {// Add cache Data only, if waypoint not already in database
 				holder.setNoFindLogs(holder.getCacheDetails(false).CacheLogs.countNotFoundLogs());
 				holder.setNew(true);
 				cacheDB.add(holder);
 				// don't spider additional waypoints, so check
 				// if waypoint starts with &quot;GC&quot;
-				if(doSpider) {
-					if(spiderOK &amp;&amp; holder.is_archived() == false){
-						if(holder.getLatLon().length() &gt; 1){ }
-						//spiderImages();
+				if (doSpider) {
+					if (spiderOK &amp;&amp; holder.is_archived() == false) {
+						if (holder.getLatLon().length() &gt; 1) {
+						}
+						// spiderImages();
 						spiderImagesUsingSpider();
-						//Rename image sources
+						// Rename image sources
 						String text;
 						String orig;
 						String imgName;
 						orig = holder.getCacheDetails(false).LongDescription;
+
 						Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
-						text = ex.findNext();
 						int num = 0;
-						while(ex.endOfSearch() == false &amp;&amp; spiderOK){
-							if (num &gt;= holder.getCacheDetails(false).images.size())break;
+						while ((text = ex.findNext()).length() &gt; 0 &amp;&amp; spiderOK) {
+							if (num &gt;= holder.getCacheDetails(false).images.size())
+								break;
 							imgName = holder.getCacheDetails(false).images.get(num).getTitle();
 							holder.getCacheDetails(false).LongDescription = STRreplace.replace(holder.getCacheDetails(false).LongDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
 							num++;
-							text = ex.findNext();
 						}
 					}
 				}
 				holder.save();
-				//crw.saveIndex(cacheDB,saveDir);
+				// crw.saveIndex(cacheDB,saveDir);
 			}
-			//Update cache data
+			// Update cache data
 			else {
-				CacheHolder oldCh= cacheDB.get(index);
+				CacheHolder oldCh = cacheDB.get(index);
 				// Preserve images: Copy images from old cache version because here we didn't add
 				// any image information to the holder object.
 				if (pref.downloadPics &amp;&amp; holder.isOC()) {
-					spiderImagesUsingSpider(); 
-				}
-				else {
+					spiderImagesUsingSpider();
+				} else {
 					holder.getCacheDetails(false).images = oldCh.getCacheDetails(true).images;
 				}
 				oldCh.initStates(false);
 				oldCh.update(holder);
 				oldCh.save();
 			}
-			
+
 			inWpt = false;
 			return;
 		}
-		if (name.equals(&quot;sym&quot;)&amp;&amp; strData.endsWith(&quot;Found&quot;)) {
+		if (name.equals(&quot;sym&quot;) &amp;&amp; strData.endsWith(&quot;Found&quot;)) {
 			holder.setFound(true);
 			holder.setCacheStatus(holder.getFoundText());
 			return;
@@ -399,88 +416,86 @@
 			return;
 		}
 
-		if (name.equals(&quot;groundspeak:name&quot;)&amp;&amp; inBug) {
-			Travelbug tb=new Travelbug(strData);
+		if (name.equals(&quot;groundspeak:name&quot;) &amp;&amp; inBug) {
+			Travelbug tb = new Travelbug(strData);
 			holder.getCacheDetails(false).Travelbugs.add(tb);
 			holder.setHas_bugs(true);
 			return;
 		}
-		
-		if (name.equals(&quot;time&quot;) &amp;&amp; !inWpt) {		    
+
+		if (name.equals(&quot;time&quot;) &amp;&amp; !inWpt) {
 			try {
-			    gpxDate.parse(strData.substring(0,19),&quot;yyyy-MM-dd'T'HH:mm:ss&quot;);
+				gpxDate.parse(strData.substring(0, 19), &quot;yyyy-MM-dd'T'HH:mm:ss&quot;);
 			} catch (IllegalArgumentException e) {
-			    gpxDate.setTime(0);
-			    pref.log(&quot;[GPXImporter:endElement]Error parsing Element time: '&quot;+strData+&quot;'. Ignoring.&quot;);
+				gpxDate.setTime(0);
+				pref.log(&quot;[GPXImporter:endElement]Error parsing Element time: '&quot; + strData + &quot;'. Ignoring.&quot;);
 			}
 			return;
 		}
 
 		if (name.equals(&quot;time&quot;) &amp;&amp; inWpt) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
 		// cache information
-		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;)|| name.equals(&quot;cache&quot;)|| name.equals(&quot;terra:terracache&quot;)) {
+		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;) || name.equals(&quot;cache&quot;) || name.equals(&quot;terra:terracache&quot;)) {
 			inCache = false;
 		}
-		
+
 		if (name.equals(&quot;name&quot;) &amp;&amp; inWpt &amp;&amp; !inCache) {
 			holder.setWayPoint(strData);
-			if (gpxDate.getTime()!=0) {
-			    holder.setLastSync(gpxDate.format(&quot;yyyyMMddHHmmss&quot;));
+			if (gpxDate.getTime() != 0) {
+				holder.setLastSync(gpxDate.format(&quot;yyyyMMddHHmmss&quot;));
 			} else {
-			    holder.setLastSync(&quot;&quot;);
-			}    
-			//msgA.setText(&quot;import &quot; + strData);
+				holder.setLastSync(&quot;&quot;);
+			}
+			// msgA.setText(&quot;import &quot; + strData);
 			return;
 		}
 
 		// fill name with contents of &lt;desc&gt;, in case of gc.com the name is
 		// later replaced by the contents of &lt;groundspeak:name&gt; which is shorter
-		if (name.equals(&quot;desc&quot;)&amp;&amp; inWpt ) {
+		if (name.equals(&quot;desc&quot;) &amp;&amp; inWpt) {
 			holder.setCacheName(strData);
-			//msgA.setText(&quot;import &quot; + strData);
+			// msgA.setText(&quot;import &quot; + strData);
 			return;
 		}
-		if (name.equals(&quot;url&quot;)&amp;&amp; inWpt){
+		if (name.equals(&quot;url&quot;) &amp;&amp; inWpt) {
 			holder.getCacheDetails(false).URL = strData;
 			return;
 		}
-		
+
 		// Text for additional waypoints, no HTML
-		if (name.equals(&quot;cmt&quot;)&amp;&amp; inWpt){
+		if (name.equals(&quot;cmt&quot;) &amp;&amp; inWpt) {
 			holder.getCacheDetails(false).LongDescription = strData;
 			holder.setHTML(false);
 			return;
 		}
-		
+
 		// aditional wapypoint
-		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
+		if (name.equals(&quot;type&quot;) &amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 			holder.setHard(CacheTerrDiff.CW_DT_UNSET);
 			holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
 			holder.setLastSync(&quot;&quot;);
 		}
-		
-		if (name.indexOf(&quot;name&quot;)&gt;-1 &amp;&amp; inCache) {
+
+		if (name.indexOf(&quot;name&quot;) &gt; -1 &amp;&amp; inCache) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;)||name.equals(&quot;terra:owner&quot;)) {
+		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;) || name.equals(&quot;terra:owner&quot;)) {
 			holder.setCacheOwner(strData);
-			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-				(pref.myAlias2.length()&gt;0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
 				holder.setOwned(true);
 			return;
 		}
 		if (name.equals(&quot;groundspeak:placed_by&quot;)) {
-			if(holder.getCacheOwner().equals(&quot;&quot;)) {
+			if (holder.getCacheOwner().equals(&quot;&quot;)) {
 				holder.setCacheOwner(strData);
-				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-						(pref.myAlias2.length()&gt;0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
-						holder.setOwned(true);
+				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+					holder.setOwned(true);
 			}
 			return;
 		}
@@ -488,11 +503,11 @@
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if (name.equals(&quot;groundspeak:terrain&quot;)|| name.equals(&quot;terrain&quot;)|| name.equals(&quot;terra:physical_challenge&quot;)) {
+		if (name.equals(&quot;groundspeak:terrain&quot;) || name.equals(&quot;terrain&quot;) || name.equals(&quot;terra:physical_challenge&quot;)) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){
+		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:style&quot;)) &amp;&amp; inCache) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			if (holder.isCustomWpt()) {
 				holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
@@ -501,158 +516,177 @@
 			}
 			return;
 		}
-		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){
+		if (name.equals(&quot;groundspeak:container&quot;) || name.equals(&quot;container&quot;)) {
 			holder.setCacheSize(CacheSize.gcGpxString2Cw(strData));
 			return;
 		}
-		if (name.equals(&quot;groundspeak:country&quot;)|| name.equals(&quot;country&quot;)){
+		if (name.equals(&quot;groundspeak:country&quot;) || name.equals(&quot;country&quot;)) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
-		if (name.equals(&quot;groundspeak:state&quot;)|| name.equals(&quot;state&quot;)){
+		if (name.equals(&quot;groundspeak:state&quot;) || name.equals(&quot;state&quot;)) {
 			holder.getCacheDetails(false).State = strData;
 			return;
 		}
-		if (name.equals(&quot;terra:size&quot;)){
+		if (name.equals(&quot;terra:size&quot;)) {
 			holder.setCacheSize(CacheSize.tcGpxString2Cw(strData));
 		}
 
-		if (name.indexOf(&quot;short_description&quot;) &gt; -1|| name.equals(&quot;summary&quot;)) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
-			else holder.getCacheDetails(false).LongDescription =strData+&quot;\n&quot;;
+		if (name.indexOf(&quot;short_description&quot;) &gt; -1 || name.equals(&quot;summary&quot;)) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription = SafeXML.cleanback(strData) + &quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
+			else
+				holder.getCacheDetails(false).LongDescription = strData + &quot;\n&quot;;
 			return;
 		}
 
-		if (name.indexOf(&quot;long_description&quot;) &gt; -1 || name.equals(&quot;description&quot;)|| name.equals(&quot;terra:description&quot;)) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.indexOf(&quot;long_description&quot;) &gt; -1 || name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;)) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
 		if (name.indexOf(&quot;encoded_hints&quot;) &gt; -1 || name.equals(&quot;hints&quot;)) {
-			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData),&quot;\n&quot;,&quot;&lt;br&gt;&quot;),&quot;\t&quot;,&quot;&quot;);
+			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData), &quot;\n&quot;, &quot;&lt;br&gt;&quot;), &quot;\t&quot;, &quot;&quot;);
 			return;
 		}
-		
+
 		if (name.equals(&quot;terra:hint&quot;)) {
 			// remove &quot;&lt;br&gt;&lt;br&gt;&quot; from the end
 			int indexTrash = strData.indexOf(&quot;&lt;br&gt;&lt;br&gt;&quot;);
-			if (indexTrash &gt; 0)	holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0,indexTrash)),&quot;\n&quot;,&quot;&lt;br&gt;&quot;),&quot;\t&quot;,&quot;&quot;);
+			if (indexTrash &gt; 0)
+				holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0, indexTrash)), &quot;\n&quot;, &quot;&lt;br&gt;&quot;), &quot;\t&quot;, &quot;&quot;);
 			return;
 		}
 
 		if (name.equals(&quot;groundspeak:attribute&quot;)) {
 			if (attID.equals(&quot;&quot;)) {
-				attID=Attribute.getIdFromGCText(strData);
+				attID = Attribute.getIdFromGCText(strData);
 			}
 			int id = Integer.parseInt(attID);
-			holder.getCacheDetails(false).attributes.add(id,attInc);
+			holder.getCacheDetails(false).attributes.add(id, attInc);
 			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			return;
-		}		
+		}
 
 	}
-	public void characters(char[] ch,int start,int length){
-		strBuf.append(ch,start,length);
-		if (debugGPX) pref.log(&quot;Char: &quot; + strBuf.toString(),null);
+
+	public void characters(char[] ch, int start, int length) {
+		strBuf.append(ch, start, length);
+		if (debugGPX)
+			pref.log(&quot;Char: &quot; + strBuf.toString(), null);
 	}
-	
-	public static String TCSizetoText(String size){
-		if (size.equals(&quot;1&quot;)) return &quot;Micro&quot;;
-		if (size.equals(&quot;2&quot;)) return &quot;Medium&quot;;
-		if (size.equals(&quot;3&quot;)) return &quot;Regular&quot;;
-		if (size.equals(&quot;4&quot;)) return &quot;Large&quot;;
-		if (size.equals(&quot;5&quot;)) return &quot;Very Large&quot;;
 
+	public static String TCSizetoText(String size) {
+		if (size.equals(&quot;1&quot;))
+			return &quot;Micro&quot;;
+		if (size.equals(&quot;2&quot;))
+			return &quot;Medium&quot;;
+		if (size.equals(&quot;3&quot;))
+			return &quot;Regular&quot;;
+		if (size.equals(&quot;4&quot;))
+			return &quot;Large&quot;;
+		if (size.equals(&quot;5&quot;))
+			return &quot;Very Large&quot;;
+
 		return &quot;None&quot;;
 	}
-	
-	private void spiderImagesUsingSpider(){
+
+	private void spiderImagesUsingSpider() {
 		String addresse;
 		String cacheText;
-		
+
 		// just to be sure to have a spider object
-		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile);
-		if (propsSpider == null) {propsSpider = imgSpider.new SpiderProperties();	}
-		
+		if (imgSpider == null)
+			imgSpider = new SpiderGC(pref, profile);
+		if (propsSpider == null) {
+			propsSpider = imgSpider.new SpiderProperties();
+		}
+
 		try {
-				if (fromTC) {
-						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
-				}
-				else {
-					if (fromOC) {
-						holder.getCacheDetails(false).images.clear();
-						addresse=holder.getCacheDetails(false).URL;
-						cacheText = UrlFetcher.fetch(addresse);
-						Extractor exBeschreibung = new Extractor(cacheText, &quot;&lt;!-- Beschreibung --&gt;&quot;, &quot;&lt;!-- End Beschreibung --&gt;&quot;, 0, false);
-						String beschreibung = exBeschreibung.findNext();
-						getOCPictures(beschreibung);
-						Extractor exBilder = new Extractor(cacheText, &quot;&lt;!-- Bilder --&gt;&quot;, &quot;&lt;!-- End Bilder --&gt;&quot;, 0, false);
-						String bilder = exBilder.findNext();
-						getOCPictures(bilder);
+			if (fromTC) {
+				imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+			} else {
+				if (fromOC) {
+					holder.getCacheDetails(false).images.clear();
+					addresse = holder.getCacheDetails(false).URL;
+					cacheText = UrlFetcher.fetch(addresse);
+					Extractor exBeschreibung = new Extractor(cacheText, &quot;&lt;!-- Beschreibung --&gt;&quot;, &quot;&lt;!-- End Beschreibung --&gt;&quot;, 0, false);
+					String beschreibung = exBeschreibung.findNext();
+					getOCPictures(beschreibung);
+					Extractor exBilder = new Extractor(cacheText, &quot;&lt;!-- Bilder --&gt;&quot;, &quot;&lt;!-- End Bilder --&gt;&quot;, 0, false);
+					String bilder = exBilder.findNext();
+					getOCPictures(bilder);
+				} else {
+					addresse = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + holder.getWayPoint();
+					cacheText = UrlFetcher.fetch(addresse);
+					if (cacheText.indexOf(propsSpider.getProp(&quot;premiumCachepage&quot;)) &gt; 0) {
+						// Premium cache spidered by non premium member
+						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+					} else {
+						imgSpider.getImages(cacheText, holder.getCacheDetails(false), true);
 					}
-					else {
-						addresse = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + holder.getWayPoint() ;
-						cacheText = UrlFetcher.fetch(addresse);
-						if (cacheText.indexOf(propsSpider.getProp(&quot;premiumCachepage&quot;)) &gt; 0) {
-							// Premium cache spidered by non premium member
-							imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
-						}
-						else {
-							imgSpider.getImages(cacheText, holder.getCacheDetails(false),true);
-						}
-						try {
-							imgSpider.getAttributes(cacheText, holder.getCacheDetails(false));
-						} catch (Exception e) {
-							pref.log(&quot;unable to fetch attributes for&quot;+holder.getWayPoint(), e);
-						}
+					try {
+						imgSpider.getAttributes(cacheText, holder.getCacheDetails(false));
+					} catch (Exception e) {
+						pref.log(&quot;unable to fetch attributes for&quot; + holder.getWayPoint(), e);
 					}
 				}
+			}
 		} catch (Exception e1) {
 			// e1.printStackTrace();
 		}
 	}
+
 	private void getOCPictures(String html) {
 		Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;);
 		imgRegexUrl.setIgnoreCase(true);
-		int descIndex=0;
-		while (imgRegexUrl.searchFrom(html, descIndex)) {			
+		int descIndex = 0;
+		while (imgRegexUrl.searchFrom(html, descIndex)) {
 			descIndex = imgRegexUrl.matchedTo();
-			String fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2)		
-			if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); } // falls ohne in (3)			
-			if (fetchUrl==null) {continue;} // schlechtes html
-			//  fetchUrl ist auf jeden Fall ohne Anf&#252;hrungszeichen
-			if (fetchUrl.startsWith(&quot;resource&quot;)) continue; // 
+			String fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2)
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			} // falls ohne in (3)
+			if (fetchUrl == null) {
+				continue;
+			} // schlechtes html
+				// fetchUrl ist auf jeden Fall ohne Anf&#252;hrungszeichen
+			if (fetchUrl.startsWith(&quot;resource&quot;))
+				continue; //
 			if (fetchUrl.startsWith(&quot;images&quot;)) // z.B. Flaggen
-				if (!fetchUrl.startsWith(&quot;images/uploads&quot;)) continue;
-			if (fetchUrl.startsWith(&quot;thumbs&quot;)) continue; // z.B. Flaggen
+				if (!fetchUrl.startsWith(&quot;images/uploads&quot;))
+					continue;
+			if (fetchUrl.startsWith(&quot;thumbs&quot;))
+				continue; // z.B. Flaggen
 			try {
-				//TODO this is not quite correct: actually the &quot;base&quot; URL must be known...
-				// but anyway a different baseURL should not happen very often  - it doesn't in my area
+				// TODO this is not quite correct: actually the &quot;base&quot; URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
 				String hostname = OC.getOCHostName(holder.getWayPoint());
 				if (!fetchUrl.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) {
-					fetchUrl = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + hostname+&quot;/&quot;), fetchUrl).toString();
+					fetchUrl = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/&quot;), fetchUrl).toString();
 				}
-			} catch (MalformedURLException e) {	continue; } // auch egal
+			} catch (MalformedURLException e) {
+				continue;
+			} // auch egal
 			ImageInfo imageInfo = new ImageInfo();
 			imageInfo.setURL(fetchUrl);
 			imageInfo.setTitle(makeTitle(imgRegexUrl.stringMatched(1), fetchUrl));
 			getPic(imageInfo);
 		}
-		
-		
+
 		Extractor exHref = new Extractor(html, &quot;&lt;a href=&quot;, &quot;&lt;/a&gt;&quot;, 0, true);
-		while (!exHref.endOfSearch()) {
-			String href = exHref.findNext();
-			if (href.length() &gt; 0) {
-				Extractor exHttp = new Extractor(href, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-				String fetchUrl = exHttp.findNext();
+		String href = &quot;&quot;;
+		Extractor exHttp = new Extractor(href, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while ((href = exHref.findNext()).length() &gt; 0) {
+			exHttp.set(href, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+			String fetchUrl = exHttp.findNext();
+			if (fetchUrl.length() &gt; 0) {
 				try {
 					String imgType = (fetchUrl.substring(fetchUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
 					fetchUrl = &quot;<A HREF="http://">http://</A>&quot; + fetchUrl.substring(0, fetchUrl.lastIndexOf('.') + imgType.length());
-					if (imgType.startsWith(&quot;.jpg&quot;) ||
-						imgType.startsWith(&quot;.bmp&quot;) ||
-						imgType.startsWith(&quot;.png&quot;) ||
-						imgType.startsWith(&quot;.gif&quot;)) {
+					if (imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
 						ImageInfo imageInfo = new ImageInfo();
 						imageInfo.setURL(fetchUrl);
 						imageInfo.setTitle(makeTitle(href, fetchUrl));
@@ -669,37 +703,40 @@
 		imgRegexAlt.setIgnoreCase(true);
 		String imgAltText;
 		if (imgRegexAlt.search(imgTag)) {
-			imgAltText=imgRegexAlt.stringMatched(1);
-			if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);			
+			imgAltText = imgRegexAlt.stringMatched(1);
+			if (imgAltText == null)
+				imgAltText = imgRegexAlt.stringMatched(2);
 		} else { // no alternative text as image title -&gt; use --- or filename
-			//wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
-			if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) 
+			// wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+			if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0)
 				imgAltText = &quot;---&quot;; // no image title
-			else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/')+1);
+			else
+				imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
 		}
 		return imgAltText;
 	}
-	
+
 	private void getPic(ImageInfo imageInfo) {
-		String fileName = holder.getWayPoint() + &quot;_&quot; + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/')+1);
+		String fileName = holder.getWayPoint() + &quot;_&quot; + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
 		fileName = Common.ClearForFileName(fileName).toLowerCase();
 		String target = profile.dataDir + fileName;
 		imageInfo.setFilename(fileName);
 		try {
 			File ftest = new FileBugfix(target);
-			if (ftest.exists()){
-				if (ftest.length() == 0) { ftest.delete(); }
-				else { holder.getCacheDetails(false).images.add(imageInfo);	}
-			}
-			else {
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
 				if (pref.downloadPics) {
 					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
 					ftest = new FileBugfix(target);
-					if (ftest.exists()){
-						if ( ftest.length() &gt; 0 ) {
+					if (ftest.exists()) {
+						if (ftest.length() &gt; 0) {
 							holder.getCacheDetails(false).images.add(imageInfo);
-						}
-						else {
+						} else {
 							ftest.delete();
 						}
 					}
@@ -708,21 +745,25 @@
 		} catch (IOException e) {
 			String ErrMessage;
 			String wp, n;
-			if (holder != null &amp;&amp; holder.getWayPoint() != null) wp = holder.getWayPoint();
-			else 												wp = &quot;WP???&quot;;
-			if (holder != null &amp;&amp; holder.getCacheName() != null) n = holder.getCacheName();
-			else 												 n = &quot;name???&quot;;
+			if (holder != null &amp;&amp; holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = &quot;WP???&quot;;
+			if (holder != null &amp;&amp; holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = &quot;name???&quot;;
 
-			if (e == null) ErrMessage = &quot;Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: &quot;+fileName+&quot; from URL:&quot;+imageInfo.getURL();
+			if (e == null)
+				ErrMessage = &quot;Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: &quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
 			else {
-				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) || e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) {
 					// is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+ n + &quot; (&quot;+wp+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;)&quot; + MyLocale.getMsg(1619, &quot;: could not download image from URL: &quot;) + imageInfo.getURL();
 				} else
-					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+ n + &quot; (&quot;+wp+&quot;): ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;): ignoring IOException: &quot; + e.getMessage() + &quot; while downloading picture:&quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
 			}
-			pref.log(ErrMessage,e,true);
+			pref.log(ErrMessage, e, true);
 		}
 
 	}

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -357,10 +357,8 @@
 		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502, &quot;Fetching pages...&quot;));
 		infB.exec();
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		// Reset states for all caches when spidering
 		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
@@ -538,16 +536,14 @@
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl&#195;&#164;nge eines Quadrats
+		double halfSideLength = maxDistance; // halbe Seitenl&#195;&#131;&#194;&#164;nge eines Quadrats
 												// ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		page_number = 0;
 		num_added = 0;
@@ -777,10 +773,8 @@
 	}
 
 	private Hashtable fillDownloadLists(int maxNew, int maxUpdate, double toDistance, double fromDistance, String[] directions, Hashtable cExpectedForUpdate) {
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return null;
-		}
+		if (!login())
+			return null;
 
 		int numFinds;
 		int startPage = 1;
@@ -1038,12 +1032,8 @@
 			return -1; // No point re-spidering an addi waypoint, comes with
 						// parent
 
-		// check if we need to login
-		if (!loggedIn || forceLogin) {
-			if (this.login() != FormBase.IDOK)
-				return -1;
-			// loggedIn is already set by this.login()
-		}
+		if (!login())
+			return -1;
 		try {
 			// Read the cache data from GC.COM and compare to old data
 			ret = getCacheByWaypointName(ch, true, pref.downloadPics, pref.downloadTBs, false, loadAllLogs);
@@ -1089,11 +1079,8 @@
 		// Check whether spider definitions could be loaded, if not issue
 		// appropriate message and terminate
 		// Try to login. If login fails, issue appropriate message and terminate
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK) {
-				return &quot;&quot;;
-			}
-		}
+		if (!login())
+			return &quot;&quot;;
 		final InfoBox localInfB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
 		localInfB.exec();
 		try {
@@ -1116,21 +1103,24 @@
 	/**
 	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
 	 */
-	private int login() {
+	private boolean login() {
+		if (loggedIn &amp;&amp; !pref.forceLogin) {
+			return true;
+		}
 		if (pref.userID.length() &gt; 0) {
 			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
 			loggedIn = switchToEnglish();
 			if (loggedIn)
-				return FormBase.IDOK;
+				return true;
 			else {
 				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences | Einstellungen.&quot;, FormBase.OKB)).execute();
-				return ERR_LOGIN;
+				return false;
 			}
 		} else {
 			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
 			if (true) {
 				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences| Einstellungen.&quot;, FormBase.OKB)).execute();
-				return ERR_LOGIN; // until SSL/https works
+				return false; // until SSL/https works
 			}
 		}
 		loggedIn = false;
@@ -1139,7 +1129,7 @@
 			loginPageUrl = p.getProp(&quot;loginPage&quot;);
 			loginSuccess = p.getProp(&quot;loginSuccess&quot;);
 		} catch (final Exception ex) { // Tag not found in spider.def
-			return ERR_LOGIN;
+			return false;
 		}
 
 		// **0 Get password
@@ -1154,7 +1144,7 @@
 		}
 		localInfB.close(0);
 		if (code != FormBase.IDOK)
-			return code;
+			return false;
 
 		// **1 now we have user and password for login
 		localInfB = new InfoBox(MyLocale.getMsg(5507, &quot;Status&quot;), MyLocale.getMsg(5508, &quot;Logging in...&quot;));
@@ -1165,13 +1155,13 @@
 				localInfB.close(0);
 				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 				pref.log(&quot;[login]:Could not fetch: gc.com login page &quot; + loginPageUrl, null);
-				return ERR_LOGIN;
+				return false;
 			}
 		} catch (final Exception ex) {
 			localInfB.close(0);
 			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
-			return ERR_LOGIN;
+			return false;
 		}
 
 		// **2 now we can check the loginpage if logged in else log in
@@ -1189,7 +1179,7 @@
 						localInfB.close(0);
 						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 						pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
-						return ERR_LOGIN;
+						return false;
 					}
 
 				}
@@ -1206,7 +1196,7 @@
 						pref.log(&quot;[login]:__VIEWSTATE not found (before login): no login possible.&quot;, null);
 						// we need the __VIEWSTATE for sending loginData, so we
 						// should abort here
-						return ERR_LOGIN;
+						return false;
 					}
 					final StringBuffer sb = new StringBuffer(1000);
 					sb.append(&quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false));
@@ -1239,7 +1229,7 @@
 						} else {
 							localInfB.close(0);
 							pref.log(&quot;[login]:SessionID not found.&quot;, null);
-							return ERR_LOGIN;
+							return false;
 						}
 						final Regex rexCookieID = new Regex(&quot;(?i)userid=(.*?);.*&quot;);
 						rexCookieID.search(docprops);
@@ -1248,7 +1238,7 @@
 						} else {
 							localInfB.close(0);
 							pref.log(&quot;[login]:userID not found.&quot;, null);
-							return ERR_LOGIN;
+							return false;
 						}
 						UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
 					} else {
@@ -1258,15 +1248,15 @@
 						pref.log(&quot;[login.Answer]:&quot; + loginPage, null);
 						localInfB.close(0);
 						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
-						return ERR_LOGIN;
+						return false;
 					}
 					if (!this.switchToEnglish())
-						return ERR_LOGIN;
+						return false;
 				} catch (final Exception ex) {
 					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
 					localInfB.close(0);
 					(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
-					return ERR_LOGIN;
+					return false;
 				}
 			}
 		}
@@ -1274,10 +1264,10 @@
 		final boolean loginAborted = localInfB.isClosed;
 		localInfB.close(0);
 		if (loginAborted)
-			return FormBase.IDCANCEL;
+			return false;
 		else {
 			loggedIn = true;
-			return FormBase.IDOK;
+			return true;
 		}
 	}
 
@@ -1285,7 +1275,6 @@
 		// change language to EN , further operations relay on English
 		String url = &quot;<A HREF="http://www.geocaching.com/default.aspx">http://www.geocaching.com/default.aspx</A>&quot;;
 		String page = &quot;&quot;;
-		String loggedInEnglish = &quot;&gt;Sign Out&lt;&quot;;
 		String userID = &quot;userid=&quot; + pref.userID;
 		try {
 			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, userID);
@@ -1319,26 +1308,31 @@
 		} catch (IOException e) {
 			return false;
 		}
-		if (page.indexOf(loggedInEnglish) &gt; -1) {
+		Extractor ext = new Extractor(page, &quot;&lt;a href=\&quot;#\&quot;&gt;&quot;, &quot;&#9660;&lt;/a&gt;&quot;, 0, true);
+		String oldLanguage = ext.findNext();
+		if (oldLanguage.equals(&quot;English&quot;)) {
 			pref.log(&quot;already English&quot;);
 			pref.oldLanguageCtl = &quot;&quot;; // nothing to reset
 			return true;
 		}
 		// switch to english now goes into gc account Display Preferences (is permanent, must be reset)
-		String languages[] = { &quot;English&quot;, &quot;Deutsch&quot;, &quot;Fran&#195;&#167;ais&quot;, &quot;Portugu&#195;&#170;s&quot;, &quot;&#196;&#140;e&#197;&#161;tina&quot;, &quot;Svenska&quot;, &quot;Nederlands&quot;, &quot;Catal&#195;&#160;&quot;, &quot;Polski&quot;, &quot;Eesti&quot;, &quot;Norsk, Bokm&#195;&#165;l&quot;, &quot;&#237;&#149;&#156;&#234;&#181;&#173;&#236;&#150;&#180;&quot;, &quot;Espa&#195;&#177;ol&quot; };
-		String oldLanguage = new Extractor(page, &quot;&lt;a href=\&quot;#\&quot;&gt;&quot;, &quot;&#9660;&lt;/a&gt;&quot;, 0, true).findNext();
+		// todo as long as Textfile Encoding is CP1252 we compare with substring(1) and think koreanisch if no merge at all
+		String languages[] = { &quot;English&quot;, &quot;Deutsch&quot;, &quot;Fran&#231;ais&quot;, &quot;Portugu&#234;s&quot;, &quot;Ce&#154;tina&quot;, &quot;Svenska&quot;, &quot;Nederlands&quot;, &quot;Catal&#224;&quot;, &quot;Polski&quot;, &quot;Eesti&quot;, &quot;Norsk, Bokm&#229;l&quot;, &quot;???&quot;, &quot;Espa&#241;ol&quot; };
 		for (int i = 0; i &lt; languages.length; i++) {
-			if (oldLanguage.equals(languages[i])) {
+			if (oldLanguage.substring(1).equals(languages[i].substring(1))) {
 				pref.oldLanguageCtl = url + &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(&quot;ctl00$uxLocaleList$uxLocaleList$ctl&quot; + MyLocale.formatLong(i, &quot;00&quot;) + &quot;$uxLocaleItem&quot;, false);
 				break;
 			}
 		}
+		if (pref.oldLanguageCtl.length() == 0) {
+			// koreanisch
+			pref.oldLanguageCtl = url + &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(&quot;ctl00$uxLocaleList$uxLocaleList$ctl&quot; + &quot;11&quot; + &quot;$uxLocaleItem&quot;, false);
+		}
 		final String strEnglishPage = &quot;ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem&quot;;
 		url += &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(strEnglishPage, false);
 		try {
 			page = UrlFetcher.fetch(url);
-			// String s = new Extractor(page, &quot;&lt;a href=\&quot;#\&quot;&gt;&quot;, &quot;&#9660;&lt;/a&gt;&quot;, 0, true).findNext();
-			if (page.indexOf(loggedInEnglish) &gt; -1) {
+			if (ext.findFirst(page).equals(&quot;English&quot;)) {
 				pref.log(&quot;Switched to English&quot;);
 				return true;
 			} else {
@@ -1532,16 +1526,13 @@
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl&#195;&#164;nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance; // halbe Seitenl&#195;&#131;&#194;&#164;nge eines Quadrats ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
+		if (!login())
+			return;
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
-
 		page_number = 0;
 		num_added = 0;
 
@@ -1697,46 +1688,34 @@
 
 	private void addCacheNewMap(String page, CWPoint p, boolean setCachesToLoad) {
 
-		final int WpIndex = page.indexOf(&quot;\&quot;gc\&quot;:&quot;);
-		final String[] elements = mString.split(page.substring(WpIndex), '\&quot;');
-		if (elements.length != 63) {
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), &quot;GC changed format of new Map Infos&quot;, FormBase.OKB)).execute();
-			return;
-		}
-		final int posWP = 3; // gc
-		// final int posWPGuid = 7; // g
-		final int posDisabled = 10; // disabled
-		final int posPM = 12; // PM - Cache
-		// final int posLI = 14; // who knows
-		final int posDiff = 18; // difficulty
-		final int posTerr = 26; // terrain
-		final int posHidden = 33; // hidden date
-		final int posSize = 39; // size oder 43
-		final int posType = 52; // type 49 , 52
-		final int posOwner = 57; // owner
-		// final int posOwnerGUID = 61; // guid
+		Extractor ext = new Extractor(page, &quot;{\&quot;name\&quot;:\&quot;&quot;, &quot;\&quot;,&quot;, 0, true);
+		String cacheName = ext.findNext(); // Text
+		String wp = ext.findNext(&quot;\&quot;gc\&quot;:\&quot;&quot;); // Text
+		String disabled = ext.findNext(&quot;\&quot;disabled\&quot;:&quot;, &quot;,&quot;); // true/false
+		String subrOnly = ext.findNext(&quot;\&quot;subrOnly\&quot;:&quot;); // true/false
+		ext.findNext(&quot;\&quot;li\&quot;:&quot;); // true/false (not used, what is that)
+		ext.findNext(&quot;\&quot;fp\&quot;:&quot;); // int (favorite points)
+		String difficulty = ext.findNext(&quot;\&quot;text\&quot;:&quot;); // double
+		String terrain = ext.findNext(); // double;
+		String hidden = ext.findNext(&quot;\&quot;hidden\&quot;:\&quot;&quot;, &quot;\&quot;,&quot;); // string Datum
+		String container = ext.findNext(&quot;\&quot;text\&quot;:\&quot;&quot;); // Text (Micro,...)
+		ext.findNext(&quot;\&quot;value\&quot;:&quot;, &quot;}&quot;); // int dont remove
+		String type = ext.findNext(&quot;\&quot;value\&quot;:&quot;, &quot;}&quot;); // int
+		String owner = ext.findNext(&quot;text\&quot;:\&quot;&quot;, &quot;\&quot;,&quot;); // Text
 
-		// final boolean found = (elements[posFound].indexOf(&quot;true&quot;) &gt; -1 ? true
-		// : false);
-		// if (found &amp;&amp; doNotgetFound) return;
-
-		final byte cacheType = CacheType.gcSpider2CwType(elements[posType].substring(1, elements[posType].length() - 2));
+		final byte cacheType = CacheType.gcSpider2CwType(type);
 		if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
 			if (restrictedCacheType != cacheType)
 				return;
 		}
-		boolean pm = elements[posPM].indexOf(&quot;false&quot;) &gt; -1 ? false : true;
-		// boolean li = elements[posLI].indexOf(&quot;true&quot;) &gt; -1 ? false : true;
-		String wp = elements[posWP];
 		CacheHolder ch = cacheDB.get(wp);
 		if (ch == null) {
-
 			ch = new CacheHolder();
 			ch.setWayPoint(wp);
+			boolean pm = subrOnly.equals(&quot;false&quot;) ? false : true;
 			if (pm &amp;&amp; !pref.isPremium)
 				ch.setCacheStatus(&quot;PM&quot;);
 			ch.pos = p;
-			final String owner = elements[posOwner];
 			ch.setCacheOwner(owner);
 			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
 			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
@@ -1748,15 +1727,13 @@
 				}
 			}
 
-			final int NameIndex = page.indexOf(&quot;\&quot;name\&quot;:\&quot;&quot;);
-			String cacheName = page.substring(NameIndex + 8, WpIndex - 2);
 			cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
 			ch.setCacheName(cacheName);
-			ch.setAvailable((elements[posDisabled].indexOf(&quot;true&quot;) &gt; -1 ? false : true));
-			ch.setDateHidden(DateFormat.toYYMMDD(elements[posHidden]));
-			ch.setHard(CacheTerrDiff.v1Converter(elements[posDiff].substring(1, elements[posDiff].length() - 1)));
-			ch.setTerrain(CacheTerrDiff.v1Converter(elements[posTerr].substring(1, elements[posTerr].length() - 1)));
-			ch.setCacheSize(CacheSize.gcGpxString2Cw(elements[posSize]));
+			ch.setAvailable(disabled.equals(&quot;true&quot;) ? false : true);
+			ch.setDateHidden(DateFormat.toYYMMDD(hidden));
+			ch.setHard(CacheTerrDiff.v1Converter(difficulty));
+			ch.setTerrain(CacheTerrDiff.v1Converter(terrain));
+			ch.setCacheSize(CacheSize.gcGpxString2Cw(container));
 			ch.setType(cacheType);
 			num_added++;
 			cacheDB.add(ch);
@@ -1915,8 +1892,8 @@
 			if (ret.indexOf(&quot;ere&quot;) &gt; -1)
 				return distanceAndDirection; // zur Zeit &quot; Here -1&quot;
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
-			// da dieser von gc mal wieder ge&#195;&#164;ndert wurde.
-			// todo Ben&#195;&#182;tigt ev noch weitere Anpassungen: | am Anfang, and calc
+			// da dieser von gc mal wieder ge&#195;&#131;&#194;&#164;ndert wurde.
+			// todo Ben&#195;&#131;&#194;&#182;tigt ev noch weitere Anpassungen: | am Anfang, and calc
 			// of keylength
 
 			// String thereitis=&quot;|0.34 km|102.698&quot;;
@@ -1949,8 +1926,8 @@
 			}
 			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
 			final String newkey = decodeXor(coded, thereitis);
-			final int keylength = 13; // wenn nicht 13 dann newkey auf
-										// wiederholung pr&#195;&#188;fen
+			final int keylength = 13;
+			// wenn nicht 13 dann newkey auf wiederholung pr&#195;&#131;&#194;&#188;fen
 			DistanceCodeKey = newkey.substring(0, keylength);
 			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
 			pref.log(&quot;Automatic key: &quot; + DistanceCodeKey + &quot; result: &quot; + ret + Preferences.NEWLINE);
@@ -1960,17 +1937,8 @@
 		if (RexPropDistance.didMatch()) {
 			if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1).replace('.', ','));
-				final String r = RexPropDistance.right(1).substring(3); // 3
-																		// expexts
-																		// 2
-																		// char
-																		// which
-																		// are
-																		// at
-																		// moment
-																		// &quot;km&quot;
-																		// or
-																		// &quot;mi&quot;
+				final String r = RexPropDistance.right(1).substring(3);
+				// 3 expexts 2 char which are at moment &quot;km&quot; or &quot;mi&quot;
 				distanceAndDirection[1] = Convert.toDouble(r.replace('.', ','));
 			} else {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1));
@@ -2687,29 +2655,26 @@
 		}
 		final String LogBlock = RexLogBlock.stringMatched(1);
 
-		exSingleLog.setSource(LogBlock);
-		singleLog = exSingleLog.findNext();
-
-		exIcon.setSource(singleLog);
-		exNameTemp.setSource(singleLog);
-		exName.setSource(exNameTemp.findNext());
-		exDate.setSource(singleLog);
-		exLog.setSource(singleLog);
-		exLogId.setSource(singleLog);
+		exSingleLog.set(LogBlock);
 		int nLogs = 0;
 		boolean foundown = false;
-		while (!exSingleLog.endOfSearch()) {
-			// pref.log(singleLog);
+		while ((singleLog = exSingleLog.findNext()).length() &gt; 0) {
 			nLogs++;
-			icon = exIcon.findNext();
+
+			icon = exIcon.findFirst(singleLog);
 			// ' changes to &quot; in UMTS-connection! first char in iconExEnd.
 			icon = icon.substring(0, icon.length() - 1);
-			name = exName.findNext();
-			logText = exLog.findNext();
+
+			name = exName.findFirst(exNameTemp.findFirst(singleLog));
+
+			logText = exLog.findFirst(singleLog);
 			logText = correctSmilies(logText);
-			logId = exLogId.findNext();
-			final String ed = exDate.findNext();
+
+			logId = exLogId.findFirst(singleLog);
+
+			final String ed = exDate.findFirst(singleLog);
 			final String d = DateFormat.toYYMMDD(ed);
+
 			// if this log says this Cache is found by me
 			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) &amp;&amp; (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);
@@ -2726,13 +2691,6 @@
 					break;
 				}
 			}
-			singleLog = exSingleLog.findNext();
-			exIcon.setSource(singleLog);
-			exNameTemp.setSource(singleLog);
-			exName.setSource(exNameTemp.findNext());
-			exDate.setSource(singleLog);
-			exLog.setSource(singleLog);
-			exLogId.setSource(singleLog);
 		}
 		if (nLogs &gt; pref.maxLogsToSpider) {
 			reslts.add(Log.maxLog());
@@ -2768,38 +2726,39 @@
 	 */
 	public void getBugs(CacheHolderDetail chD, String doc) throws Exception {
 		final Extractor exBlock = new Extractor(doc, p.getProp(&quot;blockExStart&quot;), p.getProp(&quot;blockExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
-		final String bugBlock = exBlock.findNext();
-		final Extractor exBug = new Extractor(bugBlock, p.getProp(&quot;bugExStart&quot;), p.getProp(&quot;bugExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
-		String link, bug, linkPlusBug, bugDetails;
-		final String oldInfoBox = infB.getInfo();
-		chD.Travelbugs.clear();
-		while (!exBug.endOfSearch()) {
-			if (infB.isClosed)
-				break; // Allow user to cancel by closing progress form
-			linkPlusBug = exBug.findNext();
-			final int idx = linkPlusBug.indexOf(p.getProp(&quot;bugLinkEnd&quot;));
-			if (idx &lt; 0)
-				break; // No link/bug pair found
-			link = linkPlusBug.substring(0, idx);
-			final Extractor exBugName = new Extractor(linkPlusBug, p.getProp(&quot;bugNameExStart&quot;), p.getProp(&quot;bugNameExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
-			bug = exBugName.findNext();
-			if (bug.length() &gt; 0) { // Found a bug, get its details
-				final Travelbug tb = new Travelbug(bug);
-				try {
-					infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, &quot;\nGetting bug: &quot;) + SafeXML.cleanback(bug));
-					bugDetails = UrlFetcher.fetch(link);
-					pref.log(&quot;[getBugs] Fetched TB details: &quot; + bug);
-					final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
-					tb.setMission(exDetails.findNext());
-					final Extractor exGuid = new Extractor(bugDetails, &quot;action=\&quot;details.aspx?guid=&quot;, &quot;\&quot; id=\&quot;aspnetForm&quot;, 0, Extractor.EXCLUDESTARTEND);
-					tb.setGuid(exGuid.findNext());
-					chD.Travelbugs.add(tb);
-				} catch (final Exception ex) {
-					pref.log(&quot;[getBugs] Could not fetch bug details&quot;, ex);
+		final String bugBlock;
+		if ((bugBlock = exBlock.findNext()).length() &gt; 0) {
+			String link, bug, linkPlusBug, bugDetails;
+			final String oldInfoBox = infB.getInfo();
+			chD.Travelbugs.clear();
+			final Extractor exBug = new Extractor(bugBlock, p.getProp(&quot;bugExStart&quot;), p.getProp(&quot;bugExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
+			while ((linkPlusBug = exBug.findNext()).length() &gt; 0) {
+				if (infB.isClosed)
+					break;
+				final int idx = linkPlusBug.indexOf(p.getProp(&quot;bugLinkEnd&quot;));
+				if (idx &lt; 0)
+					break; // No link/bug pair found
+				link = linkPlusBug.substring(0, idx);
+				final Extractor exBugName = new Extractor(linkPlusBug, p.getProp(&quot;bugNameExStart&quot;), p.getProp(&quot;bugNameExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
+				if ((bug = exBugName.findNext()).length() &gt; 0) {
+					// Found a bug, get its details
+					final Travelbug tb = new Travelbug(bug);
+					try {
+						infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, &quot;\nGetting bug: &quot;) + SafeXML.cleanback(bug));
+						bugDetails = UrlFetcher.fetch(link);
+						pref.log(&quot;[getBugs] Fetched TB details: &quot; + bug);
+						final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
+						tb.setMission(exDetails.findNext());
+						final Extractor exGuid = new Extractor(bugDetails, &quot;action=\&quot;details.aspx?guid=&quot;, &quot;\&quot; id=\&quot;aspnetForm&quot;, 0, Extractor.EXCLUDESTARTEND);
+						tb.setGuid(exGuid.findNext());
+						chD.Travelbugs.add(tb);
+					} catch (final Exception ex) {
+						pref.log(&quot;[getBugs] Could not fetch bug details&quot;, ex);
+					}
 				}
 			}
+			infB.setInfo(oldInfoBox);
 		}
-		infB.setInfo(oldInfoBox);
 	}
 
 	/**
@@ -2840,56 +2799,52 @@
 			return;
 		}
 		String tst;
-		tst = exImgBlock.findNext();
-		Extractor exImgSrc = new Extractor(tst, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while (exImgBlock.endOfSearch() == false) {
-			imgUrl = exImgSrc.findNext();
-			if (imgUrl.length() &gt; 0) {
-				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl &lt; 0) { // New image
-							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
-							pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+		Extractor exImgSrc = new Extractor(&quot;&quot;, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while ((tst = exImgBlock.findNext()).length() &gt; 0) {
+			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
+			// better caching purposes)
+			imgUrl = exImgSrc.findFirst(tst);
+			imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+					// Check whether image was already spidered for this
+					// cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl &lt; 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(imgName);
-						imageInfo.setComment(null);
-						imgCounter++;
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
+						pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (final IndexOutOfBoundsException e) {
-					pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
+					imageInfo.setTitle(imgName);
+					imageInfo.setComment(null);
+					imgCounter++;
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 			}
-			exImgSrc.setSource(exImgBlock.findNext());
 		}
 		// ========
 		// In the image span
@@ -2904,101 +2859,97 @@
 		} catch (final Exception ex) {
 			return;
 		}
-		while (!exImgSrc.endOfSearch()) {
-			imgUrl = exImgSrc.findNext();
+		while ((imgUrl = exImgSrc.findNext()).length() &gt; 0) {
 			imgComment = exImgComment.findNext();
-			if (imgUrl.length() &gt; 0) {
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl &lt; 0) { // New image
-							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
-							pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+			imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+					// Check whether image was already spidered for this
+					// cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl &lt; 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(exImgName.findNext());
-						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;))
-							imgComment = imgComment.substring(6);
-						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;))
-							imgComment = imgComment.substring(0, imgComment.length() - 6);
-						imageInfo.setComment(imgComment);
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
+						pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (final IndexOutOfBoundsException e) {
-					pref.log(&quot;[getImages] IndexOutOfBoundsException in image span. imgURL:&quot; + imgUrl, e);
+					imageInfo.setTitle(exImgName.findNext());
+					while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;))
+						imgComment = imgComment.substring(6);
+					while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;))
+						imgComment = imgComment.substring(0, imgComment.length() - 6);
+					imageInfo.setComment(imgComment);
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log(&quot;[getImages] IndexOutOfBoundsException in image span. imgURL:&quot; + imgUrl, e);
 			}
+
 		}
 		// ========
 		// Final sweep to check for images in hrefs
 		// ========
 		final Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while (!exFinal.endOfSearch()) {
-			imgUrl = exFinal.findNext();
-			if (imgUrl.length() &gt; 0) {
-				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with . Delete
-					// characters in URL after the image extension
-					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
-					if (imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						if (idxUrl &lt; 0) { // New image
-							imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
-							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-							imageInfo.setTitle(imgName);
-							imgCounter++;
-							chD.images.add(imageInfo);
+		while ((imgUrl = exFinal.findNext()).length() &gt; 0) {
+			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
+			// better caching purposes)
+			imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with . Delete
+				// characters in URL after the image extension
+				imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
+				if (imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+					// Check whether image was already spidered for this
+					// cache
+					idxUrl = spideredUrls.find(imgUrl);
+					if (idxUrl &lt; 0) { // New image
+						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
 						}
+						if (imageInfo == null) {
+							imageInfo = new ImageInfo();
+							pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
+							imageInfo.setFilename(fileName + imgType);
+							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
+						}
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+						imageInfo.setTitle(imgName);
+						imgCounter++;
+						chD.images.add(imageInfo);
 					}
-				} catch (final IndexOutOfBoundsException e) {
-					pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 			}
+
 		}
 	}
 
@@ -3038,96 +2989,90 @@
 
 	private void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception {
 		final Extractor exWayBlock = new Extractor(doc, p.getProp(&quot;wayBlockExStart&quot;), p.getProp(&quot;wayBlockExEnd&quot;), 0, false);
-		String wayBlock = &quot;&quot;;
-		String rowBlock = &quot;&quot;;
-		wayBlock = exWayBlock.findNext();
-		final Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
-		final Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
-		final Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
-		final Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
-		int counter = 0;
-		if (!exWayBlock.endOfSearch() &amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;) &lt; 0) {
-			final Extractor exRowBlock = new Extractor(wayBlock, p.getProp(&quot;rowBlockExStart&quot;), p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
-			rowBlock = exRowBlock.findNext();
-			rowBlock = exRowBlock.findNext();
-			while (!exRowBlock.endOfSearch()) {
-				CacheHolder hd = null;
+		String wayBlock;
+		if ((wayBlock = exWayBlock.findNext()).length() &gt; 0) {
+			if (wayBlock.indexOf(&quot;No additional waypoints to display.&quot;) &lt; 0) {
+				final Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
+				final Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
+				final Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
+				final Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
+				int counter = 0;
+				final Extractor exRowBlock = new Extractor(wayBlock, p.getProp(&quot;rowBlockExStart&quot;), p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
+				String rowBlock;
+				rowBlock = exRowBlock.findNext();
+				while ((rowBlock = exRowBlock.findNext()).length() &gt; 0) {
+					CacheHolder hd = null;
 
-				/*
-				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int linePrefix=8; if(AddiBlock.length &lt; linePrefix + 1) { (new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), &quot;GC changed table output \nCW must be changed too!&quot;, FormBase.OKB)).execute();
-				 * break; } String prefix=AddiBlock[linePrefix].trim();
-				 */
+					final Extractor exPrefix = new Extractor(rowBlock, p.getProp(&quot;prefixExStart&quot;), p.getProp(&quot;prefixExEnd&quot;), 0, true);
+					final String prefix = exPrefix.findNext();
+					String adWayPoint;
+					if (prefix.length() == 2)
+						adWayPoint = prefix + wayPoint.substring(2);
+					else
+						adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
+					counter++;
+					final int idx = profile.getCacheIndex(adWayPoint);
+					if (idx &gt;= 0) {
+						// Creating new CacheHolder, but accessing old cache.xml file
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+						// Accessing Details reads file if not yet done
+						hd.getCacheDetails(true);
+					} else {
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+					}
+					hd.initStates(idx &lt; 0);
 
-				// Extractor exPrefix=new
-				// Extractor(AddiBlock[linePrefix].trim(),p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
-				final Extractor exPrefix = new Extractor(rowBlock, p.getProp(&quot;prefixExStart&quot;), p.getProp(&quot;prefixExEnd&quot;), 0, true);
-				final String prefix = exPrefix.findNext();
+					nameRex.search(rowBlock);
+					if (nameRex.didMatch()) {
+						hd.setCacheName(nameRex.stringMatched(1));
+					} else {
+						pref.log(&quot;check nameRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					}
 
-				String adWayPoint;
-				if (prefix.length() == 2)
-					adWayPoint = prefix + wayPoint.substring(2);
-				else
-					adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
-				counter++;
-				final int idx = profile.getCacheIndex(adWayPoint);
-				if (idx &gt;= 0) {
-					// Creating new CacheHolder, but accessing old cache.xml
-					// file
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-					hd.getCacheDetails(true); // Accessing Details reads file if
-												// not yet done
-				} else {
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-				}
-				hd.initStates(idx &lt; 0);
-				nameRex.search(rowBlock);
-				if (nameRex.didMatch()) {
-					hd.setCacheName(nameRex.stringMatched(1));
-				} else {
-					pref.log(&quot;check nameRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
-				}
-				koordRex.search(rowBlock);
-				typeRex.search(rowBlock);
-				if (koordRex.didMatch()) {
-					hd.setLatLon(koordRex.stringMatched(1));
-					koords_not_yet_found = false;
-				} else {
-					if (koords_not_yet_found) {
+					koordRex.search(rowBlock);
+					if (koordRex.didMatch()) {
+						hd.setLatLon(koordRex.stringMatched(1));
 						koords_not_yet_found = false;
-						pref.log(&quot;check koordRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					} else {
+						if (koords_not_yet_found) {
+							koords_not_yet_found = false;
+							pref.log(&quot;check koordRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+						}
 					}
-				}
-				if (typeRex.didMatch()) {
-					hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot; + typeRex.stringMatched(1)));
-				} else {
-					pref.log(&quot;check typeRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
-				}
-				rowBlock = exRowBlock.findNext();
-				descRex.search(rowBlock);
-				if (descRex.didMatch()) {
-					hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
-				} else {
-					pref.log(&quot;check descRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
-				}
-				hd.setFound(is_found);
-				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-				hd.setHard(CacheTerrDiff.CW_DT_UNSET);
-				hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (idx &lt; 0) {
-					cacheDB.add(hd);
-					hd.save();
-				} else {
-					final CacheHolder cx = cacheDB.get(idx);
-					final boolean checked = cx.is_Checked;
-					cx.initStates(false);
-					cx.update(hd);
-					cx.is_Checked = checked;
-					cx.save();
-				}
-				rowBlock = exRowBlock.findNext();
 
+					typeRex.search(rowBlock);
+					if (typeRex.didMatch()) {
+						hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot; + typeRex.stringMatched(1)));
+					} else {
+						pref.log(&quot;check typeRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					}
+
+					rowBlock = exRowBlock.findNext();
+					descRex.search(rowBlock);
+					if (descRex.didMatch()) {
+						hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
+					} else {
+						pref.log(&quot;check descRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					}
+					hd.setFound(is_found);
+					hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+					hd.setHard(CacheTerrDiff.CW_DT_UNSET);
+					hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+
+					if (idx &lt; 0) {
+						cacheDB.add(hd);
+						hd.save();
+					} else {
+						final CacheHolder cx = cacheDB.get(idx);
+						final boolean checked = cx.is_Checked;
+						cx.initStates(false);
+						cx.update(hd);
+						cx.is_Checked = checked;
+						cx.save();
+					}
+				}
 			}
 		}
 	}
@@ -3136,11 +3081,10 @@
 		final Extractor attBlock = new Extractor(doc, p.getProp(&quot;attBlockExStart&quot;), p.getProp(&quot;attBlockExEnd&quot;), 0, true);
 		final String atts = attBlock.findNext();
 		final Extractor attEx = new Extractor(atts, p.getProp(&quot;attExStart&quot;), p.getProp(&quot;attExEnd&quot;), 0, true);
-		String attribute = attEx.findNext();
+		String attribute;
 		chD.attributes.clear();
-		while (!attEx.endOfSearch()) {
+		while ((attribute = attEx.findNext()).length() &gt; 0) {
 			chD.attributes.add(attribute);
-			attribute = attEx.findNext();
 		}
 		chD.getParent().setAttribsAsBits(chD.attributes.getAttribsAsBits());
 	}

Modified: trunk/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/CWGPSPoint.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/navi/CWGPSPoint.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import org.json.JSONArray;
@@ -40,19 +40,18 @@
 import ewe.sys.TimerProc;
 import ewe.sys.Vm;
 
-
 /**
  * @author Kalle
- * Class for decoding NMEA sentences
+ *         Class for decoding NMEA sentences
  */
 
-public class CWGPSPoint extends CWPoint implements TimerProc{
+public class CWGPSPoint extends CWPoint implements TimerProc {
 	public static final int LOGNMEA = 0x01;
-	public static final int LOGRAW  = 0x02;
-	public static final int LOGALL  = LOGNMEA|LOGRAW;
+	public static final int LOGRAW = 0x02;
+	public static final int LOGALL = LOGNMEA | LOGRAW;
 
 	public double Speed; // Speed: km/h
-	public double Bear;	// Bearing
+	public double Bear; // Bearing
 	public String Time; // Time: HHmmss.SS
 	public String Date; // Date: ddMMyy
 	public int Fix; // Fix (0: none, 1: GPS, 2: differential GPS). See getFix() for more possible values.
@@ -61,7 +60,7 @@
 	public double HDOP; // Horizontal dilution of precision
 	public double Alt; // Altitude in meters
 
-	//Logging
+	// Logging
 	int logTimer = 0;
 	int logFlag = 0;
 	boolean writeLog = false;
@@ -69,15 +68,14 @@
 	FileWriter logFile;
 	String lastStrExamined = &quot;&quot;;
 
-	//Regex numberMatcher = new Regex(&quot;\\-?\\d+&quot;);
+	// Regex numberMatcher = new Regex(&quot;\\-?\\d+&quot;);
 
-	public CWGPSPoint()
-	{
+	public CWGPSPoint() {
 		super();
 		this.Speed = 0;
 		this.Bear = 0;
 		this.Time = &quot;&quot;;
-		this.Date=&quot;&quot;;
+		this.Date = &quot;&quot;;
 		this.Fix = 0;
 		this.numSat = 0;
 		this.numSatsInView = 0;
@@ -85,29 +83,32 @@
 		this.HDOP = 0;
 	}
 
-
-	public double getSpeed(){
+	public double getSpeed() {
 		return this.Speed;
 	}
 
-	public double getBear (){
+	public double getBear() {
 		return this.Bear;
 	}
-	public String getTime(){
+
+	public String getTime() {
 		return this.Time;
 	}
 
 	/**
-	 * @return &gt; 0: fixed &lt;br&gt; 0: not fixed &lt;br&gt; -1: no data from serial port &lt;br&gt; -2 data from serial port could not be interpreted
+	 * @return &gt; 0: fixed &lt;br&gt;
+	 *         0: not fixed &lt;br&gt;
+	 *         -1: no data from serial port &lt;br&gt;
+	 *         -2 data from serial port could not be interpreted
 	 */
-	public int getFix(){
+	public int getFix() {
 		return this.Fix;
 	}
 
 	/**
 	 * this method should be called, if COM-Port is closed
 	 */
-	public void noData(){
+	public void noData() {
 		this.Fix = 0;
 		this.numSat = 0;
 		this.HDOP = 0;
@@ -116,7 +117,7 @@
 	/**
 	 * this method should be called, if not data is coming from COM-Port but is expected to come
 	 */
-	public void noDataError(){
+	public void noDataError() {
 		this.Fix = -1;
 		this.numSat = -1;
 		this.HDOP = -1;
@@ -125,13 +126,13 @@
 	/**
 	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
 	 */
-	public void noInterpretableData(){
+	public void noInterpretableData() {
 		this.Fix = -2;
 		this.numSat = -2;
 		this.HDOP = -2;
 	}
 
-	public void ticked(int timerId, int elapsed){
+	public void ticked(int timerId, int elapsed) {
 		if (timerId == logTimer) {
 			writeLog = true;
 		}
@@ -139,23 +140,26 @@
 	}
 
 	/**
-	 *
-	 * @param logFileDir directory for logfile
-	 * @param seconds	 intervall for writing to logfile
-	 * @param flag		 level of logging
+	 * 
+	 * @param logFileDir
+	 *            directory for logfile
+	 * @param seconds
+	 *            intervall for writing to logfile
+	 * @param flag
+	 *            level of logging
 	 * @return 0 success, -1 failure
 	 */
-	public int startLog(String logFileDir, int seconds, int flag){
+	public int startLog(String logFileDir, int seconds, int flag) {
 
 		Time currTime = new Time();
 		currTime.getTime();
 		currTime.setFormat(&quot;yyyyMMdd'_'HHmm&quot;);
-		String logFileName = new String(logFileDir + currTime.toString()+ &quot;.log&quot;);
+		String logFileName = new String(logFileDir + currTime.toString() + &quot;.log&quot;);
 		// create Logfile
 		try {
 			logFile = new FileWriter(logFileName);
 		} catch (IOException e) {
-			Global.getPref().log(&quot;Error creating LogFile &quot; + logFileName,e,true);
+			Global.getPref().log(&quot;Error creating LogFile &quot; + logFileName, e, true);
 			return -1;
 		}
 		// start timer
@@ -168,10 +172,11 @@
 	public void stopLog() {
 		writeLog = false;
 
-		if (doLogging){
+		if (doLogging) {
 			try {
 				logFile.close();
-			} catch (IOException e) {/*Too lazy to do something */}
+			} catch (IOException e) {/* Too lazy to do something */
+			}
 			if (logTimer &gt; 0) {
 				Vm.cancelTimer(logTimer);
 				logTimer = 0;
@@ -180,82 +185,107 @@
 		doLogging = false;
 	}
 
-
-	public int getSats(){
+	public int getSats() {
 		return this.numSat;
 	}
 
-	public int getSatsInView(){
+	public int getSatsInView() {
 		return this.numSatsInView;
 	}
 
-	public double getAlt(){
+	public double getAlt() {
 		return this.Alt;
 	}
 
-	public double getHDOP(){
+	public double getHDOP() {
 		return this.HDOP;
 	}
 
 	/**
 	 * Sets the attributes from a NMEA String
-	 * @param NMEA	string with data to examine
+	 * 
+	 * @param NMEA
+	 *            string with data to examine
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examine(String NMEA){
+	public boolean examine(String NMEA) {
 		boolean interpreted = false;
 		boolean logWritten = false;
 		try {
 			int i, start, end;
-			String latDeg=&quot;0&quot;, latMin=&quot;0&quot;, latNS=&quot;N&quot;;
-			String lonDeg=&quot;0&quot;, lonMin=&quot;0&quot;, lonEW=&quot;E&quot;;
+			String latDeg = &quot;0&quot;, latMin = &quot;0&quot;, latNS = &quot;N&quot;;
+			String lonDeg = &quot;0&quot;, lonMin = &quot;0&quot;, lonEW = &quot;E&quot;;
 			String currToken;
 			end = 0;
 			lastStrExamined = NMEA;
-			while(true){
+			while (true) {
 				start = NMEA.indexOf(&quot;$GP&quot;, end);
-				if (start == -1) break;
+				if (start == -1)
+					break;
 				end = NMEA.indexOf(&quot;*&quot;, start);
-				if ((end == -1)||(end+3 &gt; NMEA.length())) break;
+				if ((end == -1) || (end + 3 &gt; NMEA.length()))
+					break;
 
-				if ((end - start) &lt; 15 || !checkSumOK(NMEA.substring(start,end+3))){
+				if ((end - start) &lt; 15 || !checkSumOK(NMEA.substring(start, end + 3))) {
 					continue;
 				}
 				// Write log after finding valid NMEA sequence
-				if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){
+				if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0) {
 					try {
-						logFile.write(NMEA.substring(start,end+3)+&quot;\n&quot;);
+						logFile.write(NMEA.substring(start, end + 3) + &quot;\n&quot;);
 						logWritten = true;
 					} catch (IOException e) {
 						// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 					}
 				}
 
-				Extractor ex = new Extractor (&quot;,&quot; + NMEA.substring(start,end), &quot;,&quot;,&quot;,&quot;,0,true);
+				Extractor ex = new Extractor(&quot;,&quot; + NMEA.substring(start, end), &quot;,&quot;, &quot;,&quot;, 0, true);
 				currToken = ex.findNext();
-				if (currToken.equals(&quot;$GPGGA&quot;)){
+				if (currToken.equals(&quot;$GPGGA&quot;)) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						boolean latlonerror = false; // indicate that some error occured in the data -&gt; in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
+						// indicate that some error occured in the data -&gt; in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
+						boolean latlonerror = false;
 						i++;
-						if (currToken.length()==0) {
-							if (i &gt;= 2 &amp;&amp; i &lt;= 5) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
-						}
-						switch (i){
-						case 1: this.Time = currToken; break;
-						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 3: latNS = currToken;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							break;
+						case 2:
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 3:
+							latNS = currToken;
+							break;
 
-						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 5: lonEW = currToken;
-						break;
+						case 4:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 5:
+							lonEW = currToken;
+							break;
 						case 6:
 							if (!latlonerror) {
 								this.Fix = Convert.toInt(currToken);
@@ -265,142 +295,194 @@
 								this.Fix = 0;
 								break;
 							}
-						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
-						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						} break;
-						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						} break;
+						case 7:
+							this.numSat = Convert.toInt(currToken);
+							interpreted = true;
+							break;
+						case 8:
+							try {
+								this.HDOP = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							break;
+						case 9:
+							try {
+								this.Alt = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							break;
 						} // switch
 					} // while
-					if (Fix &gt; 0) this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
+					if (Fix &gt; 0)
+						this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
 
 				} // if
 
-				if (currToken.equals(&quot;$GPVTG&quot;)){
+				if (currToken.equals(&quot;$GPVTG&quot;)) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
 						i++;
-						if (currToken.length()==0) continue;
-						switch (i){
-						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						if (this.Bear &gt; 360) Global.getPref().log(&quot;Error bear VTG&quot;,null);
-						break;
-						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						break;
+						switch (i) {
+						case 1:
+							try {
+								this.Bear = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							if (this.Bear &gt; 360)
+								Global.getPref().log(&quot;Error bear VTG&quot;, null);
+							break;
+						case 7:
+							try {
+								this.Speed = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							break;
 						} // switch
 					} // while
 				} // if
 
-				if (currToken.equals(&quot;$GPRMC&quot;)){
+				if (currToken.equals(&quot;$GPRMC&quot;)) {
 					i = 0;
 					String status = &quot;V&quot;;
 					boolean latlonerror = false;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
 						i++;
-						if (currToken.length() == 0) {
-							if (i &gt;= 2 &amp;&amp; i &lt;= 6) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
-						}
-						if (currToken.length() == 0) continue;
-						switch (i){
-						case 1: this.Time = currToken; interpreted = true; break;
-						case 2: status = currToken;
-						if (status.equals(&quot;A&quot;)) this.Fix = 1;
-						else this.Fix = 0;
-						interpreted = true;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							interpreted = true;
+							break;
+						case 2:
+							status = currToken;
+							if (status.equals(&quot;A&quot;))
+								this.Fix = 1;
+							else
+								this.Fix = 0;
+							interpreted = true;
+							break;
 						case 3:
-							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
 							break;
-						case 4: latNS = currToken; interpreted = true;
-						break;
-						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						break;
-						case 6: lonEW = currToken;
-						interpreted = true;
-						break;
-						case 7: if (status.equals(&quot;A&quot;)){
-							try {this.Speed = Common.parseDouble(currToken)*1.854;
-							interpreted = true; } catch (NumberFormatException e) {
-								//Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-							}
-						}
-						break;
-						case 8: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
-							try {this.Bear = Common.parseDouble(currToken);
-							interpreted = true; } catch (NumberFormatException e) {
+						case 4:
+							latNS = currToken;
+							interpreted = true;
+							break;
+						case 5:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 							}
-						}
-						break;
-						case 9: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
-							try {this.Date = currToken;
-							interpreted = true; } catch (NumberFormatException e) {
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 							}
-						}
-						break;
+							break;
+						case 6:
+							lonEW = currToken;
+							interpreted = true;
+							break;
+						case 7:
+							if (status.equals(&quot;A&quot;)) {
+								try {
+									this.Speed = Common.parseDouble(currToken) * 1.854;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+								}
+							}
+							break;
+						case 8:
+							if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length() &gt; 0) {
+								try {
+									this.Bear = Common.parseDouble(currToken);
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+								}
+							}
+							break;
+						case 9:
+							if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length() &gt; 0) {
+								try {
+									this.Date = currToken;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+								}
+							}
+							break;
 						} // switch
 					} // while
-					if (latlonerror) this.Fix = 0;
+					if (latlonerror)
+						this.Fix = 0;
 					else {
-						if (status.equals(&quot;A&quot;)){
-							this.set(latNS, latDeg, latMin, &quot;0&quot;,
-									lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
+						if (status.equals(&quot;A&quot;)) {
+							this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
 						}
 					}
 				} // if
 
-				if (currToken.equals(&quot;$GPGSV&quot;)){
+				if (currToken.equals(&quot;$GPGSV&quot;)) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
 						i++;
-						if (currToken.length() == 0) continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
-						switch (i){
-						case 3: this.numSatsInView = Convert.toInt(currToken); interpreted = true; break;
+						switch (i) {
+						case 3:
+							this.numSatsInView = Convert.toInt(currToken);
+							interpreted = true;
+							break;
 						} // switch
 					} // while
 				} // if
 
-			} //while
+			} // while
 		} catch (Exception e) {
 			Global.getPref().log(&quot;Exception in examine in CWGPSPoint&quot;, e, true);
 		}
 
-		if	(logWritten)
+		if (logWritten)
 			writeLog = false;
 
 		return interpreted;
 	}
 
-
 	/**
 	 * Sets the attributes from a GPSD &lt;code&gt;POLL&lt;/code&gt; object
-	 *
-	 * @param gps	{@link JSONObject} containing GPS &lt;code&gt;POLL&lt;/code&gt; data.
+	 * 
+	 * @param gps
+	 *            {@link JSONObject} containing GPS &lt;code&gt;POLL&lt;/code&gt; data.
 	 * @return true if some data could be interpreted false otherwise
 	 *         Tblue&gt; For now, this always returns true. Any ideas what
-	 *                should be treated as not interpretable?
-	 * @throws JSONException When trying to access a not existing key (should not happen!).
+	 *         should be treated as not interpretable?
+	 * @throws JSONException
+	 *             When trying to access a not existing key (should not happen!).
 	 */
 	public boolean examineGpsd(JSONObject gps) throws JSONException {
-		JSONArray fixes    = gps.getJSONArray( &quot;fixes&quot; );
-		JSONArray skyviews = gps.getJSONArray( &quot;skyviews&quot; );
+		JSONArray fixes = gps.getJSONArray(&quot;fixes&quot;);
+		JSONArray skyviews = gps.getJSONArray(&quot;skyviews&quot;);
 		JSONArray sats;
 		JSONObject a_fix, a_skyview;
 		int fix_mode, i;
@@ -409,59 +491,55 @@
 
 		lastStrExamined = gps.toString();
 
-		TimeObj.setTime( (long)( gps.getDouble( &quot;timestamp&quot; ) * 1000 ) );
-		this.Time = TimeObj.format( &quot;HHmmss.SS&quot; );
-		this.Date = TimeObj.format( &quot;ddMMyy&quot; );
+		TimeObj.setTime((long) (gps.getDouble(&quot;timestamp&quot;) * 1000));
+		this.Time = TimeObj.format(&quot;HHmmss.SS&quot;);
+		this.Date = TimeObj.format(&quot;ddMMyy&quot;);
 
-		if( fixes.length() &gt; 0 ) {
+		if (fixes.length() &gt; 0) {
 			// We will only use the first fix.
 			// TODO: Randomize?
-			a_fix = fixes.getJSONObject( 0 );
-			
+			a_fix = fixes.getJSONObject(0);
+
 			// 0: no mode seen yet, 1: none, 2: 2D, 3: 3D.
 			// Tblue&gt; Does 3D mean differential here?
-			this.Fix = ( fix_mode = a_fix.getInt( &quot;mode&quot; ) ) &gt; 0 ? fix_mode - 1 : 0;
+			this.Fix = (fix_mode = a_fix.getInt(&quot;mode&quot;)) &gt; 0 ? fix_mode - 1 : 0;
 
 			// Speed is in m/s.
-			if( a_fix.has( &quot;speed&quot; ) ) {
-				this.Speed = ( a_fix.getDouble( &quot;speed&quot; ) / 1000 ) * 60 * 60;
+			if (a_fix.has(&quot;speed&quot;)) {
+				this.Speed = (a_fix.getDouble(&quot;speed&quot;) / 1000) * 60 * 60;
 			}
 
-			if( a_fix.has( &quot;track&quot; ) ) {
-				this.Bear = a_fix.getDouble( &quot;track&quot; );
+			if (a_fix.has(&quot;track&quot;)) {
+				this.Bear = a_fix.getDouble(&quot;track&quot;);
 			}
 
-			if( a_fix.has( &quot;alt&quot; ) ) {
-				this.Alt = a_fix.getDouble( &quot;alt&quot; );
+			if (a_fix.has(&quot;alt&quot;)) {
+				this.Alt = a_fix.getDouble(&quot;alt&quot;);
 			}
 
-			if( a_fix.has( &quot;lat&quot; ) &amp;&amp; a_fix.has( &quot;lon&quot; ) ) {
-				my_lat = a_fix.getDouble( &quot;lat&quot; );
-				my_lon = a_fix.getDouble( &quot;lon&quot; );
+			if (a_fix.has(&quot;lat&quot;) &amp;&amp; a_fix.has(&quot;lon&quot;)) {
+				my_lat = a_fix.getDouble(&quot;lat&quot;);
+				my_lon = a_fix.getDouble(&quot;lon&quot;);
 
-				set( my_lat &gt; 0 ? &quot;N&quot; : &quot;S&quot;, String.valueOf( my_lat ), &quot;0&quot;, &quot;0&quot;,
-					 my_lon &gt; 0 ? &quot;E&quot; : &quot;W&quot;, String.valueOf( my_lon ), &quot;0&quot;, &quot;0&quot;,
-					 TransformCoordinates.DD );
+				set(my_lat &gt; 0 ? &quot;N&quot; : &quot;S&quot;, String.valueOf(my_lat), &quot;0&quot;, &quot;0&quot;, my_lon &gt; 0 ? &quot;E&quot; : &quot;W&quot;, String.valueOf(my_lon), &quot;0&quot;, &quot;0&quot;, TransformCoordinates.DD);
 			}
 		}
 
-		if( skyviews.length() &gt; 0 )
-		{
+		if (skyviews.length() &gt; 0) {
 			// We will only use the first skyview.
 			// TODO: Randomize?
-			a_skyview = skyviews.getJSONObject( 0 );
+			a_skyview = skyviews.getJSONObject(0);
 
-			if( a_skyview.has( &quot;hdop&quot; ) ) {
-				this.HDOP = a_skyview.getDouble( &quot;hdop&quot; );
+			if (a_skyview.has(&quot;hdop&quot;)) {
+				this.HDOP = a_skyview.getDouble(&quot;hdop&quot;);
 			}
 
-			sats = a_skyview.getJSONArray( &quot;satellites&quot; );
+			sats = a_skyview.getJSONArray(&quot;satellites&quot;);
 			this.numSatsInView = sats.length();
 
-			if( this.numSatsInView &gt; 0 )
-			{
-				for( this.numSat = 0, i = 0; i &lt; this.numSatsInView; i++ ) {
-					if( sats.getJSONObject( i ).getBoolean( &quot;used&quot; ) ) {
+			if (this.numSatsInView &gt; 0) {
+				for (this.numSat = 0, i = 0; i &lt; this.numSatsInView; i++) {
+					if (sats.getJSONObject(i).getBoolean(&quot;used&quot;)) {
 						this.numSat++;
 					}
 				}
@@ -471,71 +549,72 @@
 		return true;
 	}
 
-
 	/**
 	 * Sets the attributes from an old-style GPSD string.
-	 * @param gps	GPSD string with data to examine
-	 *              Format: GPSD,key=value,...
+	 * 
+	 * @param gps
+	 *            GPSD string with data to examine
+	 *            Format: GPSD,key=value,...
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examineOldGpsd(String gps){
+	public boolean examineOldGpsd(String gps) {
 		boolean valid = false;
-		if(!gps.startsWith(&quot;GPSD,&quot;))
+		if (!gps.startsWith(&quot;GPSD,&quot;))
 			return false;
-		Extractor ex = new Extractor (gps, &quot;,&quot;,&quot;,&quot;,4,true);
-		while(!ex.endOfSearch()){
-			String part = ex.findNext();
-			if(part.startsWith(&quot;A=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+		Extractor ex = new Extractor(gps, &quot;,&quot;, &quot;,&quot;, 4, true);
+		String part;
+		while ((part = ex.findNext()).length() &gt; 0) {
+			if (part.startsWith(&quot;A=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// The current altitude as &quot;A=%f&quot;, meters above mean sea level.
-				this.Alt=Common.parseDouble(part.substring(2));
+				this.Alt = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith(&quot;D=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+			} else if (part.startsWith(&quot;D=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// Returns the UTC time in the ISO 8601 format, &quot;D=yyyy-mm-ddThh:mm:ss.ssZ&quot;
-				//                                               0000000000111111111122
-				//                                               0123456789012345678901
-				String year = part.substring(2,6);
-				String month = part.substring(7,9);
-				String day = part.substring(10,12);
-				String hour = part.substring(13,15);
-				String min = part.substring(16,18);
-				String sec = part.substring(19,21);
-				this.Date=year+month+day;
-				this.Time=hour+min+sec;
+				// 0000000000111111111122
+				// 0123456789012345678901
+				String year = part.substring(2, 6);
+				String month = part.substring(7, 9);
+				String day = part.substring(10, 12);
+				String hour = part.substring(13, 15);
+				String min = part.substring(16, 18);
+				String sec = part.substring(19, 21);
+				this.Date = year + month + day;
+				this.Time = hour + min + sec;
 				valid = true;
-			}else if(part.startsWith(&quot;P=&quot;)){
+			} else if (part.startsWith(&quot;P=&quot;)) {
 				// Returns the current position in the form &quot;P=%f %f&quot;; numbers are in degrees, latitude first.
-				if(part.indexOf('?')&lt;0){
+				if (part.indexOf('?') &lt; 0) {
 					this.Fix = 1;
-					int spacepos=part.indexOf(' ');
-					if(spacepos&gt;=3){
-						String lat=part.substring(2,spacepos);
-						String lon=part.substring(spacepos+1);
-						this.latDec=Common.parseDouble(lat);
-						this.lonDec=Common.parseDouble(lon);
-					}else
+					int spacepos = part.indexOf(' ');
+					if (spacepos &gt;= 3) {
+						String lat = part.substring(2, spacepos);
+						String lon = part.substring(spacepos + 1);
+						this.latDec = Common.parseDouble(lat);
+						this.lonDec = Common.parseDouble(lon);
+					} else
 						this.set(part.substring(2));
-				}else{
+				} else {
 					this.Fix = 0;
 				}
 				valid = true;
-			}else if(part.startsWith(&quot;Q=&quot;)){
+			} else if (part.startsWith(&quot;Q=&quot;)) {
 				// Returns &quot;Q=%d %f %f %f %f %f&quot;: a count of satellites used in the last fix,
 				// and five dimensionless dilution-of-precision (DOP) numbers --
 				// spherical, horizontal, vertical, time, and total geometric.
-				int spacepos=part.indexOf(' ');
-				if(part.indexOf('?')&lt;0 &amp;&amp; spacepos&gt;=3){
+				int spacepos = part.indexOf(' ');
+				if (part.indexOf('?') &lt; 0 &amp;&amp; spacepos &gt;= 3) {
 					this.numSat = Common.parseInt(part.substring(2, spacepos));
 					valid = true;
-				}else{
+				} else {
 					this.numSat = 0;
 				}
-				this.numSatsInView = 0;			// Not supported by GPSD
-				//TODO parse DOP values
-			}else if(part.startsWith(&quot;T=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+				this.numSatsInView = 0; // Not supported by GPSD
+				// TODO parse DOP values
+			} else if (part.startsWith(&quot;T=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// Track made good; course &quot;T=%f&quot; in degrees from true north.
 				this.Bear = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith(&quot;V=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+			} else if (part.startsWith(&quot;V=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// The current speed over ground as &quot;V=%f&quot; in knots.
 				this.Speed = Common.parseDouble(part.substring(2));
 				valid = true;
@@ -544,16 +623,16 @@
 		return valid;
 	}
 
-
-	private boolean checkSumOK(String nmea){
+	private boolean checkSumOK(String nmea) {
 		int startPos = 1; // begin after $
 		int endPos = nmea.length() - 3;// without * an two checksum chars
 		byte checkSum = 0;
 
-		for (int i= startPos; i&lt;endPos;i++){
+		for (int i = startPos; i &lt; endPos; i++) {
 			checkSum ^= nmea.charAt(i);
 		}
-		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		try {
+			return (checkSum == Byte.parseByte(nmea.substring(endPos + 1), 16));
 		} catch (IndexOutOfBoundsException e) {
 			return false;
 		} catch (NumberFormatException e) {
@@ -561,9 +640,7 @@
 		}
 	}
 
-
-
-	public void printAll(){
+	public void printAll() {
 		Global.getPref().log(&quot;Latitude:     &quot; + this.getLatDeg(TransformCoordinates.DD));
 		Global.getPref().log(&quot;Longitude:    &quot; + this.getLonDeg(TransformCoordinates.DD));
 		Global.getPref().log(&quot;Speed:        &quot; + this.Speed);
@@ -577,5 +654,3 @@
 		Global.getPref().log(&quot;----------------&quot;);
 	}
 }
-
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002996.html">[Cachewolf-svn] r3005 - in trunk/src/CacheWolf: . imp view/ewe	view/pda
</A></li>
	<LI>Next message: <A HREF="002997.html">[Cachewolf-svn] r3006 - trunk/res_noewe
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2998">[ date ]</a>
              <a href="thread.html#2998">[ thread ]</a>
              <a href="subject.html#2998">[ subject ]</a>
              <a href="author.html#2998">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
