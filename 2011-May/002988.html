<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r2997 - in trunk: res_noewe/attributes	res_noewe/languages src/CacheWolf src/CacheWolf/imp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-May/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2997%20-%20in%20trunk%3A%20res_noewe/attributes%0A%09res_noewe/languages%20src/CacheWolf%20src/CacheWolf/imp&In-Reply-To=%3C20110510215454.32447481270%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002987.html">
   <LINK REL="Next"  HREF="002989.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r2997 - in trunk: res_noewe/attributes	res_noewe/languages src/CacheWolf src/CacheWolf/imp</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2997%20-%20in%20trunk%3A%20res_noewe/attributes%0A%09res_noewe/languages%20src/CacheWolf%20src/CacheWolf/imp&In-Reply-To=%3C20110510215454.32447481270%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r2997 - in trunk: res_noewe/attributes	res_noewe/languages src/CacheWolf src/CacheWolf/imp">araber95 at mail.berlios.de
       </A><BR>
    <I>Tue May 10 11:54:53 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002987.html">[Cachewolf-svn] r2996 - in trunk: res_noewe src/CacheWolf	src/CacheWolf/imp
</A></li>
        <LI>Next message: <A HREF="002989.html">[Cachewolf-svn] r2998 - in trunk/src/CacheWolf: . imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2988">[ date ]</a>
              <a href="thread.html#2988">[ thread ]</a>
              <a href="subject.html#2988">[ subject ]</a>
              <a href="author.html#2988">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-05-10 23:54:53 +0200 (Tue, 10 May 2011)
New Revision: 2997

Added:
   trunk/res_noewe/attributes/sponsored-no.gif
   trunk/res_noewe/attributes/sponsored-non.gif
   trunk/res_noewe/attributes/sponsored-yes.gif
Modified:
   trunk/res_noewe/languages/DE.cfg
   trunk/res_noewe/languages/EN.cfg
   trunk/res_noewe/languages/FR.cfg
   trunk/res_noewe/languages/NL.cfg
   trunk/res_noewe/languages/PL.cfg
   trunk/res_noewe/languages/SV.cfg
   trunk/src/CacheWolf/Attribute.java
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DateFormat.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
1. add Attribute &quot;sponsored cache), id and gpx text guessed (todo correct values)
2. date format can be set to one of the formats of gc
3.  quick import with new map fixed (gc changed infos)

Added: trunk/res_noewe/attributes/sponsored-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/res_noewe/attributes/sponsored-no.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/res_noewe/attributes/sponsored-non.gif
===================================================================
(Binary files differ)


Property changes on: trunk/res_noewe/attributes/sponsored-non.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/res_noewe/attributes/sponsored-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/res_noewe/attributes/sponsored-yes.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/res_noewe/languages/DE.cfg
===================================================================
--- trunk/res_noewe/languages/DE.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/DE.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682=RFID, CHIRP / Funk Ausr&#195;&#188;stung
 2683=keine Erste Hilfe 
 2684=Erste Hilfe nahebei
+2685=nicht gesponsert
+2686=gesponsert
 3000=Schlie&#195;&#159;en
 4000=Geladene Caches:+
 4001=GPX-Dateien von Opencaching enthalten keine Informationen zu Bildern, sie werden nicht heruntergeladen. Am besten Caches von Opencaching holen per Men&#195;&#188; /Anwendung/Import/von Opencaching

Modified: trunk/res_noewe/languages/EN.cfg
===================================================================
--- trunk/res_noewe/languages/EN.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/EN.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP / radio equipment
 2683 = No emergency
 2684 = First Aid nearby
+2685=not sponsored
+2686=sponsored
 3000=Close
 4000=Loaded caches:+
 4001=GPX files from opencaching don't contain information of images, they cannot be loaded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching

Modified: trunk/res_noewe/languages/FR.cfg
===================================================================
--- trunk/res_noewe/languages/FR.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/FR.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP &#195;&#169;quipement radio /
 2683 = Pas d'urgence
 2684 = First Aid &#195;&#160; proximit&#195;&#169;
+2685 = non parrain&#195;&#169;
+2686 = parrain&#195;&#169;
 3000=Fermer
 4000=Caches charg&#195;&#169;es:
 4001=GPX fichiers &#195;&#160; partir Opencaching ne contiennent pas d'informations d'images, ils ne peuvent pas &#195;&#170;tre charg&#195;&#169;. Pour le meilleur vous obtenez des caches de Opencaching par le menu /Application/importation/Download from Opencaching

Modified: trunk/res_noewe/languages/NL.cfg
===================================================================
--- trunk/res_noewe/languages/NL.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/NL.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP / radio-apparatuur
 2683 = Geen spoed
 2684 = Eerste Hulp in de buurt
+2685 = niet gesponsord
+2686 = gesponsord
 3000=Sluiten
 4000=Geladen caches
 4001=GPX bestanden uit opencaching bevatten geen informatie van beelden, kunnen zij niet worden downloaden. Beste je caches van opencaching menu /Application/Import/Download from Opencaching

Modified: trunk/res_noewe/languages/PL.cfg
===================================================================
--- trunk/res_noewe/languages/PL.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/PL.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP / urz&#196;&#133;dze&#197;&#132; radiowych
 2683 = Nie awaryjne
 2684 = Pierwsza pomoc w pobli&#197;&#188;u
+2685 = nie sponsorowane
+2686 = sponsorowane
 3000=Zamknij
 4000=Wczytaj skrzynki:+
 4001=Pliki GPX z opencaching nie zawieraja informacji o obrazach, nie moga byc one wczytane. Najlepiej pobierz skrzynki z opencaching przez menu /Aplikacja/Importuj/Sciagnij Z Opencaching

Modified: trunk/res_noewe/languages/SV.cfg
===================================================================
--- trunk/res_noewe/languages/SV.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/SV.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID,CHIRP / tr&#195;&#165;dl&#195;&#182;s utrustning
 2683 = Ingen akut
 2684 = F&#195;&#182;rsta hj&#195;&#164;lpen i n&#195;&#164;rheten
+2685 = inte sponsras
+2686 = sponsrade
 3000=St&#195;&#164;ng
 4000=Loaded cachar:+
 4001=GPX filer fr&#195;&#165;n opencaching inte inneh&#195;&#165;ller n&#195;&#165;gon information av bilder, kan de inte laoded. B&#195;&#164;st du cachar fr&#195;&#165;n opencaching genom menyn / Application / Import / Download fr&#195;&#165;n Opencaching

Modified: trunk/src/CacheWolf/Attribute.java
===================================================================
--- trunk/src/CacheWolf/Attribute.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/Attribute.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.mImage;
@@ -30,332 +30,372 @@
 
 /**
  * This class represents a single attribute
+ * 
  * @author skg
- *
+ * 
  */
 public class Attribute {
 	// Constructors
-	public Attribute(int id, int inc) {_Id=id;setInc(inc);setIdBit();}
-	public Attribute(String attributeName) { attName2attNo(attributeName); setIdBit();}
-	public Attribute(int attIdOC) { OCAttNo2attNo(attIdOC); setIdBit();}
-	public Attribute(int attIdGC, String Yes1No0) { GCAttNo2attNo(attIdGC, Yes1No0); setIdBit();}
+	public Attribute(int id, int inc) {
+		_Id = id;
+		setInc(inc);
+		setIdBit();
+	}
+
+	public Attribute(String attributeName) {
+		attName2attNo(attributeName);
+		setIdBit();
+	}
+
+	public Attribute(int attIdOC) {
+		OCAttNo2attNo(attIdOC);
+		setIdBit();
+	}
+
+	public Attribute(int attIdGC, String Yes1No0) {
+		GCAttNo2attNo(attIdGC, Yes1No0);
+		setIdBit();
+	}
+
 	// Constructors end
 	private int _Id;
 	private int _Inc; // Yes=1 No=0 non=2
 	private String _ImageName;
-	private long[] _bit = {0l,0l};
+	private long[] _bit = { 0l, 0l };
+
 	// for GC Constructor Spider
 	private void attName2attNo(String attributeName) {
-    	for (int i=0; i&lt;maxAttRef; i++) {
-    		if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
-				_Id=i;
-				_Inc=attributeName.toLowerCase().endsWith(&quot;-no.gif&quot;) ? 0 : 1;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
+				_Id = i;
+				_Inc = attributeName.toLowerCase().endsWith(&quot;-no.gif&quot;) ? 0 : 1;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName=&quot;error.gif&quot;;
-    	}
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = &quot;error.gif&quot;;
+	}
+
 	// for OC Constructor
-    private void OCAttNo2attNo(int attIdOC) {
-    	for (int i=0; i&lt;maxAttRef; i++) {
-    		if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
-				_Id=i;
-				_Inc=1;
-				_ImageName=attRef[i][PIC_NAME]+&quot;-yes.gif&quot;;
+	private void OCAttNo2attNo(int attIdOC) {
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
+				_Id = i;
+				_Inc = 1;
+				_ImageName = attRef[i][PIC_NAME] + &quot;-yes.gif&quot;;
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName=&quot;error.gif&quot;;
-    }
-    // for GC Constructor gpx-Import
-    private void GCAttNo2attNo(int attIdGC, String Yes1No0 ) {
-    	for (int i=0; i&lt;maxAttRef; i++) {
-    		if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
-				_Id=i;
-    			_Inc=Yes1No0.equals(&quot;1&quot;) ? 1 : 0;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
-				return;				
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName=&quot;error.gif&quot;;
-    }
-    // used by all Constructors
-    private void setIdBit() {
-    	_bit=getIdBit(_Id);
-    }
-    // checking for array limits (caus -1 is possible value)
-    private static String attRef(int row, int column ) {
-    	if (row &gt; -1 &amp;&amp; row &lt; maxAttRef) {
-    		return attRef[row][column];
-    	}
-    	else {
-    		return &quot;&quot;;
-    	}
-    }
-    // *** public part
-    public static long[] getIdBit(int id) {
-    	long [] bit = new long[2];
-    	if (id&gt;-1 &amp;&amp; id&lt;maxAttRef) {
-        	int b = Common.parseInt(attRef[id][BIT_NR]);
-    		bit[0] = b&gt;63 ? 0l : (1L &lt;&lt; b);
-    		bit[1] = b&gt;63 ? (1L &lt;&lt; b-64) : 0;
-    	}
-    	else {
-        	bit[0]=0;
-        	bit[1]=0;
-    	}
-    	return bit;
-    }    
-    /**
-     * get GC_TEXT string
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = &quot;error.gif&quot;;
+	}
+
+	// for GC Constructor gpx-Import
+	private void GCAttNo2attNo(int attIdGC, String Yes1No0) {
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
+				_Id = i;
+				_Inc = Yes1No0.equals(&quot;1&quot;) ? 1 : 0;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
+				return;
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = &quot;error.gif&quot;;
+	}
+
+	// used by all Constructors
+	private void setIdBit() {
+		_bit = getIdBit(_Id);
+	}
+
+	// checking for array limits (caus -1 is possible value)
+	private static String attRef(int row, int column) {
+		if (row &gt; -1 &amp;&amp; row &lt; maxAttRef) {
+			return attRef[row][column];
+		} else {
+			return &quot;&quot;;
+		}
+	}
+
+	// *** public part
+	public static long[] getIdBit(int id) {
+		long[] bit = new long[2];
+		if (id &gt; -1 &amp;&amp; id &lt; maxAttRef) {
+			int b = Common.parseInt(attRef[id][BIT_NR]);
+			bit[0] = b &gt; 63 ? 0l : (1L &lt;&lt; b);
+			bit[1] = b &gt; 63 ? (1L &lt;&lt; b - 64) : 0;
+		} else {
+			bit[0] = 0;
+			bit[1] = 0;
+		}
+		return bit;
+	}
+
+	/**
+	 * get GC_TEXT string
 	 */
-    public String getGCText () { return attRef(_Id,GC_TEXT); }
-    /*
+	public String getGCText() {
+		return attRef(_Id, GC_TEXT);
+	}
+
+	/*
      * 
      */
-    public static String getIdFromGCText(String t) {
-    	for (int i = 0; i &lt; maxAttRef; i++) {
-    		if 	(attRef[i] [GC_TEXT].equals(t)) {
-    			return attRef[i][GC_ID];
-    		}
-    	}
-    	return &quot;-1&quot;;
-    }
-    /**
-     * get GC_ID string
+	public static String getIdFromGCText(String t) {
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attRef[i][GC_TEXT].equals(t)) {
+				return attRef[i][GC_ID];
+			}
+		}
+		return &quot;-1&quot;;
+	}
+
+	/**
+	 * get GC_ID string
 	 */
-    public String getGCId () { return attRef(_Id,GC_ID); }
-    /**
-     * getting attribute given=1,negative=0,not specified=2  
-     */
-	public int getInc () { return _Inc; }
-    /**
-     * getting CW internal attribute number (-1..127)  
-     */
-	public int getId () { return _Id; }
-    /**
-     * setting/changing attribute given=1,negative=0,not specified=2  
-     */
-    public void setInc(int inc) {
-    	_Inc=inc;
-    	if (_Id&lt;0 || _Id&gt;=maxAttRef) {
-    		_ImageName=&quot;error.gif&quot;;
-    	}
-    	else {
-    		_ImageName=attRef(_Id,PIC_NAME);
-    		if (inc==0) _ImageName+=&quot;-no.gif&quot;;
-    		else if (inc==1) _ImageName+=&quot;-yes.gif&quot;;
-    		else _ImageName+=&quot;-non.gif&quot;;
-    	}
-    }
-    /**
-     * getting name of corresponding image stored in attributes subdirectory 
-     */
-    public String getImageName() {
-    	return _ImageName;
-    }   
-    /**
-     * getting path+name of corresponding image stored in attributes subdirectory 
-     */
-    public String getPathAndImageName() {
-    	return IMAGEDIR+_ImageName;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getYesBit(long[] yes) {
-    	if (_Inc==1) {
-    		yes[0]|=_bit[0];
-    		yes[1]|=_bit[1];    		
-    	}
-    	else {
-    		yes[0]&amp;=~_bit[0];
-    		yes[1]&amp;=~_bit[1];    		
-    	}
-    	return yes;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getNoBit(long[] no) {
-    	if (_Inc==0) {
-    		no[0]|=_bit[0];
-    		no[1]|=_bit[1];
-    	}
-    	else {
-    		no[0]&amp;=~_bit[0];
-    		no[1]&amp;=~_bit[1];    		
-    	}
-    	return no;
-    }
-    /**
-     * get the language dependant description of the attribute  
-     */
-    public String getMsg() {
-    	return getMsg(_Id,_Inc);
-    }
-	
-	private final static int BIT_NR = 0; 
+	public String getGCId() {
+		return attRef(_Id, GC_ID);
+	}
+
+	/**
+	 * getting attribute given=1,negative=0,not specified=2
+	 */
+	public int getInc() {
+		return _Inc;
+	}
+
+	/**
+	 * getting CW internal attribute number (-1..127)
+	 */
+	public int getId() {
+		return _Id;
+	}
+
+	/**
+	 * setting/changing attribute given=1,negative=0,not specified=2
+	 */
+	public void setInc(int inc) {
+		_Inc = inc;
+		if (_Id &lt; 0 || _Id &gt;= maxAttRef) {
+			_ImageName = &quot;error.gif&quot;;
+		} else {
+			_ImageName = attRef(_Id, PIC_NAME);
+			if (inc == 0)
+				_ImageName += &quot;-no.gif&quot;;
+			else if (inc == 1)
+				_ImageName += &quot;-yes.gif&quot;;
+			else
+				_ImageName += &quot;-non.gif&quot;;
+		}
+	}
+
+	/**
+	 * getting name of corresponding image stored in attributes subdirectory
+	 */
+	public String getImageName() {
+		return _ImageName;
+	}
+
+	/**
+	 * getting path+name of corresponding image stored in attributes subdirectory
+	 */
+	public String getPathAndImageName() {
+		return IMAGEDIR + _ImageName;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getYesBit(long[] yes) {
+		if (_Inc == 1) {
+			yes[0] |= _bit[0];
+			yes[1] |= _bit[1];
+		} else {
+			yes[0] &amp;= ~_bit[0];
+			yes[1] &amp;= ~_bit[1];
+		}
+		return yes;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getNoBit(long[] no) {
+		if (_Inc == 0) {
+			no[0] |= _bit[0];
+			no[1] |= _bit[1];
+		} else {
+			no[0] &amp;= ~_bit[0];
+			no[1] &amp;= ~_bit[1];
+		}
+		return no;
+	}
+
+	/**
+	 * get the language dependant description of the attribute
+	 */
+	public String getMsg() {
+		return getMsg(_Id, _Inc);
+	}
+
+	private final static int BIT_NR = 0;
 	private final static int MSG_NR = 1;
 	private final static int PIC_NAME = 2;
 	private final static int OC_ID = 3; // OC - XML
 	private final static int GC_ID = 4; // auch OC neues gpx
-	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum	
-	private static final String[][] attRef = {
-		{&quot;00&quot;,&quot;2502&quot;,&quot;available&quot;,&quot;38&quot;,&quot;13&quot;,&quot;Available at all times&quot;},//02 available 24-7
-		{&quot;01&quot;,&quot;2504&quot;,&quot;bicycles&quot;,&quot;0&quot;,&quot;32&quot;,&quot;Bicycles&quot;},//04 bikes allowed
-		{&quot;02&quot;,&quot;2506&quot;,&quot;boat&quot;,&quot;52&quot;,&quot;4&quot;,&quot;Boat&quot;},//06 Wasserfahrzeug
-		// {&quot;03&quot;,&quot;2508&quot;,&quot;cactus&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;},//08 removed 14.08.10 araber95
-		{&quot;04&quot;,&quot;2510&quot;,&quot;campfires&quot;,&quot;0&quot;,&quot;38&quot;,&quot;Campfires&quot;},//10 campfires allowed
-		{&quot;05&quot;,&quot;2512&quot;,&quot;camping&quot;,&quot;0&quot;,&quot;31&quot;,&quot;Camping available&quot;},//12 Camping allowed
-		{&quot;06&quot;,&quot;2514&quot;,&quot;cliff&quot;,&quot;11&quot;,&quot;21&quot;,&quot;Cliff / falling rocks&quot;},//14 falling-rocks nearby
-		{&quot;07&quot;,&quot;2516&quot;,&quot;climbing&quot;,&quot;28&quot;,&quot;10&quot;,&quot;Difficult climbing&quot;},//16 easy climbing(OC-28), difficult climbing(GC-10) 
-		{&quot;08&quot;,&quot;2518&quot;,&quot;compass&quot;,&quot;47&quot;,&quot;147&quot;,&quot;Compass&quot;}, //OC special
-		{&quot;09&quot;,&quot;2520&quot;,&quot;cow&quot;,&quot;0&quot;,&quot;43&quot;,&quot;Watch for livestock&quot;},//20 watch for livestock
-		{&quot;10&quot;,&quot;2522&quot;,&quot;danger&quot;,&quot;9&quot;,&quot;23&quot;,&quot;Dangerous area&quot;},//22 dangerous area
-		{&quot;11&quot;,&quot;2524&quot;,&quot;dogs&quot;,&quot;0&quot;,&quot;1&quot;,&quot;Dogs&quot;},//24 dogs allowed
-		{&quot;12&quot;,&quot;2526&quot;,&quot;fee&quot;,&quot;36&quot;,&quot;2&quot;,&quot;Access or parking fee&quot;},//26 access/parking fees
-		// {&quot;13&quot;,&quot;2528&quot;,&quot;hiking&quot;,&quot;0&quot;,&quot;9&quot;,&quot;Significant hike&quot;},//28 significant hike : removed
-		{&quot;13&quot;,&quot;2528&quot;,&quot;hiking&quot;,&quot;25&quot;,&quot;125&quot;,&quot;Long walk&quot;}, //OC special
-		{&quot;14&quot;,&quot;2530&quot;,&quot;horses&quot;,&quot;0&quot;,&quot;37&quot;,&quot;Horses&quot;},//30 horses allowed
-		{&quot;15&quot;,&quot;2532&quot;,&quot;hunting&quot;,&quot;12&quot;,&quot;22&quot;,&quot;Hunting&quot;},//32 hunting area
-		{&quot;16&quot;,&quot;2534&quot;,&quot;jeeps&quot;,&quot;0&quot;,&quot;35&quot;,&quot;Off-road vehicles&quot;},//34 off-road vehicles allowed
-		{&quot;17&quot;,&quot;2536&quot;,&quot;kids&quot;,&quot;59&quot;,&quot;6&quot;,&quot;Recommended for kids&quot;},//36 kid friendly
-		{&quot;18&quot;,&quot;2538&quot;,&quot;mine&quot;,&quot;15&quot;,&quot;20&quot;,&quot;Abandoned mines&quot;},//38
-		{&quot;19&quot;,&quot;2540&quot;,&quot;motorcycles&quot;,&quot;0&quot;,&quot;33&quot;,&quot;Motorcycles&quot;},//40 motorcycles allowed
-		{&quot;20&quot;,&quot;2542&quot;,&quot;night&quot;,&quot;1&quot;,&quot;14&quot;,&quot;Recommended at night&quot;},//42 recommended at night
-		{&quot;21&quot;,&quot;2544&quot;,&quot;onehour&quot;,&quot;0&quot;,&quot;7&quot;,&quot;Takes less than an hour&quot;},//44 takes less than one hour
-		{&quot;22&quot;,&quot;2546&quot;,&quot;parking&quot;,&quot;18&quot;,&quot;25&quot;,&quot;Parking available&quot;},//46 parking available
-		{&quot;23&quot;,&quot;2548&quot;,&quot;phone&quot;,&quot;22&quot;,&quot;29&quot;,&quot;Telephone nearby&quot;},//48 telephone nearby
-		{&quot;24&quot;,&quot;2550&quot;,&quot;picnic&quot;,&quot;0&quot;,&quot;30&quot;,&quot;Picnic tables nearby&quot;},//50 picnic tables available
-		{&quot;25&quot;,&quot;2552&quot;,&quot;poisonoak&quot;,&quot;16&quot;,&quot;17&quot;,&quot;Poison plants&quot;},//52 Giftige Pflanzen
-		{&quot;26&quot;,&quot;2554&quot;,&quot;public&quot;,&quot;19&quot;,&quot;26&quot;,&quot;Public transportation&quot;},//54 public transit available
-		{&quot;27&quot;,&quot;2556&quot;,&quot;quads&quot;,&quot;0&quot;,&quot;34&quot;,&quot;Quads&quot;},//56 quads allowed
-		{&quot;28&quot;,&quot;2558&quot;,&quot;rappelling&quot;,&quot;49&quot;,&quot;3&quot;,&quot;Climbing gear&quot;},//58 climbing gear Kletterausr&#252;stung
-		{&quot;29&quot;,&quot;2560&quot;,&quot;restrooms&quot;,&quot;21&quot;,&quot;28&quot;,&quot;Public restrooms nearby&quot;},//60 restrooms available
-		{&quot;30&quot;,&quot;2562&quot;,&quot;scenic&quot;,&quot;0&quot;,&quot;8&quot;,&quot;Scenic view&quot;},//62 scenic view
-		{&quot;31&quot;,&quot;2564&quot;,&quot;scuba&quot;,&quot;51&quot;,&quot;5&quot;,&quot;Scuba gear&quot;},//64 Tauchausr&#252;stung
-		// {&quot;32&quot;,&quot;2566&quot;,&quot;snakes&quot;,&quot;0&quot;,&quot;18&quot;,&quot;Snakes&quot;},//66 araber95 replaced by Dangerous Animals 14.08.10
-		{&quot;32&quot;,&quot;2566&quot;,&quot;dangerousanimals&quot;,&quot;0&quot;,&quot;18&quot;,&quot;Dangerous Animals&quot;},//66
-		{&quot;33&quot;,&quot;2568&quot;,&quot;snowmobiles&quot;,&quot;0&quot;,&quot;36&quot;,&quot;Snowmobiles&quot;},//68
-		{&quot;34&quot;,&quot;2570&quot;,&quot;stealth&quot;,&quot;0&quot;,&quot;40&quot;,&quot;Stealth required&quot;},//70 stealth required (Heimlich,List,Schl&#228;ue)
-		{&quot;35&quot;,&quot;2572&quot;,&quot;stroller&quot;,&quot;0&quot;,&quot;41&quot;,&quot;Stroller accessible&quot;},//72 stroller accessible	
-		{&quot;36&quot;,&quot;2574&quot;,&quot;swimming&quot;,&quot;29&quot;,&quot;12&quot;,&quot;May require swimming&quot;},//74
-		{&quot;37&quot;,&quot;2576&quot;,&quot;thorn&quot;,&quot;13&quot;,&quot;39&quot;,&quot;Thorns&quot;},//76 thorns!
-		{&quot;38&quot;,&quot;2578&quot;,&quot;ticks&quot;,&quot;14&quot;,&quot;19&quot;,&quot;Ticks&quot;},//78 ticks!
-		{&quot;39&quot;,&quot;2580&quot;,&quot;wading&quot;,&quot;26&quot;,&quot;11&quot;,&quot;May require wading&quot;},//80 may require wading
-		{&quot;40&quot;,&quot;2582&quot;,&quot;water&quot;,&quot;20&quot;,&quot;27&quot;,&quot;Drinking water nearby&quot;},//82 drinking water nearby
-		{&quot;41&quot;,&quot;2584&quot;,&quot;wheelchair&quot;,&quot;0&quot;,&quot;24&quot;,&quot;Wheelchair accessible&quot;},//84 wheelchair accessible
-		{&quot;42&quot;,&quot;2586&quot;,&quot;winter&quot;,&quot;44&quot;,&quot;15&quot;,&quot;Available during winter&quot;},//86 available in winter 132 Schneesicheres Versteck
-		{&quot;43&quot;,&quot;2588&quot;,&quot;firstaid&quot;,&quot;0&quot;,&quot;42&quot;,&quot;Firstaid&quot;}, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe 
-		{&quot;44&quot;,&quot;2590&quot;,&quot;flashlight&quot;,&quot;48&quot;,&quot;44&quot;,&quot;Flashlight required&quot;}, // 90 Flashlight required
-		{&quot;45&quot;,&quot;2592&quot;,&quot;aircraft&quot;,&quot;53&quot;,&quot;153&quot;,&quot;Aircraft&quot;}, //OC special //38 GC removed
-		{&quot;46&quot;,&quot;2594&quot;,&quot;animals&quot;,&quot;17&quot;,&quot;0&quot;,&quot;&quot;},// 94 Giftige/gef%e4hrliche Tiere
-		{&quot;47&quot;,&quot;2596&quot;,&quot;arith_prob&quot;,&quot;56&quot;,&quot;156&quot;,&quot;Arithmetical problem&quot;}, //OC special
-		{&quot;48&quot;,&quot;2598&quot;,&quot;ask&quot;,&quot;58&quot;,&quot;158&quot;,&quot;Ask owner for start conditions&quot;}, //OC special
-		{&quot;49&quot;,&quot;2600&quot;,&quot;car&quot;,&quot;24&quot;,&quot;0&quot;,&quot;&quot;},// 100 Nahe beim Auto
-		{&quot;50&quot;,&quot;2602&quot;,&quot;cave&quot;,&quot;50&quot;,&quot;150&quot;,&quot;Cave equipment&quot;}, //OC special
-		{&quot;51&quot;,&quot;2604&quot;,&quot;date&quot;,&quot;42&quot;,&quot;142&quot;,&quot;All seasons&quot;}, //OC special
-		{&quot;52&quot;,&quot;2606&quot;,&quot;day&quot;,&quot;40&quot;,&quot;140&quot;,&quot;by day only&quot;}, //OC special 
-		{&quot;53&quot;,&quot;2608&quot;,&quot;indoor&quot;,&quot;33&quot;,&quot;133&quot;,&quot;Within enclosed rooms (caves, buildings etc.)&quot;}, //OC special
-		{&quot;54&quot;,&quot;2610&quot;,&quot;interestsign&quot;,&quot;30&quot;,&quot;130&quot;,&quot;Point of interest&quot;}, //OC special
-		{&quot;55&quot;,&quot;2612&quot;,&quot;letter&quot;,&quot;8&quot;,&quot;108&quot;,&quot;Letterbox (needs stamp)&quot;}, //OC special
-		{&quot;56&quot;,&quot;2614&quot;,&quot;moving&quot;,&quot;31&quot;,&quot;131&quot;,&quot;Moving target&quot;}, //OC special
-		{&quot;57&quot;,&quot;2616&quot;,&quot;naturschutz&quot;,&quot;43&quot;,&quot;143&quot;,&quot;Breeding season / protected nature&quot;}, //OC special
-		{&quot;58&quot;,&quot;2618&quot;,&quot;nogps&quot;,&quot;35&quot;,&quot;135&quot;,&quot;Without GPS (letterboxes, cistes, compass juggling ...)&quot;}, //OC special
-		{&quot;59&quot;,&quot;2620&quot;,&quot;oconly&quot;,&quot;6&quot;,&quot;106&quot;,&quot;Only loggable at Opencaching&quot;},// 120 Nur bei Opencaching logbar
-		{&quot;60&quot;,&quot;2622&quot;,&quot;othercache&quot;,&quot;57&quot;,&quot;157&quot;,&quot;Other cache type&quot;}, //OC special
-		{&quot;61&quot;,&quot;2624&quot;,&quot;overnight&quot;,&quot;37&quot;,&quot;137&quot;,&quot;Overnight stay necessary&quot;}, //OC special
-		{&quot;62&quot;,&quot;2644&quot;,&quot;train&quot;,&quot;10&quot;,&quot;110&quot;,&quot;Active railway nearby&quot;}, //OC special
-		{&quot;63&quot;,&quot;2630&quot;,&quot;riddle&quot;,&quot;55&quot;,&quot;0&quot;,&quot;&quot;},// 130 R&#228;tsel
-		{&quot;64&quot;,&quot;2646&quot;,&quot;webcam&quot;,&quot;32&quot;,&quot;132&quot;,&quot;Webcam&quot;}, //OC special
-		{&quot;65&quot;,&quot;2634&quot;,&quot;steep&quot;,&quot;27&quot;,&quot;127&quot;,&quot;Hilly area&quot;}, //OC special
-		{&quot;66&quot;,&quot;2636&quot;,&quot;submerged&quot;,&quot;34&quot;,&quot;134&quot;,&quot;In the water&quot;}, //OC special
-		{&quot;67&quot;,&quot;2638&quot;,&quot;tide&quot;,&quot;41&quot;,&quot;141&quot;,&quot;Tide&quot;}, //OC special
-		{&quot;68&quot;,&quot;2640&quot;,&quot;time&quot;,&quot;39&quot;,&quot;139&quot;,&quot;Only available at specified times&quot;}, //OC special
-		{&quot;69&quot;,&quot;2642&quot;,&quot;tools&quot;,&quot;46&quot;,&quot;0&quot;,&quot;Special Tool required&quot;},// 142 Spezielle Ausr&#252;stung
-		{&quot;70&quot;,&quot;2648&quot;,&quot;wiki&quot;,&quot;54&quot;,&quot;154&quot;,&quot;Investigation&quot;}, //OC special
-		{&quot;71&quot;,&quot;2650&quot;,&quot;wwwlink&quot;,&quot;7&quot;,&quot;107&quot;,&quot;Hyperlink to another caching portal only&quot;}, //OC special
-		{&quot;72&quot;,&quot;2652&quot;,&quot;landf&quot;,&quot;0&quot;,&quot;45&quot;,&quot;Lost And Found Tour&quot;}, // thx to Kappler and MiK
-		{&quot;73&quot;,&quot;2654&quot;,&quot;rv&quot;,&quot;0&quot;,&quot;46&quot;,&quot;Truck Driver/RV&quot;},// changed by Moorteufel 12.07.10 
-		{&quot;74&quot;,&quot;2656&quot;,&quot;field_puzzle&quot;,&quot;0&quot;,&quot;47&quot;,&quot;Field Puzzle&quot;},// changed by Moorteufel 12.07.10
-		{&quot;75&quot;,&quot;2658&quot;,&quot;uv&quot;,&quot;0&quot;,&quot;48&quot;,&quot;UV Light required&quot;}, // added by araber95 14.8.10
-		{&quot;76&quot;,&quot;2660&quot;,&quot;snowshoes&quot;,&quot;0&quot;,&quot;49&quot;,&quot;Snowshoes&quot;}, // added by araber95 14.8.10&quot;
-		{&quot;77&quot;,&quot;2662&quot;,&quot;skiis&quot;,&quot;0&quot;,&quot;50&quot;,&quot;Cross Country Skis&quot;}, // added by araber95 14.8.10
-		{&quot;78&quot;,&quot;2664&quot;,&quot;s-tool&quot;,&quot;0&quot;,&quot;51&quot;,&quot;Special Tool required&quot;}, // added by araber95 14.8.10
-		{&quot;79&quot;,&quot;2666&quot;,&quot;nightcache&quot;,&quot;0&quot;,&quot;52&quot;,&quot;Night Cache&quot;}, // added by araber95 14.8.10
-		{&quot;80&quot;,&quot;2668&quot;,&quot;parkngrab&quot;,&quot;0&quot;,&quot;53&quot;,&quot;Park and grab&quot;}, // added by araber95 14.8.10
-		{&quot;81&quot;,&quot;2670&quot;,&quot;abandonedbuilding&quot;,&quot;0&quot;,&quot;54&quot;,&quot;Abandoned structure&quot;}, // added by araber95 14.8.10
-		{&quot;82&quot;,&quot;2672&quot;,&quot;hike_short&quot;,&quot;0&quot;,&quot;55&quot;,&quot;Short hike&quot;}, // added by araber95 14.8.10
-		{&quot;83&quot;,&quot;2674&quot;,&quot;hike_med&quot;,&quot;0&quot;,&quot;56&quot;,&quot;Medium Hike&quot;}, // added by araber95 14.8.10
-		{&quot;84&quot;,&quot;2676&quot;,&quot;hike_long&quot;,&quot;0&quot;,&quot;57&quot;,&quot;Long Hike&quot;}, // added by araber95 14.8.10
-		{&quot;85&quot;,&quot;2678&quot;,&quot;fuel&quot;,&quot;0&quot;,&quot;58&quot;,&quot;Fuel nearby&quot;}, // changed by araber95 14.08.10 
-		{&quot;86&quot;,&quot;2680&quot;,&quot;food&quot;,&quot;0&quot;,&quot;59&quot;,&quot;Food nearby&quot;}, // changed by araber95 14.08.10
-		{&quot;87&quot;,&quot;2681&quot;,&quot;wirelessbeacon&quot;,&quot;0&quot;,&quot;60&quot;,&quot;Wireless Beacon&quot;}, // added by araber95 27.10.10		
-		{&quot;88&quot;,&quot;2588&quot;,&quot;firstaid&quot;,&quot;23&quot;,&quot;123&quot;,&quot;First aid available&quot;}, //OC special
-		// {&quot;-1&quot;,&quot;2500&quot;,&quot;error&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;}, //
+	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum
+	private static final String[][] attRef = { { &quot;00&quot;, &quot;2502&quot;, &quot;available&quot;, &quot;38&quot;, &quot;13&quot;, &quot;Available at all times&quot; },// 02 available 24-7
+			{ &quot;01&quot;, &quot;2504&quot;, &quot;bicycles&quot;, &quot;0&quot;, &quot;32&quot;, &quot;Bicycles&quot; },// 04 bikes allowed
+			{ &quot;02&quot;, &quot;2506&quot;, &quot;boat&quot;, &quot;52&quot;, &quot;4&quot;, &quot;Boat&quot; },// 06 Wasserfahrzeug
+			// {&quot;03&quot;,&quot;2508&quot;,&quot;cactus&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;},//08 removed 14.08.10 araber95
+			{ &quot;04&quot;, &quot;2510&quot;, &quot;campfires&quot;, &quot;0&quot;, &quot;38&quot;, &quot;Campfires&quot; },// 10 campfires allowed
+			{ &quot;05&quot;, &quot;2512&quot;, &quot;camping&quot;, &quot;0&quot;, &quot;31&quot;, &quot;Camping available&quot; },// 12 Camping allowed
+			{ &quot;06&quot;, &quot;2514&quot;, &quot;cliff&quot;, &quot;11&quot;, &quot;21&quot;, &quot;Cliff / falling rocks&quot; },// 14 falling-rocks nearby
+			{ &quot;07&quot;, &quot;2516&quot;, &quot;climbing&quot;, &quot;28&quot;, &quot;10&quot;, &quot;Difficult climbing&quot; },// 16 easy climbing(OC-28), difficult climbing(GC-10)
+			{ &quot;08&quot;, &quot;2518&quot;, &quot;compass&quot;, &quot;47&quot;, &quot;147&quot;, &quot;Compass&quot; }, // OC special
+			{ &quot;09&quot;, &quot;2520&quot;, &quot;cow&quot;, &quot;0&quot;, &quot;43&quot;, &quot;Watch for livestock&quot; },// 20 watch for livestock
+			{ &quot;10&quot;, &quot;2522&quot;, &quot;danger&quot;, &quot;9&quot;, &quot;23&quot;, &quot;Dangerous area&quot; },// 22 dangerous area
+			{ &quot;11&quot;, &quot;2524&quot;, &quot;dogs&quot;, &quot;0&quot;, &quot;1&quot;, &quot;Dogs&quot; },// 24 dogs allowed
+			{ &quot;12&quot;, &quot;2526&quot;, &quot;fee&quot;, &quot;36&quot;, &quot;2&quot;, &quot;Access or parking fee&quot; },// 26 access/parking fees
+			// {&quot;13&quot;,&quot;2528&quot;,&quot;hiking&quot;,&quot;0&quot;,&quot;9&quot;,&quot;Significant hike&quot;},//28 significant hike : removed
+			{ &quot;13&quot;, &quot;2528&quot;, &quot;hiking&quot;, &quot;25&quot;, &quot;125&quot;, &quot;Long walk&quot; }, // OC special
+			{ &quot;14&quot;, &quot;2530&quot;, &quot;horses&quot;, &quot;0&quot;, &quot;37&quot;, &quot;Horses&quot; },// 30 horses allowed
+			{ &quot;15&quot;, &quot;2532&quot;, &quot;hunting&quot;, &quot;12&quot;, &quot;22&quot;, &quot;Hunting&quot; },// 32 hunting area
+			{ &quot;16&quot;, &quot;2534&quot;, &quot;jeeps&quot;, &quot;0&quot;, &quot;35&quot;, &quot;Off-road vehicles&quot; },// 34 off-road vehicles allowed
+			{ &quot;17&quot;, &quot;2536&quot;, &quot;kids&quot;, &quot;59&quot;, &quot;6&quot;, &quot;Recommended for kids&quot; },// 36 kid friendly
+			{ &quot;18&quot;, &quot;2538&quot;, &quot;mine&quot;, &quot;15&quot;, &quot;20&quot;, &quot;Abandoned mines&quot; },// 38
+			{ &quot;19&quot;, &quot;2540&quot;, &quot;motorcycles&quot;, &quot;0&quot;, &quot;33&quot;, &quot;Motorcycles&quot; },// 40 motorcycles allowed
+			{ &quot;20&quot;, &quot;2542&quot;, &quot;night&quot;, &quot;1&quot;, &quot;14&quot;, &quot;Recommended at night&quot; },// 42 recommended at night
+			{ &quot;21&quot;, &quot;2544&quot;, &quot;onehour&quot;, &quot;0&quot;, &quot;7&quot;, &quot;Takes less than an hour&quot; },// 44 takes less than one hour
+			{ &quot;22&quot;, &quot;2546&quot;, &quot;parking&quot;, &quot;18&quot;, &quot;25&quot;, &quot;Parking available&quot; },// 46 parking available
+			{ &quot;23&quot;, &quot;2548&quot;, &quot;phone&quot;, &quot;22&quot;, &quot;29&quot;, &quot;Telephone nearby&quot; },// 48 telephone nearby
+			{ &quot;24&quot;, &quot;2550&quot;, &quot;picnic&quot;, &quot;0&quot;, &quot;30&quot;, &quot;Picnic tables nearby&quot; },// 50 picnic tables available
+			{ &quot;25&quot;, &quot;2552&quot;, &quot;poisonoak&quot;, &quot;16&quot;, &quot;17&quot;, &quot;Poison plants&quot; },// 52 Giftige Pflanzen
+			{ &quot;26&quot;, &quot;2554&quot;, &quot;public&quot;, &quot;19&quot;, &quot;26&quot;, &quot;Public transportation&quot; },// 54 public transit available
+			{ &quot;27&quot;, &quot;2556&quot;, &quot;quads&quot;, &quot;0&quot;, &quot;34&quot;, &quot;Quads&quot; },// 56 quads allowed
+			{ &quot;28&quot;, &quot;2558&quot;, &quot;rappelling&quot;, &quot;49&quot;, &quot;3&quot;, &quot;Climbing gear&quot; },// 58 climbing gear Kletterausr&#252;stung
+			{ &quot;29&quot;, &quot;2560&quot;, &quot;restrooms&quot;, &quot;21&quot;, &quot;28&quot;, &quot;Public restrooms nearby&quot; },// 60 restrooms available
+			{ &quot;30&quot;, &quot;2562&quot;, &quot;scenic&quot;, &quot;0&quot;, &quot;8&quot;, &quot;Scenic view&quot; },// 62 scenic view
+			{ &quot;31&quot;, &quot;2564&quot;, &quot;scuba&quot;, &quot;51&quot;, &quot;5&quot;, &quot;Scuba gear&quot; },// 64 Tauchausr&#252;stung
+			// {&quot;32&quot;,&quot;2566&quot;,&quot;snakes&quot;,&quot;0&quot;,&quot;18&quot;,&quot;Snakes&quot;},//66 araber95 replaced by Dangerous Animals 14.08.10
+			{ &quot;32&quot;, &quot;2566&quot;, &quot;dangerousanimals&quot;, &quot;0&quot;, &quot;18&quot;, &quot;Dangerous Animals&quot; },// 66
+			{ &quot;33&quot;, &quot;2568&quot;, &quot;snowmobiles&quot;, &quot;0&quot;, &quot;36&quot;, &quot;Snowmobiles&quot; },// 68
+			{ &quot;34&quot;, &quot;2570&quot;, &quot;stealth&quot;, &quot;0&quot;, &quot;40&quot;, &quot;Stealth required&quot; },// 70 stealth required (Heimlich,List,Schl&#228;ue)
+			{ &quot;35&quot;, &quot;2572&quot;, &quot;stroller&quot;, &quot;0&quot;, &quot;41&quot;, &quot;Stroller accessible&quot; },// 72 stroller accessible
+			{ &quot;36&quot;, &quot;2574&quot;, &quot;swimming&quot;, &quot;29&quot;, &quot;12&quot;, &quot;May require swimming&quot; },// 74
+			{ &quot;37&quot;, &quot;2576&quot;, &quot;thorn&quot;, &quot;13&quot;, &quot;39&quot;, &quot;Thorns&quot; },// 76 thorns!
+			{ &quot;38&quot;, &quot;2578&quot;, &quot;ticks&quot;, &quot;14&quot;, &quot;19&quot;, &quot;Ticks&quot; },// 78 ticks!
+			{ &quot;39&quot;, &quot;2580&quot;, &quot;wading&quot;, &quot;26&quot;, &quot;11&quot;, &quot;May require wading&quot; },// 80 may require wading
+			{ &quot;40&quot;, &quot;2582&quot;, &quot;water&quot;, &quot;20&quot;, &quot;27&quot;, &quot;Drinking water nearby&quot; },// 82 drinking water nearby
+			{ &quot;41&quot;, &quot;2584&quot;, &quot;wheelchair&quot;, &quot;0&quot;, &quot;24&quot;, &quot;Wheelchair accessible&quot; },// 84 wheelchair accessible
+			{ &quot;42&quot;, &quot;2586&quot;, &quot;winter&quot;, &quot;44&quot;, &quot;15&quot;, &quot;Available during winter&quot; },// 86 available in winter 132 Schneesicheres Versteck
+			{ &quot;43&quot;, &quot;2588&quot;, &quot;firstaid&quot;, &quot;0&quot;, &quot;42&quot;, &quot;Firstaid&quot; }, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe
+			{ &quot;44&quot;, &quot;2590&quot;, &quot;flashlight&quot;, &quot;48&quot;, &quot;44&quot;, &quot;Flashlight required&quot; }, // 90 Flashlight required
+			{ &quot;45&quot;, &quot;2592&quot;, &quot;aircraft&quot;, &quot;53&quot;, &quot;153&quot;, &quot;Aircraft&quot; }, // OC special //38 GC removed
+			{ &quot;46&quot;, &quot;2594&quot;, &quot;animals&quot;, &quot;17&quot;, &quot;0&quot;, &quot;&quot; },// 94 Giftige/gef%e4hrliche Tiere
+			{ &quot;47&quot;, &quot;2596&quot;, &quot;arith_prob&quot;, &quot;56&quot;, &quot;156&quot;, &quot;Arithmetical problem&quot; }, // OC special
+			{ &quot;48&quot;, &quot;2598&quot;, &quot;ask&quot;, &quot;58&quot;, &quot;158&quot;, &quot;Ask owner for start conditions&quot; }, // OC special
+			{ &quot;49&quot;, &quot;2600&quot;, &quot;car&quot;, &quot;24&quot;, &quot;0&quot;, &quot;&quot; },// 100 Nahe beim Auto
+			{ &quot;50&quot;, &quot;2602&quot;, &quot;cave&quot;, &quot;50&quot;, &quot;150&quot;, &quot;Cave equipment&quot; }, // OC special
+			{ &quot;51&quot;, &quot;2604&quot;, &quot;date&quot;, &quot;42&quot;, &quot;142&quot;, &quot;All seasons&quot; }, // OC special
+			{ &quot;52&quot;, &quot;2606&quot;, &quot;day&quot;, &quot;40&quot;, &quot;140&quot;, &quot;by day only&quot; }, // OC special
+			{ &quot;53&quot;, &quot;2608&quot;, &quot;indoor&quot;, &quot;33&quot;, &quot;133&quot;, &quot;Within enclosed rooms (caves, buildings etc.)&quot; }, // OC special
+			{ &quot;54&quot;, &quot;2610&quot;, &quot;interestsign&quot;, &quot;30&quot;, &quot;130&quot;, &quot;Point of interest&quot; }, // OC special
+			{ &quot;55&quot;, &quot;2612&quot;, &quot;letter&quot;, &quot;8&quot;, &quot;108&quot;, &quot;Letterbox (needs stamp)&quot; }, // OC special
+			{ &quot;56&quot;, &quot;2614&quot;, &quot;moving&quot;, &quot;31&quot;, &quot;131&quot;, &quot;Moving target&quot; }, // OC special
+			{ &quot;57&quot;, &quot;2616&quot;, &quot;naturschutz&quot;, &quot;43&quot;, &quot;143&quot;, &quot;Breeding season / protected nature&quot; }, // OC special
+			{ &quot;58&quot;, &quot;2618&quot;, &quot;nogps&quot;, &quot;35&quot;, &quot;135&quot;, &quot;Without GPS (letterboxes, cistes, compass juggling ...)&quot; }, // OC special
+			{ &quot;59&quot;, &quot;2620&quot;, &quot;oconly&quot;, &quot;6&quot;, &quot;106&quot;, &quot;Only loggable at Opencaching&quot; },// 120 Nur bei Opencaching logbar
+			{ &quot;60&quot;, &quot;2622&quot;, &quot;othercache&quot;, &quot;57&quot;, &quot;157&quot;, &quot;Other cache type&quot; }, // OC special
+			{ &quot;61&quot;, &quot;2624&quot;, &quot;overnight&quot;, &quot;37&quot;, &quot;137&quot;, &quot;Overnight stay necessary&quot; }, // OC special
+			{ &quot;62&quot;, &quot;2644&quot;, &quot;train&quot;, &quot;10&quot;, &quot;110&quot;, &quot;Active railway nearby&quot; }, // OC special
+			{ &quot;63&quot;, &quot;2630&quot;, &quot;riddle&quot;, &quot;55&quot;, &quot;0&quot;, &quot;&quot; },// 130 R&#228;tsel
+			{ &quot;64&quot;, &quot;2646&quot;, &quot;webcam&quot;, &quot;32&quot;, &quot;132&quot;, &quot;Webcam&quot; }, // OC special
+			{ &quot;65&quot;, &quot;2634&quot;, &quot;steep&quot;, &quot;27&quot;, &quot;127&quot;, &quot;Hilly area&quot; }, // OC special
+			{ &quot;66&quot;, &quot;2636&quot;, &quot;submerged&quot;, &quot;34&quot;, &quot;134&quot;, &quot;In the water&quot; }, // OC special
+			{ &quot;67&quot;, &quot;2638&quot;, &quot;tide&quot;, &quot;41&quot;, &quot;141&quot;, &quot;Tide&quot; }, // OC special
+			{ &quot;68&quot;, &quot;2640&quot;, &quot;time&quot;, &quot;39&quot;, &quot;139&quot;, &quot;Only available at specified times&quot; }, // OC special
+			{ &quot;69&quot;, &quot;2642&quot;, &quot;tools&quot;, &quot;46&quot;, &quot;0&quot;, &quot;Special Tool required&quot; },// 142 Spezielle Ausr&#252;stung
+			{ &quot;70&quot;, &quot;2648&quot;, &quot;wiki&quot;, &quot;54&quot;, &quot;154&quot;, &quot;Investigation&quot; }, // OC special
+			{ &quot;71&quot;, &quot;2650&quot;, &quot;wwwlink&quot;, &quot;7&quot;, &quot;107&quot;, &quot;Hyperlink to another caching portal only&quot; }, // OC special
+			{ &quot;72&quot;, &quot;2652&quot;, &quot;landf&quot;, &quot;0&quot;, &quot;45&quot;, &quot;Lost And Found Tour&quot; }, // thx to Kappler and MiK
+			{ &quot;73&quot;, &quot;2654&quot;, &quot;rv&quot;, &quot;0&quot;, &quot;46&quot;, &quot;Truck Driver/RV&quot; },// changed by Moorteufel 12.07.10
+			{ &quot;74&quot;, &quot;2656&quot;, &quot;field_puzzle&quot;, &quot;0&quot;, &quot;47&quot;, &quot;Field Puzzle&quot; },// changed by Moorteufel 12.07.10
+			{ &quot;75&quot;, &quot;2658&quot;, &quot;uv&quot;, &quot;0&quot;, &quot;48&quot;, &quot;UV Light required&quot; }, // added by araber95 14.8.10
+			{ &quot;76&quot;, &quot;2660&quot;, &quot;snowshoes&quot;, &quot;0&quot;, &quot;49&quot;, &quot;Snowshoes&quot; }, // added by araber95 14.8.10&quot;
+			{ &quot;77&quot;, &quot;2662&quot;, &quot;skiis&quot;, &quot;0&quot;, &quot;50&quot;, &quot;Cross Country Skis&quot; }, // added by araber95 14.8.10
+			{ &quot;78&quot;, &quot;2664&quot;, &quot;s-tool&quot;, &quot;0&quot;, &quot;51&quot;, &quot;Special Tool required&quot; }, // added by araber95 14.8.10
+			{ &quot;79&quot;, &quot;2666&quot;, &quot;nightcache&quot;, &quot;0&quot;, &quot;52&quot;, &quot;Night Cache&quot; }, // added by araber95 14.8.10
+			{ &quot;80&quot;, &quot;2668&quot;, &quot;parkngrab&quot;, &quot;0&quot;, &quot;53&quot;, &quot;Park and grab&quot; }, // added by araber95 14.8.10
+			{ &quot;81&quot;, &quot;2670&quot;, &quot;abandonedbuilding&quot;, &quot;0&quot;, &quot;54&quot;, &quot;Abandoned structure&quot; }, // added by araber95 14.8.10
+			{ &quot;82&quot;, &quot;2672&quot;, &quot;hike_short&quot;, &quot;0&quot;, &quot;55&quot;, &quot;Short hike&quot; }, // added by araber95 14.8.10
+			{ &quot;83&quot;, &quot;2674&quot;, &quot;hike_med&quot;, &quot;0&quot;, &quot;56&quot;, &quot;Medium Hike&quot; }, // added by araber95 14.8.10
+			{ &quot;84&quot;, &quot;2676&quot;, &quot;hike_long&quot;, &quot;0&quot;, &quot;57&quot;, &quot;Long Hike&quot; }, // added by araber95 14.8.10
+			{ &quot;85&quot;, &quot;2678&quot;, &quot;fuel&quot;, &quot;0&quot;, &quot;58&quot;, &quot;Fuel nearby&quot; }, // changed by araber95 14.08.10
+			{ &quot;86&quot;, &quot;2680&quot;, &quot;food&quot;, &quot;0&quot;, &quot;59&quot;, &quot;Food nearby&quot; }, // changed by araber95 14.08.10
+			{ &quot;87&quot;, &quot;2681&quot;, &quot;wirelessbeacon&quot;, &quot;0&quot;, &quot;60&quot;, &quot;Wireless Beacon&quot; }, // added by araber95 27.10.10
+			{ &quot;88&quot;, &quot;2588&quot;, &quot;firstaid&quot;, &quot;23&quot;, &quot;123&quot;, &quot;First aid available&quot; }, // OC special
+			{ &quot;89&quot;, &quot;2685&quot;, &quot;sponsored&quot;, &quot;0&quot;, &quot;61&quot;, &quot;Sponsored Cache&quot; },
+	// {&quot;-1&quot;,&quot;2500&quot;,&quot;error&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;}, //
 
 	};
-    public static int maxAttRef=attRef.length;	
-    private static String IMAGEDIR=STRreplace.replace(FileBase.getProgramDirectory()+&quot;/attributes/&quot;, &quot;//&quot;, &quot;/&quot;);
-    /*
-    private static String getImageName(int cw_Id, int cw_Inc){
-		if (cw_Id&lt;0 || cw_Id&gt;maxAttRef)
-			return &quot;error.gif&quot;;
-		else {
-			switch (cw_Inc) {
-			case 1: return attRef[cw_Id][PIC_NAME]+&quot;-yes.gif&quot;;
-			case 0: return attRef[cw_Id][PIC_NAME]+&quot;-no.gif&quot;;
-			case 2: return attRef[cw_Id][PIC_NAME]+&quot;-non.gif&quot;;
-			default:return &quot;error.gif&quot;;
-			}
+	public static int maxAttRef = attRef.length;
+	private static String IMAGEDIR = STRreplace.replace(FileBase.getProgramDirectory() + &quot;/attributes/&quot;, &quot;//&quot;, &quot;/&quot;);
+
+	/*
+	 * private static String getImageName(int cw_Id, int cw_Inc){ if (cw_Id&lt;0 || cw_Id&gt;maxAttRef) return &quot;error.gif&quot;; else { switch (cw_Inc) { case 1: return attRef[cw_Id][PIC_NAME]+&quot;-yes.gif&quot;; case 0: return attRef[cw_Id][PIC_NAME]+&quot;-no.gif&quot;; case 2:
+	 * return attRef[cw_Id][PIC_NAME]+&quot;-non.gif&quot;; default:return &quot;error.gif&quot;; } } }
+	 */
+	private static String getMsg(int cw_Id, int cw_Inc) {
+		if (cw_Id &lt; 0 || cw_Id &gt;= maxAttRef) {
+			return MyLocale.getMsg(2500, &quot;error attribute&quot;);
 		}
-	}
-	*/
-    private static String getMsg(int cw_Id, int cw_Inc){
-    	if (cw_Id&lt;0 || cw_Id&gt;=maxAttRef) {
-    		return MyLocale.getMsg(2500,&quot;error attribute&quot;);
-    	}
-		if (cw_Inc==0)
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR])-1,&quot;&quot;);
+		if (cw_Inc == 0)
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]) - 1, &quot;&quot;);
 		else
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]),&quot;&quot;);
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]), &quot;&quot;);
 	}
-    private static mImage[] yesImages=new mImage[maxAttRef];
-	private static mImage[] noImages=new mImage[maxAttRef];
-	private static mImage[] nonImages=new mImage[maxAttRef];
-	private static final mImage errorImage=new mImage(IMAGEDIR+&quot;error.gif&quot;);	
+
+	private static mImage[] yesImages = new mImage[maxAttRef];
+	private static mImage[] noImages = new mImage[maxAttRef];
+	private static mImage[] nonImages = new mImage[maxAttRef];
+	private static final mImage errorImage = new mImage(IMAGEDIR + &quot;error.gif&quot;);
+
 	/**
 	 * Returns the width of the attribute icons
-	 * @return The width of the images 
+	 * 
+	 * @return The width of the images
 	 */
 	public static int getImageWidth() {
 		return errorImage.image.getWidth();
-	}	
-    /**
-     * Get the image for a given attribute number. 
-     * We use lazy initialisation here, i.e. the images are only loaded when they are requested. 
-     * @return
-     */
-    public mImage getImage() {
-    	if (_Id&lt;0 || _Id&gt;=maxAttRef) {
-    		return errorImage;
-    	}
-    	if (_Inc==1) {
-    		if (yesImages[_Id]==null) {yesImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return yesImages[_Id];
-    	}
-    	else if (_Inc==0) {
-    		if (noImages[_Id]==null) {noImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return noImages[_Id];
-    	} 
-    	else {
-    		if (nonImages[_Id]==null) {nonImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return nonImages[_Id];
-    	}
-    }	
+	}
+
+	/**
+	 * Get the image for a given attribute number. We use lazy initialisation here, i.e. the images are only loaded when they are requested.
+	 * 
+	 * @return
+	 */
+	public mImage getImage() {
+		if (_Id &lt; 0 || _Id &gt;= maxAttRef) {
+			return errorImage;
+		}
+		if (_Inc == 1) {
+			if (yesImages[_Id] == null) {
+				yesImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return yesImages[_Id];
+		} else if (_Inc == 0) {
+			if (noImages[_Id] == null) {
+				noImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return noImages[_Id];
+		} else {
+			if (nonImages[_Id] == null) {
+				nonImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return nonImages[_Id];
+		}
+	}
 }

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.exp.Exporter;
@@ -45,12 +45,11 @@
 import ewe.util.Vector;
 
 /**
- *	A class to hold information on a cache.&lt;br&gt;
- *	Not all attributes are filled at once. You will have to look at other
- *	classes and methods to get more information.
- *	
+ * A class to hold information on a cache.&lt;br&gt;
+ * Not all attributes are filled at once. You will have to look at other classes and methods to get more information.
+ * 
  */
-public class CacheHolder{
+public class CacheHolder {
 	protected static final String NOBEARING = &quot;?&quot;;
 	protected static final String EMPTY = &quot;&quot;;
 
@@ -79,12 +78,12 @@
 	private String bearing = NOBEARING;
 	/** The angle (0=North, 180=South) from the current centre to this point */
 	public double degrees = 0;
-	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
+	/** The difficulty of the cache from 1 to 5 in .5 incements */
 	private byte hard = CacheTerrDiff.CW_DT_UNSET;
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
 	private byte terrain = CacheTerrDiff.CW_DT_UNSET;
-	/** The cache type (@see CacheType for translation table)  */
-	private byte type; 
+	/** The cache type (@see CacheType for translation table) */
+	private byte type;
 	/** True if the cache has been archived */
 	private boolean archived = false;
 	/** True if the cache is available for searching */
@@ -97,7 +96,7 @@
 	private boolean filtered = false;
 	/** True if the number of logs for this cache has changed */
 	private boolean log_updated = false;
-	/** True if cache details have changed: longDescription, Hints,  */
+	/** True if cache details have changed: longDescription, Hints, */
 	private boolean cache_updated = false;
 	/** True if the cache data is incomplete (e.g. an error occurred during spidering */
 	private boolean incomplete = false;
@@ -119,7 +118,7 @@
 	private int numRecommended = 0;
 	/** Number of Founds since start of recommendations system */
 	private int numFoundsSinceRecommendation = 0;
-	/** Recommendation score: calculated as rations  numRecommended / numLogsSinceRecommendation * 100 */
+	/** Recommendation score: calculated as rations numRecommended / numLogsSinceRecommendation * 100 */
 	public int recommendationScore = 0;
 	/** True if this cache has travelbugs */
 	private boolean bugs = false;
@@ -127,7 +126,7 @@
 	private boolean html = true;
 	/** List of additional waypoints associated with this waypoint */
 	public Vector addiWpts = new Vector();
-	/** in range is used by the route filter to identify caches in range of a segment*/
+	/** in range is used by the route filter to identify caches in range of a segment */
 	public boolean in_range = false;
 	/** If this is an additional waypoint, this links back to the main waypoint */
 	public CacheHolder mainCache;
@@ -138,304 +137,297 @@
 	/** True if a note is entered for the cache */
 	private boolean hasNote = false;
 	private CacheHolderDetail details = null;
-	/** When sorting the cacheDB this field is used. The relevant field is copied here and
-	 *  the sort is always done on this field to speed up the sorting process 
+	/**
+	 * When sorting the cacheDB this field is used. The relevant field is copied here and the sort is always done on this field to speed up the sorting process
 	 */
 	public String sort;
-	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
+	private static StringBuffer sb = new StringBuffer(530); // Used in toXML()
 
-	private long[] attributesBits = {0l,0l,0l,0l};
-	
+	private long[] attributesBits = { 0l, 0l, 0l, 0l };
+
 	private IconAndText iconAndTextWP = null;
 	private int iconAndTextWPLevel = 0;
 
-	static char decSep,notDecSep;
+	static char decSep, notDecSep;
 	static {
-		decSep=MyLocale.getDigSeparator().charAt(0);
-		notDecSep = (decSep == '.'?',':'.');
+		decSep = MyLocale.getDigSeparator().charAt(0);
+		notDecSep = (decSep == '.' ? ',' : '.');
 	}
 
 	public CacheHolder() {
 		// do nothing
 	}
-	
+
 	public CacheHolder(String wp) {
 		wayPoint = wp;
-		type=CacheType.CW_TYPE_ERROR;
-    }
-	
+		type = CacheType.CW_TYPE_ERROR;
+	}
+
 	public CacheHolder(String xmlString, int version) {
-		int start,end;
-	        try {
-				if (version == 1) {
-			        start = xmlString.indexOf('&quot;');
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        // Assume coordinates are in decimal format
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        pos = new CWPoint(lat, lon);
-			        LatLon = pos.toString();
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setDateHidden(xmlString.substring(start + 1, end));
-			        // Convert the US format to YYYY-MM-DD if necessary
-			        if (getDateHidden().indexOf('/') &gt; -1)
-				        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setCacheStatus(xmlString.substring(start + 1, end));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-		        	setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
-		            
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setHard(CacheTerrDiff.CW_DT_UNSET);
-			        } else {
-				        try {
-				        	setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setHard(CacheTerrDiff.CW_DT_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('&quot;', end + 1);
-				    end = xmlString.indexOf('&quot;', start + 1);
-				    if (isAddiWpt() || isCustomWpt()) {
-				    	setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				    } else {
-					    try {
-					    	setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-					    } catch (IllegalArgumentException ex) {
-					    	setTerrain(CacheTerrDiff.CW_DT_ERROR);
-					    	setIncomplete(true);
-					    	Global.getPref().log(wayPoint, ex, true);
-				        }
-				    }
-			        // The next item was 'dirty' but this is no longer used.
-		            start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setFiltered(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-			        } else {
-				        try {
-				        	setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setCacheSize(CacheSize.CW_SIZE_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setAvailable(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setArchived(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setHas_bugs(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setBlack(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setOwned(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setFound(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setNew(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setLog_updated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setUpdated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-			        // for backwards compatibility set value to true, if it is not in the file
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setHTML(!xmlString.substring(start + 1, end).equals(&quot;false&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-		            setNoFindLogs((byte)Convert.toInt(xmlString.substring(start + 1, end)));
-	
-		            start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setOcCacheID(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;) || incomplete);
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setLastSync(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-			        recommendationScore = LogList.getScore(getNumRecommended(),
-			                getNumFoundsSinceRecommendation());
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-		            if (start &gt; -1 &amp;&amp; end &gt; -1) {
-		            	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		        		
-				        start = xmlString.indexOf('&quot;', end + 1);
-				        end = xmlString.indexOf('&quot;', start + 1);
-				        if (start &gt; -1 &amp;&amp; end &gt; -1)
-			            	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            setAttribsAsBits(attribsBits);
-	            } else if (version == 3 || version == 2) {
-		            start = xmlString.indexOf('&quot;');
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            // Assume coordinates are in decimal format
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            pos = new CWPoint(lat, lon);
-		            LatLon = pos.toString();
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setDateHidden(xmlString.substring(start + 1, end));
-		            // Convert the US format to YYYY-MM-DD if necessary
-		            if (getDateHidden().indexOf('/') &gt; -1)
-			            setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setCacheStatus(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setOcCacheID(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setLastSync(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-		            recommendationScore = LogList.getScore(getNumRecommended(),
-		                    getNumFoundsSinceRecommendation());
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-			        if (start &gt; -1 &amp;&amp; end &gt; -1) {
-			        	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('&quot;', end + 1);
-				        end = xmlString.indexOf('&quot;', start + 1);
-				        if (start &gt; -1 &amp;&amp; end &gt; -1)
-				        	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            if (version == 2) {
-		            	long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            } else {
-		            	long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-			        if (start &gt; -1 &amp;&amp; end &gt; -1) {
-			        	attribsBits[1]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('&quot;', end + 1);
-				        end = xmlString.indexOf('&quot;', start + 1);
-				        if (start &gt; -1 &amp;&amp; end &gt; -1)
-				        	attribsBits[3]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        setAttribsAsBits(attribsBits);
-	            }
-				if (version &lt; Profile.CURRENTFILEFORMAT) {
-		            // forceload of details, creates waypoint.xml if missing
-		            details = getCacheDetails(false);
-		            // make sure details get (re)written in new format
-		            details.hasUnsavedChanges = true;
-		            // update information on notes and solver info
-		            setHasNote(!details.getCacheNotes().equals(&quot;&quot;));
-			    setHasSolver(!details.getSolver().equals(&quot;&quot;));
+		int start, end;
+		try {
+			if (version == 1) {
+				start = xmlString.indexOf('&quot;');
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos = new CWPoint(lat, lon);
+				LatLon = pos.toString();
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') &gt; -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setHard(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
 				}
-	        } catch (Exception ex) {
-	        	// Global.getPref().log(&quot;Ignored Exception in CacheHolder()&quot;, ex, true);
-	        }
-        }
-	
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setTerrain(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				// The next item was 'dirty' but this is no longer used.
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setFiltered(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				} else {
+					try {
+						setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setCacheSize(CacheSize.CW_SIZE_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setAvailable(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setArchived(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setHas_bugs(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setBlack(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setOwned(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setFound(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNew(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setLog_updated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setUpdated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+				// for backwards compatibility set value to true, if it is not in the file
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setHTML(!xmlString.substring(start + 1, end).equals(&quot;false&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNoFindLogs((byte) Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;) || incomplete);
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start &gt; -1 &amp;&amp; end &gt; -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('&quot;', end + 1);
+					end = xmlString.indexOf('&quot;', start + 1);
+					if (start &gt; -1 &amp;&amp; end &gt; -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			} else if (version == 3 || version == 2) {
+				start = xmlString.indexOf('&quot;');
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos = new CWPoint(lat, lon);
+				LatLon = pos.toString();
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') &gt; -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start &gt; -1 &amp;&amp; end &gt; -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('&quot;', end + 1);
+					end = xmlString.indexOf('&quot;', start + 1);
+					if (start &gt; -1 &amp;&amp; end &gt; -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (version == 2) {
+					long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
+				} else {
+					long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (start &gt; -1 &amp;&amp; end &gt; -1) {
+					attribsBits[1] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('&quot;', end + 1);
+					end = xmlString.indexOf('&quot;', start + 1);
+					if (start &gt; -1 &amp;&amp; end &gt; -1)
+						attribsBits[3] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			}
+			if (version &lt; Profile.CURRENTFILEFORMAT) {
+				// forceload of details, creates waypoint.xml if missing
+				details = getCacheDetails(false);
+				// make sure details get (re)written in new format
+				details.hasUnsavedChanges = true;
+				// update information on notes and solver info
+				setHasNote(!details.getCacheNotes().equals(&quot;&quot;));
+				setHasSolver(!details.getSolver().equals(&quot;&quot;));
+			}
+		} catch (Exception ex) {
+			// Global.getPref().log(&quot;Ignored Exception in CacheHolder()&quot;, ex, true);
+		}
+	}
+
 	/**
-	 * Returns the distance in formatted output. Using kilometers when metric system is active,
-	 * using miles when imperial system is active.
+	 * Returns the distance in formatted output. Using kilometers when metric system is active, using miles when imperial system is active.
 	 * 
 	 * @return The current distance.
 	 */
@@ -461,8 +453,7 @@
 				}
 				result = MyLocale.formatDouble(newValue, &quot;0.00&quot;) + &quot; &quot; + newUnit;
 			} else {
-				result = &quot;? &quot;
-				        + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
+				result = &quot;? &quot; + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
 			}
 			// Caching values, so reevaluation is only done when really needed
 			this.lastKilom = this.kilom;
@@ -471,31 +462,26 @@
 		}
 		return result;
 	}
-	/** 
-	 * Updates Cache information with information provided by cache given as argument. This is used
-	 * to update the cache with the information retrieved from files or web: The argument cache
-	 * is the one that is filled with the read information, &lt;code&gt;this&lt;/code&gt; is the cache that
-	 * is already in the database and subject to update. 
-	 * @param ch The cache who's information is updating the current one
-	 * @param overwrite If &lt;code&gt;true&lt;/code&gt;, then &lt;i&gt;status&lt;/i&gt;, &lt;i&gt;is_found&lt;/i&gt; and &lt;i&gt;position&lt;/i&gt;
-	 * is updated, otherwise not.
+
+	/**
+	 * Updates Cache information with information provided by cache given as argument. This is used to update the cache with the information retrieved from files or web: The argument cache is the one that is filled with the read information,
+	 * &lt;code&gt;this&lt;/code&gt; is the cache that is already in the database and subject to update.
+	 * 
+	 * @param ch
+	 *            The cache who's information is updating the current one
+	 * @param overwrite
+	 *            If &lt;code&gt;true&lt;/code&gt;, then &lt;i&gt;status&lt;/i&gt;, &lt;i&gt;is_found&lt;/i&gt; and &lt;i&gt;position&lt;/i&gt; is updated, otherwise not.
 	 */
 	public void update(CacheHolder ch) {
 		this.recommendationScore = ch.recommendationScore;
 		this.setNumFoundsSinceRecommendation(ch.getNumFoundsSinceRecommendation());
 		this.setNumRecommended(ch.getNumRecommended());
-		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362,&quot;solved&quot;));
-		/* Here we have to distinguish several cases:
-		 * this.is_found       this                ch               Update 'this'
-		 *                                         (values are
-		 *                                     empty or yyyy-mm-dd)
-		 * ----------------------------------------------------------------------
-		 * false               any                 yyyy-mm-dd       yes
-		 * true                &quot;Found&quot;             yyyy-mm-dd       yes
-		 * true                yyyy-mm-dd          yyyy-mm-dd       yes (or no)
-		 * true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
-		*/
-		if (!this.found || this.cacheStatus.indexOf(&quot;:&quot;)&lt;0) {
+		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362, &quot;solved&quot;));
+		/*
+		 * Here we have to distinguish several cases: this.is_found this ch Update 'this' (values are empty or yyyy-mm-dd) ---------------------------------------------------------------------- false any yyyy-mm-dd yes true &quot;Found&quot; yyyy-mm-dd yes true
+		 * yyyy-mm-dd yyyy-mm-dd yes (or no) true yyyy-mm-dd hh:mm yyyy-mm-dd no
+		 */
+		if (!this.found || this.cacheStatus.indexOf(&quot;:&quot;) &lt; 0) {
 			// don't overwrite with empty data
 			if (!ch.getCacheStatus().trim().equals(&quot;&quot;)) {
 				this.setCacheStatus(ch.getCacheStatus());
@@ -527,19 +513,20 @@
 		this.setFiltered(ch.is_filtered());
 		this.setIncomplete(ch.is_incomplete());
 		this.addiWpts = ch.addiWpts;
-		this.mainCache=ch.mainCache;
+		this.mainCache = ch.mainCache;
 		this.setOcCacheID(ch.getOcCacheID());
 		this.setNoFindLogs(ch.getNoFindLogs());
 		this.setHas_bugs(ch.has_bugs());
 		this.setHTML(ch.is_HTML());
-		this.sort=ch.sort;
+		this.sort = ch.sort;
 		this.setLastSync(ch.getLastSync());
 
 		this.setAttribsAsBits(ch.getAttributesBits());
 		if (ch.detailsLoaded()) {
 			this.getCacheDetails(false).update(ch.getCacheDetails(false));
-		}	
+		}
 	}
+
 	/**
 	 * Call it only when necessary, it takes time, because all logs must be parsed
 	 */
@@ -565,84 +552,93 @@
 		} else {
 			recommendationScore = -1;
 			setNumFoundsSinceRecommendation(-1);
-//			setNumRecommended(-1);
+			// setNumRecommended(-1);
 		}
 	}
-	
+
 	/** Return a XML string containing all the cache data for storing in index.xml */
 	public String toXML() {
-		calcRecommendationScore(); 
-		sb.delete(0,sb.length());
+		calcRecommendationScore();
+		sb.delete(0, sb.length());
 		sb.append(&quot;    &lt;CACHE &quot;);
-		sb.append(&quot; name = \&quot;&quot;);        sb.append(SafeXML.clean(getCacheName()));
-		sb.append(&quot;\&quot; owner = \&quot;&quot;);		sb.append(SafeXML.clean(getCacheOwner()));
-		sb.append(&quot;\&quot; lat = \&quot;&quot;); 		sb.append(pos.latDec ); 
-		sb.append(&quot;\&quot; lon = \&quot;&quot;);		sb.append(pos.lonDec);
-		sb.append(&quot;\&quot; hidden = \&quot;&quot;);	sb.append(getDateHidden());
-		sb.append(&quot;\&quot; wayp = \&quot;&quot;);		sb.append(SafeXML.clean(getWayPoint()));
-		sb.append(&quot;\&quot; status = \&quot;&quot;);	sb.append(getCacheStatus());
-		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot; );sb.append(getOcCacheID()); 
-		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot; );sb.append(getLastSync()); 
-		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);sb.append(Convert.formatInt(getNumRecommended())); 
-		sb.append(&quot;\&quot; num_found = \&quot;&quot; );sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
+		sb.append(&quot; name = \&quot;&quot;);
+		sb.append(SafeXML.clean(getCacheName()));
+		sb.append(&quot;\&quot; owner = \&quot;&quot;);
+		sb.append(SafeXML.clean(getCacheOwner()));
+		sb.append(&quot;\&quot; lat = \&quot;&quot;);
+		sb.append(pos.latDec);
+		sb.append(&quot;\&quot; lon = \&quot;&quot;);
+		sb.append(pos.lonDec);
+		sb.append(&quot;\&quot; hidden = \&quot;&quot;);
+		sb.append(getDateHidden());
+		sb.append(&quot;\&quot; wayp = \&quot;&quot;);
+		sb.append(SafeXML.clean(getWayPoint()));
+		sb.append(&quot;\&quot; status = \&quot;&quot;);
+		sb.append(getCacheStatus());
+		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot;);
+		sb.append(getOcCacheID());
+		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot;);
+		sb.append(getLastSync());
+		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);
+		sb.append(Convert.formatInt(getNumRecommended()));
+		sb.append(&quot;\&quot; num_found = \&quot;&quot;);
+		sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
 		long[] attribsBits = getAttributesBits();
-		sb.append(&quot;\&quot; attributesYes = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[0]));
-		sb.append(&quot;\&quot; attributesNo = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[2]));
-		sb.append(&quot;\&quot; boolFields=\&quot;&quot; ); sb.append(Convert.formatLong(this.boolFields2long()));
-		sb.append(&quot;\&quot; byteFields=\&quot;&quot; ); sb.append(Convert.formatLong(this.byteFields2long()));
-		sb.append(&quot;\&quot; attributesYes1 = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[1]));
-		sb.append(&quot;\&quot; attributesNo1 = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[3]));
+		sb.append(&quot;\&quot; attributesYes = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[0]));
+		sb.append(&quot;\&quot; attributesNo = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[2]));
+		sb.append(&quot;\&quot; boolFields=\&quot;&quot;);
+		sb.append(Convert.formatLong(this.boolFields2long()));
+		sb.append(&quot;\&quot; byteFields=\&quot;&quot;);
+		sb.append(Convert.formatLong(this.byteFields2long()));
+		sb.append(&quot;\&quot; attributesYes1 = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[1]));
+		sb.append(&quot;\&quot; attributesNo1 = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[3]));
 		sb.append(&quot;\&quot; /&gt;\n&quot;);
 		return sb.toString();
 	}
-	
+
 	/** Return a Hashtable containing all the cache data for Templates */
-	public Hashtable toHashtable(
-			Regex decSep, Regex badChars, 
-			int shortWaypointLength, int shortNameLength, int nrOfLogs,
-			TextCodec codec, GarminMap gm,
-			boolean withFoundText,
-			int ModTyp,
-			String expName
-			) {
+	public Hashtable toHashtable(Regex decSep, Regex badChars, int shortWaypointLength, int shortNameLength, int nrOfLogs, TextCodec codec, GarminMap gm, boolean withFoundText, int ModTyp, String expName) {
 		Hashtable varParams = new Hashtable();
 		CacheHolderDetail det = this.getCacheDetails(false);
 		varParams.put(&quot;PROGDIR&quot;, FileBase.getProgramDirectory());
 		varParams.put(&quot;PROFILDIR&quot;, Global.getProfile().dataDir);
 		varParams.put(&quot;ALIAS&quot;, Global.getPref().myAlias);
-		varParams.put(&quot;TYPE&quot;, CacheType.type2TypeTag(type)); //&lt;type&gt;
-		varParams.put(&quot;TYPENO&quot;,&quot;&quot;+type);
-		varParams.put(&quot;SYM&quot;, CacheType.type2SymTag(type)); //&lt;sym&gt;
-		varParams.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(type)); //&lt;groundspeak:type&gt;
+		varParams.put(&quot;TYPE&quot;, CacheType.type2TypeTag(type)); // &lt;type&gt;
+		varParams.put(&quot;TYPENO&quot;, &quot;&quot; + type);
+		varParams.put(&quot;SYM&quot;, CacheType.type2SymTag(type)); // &lt;sym&gt;
+		varParams.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(type)); // &lt;groundspeak:type&gt;
 		varParams.put(&quot;SHORTTYPE&quot;, CacheType.getExportShortId(type));
 		if (isAddiWpt()) {
-			CacheHolder ch=this.mainCache;
-			varParams.put(&quot;MAINWP&quot;,ch.getWayPoint());
+			CacheHolder ch = this.mainCache;
+			varParams.put(&quot;MAINWP&quot;, ch.getWayPoint());
 			varParams.put(&quot;MAINWPNAME&quot;, ch.getCacheName());
-			varParams.put(&quot;DIFFICULTY&quot;, (ch.hard &lt; 0)?&quot;!&lt;!&quot;:decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
+			varParams.put(&quot;DIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;!&lt;!&quot; : decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
 			String sHard = Integer.toString(ch.hard);
-			varParams.put(&quot;SHORTDIFFICULTY&quot;, (ch.hard &lt; 0)?&quot;&quot;:sHard);
-			varParams.put(&quot;SHDIFFICULTY&quot;, (ch.hard &lt; 0)?&quot;&quot;:sHard.substring(0,1));
-			varParams.put(&quot;TERRAIN&quot;, (ch.terrain &lt; 0)?&quot;&quot;:decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
+			varParams.put(&quot;SHORTDIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;&quot; : sHard);
+			varParams.put(&quot;SHDIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;&quot; : sHard.substring(0, 1));
+			varParams.put(&quot;TERRAIN&quot;, (ch.terrain &lt; 0) ? &quot;&quot; : decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
 			String sTerrain = Integer.toString(ch.terrain);
-			varParams.put(&quot;SHORTTERRAIN&quot;, (ch.terrain &lt; 0)?&quot;&quot;:sTerrain);
-			varParams.put(&quot;SHTERRAIN&quot;, (ch.terrain &lt; 0)?&quot;&quot;:sTerrain.substring(0,1));
+			varParams.put(&quot;SHORTTERRAIN&quot;, (ch.terrain &lt; 0) ? &quot;&quot; : sTerrain);
+			varParams.put(&quot;SHTERRAIN&quot;, (ch.terrain &lt; 0) ? &quot;&quot; : sTerrain.substring(0, 1));
 			varParams.put(&quot;SIZE&quot;, CacheSize.cw2ExportString(ch.cacheSize));
 			varParams.put(&quot;SHORTSIZE&quot;, CacheSize.getExportShortId(ch.cacheSize));
 			varParams.put(&quot;OWNER&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(ch.cacheOwner) : ch.cacheOwner);
 			varParams.put(&quot;DATE&quot;, ch.dateHidden);
-		}
-		else {
+		} else {
 			varParams.put(&quot;MAINWP&quot;, &quot;&quot;);
 			varParams.put(&quot;MAINWPNAME&quot;, &quot;&quot;);
-			varParams.put(&quot;DIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0)?&quot;&quot;:decSep.replaceAll(CacheTerrDiff.longDT(hard)));
+			varParams.put(&quot;DIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0) ? &quot;&quot; : decSep.replaceAll(CacheTerrDiff.longDT(hard)));
 			String sHard = Integer.toString(hard);
-			varParams.put(&quot;SHORTDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0)?&quot;&quot;:sHard);
-			varParams.put(&quot;SHDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0)?&quot;&quot;:sHard.substring(0,1));
-			varParams.put(&quot;TERRAIN&quot;, (isCustomWpt() || terrain &lt; 0)?&quot;&quot;:decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
+			varParams.put(&quot;SHORTDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0) ? &quot;&quot; : sHard);
+			varParams.put(&quot;SHDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0) ? &quot;&quot; : sHard.substring(0, 1));
+			varParams.put(&quot;TERRAIN&quot;, (isCustomWpt() || terrain &lt; 0) ? &quot;&quot; : decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
 			String sTerrain = Integer.toString(terrain);
-			varParams.put(&quot;SHORTTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0)?&quot;&quot;:sTerrain);
-			varParams.put(&quot;SHTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0)?&quot;&quot;:sTerrain.substring(0,1));
+			varParams.put(&quot;SHORTTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0) ? &quot;&quot; : sTerrain);
+			varParams.put(&quot;SHTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0) ? &quot;&quot; : sTerrain.substring(0, 1));
 			varParams.put(&quot;SIZE&quot;, CacheSize.cw2ExportString(cacheSize));
 			varParams.put(&quot;SHORTSIZE&quot;, CacheSize.getExportShortId(cacheSize));
 			varParams.put(&quot;OWNER&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(cacheOwner) : cacheOwner);
@@ -650,48 +646,51 @@
 		}
 		if (isCustomWpt()) {
 
-		}		
-		varParams.put(&quot;WAYPOINT&quot;, wayPoint); //&lt;name&gt;
+		}
+		varParams.put(&quot;WAYPOINT&quot;, wayPoint); // &lt;name&gt;
 		int wpl = wayPoint.length();
 		int wps = (wpl &lt; shortWaypointLength) ? 0 : wpl - shortWaypointLength;
 		varParams.put(&quot;SHORTWAYPOINT&quot;, wayPoint.substring(wps, wpl));
 		varParams.put(&quot;DISTANCE&quot;, decSep.replaceAll(getDistance()));
 		varParams.put(&quot;BEARING&quot;, bearing);
-		if ((pos!=null &amp;&amp; pos.isValid())) {
+		if ((pos != null &amp;&amp; pos.isValid())) {
 			varParams.put(&quot;LATLON&quot;, decSep.replaceAll(LatLon));
 			varParams.put(&quot;LAT&quot;, decSep.replaceAll(pos.getLatDeg(CWPoint.DD)));
-			varParams.put(&quot;LON&quot;, decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));		
-		}
-		else {
+			varParams.put(&quot;LON&quot;, decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));
+		} else {
 			varParams.put(&quot;LATLON&quot;, &quot;unknown&quot;);
 			varParams.put(&quot;LAT&quot;, &quot;&quot;);
-			varParams.put(&quot;LON&quot;, &quot;&quot;);		
+			varParams.put(&quot;LON&quot;, &quot;&quot;);
 		}
 		if (withFoundText) {
-			varParams.put(&quot;STATUS&quot;,getStatusText());
-		}
-		else
+			varParams.put(&quot;STATUS&quot;, getStatusText());
+		} else
 			varParams.put(&quot;STATUS&quot;, cacheStatus);
 		varParams.put(&quot;GC_LOGTYPE&quot;, getGCLogType());
 		varParams.put(&quot;STATUS_DATE&quot;, getStatusDate());
 		varParams.put(&quot;STATUS_TIME&quot;, getStatusTime());
 		varParams.put(&quot;CACHE_NAME&quot;, cacheName);
-		if (codec instanceof AsciiCodec) { cacheName=Exporter.simplifyString(cacheName);} // use for &quot;NAME&quot;
-		if (badChars != null) { cacheName=badChars.replaceAll(cacheName); } // use for &quot;NAME&quot;
+		if (codec instanceof AsciiCodec) {
+			cacheName = Exporter.simplifyString(cacheName);
+		} // use for &quot;NAME&quot;
+		if (badChars != null) {
+			cacheName = badChars.replaceAll(cacheName);
+		} // use for &quot;NAME&quot;
 		varParams.put(&quot;NAME&quot;, cacheName); // !!! cacheName used twice
-		String shortName=shortenName(cacheName, shortNameLength);
+		String shortName = shortenName(cacheName, shortNameLength);
 		varParams.put(&quot;SHORTNAME&quot;, shortName);
-		varParams.put(&quot;TRAVELBUG&quot;, (bugs?&quot;Y&quot;:&quot;N&quot;));
-		if (gm!=null) varParams.put(&quot;GMTYPE&quot;, gm.getIcon(this));
-		varParams.put(&quot;NOW_DATE&quot;,nowdate().setToCurrentTime().toString());
-		varParams.put(&quot;NOW_TIME&quot;,nowtime().setToCurrentTime().toString());
+		varParams.put(&quot;TRAVELBUG&quot;, (bugs ? &quot;Y&quot; : &quot;N&quot;));
+		if (gm != null)
+			varParams.put(&quot;GMTYPE&quot;, gm.getIcon(this));
+		varParams.put(&quot;NOW_DATE&quot;, nowdate().setToCurrentTime().toString());
+		varParams.put(&quot;NOW_TIME&quot;, nowtime().setToCurrentTime().toString());
 		varParams.put(&quot;CACHEID&quot;, GetCacheID());
 		varParams.put(&quot;AVAILABLE&quot;, available ? &quot;TRUE&quot; : &quot;FALSE&quot;);
 		varParams.put(&quot;ARCHIVED&quot;, archived ? &quot;TRUE&quot; : &quot;FALSE&quot;);
 		varParams.put(&quot;HTML&quot;, html ? &quot;TRUE&quot; : &quot;FALSE&quot;);
 		varParams.put(&quot;VOTE&quot;, getRecommended());
-		//() ? TRUE : FALSE
-		if (det == null){
+		// () ? TRUE : FALSE
+		if (det == null) {
 			varParams.put(&quot;URL&quot;, &quot;&quot;);
 			varParams.put(&quot;DESCRIPTION&quot;, &quot;&quot;);
 			varParams.put(&quot;NOTES&quot;, &quot;&quot;);
@@ -699,145 +698,143 @@
 			varParams.put(&quot;DECRYPTEDHINTS&quot;, &quot;&quot;);
 			varParams.put(&quot;COUNTRY&quot;, &quot;&quot;);
 			varParams.put(&quot;STATE&quot;, &quot;&quot;);
-		}
-		else {
+		} else {
 			varParams.put(&quot;URL&quot;, det.URL);
 			if (html) {
 				if (ModTyp == 0) {
-					varParams.put(&quot;DESCRIPTION&quot;,SafeXML.cleanGPX(det.LongDescription));
-				}
-				else {
+					varParams.put(&quot;DESCRIPTION&quot;, SafeXML.cleanGPX(det.LongDescription));
+				} else {
 					varParams.put(&quot;DESCRIPTION&quot;, modifyLongDesc(det, ModTyp));
 				}
 			} else {
-				 // what was the reason? replace or no replace? I dont remember
-				varParams.put(&quot;DESCRIPTION&quot;,STRreplace.replace(det.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
+				// what was the reason? replace or no replace? I dont remember
+				varParams.put(&quot;DESCRIPTION&quot;, STRreplace.replace(det.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
 			}
-			
+
 			if (badChars != null) {
-				if (ModTyp == 0){
-					varParams.put(&quot;NOTES&quot;,badChars.replaceAll(det.getCacheNotes()));
+				if (ModTyp == 0) {
+					varParams.put(&quot;NOTES&quot;, badChars.replaceAll(det.getCacheNotes()));
+				} else {
+					varParams.put(&quot;NOTES&quot;, STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
 				}
-				else {
-					varParams.put(&quot;NOTES&quot;,STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
-				}
-				varParams.put(&quot;HINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
-				varParams.put(&quot;DECRYPTEDHINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
+				varParams.put(&quot;HINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
+				varParams.put(&quot;DECRYPTEDHINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
 			} else {
-				if (ModTyp == 0){
+				if (ModTyp == 0) {
 					varParams.put(&quot;NOTES&quot;, SafeXML.cleanGPX(det.getCacheNotes()));
-				}
-				else {
+				} else {
 					varParams.put(&quot;NOTES&quot;, STRreplace.replace(det.getCacheNotes(), &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
 				}
-				varParams.put(&quot;HINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
-				varParams.put(&quot;DECRYPTEDHINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
+				varParams.put(&quot;HINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
+				varParams.put(&quot;DECRYPTEDHINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
 			}
-			if (det.Travelbugs.size()&gt;0) varParams.put(&quot;BUGS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
-			if (det.getSolver()!=null &amp;&amp; det.getSolver().trim().length()&gt;0) 
-				varParams.put(&quot;SOLVER&quot;, STRreplace.replace(det.getSolver(),&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
+			if (det.Travelbugs.size() &gt; 0)
+				varParams.put(&quot;BUGS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
+			if (det.getSolver() != null &amp;&amp; det.getSolver().trim().length() &gt; 0)
+				varParams.put(&quot;SOLVER&quot;, STRreplace.replace(det.getSolver(), &quot;\n&quot;, &quot;&lt;br/&gt;\n&quot;));
 			varParams.put(&quot;COUNTRY&quot;, det.Country);
 			varParams.put(&quot;STATE&quot;, det.State);
-			
+
 			// attributes
-			Vector attVect=new Vector(det.attributes.count()+1);
-			for (int i=0; i&lt;det.attributes.count(); i++) {
-				Hashtable atts=new Hashtable();
+			Vector attVect = new Vector(det.attributes.count() + 1);
+			for (int i = 0; i &lt; det.attributes.count(); i++) {
+				Hashtable atts = new Hashtable();
 				atts.put(&quot;PATHANDIMAGE&quot;, det.attributes.getAttribute(i).getPathAndImageName());
 				atts.put(&quot;IMAGE&quot;, det.attributes.getAttribute(i).getImageName());
 				atts.put(&quot;GCID&quot;, det.attributes.getAttribute(i).getGCId());
 				atts.put(&quot;INC&quot;, &quot;&quot; + det.attributes.getAttribute(i).getInc());
-				atts.put(&quot;INC2TXT&quot;, det.attributes.getAttribute(i).getInc()==1 ? &quot;YES:&quot; : &quot;NO:&quot;);
-				if (i % 5 ==4)
-					atts.put(&quot;BR&quot;,&quot;&lt;br/&gt;&quot;);
+				atts.put(&quot;INC2TXT&quot;, det.attributes.getAttribute(i).getInc() == 1 ? &quot;YES:&quot; : &quot;NO:&quot;);
+				if (i % 5 == 4)
+					atts.put(&quot;BR&quot;, &quot;&lt;br/&gt;&quot;);
 				else
-					atts.put(&quot;BR&quot;,&quot;&quot;);
-				atts.put(&quot;INFO&quot;,det.attributes.getAttribute(i).getMsg());
-				atts.put(&quot;GCINFO&quot;,det.attributes.getAttribute(i).getGCText());
+					atts.put(&quot;BR&quot;, &quot;&quot;);
+				atts.put(&quot;INFO&quot;, det.attributes.getAttribute(i).getMsg());
+				atts.put(&quot;GCINFO&quot;, det.attributes.getAttribute(i).getGCText());
 				attVect.add(atts);
 			}
-			varParams.put(&quot;ATTRIBUTES&quot;,attVect);
-			
+			varParams.put(&quot;ATTRIBUTES&quot;, attVect);
+
 			// logs
-			Vector logVect=new Vector(det.CacheLogs.size());
+			Vector logVect = new Vector(det.CacheLogs.size());
 			int maxlogs = det.CacheLogs.size();
-			if (nrOfLogs &gt; -1 &amp;&amp; nrOfLogs &lt; maxlogs ) maxlogs=nrOfLogs;
-			for (int i=0; i&lt;maxlogs; i++) {
-				Hashtable logs=new Hashtable();
+			if (nrOfLogs &gt; -1 &amp;&amp; nrOfLogs &lt; maxlogs)
+				maxlogs = nrOfLogs;
+			for (int i = 0; i &lt; maxlogs; i++) {
+				Hashtable logs = new Hashtable();
 				String stmp;
 				if (det.CacheLogs.getLog(i).getIcon().equals(&quot;MAXLOG&quot;)) {
 					logs.put(&quot;WAYPOINT&quot;, wayPoint);
-					logs.put(&quot;ICON&quot;,&quot;&quot;);
-					logs.put(&quot;LOGTYPE&quot;,&quot;&quot;);
+					logs.put(&quot;ICON&quot;, &quot;&quot;);
+					logs.put(&quot;LOGTYPE&quot;, &quot;&quot;);
 					logs.put(&quot;DATE&quot;, &quot;&quot;);
 					logs.put(&quot;LOGGER&quot;, &quot;&quot;);
-					stmp = &quot;&lt;hr&gt;&quot;+MyLocale.getMsg(736,&quot;Too many logs&quot;)+&quot;&lt;hr&gt;&quot;;
-				}
-				else {
+					stmp = &quot;&lt;hr&gt;&quot; + MyLocale.getMsg(736, &quot;Too many logs&quot;) + &quot;&lt;hr&gt;&quot;;
+				} else {
 					logs.put(&quot;WAYPOINT&quot;, wayPoint);
-					logs.put(&quot;ICON&quot;,det.CacheLogs.getLog(i).getIcon());
-					logs.put(&quot;LOGTYPE&quot;,image2TypeText(det.CacheLogs.getLog(i).getIcon()));
+					logs.put(&quot;ICON&quot;, det.CacheLogs.getLog(i).getIcon());
+					logs.put(&quot;LOGTYPE&quot;, image2TypeText(det.CacheLogs.getLog(i).getIcon()));
 					logs.put(&quot;DATE&quot;, det.CacheLogs.getLog(i).getDate());
 					logs.put(&quot;LOGGER&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(det.CacheLogs.getLog(i).getLogger()) : det.CacheLogs.getLog(i).getLogger());
-					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,null);
+					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(), &quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;, null);
 				}
 				logs.put(&quot;MESSAGE&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(stmp) : stmp);
 				logVect.add(logs);
 			}
-			varParams.put(&quot;LOGS&quot;,logVect);
+			varParams.put(&quot;LOGS&quot;, logVect);
 
-			Vector addiVect=new Vector(addiWpts.size());
-			for (int i=0; i&lt;addiWpts.size(); i++) {
-				Hashtable addis=new Hashtable();
-				CacheHolder ch=(CacheHolder) addiWpts.get(i);
-				addis.put(&quot;WAYPOINT&quot;,ch.getWayPoint());
-				addis.put(&quot;NAME&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
-				if ((ch.pos!=null &amp;&amp; ch.pos.isValid())) {
-					addis.put(&quot;LATLON&quot;,decSep.replaceAll(ch.pos.toString()));
-					addis.put(&quot;LAT&quot;,decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
-					addis.put(&quot;LON&quot;,decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
-				}
-				else {
+			Vector addiVect = new Vector(addiWpts.size());
+			for (int i = 0; i &lt; addiWpts.size(); i++) {
+				Hashtable addis = new Hashtable();
+				CacheHolder ch = (CacheHolder) addiWpts.get(i);
+				addis.put(&quot;WAYPOINT&quot;, ch.getWayPoint());
+				addis.put(&quot;NAME&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
+				if ((ch.pos != null &amp;&amp; ch.pos.isValid())) {
+					addis.put(&quot;LATLON&quot;, decSep.replaceAll(ch.pos.toString()));
+					addis.put(&quot;LAT&quot;, decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
+					addis.put(&quot;LON&quot;, decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
+				} else {
 					addis.put(&quot;LATLON&quot;, &quot;unknown&quot;);
 					addis.put(&quot;LAT&quot;, &quot;&quot;);
-					addis.put(&quot;LON&quot;, &quot;&quot;);		
+					addis.put(&quot;LON&quot;, &quot;&quot;);
 				}
-				addis.put(&quot;IMG&quot;,CacheType.typeImageForId(ch.getType()));
-				addis.put(&quot;ICON&quot;,&quot;&quot;+ch.getType());
+				addis.put(&quot;IMG&quot;, CacheType.typeImageForId(ch.getType()));
+				addis.put(&quot;ICON&quot;, &quot;&quot; + ch.getType());
 				addis.put(&quot;TYPENAME&quot;, CacheType.type2Gui(ch.getType()));
-				addis.put(&quot;TYPE&quot;, CacheType.type2TypeTag(ch.getType())); //&lt;type&gt;
-				addis.put(&quot;SYM&quot;, CacheType.type2SymTag(ch.getType())); //&lt;sym&gt;
-				addis.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(ch.getType())); //&lt;groundspeak:type&gt;
-				addis.put(&quot;LONGDESC&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
+				addis.put(&quot;TYPE&quot;, CacheType.type2TypeTag(ch.getType())); // &lt;type&gt;
+				addis.put(&quot;SYM&quot;, CacheType.type2SymTag(ch.getType())); // &lt;sym&gt;
+				addis.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(ch.getType())); // &lt;groundspeak:type&gt;
+				addis.put(&quot;LONGDESC&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
 				addiVect.add(addis);
 			}
-			varParams.put(&quot;ADDIS&quot;,addiVect);
-			
-			Vector imgVect=new Vector(det.images.size());
-			for (int i=0; i&lt;det.images.size(); i++) {
-				Hashtable imgs=new Hashtable();
+			varParams.put(&quot;ADDIS&quot;, addiVect);
+
+			Vector imgVect = new Vector(det.images.size());
+			for (int i = 0; i &lt; det.images.size(); i++) {
+				Hashtable imgs = new Hashtable();
 				String imgFile = det.images.get(i).getFilename();
-				imgs.put(&quot;FILENAME&quot;,imgFile);
-				imgs.put(&quot;TEXT&quot;,det.images.get(i).getTitle());
-				imgs.put(&quot;COMMENT&quot;,det.images.get(i).getComment());
-				imgs.put(&quot;URL&quot;,det.images.get(i).getURL());
+				imgs.put(&quot;FILENAME&quot;, imgFile);
+				imgs.put(&quot;TEXT&quot;, det.images.get(i).getTitle());
+				imgs.put(&quot;COMMENT&quot;, det.images.get(i).getComment());
+				imgs.put(&quot;URL&quot;, det.images.get(i).getURL());
 				if (!expName.equals(&quot;&quot;)) {
 					String src = Global.getProfile().dataDir + imgFile;
 					String dest = Global.getPref().getExportPath(expName) + imgFile;
-					if (!DataMover.copy(src,dest)) {
-						Global.getPref().log(&quot;[CacheHolder:toHashtable]error copying &quot;+imgFile+&quot; to &quot;+Global.getPref().getExportPath(expName));
+					if (!DataMover.copy(src, dest)) {
+						Global.getPref().log(&quot;[CacheHolder:toHashtable]error copying &quot; + imgFile + &quot; to &quot; + Global.getPref().getExportPath(expName));
 					}
 				}
 				imgVect.add(imgs);
 			}
-			varParams.put(&quot;cacheImg&quot;,imgVect);
+			varParams.put(&quot;cacheImg&quot;, imgVect);
 		}
 		return varParams;
-	}	
+	}
 
 	/**
 	 * generate a gc.com compatible string representation of log derived from the internally stored image
-	 * @param image name of the image to display
+	 * 
+	 * @param image
+	 *            name of the image to display
 	 * @return log type. will default to &quot;Write note&quot; for unknown logtypes
 	 */
 	public static final String image2TypeText(String image) {
@@ -877,36 +874,40 @@
 	}
 
 	/**
-	 * Modify the image links in the long description so that they point to image files in the local directory
-	 * Also copy the image file to the target directory so that it can be displayed.
-	 * @param chD CacheHolderDetail
+	 * Modify the image links in the long description so that they point to image files in the local directory Also copy the image file to the target directory so that it can be displayed.
+	 * 
+	 * @param chD
+	 *            CacheHolderDetail
 	 * @param int ModTypLongDesc == 1 get image from profile path, == 2 get image from html-path
 	 * @return The modified long description
 	 */
 	private String modifyLongDesc(CacheHolderDetail chD, int ModTypLongDesc) {
-		StringBuffer s=new StringBuffer(chD.LongDescription.length());
-		int start=0;
+		StringBuffer s = new StringBuffer(chD.LongDescription.length());
+		int start = 0;
 		int pos;
-		int imageNo=0;
-		String imgsrc=&quot;&quot;;
-		if (ModTypLongDesc==1) imgsrc=&quot;<A HREF="file://">file://</A>&quot;+Global.getProfile().dataDir;
-		while (start&gt;=0 &amp;&amp; (pos=chD.LongDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
-			if (imageNo &gt;= chD.images.size()) break;
-			s.append(chD.LongDescription.substring(start,pos));
-			start=chD.LongDescription.indexOf(&quot;&gt;&quot;,pos)+1;
-			String oldurl=chD.images.get(imageNo).getURL();
-			String imgString=chD.LongDescription.substring(pos, start);
-			if (imgString.indexOf(oldurl)==-1) {
+		int imageNo = 0;
+		String imgsrc = &quot;&quot;;
+		if (ModTypLongDesc == 1)
+			imgsrc = &quot;<A HREF="file://">file://</A>&quot; + Global.getProfile().dataDir;
+		while (start &gt;= 0 &amp;&amp; (pos = chD.LongDescription.indexOf(&quot;&lt;img&quot;, start)) &gt; 0) {
+			if (imageNo &gt;= chD.images.size())
+				break;
+			s.append(chD.LongDescription.substring(start, pos));
+			start = chD.LongDescription.indexOf(&quot;&gt;&quot;, pos) + 1;
+			String oldurl = chD.images.get(imageNo).getURL();
+			String imgString = chD.LongDescription.substring(pos, start);
+			if (imgString.indexOf(oldurl) == -1) {
 				if (oldurl.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) {
-					int i = oldurl.indexOf(&quot;/&quot;, 7)+1;
-					oldurl=oldurl.substring(i);
+					int i = oldurl.indexOf(&quot;/&quot;, 7) + 1;
+					oldurl = oldurl.substring(i);
 				}
 			}
-			String newurl=imgsrc+chD.images.get(imageNo).getFilename();
-			s.append(STRreplace.replace(imgString,oldurl,newurl));
+			String newurl = imgsrc + chD.images.get(imageNo).getFilename();
+			s.append(STRreplace.replace(imgString, oldurl, newurl));
 			imageNo++;
 		}
-		if (start&gt;=0) s.append(chD.LongDescription.substring(start));
+		if (start &gt;= 0)
+			s.append(chD.LongDescription.substring(start));
 		return s.toString();
 	}
 
@@ -914,56 +915,61 @@
 		Time nd = new Time();
 		return nd.setFormat(&quot;yyyy-MM-dd&quot;);
 	}
+
 	private final static Time nowtime() {
 		Time nt = new Time();
 		return nt.setFormat(&quot;HH:mm&quot;);
 	}
 
-	private final static String selbstLaute=&quot;aeiouAEIOU&quot;;
+	private final static String selbstLaute = &quot;aeiouAEIOU&quot;;
+
 	private final static String mitLauteKlein() {
-		final StringBuffer lower=new StringBuffer(26);// region/language dependent ?
-		for (int i=97; i&lt;=122; i++ ) {
+		final StringBuffer lower = new StringBuffer(26);// region/language dependent ?
+		for (int i = 97; i &lt;= 122; i++) {
 			lower.append((char) i);
 		}
 		return lower.toString();
 	}
+
 	public String shortenName(String Name, int maxLength) {
-		String shortName=removeCharsfromString(Name, maxLength, selbstLaute);
-		return  removeCharsfromString(shortName, maxLength, mitLauteKlein());
+		String shortName = removeCharsfromString(Name, maxLength, selbstLaute);
+		return removeCharsfromString(shortName, maxLength, mitLauteKlein());
 	}
-    private static String removeCharsfromString( String text, int MaxLength, String chars ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        int anzToRemove=originalTextLength-MaxLength;
-        if (anzToRemove&lt;=0) return text;
-        int anzRemoved=0;
-        StringBuffer sb = new StringBuffer( 50 );
-        for ( int i = originalTextLength-1; i &gt;= 0; i-- ) {
-            char c = text.charAt( i );
-            if (chars.indexOf(c) == -1) {
-            	sb.insert(0,c);
-            }
-            else {
-            	anzRemoved++;
-            	if (anzRemoved==anzToRemove) {
-            		sb.insert(0, text.substring(0,i));
-            		i=0; // exit for
-            	}
-            }
-        }
-        return sb.toString();
-    }
 
+	private static String removeCharsfromString(String text, int MaxLength, String chars) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		int anzToRemove = originalTextLength - MaxLength;
+		if (anzToRemove &lt;= 0)
+			return text;
+		int anzRemoved = 0;
+		StringBuffer sb = new StringBuffer(50);
+		for (int i = originalTextLength - 1; i &gt;= 0; i--) {
+			char c = text.charAt(i);
+			if (chars.indexOf(c) == -1) {
+				sb.insert(0, c);
+			} else {
+				anzRemoved++;
+				if (anzRemoved == anzToRemove) {
+					sb.insert(0, text.substring(0, i));
+					i = 0; // exit for
+				}
+			}
+		}
+		return sb.toString();
+	}
+
 	/** return true if waypoint is an additional waypoint of a cache */
 	public boolean isAddiWpt() {
 		return CacheType.isAddiWpt(type);
 	}
-	
+
 	/** return true if waypoint is a custom waypoint */
 	public boolean isCustomWpt() {
 		return CacheType.isCustomWpt(type);
 	}
-	
+
 	/** return true if waypoint is a cache main waypoint */
 	public boolean isCacheWpt() {
 		return CacheType.isCacheWpt(type);
@@ -971,15 +977,15 @@
 
 	/** return true waypoint has one or more additional waypoints */
 	public boolean hasAddiWpt() {
-		return addiWpts.getCount()&gt;0;
+		return addiWpts.getCount() &gt; 0;
 	}
 
 	public boolean isOC() {
 		return OC.isOC(wayPoint);
 	}
 
-	public void calcDistance(CWPoint toPoint) {	
-		if(pos.isValid()){
+	public void calcDistance(CWPoint toPoint) {
+		if (pos.isValid()) {
 			kilom = pos.getDistance(toPoint);
 			degrees = toPoint.getBearing(pos);
 			bearing = CWPoint.getDirection(degrees);
@@ -989,7 +995,7 @@
 		}
 	}
 
-	public void setAttributesFromMainCache(){
+	public void setAttributesFromMainCache() {
 		CacheHolder mainCh = this.mainCache;
 		this.setCacheOwner(mainCh.getCacheOwner());
 		if (mainCh.is_found()) {
@@ -997,9 +1003,8 @@
 				this.setCacheStatus(mainCh.getCacheStatus());
 				this.setFound(true);
 			}
-			// else addi is already found (perhaps at other time) 
-		}
-		else {
+			// else addi is already found (perhaps at other time)
+		} else {
 			// there may be a found addi , so don't overwrite
 			if ((this.getType() == CacheType.CW_TYPE_FINAL)) {
 				this.setCacheStatus(mainCh.getCacheStatus());
@@ -1013,10 +1018,10 @@
 		this.setNew(mainCh.is_new());
 	}
 
-	public void setAttributesToAddiWpts(){
-		if (this.hasAddiWpt()){
+	public void setAttributesToAddiWpts() {
+		if (this.hasAddiWpt()) {
 			CacheHolder addiWpt;
-			for (int i= this.addiWpts.getCount() - 1;  i&gt;=0; i--){
+			for (int i = this.addiWpts.getCount() - 1; i &gt;= 0; i--) {
 				addiWpt = (CacheHolder) this.addiWpts.get(i);
 				addiWpt.setAttributesFromMainCache();
 			}
@@ -1024,39 +1029,46 @@
 	}
 
 	/**
-	 * True if ch and this belong to the same main cache. 
+	 * True if ch and this belong to the same main cache.
+	 * 
 	 * @param ch
 	 * @return
 	 */
 	public boolean hasSameMainCache(CacheHolder ch) {
-		if (this == ch) return true;
-		if (ch == null) return false;
-		if ((!this.isAddiWpt()) &amp;&amp; (!ch.isAddiWpt())) return false;
+		if (this == ch)
+			return true;
+		if (ch == null)
+			return false;
+		if ((!this.isAddiWpt()) &amp;&amp; (!ch.isAddiWpt()))
+			return false;
 		CacheHolder main1, main2;
-		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
-		if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
+		if (this.isAddiWpt())
+			main1 = this.mainCache;
+		else
+			main1 = this;
+		if (ch.isAddiWpt())
+			main2 = ch.mainCache;
+		else
+			main2 = ch;
 		return main1 == main2;
 	}
 
-	/** Find out of detail object of Cache is loaded. Returns &lt;code&gt;true&lt;/code&gt; if this is the case.
+	/**
+	 * Find out of detail object of Cache is loaded. Returns &lt;code&gt;true&lt;/code&gt; if this is the case.
+	 * 
 	 * @return True when details object is present
 	 */
 	public boolean detailsLoaded() {
-		return details!=null;
+		return details != null;
 	}
 
 	/**
-	 * Gets the detail object of a cache. The detail object stores information which is not needed
-	 * for every cache instantaneously, but can be loaded if the user decides to look at this cache.
-	 * If the cache object is already existing, the method will return this object, otherwise it 
-	 * will create it and try to read it from the corresponding &lt;waypoint&gt;.xml file.
-	 * Depending on the parameters it is allowed that the &lt;waypoint&gt;.xml file does not yet exist,
-	 * or the user is warned that the file doesn't exist.
-	 * If more than &lt;code&gt;maxdetails&lt;/code&gt; details are loaded, then the 5 last recently loaded 
-	 * caches are unloaded (to save ram). 
+	 * Gets the detail object of a cache. The detail object stores information which is not needed for every cache instantaneously, but can be loaded if the user decides to look at this cache. If the cache object is already existing, the method will
+	 * return this object, otherwise it will create it and try to read it from the corresponding &lt;waypoint&gt;.xml file. Depending on the parameters it is allowed that the &lt;waypoint&gt;.xml file does not yet exist, or the user is warned that the file doesn't
+	 * exist. If more than &lt;code&gt;maxdetails&lt;/code&gt; details are loaded, then the 5 last recently loaded caches are unloaded (to save ram).
+	 * 
 	 * @param alarmuser
-	 *            If true an error message will be displayed to the user, if the details could not
-	 *            be read, and the method returns null 
+	 *            If true an error message will be displayed to the user, if the details could not be read, and the method returns null
 	 * @return The respective CacheHolderDetail, or null
 	 */
 	public CacheHolderDetail getCacheDetails(boolean alarmuser) {
@@ -1066,9 +1078,8 @@
 				details.readCache(Global.getProfile().dataDir);
 			} catch (IOException e) {
 				if (alarmuser) {
-					//FIXME: put a message to languages file
-					(new MessageBox(MyLocale.getMsg(31415,&quot;Error&quot;), MyLocale.getMsg(31415, &quot;Could not read cache details for cache: &quot;)
-					        + this.getWayPoint(), FormBase.OKB)).execute();
+					// FIXME: put a message to languages file
+					(new MessageBox(MyLocale.getMsg(31415, &quot;Error&quot;), MyLocale.getMsg(31415, &quot;Could not read cache details for cache: &quot;) + this.getWayPoint(), FormBase.OKB)).execute();
 					// details = null;
 				}
 				this.setIncomplete(true);
@@ -1076,111 +1087,115 @@
 			// for importing/spidering reasons helper objects with same waypoint are created
 			if (details != null &amp;&amp; !cachesWithLoadedDetails.contains(this)) {
 				cachesWithLoadedDetails.add(this);
-				if (cachesWithLoadedDetails.size() &gt;= Global.getPref().maxDetails) removeOldestDetails();
+				if (cachesWithLoadedDetails.size() &gt;= Global.getPref().maxDetails)
+					removeOldestDetails();
 			}
 		}
 		return details;
 	}
 
 	/**
-	 * Saves the cache to the corresponding &lt;waypoint&gt;.xml file, located in the profiles
-	 * directory. The waypoint of the 
-	 * cache should be set to do so.
+	 * Saves the cache to the corresponding &lt;waypoint&gt;.xml file, located in the profiles directory. The waypoint of the cache should be set to do so.
 	 */
 	public void save() {
 		checkIncomplete();
 		this.getCacheDetails(false).saveCacheDetails(Global.getProfile().dataDir);
 	}
-	
+
 	void releaseCacheDetails() {
-		if (details != null &amp;&amp; details.hasUnsavedChanges){
+		if (details != null &amp;&amp; details.hasUnsavedChanges) {
 			details.saveCacheDetails(Global.getProfile().dataDir);
 		}
 		details = null;
 		cachesWithLoadedDetails.remove(this);
 	}
 
-	//final static int maxDetails = 50; 
+	// final static int maxDetails = 50;
 	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
 
 	public static void removeOldestDetails() {
 		CacheHolder ch;
-		for (int i=0; i&lt;Global.getPref().deleteDetails; i++) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-	//		CacheHolder ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = 0; i &lt; Global.getPref().deleteDetails; i++) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null) ch.releaseCacheDetails();
-		}	
+			if (ch != null)
+				ch.releaseCacheDetails();
+		}
 	}
 
 	public static void removeAllDetails() {
 		CacheHolder ch;
-		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--) {
+		for (int i = cachesWithLoadedDetails.size() - 1; i &gt;= 0; i--) {
 			// String wp = (String) cachesWithLoadedDetails.get(i);
 			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null &amp;&amp; ch.detailsLoaded()) ch.releaseCacheDetails();
+			if (ch != null &amp;&amp; ch.detailsLoaded())
+				ch.releaseCacheDetails();
 		}
 	}
 
 	/**
-	 * when importing caches you can set details.saveChanges = true
-	 * when the import is finished call this method to save the pending changes
+	 * when importing caches you can set details.saveChanges = true when the import is finished call this method to save the pending changes
 	 */
 	public static void saveAllModifiedDetails() {
 		CacheHolder ch;
 		CacheHolderDetail chD;
-		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-//			ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = cachesWithLoadedDetails.size() - 1; i &gt;= 0; i--) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
 			if (ch != null) {
-	            chD = ch.getCacheDetails(true);
-	            if (chD!=null &amp;&amp; chD.hasUnsavedChanges) {
-		            //ch.calcRecommendationScore();
-		            chD.saveCacheDetails(Global.getProfile().dataDir);
-	            }
-            }
+				chD = ch.getCacheDetails(true);
+				if (chD != null &amp;&amp; chD.hasUnsavedChanges) {
+					// ch.calcRecommendationScore();
+					chD.saveCacheDetails(Global.getProfile().dataDir);
+				}
+			}
 		}
 	}
-	
+
 	public String getFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		return MyLocale.getMsg(msgNr, &quot;Found&quot;);
 	}
+
 	public String getGCFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		for (int i = 0; i &lt; _logType.length; i++) {
-			if ((&quot;&quot;+msgNr).equals(_logType[i][MSG_NR])) {
+			if ((&quot;&quot; + msgNr).equals(_logType[i][MSG_NR])) {
 				return _logType[i][GC_MSG];
-			}			
+			}
 		}
 		return &quot;&quot;;
 	}
+
 	public String getCWLogText(String s) {
 		for (int i = 0; i &lt; _logType.length; i++) {
 			if ((s).equals(_logType[i][GC_MSG])) {
-				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),&quot;&quot;);
-			}			
+				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), &quot;&quot;);
+			}
 		}
 		return &quot;&quot;;
 	}
-	
+
 	public String getStatusText() {
-		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) &amp;&amp;
-				cacheStatus.charAt(4) == '-') {
-			return getFoundText() + &quot; &quot; + cacheStatus;			
+		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) &amp;&amp; cacheStatus.charAt(4) == '-') {
+			return getFoundText() + &quot; &quot; + cacheStatus;
 		} else {
 			if (found) {
 				return getFoundText();
-			}
-			else {
+			} else {
 				return cacheStatus;
 			}
 		}
@@ -1188,137 +1203,119 @@
 
 	public String getStatusDate() {
 		String statusDate = &quot;&quot;;
-		
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,&quot;not found&quot;))&gt;10) {
-			Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, &quot;not found&quot;)) &gt; 10) {
+			Regex rexDate = new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
 			rexDate.search(getCacheStatus());
-			if (rexDate.stringMatched(1)!= null) {
+			if (rexDate.stringMatched(1) != null) {
 				statusDate = rexDate.stringMatched(1);
 			}
 		}
 
-		return statusDate;		
+		return statusDate;
 	}
-	
+
 	public String getStatusTime() {
 		String statusTime = &quot;&quot;;
 
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,&quot;not found&quot;))&gt;10) {
-			Regex rexTime=new Regex(&quot;([0-9]{1,2}:[0-9]{2})&quot;);
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, &quot;not found&quot;)) &gt; 10) {
+			Regex rexTime = new Regex(&quot;([0-9]{1,2}:[0-9]{2})&quot;);
 			rexTime.search(getCacheStatus());
-			if (rexTime.stringMatched(1)!= null) {
+			if (rexTime.stringMatched(1) != null) {
 				statusTime = rexTime.stringMatched(1);
-			}
-			else {
-				Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+			} else {
+				Regex rexDate = new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
 				rexDate.search(getCacheStatus());
-				if (rexDate.stringMatched(1)!= null) {
+				if (rexDate.stringMatched(1) != null) {
 					statusTime = &quot;00:00&quot;;
 				}
 			}
 		}
 
-		return statusTime;		
+		return statusTime;
 	}
-		
+
 	public String GetCacheID() {
 		String result = &quot;&quot;;
 		String pattern = getWayPoint().toUpperCase();
 
-		if ( pattern.startsWith( &quot;GC&quot; ) ) {
+		if (pattern.startsWith(&quot;GC&quot;)) {
 			int gcId = 0;
 
 			String sequence = &quot;0123456789ABCDEFGHJKMNPQRTVWXYZ&quot;;
-			
-			String rightPart = getWayPoint().substring( 2 ).toUpperCase();
-			
+
+			String rightPart = getWayPoint().substring(2).toUpperCase();
+
 			int base = 31;
 			if ((rightPart.length() &lt; 4) || (rightPart.length() == 4 &amp;&amp; sequence.indexOf(rightPart.charAt(0)) &lt; 16)) {
 				base = 16;
 			}
-			
-			for ( int p = 0; p &lt; rightPart.length(); p++ ) {
+
+			for (int p = 0; p &lt; rightPart.length(); p++) {
 				gcId *= base;
 				gcId += sequence.indexOf(rightPart.charAt(p));
 			}
-			
-	        if ( base == 31 ) {
-	        	gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
-	        }
-	        
-	        result = Integer.toString(gcId);	        
+
+			if (base == 31) {
+				gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
+			}
+
+			result = Integer.toString(gcId);
 		} else if (isOC()) {
-        	result = getOcCacheID();
-        }
+			result = getOcCacheID();
+		}
 
 		return result;
 	}
 
-	private final static int MSG_NR = 0; 
-	private final static int GC_MSG = 1; 
-	private final static int IDX_WRITENOTE = 5; 	
-	private final static String[][] _logType = {	
-			{&quot;353&quot;, &quot;&quot;},
-			{&quot;318&quot;, &quot;Found it&quot;},
-			{&quot;355&quot;, &quot;Attended&quot;},
-			{&quot;361&quot;, &quot;Webcam Photo Taken&quot;},
-			{&quot;319&quot;, &quot;Didn't find it&quot;},
-			{&quot;314&quot;, &quot;Write note&quot;}, // at change do change IDX_WRITENOTE = 5;
-			{&quot;315&quot;, &quot;Needs Archived&quot;},
-			{&quot;316&quot;, &quot;Needs Maintenance&quot;},
-			{&quot;317&quot;, &quot;Search&quot;}, 
-			{&quot;354&quot;, &quot;Will Attend&quot;},
-			{&quot;320&quot;, &quot;Owner&quot;},
-			{&quot;359&quot;, &quot;Owner Maintenance&quot;},
-			{&quot;356&quot;, &quot;Temporarily Disable Listing&quot;},
-			{&quot;357&quot;, &quot;Enable Listing&quot;},
-			{&quot;358&quot;, &quot;Post Reviewer Note&quot;},
-			{&quot;362&quot;, &quot;Solved&quot;},
-			{&quot;313&quot;, &quot;Flag 1&quot;},
-			{&quot;360&quot;, &quot;Flag 2&quot;},
-	};
+	private final static int MSG_NR = 0;
+	private final static int GC_MSG = 1;
+	private final static int IDX_WRITENOTE = 5;
+	private final static String[][] _logType = { { &quot;353&quot;, &quot;&quot; }, { &quot;318&quot;, &quot;Found it&quot; }, { &quot;355&quot;, &quot;Attended&quot; }, { &quot;361&quot;, &quot;Webcam Photo Taken&quot; }, { &quot;319&quot;, &quot;Didn't find it&quot; },
+			{ &quot;314&quot;, &quot;Write note&quot; }, // at change do change IDX_WRITENOTE = 5;
+			{ &quot;315&quot;, &quot;Needs Archived&quot; }, { &quot;316&quot;, &quot;Needs Maintenance&quot; }, { &quot;317&quot;, &quot;Search&quot; }, { &quot;354&quot;, &quot;Will Attend&quot; }, { &quot;320&quot;, &quot;Owner&quot; }, { &quot;359&quot;, &quot;Owner Maintenance&quot; }, { &quot;356&quot;, &quot;Temporarily Disable Listing&quot; }, { &quot;357&quot;, &quot;Enable Listing&quot; },
+			{ &quot;358&quot;, &quot;Post Reviewer Note&quot; }, { &quot;362&quot;, &quot;Solved&quot; }, { &quot;313&quot;, &quot;Flag 1&quot; }, { &quot;360&quot;, &quot;Flag 2&quot; }, };
 
 	public final static String[] GetGuiLogTypes() {
 		String[] ret = new String[_logType.length];
 		for (int i = 0; i &lt; _logType.length; i++) {
-			ret[i]=MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),&quot;&quot;);
+			ret[i] = MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), &quot;&quot;);
 		}
 		return ret;
 	}
-	
-	public String getGCLogType() {                                                                                
-		String gcLogType=_logType[IDX_WRITENOTE][GC_MSG];
+
+	public String getGCLogType() {
+		String gcLogType = _logType[IDX_WRITENOTE][GC_MSG];
 		if (is_found()) {
-			String msgNr=&quot;318&quot;; // normal found			
-			if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=&quot;361&quot;;}
-			else if (type == CacheType.CW_TYPE_EVENT 
-					|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=&quot;355&quot;;}
+			String msgNr = &quot;318&quot;; // normal found
+			if (type == CacheType.CW_TYPE_WEBCAM) {
+				msgNr = &quot;361&quot;;
+			} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+				msgNr = &quot;355&quot;;
+			}
 			for (int i = 1; i &lt; _logType.length; i++) {
 				if (_logType[i][MSG_NR].equals(msgNr)) {
-					gcLogType = _logType[i][GC_MSG]; 
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
-		}
-		else {
-			String CacheStatus=getCacheStatus();  
+		} else {
+			String CacheStatus = getCacheStatus();
 			for (int i = 1; i &lt; _logType.length; i++) {
-				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),&quot;&quot;))) {
-					gcLogType=_logType[i][GC_MSG];
+				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), &quot;&quot;))) {
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
 		}
-		return gcLogType;    
-	}                                                                                                             
-	
-	
-	
+		return gcLogType;
+	}
+
 	/**
-	 * Initializes the caches states (and its addis) before updating, so that the &quot;new&quot;, &quot;updated&quot;,
-	 * &quot;log_updated&quot; and &quot;incomplete&quot; properties are properly set. 
-	 * @param pNewCache &lt;code&gt;true&lt;/code&gt; if it is a new cache (i.e. a cache not existing in CacheDB),
-	 * &lt;code&gt;false&lt;/code&gt; otherwise.
+	 * Initializes the caches states (and its addis) before updating, so that the &quot;new&quot;, &quot;updated&quot;, &quot;log_updated&quot; and &quot;incomplete&quot; properties are properly set.
+	 * 
+	 * @param pNewCache
+	 *            &lt;code&gt;true&lt;/code&gt; if it is a new cache (i.e. a cache not existing in CacheDB), &lt;code&gt;false&lt;/code&gt; otherwise.
 	 */
 	public void initStates(boolean pNewCache) {
 		this.setNew(pNewCache);
@@ -1326,59 +1323,43 @@
 		this.setLog_updated(false);
 		this.setIncomplete(false);
 		if (!pNewCache &amp;&amp; this.hasAddiWpt()) {
-			for (int i=0; i&lt;this.addiWpts.size(); i++) {
-				((CacheHolder)this.addiWpts.get(i)).initStates(pNewCache);
+			for (int i = 0; i &lt; this.addiWpts.size(); i++) {
+				((CacheHolder) this.addiWpts.get(i)).initStates(pNewCache);
 			}
 		}
 	}
 
 	/**
-	 * Creates a bit field of boolean values of the cache, represented as a long value.
-	 * Boolean value of &lt;code&gt;true&lt;/code&gt; results in &lt;code&gt;1&lt;/code&gt; in the long values bits,
-	 * and, vice versa, 0 for false.
+	 * Creates a bit field of boolean values of the cache, represented as a long value. Boolean value of &lt;code&gt;true&lt;/code&gt; results in &lt;code&gt;1&lt;/code&gt; in the long values bits, and, vice versa, 0 for false.
+	 * 
 	 * @return long value representing the boolean bit field
 	 */
 	private long boolFields2long() {
 		// To get the same list of visible caches after loading a profile,
-		// the property isVisible() is saved instead of is_filtered(), but at 
+		// the property isVisible() is saved instead of is_filtered(), but at
 		// the place where is_filtered() is read.
-		long value = bool2BitMask(!this.isVisible(), 1)     | 
-		             bool2BitMask(this.is_available(), 2)   |
-		             bool2BitMask(this.is_archived(), 3)    |
-		             bool2BitMask(this.has_bugs(), 4)       |
-		             bool2BitMask(this.is_black(), 5)       |
-		             bool2BitMask(this.is_owned(), 6)       |
-		             bool2BitMask(this.is_found(), 7)       |
-		             bool2BitMask(this.is_new(), 8)         |
-		             bool2BitMask(this.is_log_updated(), 9) |
-		             bool2BitMask(this.is_updated(), 10)    |
-		             bool2BitMask(this.is_HTML(), 11)       |
-		             bool2BitMask(this.is_incomplete(), 12) |
-		             bool2BitMask(this.hasNote(), 13)       |
-		             bool2BitMask(this.hasSolver(), 14);		             
+		long value = bool2BitMask(!this.isVisible(), 1) | bool2BitMask(this.is_available(), 2) | bool2BitMask(this.is_archived(), 3) | bool2BitMask(this.has_bugs(), 4) | bool2BitMask(this.is_black(), 5) | bool2BitMask(this.is_owned(), 6)
+				| bool2BitMask(this.is_found(), 7) | bool2BitMask(this.is_new(), 8) | bool2BitMask(this.is_log_updated(), 9) | bool2BitMask(this.is_updated(), 10) | bool2BitMask(this.is_HTML(), 11) | bool2BitMask(this.is_incomplete(), 12)
+				| bool2BitMask(this.hasNote(), 13) | bool2BitMask(this.hasSolver(), 14);
 		return value;
 	}
 
 	/**
-	 * Creates a field of byte values of certain properties of the cache, represented
-	 * as a long value.
-	 * As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8
-	 * bits. The position indicates the group of bits where the byte is packed,
+	 * Creates a field of byte values of certain properties of the cache, represented as a long value. As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8 bits. The position indicates the group of bits where the byte is packed,
 	 * counting starting from one by the right side of the long.
+	 * 
 	 * @return long value representing the byte field
 	 */
 	private long byteFields2long() {
-		long value = byteBitMask(hard, 1)    | 
-		byteBitMask(terrain, 2)   |
-		byteBitMask(type, 3)    |
-		byteBitMask(cacheSize, 4)|
-		byteBitMask(this.noFindLogs, 5);		             
+		long value = byteBitMask(hard, 1) | byteBitMask(terrain, 2) | byteBitMask(type, 3) | byteBitMask(cacheSize, 4) | byteBitMask(this.noFindLogs, 5);
 		return value;
 	}
-	
+
 	/**
 	 * Evaluates byte values from a long value for certain properties of the cache.
-	 * @param value The long value which contains up to 8 bytes.
+	 * 
+	 * @param value
+	 *            The long value which contains up to 8 bytes.
 	 */
 	private void long2byteFields(long value) {
 		setHard(byteFromLong(value, 1));
@@ -1386,17 +1367,15 @@
 		setType(byteFromLong(value, 3));
 		setCacheSize(byteFromLong(value, 4));
 		setNoFindLogs((byteFromLong(value, 5)));
-		
-		if ( getHard() == CacheTerrDiff.CW_DT_ERROR 
-				|| getTerrain() == CacheTerrDiff.CW_DT_ERROR 
-				|| getCacheSize() == CacheSize.CW_SIZE_ERROR 
-				|| getType() == CacheType.CW_TYPE_ERROR ) {
+
+		if (getHard() == CacheTerrDiff.CW_DT_ERROR || getTerrain() == CacheTerrDiff.CW_DT_ERROR || getCacheSize() == CacheSize.CW_SIZE_ERROR || getType() == CacheType.CW_TYPE_ERROR) {
 			setIncomplete(true);
 		}
 	}
-	
+
 	/**
 	 * convert a v2 byte filed to the current structures
+	 * 
 	 * @param value
 	 */
 	private void long2byteFieldsv2(long value) {
@@ -1408,11 +1387,14 @@
 		if (getHard() == -1 || getTerrain() == -1 || getCacheSize() == -1) {
 			if (isAddiWpt() || isCustomWpt()) {
 				// Addis don't have their own values for difficulty, terrain and size
-				// Custom waypoints can't be updated to remove incomplete flag, so we 
+				// Custom waypoints can't be updated to remove incomplete flag, so we
 				// have to set reasonable values.
-				if (getHard() == CacheTerrDiff.CW_DT_ERROR) setHard(CacheTerrDiff.CW_DT_UNSET);
-				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR) setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (getCacheSize() == CacheSize.CW_SIZE_ERROR) setCacheSize(CacheSize.CW_SIZE_NONE);
+				if (getHard() == CacheTerrDiff.CW_DT_ERROR)
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR)
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				if (getCacheSize() == CacheSize.CW_SIZE_ERROR)
+					setCacheSize(CacheSize.CW_SIZE_NONE);
 			} else {
 				setIncomplete(true);
 			}
@@ -1420,21 +1402,24 @@
 	}
 
 	/**
-	 * Extracts a byte from a long value. The position is the number of the 8-bit block
-	 * of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the
-	 * right side of the long.
-     * @param value The long value which contains the bytes
-     * @param position The position of the byte, from 1 to 8
-     * @return The decoded byte value
-     */
-    private byte byteFromLong(long value, int position) {
+	 * Extracts a byte from a long value. The position is the number of the 8-bit block of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the right side of the long.
+	 * 
+	 * @param value
+	 *            The long value which contains the bytes
+	 * @param position
+	 *            The position of the byte, from 1 to 8
+	 * @return The decoded byte value
+	 */
+	private byte byteFromLong(long value, int position) {
 		byte b = -1; // = 11111111
-	    return (byte)((value &amp; this.byteBitMask(b, position))&gt;&gt;&gt;(position-1)*8);
-    }
+		return (byte) ((value &amp; this.byteBitMask(b, position)) &gt;&gt;&gt; (position - 1) * 8);
+	}
 
 	/**
 	 * Evaluates boolean values from a long value, which is seen as bit field.
-	 * @param value The bit field as long value
+	 * 
+	 * @param value
+	 *            The bit field as long value
 	 */
 	private void long2boolFields(long value) {
 		this.setFiltered((value &amp; this.bool2BitMask(true, 1)) != 0);
@@ -1452,57 +1437,49 @@
 		this.setHasNote((value &amp; this.bool2BitMask(true, 13)) != 0);
 		this.setHasSolver((value &amp; this.bool2BitMask(true, 14)) != 0);
 	}
-	
+
 	/**
-	 * Represents a bit mask as long value for a boolean value which is saved at
-	 * a specified position in the long field.
-	 * @param value The boolean value we want to code
-	 * @param position Position of the value in the bit mask
-	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for
-	 * the one we like to represent: This is 1 if the value is true, 0 if not. 
+	 * Represents a bit mask as long value for a boolean value which is saved at a specified position in the long field.
+	 * 
+	 * @param value
+	 *            The boolean value we want to code
+	 * @param position
+	 *            Position of the value in the bit mask
+	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for the one we like to represent: This is 1 if the value is true, 0 if not.
 	 */
 	private long bool2BitMask(boolean value, int position) {
 		if (value) {
-			return (1L &lt;&lt; (position-1));
+			return (1L &lt;&lt; (position - 1));
 		} else {
 			return 0L;
 		}
 	}
-	
+
 	/**
-	 * Coding a long field which has only the bits of the byte value set. The position is the 
-	 * number (from 1 to 8) of the byte block which is used from the long.
-	 * @param value Byte to encode
-	 * @param position Position of the byte value in the long
+	 * Coding a long field which has only the bits of the byte value set. The position is the number (from 1 to 8) of the byte block which is used from the long.
+	 * 
+	 * @param value
+	 *            Byte to encode
+	 * @param position
+	 *            Position of the byte value in the long
 	 * @return Encoded byte value as long
 	 */
 	private long byteBitMask(byte value, int position) {
-		long result = (0xFF &amp; (long) value) &lt;&lt; ((position-1) *8);
+		long result = (0xFF &amp; (long) value) &lt;&lt; ((position - 1) * 8);
 		return result;
 	}
 
-
 	/**
-	 * Returns &lt;code&gt;true&lt;/code&gt; if the waypoint should appear in the cache list, 
-	 * &lt;code&gt;false&lt;/code&gt; if it should not appear.&lt;br&gt;
-	 * The method takes into account blacklist, filters, search results - everything
-	 * that determines if a cache is visible in the list or not. 
+	 * Returns &lt;code&gt;true&lt;/code&gt; if the waypoint should appear in the cache list, &lt;code&gt;false&lt;/code&gt; if it should not appear.&lt;br&gt;
+	 * The method takes into account blacklist, filters, search results - everything that determines if a cache is visible in the list or not.
+	 * 
 	 * @return
 	 */
 	public boolean isVisible() {
 		Profile profile = Global.getProfile();
 		int filter = profile.getFilterActive();
-		boolean noShow=
-			(  (profile.showBlacklisted() != this.is_black())   
-				||
-			   (profile.showSearchResult() &amp;&amp; !this.is_flaged)   
-			    ||
-			   ( (filter == Filter.FILTER_ACTIVE||filter == Filter.FILTER_MARKED_ONLY) &amp;&amp;	
-			  	 (this.is_filtered())^profile.isFilterInverted())                            
-			  	||
-			   (filter == Filter.FILTER_CACHELIST) &amp;&amp; 
-			     !Global.mainForm.cacheList.contains(this.getWayPoint())
-			);
+		boolean noShow = ((profile.showBlacklisted() != this.is_black()) || (profile.showSearchResult() &amp;&amp; !this.is_flaged) || ((filter == Filter.FILTER_ACTIVE || filter == Filter.FILTER_MARKED_ONLY) &amp;&amp; (this.is_filtered()) ^ profile.isFilterInverted()) || (filter == Filter.FILTER_CACHELIST)
+				&amp;&amp; !Global.mainForm.cacheList.contains(this.getWayPoint()));
 		boolean showAddi = this.showAddis() &amp;&amp; this.mainCache != null &amp;&amp; this.mainCache.isVisible();
 		noShow = noShow &amp;&amp; !showAddi;
 		return !noShow;
@@ -1510,198 +1487,218 @@
 
 	// Getter and Setter for private properties
 
-	public String getLatLon() { return LatLon; }
+	public String getLatLon() {
+		return LatLon;
+	}
+
 	public void setLatLon(String _LatLon) {
-		_LatLon=_LatLon.trim();
-		if (!_LatLon.equals(LatLon.trim())) setUpdated(true);
+		_LatLon = _LatLon.trim();
+		if (!_LatLon.equals(LatLon.trim()))
+			setUpdated(true);
 		LatLon = _LatLon;
 		pos.set(_LatLon);
 	}
 
-	public String getBearing() {return bearing;}
-	
+	public String getBearing() {
+		return bearing;
+	}
+
 	/**
-	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the 
-	 * last call of the method, the same (cached) object is returned. If the object is
-	 * null or the level is different, a new object is created.&lt;br&gt; 
-	 * @param level 4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
-	 * @param fm Font metrics
+	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the last call of the method, the same (cached) object is returned. If the object is null or the level is different, a new object is created.&lt;br&gt;
+	 * 
+	 * @param level
+	 *            4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
+	 * @param fm
+	 *            Font metrics
 	 * @return New or old IconAndText object
 	 */
 	public IconAndText getIconAndTextWP(int level, FontMetrics fm) {
 		if (level != iconAndTextWPLevel || iconAndTextWP == null || !iconAndTextWP.text.equals(wayPoint)) {
 			switch (level) {
-				case 4: iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm); break;
-				case 3: iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm); break;
-				case 2: iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm); break;
-				case 1: iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm); break;
+			case 4:
+				iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm);
+				break;
+			case 3:
+				iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm);
+				break;
+			case 2:
+				iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm);
+				break;
+			case 1:
+				iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm);
+				break;
 			}
 			iconAndTextWPLevel = level;
 		}
 		return iconAndTextWP;
 	}
-	
-	public String getCacheStatus() { return cacheStatus; }
 
+	public String getCacheStatus() {
+		return cacheStatus;
+	}
+
 	public void setCacheStatus(String cacheStatus) {
-        if (!cacheStatus.equals(this.cacheStatus)) {
-        	this.cacheStatus = cacheStatus;
-            Global.getProfile().notifyUnsavedChanges(true);		
-            this.cacheStatus = cacheStatus;
-            if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null) ) {
-              this.mainCache.setCacheStatus(this.getCacheStatus());
-              // change the addi's in setFound
-            }
-        }
+		if (!cacheStatus.equals(this.cacheStatus)) {
+			this.cacheStatus = cacheStatus;
+			Global.getProfile().notifyUnsavedChanges(true);
+			this.cacheStatus = cacheStatus;
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null)) {
+				this.mainCache.setCacheStatus(this.getCacheStatus());
+				// change the addi's in setFound
+			}
+		}
 	}
 
 	public String getWayPoint() {
-    	return wayPoint;
-    }
+		return wayPoint;
+	}
 
 	public void setWayPoint(String wayPoint) {
-		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));		
-    	this.wayPoint = wayPoint;
-    }
+		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));
+		this.wayPoint = wayPoint;
+	}
 
 	public String getCacheName() {
-    	return cacheName;
-    }
+		return cacheName;
+	}
 
 	public void setCacheName(String cacheName) {
-		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));		
-    	this.cacheName = cacheName;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));
+		this.cacheName = cacheName;
+	}
 
 	public String getCacheOwner() {
-    	return cacheOwner;
-    }
+		return cacheOwner;
+	}
 
 	public void setCacheOwner(String cacheOwner) {
-		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));		
-    	this.cacheOwner = cacheOwner;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));
+		this.cacheOwner = cacheOwner;
+	}
 
 	public String getDateHidden() {
-    	return dateHidden;
-    }
+		return dateHidden;
+	}
 
 	public void setDateHidden(String dateHidden) {
-		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));		
-    	this.dateHidden = dateHidden;
-    }
+		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));
+		this.dateHidden = dateHidden;
+	}
 
 	public byte getCacheSize() {
-    	return cacheSize;
-    }
+		return cacheSize;
+	}
 
 	public void setCacheSize(byte cacheSize) {
-		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);		
-    	this.cacheSize = cacheSize;
-    }
+		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);
+		this.cacheSize = cacheSize;
+	}
 
 	public byte getHard() {
-    	return hard;
-    }
+		return hard;
+	}
 
 	public void setHard(byte hard) {
-		Global.getProfile().notifyUnsavedChanges(hard != this.hard);		
-    	this.hard = hard;
-    }
+		Global.getProfile().notifyUnsavedChanges(hard != this.hard);
+		this.hard = hard;
+	}
 
 	public byte getTerrain() {
-    	return terrain;
-    }
+		return terrain;
+	}
 
 	public void setTerrain(byte terrain) {
-		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);		
-    	this.terrain = terrain;
-    }
+		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);
+		this.terrain = terrain;
+	}
 
 	/**
 	 * Gets the type of cache as integer.
+	 * 
 	 * @return Cache type
 	 */
 	public byte getType() {
 		return type;
-    }
+	}
 
 	/**
-	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf
-	 * and byte internally of CacheHolder, some conversion has to be done.
-	 * @param typeId Cache Type
+	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf and byte internally of CacheHolder, some conversion has to be done.
+	 * 
+	 * @param typeId
+	 *            Cache Type
 	 */
 	public void setType(byte typeId) {
-		Global.getProfile().notifyUnsavedChanges(typeId != type);		
-    	type = typeId;
-    }
+		Global.getProfile().notifyUnsavedChanges(typeId != type);
+		type = typeId;
+	}
 
 	public boolean is_archived() {
-    	return archived;
-    }
+		return archived;
+	}
 
 	public void setArchived(boolean is_archived) {
-		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);		
-    	this.archived = is_archived;
-    	if (this.archived) {this.available=false;}
-    }
+		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);
+		this.archived = is_archived;
+		if (this.archived) {
+			this.available = false;
+		}
+	}
 
 	public boolean is_available() {
-    	return available;
-    }
+		return available;
+	}
 
 	public void setAvailable(boolean is_available) {
 		Global.getProfile().notifyUnsavedChanges(is_available != this.available);
-    	this.available = is_available;
-		if (this.available) {this.archived=false;}
-    }
+		this.available = is_available;
+		if (this.available) {
+			this.archived = false;
+		}
+	}
 
 	public boolean is_owned() {
-    	return owned;
-    }
+		return owned;
+	}
 
 	public void setOwned(boolean is_owned) {
-		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);		
-    	this.owned = is_owned;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);
+		this.owned = is_owned;
+	}
 
 	public boolean is_found() {
-    	return found;
-    }
+		return found;
+	}
 
 	public void setFound(boolean is_found) {
-    if (is_found != this.found) {
-      Global.getProfile().notifyUnsavedChanges(true);		
-      this.found = is_found;
-      if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null) ) {
-        this.mainCache.setFound(is_found);
-		// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
-        // so setFound should be called after setCacheStatus 
-        if (is_found) this.mainCache.setAttributesToAddiWpts();
-      }
-    }
-  }
+		if (is_found != this.found) {
+			Global.getProfile().notifyUnsavedChanges(true);
+			this.found = is_found;
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null)) {
+				this.mainCache.setFound(is_found);
+				// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
+				// so setFound should be called after setCacheStatus
+				if (is_found)
+					this.mainCache.setAttributesToAddiWpts();
+			}
+		}
+	}
 
 	/**
-	 * If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal 
-	 * filter settings apply.&lt;br&gt;
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
+	 * If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal filter settings apply.&lt;br&gt;
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
 	 * @return &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
 	 */
 	public boolean showAddis() {
 		return this.showAddis;
 	}
-	
+
 	/**
-	 * Setter for &lt;code&gt;showAddis()&lt;/code&gt;. 
-	 * If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal 
-	 * filter settings apply.&lt;br&gt;
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
-	 * @param value &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
+	 * Setter for &lt;code&gt;showAddis()&lt;/code&gt;. If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal filter settings apply.&lt;br&gt;
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
+	 * @param value
+	 *            &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
 	 */
 	public void setShowAddis(boolean value) {
 		// This value is always stored in the main cache and all addis.
@@ -1713,17 +1710,15 @@
 		}
 		if (mc.showAddis != value) {
 			mc.showAddis = value;
-			for (int i=0; i&lt;mc.addiWpts.size(); i++) {
+			for (int i = 0; i &lt; mc.addiWpts.size(); i++) {
 				CacheHolder ac = (CacheHolder) mc.addiWpts.get(i);
 				ac.showAddis = value;
 			}
 		}
 	}
-	
+
 	/**
-	 * &lt;b&gt;&lt;u&gt;Important&lt;/u&gt;&lt;/b&gt;: This flag no longer indicates if a cache is visible
-	 * in the list. Instead, it now &lt;u&gt;only&lt;/u&gt; flags if the cache is filtered out
-	 * by filter criteria. Use &lt;code&gt;isVisible()&lt;/code&gt; instead.&lt;br&gt;
+	 * &lt;b&gt;&lt;u&gt;Important&lt;/u&gt;&lt;/b&gt;: This flag no longer indicates if a cache is visible in the list. Instead, it now &lt;u&gt;only&lt;/u&gt; flags if the cache is filtered out by filter criteria. Use &lt;code&gt;isVisible()&lt;/code&gt; instead.&lt;br&gt;
 	 * This property is affected by the following features:
 	 * &lt;ul&gt;
 	 * &lt;li&gt;&quot;Defining and applying&quot; a filter&lt;/li&gt;
@@ -1737,239 +1732,232 @@
 	 * &lt;li&gt;Applying a cache tour filter&lt;/li&gt;
 	 * &lt;li&gt;Switching between normal view and blacklist view&lt;/li&gt;
 	 * &lt;li&gt;Performing searches&lt;/li&gt;
-	 * &lt;li&gt;Anything else that isn't directly connected to filters in 
-	 * it's proper sense.&lt;/li&gt;
+	 * &lt;li&gt;Anything else that isn't directly connected to filters in it's proper sense.&lt;/li&gt;
 	 * &lt;/ul&gt;
 	 * The new method for deciding if a cache is visible or not is &lt;code&gt;isVisible()
-	 * &lt;/code&gt;.  
+	 * &lt;/code&gt;.
+	 * 
 	 * @return &lt;code&gt;True&lt;/code&gt; if filter criteria are matched
 	 */
 	public boolean is_filtered() {
-    	return filtered;
-    }
+		return filtered;
+	}
 
 	public void setFiltered(boolean is_filtered) {
-		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);		
-    	this.filtered = is_filtered;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);
+		this.filtered = is_filtered;
+	}
 
 	public boolean is_log_updated() {
-    	return log_updated;
-    }
+		return log_updated;
+	}
 
 	public void setLog_updated(boolean is_log_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);		
-		if (is_log_updated &amp;&amp; iconAndTextWPLevel == 1) iconAndTextWP = null;
-    	this.log_updated = is_log_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);
+		if (is_log_updated &amp;&amp; iconAndTextWPLevel == 1)
+			iconAndTextWP = null;
+		this.log_updated = is_log_updated;
+	}
 
 	public boolean is_updated() {
-    	return cache_updated;
-    }
+		return cache_updated;
+	}
 
 	public void setUpdated(boolean is_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);		
-		if (is_updated &amp;&amp; iconAndTextWPLevel == 2) iconAndTextWP = null;
-    	this.cache_updated = is_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);
+		if (is_updated &amp;&amp; iconAndTextWPLevel == 2)
+			iconAndTextWP = null;
+		this.cache_updated = is_updated;
+	}
 
 	public boolean is_incomplete() {
-    	return incomplete;
-    }
+		return incomplete;
+	}
 
 	public void setIncomplete(boolean is_incomplete) {
-		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);	
-		if (is_incomplete &amp;&amp; iconAndTextWPLevel == 4) iconAndTextWP = null;
-    	this.incomplete = is_incomplete;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);
+		if (is_incomplete &amp;&amp; iconAndTextWPLevel == 4)
+			iconAndTextWP = null;
+		this.incomplete = is_incomplete;
+	}
+
 	/** checks the waypoint data integrity to set a warning flag if something is missing */
 	public boolean checkIncomplete() {
 		// TODO: discuss if we should only check cache waypoints and silently &quot;fix&quot; everything else
 		boolean ret;
 		if (isCacheWpt()) {
-			if (getWayPoint().length() &lt; 3
-					|| getHard() &lt; CacheTerrDiff.CW_DT_UNSET
-					|| getTerrain() &lt; CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() == CacheSize.CW_SIZE_ERROR
-					|| getCacheOwner().length() == 0
-					|| getDateHidden().length() == 0 
-					|| getCacheName().length() == 0) 
+			if (getWayPoint().length() &lt; 3 || getHard() &lt; CacheTerrDiff.CW_DT_UNSET || getTerrain() &lt; CacheTerrDiff.CW_DT_UNSET || getCacheSize() == CacheSize.CW_SIZE_ERROR || getCacheOwner().length() == 0 || getDateHidden().length() == 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isAddiWpt()) {
-			//FIXME: do not check for mainCache == null, since it will be null during initial import
-			//FIXME: find out why we only check waypoints with IDs of a certain length ???
-//			if (mainCache == null
-//					|| getHard() != CacheTerrDiff.CW_DT_UNSET 
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getWayPoint().length() &lt; 3
-//					|| getCacheOwner().length() &gt; 0
-//					|| getDateHidden().length() &gt; 0 
-					|| getCacheName().length() == 0
-					)
+			// FIXME: do not check for mainCache == null, since it will be null during initial import
+			// FIXME: find out why we only check waypoints with IDs of a certain length ???
+			// if (mainCache == null
+			// || getHard() != CacheTerrDiff.CW_DT_UNSET
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getWayPoint().length() &lt; 3
+			// || getCacheOwner().length() &gt; 0
+			// || getDateHidden().length() &gt; 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isCustomWpt()) {
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET 
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getWayPoint().length() &lt; 3
-//					|| getCacheOwner().length() &gt; 0
-//					|| getDateHidden().length() &gt; 0 
-//					|| getCacheName().length() == 0
-					)
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getWayPoint().length() &lt; 3
+			// || getCacheOwner().length() &gt; 0
+			// || getDateHidden().length() &gt; 0
+			// || getCacheName().length() == 0
+			)
 				ret = true;
 			else
 				ret = false;
 		} else {
 			// we should not get here, so let's set a warning just in case
-			ret=true;
+			ret = true;
 		}
 		setIncomplete(ret);
 		return ret;
 	}
 
 	/**
-	 * Determines if the blacklist status is set for the cache. Do not use this method
-	 * to check if the cache should be displayed. Use &lt;code&gt;isVisible()&lt;/code&gt; for
-	 * this, which already does this (and other) checks.&lt;br&gt;
-	 * Only use this method if you really want to inform yourself about the 
-	 * black status of the cache!
+	 * Determines if the blacklist status is set for the cache. Do not use this method to check if the cache should be displayed. Use &lt;code&gt;isVisible()&lt;/code&gt; for this, which already does this (and other) checks.&lt;br&gt;
+	 * Only use this method if you really want to inform yourself about the black status of the cache!
+	 * 
 	 * @return &lt;code&gt;true&lt;/code&gt; if he black status of the cache is set.
 	 */
 	public boolean is_black() {
-    	return black;
-    }
+		return black;
+	}
 
 	public void setBlack(boolean is_black) {
-		Global.getProfile().notifyUnsavedChanges(is_black != this.black);		
-    	this.black = is_black;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_black != this.black);
+		this.black = is_black;
+	}
 
 	public boolean is_new() {
-    	return newCache;
-    }
+		return newCache;
+	}
 
 	public void setNew(boolean is_new) {
-		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);		
-		if (is_new &amp;&amp; iconAndTextWPLevel == 3) iconAndTextWP = null;
+		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);
+		if (is_new &amp;&amp; iconAndTextWPLevel == 3)
+			iconAndTextWP = null;
 		this.newCache = is_new;
-    }
+	}
 
 	public String getOcCacheID() {
-    	return ocCacheID;
-    }
+		return ocCacheID;
+	}
 
 	public void setOcCacheID(String ocCacheID) {
-		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));		
-    	this.ocCacheID = ocCacheID;
-    }
+		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));
+		this.ocCacheID = ocCacheID;
+	}
 
 	public byte getNoFindLogs() {
-    	return noFindLogs;
-    }
+		return noFindLogs;
+	}
 
 	public void setNoFindLogs(byte noFindLogs) {
-		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);		
-    	this.noFindLogs = noFindLogs;
-    }
+		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);
+		this.noFindLogs = noFindLogs;
+	}
 
 	public int getNumRecommended() {
-    	return numRecommended;
-    }
+		return numRecommended;
+	}
+
 	public String getRecommended() {
 		if (!isCacheWpt())
 			return &quot;&quot;;
-		if ( isOC() ) {
-		  return Convert.formatInt(numRecommended);
+		if (isOC()) {
+			return Convert.formatInt(numRecommended);
 		} else {
-		  int gcVote = numRecommended;
-		  if ( gcVote &lt; 100 ) {
-		    return MyLocale.formatDouble((double)gcVote/10.0, &quot;0.0&quot;); 
-		  } else {
-		    int votes = gcVote / 100;
-		    gcVote = gcVote - 100 * votes;
-		    return MyLocale.formatDouble((double)gcVote/10.0, &quot;0.0&quot;) + &quot; (&quot; + Convert.formatInt(votes) + &quot;)&quot;;
-		  }
+			int gcVote = numRecommended;
+			if (gcVote &lt; 100) {
+				return MyLocale.formatDouble((double) gcVote / 10.0, &quot;0.0&quot;);
+			} else {
+				int votes = gcVote / 100;
+				gcVote = gcVote - 100 * votes;
+				return MyLocale.formatDouble((double) gcVote / 10.0, &quot;0.0&quot;) + &quot; (&quot; + Convert.formatInt(votes) + &quot;)&quot;;
+			}
 		}
 	}
 
 	public void setNumRecommended(int numRecommended) {
-		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);		
-    	this.numRecommended = numRecommended;
-    }
+		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);
+		this.numRecommended = numRecommended;
+	}
 
 	public int getNumFoundsSinceRecommendation() {
-    	return numFoundsSinceRecommendation;
-    }
+		return numFoundsSinceRecommendation;
+	}
 
 	public void setNumFoundsSinceRecommendation(int numFoundsSinceRecommendation) {
-		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);		
-    	this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
-    }
+		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);
+		this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
+	}
 
 	public boolean has_bugs() {
-    	return bugs;
-    }
+		return bugs;
+	}
 
 	public void setHas_bugs(boolean has_bug) {
-		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);		
-    	this.bugs = has_bug;
-    }
+		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);
+		this.bugs = has_bug;
+	}
 
 	public boolean is_HTML() {
-    	return html;
-    }
+		return html;
+	}
 
 	public void setHTML(boolean is_HTML) {
-		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);		
-    	this.html = is_HTML;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);
+		this.html = is_HTML;
+	}
 
 	public String getLastSync() {
-    	return lastSync;
-    }
+		return lastSync;
+	}
 
 	public void setLastSync(String lastSync) {
-		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));		
-    	this.lastSync = lastSync;
-    }
+		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));
+		this.lastSync = lastSync;
+	}
 
 	public long[] getAttributesBits() {
-    	return this.attributesBits;
-    }
+		return this.attributesBits;
+	}
 
 	public void setAttribsAsBits(long[] attributesBits) {
-		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);		
-    	this.attributesBits = attributesBits;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);
+		this.attributesBits = attributesBits;
+	}
+
 	public boolean hasSolver() {
 		return hasSolver;
 	}
-	
+
 	public void setHasSolver(boolean hasSolver) {
-		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);		
+		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);
 		this.hasSolver = hasSolver;
 	}
 
 	public boolean hasNote() {
 		return hasNote;
 	}
-	
+
 	public void setHasNote(boolean hasNote) {
-		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);		
+		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);
 		this.hasNote = hasNote;
 	}
-	
+
 	/**
 	 * rename a waypoint and all its associated files
-	 * @param newWptId new waypoint id (will be converted to upper case)
+	 * 
+	 * @param newWptId
+	 *            new waypoint id (will be converted to upper case)
 	 * @return true on success, false on error
 	 */
 	public boolean rename(String newWptId) {
@@ -1985,4 +1973,3 @@
 		}
 	}
 }
-

Modified: trunk/src/CacheWolf/DateFormat.java
===================================================================
--- trunk/src/CacheWolf/DateFormat.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/DateFormat.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /* Several date formats are used by GC.COM
@@ -33,75 +33,129 @@
  *    2004-02-27    - YYYY-MM-DD   
  */
 
-import ewe.sys.Convert;
 import ewe.sys.Time;
+import ewe.util.mString;
 
 public class DateFormat {
 
 	/** Convert the US Format into a sortable format */
-	public static String MDY2YMD(String date) {
-		// Dates are in format M/D/Y
-		int p1, p2 = -1, p3;
-		p1 = date.indexOf(&quot;/&quot;);
-		if (p1==-1){
-			//dayofweek, dayofmonth month year (Monday, 07 June 2010)
-			p1 = date.indexOf(&quot;,&quot;);			
-			p2 = date.indexOf(&quot; &quot;, p1 + 2);
-			p3 = date.indexOf(&quot; &quot;, p2 + 1);
-			final String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;,
-					&quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;,
-					&quot;December&quot; };
-			for (int m = 0; m &lt; 12; m++) {
-				if (monthNames[m].equals(date.substring(p2+1,p3))) {
-					String mm = Integer.toString(m+1);
-					if (mm.length()==1) {mm=0+mm;}
-					return date.substring(p3+1,p3+5) + &quot;-&quot; + mm + &quot;-&quot; + date.substring(p1+2, p1+4);
+	public static String toYYMMDD(String date) {
+		return toYYMMDD(toDate(date));
+	}
+
+	public static Time toDate(String ds) {
+		if (ds == null || ds.equals(&quot;&quot;) || ds.indexOf(&quot;1900&quot;) &gt; -1)
+			return new Time(1, 1, 1900);
+		final long adaylong = new Time(2, 1, 2000).getTime() - new Time(1, 1, 2000).getTime();
+		Time d = new Time();
+		d.hour = 0;
+		d.minute = 0;
+		d.second = 0;
+		d.millis = 0;
+		if (ds.indexOf(&quot;day&quot;) &gt; 0) {
+			if (ds.indexOf(&quot;Yesterday&quot;) &gt; -1) {
+				d.setTime(d.getTime() - adaylong);
+			} else {
+				d.setTime(d.getTime() - adaylong * Common.parseInt(ds.substring(0, 1)));
+			}
+		} else {
+			String[] SDate;
+			ds = STRreplace.replace(ds, &quot;,&quot;, &quot; &quot;);
+			ds = STRreplace.replace(ds, &quot;  &quot;, &quot; &quot;);
+			SDate = mString.split(ds, ' ');
+			if (SDate.length == 1) {
+				if (ds.indexOf('/') &gt; -1)
+					SDate = mString.split(ds, '/');
+				else if (ds.indexOf('-') &gt; -1)
+					SDate = mString.split(ds, '-');
+				// trying to determine Dateformat
+				int v0 = Common.parseInt(SDate[0]);
+				int v1 = Common.parseInt(SDate[1]);
+				int v2 = Common.parseInt(SDate[2]);
+				int dd, mm, yy;
+				if (v0 &gt; 31) {
+					// yyyy mm dd
+					yy = v0;
+					mm = v1;
+					dd = v2;
+				} else {
+					yy = v2;
+					if ((v0 == 0) || (v1 == 0)) {
+						// month as text
+						String month;
+						if (v0 == 0) {
+							month = SDate[0];
+							dd = v1;
+						} else {
+							month = SDate[1];
+							dd = v0;
+						}
+						mm = monthName2int(month);
+					} else {
+						// mm dd yyyy
+						mm = v0;
+						dd = v1;
+					}
+
 				}
+				d.month = mm;
+				d.day = dd;
+				d.year = yy;
+			} else {
+				// starting with dayOfWeek or missing year
+				int offs = SDate.length - 3;
+				if (offs &lt; 0)
+					offs = 0;
+				int v0 = Common.parseInt(SDate[offs]);
+				if (v0 == 0) {
+					d.day = Common.parseInt(SDate[offs + 1]);
+					d.month = monthName2int(SDate[offs]);
+				} else {
+					d.day = Common.parseInt(SDate[offs]);
+					d.month = monthName2int(SDate[offs + 1]);
+				}
+				if (SDate.length &gt; 2) {
+					int yy = Common.parseInt(SDate[offs + 2]);
+					if (yy &lt; 100)
+						d.year = 2000 + yy;
+					else
+						d.year = yy;
+				} else
+					// missing year
+					; // d.year = this year
 			}
-			return date;
 		}
-		else {
-			if (p1 &gt; 0)
-				p2 = date.indexOf(&quot;/&quot;, p1 + 1);
-			if (p1 &gt; 0 &amp;&amp; p2 &gt; 0) {
-				return date.substring(p2 + 1) + &quot;-&quot; + (p1 == 1 ? &quot;0&quot; : &quot;&quot;)
-						+ date.substring(0, p1) + &quot;-&quot; + (p1 + 2 == p2 ? &quot;0&quot; : &quot;&quot;)
-						+ date.substring(p1 + 1, p2);
-			} else
-				return date;
-		}
+		return d;
 	}
 
-	/* Convert the sortable date into a US date */
-	// static String YMD2MDY(String date) {
-	// return
-	// date.substring(4,6)+&quot;/&quot;+date.substring(6,8)+&quot;/&quot;+date.substring(0,4);
-	// }
-	/** Convert the log format into a sortable format */
-	public static String logdate2YMD(String logdate) {
-		String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;,
-				&quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;,
-				&quot;December&quot; };
-		Time t = new Time();
-		String year, month, day;
-		int i, m;
-		logdate += &quot;, &quot; + t.year; // If logdate already has a year, this one is
-									// ignored
-		i = logdate.indexOf(',');
-		year = logdate.substring(i + 2, i + 6);
-		for (m = 0; m &lt; 12; m++) {
-			if (logdate.startsWith(monthNames[m])) {
-				month = (m &lt; 9 ? &quot;0&quot; : &quot;&quot;) + Convert.formatInt(m + 1);
-				day = logdate.substring(monthNames[m].length() + 1, i);
-				if (day.length() == 1)
-					day = &quot;0&quot; + day;
-				return year + &quot;-&quot; + month + &quot;-&quot; + day;
+	private static int monthName2int(String month) {
+		final String enMonthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };
+		for (int m = 0; m &lt; 12; m++) {
+			if (enMonthNames[m].startsWith(month)) {
+				return m + 1;
 			}
 		}
-		return &quot;&quot;;
+		final String deMonthNames[] = { &quot;Januar&quot;, &quot;Februar&quot;, &quot;M&#228;rz&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot; };
+		for (int m = 0; m &lt; 12; m++) {
+			if (deMonthNames[m].startsWith(month)) {
+				return m + 1;
+			}
+		}
+		return 1; // Januar if not detected / in other language
 	}
+
+	public static String toYYMMDD(Time d) {
+		return toYYMMDD(d, '-');
+	}
+
+	public static String toYYMMDD(Time d, char separator) {
+		// the CW Time Format is with separator
+		String f = &quot;yyyy&quot; + separator + &quot;MM&quot; + separator + &quot;dd&quot;;
+		return d.format(f);
+	}
+
 	// from lastSyncDate (yyyyMMddHHmmss) to gpxLogdate (yyyy-MM-dd)
-	// if no lastSyncDate returns current Date 
+	// if no lastSyncDate returns current Date
 	public static String yyyyMMddHHmmss2gpxLogdate(String yyyyMMddHHmmss) {
 		Time d = new Time();
 		try {
@@ -109,7 +163,7 @@
 		} catch (IllegalArgumentException e) {
 			d = new Time();
 			d.parse(yyyyMMddHHmmss, &quot;yyyyMMddHHmmss&quot;);
-		}		
+		}
 		return d.format(&quot;yyyy-MM-dd&quot;); // +d.format(&quot;HH:mm:ss&quot;); is set to 00:00:00 at gpxExport
 	}
 

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1330,6 +1330,7 @@
 			pref.log(&quot;already English&quot;);
 			return true;
 		}
+
 		// todo next doesn't work correct don't know why
 		// switch to english now goes into gc account Display Preferences (is permanent, must be reset)
 		final Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
@@ -1605,7 +1606,7 @@
 			lonmax = (int) br.lonDec;
 			latmin = (int) tl.latDec;
 			latmax = (int) br.latDec;
-		} while ((lonmax - lonmin &gt; 1) &amp;&amp; (latmax - latmin &gt; 1) &amp;&amp; (scale &gt; 16));
+		} while ((lonmax - lonmin &gt; 1) &amp;&amp; (latmax - latmin &gt; 1) &amp;&amp; (scale &gt; 10));
 
 		String cachelist;
 
@@ -1706,16 +1707,22 @@
 
 		final int WpIndex = page.indexOf(&quot;\&quot;gc\&quot;:&quot;);
 		final String[] elements = mString.split(page.substring(WpIndex), '\&quot;');
-
+		if (elements.length != 63) {
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), &quot;GC changed format of new Map Infos&quot;, FormBase.OKB)).execute();
+			return;
+		}
 		final int posWP = 3; // gc
-		final int posDisabled = 6; // disabled
-		final int posDiff = 10; // difficulty
-		final int posTerr = 18; // terrain
-		final int posHidden = 25; // hidden date
-		final int posSize = 31; // size
-		final int posType = 44; // type
-		final int posOwner = 49; // owner
-		final int posGUID = 53; // guid
+		// final int posWPGuid = 7; // g
+		final int posDisabled = 10; // disabled
+		final int posPM = 12; // PM - Cache
+		// final int posLI = 14; // who knows
+		final int posDiff = 18; // difficulty
+		final int posTerr = 26; // terrain
+		final int posHidden = 33; // hidden date
+		final int posSize = 39; // size oder 43
+		final int posType = 52; // type 49 , 52
+		final int posOwner = 57; // owner
+		// final int posOwnerGUID = 61; // guid
 
 		// final boolean found = (elements[posFound].indexOf(&quot;true&quot;) &gt; -1 ? true
 		// : false);
@@ -1726,13 +1733,16 @@
 			if (restrictedCacheType != cacheType)
 				return;
 		}
-
+		boolean pm = elements[posPM].indexOf(&quot;false&quot;) &gt; -1 ? false : true;
+		// boolean li = elements[posLI].indexOf(&quot;true&quot;) &gt; -1 ? false : true;
 		String wp = elements[posWP];
 		CacheHolder ch = cacheDB.get(wp);
 		if (ch == null) {
 
 			ch = new CacheHolder();
 			ch.setWayPoint(wp);
+			if (pm &amp;&amp; !pref.isPremium)
+				ch.setCacheStatus(&quot;PM&quot;);
 			ch.pos = p;
 			final String owner = elements[posOwner];
 			ch.setCacheOwner(owner);
@@ -1751,7 +1761,7 @@
 			cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
 			ch.setCacheName(cacheName);
 			ch.setAvailable((elements[posDisabled].indexOf(&quot;true&quot;) &gt; -1 ? false : true));
-			ch.setDateHidden(DateFormat.MDY2YMD(elements[posHidden]));
+			ch.setDateHidden(DateFormat.toYYMMDD(elements[posHidden]));
 			ch.setHard(CacheTerrDiff.v1Converter(elements[posDiff].substring(1, elements[posDiff].length() - 1)));
 			ch.setTerrain(CacheTerrDiff.v1Converter(elements[posTerr].substring(1, elements[posTerr].length() - 1)));
 			ch.setCacheSize(CacheSize.gcGpxString2Cw(elements[posSize]));
@@ -2224,12 +2234,6 @@
 			return true; // or check cacheDescGC also no log?
 		lastLogCW.parse(slastLogCW, &quot;yyyy-MM-dd&quot;);
 
-		final Time lastLogGC = new Time(); // is current time
-		lastLogGC.hour = 0;
-		lastLogGC.minute = 0;
-		lastLogGC.second = 0;
-		lastLogGC.millis = 0;
-		String[] SDate;
 		String stmp = &quot;&quot;;
 		RexPropLogDate.search(cacheDescription);
 		if (RexPropLogDate.didMatch()) {
@@ -2238,67 +2242,8 @@
 			pref.log(&quot;check logDateRex in spider.def&quot; + Preferences.NEWLINE + cacheDescription);
 			return false;
 		}
-		if (stmp.indexOf(&quot;day&quot;) &gt; 0) {
-			// simplyfied (update if not newer than last week)
-			lastLogGC.setTime(lastLogGC.getTime() - 691200000L);
-		} else if (stmp.equals(&quot;&quot;)) {
-			return false; // no log yet
-		} else {
-			final String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };
-			SDate = mString.split(stmp, ' ');
-			if (SDate.length == 1) {
-				SDate = mString.split(stmp, '/');
-				// trying to determine Dateformat
-				int v0 = Common.parseInt(SDate[0]);
-				int v1 = Common.parseInt(SDate[1]);
-				int v2 = Common.parseInt(SDate[2]);
-				int dd, mm, yy;
-				if (v0 &gt; 31) {
-					// yyyy mm dd
-					yy = v0;
-					mm = v1;
-					dd = v2;
-				} else {
-					yy = v2;
-					if ((v0 == 0) || (v1 == 0)) {
-						// month as text
-						String month;
-						if (v0 == 0) {
-							month = SDate[0];
-							dd = v1;
-						} else {
-							month = SDate[1];
-							dd = v0;
-						}
-						mm = 12;
-						for (int m = 0; m &lt; 12; m++) {
-							if (monthNames[m].startsWith(month)) {
-								mm = m + 1;
-								m = 12;
-							}
-						}
-					} else {
-						// mm dd yyyy
-						mm = v0;
-						dd = v1;
-					}
-
-				}
-				lastLogGC.month = mm;
-				lastLogGC.day = dd;
-				lastLogGC.year = yy;
-			} else {
-				// Format till may 2011
-				lastLogGC.day = Common.parseInt(SDate[0]);
-				for (int m = 0; m &lt; 12; m++) {
-					if (monthNames[m].startsWith(SDate[1])) {
-						lastLogGC.month = m + 1;
-						m = 12;
-					}
-				}
-				lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
-			}
-		}
+		final Time lastLogGC = DateFormat.toDate(stmp);
+		// String timecheck = DateFormat.toYYMMDD(lastLogGC);
 		final boolean ret = lastLogCW.compareTo(lastLogGC) &lt; 0;
 		return ret;
 	}
@@ -2442,7 +2387,7 @@
 							ch.setOwned(true);
 						pref.log(&quot;Owner: &quot; + ch.getCacheOwner() + &quot;; is_owned = &quot; + ch.is_owned() + &quot;;  alias1,2 = [&quot; + pref.myAlias + &quot;|&quot; + pref.myAlias2 + &quot;]&quot;);
 
-						ch.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
+						ch.setDateHidden(DateFormat.toYYMMDD(getDateHidden(completeWebPage)));
 						pref.log(&quot;Hidden: &quot; + ch.getDateHidden());
 
 						ch.getCacheDetails(false).setHints(getHints(completeWebPage));
@@ -2749,8 +2694,10 @@
 			pref.log(&quot;check blockRex in spider.def&quot; + Preferences.NEWLINE + completeWebPage);
 		}
 		final String LogBlock = RexLogBlock.stringMatched(1);
+
 		exSingleLog.setSource(LogBlock);
 		singleLog = exSingleLog.findNext();
+
 		exIcon.setSource(singleLog);
 		exNameTemp.setSource(singleLog);
 		exName.setSource(exNameTemp.findNext());
@@ -2763,17 +2710,14 @@
 			// pref.log(singleLog);
 			nLogs++;
 			icon = exIcon.findNext();
-			icon = icon.substring(0, icon.length() - 1); // ' changes to &quot; in
-															// UMTS-connection!
-															// first char in
-															// iconExEnd.
+			// ' changes to &quot; in UMTS-connection! first char in iconExEnd.
+			icon = icon.substring(0, icon.length() - 1);
 			name = exName.findNext();
 			logText = exLog.findNext();
 			logText = correctSmilies(logText);
 			logId = exLogId.findNext();
 			final String ed = exDate.findNext();
-			final String d = DateFormat.logdate2YMD(ed);
-			// pref.log(&quot;Lognr:&quot;+nLogs+&quot;|&quot;+icon+&quot;|&quot;+name+&quot;-|-&quot;+SafeXML.clean(pref.myAlias)+&quot;|&quot;+logId,null);
+			final String d = DateFormat.toYYMMDD(ed);
 			// if this log says this Cache is found by me
 			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) &amp;&amp; (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002987.html">[Cachewolf-svn] r2996 - in trunk: res_noewe src/CacheWolf	src/CacheWolf/imp
</A></li>
	<LI>Next message: <A HREF="002989.html">[Cachewolf-svn] r2998 - in trunk/src/CacheWolf: . imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2988">[ date ]</a>
              <a href="thread.html#2988">[ thread ]</a>
              <a href="subject.html#2988">[ subject ]</a>
              <a href="author.html#2988">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
