<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3027 - in trunk/src/CacheWolf: . imp navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-June/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3027%20-%20in%20trunk/src/CacheWolf%3A%20.%20imp%20navi&In-Reply-To=%3C20110615205302.20F3E481259%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003017.html">
   <LINK REL="Next"  HREF="003019.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3027 - in trunk/src/CacheWolf: . imp navi</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3027%20-%20in%20trunk/src/CacheWolf%3A%20.%20imp%20navi&In-Reply-To=%3C20110615205302.20F3E481259%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3027 - in trunk/src/CacheWolf: . imp navi">araber95 at mail.berlios.de
       </A><BR>
    <I>Wed Jun 15 10:53:02 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003017.html">[Cachewolf-svn] r3026 - trunk/res_noewe/webmapservices
</A></li>
        <LI>Next message: <A HREF="003019.html">[Cachewolf-svn] r3028 - in trunk/src/CacheWolf: . exp imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3018">[ date ]</a>
              <a href="thread.html#3018">[ thread ]</a>
              <a href="subject.html#3018">[ subject ]</a>
              <a href="author.html#3018">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-06-15 22:53:01 +0200 (Wed, 15 Jun 2011)
New Revision: 3027

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
direct map access

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-06-13 17:58:00 UTC (rev 3026)
+++ trunk/src/CacheWolf/MainTab.java	2011-06-15 20:53:01 UTC (rev 3027)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.GotoPanel;
@@ -41,90 +41,131 @@
 import ewe.ui.mTabbedPanel;
 
 /**
- *	This class creates the tabbed panel and sets the tabs to the respective
- *	other panels. Important is to have a look at the event handler!&lt;br&gt;
- *	Class ID = 1200
- *	@see MainForm
- *	@see MainMenu
+ * This class creates the tabbed panel and sets the tabs to the respective other panels. Important is to have a look at
+ * the event handler!&lt;br&gt;
+ * Class ID = 1200
+ * 
+ * @see MainForm
+ * @see MainMenu
  */
 public class MainTab extends mTabbedPanel {
-	DescriptionPanel descP= new DescriptionPanel();
+	static int LIST_CARD;
+	static int DETAILS_CARD;
+	static int DESCRIPTION_CARD;
+	static int IMAGES_CARD;
+	static int HINTSANSLOGS_CARD;
+	static int SOLVER_CARD;
+	static int CALC_CARD;
+	static int GOTO_CARD;
+	static int RADAR_CARD;
+	static int MAP_CARD;
+
+	TableForm listP;
+	public DetailsPanel detP = new DetailsPanel();
+	DescriptionPanel descP = new DescriptionPanel();
 	HintLogPanel hintLP = new HintLogPanel();
 	public TablePanel tbP;
-	CacheDB cacheDB;
-	public DetailsPanel detP = new DetailsPanel();
 	CalcPanel calcP;
-	Preferences pref;
-	Profile profile;
 	GotoPanel gotoP;
 	RadarPanel radarP = new RadarPanel();
 	ImagePanel imageP;
 	SolverPanel solverP;
+	ewe.ui.CellPanel mapP;
+
+	Preferences pref;
+	Profile profile;
+
+	CacheDB cacheDB;
 	String lastselected = &quot;&quot;;
-	public CacheHolder ch=null, chMain=null;
-	CacheHolderDetail chD =null;
+	public CacheHolder ch = null, chMain = null;
+	CacheHolderDetail chD = null;
 	MainMenu mnuMain;
+
 	public StatusBar statBar;
 	public MovingMap mm;
 	public Navigate nav;
-	public String mainCache=&quot;&quot;;
-	int oldCard=0;
-	boolean cacheDirty=false;
+	public String mainCache = &quot;&quot;;
+	int oldCard;
+	boolean cacheDirty = false;
 
-	public MainTab(MainMenu mainMenu,StatusBar statBar){
-		Global.mainTab=this;
-		mnuMain=mainMenu;
+	public MainTab(MainMenu mainMenu, StatusBar statBar) {
+		// Init here so that Global.MainT is already set
+		Global.mainTab = this;
+		mnuMain = mainMenu;
 		pref = Global.getPref();
-		profile=Global.getProfile();
-		if (!pref.tabsAtTop) tabLocation=SOUTH;
+		profile = Global.getProfile();
+		if (!pref.tabsAtTop)
+			tabLocation = SOUTH;
 		cacheDB = profile.cacheDB;
-		this.statBar=statBar;
+		this.statBar = statBar;
 		MyLocale.setSIPButton();
-		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
+		// Don't expand tabs if the screen is very narrow, i.e. HP IPAQ
+		// 65xx, 69xx
 		int sw = MyLocale.getScreenWidth();
-		if ( sw &lt;= 240) this.dontExpandTabs=true;
-		String imagesize=&quot;&quot;;
-		if (pref.useBigIcons) imagesize=&quot;_vga&quot;;
-		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
+		if (sw &lt;= 240)
+			this.dontExpandTabs = true;
+		String imagesize = &quot;&quot;;
+		if (pref.useBigIcons)
+			imagesize = &quot;_vga&quot;;
+
 		tbP = new TablePanel(pref, profile, statBar);
-		Card c = this.addCard(new TableForm(tbP), MyLocale.getMsg(1200,&quot;List&quot;), null);
+		Card c = this.addCard(listP = new TableForm(tbP), MyLocale.getMsg(1200, &quot;List&quot;), null);
+		LIST_CARD = this.cardPanel.cards.size() - 1;
+		oldCard = LIST_CARD;
 
-		c = this.addCard(detP, MyLocale.getMsg(1201,&quot;Details&quot;), null);
-		c.iconize(new Image(&quot;details&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(detP, MyLocale.getMsg(1201, &quot;Details&quot;), null);
+		DETAILS_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;details&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(descP, MyLocale.getMsg(1202,&quot;Description&quot;), null);
-		c.iconize(new Image(&quot;descr&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(descP, MyLocale.getMsg(1202, &quot;Description&quot;), null);
+		DESCRIPTION_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;descr&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203,&quot;Images&quot;), null);
-		c.iconize(new Image(&quot;images&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203, &quot;Images&quot;), null);
+		IMAGES_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;images&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(hintLP, MyLocale.getMsg(1204,&quot;Hints &amp; Logs&quot;), null);
-		c.iconize(new Image(&quot;more&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(hintLP, MyLocale.getMsg(1204, &quot;Hints &amp; Logs&quot;), null);
+		HINTSANSLOGS_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;more&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205,&quot;Solver&quot;), null);
-		c.iconize(new Image(&quot;solver&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205, &quot;Solver&quot;), null);
+		SOLVER_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;solver&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(calcP, MyLocale.getMsg(1206,&quot;Calc&quot;), null);
-		mImage imgCalc=new mImage(&quot;projecttab&quot;+imagesize+&quot;.gif&quot;); imgCalc.transparentColor=new Color(0,255,0);
-		c.iconize(imgCalc,true);
+		c = this.addCard(calcP = new CalcPanel(), MyLocale.getMsg(1206, &quot;Calc&quot;), null);
+		CALC_CARD = this.cardPanel.cards.size() - 1;
+		mImage imgCalc = new mImage(&quot;projecttab&quot; + imagesize + &quot;.gif&quot;);
+		imgCalc.transparentColor = new Color(0, 255, 0);
+		c.iconize(imgCalc, true);
 
 		nav = new Navigate();
-		c = this.addCard(gotoP = new GotoPanel(nav), &quot;Goto&quot;, null);
-		c.iconize(new Image(&quot;goto&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(gotoP = new GotoPanel(nav), MyLocale.getMsg(345, &quot;Goto these coordinates&quot;), null);
+		GOTO_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;goto&quot; + imagesize + &quot;.gif&quot;), true);
 		nav.setGotoPanel(gotoP);
 
-		c = this.addCard(radarP, &quot;Radar&quot;, null);
-		radarP.setMainTab(this);
-		c.iconize(new Image(&quot;radar&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(mapP = new ewe.ui.CellPanel(), MyLocale.getMsg(347, &quot;Show map&quot;), null);
+		MAP_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;globe_small&quot; + imagesize + &quot;.gif&quot;), true);
+
+		if (pref.useBigIcons) {
+			c = this.addCard(radarP, &quot;Radar&quot;, null);
+			RADAR_CARD = this.cardPanel.cards.size() - 1;
+			radarP.setMainTab(this);
+			c.iconize(new Image(&quot;radar&quot; + imagesize + &quot;.gif&quot;), true);
+		}
+
 		mnuMain.allowProfileChange(true);
-//		if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
+		// if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
 	}
 
-	public TablePanel getTablePanel(){
+	public TablePanel getTablePanel() {
 		return tbP;
 	}
 
-	public void selectAndActive(int rownum){// Called from myInteractivePanel.imageClicked
+	public void selectAndActive(int rownum) {// Called from
+		// myInteractivePanel.imageClicked
 		tbP.selectRow(rownum);
 		this.selectAndExpand(0);
 	}
@@ -138,79 +179,86 @@
 	}
 
 	public void onEvent(Event ev) {
-		// This section clears old data when a new line is selected in the table
+		// This section clears old data when a new line is selected in the
+		// table
 		if (ev instanceof TableEvent) {
 			clearDetails();
 		}
-		if(ev instanceof MultiPanelEvent){
-			// Check whether a profile change is allowed, if not disable the relevant options
+		if (ev instanceof MultiPanelEvent) {
+			// Check whether a profile change is allowed, if not disable the
+			// relevant options
 			checkProfileChange();
 			// Perform clean up actions for the panel we are leaving
 			onLeavingPanel(oldCard);
 			// Prepare actions for the panel we are about to enter
-			onEnteringPanel(((MultiPanelEvent)ev).selectedIndex);
-			oldCard=((MultiPanelEvent)ev).selectedIndex;
+			onEnteringPanel(((MultiPanelEvent) ev).selectedIndex);
 		}
-		super.onEvent(ev); //Make sure you call this.
-		// If we are in Listview update status
-//		if (this.getSelectedItem()==0 &amp;&amp; statBar!=null) statBar.updateDisplay();
+		super.onEvent(ev); // Make sure you call this.
 	}
 
 	/**
 	 * Code to execute when leaving a panel (oldCard is the panel number)
-	 *
+	 * 
 	 */
 	private void onLeavingPanel(int panelNo) {
-		if (panelNo==0) { // Leaving the list view
+		if (panelNo == MainTab.LIST_CARD) { // Leaving the list view
 			// Get the cache for the current line (ch)
 			// Get the details for the current line (chD)
 			// If it is Addi get details of main Wpt (chMain)
-			chMain=null;
-			cacheDirty=false;
-			if (tbP.getSelectedCache()&gt;=Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache()&lt;0) {
-				ch=null;
-				chD=null;
-				lastselected=&quot;&quot;;
+			chMain = null;
+			cacheDirty = false;
+			if (tbP.getSelectedCache() &gt;= Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache() &lt; 0) {
+				ch = null;
+				chD = null;
+				lastselected = &quot;&quot;;
 			} else {
 				ch = cacheDB.get(tbP.getSelectedCache());
-				lastselected=ch.getWayPoint();  // Used in Parser.Skeleton
+				lastselected = ch.getWayPoint(); // Used in
+				// Parser.Skeleton
 				chD = ch.getCacheDetails(true);
 			}
 		}
-		if (panelNo==1) { // Leaving the Details Panel
-			detP.evWaypointChanged=false;
+		if (panelNo == MainTab.DETAILS_CARD) { // Leaving the Details Panel
+			detP.evWaypointChanged = false;
 			// Update chD with Details
-			if(detP.isDirty()) {
-				cacheDirty=true;
+			if (detP.isDirty()) {
+				cacheDirty = true;
 				boolean needTableUpdate = detP.getNeedsTableUpdate();
 				detP.saveDirtyWaypoint();
 				if (needTableUpdate) {
-					tbP.myMod.updateRows();// This sorts the waypoint (if it is new) into the right position
+					tbP.myMod.updateRows();// This sorts the waypoint (if
+					// it is new) into the right
+					// position
 					tbP.selectRow(profile.getCacheIndex(detP.cache.getWayPoint()));
 				}
-				//was tbP.refreshTable();
+				// was tbP.refreshTable();
 				tbP.tc.update(true); // Update and repaint
-				if (statBar!=null) statBar.updateDisplay(&quot;&quot;);
+				if (statBar != null)
+					statBar.updateDisplay(&quot;&quot;);
 			}
 		}
-		if (panelNo==5) { // Leaving the Solver Panel
+		if (panelNo == MainTab.SOLVER_CARD) { // Leaving the Solver Panel
 			// Update chD or chMain with Solver
-			// If chMain is set (i.e. if it is an addi Wpt) save it immediately
-			if (chD!=null &amp;&amp; solverP.isDirty()) {
-				if (chMain==null) {
-					cacheDirty=true;
+			// If chMain is set (i.e. if it is an addi Wpt) save it
+			// immediately
+			if (chD != null &amp;&amp; solverP.isDirty()) {
+				if (chMain == null) {
+					cacheDirty = true;
 					boolean oldHasSolver = chD.getParent().hasSolver();
 					chD.setSolver(solverP.getInstructions());
-					if (oldHasSolver != chD.getParent().hasSolver()) tbP.tc.update(true);
-					// For safety reasons: Immediately save solver instructions when
+					if (oldHasSolver != chD.getParent().hasSolver())
+						tbP.tc.update(true);
+					// For safety reasons: Immediately save solver
+					// instructions when
 					// switching panels
 					updatePendingChanges();
 				} else {
 					boolean oldHasSolver = chMain.hasSolver();
 					chMain.getCacheDetails(true).setSolver(solverP.getInstructions());
-					if (oldHasSolver != chMain.hasSolver()) tbP.tc.update(true);
+					if (oldHasSolver != chMain.hasSolver())
+						tbP.tc.update(true);
 					chMain.save();
-					chMain=null;
+					chMain = null;
 				}
 			}
 		}
@@ -218,120 +266,122 @@
 
 	/**
 	 * Code to execute when entering a panel (getSelectedItem() is the panel number)
-	 *
+	 * 
 	 */
 	private void onEnteringPanel(int panelNo) {
-		switch (panelNo) {// Switch by panel number
-		case 0:  //MainPanel
-			MyLocale.setSIPOff();
+		MyLocale.setSIPOff();
+		if (panelNo == LIST_CARD) {
 			// If Solver or Details has changed, save Cache
 			updatePendingChanges();
 			if (detP.hasBlackStatusChanged()) {
 				tbP.refreshTable();
 			}
 			updateCurCentrePtFromGPS();
-			break;
-		case 1:  // DetailsPanel
+		} else if (panelNo == DETAILS_CARD) {
 			boolean newCache = false;
-			if (chD==null) { // Empty DB - show a dummy detail
-				newWaypoint(ch=new CacheHolder());
+			if (chD == null) { // Empty DB - show a dummy detail
+				newWaypoint(ch = new CacheHolder());
 				newCache = true;
 			}
-			MyLocale.setSIPOff();
 			detP.setDetails(ch, newCache);
-			break;
-		case 2: // Description Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == DESCRIPTION_CARD) {
 			descP.setText(ch);
-			break;
-		case 3: // Picture Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == IMAGES_CARD) {
 			if (ch.isAddiWpt()) {
 				imageP.setImages(ch.mainCache.getCacheDetails(true));
 			} else {
 				imageP.setImages(chD);
 			}
-			break;
-		case 4:  // Log Hint Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == HINTSANSLOGS_CARD) {
 			if (ch.isAddiWpt()) {
 				hintLP.setText(ch.mainCache.getCacheDetails(true));
 			} else {
 				hintLP.setText(chD);
 			}
-			break;
-		case 5:  // Solver Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == SOLVER_CARD) {
 			if (ch.isAddiWpt()) {
-				chMain=ch.mainCache;
+				chMain = ch.mainCache;
 				solverP.setInstructions(ch.mainCache);
 			} else {
 				solverP.setInstructions(ch);
 			}
-			break;
-		case 6:  // CalcPanel
-			MyLocale.setSIPOff();
-			if (ch != null) calcP.setFields(ch);
-			break;
-		case 7: // GotoPanel
-			MyLocale.setSIPOff();
-			break;
-		case 8:  // Cache Radar Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == CALC_CARD) {
+			if (ch != null)
+				calcP.setFields(ch);
+		} else if (panelNo == MAP_CARD) {
+			gotoP.switchToMovingMap();
+			if (oldCard == LIST_CARD) {
+				select(listP);
+			} else if (oldCard == DETAILS_CARD) {
+				select(detP);
+			} else if (oldCard == DESCRIPTION_CARD) {
+				select(descP);
+			} else if (oldCard == IMAGES_CARD) {
+				select(imageP);
+			} else if (oldCard == HINTSANSLOGS_CARD) {
+				select(hintLP);
+			} else if (oldCard == SOLVER_CARD) {
+				select(solverP);
+			} else if (oldCard == CALC_CARD) {
+				select(calcP);
+			} else if (oldCard == GOTO_CARD) {
+				select(gotoP);
+			} else if (oldCard == RADAR_CARD) {
+				select(radarP);
+			}
+		} else if (panelNo == RADAR_CARD) {
 			radarP.setParam(pref, cacheDB, ch);
 			radarP.drawThePanel();
 			updateCurCentrePtFromGPS();
-			break;
 		}
+		oldCard = panelNo;
 	}
+
 	/**
 	 * this is called from MovingMap Cache context menu
-	 * @param chi , the CacheHolder for the Cache to switch to
-	 * @param panelNo 1=DetailsPanel 2=Description Panel
+	 * 
+	 * @param chi ,
+	 *            the CacheHolder for the Cache to switch to
+	 * @param panelNo
+	 *            1=DetailsPanel 2=Description Panel
 	 */
 	public void openPanel(CacheHolder chi, int panelNo) {
-		MyLocale.setSIPOff();
-		// To change cache we need to be in panel 0
-		onLeavingPanel(oldCard); // is 7 or 1
-		onEnteringPanel(0); oldCard=0;
+		// To change cache we need to be in panel LIST_CARD
+		onLeavingPanel(oldCard);
+		onEnteringPanel(LIST_CARD);
 		int row = profile.getCacheIndex(chi.getWayPoint());
 		tbP.selectRow(row);
-	switch (panelNo) {// Switch by panel number
-		case 1:  // DetailsPanel
-			ch=chi; //possibly wrong (old) detail if map is called directly
-			onEnteringPanel(1);
-			oldCard=1;
+		if (panelNo == DETAILS_CARD) {
+			ch = chi; // possibly wrong (old) detail if map is called
+			// directly
+			onEnteringPanel(DETAILS_CARD);
 			select(detP);
-			break;
-		case 2: // Description Panel
+		} else if (panelNo == DESCRIPTION_CARD) {
+			onEnteringPanel(DESCRIPTION_CARD);
 			select(descP);
-			break;
-		}		
+		}
+
 	}
 
-
 	/**
-	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to
-	 * offer the user the possibility of entering an new waypoint
-	 * at a given position. pCh must already been preset with a valid
-	 * CacheHolder object
-	 *
+	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to offer the user the possibility of
+	 * entering an new waypoint at a given position. pCh must already been preset with a valid CacheHolder object
+	 * 
 	 * @param pCh
 	 */
-	public void newWaypoint(CacheHolder pCh){
-		//When creating a new waypoint, simulate a change to the list view
-		//if we are currently NOT in the list view
-		if (oldCard != 0)
-		{
+	public void newWaypoint(CacheHolder pCh) {
+		// When creating a new waypoint, simulate a change to the list view
+		// if we are currently NOT in the list view
+		if (oldCard != LIST_CARD) {
 			onLeavingPanel(oldCard);
 		}
 		updatePendingChanges(); // was: onEnteringPanel(0); oldCard=0;
 
-		mainCache=lastselected;
-		int selectedIndex = profile.getCacheIndex( lastselected );
+		mainCache = lastselected;
+		int selectedIndex = profile.getCacheIndex(lastselected);
 		if (selectedIndex &gt;= 0) {
-			CacheHolder selectedCache = profile.cacheDB.get( selectedIndex );
-			if ( selectedCache.isAddiWpt() ) {
+			CacheHolder selectedCache = profile.cacheDB.get(selectedIndex);
+			if (selectedCache.isAddiWpt()) {
 				if (selectedCache.mainCache != null) {
 					mainCache = selectedCache.mainCache.getWayPoint();
 				} else {
@@ -339,12 +389,12 @@
 				}
 			}
 		}
-		if (CacheType.isAddiWpt(pCh.getType()) &amp;&amp; mainCache!=null &amp;&amp; mainCache.length()&gt;2) {
+		if (CacheType.isAddiWpt(pCh.getType()) &amp;&amp; mainCache != null &amp;&amp; mainCache.length() &gt; 2) {
 			pCh.setWayPoint(profile.getNewAddiWayPointName(mainCache));
 			profile.setAddiRef(pCh);
 		} else {
 			pCh.setWayPoint(profile.getNewWayPointName());
-			lastselected=pCh.getWayPoint();
+			lastselected = pCh.getWayPoint();
 		}
 		pCh.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 		chD = pCh.getCacheDetails(false);
@@ -353,18 +403,20 @@
 		Global.getProfile().notifyUnsavedChanges(true); // Just to be sure
 		tbP.myMod.numRows++;
 		detP.setDetails(pCh, true);
-		oldCard=1;
-		if (this.cardPanel.selectedItem != 1) select(detP);
+		oldCard = DETAILS_CARD;
+		if (this.cardPanel.selectedItem != 1)
+			select(detP);
 		solverP.setInstructions(pCh);
-		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
+		// tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
 	}
 
-
 	/**
 	 * sets posCircle Lat/Lon to centerTo
-	 *
-	 * @param centerTo true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the loaded map
+	 * 
+	 * @param centerTo
+	 *            true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the
+	 *            loaded map
 	 * @param forceCenter
 	 */
 	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
@@ -377,19 +429,29 @@
 				mm = new MovingMap(nav, profile.cacheDB);
 				nav.setMovingMap(mm);
 			}
-			
+
 			mm.myExec(centerTo, forceCenter);
-			
+
 			if (forceCenter) {
 				try {
 					int i = 0;
-					while (MapImage.screenDim.width == 0 &amp;&amp; i &lt; 10*60) { i++; ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
-					if (i &gt;= 10*60) {(new MessageBox(&quot;Error&quot;, &quot;MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de&quot;, FormBase.OKB)).execute(); return;}
-					//If white Areas are filled there is a problem with painting the image. We force painting here.
-					mm.repaint ();
-				}catch (InterruptedException e) {
+					while (MapImage.screenDim.width == 0 &amp;&amp; i &lt; 10 * 60) {
+						i++;
+						ewe.sys.mThread.sleep(100);
+					} // wait until the window size of the moving map is
+					// known note: ewe.sys.sleep() will pause the whole
+					// vm - no other thread will run
+					if (i &gt;= 10 * 60) {
+						(new MessageBox(&quot;Error&quot;, &quot;MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de&quot;, FormBase.OKB)).execute();
+						return;
+					}
+					// If white Areas are filled there is a problem with
+					// painting the image. We force painting here.
+					mm.repaint();
+				} catch (InterruptedException e) {
 					Global.getPref().log(&quot;Error starting mavoing map (1): &quot;, e, true);
-					(new MessageBox(&quot;Error&quot;, &quot;This must not happen please report to pfeffer how to produce this error message&quot;, FormBase.OKB)).execute(); }
+					(new MessageBox(&quot;Error&quot;, &quot;This must not happen please report to pfeffer how to produce this error message&quot;, FormBase.OKB)).execute();
+				}
 			}
 		} catch (Exception e) { // TODO swith waiting indication clock off
 			Global.getPref().log(&quot;Error starting moving map (2): &quot;, e, true);
@@ -405,39 +467,41 @@
 		}
 	}
 
-	/** Save the index file
-	 *
-	 * @param askForConfirmation is ignored, old: If true, the save can be cancelled by user
+	/**
+	 * Save the index file
+	 * 
+	 * @param askForConfirmation
+	 *            is ignored, old: If true, the save can be cancelled by user
 	 */
 	public void saveUnsavedChanges(boolean askForConfirmation) {
-		if (oldCard!=0) {
+		if (oldCard != LIST_CARD) {
 			onLeavingPanel(oldCard);
-			onEnteringPanel(0);
-			oldCard=0;
+			onEnteringPanel(LIST_CARD);
+			oldCard = LIST_CARD;
 		}
 		updatePendingChanges();
-		if (profile.hasUnsavedChanges()) profile.saveIndex(Global.getPref(),true);
-	    this.tbP.saveColWidth(pref);
+		if (profile.hasUnsavedChanges())
+			profile.saveIndex(Global.getPref(), true);
+		this.tbP.saveColWidth(pref);
 		Global.getPref().savePreferences();
 	}
 
 	private void checkProfileChange() {
 		// A panel is selected. Could be the same panel twice
 		mnuMain.allowProfileChange(false);
-		if(this.getSelectedItem() == 0){// List view selected
+		if (this.getSelectedItem() == 0) {// List view selected
 			mnuMain.allowProfileChange(true);
 			MyLocale.setSIPOff();
 		}
 	}
 
-	private void  updateCurCentrePtFromGPS() {
-		if (pref.setCurrentCentreFromGPSPosition){
+	private void updateCurCentrePtFromGPS() {
+		if (pref.setCurrentCentreFromGPSPosition) {
 			if (nav.gpsRunning) {
 				CWPoint whereAmI = nav.gpsPos;
 				if (whereAmI.isValid()) {
 					CWPoint curCentr = pref.getCurCentrePt();
-					if (whereAmI.latDec != curCentr.latDec ||
-						whereAmI.lonDec != curCentr.lonDec ) {
+					if (whereAmI.latDec != curCentr.latDec || whereAmI.lonDec != curCentr.lonDec) {
 						pref.setCurCentrePt(whereAmI);
 					}
 				}
@@ -447,7 +511,3 @@
 }
 //
 
-
-
-
-

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-06-13 17:58:00 UTC (rev 3026)
+++ trunk/src/CacheWolf/Preferences.java	2011-06-15 20:53:01 UTC (rev 3027)
@@ -51,14 +51,16 @@
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
-import ewe.util.Map.MapEntry;
 import ewe.util.StringTokenizer;
 import ewe.util.Utils;
+import ewe.util.Map.MapEntry;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
 /**
- * A class to hold the preferences that were loaded upon start up of CacheWolf. This class is also capable of parsing the prefs.xml file as well as saving the current settings of preferences.
+ * A class to hold the preferences that were loaded upon start up of
+ * CacheWolf. This class is also capable of parsing the prefs.xml file as
+ * well as saving the current settings of preferences.
  */
 public class Preferences extends MinML {
 
@@ -68,7 +70,8 @@
 	public final int DEFAULT_GPSD_PORT = 2947;
 	public static final int GPSD_DISABLED = 0; // do not use gpsd
 	public static final int GPSD_FORMAT_OLD = 1; // use old protocol
-	public static final int GPSD_FORMAT_NEW = 2; // use new protocol (JSON)
+	public static final int GPSD_FORMAT_NEW = 2; // use new protocol
+													// (JSON)
 	public static final int YES = 0;
 	public static final int NO = 1;
 	public static final int ASK = 2;
@@ -103,7 +106,8 @@
 
 	/**
 	 * Call this method to set the path of the config file &lt;br&gt;
-	 * If you call it with null it defaults to [program-dir]/pref.xml if p is a directory &quot;pref.xml&quot; will automatically appended
+	 * If you call it with null it defaults to [program-dir]/pref.xml if p
+	 * is a directory &quot;pref.xml&quot; will automatically appended
 	 * 
 	 * @param p
 	 */
@@ -111,10 +115,21 @@
 		String p_;
 		if (p == null) {
 			/*
-			 * String test; test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt; log(&quot;Vm.getenv(APPDATA: &quot; + test); // this works also in win32.exe (ewe-vm on win xp) test =
-			 * Vm.getenv(&quot;HOME&quot;, &quot;/&quot;); // This should return on *nix system the home dir log(&quot;Vm.getenv(HOME: &quot; + test); test = System.getProperty(&quot;user.dir&quot;); // return in java-vm on win xp: &lt;working dir&gt; or maybe &lt;program dir&gt;
-			 * log(&quot;System.getProperty(user.dir: &quot; + test); // in win32.exe -&gt; null test = System.getProperty(&quot;user.home&quot;); // in MS-java-VM env variable $HOME is ignored and always &lt;windir&gt;\java returned, see
-			 * <A HREF="http://support.microsoft.com/kb/177181/en-us/">http://support.microsoft.com/kb/177181/en-us/</A> log(&quot;System.getProperty(user.home: &quot; + test); // in win32.exe -&gt; null // &quot;user.dir&quot; User's current working directory // &quot;user.home&quot; User home directory (taken from
+			 * String test; test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;); // returns in
+			 * java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application
+			 * data&gt; log(&quot;Vm.getenv(APPDATA: &quot; + test); // this works also
+			 * in win32.exe (ewe-vm on win xp) test = Vm.getenv(&quot;HOME&quot;,
+			 * &quot;/&quot;); // This should return on *nix system the home dir
+			 * log(&quot;Vm.getenv(HOME: &quot; + test); test =
+			 * System.getProperty(&quot;user.dir&quot;); // return in java-vm on win
+			 * xp: &lt;working dir&gt; or maybe &lt;program dir&gt;
+			 * log(&quot;System.getProperty(user.dir: &quot; + test); // in win32.exe -&gt;
+			 * null test = System.getProperty(&quot;user.home&quot;); // in MS-java-VM
+			 * env variable $HOME is ignored and always &lt;windir&gt;\java
+			 * returned, see <A HREF="http://support.microsoft.com/kb/177181/en-us/">http://support.microsoft.com/kb/177181/en-us/</A>
+			 * log(&quot;System.getProperty(user.home: &quot; + test); // in win32.exe -&gt;
+			 * null // &quot;user.dir&quot; User's current working directory //
+			 * &quot;user.home&quot; User home directory (taken from
 			 * <A HREF="http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html">http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html</A> )
 			 */
 			p_ = FileBase.makePath(FileBase.getProgramDirectory(), &quot;pref.xml&quot;);
@@ -124,7 +139,16 @@
 			else
 				p_ = p;
 		}
-		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is necessary in case that the root dir is the dir where the pref.xml is stored
+		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is
+																// necessary
+																// in case
+																// that the
+																// root dir
+																// is the
+																// dir where
+																// the
+																// pref.xml
+																// is stored
 		pathToConfigFile = pathToConfigFile.replace('\\', '/');
 		p = System.getProperty(&quot;os.name&quot;);
 		if (p == null || p.indexOf(&quot;indows&quot;) != -1) {
@@ -164,7 +188,10 @@
 	public String absoluteBaseDir = &quot;&quot;;
 	/** Name of last used profile */
 	public String lastProfile = &quot;&quot;;
-	/** If true, the last profile is reloaded automatically without a dialogue */
+	/**
+	 * If true, the last profile is reloaded automatically without a
+	 * dialogue
+	 */
 	public boolean autoReloadLastProfile = false;
 	/** If true current cetre will be set from gps position */
 	public boolean setCurrentCentreFromGPSPosition = true;
@@ -172,7 +199,10 @@
 	public String myAlias = &quot;&quot;;
 	/** Optional password */
 	public String password = &quot;&quot;;
-	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs) */
+	/**
+	 * This is an alternative alias used to identify found caches (i.e. if
+	 * using multiple IDs)
+	 */
 	public String myAlias2 = &quot;&quot;;
 	/** The path to the browser */
 	public String browser = &quot;&quot;;
@@ -201,7 +231,8 @@
 	/** The default font size */
 	public int fontSize;
 	public String fontName;
-	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
+	// These settings govern where the menu and the tabs are displayed and
+	// whether the statusbas is shown
 	/** True if the menu is to be displayed at the top of the screen */
 	public boolean menuAtTop = true;
 	/** True if the tabs are to be displayed at the top of the screen */
@@ -210,7 +241,9 @@
 	public boolean showStatus = true;
 	// public boolean noTabs=false;
 	/**
-	 * True if the application can be closed by clicking on the close button in the top line. This can be set to avoid accidental closing of the application
+	 * True if the application can be closed by clicking on the close button
+	 * in the top line. This can be set to avoid accidental closing of the
+	 * application
 	 */
 	public boolean hasCloseButton = true;
 	/** True if the SIP is always visible */
@@ -219,15 +252,24 @@
 	public String listColMap = &quot;0,1,2,3,4,5,6,7,8,9,10,11,12&quot;;
 	/** The widths for each column in list view */
 	public String listColWidth = &quot;15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30&quot;;
-	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
+	/**
+	 * The columns which are to be displayed in TravelbugsJourneyScreen. See
+	 * also TravelbugJourney
+	 */
 	public String travelbugColMap = &quot;1,4,5,6,8,9,10,7&quot;;
 	/** The column widths for the travelbug journeys. */
 	public String travelbugColWidth = &quot;212,136,62,90,50,56,90,38,50,50,94,50&quot;;
-	/** If this flag is true, only non-logged travelbug journeys will be shown */
+	/**
+	 * If this flag is true, only non-logged travelbug journeys will be
+	 * shown
+	 */
 	public boolean travelbugShowOnlyNonLogged = false;
 	/** If this is true, deleted images are shown with a ? in the imagepanel */
 	public boolean showDeletedImages = true;
-	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
+	/**
+	 * This setting determines how many logs are shown per page of hintlogs
+	 * (default 5)
+	 */
 	public int logsPerPage = DEFAULT_LOGS_PER_PAGE;
 	/** Initial height of hints field (set to 0 to hide them initially) */
 	public int initialHintHeight = DEFAULT_INITIAL_HINT_HEIGHT;
@@ -235,7 +277,10 @@
 	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
 	/** True if the Solver should ignore the case of variables */
 	public boolean solverIgnoreCase = true;
-	/** True if the solver expects arguments for trigonometric functions in degrees */
+	/**
+	 * True if the solver expects arguments for trigonometric functions in
+	 * degrees
+	 */
 	public boolean solverDegMode = true;
 	/** True if the description panel should show images */
 	public boolean descShowImg = true;
@@ -243,13 +288,17 @@
 	public String garminConn = &quot;com1&quot;;
 	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
 	public String garminGPSBabelOptions = &quot;&quot;;
-	/** Max. length for Garmin waypoint names (for etrex which can only accept 6 chars) */
+	/**
+	 * Max. length for Garmin waypoint names (for etrex which can only
+	 * accept 6 chars)
+	 */
 	public int garminMaxLen = 0;
 	/** OC true = alle neu Laden false = wenn &#196;nderungsdatum neuer */
 	public boolean downloadAllOC = false;
 	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
 	/**
-	 * The currently used centre point, can be different from the profile's centrepoint. This is used for spidering
+	 * The currently used centre point, can be different from the profile's
+	 * centrepoint. This is used for spidering
 	 */
 	private CWPoint curCentrePt = new CWPoint();
 	/** True if a login screen is displayed on each spider operation */
@@ -260,7 +309,10 @@
 	private String customMapsPath = null;
 	/** Number of CacheHolder details that are kept in memory */
 	public int maxDetails = 50;
-	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
+	/**
+	 * Number of details to delete when maxDetails have been stored in
+	 * cachesWithLoadedDetails
+	 */
 	public int deleteDetails = 5;
 	/** The locale code (DE, EN, ...) */
 	public String language = &quot;&quot;;
@@ -320,7 +372,7 @@
 	public boolean SortingGroupedByCache = true;
 	/** useOwnSymbols */
 	public boolean useOwnSymbols = true;
-	/** TRUE if we want automatic sorting **/
+	/** TRUE if we want automatic sorting * */
 	public boolean sortAutomatic = true;
 	//
 	public String oldLanguageCtl = &quot;&quot;;
@@ -328,10 +380,11 @@
 
 	// ////////////////////////////////////////////
 	/**
-	 * The debug switch (Can be used to activate dormant code) by adding the line:
+	 * The debug switch (Can be used to activate dormant code) by adding the
+	 * line:
 	 * 
 	 * &lt;pre&gt;
-	 * &lt;debug value=&quot;true&quot; /&gt;
+	 * &lt;debug value=&quot;true&quot; /&gt;
 	 * &lt;/pre&gt;
 	 * 
 	 * to the pref.xml file.
@@ -340,7 +393,10 @@
 	// ////////////////////////////////////////////
 
 	/**
-	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms. It can only be set in the Preference-File directly, not by user-interaction now. Add &lt;MobileGui value=&quot;true&quot;/&gt; to your pref.xml
+	 * This switches the behaviour of GUI-Element factories. If set to true,
+	 * it will construct alternative Forms. It can only be set in the
+	 * Preference-File directly, not by user-interaction now. Add &lt;MobileGui
+	 * value=&quot;true&quot;/&gt; to your pref.xml
 	 */
 	public boolean mobileGUI = false;
 
@@ -362,7 +418,9 @@
 	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
-	 * Method to open and parse the config file (pref.xml). Results are stored in the public variables of this class. If you want to specify a non default config file call setPathToConfigFile() first.
+	 * Method to open and parse the config file (pref.xml). Results are
+	 * stored in the public variables of this class. If you want to specify
+	 * a non default config file call setPathToConfigFile() first.
 	 */
 	public void readPrefFile() {
 		if (pathToConfigFile == null)
@@ -381,7 +439,7 @@
 			else
 				log(&quot;Error reading pref.xml: &quot;, e);
 		}
-		useBigIcons = Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400;
+		useBigIcons = MyLocale.getScreenWidth() &gt;= 400; // &amp;&amp; Vm.isMobile()
 		isBigScreen = (MyLocale.getScreenWidth() &gt;= 400) &amp;&amp; (MyLocale.getScreenHeight() &gt;= 600);
 	}
 
@@ -394,7 +452,11 @@
 		String pf = Vm.getPlatform();
 		String testlist[] = null;
 		if (pf.equals(&quot;Java&quot;) || pf.equals(&quot;Win32&quot;)) {
-			String progdir = Vm.getenv(&quot;ProgramFiles&quot;, null); // at least in java-Win XP this is set
+			String progdir = Vm.getenv(&quot;ProgramFiles&quot;, null); // at least
+																// in
+																// java-Win
+																// XP this
+																// is set
 			String homedir = Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
 			if (progdir != null) {
 				String test[] = { homedir + &quot;/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe&quot;, progdir + &quot;/Firefox/firefox.exe&quot;, progdir + &quot;/Opera/opera.exe&quot;, progdir + &quot;/Internet Explorer/iexplore.exe&quot; };
@@ -421,7 +483,8 @@
 
 	/** Helper variables for XML parser */
 	private StringBuffer collectElement = null;
-	private String lastName; // The string to the last XML that was processed
+	private String lastName; // The string to the last XML that was
+								// processed
 
 	private long getLongAttr(AttributeList atts, String name) {
 		String stmp = atts.getValue(name);
@@ -433,7 +496,8 @@
 	}
 
 	/**
-	 * Method that gets called when a new element has been identified in pref.xml
+	 * Method that gets called when a new element has been identified in
+	 * pref.xml
 	 */
 	public void startElement(String name, AttributeList atts) {
 		lastName = name;
@@ -683,12 +747,15 @@
 
 	public void characters(char ch[], int start, int length) {
 		if (collectElement != null) {
-			collectElement.append(ch, start, length); // Collect the name of the last profile
+			collectElement.append(ch, start, length); // Collect the name
+														// of the last
+														// profile
 		}
 	}
 
 	/**
-	 * Method that gets called when the end of an element has been identified in pref.xml
+	 * Method that gets called when the end of an element has been
+	 * identified in pref.xml
 	 */
 	public void endElement(String tag) {
 		if (tag.equals(&quot;lastprofile&quot;)) {
@@ -837,7 +904,10 @@
 				outp.print(this.getFilter(filterIDs[i]).toXML(filterIDs[i]));
 			}
 			if (debug)
-				outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the debug switch if it is set
+				outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the
+																// debug
+																// switch if
+																// it is set
 			// save last path of different exporters
 			Iterator itPath = exporterPaths.entries();
 			MapEntry entry;
@@ -858,7 +928,13 @@
 			outp.print(&quot;    &lt;SortingGroupedByCache on=\&quot;&quot; + SafeXML.strxmlencode(SortingGroupedByCache) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;Symbols useOwnSymbols=\&quot;&quot; + SafeXML.strxmlencode(useOwnSymbols) + &quot;\&quot;/&gt;\n&quot;);
 			if (mobileGUI)
-				outp.print(&quot;    &lt;MobileGui value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the vmgui switch if it is set
+				outp.print(&quot;    &lt;MobileGui value=\&quot;true\&quot; /&gt;\n&quot;); // Keep
+																	// the
+																	// vmgui
+																	// switch
+																	// if it
+																	// is
+																	// set
 			outp.print(&quot;&lt;/preferences&gt;&quot;);
 			outp.close();
 		} catch (Exception e) {
@@ -928,8 +1004,11 @@
 	}
 
 	/**
-	 * gets the path to the calibrated maps it first tries if there are manually imported maps in &lt;baseDir&gt;/maps/standard then it tries the legacy dir: &lt;program-dir&gt;/maps In case in both locations are no .wfl-files it returns &lt;baseDir&gt;/maps/expedia - the
-	 * place where the automatically downloaded maps are placed.
+	 * gets the path to the calibrated maps it first tries if there are
+	 * manually imported maps in &lt;baseDir&gt;/maps/standard then it tries the
+	 * legacy dir: &lt;program-dir&gt;/maps In case in both locations are no
+	 * .wfl-files it returns &lt;baseDir&gt;/maps/expedia - the place where the
+	 * automatically downloaded maps are placed.
 	 * 
 	 * 
 	 */
@@ -950,7 +1029,9 @@
 		if (f != null &amp;&amp; f.length &gt; 0)
 			return absoluteBaseDir + mapsPath;
 		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_DIRECTORIES_ONLY | FileBase.LIST_ALWAYS_INCLUDE_DIRECTORIES);
-		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of &lt;baseDir&gt;/maps/standard are .wfl files
+		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of
+											// &lt;baseDir&gt;/maps/standard are
+											// .wfl files
 			String[] f2;
 			for (int i = 0; i &lt; f.length; i++) {
 				t.set(null, ret + &quot;/&quot; + f[i]);
@@ -998,12 +1079,15 @@
 	/**
 	 * @param create
 	 *            if true the directory if it doesn't exist will be created
-	 * @return the path where manually imported maps should be stored this should be adjustable in preferences...
+	 * @return the path where manually imported maps should be stored this
+	 *         should be adjustable in preferences...
 	 */
 	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = absoluteBaseDir + mapsPath;
-		if (create &amp;&amp; !(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
-			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation failed?
+		if (create &amp;&amp; !(new FileBugfix(mapsDir).isDirectory())) { // dir
+																	// exists?
+			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation
+															// failed?
 				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + mapsDir, FormBase.OKB)).exec();
 				return null;
 			}
@@ -1018,7 +1102,8 @@
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().absoluteBaseDir.length()).replace('\\', '/');
 		String mapsDir = Global.getPref().absoluteBaseDir + &quot;maps/&quot; + Common.ClearForFileName(mapkind) + &quot;/&quot; + subdir;
 		if (!(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
-			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation failed?
+			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation
+															// failed?
 			{
 				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
 				return null;
@@ -1028,7 +1113,10 @@
 	}
 
 	public String getMapExpediaLoadPath() {
-		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps/expedia&quot;; // baseDir has trailing /
+		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps/expedia&quot;; // baseDir
+																						// has
+																						// trailing
+																						// /
 	}
 
 	// ////////////////////////////////////////////////////////////////////////////////////
@@ -1040,18 +1128,31 @@
 	static protected final int PROFILE_SELECTOR_ONOROFF = 2;
 
 	/**
-	 * tries to get the home data dir of the user e.g. &quot;c:\documents and...\&lt;user&gt;\my documents&quot; or &quot;/home/&lt;user&gt;&quot; in linux if none could be identified, &quot;/&quot; is returned.
+	 * tries to get the home data dir of the user e.g. &quot;c:\documents and...\&lt;user&gt;\my
+	 * documents&quot; or &quot;/home/&lt;user&gt;&quot; in linux if none could be identified,
+	 * &quot;/&quot; is returned.
 	 * 
 	 * @return
 	 */
 	public String getHomeDir() {
 		String test;
-		test = Vm.getenv(&quot;HOMEDRIVE&quot;, &quot;&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
-		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in win32.exe (ewe-vm on win xp)
-		test += Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
-		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in win32.exe (ewe-vm on win xp)
+		test = Vm.getenv(&quot;HOMEDRIVE&quot;, &quot;&quot;); // returns in java-vm on win xp:
+											// c:\&lt;dokumente und
+											// Einstellungen&gt;\&lt;username&gt;\&lt;application
+											// data&gt;
+		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in
+												// win32.exe (ewe-vm on win
+												// xp)
+		test += Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;); // returns in java-vm on win xp:
+											// c:\&lt;dokumente und
+											// Einstellungen&gt;\&lt;username&gt;\&lt;application
+											// data&gt;
+		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in
+												// win32.exe (ewe-vm on win
+												// xp)
 		if (test.length() == 0)
-			test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;); // This should return on *nix system the home dir
+			test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;); // This should return on *nix
+											// system the home dir
 		if (test.length() == 0)
 			test = &quot;/&quot;;
 		return test;
@@ -1082,7 +1183,10 @@
 		checkAbsoluteBaseDir();
 		boolean profileExists = true; // Assume that the profile exists
 		do {
-			if (!profileExists || (showProfileSelector == PROFILE_SELECTOR_FORCED_ON) || (showProfileSelector == PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)) { // Ask for the profile
+			if (!profileExists || (showProfileSelector == PROFILE_SELECTOR_FORCED_ON) || (showProfileSelector == PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)) { // Ask
+																																										// for
+																																										// the
+																																										// profile
 				ProfilesForm f = new ProfilesForm(absoluteBaseDir, lastProfile, !profileExists || hasNewButton ? 0 : 1);
 				int code = f.execute();
 				// If no profile chosen (includes a new one), terminate
@@ -1176,7 +1280,9 @@
 	private final String LOGFILENAME = FileBase.getProgramDirectory() + &quot;/log.txt&quot;;
 
 	/**
-	 * Method to delete an existing log file. Called on every SpiderGC. The log file is also cleared when Preferences is created and the filesize &gt; 60KB
+	 * Method to delete an existing log file. Called on every SpiderGC. The
+	 * log file is also cleared when Preferences is created and the filesize &gt;
+	 * 60KB
 	 */
 	public void logInit() {
 		File logFile = new FileBugfix(LOGFILENAME);
@@ -1193,10 +1299,12 @@
 	boolean forceLog = false;
 
 	/**
-	 * Method to log messages to a file called log.txt It will always append to an existing file. To show the message on the console, the global variable debug must be set. This can be done by adding
+	 * Method to log messages to a file called log.txt It will always append
+	 * to an existing file. To show the message on the console, the global
+	 * variable debug must be set. This can be done by adding
 	 * 
 	 * &lt;pre&gt;
-	 * &lt;debug value=&quot;true&quot;&gt;
+	 * &lt;debug value=&quot;true&quot;&gt;
 	 * &lt;/pre&gt;
 	 * 
 	 * to the pref.xml file
@@ -1239,14 +1347,18 @@
 	 * @param e
 	 *            The exception
 	 * @param withStackTrace
-	 *            If true and the debug switch is true, the stack trace is appended to the log The debug switch can be set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file or by manually setting it (i.e. in BE
-	 *            versions or RC versions) by including the line
+	 *            If true and the debug switch is true, the stack trace is
+	 *            appended to the log The debug switch can be set by
+	 *            including the line &lt;i&gt;&lt;debug
+	 *            value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file
+	 *            or by manually setting it (i.e. in BE versions or RC
+	 *            versions) by including the line
 	 * 
-	 *            &lt;pre&gt;
+	 * &lt;pre&gt;
 	 * Global.getPref().debug = true;
 	 * &lt;/pre&gt;
 	 * 
-	 *            in Version.getRelease()
+	 * in Version.getRelease()
 	 */
 	public void log(String text, Throwable e, boolean withStackTrace) {
 		if (e != null) {
@@ -1262,7 +1374,9 @@
 	}
 
 	/**
-	 * Log an exception to the log file without a stack trace, i.e. where a stack trace is not needed because the location/cause of the error is clear
+	 * Log an exception to the log file without a stack trace, i.e. where a
+	 * stack trace is not needed because the location/cause of the error is
+	 * clear
 	 * 
 	 * @param message
 	 *            Optional message (Can be empty string)
@@ -1314,7 +1428,8 @@
 	}
 
 	/**
-	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is saved in the preferences.
+	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter
+	 * with the given ID is saved in the preferences.
 	 * 
 	 * @param filterID
 	 *            ID of the filter to check
@@ -1325,7 +1440,8 @@
 	}
 
 	/**
-	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, so it may be resaved under another ID.
+	 * Returns the FilterData object saved with the given ID. The ID is not
+	 * saved in the object, so it may be resaved under another ID.
 	 * 
 	 * @param filterID
 	 *            ID of the FilterData object
@@ -1336,7 +1452,9 @@
 	}
 
 	/**
-	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the given ID, the old object is removed and the new one is set at its place.
+	 * Adds a FilterData object to the list. If a FilterData object is
+	 * already saved unter the given ID, the old object is removed and the
+	 * new one is set at its place.
 	 * 
 	 * @param filterID
 	 *            ID to associate with the filter object
@@ -1348,7 +1466,8 @@
 	}
 
 	/**
-	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object exists, nothing happens.
+	 * Removed the FilterData object which is saved with the given ID. If no
+	 * such FilterData object exists, nothing happens.
 	 * 
 	 * @param filterID
 	 *            ID of FilterData object to remove
@@ -1358,7 +1477,8 @@
 	}
 
 	/**
-	 * Returns a alphabetically sorted array of ID of saved FilterData objects.
+	 * Returns a alphabetically sorted array of ID of saved FilterData
+	 * objects.
 	 * 
 	 * @return Array of IDs
 	 */
@@ -1388,7 +1508,8 @@
 			p.waitFor();
 			gpsbabel = &quot;gpsbabel&quot;;
 		} catch (IOException ioex) {
-			// Most of the time there will be an exception, so don't complain
+			// Most of the time there will be an exception, so don't
+			// complain
 		}
 		if (gpsbabel == null) {
 			try {
@@ -1396,14 +1517,16 @@
 				p.waitFor();
 				gpsbabel = &quot;gpsbabel.exe&quot;;
 			} catch (IOException ioex) {
-				// Most of the time there will be an exception, so don't complain
+				// Most of the time there will be an exception, so don't
+				// complain
 			}
 		}
 	}
 
 	/**
 	 * get directory where pref.xml is stored&lt;br&gt;
-	 * use this if you need a path where the user has sufficient rights to create a file
+	 * use this if you need a path where the user has sufficient rights to
+	 * create a file
 	 */
 	public String getPathToConfigFile() {
 		return pathToConfigFile;

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-06-13 17:58:00 UTC (rev 3026)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-06-15 20:53:01 UTC (rev 3027)
@@ -205,15 +205,14 @@
 	public void doIt(boolean _spiderAllFinds) {
 		cachesToLoad.clear();
 		spiderAllFinds = _spiderAllFinds;
-		origin = pref.getCurCentrePt(); // No need to copy curCentrePt as it is
-										// only read and not written
+		// No need to copy curCentrePt as it is only read and not written
+		origin = pref.getCurCentrePt();
 		if (!spiderAllFinds &amp;&amp; !origin.isValid()) {
 			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
 			return;
 		}
 
-		// Reset states for all caches when spidering
-		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
+		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
@@ -320,12 +319,8 @@
 					for (int i = 0; i &lt; points.size(); i++) {
 						try {
 							nav.curTrack.add((TrackPoint) points.get(i));
-						} catch (final IndexOutOfBoundsException e) { // track
-																		// full
-																		// -&gt;
-																		// create
-																		// a new
-																		// one
+						} catch (final IndexOutOfBoundsException e) {
+							// track full -&gt; create a new one
 							nav.curTrack = new Track(nav.trackColor);
 							nav.curTrack.add((TrackPoint) points.get(i));
 							if (mm != null)
@@ -528,16 +523,15 @@
 		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(1609, &quot;getting the caches.&quot;));
 		infB.exec();
 
-		// Reset states for all caches when spidering
-		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
+		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl&#195;&#131;&#194;&#164;nge eines Quadrats
-												// ums Zentrum in km
+		// halbe Seitenl&#228;nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance;
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
@@ -702,12 +696,11 @@
 			doNotgetFound = options.foundCheckBox.getState();
 			profile.setDirectionGC(direction);
 
-		} else if (menu == 1) { // menu = 1 input values for get Caches along a
-								// route
+		} else if (menu == 1) {
+			// menu = 1 input values for get Caches along a route
 			options = new OCXMLImporterScreen(MyLocale.getMsg(137, &quot;Download along a Route from geocaching.com&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TRAVELBUGS
 					| OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.FILENAME | OCXMLImporterScreen.TYPE);
-			// setting defaults for input
-			// doing the input
+			// setting defaults for input doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
 				return false;
 			}
@@ -756,9 +749,10 @@
 			maxDistance = Common.parseDouble(maxDist);
 			if (maxDistance == 0)
 				return false;
+			// zur Sicherheit bei &quot;along the route&quot;
+			// mindenstens 500 meter Umkreis
 			if (maxDistance &lt; 0.5)
-				maxDistance = 0.5; // zur Sicherheit bei &quot;along the route&quot;
-									// mindenstens 500 meter Umkreis
+				maxDistance = 0.5;
 			profile.setDistGC(Double.toString(maxDistance));
 		}
 
@@ -778,8 +772,7 @@
 
 		int numFinds;
 		int startPage = 1;
-		// get pagenumber of page with fromDistance , to skip reading of pages &lt;
-		// fromDistance
+		// get pagenumber of page with fromDistance , to skip reading of pages &lt; fromDistance
 		if (fromDistance &gt; 0) {
 			// distance in miles for URL
 			int fromDistanceInMiles = (int) java.lang.Math.ceil(fromDistance);
@@ -788,9 +781,8 @@
 			}
 			// - a mile to be save to get a page with fromDistance
 			getFirstListPage(java.lang.Math.max(fromDistanceInMiles - 1, 1));
-			numFinds = getNumFound(htmlListPage); // Number of caches from gc
-													// Listpage
-			// calc the number of the startpage
+			// Number of caches from gc Listpage calc the number of the startpage
+			numFinds = getNumFound(htmlListPage);
 			startPage = (int) java.lang.Math.ceil(numFinds / 20);
 		}
 
@@ -799,12 +791,11 @@
 		if (pref.metricSystem != Metrics.IMPERIAL) {
 			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(toDistance, Metrics.KILOMETER, Metrics.MILES));
 		}
-		// add a mile to be save from different distance calculations in CW and
-		// at GC
+		// add a mile to be save from different distance calculations in CW and at GC
 		toDistanceInMiles++;
 		getFirstListPage(toDistanceInMiles);
-		numFinds = getNumFound(htmlListPage); // Number of caches from gc first
-												// Listpage
+		// Number of caches from gcfirst Listpage
+		numFinds = getNumFound(htmlListPage);
 
 		if (fromDistance &gt; 0) {
 			// skip (most of) the pages with distance &lt; fromDistance
@@ -847,15 +838,15 @@
 				}
 			}
 		}
-		final int startSize = cExpectedForUpdate.size(); // for save reasons
+		// for save reasons
+		final int startSize = cExpectedForUpdate.size();
 
 		// for don't loose the already done work
 		final Hashtable cFoundForUpdate = new Hashtable(cacheDB.size());
 		page_number = 1;
 		int found_on_page = 0;
 		try {
-			// Loop pages till maximum distance has been found or no more caches
-			// are in the list
+			// Loop pages till maximum distance has been found or no more caches are in the list
 			while (toDistance &gt; 0) {
 				RexPropListBlock.search(htmlListPage);
 				String tableOfHtmlListPage;
@@ -888,12 +879,13 @@
 									cachesToLoad.add(chWaypoint);
 								}
 							} else {
-								// pref.log(&quot;no load of (Premium Cache/other direction/short Distance ?) &quot;
-								// + chWaypoint);
+								// pref.log(&quot;no load of (Premium Cache/other direction/short
+								// Distance ?) &quot; + chWaypoint);
 								cExpectedForUpdate.remove(chWaypoint);
 							}
 						} else {
-							if (maxUpdate &gt; 0) { // regardless of fromDistance
+							if (maxUpdate &gt; 0) {
+								// regardless of fromDistance
 								if (!ch.is_black()) {
 									if (doPMCache(chWaypoint, CacheDescriptionGC) &amp;&amp; updateExists(ch, CacheDescriptionGC)) {
 										if (cFoundForUpdate.size() &lt; maxUpdate) {
@@ -917,9 +909,8 @@
 							}
 						}
 					} else
-						toDistance = 0; // finish listing
-					// get next row of table (next Cache Description) of this
-					// htmlListPage
+						// finish listing get next row of table (next Cache Description) of this htmlListPage
+						toDistance = 0;
 					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine.matchedTo());
 					if (infB.isClosed) {
 						toDistance = 0;
@@ -929,14 +920,12 @@
 				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;) + cachesToLoad.size() + &quot; / &quot; + cFoundForUpdate.size() + MyLocale.getMsg(5512, &quot; caches&quot;));
 				if (found_on_page &lt; 20) {
 					if (spiderAllFinds) {
-						// check all pages ( seen a gc-account with
-						// found_on_page less 20 and not on end )
+						// check all pages ( seen a gc-account with found_on_page less 20 and not on end )
 						if (((page_number - 1) * 20 + found_on_page) &gt;= numFinds) {
 							toDistance = 0;
 						}
 					} else
-						toDistance = 0; // last page (has less than 20
-										// entries!?) to check reached
+						toDistance = 0; // last page (has less than 20 entries!?) to check reached
 				}
 				if (toDistance &gt; 0) {
 					getAListPage(toDistanceInMiles, gotoNextPage);
@@ -989,8 +978,7 @@
 				} else if (test == SPIDER_OK) {
 					cacheDB.add(holder);
 					holder.save();
-				} // For test == SPIDER_IGNORE_PREMIUM and SPIDER_IGNORE there
-					// is nothing to do
+				} // For test == SPIDER_IGNORE_PREMIUM and SPIDER_IGNORE there is nothing to do
 			}
 		}
 		return spiderErrors;
@@ -1021,7 +1009,8 @@
 	/**
 	 * Method to spider a single cache. It assumes a login has already been performed!
 	 * 
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
+	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with
+	 *         next cache
 	 */
 	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin, boolean loadAllLogs) {
 		int ret = -1;
@@ -1029,8 +1018,7 @@
 		final CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
 		ch.setWayPoint(cacheDB.get(number).getWayPoint());
 		if (ch.isAddiWpt())
-			return -1; // No point re-spidering an addi waypoint, comes with
-						// parent
+			return -1; // No point re-spidering an addi waypoint, comes with parent
 
 		if (!login())
 			return -1;
@@ -1042,11 +1030,9 @@
 				final CacheHolder cacheInDB = cacheDB.get(number);
 				cacheInDB.initStates(false);
 				if (cacheInDB.is_found() &amp;&amp; !ch.is_found() &amp;&amp; !loadAllLogs) {
-					// If the number of logs to spider is 5 or less, then the
-					// &quot;not found&quot; information
-					// of the spidered cache is not credible. In this case it
-					// should not overwrite
-					// the &quot;found&quot; state of an existing cache.
+					// If the number of logs to spider is 5 or less,
+					// then the &quot;not found&quot; information of the spidered cache is not credible.
+					// In this case it should not overwrite the &quot;found&quot; state of an existing cache.
 					ch.setFound(true);
 				}
 				// preserve rating information
@@ -1076,8 +1062,8 @@
 	 */
 	public String getCacheCoordinates(String wayPoint) {
 		String completeWebPage;
-		// Check whether spider definitions could be loaded, if not issue
-		// appropriate message and terminate
+		// Check whether spider definitions could be loaded,
+		// if not issue appropriate message and terminate
 		// Try to login. If login fails, issue appropriate message and terminate
 		if (!login())
 			return &quot;&quot;;
@@ -1101,7 +1087,8 @@
 	} // getCacheCoordinates
 
 	/**
-	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
+	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the
+	 * login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
 	 */
 	private boolean login() {
 		if (loggedIn &amp;&amp; !pref.forceLogin) {
@@ -1194,8 +1181,7 @@
 					} else {
 						localInfB.close(0);
 						pref.log(&quot;[login]:__VIEWSTATE not found (before login): no login possible.&quot;, null);
-						// we need the __VIEWSTATE for sending loginData, so we
-						// should abort here
+						// we need the __VIEWSTATE for sending loginData, so we should abort here
 						return false;
 					}
 					final StringBuffer sb = new StringBuffer(1000);
@@ -1212,8 +1198,7 @@
 					loginPage = UrlFetcher.fetch(loginPageUrl);
 					if (loginPage.indexOf(loginSuccess) &gt; 0) {
 						pref.log(&quot;Login successful: &quot; + pref.myAlias);
-						// **3 now we are logged in and get the Cookie (there
-						// are two)
+						// **3 now we are logged in and get the Cookie (there are two)
 						final PropertyList pl = UrlFetcher.getDocumentProperties();
 						String docprops = &quot;&quot;;
 						for (int i = 0; i &lt; pl.size(); i++) {
@@ -1321,8 +1306,10 @@
 			pref.oldLanguageCtl = &quot;&quot;; // nothing to reset
 			return true;
 		}
-		// switch to english now goes into gc account Display Preferences (is permanent, must be reset)
-		// todo as long as Textfile Encoding is CP1252 we compare with substring(1) and think koreanisch if no merge at all
+		// switch to english now goes into gc account Display Preferences
+		// (is permanent, must be reset)
+		// todo as long as Textfile Encoding is CP1252 we compare with
+		// substring(1) and think koreanisch if no merge at all
 		String languages[] = { &quot;English&quot;, &quot;Deutsch&quot;, &quot;Fran&#231;ais&quot;, &quot;Portugu&#234;s&quot;, &quot;Ce&#154;tina&quot;, &quot;Svenska&quot;, &quot;Nederlands&quot;, &quot;Catal&#224;&quot;, &quot;Polski&quot;, &quot;Eesti&quot;, &quot;Norsk, Bokm&#229;l&quot;, &quot;???&quot;, &quot;Espa&#241;ol&quot; };
 		for (int i = 0; i &lt; languages.length; i++) {
 			if (oldLanguage.substring(1).equals(languages[i].substring(1))) {
@@ -1354,7 +1341,7 @@
 	}
 
 	/*
-	 *
+	 * 
 	 */
 	private void initialiseProperties() {
 		try {
@@ -1397,7 +1384,7 @@
 	}
 
 	/*
-	 *
+	 * 
 	 */
 	private void getFirstListPage(int distance) {
 		// Get first page
@@ -1533,7 +1520,8 @@
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl&#195;&#131;&#194;&#164;nge eines Quadrats ums Zentrum in km
+		// halbe Seitenl&#228;nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance;
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
@@ -1633,7 +1621,8 @@
 		final int f = 1 &lt;&lt; scale; // 2**scale
 		lat = lat * f;
 		lon = lon * f;
-		return new TrackPoint(lat, lon); // TrackPoint only for returning values
+		return new TrackPoint(lat, lon); // TrackPoint only for returning
+		// values
 	}
 
 	private CWPoint getLatLon(double basex, double basey, int offsetx, int offsety, int scale) {
@@ -1900,9 +1889,7 @@
 				return distanceAndDirection; // zur Zeit &quot; Here -1&quot;
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
 			// da dieser von gc mal wieder ge&#195;&#131;&#194;&#164;ndert wurde.
-			// todo Ben&#195;&#131;&#194;&#182;tigt ev noch weitere Anpassungen: | am Anfang, and calc
-			// of keylength
-
+			// todo Ben&#246;tigt ev noch weitere Anpassungen: | am Anfang, and calc of keylength
 			// String thereitis=&quot;|0.34 km|102.698&quot;;
 			// String page =
 			// fetchText(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1">http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1</A>&quot;,false);
@@ -2032,19 +2019,27 @@
 			}
 			final Image idoc = new Image(doc, 0, null, 0, 0);
 			/*
-			 * FileOutputStream fos; try { fos = new FileOutputStream(new File(&quot;temp.png&quot;)); fos.write(doc.toBytes()); fos.close(); } catch (IOException e) { } finally { }
+			 * FileOutputStream fos; try { fos = new FileOutputStream(new File(&quot;temp.png&quot;)); fos.write(doc.toBytes());
+			 * fos.close(); } catch (IOException e) { } finally { }
 			 */
 			final String ret = getDTfromImage(idoc) + &quot;/&quot; + getSizeFromImage(idoc);
 			return ret;
 			// */
 
 			/*
-			 * int decoded = 0; int pwr = 1; for (int i = code.length()-1 ; i &gt;= 0; i--) { decoded = decoded + DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr; pwr = pwr * 42; } decoded = (decoded - 1386) % 16777216; // size 0=not choosen 1=Micro
-			 * 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small int sizecode = decoded / 74088; // 42 ^ 3 int sizeremove; byte size; switch (sizecode) { case 0: size=CacheSize.CW_SIZE_NOTCHOSEN; sizeremove=0; break; case 1: size=CacheSize.CW_SIZE_MICRO;
-			 * sizeremove=131072; break; case 3: size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break; case 5: size=CacheSize.CW_SIZE_LARGE; sizeremove=393217; break; case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break; case 8:
-			 * size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break; case 12: size=CacheSize.CW_SIZE_SMALL; sizeremove=917504; break; default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break; } decoded = decoded - sizeremove; int terraincode =
-			 * decoded / 252; // terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5 String terrain = &quot;&quot; + (1 + terraincode / 2.0 ); // difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5 String difficulty = &quot;&quot; + (1+((decoded % 42) - (terraincode *
-			 * 4)) / 2.0); if (difficulty.equals(&quot;0.5&quot;)) { difficulty = &quot;5&quot;; } return difficulty+&quot;/&quot;+terrain+&quot;/&quot;+size;
+			 * int decoded = 0; int pwr = 1; for (int i = code.length()-1 ; i &gt;= 0; i--) { decoded = decoded +
+			 * DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr; pwr = pwr * 42; } decoded = (decoded - 1386) % 16777216; //
+			 * size 0=not choosen 1=Micro 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small int sizecode = decoded / 74088; //
+			 * 42 ^ 3 int sizeremove; byte size; switch (sizecode) { case 0: size=CacheSize.CW_SIZE_NOTCHOSEN;
+			 * sizeremove=0; break; case 1: size=CacheSize.CW_SIZE_MICRO; sizeremove=131072; break; case 3:
+			 * size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break; case 5: size=CacheSize.CW_SIZE_LARGE;
+			 * sizeremove=393217; break; case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break; case 8:
+			 * size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break; case 12: size=CacheSize.CW_SIZE_SMALL;
+			 * sizeremove=917504; break; default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break; } decoded = decoded -
+			 * sizeremove; int terraincode = decoded / 252; // terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
+			 * String terrain = &quot;&quot; + (1 + terraincode / 2.0 ); // difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
+			 * String difficulty = &quot;&quot; + (1+((decoded % 42) - (terraincode * 4)) / 2.0); if (difficulty.equals(&quot;0.5&quot;)) {
+			 * difficulty = &quot;5&quot;; } return difficulty+&quot;/&quot;+terrain+&quot;/&quot;+size;
 			 */
 		}
 		pref.log(&quot;[SpiderGC.java:getDTS]check DTSRex!&quot;, null);
@@ -2103,9 +2098,7 @@
 			if (bild.getHeight() &gt; startY + y) {
 				for (int x = 0; x &lt; validChar[0].length; x++) {
 					if (bild.getWidth() &gt; startX + x) {
-						// int[] alpha =
-						// bild.getAlphaRaster().getPixel(startX+x, startY+y,
-						// new int[1]);
+						// int[] alpha = bild.getAlphaRaster().getPixel(startX+x, startY+y, new int[1]);
 						final int[] argb = bild.getPixels(null, 0, startX + x, startY + y, 1, 1, 0);
 						if ((argb[0] == 0 &amp;&amp; validChar[y][x] == 0) || (argb[0] != 0 &amp;&amp; validChar[y][x] &gt; 0)) {
 							// matches
@@ -2225,18 +2218,27 @@
 	}
 
 	/**
-	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file and fetching the images.
+	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already
+	 * existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file
+	 * and fetching the images.
 	 * 
 	 * This is the workhorse function of the spider.
 	 * 
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
-	 * @param boolean isUpdate True if an existing cache is being updated, false if it is a new cache
-	 * @param boolean fetchImages True if the pictures are to be fetched
-	 * @param boolean fetchTBs True if the TBs are to be fetched
-	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
-	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line). This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
+	 * @param boolean
+	 *            isUpdate True if an existing cache is being updated, false if it is a new cache
+	 * @param boolean
+	 *            fetchImages True if the pictures are to be fetched
+	 * @param boolean
+	 *            fetchTBs True if the TBs are to be fetched
+	 * @param boolean
+	 *            doNotGetFound True if the cache is not to be spidered if it has already been found
+	 * @param boolean
+	 *            fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line). This is
+	 *            normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if
+	 *         everything ok
 	 */
 	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean fetchTBs, boolean doNotGetFound, boolean fetchAllLogs) {
 		int ret = SPIDER_OK; // initialize value;
@@ -2269,14 +2271,12 @@
 						return SPIDER_CANCEL;
 					}
 				}
-				// Only analyse the cache data and fetch pictures if user has
-				// not closed the progress window
+				// Only analyse the cache data and fetch pictures if user has not closed the progress window
 				if (!infB.isClosed) {
 					try {
 						ch.initStates(!isUpdate);
 
-						// first check if coordinates are available to prevent
-						// deleting existing coordinates
+						// first check if coordinates are available to prevent deleting existing coordinates
 						final String latLon = getLatLon(completeWebPage);
 						if (latLon.equals(&quot;???&quot;)) {
 							if (completeWebPage.indexOf(p.getProp(&quot;premiumCachepage&quot;)) &gt; 0) {
@@ -2287,7 +2287,7 @@
 								continue;
 							} else {
 								if (spiderTrys == MAX_SPIDER_TRYS)
-									pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot; + completeWebPage, null);
+									pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot;, null);
 								ret = SPIDER_ERROR;
 								continue; // Restart the spider
 							}
@@ -2295,8 +2295,7 @@
 
 						ch.setHTML(true);
 						ch.setIncomplete(true);
-						// Save size of logs to be able to check whether any new
-						// logs were added
+						// Save size of logs to be able to check whether any new logs were added
 						// int logsz = chD.CacheLogs.size();
 						// chD.CacheLogs.clear();
 						ch.addiWpts.clear();
@@ -2309,8 +2308,7 @@
 						// ==========
 						getLogs(completeWebPage, ch.getCacheDetails(false));
 						pref.log(&quot;Got logs&quot;);
-						// If the switch is set to not store found caches and we
-						// found the cache =&gt; return
+						// If the switch is set to not store found caches and we found the cache =&gt; return
 						if (ch.is_found() &amp;&amp; doNotGetFound) {
 							if (infB.isClosed) {
 								return SPIDER_CANCEL;
@@ -2422,8 +2420,8 @@
 			}
 			break;
 		}// while(true) // retry even if failure
-		if (infB.isClosed) {// If the infoBox was closed before getting here, we
-							// return -1
+		if (infB.isClosed) {
+			// If the infoBox was closed before getting here, we return -1
 			return SPIDER_CANCEL;
 		}
 		return ret;
@@ -2479,9 +2477,8 @@
 		if (spanEnd &gt;= 0) {
 			res = res.substring(0, spanEnd);
 		}
-		return SafeXML.cleanback(res); // since internal viewer doesn't show
-										// html-entities that are now in
-										// cacheDescription
+		// since internal viewer doesn't show html-entities that are now in cacheDescription
+		return SafeXML.cleanback(res);
 	}
 
 	/**
@@ -2725,7 +2722,8 @@
 	}
 
 	/**
-	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each travelbug
+	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each
+	 * travelbug
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
@@ -2761,7 +2759,8 @@
 					try {
 						infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, &quot;\nGetting bug: &quot;) + SafeXML.cleanback(bug));
 						bugDetails = UrlFetcher.fetch(link);
-						exBugName.set(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND); // reusing exBugName
+						exBugName.set(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND); // reusing
+						// exBugName
 						chD.Travelbugs.add(new Travelbug(link.substring(1 + link.indexOf(&quot;=&quot;)), bug, exBugName.findNext()));
 					} catch (final Exception ex) {
 						pref.log(&quot;[SpiderGC.java:getBugs] Could not fetch buginfo from &quot; + link, ex);
@@ -2777,7 +2776,8 @@
 	}
 
 	/**
-	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and the pictures section (including the spoiler)
+	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and
+	 * the pictures section (including the spoiler)
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
@@ -2816,16 +2816,14 @@
 		String tst;
 		Extractor exImgSrc = new Extractor(&quot;&quot;, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
 		while ((tst = exImgBlock.findNext()).length() &gt; 0) {
-			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
-			// better caching purposes)
+			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for better caching purposes)
 			imgUrl = exImgSrc.findFirst(tst);
 			imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
 			try {
 				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
 				// imgType is now max 4 chars, starting with .
 				if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
-					// Check whether image was already spidered for this
-					// cache
+					// Check whether image was already spidered for this cache
 					idxUrl = spideredUrls.find(imgUrl);
 					imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
 					imageInfo = null;
@@ -2881,8 +2879,7 @@
 				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
 				// imgType is now max 4 chars, starting with .
 				if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
-					// Check whether image was already spidered for this
-					// cache
+					// Check whether image was already spidered for this cache
 					idxUrl = spideredUrls.find(imgUrl);
 					imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
 					imageInfo = null;
@@ -2927,17 +2924,15 @@
 		// ========
 		final Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
 		while ((imgUrl = exFinal.findNext()).length() &gt; 0) {
-			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
-			// better caching purposes)
+			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for better caching purposes)
 			imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
 			try {
 				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-				// imgType is now max 4 chars, starting with . Delete
-				// characters in URL after the image extension
+				// imgType is now max 4 chars, starting with .
+				// Delete characters in URL after the image extension
 				imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
 				if (imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
-					// Check whether image was already spidered for this
-					// cache
+					// Check whether image was already spidered for this cache
 					idxUrl = spideredUrls.find(imgUrl);
 					if (idxUrl &lt; 0) { // New image
 						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
@@ -3108,9 +3103,8 @@
 
 	public String encodeUTF8URL(byte[] what) {
 		final int max = what.length;
-		final char[] dest = new char[6 * max]; // Assume each char is a UTF char
-												// and
-												// encoded into 6 chars
+		// Assume each char is a UTF char and encoded into 6 chars
+		final char[] dest = new char[6 * max];
 		char d = 0;
 		for (int i = 0; i &lt; max; i++) {
 			final char c = (char) what[i];
@@ -3125,7 +3119,8 @@
 	}
 
 	/**
-	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
+	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical
+	 * names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
 	 * Note that each bug has both an ID and a GUID.
 	 * 
 	 * @param name
@@ -3161,7 +3156,8 @@
 	}
 
 	/**
-	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be a GUID, otherwise it is an ID.
+	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be
+	 * a GUID, otherwise it is an ID.
 	 * 
 	 * @param guid
 	 *            the guid or id of the travelbug

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-06-13 17:58:00 UTC (rev 3026)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-06-15 20:53:01 UTC (rev 3027)
@@ -92,8 +92,13 @@
 	public final static int gotFix = 4; // green
 	public final static int lostFix = 3; // yellow
 	public final static int noGPSData = 2; // red
-	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
-	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
+	public final static int noGPS = 1; // no GPS-Position marker, manually
+										// disconnected
+	public final static int ignoreGPS = -1; // ignore even changes in
+											// GPS-signal (eg. from lost fix
+											// to gotFix) this is wanted
+											// when the map is moved
+											// manually
 
 	public MapSymbol gotoPos = null;
 	public int GpsStatus;
@@ -122,10 +127,14 @@
 	// double posCircleLat, posCircleLon;
 	FontMetrics fm;
 
-	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean dontUpdatePos = false; // this is only internaly used to avoid
+									// multi-threading problems
 	boolean ignoreGps = false; // ignores updateGps-calls if true
 	boolean autoSelectMap = true;
-	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean forceMapLoad = true; // only needed to force updateposition
+									// to try to load the best map again
+									// after OutOfMemoryError after an
+									// repeated click on snap-to-gps
 	public boolean mapHidden = false;
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
@@ -143,7 +152,8 @@
 	public static final int tileWidth = 100;
 	public static final int tileHeight = 100;
 
-	// Needed by updatePosition to decide if a recalculation of map-tiles is needed:
+	// Needed by updatePosition to decide if a recalculation of map-tiles is
+	// needed:
 	private int lastXPos;
 	private int lastYPos;
 	private int lastWidth;
@@ -194,15 +204,26 @@
 		this.pref = Global.getPref();
 		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)
 			this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
-		// The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
+		// The following line is commented out, because this caused trouble
+		// under ewe-vm v1.49 on win-xp
 		// when MovingMap was started with maximized CacheWolf-Window
-		// this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
+		// this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE |
+		// UIConstants.BDR_NOBORDER;
 		this.hasTopBar = false;
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		// this.setPreferredSize(240,320);
 		this.title = &quot;Moving Map&quot;;
-		this.backGround = new Color(254, 254, 254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.backGround = new Color(254, 254, 254); // background must not
+													// be black because
+													// black is interpreted
+													// as transparent and
+													// transparent images
+													// above (eg
+													// trackoverlay) want be
+													// drawn in windows-VM,
+													// so be care, don|t use
+													// white either
 
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
@@ -254,7 +275,8 @@
 			posCircle.screenDimChanged();
 		if (tracks != null)
 			rebuildOverlaySet();
-		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
+		if (symbols != null) { // TODO: see if the rest of the code works
+								// with symbols = null
 			for (int i = symbols.size() - 1; i &gt;= 0; i--) {
 				((MapSymbol) symbols.get(i)).screenDimChanged();
 			}
@@ -272,7 +294,8 @@
 	 * @param mapsPath
 	 *            must not have a trailing end &quot;/&quot;
 	 * @param lat
-	 *            used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 *            used to create empty maps with correct conversion from lon
+	 *            to meters the latitude must be known
 	 */
 	public void loadMaps(String mapsPath, double lat) {
 		if (loadingMapList)
@@ -292,7 +315,10 @@
 			noMapsAvailable = true;
 		} else
 			noMapsAvailable = false;
-		maps.addEmptyMaps(lat); // the empty maps must be added last, otherwise in method setBestMap, when no map is available, a malfunction will happen, see there
+		maps.addEmptyMaps(lat); // the empty maps must be added last,
+								// otherwise in method setBestMap, when no
+								// map is available, a malfunction will
+								// happen, see there
 		maps.onCompletedRead();
 		dontUpdatePos = saveGpsIgnoreStatus;
 		inf.close(0);
@@ -348,7 +374,8 @@
 				final int decimals = (int) (-1 * digits);
 
 				lineLengthString = tmp.toString(decimals + 2, decimals, 0) + Metrics.getUnit(currentUnit);
-				// lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) + Metrics.getUnit(currentUnit);
+				// lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) +
+				// Metrics.getUnit(currentUnit);
 			}
 
 			lineLengthMeters = Metrics.convertUnit(localizedLineLength, currentUnit, Metrics.METER);
@@ -406,17 +433,21 @@
 
 	public void forceMapLoad() {
 		forceMapLoad = true;
-		updatePosition(posCircle.where); // this sets forceMapLoad to false after loading a map
+		updatePosition(posCircle.where); // this sets forceMapLoad to
+											// false after loading a map
 	}
 
 	public final FormFrame myExec(CWPoint centerTo, boolean forceCenter) {
 		final FormFrame ret = exec();
 		running = true;
-		// disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
+		// disconnect movingMap from GPS TODO only if GPS-pos is not on the
+		// screen
 		if (forceCenter)
 			setGpsStatus(noGPS);
-		// to load maplist + place a map on screen otherwise no symbol can be placed
-		ignoreGps = true; // else overlay symbols are removed on started gps
+		// to load maplist + place a map on screen otherwise no symbol can
+		// be placed
+		ignoreGps = true; // else overlay symbols are removed on started
+							// gps
 
 		rebuildOverlaySet(); // show tracks , even if reentering map
 
@@ -432,7 +463,8 @@
 			// this means marking has changed
 			Global.getProfile().selectionChanged = false;
 			if (pref.showCachesOnMap)
-				removeAllMapSymbols(); // not really needed: hopefully removed by showCachesOnMap
+				removeAllMapSymbols(); // not really needed: hopefully
+										// removed by showCachesOnMap
 		}
 		showCachesOnMap();
 
@@ -483,7 +515,9 @@
 		} catch (final NullPointerException e) {
 			// hapens if currentmap == null or PosCircle not valid
 		} catch (final IllegalArgumentException e) {
-			// happens if screensize is still not known ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
+			// happens if screensize is still not known ---&gt; in both cases
+			// creation of Overlayset will be done in updateOverlayPos if
+			// tracks != null
 		}
 	}
 
@@ -504,16 +538,25 @@
 
 	public void addMissingOverlays() {
 		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0)
-			return; // height == 0 happens if this is called before the form ist displayed on the screen
+			return; // height == 0 happens if this is called before the form
+					// ist displayed on the screen
 		if (TrackOverlays == null) {
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 		}
-		final boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		final boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid
+															// multi-threading
+															// problems
 		dontUpdatePos = true;
-		final Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
-		// upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
-		// upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		final Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4]
+																				// ==
+																				// center
+																				// of
+																				// Trackoverlays
+		// upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 *
+		// width;
+		// upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1
+		// * height;
 		int i;
 		for (int yi = 0; yi &lt; 3; yi++) {
 			for (int xi = 0; xi &lt; 3; xi++) {
@@ -521,7 +564,22 @@
 				if (TrackOverlays[i] == null) {
 					pref.log(&quot;addMissingOverlays: widht: &quot; + width + &quot;, height: &quot; + height);
 					TrackOverlays[i] = new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x + (xi - 1) * width, upperleftOf4.y + (yi - 1) * height), width, height, currentMap);
-					TrackOverlays[i].setLocation(width + 1, height + 1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
+					TrackOverlays[i].setLocation(width + 1, height + 1); // outside
+																			// of
+																			// the
+																			// screen
+																			// will
+																			// hide
+																			// it
+																			// automatically
+																			// it
+																			// will
+																			// get
+																			// the
+																			// correct
+																			// position
+																			// in
+																			// upadteOverlayposition
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -627,8 +685,10 @@
 						destroyOverlay(3);
 						destroyOverlay(4);
 						destroyOverlay(5);
-					} else { // it is important to test for diagonal only if the other didn't match
-						if (TrackOverlays[0].isOnScreen()) { // links oben raus
+					} else { // it is important to test for diagonal only
+								// if the other didn't match
+						if (TrackOverlays[0].isOnScreen()) { // links
+																// oben raus
 							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y - 2 * height));
 							destroyOverlay(8);
 							mmp.removeImage(TrackOverlays[0]);
@@ -643,7 +703,9 @@
 							destroyOverlay(6);
 							destroyOverlay(7);
 						} else {
-							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
+							if (TrackOverlays[2].isOnScreen()) { // rechts
+																	// oben
+																	// raus
 								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y - 2 * height));
 								destroyOverlay(6);
 								mmp.removeImage(TrackOverlays[2]);
@@ -658,7 +720,9 @@
 								destroyOverlay(7);
 								destroyOverlay(8);
 							} else {
-								if (TrackOverlays[6].isOnScreen()) { // links unten raus
+								if (TrackOverlays[6].isOnScreen()) { // links
+																		// unten
+																		// raus
 									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y + 2 * height));
 									destroyOverlay(2);
 									mmp.removeImage(TrackOverlays[6]);
@@ -673,7 +737,9 @@
 									destroyOverlay(7);
 									destroyOverlay(8);
 								} else {
-									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
+									if (TrackOverlays[8].isOnScreen()) { // rechts
+																			// unten
+																			// raus
 										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y + 2 * height));
 										destroyOverlay(0);
 										mmp.removeImage(TrackOverlays[8]);
@@ -691,7 +757,8 @@
 										for (int i = 0; i &lt; TrackOverlays.length; i++) {
 											destroyOverlay(i);
 											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
-										} // this happens if a position jump occured
+										} // this happens if a position
+											// jump occured
 								}
 							}
 						}
@@ -719,7 +786,8 @@
 		final Dimension ws = mmp.getSize(null);
 		final int ww = ws.width;
 		final int wh = ws.height;
-		// Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		// Vm.sleep(100); // this is necessary because the ewe vm ist not
+		// multi-threaded and the serial thread also needs time
 		int num, pX, pY;
 		for (int yi = 0; yi &lt; 3; yi++) {
 			for (int xi = 0; xi &lt; 3; xi++) {
@@ -755,11 +823,23 @@
 			posCircleX = width / 2;
 			posCircleY = height / 2;
 		} else {
-			posCircleX = pref.myAppWidth / 2; // maybe this could /should be repleced to windows size
+			posCircleX = pref.myAppWidth / 2; // maybe this could /should
+												// be repleced to windows
+												// size
 			posCircleY = pref.myAppHeight / 2;
 		}
 		posCircle.hidden = false;
-		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2); // posCircle.setLocation caused a problem -&gt; hiding the posCircle in some situation
+		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2); // posCircle.setLocation
+																										// caused
+																										// a
+																										// problem
+																										// -&gt;
+																										// hiding
+																										// the
+																										// posCircle
+																										// in
+																										// some
+																										// situation
 	}
 
 	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
@@ -781,8 +861,8 @@
 	}
 
 	/**
-	 * call this if the map moved on the screen (by dragging)
-	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * call this if the map moved on the screen (by dragging) this routine
+	 * will adjust (move accordingly) all other symbols on the screen
 	 * 
 	 * @param diffX
 	 * @param diffY
@@ -799,23 +879,25 @@
 			dontUpdatePos = false;
 			updatePosition(posCircle.where);
 		} else
-			updateSymbolPositions(); // will also be done in updatePosition
+			updateSymbolPositions(); // will also be done in
+										// updatePosition
 		updateOverlayPos();
 	}
 
 	/**
-	 * get upper left corner of map on window
-	 * this is called when the map needs to be moved / the position of the map is wanted
-	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
-	 * returns the same as mmp.mapImage.getLocation(mapPos);
-	 * but also works if mmp == null and is used to move the map to the correct point
+	 * get upper left corner of map on window this is called when the map
+	 * needs to be moved / the position of the map is wanted the
+	 * map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos); but also works
+	 * if mmp == null and is used to move the map to the correct point
 	 * 
 	 * @return
 	 */
 	public Point getMapPositionOnScreen() {
 		if (currentMap == null || !posCircle.where.isValid())
 			return new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
-		// in case no calculation is possible return somthing outside of the screen
+		// in case no calculation is possible return somthing outside of the
+		// screen
 		final Point mapPos = new Point();
 		// if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
 		// else {
@@ -926,7 +1008,8 @@
 			return;
 		gotoPos = addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, d);
 		forceMapLoad = true;
-		// dirty hack: if this.width == 0, then the symbols are not on the screen
+		// dirty hack: if this.width == 0, then the symbols are not on the
+		// screen
 		// and get hidden by updateSymbolPositions
 		if (this.width != 0)
 			updatePosition(posCircle.where);
@@ -941,7 +1024,8 @@
 			return;
 		gotoPos = addSymbol(&quot;goto&quot;, ch, &quot;goto_map.png&quot;, d);
 		forceMapLoad = true;
-		// dirty hack: if this.width == 0, then the symbols are not on the screen
+		// dirty hack: if this.width == 0, then the symbols are not on the
+		// screen
 		// and get hidden by updateSymbolPositions
 		if (this.width != 0)
 			updatePosition(posCircle.where);
@@ -1037,7 +1121,8 @@
 	}
 
 	/**
-	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 * Method to laod the best map for lat/lon and move the map so that the
+	 * posCircle is at lat/lon
 	 */
 	public void updatePosition(CWPoint where) {
 		if (dontUpdatePos || loadingMapList)
@@ -1052,9 +1137,20 @@
 		final boolean screenNotCompletlyCovered = (mmp.mapImage == null) || (mmp.mapImage != null &amp;&amp; (mapPos.y &gt; 0 || mapPos.x &gt; 0 || mapPos.y + mmp.mapImage.getHeight() &lt; this.height || mapPos.x + mmp.mapImage.getWidth() &lt; this.width));
 		// if screendimensions changed also force reload of map
 		forceMapLoad |= lastWidth != width || lastHeight != height;
-		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) { // if force || want || map doesn't cover the screen completly
+		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) { // if
+																		// force
+																		// ||
+																		// want
+																		// ||
+																		// map
+																		// doesn't
+																		// cover
+																		// the
+																		// screen
+																		// completly
 			if (forceMapLoad || (java.lang.Math.abs(lastCompareX - mapPos.x) &gt; this.width / 10 || java.lang.Math.abs(lastCompareY - mapPos.y) &gt; this.height / 10)) {
-				// more then 1/10 of screen moved since last time we tried to find a better map
+				// more then 1/10 of screen moved since last time we tried
+				// to find a better map
 				if (autoSelectMap) {
 					setBestMap(where, screenNotCompletlyCovered);
 					forceMapLoad = false;
@@ -1071,7 +1167,8 @@
 					final AniImage im = (AniImage) mmp.images.get(i);
 					if ((im instanceof MapImage) &amp;&amp; (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
 						// locAlways contains the real coordinates while
-						// location is only correct if the image is on the screen.
+						// location is only correct if the image is on the
+						// screen.
 						final Point p = ((MapImage) im).locAlways;
 						p.x += deltaX;
 						p.y += deltaY;
@@ -1094,7 +1191,8 @@
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
 			if (screenArea.isInBound(ch.pos)) {
-				// because visible and valid don't change while showing map --&gt;need no remove
+				// because visible and valid don't change while showing map
+				// --&gt;need no remove
 				if (ch.isVisible() &amp;&amp; ch.pos.isValid()) {
 					if (pref.showCachesOnMap) {
 						if (addSymbolIsNecessary(ch.getWayPoint())) {
@@ -1117,7 +1215,8 @@
 		// adding target and selected
 		// show target
 		if (gotoPos != null) {
-			// the CacheHolder Symbol must be inserted too, even if not marked (if it is Cache)
+			// the CacheHolder Symbol must be inserted too, even if not
+			// marked (if it is Cache)
 			// anywhere there if all Caches shown on map
 			CacheHolder gotoPosCH = null;
 			if (gotoPos.mapObject instanceof CacheHolder) {
@@ -1154,7 +1253,8 @@
 			Vm.showWait(true);
 			dontUpdatePos = true; // no new Position while filling
 
-			final int s = mmp.images.size(); // avoid calling size() in each iteration
+			final int s = mmp.images.size(); // avoid calling size() in
+												// each iteration
 			for (int i = 0; i &lt; s; i++) {
 				final AniImage im = (AniImage) mmp.images.get(i);
 				if (!(im instanceof MapImage) || (im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im) {
@@ -1169,10 +1269,39 @@
 			final Vector rectangles = new Vector();
 			// calculate areas which will not drawn
 			final Point mapPosx = getMapPositionOnScreen();
-			if (screenNotCompletlyCovered &amp;&amp; ( // screen not completely covered is only used, because it is already calculated
-					mapPosx.x &gt; this.width || mapPosx.y &gt; this.height // map doesn't overlap with the screen
+			if (screenNotCompletlyCovered &amp;&amp; ( // screen not completely
+												// covered is only used,
+												// because it is already
+												// calculated
+					mapPosx.x &gt; this.width || mapPosx.y &gt; this.height // map
+																		// doesn't
+																		// overlap
+																		// with
+																		// the
+																		// screen
 							|| mapPosx.x + mmp.mapImage.getWidth() &lt; 0 || mapPosx.y + mmp.mapImage.getHeight() &lt; 0)) {
-				rectangles.add(new Rect(0, 0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
+				rectangles.add(new Rect(0, 0, this.width, this.height)); // if
+																			// the
+																			// map
+																			// is
+																			// completely
+																			// outside
+																			// the
+																			// screen,
+																			// just
+																			// fill
+																			// the
+																			// screen,
+																			// nit
+																			// all
+																			// the
+																			// space
+																			// beteween
+																			// the
+																			// map
+																			// and
+																			// the
+																			// screen
 			} else {
 				final Rect whiteArea = new Rect((-width / 10), (-height / 10), (int) (width * 1.1), (int) (height * 1.1));
 				final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
@@ -1213,7 +1342,8 @@
 		Rect blackArea;
 		final Rect r = (Rect) rectangles.get(0);
 		rectangles.removeElementAt(0);
-		// calculate the center of the rectangle and try to get an map for it
+		// calculate the center of the rectangle and try to get an map for
+		// it
 		final int middlewidth = r.x + (r.width) / 2;
 		final int middleheight = r.y + (r.height) / 2;
 		final CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
@@ -1225,14 +1355,16 @@
 			// No map found, area must be left white
 			return;
 		}
-		// A map was found, but it does not contain the previously calculated center
+		// A map was found, but it does not contain the previously
+		// calculated center
 		if (!(bestMap.bottomright.latDec &lt;= centerPoint.latDec &amp;&amp; centerPoint.latDec &lt;= bestMap.topleft.latDec)) {
 			return;
 		}
 		if (!(bestMap.topleft.lonDec &lt;= centerPoint.lonDec &amp;&amp; centerPoint.lonDec &lt;= bestMap.bottomright.lonDec)) {
 			return;
 		}
-		// Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
+		// Pfeffer got an NPE in the following if-statement. I think the
+		// image-filename has got not the correct extension.
 		// For me, showing a message seems better than throwing the NPE
 		final String imagefilename = bestMap.getImageFilename();
 		if (imagefilename == null) {
@@ -1252,7 +1384,8 @@
 				blackArea = new Rect(mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
 				// Are there any white areas left?
 				calculateRectangles(blackArea, r, rectangles);
-				// Not all maps have the dimension 1000x1000 Pixels, we cache this information:
+				// Not all maps have the dimension 1000x1000 Pixels, we
+				// cache this information:
 				Dimension rect2 = MovingMapCache.getCache().getDimension(filename);
 				MapImage fullImage = null;
 				if (rect2 == null) {
@@ -1275,7 +1408,8 @@
 				if (!isCoveredByBlackArea(mapPos, row, column, blackArea, rect2)) {
 					continue;
 				}
-				// Get tile from cache or if not found, put all tiles for this image into the cache.
+				// Get tile from cache or if not found, put all tiles for
+				// this image into the cache.
 				MapImage im = MovingMapCache.getCache().get(filename, row, column);
 				if (im == null) {
 					if (fullImage == null) {
@@ -1286,7 +1420,8 @@
 				}
 				// If a tile has been found, draw it on the screen
 				if (im != null) {
-					// Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
+					// Check if not already added. this might happen if the
+					// map for horizontal and vertical stripe is the same
 					boolean added = false;
 					for (int i = mmp.images.size() - 1; i &gt;= 0; i--) {
 						final MapImage m = (MapImage) mmp.images.get(i);
@@ -1344,12 +1479,10 @@
 	}
 
 	/*
-	 * private String SRect(Rect r){
-	 * String OL, UR ;
-	 * OL= &quot; (&quot;+String.valueOf(r.x)+&quot;,&quot;+String.valueOf(r.y)+&quot;)&quot;;
-	 * UR= &quot; (&quot;+String.valueOf(r.x+r.width)+&quot;,&quot;+String.valueOf(r.y+r.height)+&quot;) &quot;;
-	 * return OL+&quot; :&quot;+UR;
-	 * }
+	 * private String SRect(Rect r){ String OL, UR ; OL= &quot;
+	 * (&quot;+String.valueOf(r.x)+&quot;,&quot;+String.valueOf(r.y)+&quot;)&quot;; UR= &quot;
+	 * (&quot;+String.valueOf(r.x+r.width)+&quot;,&quot;+String.valueOf(r.y+r.height)+&quot;) &quot;;
+	 * return OL+&quot; :&quot;+UR; }
 	 */
 	private void calculateRectangles(Rect blackArea, Rect whiteArea, Vector rectangles) {
 		if (width == 0 || height == 0)
@@ -1415,7 +1548,11 @@
 			return;
 		// runMovingMap neccessary in case of multi-threaded Java-VM:
 		// ticked could be called during load of mmp
-		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) { // TODO is getSats really necessary?
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) { // TODO
+																	// is
+																	// getSats
+																	// really
+																	// necessary?
 			directionArrows.setDirections((float) myNavigation.gpsPos.getBearing(myNavigation.destination), (float) myNavigation.skyOrientationDir.lonDec, (float) myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos);
@@ -1440,28 +1577,43 @@
 
 	int mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 	float scaleWanted;
-	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
-	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the
-														// wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	boolean wantMapTest = true; // if true updateposition calls setBestMap
+								// regulary even if the currentmap covers
+								// the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen
+														// resolution as
+														// long as a map is
+														// available that
+														// overlaps with the
+														// screen and with
+														// the PosCircle -
+														// it changes the
+														// resolution if no
+														// such map is
+														// available. It wil
+														// cahnge back to
+														// the
+	// wanted scale as soon as a map becomes available (through movement of
+	// the GPS-receiver)
 	public final static int HIGHEST_RESOLUTION = 2;
 	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
 	boolean inBestMap = false; // to avoid multi-threading problems
 
 	/**
-	 * loads the best map for lat/lon according to mapChangeModus
-	 * lat/lon will be at the screen-pos of posCircle
-	 * when posCircle is not on the screen (shifted outside my the user)
-	 * then this routine uses the centre of the screen to find the best map
-	 * but anyway the map will be adjusted (moved) relativ to posCircle
-	 * when a better map was found the called method updateposition will set
-	 * posCirleLat/-Lon to lat/lon.
+	 * loads the best map for lat/lon according to mapChangeModus lat/lon
+	 * will be at the screen-pos of posCircle when posCircle is not on the
+	 * screen (shifted outside my the user) then this routine uses the
+	 * centre of the screen to find the best map but anyway the map will be
+	 * adjusted (moved) relativ to posCircle when a better map was found the
+	 * called method updateposition will set posCirleLat/-Lon to lat/lon.
 	 * 
 	 * @param lat
 	 * @param lon
 	 * @param loadIfSameScale
-	 *            false: will not change the map if the better map has the same scale as the current
-	 *            - this is used not to change the map if it covers already the screen completely
-	 *            true: willchange the map, regardless of change in scale
+	 *            false: will not change the map if the better map has the
+	 *            same scale as the current - this is used not to change the
+	 *            map if it covers already the screen completely true:
+	 *            willchange the map, regardless of change in scale
 	 */
 	public void setBestMap(CWPoint where, boolean loadIfSameScale) {
 		if (inBestMap)
@@ -1491,9 +1643,37 @@
 				if ((!posCircleOnScreen) &amp;&amp; (lastHighestResolutionGPSDestScale &gt; 0)) {
 					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 				} else {
-					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
+					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO
+																					// use
+																					// home-coos
+																					// if
+																					// no
+																					// gps?
+																					// -
+																					// consider
+																					// start
+																					// from
+																					// details
+																					// panel
+																					// and
+																					// from
+																					// gotopanel
 					if (newmap == null)
-						newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false, true); // use map with most available overview if no map containing PosCircle and GotoPos is available
+						newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false, true); // use
+																													// map
+																													// with
+																													// most
+																													// available
+																													// overview
+																													// if
+																													// no
+																													// map
+																													// containing
+																													// PosCircle
+																													// and
+																													// GotoPos
+																													// is
+																													// available
 
 					if (newmap != null) {
 						lastHighestResolutionGPSDestScale = newmap.scale;
@@ -1525,13 +1705,29 @@
 		}
 		if (currentMap == null &amp;&amp; newmap == null) {
 			// F?r die aktuelle Position steht keine Karte zur Verf?ng
-			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
+			posCircle.where.set(cll); // choosemap calls setmap with
+										// posCircle-coos
 			try {
-				setMap(((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+				setMap(((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware:
+																								// &quot;-4&quot;
+																								// only
+																								// works
+																								// if
+																								// the
+																								// empty
+																								// maps
+																								// were
+																								// added
+																								// last
+																								// see
+																								// MapsList.addEmptyMaps
 			} catch (final IOException e) {
 				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec();
 			}
-			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
+			while (currentMap == null) { // this actually cannot happen,
+											// but maybe in case of an
+											// inconstistent code change
+											// (esp. regarding empty maps)
 				mmp.chooseMap(); // force the user to select a scale
 				if (currentMap == null)
 					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
@@ -1553,17 +1749,28 @@
 
 	/**
 	 * method to get a point on the screen which must be included in the map
-	 * the map methods are looking for. If the poscircle is on the screen this will be
-	 * that point. If it is outside then the centre of the screen will be used.
+	 * the map methods are looking for. If the poscircle is on the screen
+	 * this will be that point. If it is outside then the centre of the
+	 * screen will be used.
 	 * 
-	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen
+	 * around it
 	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
 	 */
 	public Object[] getRectForMapChange(CWPoint ll) {
-		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
 		final int h = (height != 0 ? height : pref.myAppHeight);
 		int pX, pY;
 		CWPoint cll;
@@ -1571,10 +1778,16 @@
 		if (posCircleX &gt;= 0 &amp;&amp; posCircleX &lt;= w &amp;&amp; posCircleY &gt;= 0 &amp;&amp; posCircleY &lt;= h &amp;&amp; ll.isValid()) {
 			posCircleOnScreen = java.lang.Boolean.TRUE;
 			pX = posCircleX; // posCircle is inside the screen
-			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn vorher PosCircle nicht auf dem
-								// SChirm war, nach dem ersten Laden aber schon.
+			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem
+								// evtl. Kartenwechsel PosCircle on Screen
+								// ist. So wie es jetzt ist, kann 2mal der
+								// gleiche Aufruf zum laden
+								// unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn
+								// vorher PosCircle nicht auf dem
+			// SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
-		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
+		} else { // when posCircle out of screen - use centre of screen
+					// as point which as to be included in the map
 			cll = ScreenXY2LatLon(w / 2, h / 2);
 			pX = w / 2;
 			pY = h / 2;
@@ -1593,7 +1806,16 @@
 	 * @return
 	 */
 	public void loadMoreDetailedMap(boolean betterOverview) {
-		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
 		final int h = (height != 0 ? height : pref.myAppHeight);
 		final Rect screen = new Rect(w / 2, h / 2, w, h);
 
@@ -1625,20 +1847,50 @@
 			return;
 		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.bottomright);
-		if (newmap == null) { // no map that includs all caches is available -&gt; load map with lowest resolution
+		if (newmap == null) { // no map that includs all caches is
+								// available -&gt; load map with lowest
+								// resolution
 			final Object[] s = getRectForMapChange(posCircle.where);
 			final CWPoint cll = (CWPoint) s[0];
 			final Rect screen = (Rect) s[1];
 			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE - 1, false, true);
 		}
-		if (newmap == null) { // no map is covering any area of the caches -&gt; zoom an empty map to cover all caches on screen
+		if (newmap == null) { // no map is covering any area of the caches
+								// -&gt; zoom an empty map to cover all caches
+								// on screen
 			try {
 				final Object[] s = getRectForMapChange(posCircle.where);
 				// CWPoint cll = (CWPoint) s[0];
 				final Rect screen = (Rect) s[1];
-				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width - 15)); // 15 for the size of the cache image
-				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height - 15)); // 15 for the size of the cache image
-				newmap = ((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width - 15)); // 15
+																																						// for
+																																						// the
+																																						// size
+																																						// of
+																																						// the
+																																						// cache
+																																						// image
+				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height - 15)); // 15
+																																						// for
+																																						// the
+																																						// size
+																																						// of
+																																						// the
+																																						// cache
+																																						// image
+				newmap = ((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(); // beware:
+																						// &quot;-4&quot;
+																						// only
+																						// works
+																						// if
+																						// the
+																						// empty
+																						// maps
+																						// were
+																						// added
+																						// last
+																						// see
+																						// MapsList.addEmptyMaps
 				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex &gt; neededscaley ? neededscalex : neededscaley), 0, 0);
 				forceMapLoad = true;
 			} catch (final IOException e) {
@@ -1654,7 +1906,8 @@
 
 	public void setGpsStatus(int status) {
 		if (status == GpsStatus)
-			return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+			return; // if ignoreGpsStatutsChanges == true than the Map is in
+					// manual-mode
 		GpsStatus = status;
 		dontUpdatePos = false;
 		ignoreGps = false;
@@ -1677,7 +1930,9 @@
 			break;
 		}
 		}
-		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
+		mapMoved(0, 0); // positions the posCircle correctly accourding to
+						// its size (which can change when the image
+						// changes, e.g. from null to something else
 		posCircle.refreshNow();
 	}
 
@@ -1685,7 +1940,10 @@
 		resetCenterOfMap();
 		dontUpdatePos = false;
 		ignoreGps = false;
-		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make
+											// updateposition to test if the
+											// current map is the best one
+											// for the GPS-Position
 		lastCompareY = Integer.MAX_VALUE;
 		autoSelectMap = true;
 		forceMapLoad = true;
@@ -1701,7 +1959,8 @@
 	 * 
 	 * @param newmap
 	 * @param lat
-	 *            move map so that lat/lon is in the centre / -361: don't adust to lat/lon
+	 *            move map so that lat/lon is in the centre / -361: don't
+	 *            adust to lat/lon
 	 * @param lon
 	 *            -361: don't adust to lat/lon
 	 */
@@ -1714,12 +1973,14 @@
 			Vm.showWait(true);
 			boolean saveIgnoreStatus;
 			saveIgnoreStatus = dontUpdatePos;
-			dontUpdatePos = true; // make updatePosition ignore calls during loading new map
+			dontUpdatePos = true; // make updatePosition ignore calls
+									// during loading new map
 			pref.log(MyLocale.getMsg(4216, &quot;Loading map...&quot;) + newmap.mapName);
 			try {
 				this.currentMap = newmap;
 				this.title = currentMap.mapName;
-				// neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+				// neccessary to make updateposition to test if the current
+				// map is the best one for the GPS-Position
 				lastCompareX = Integer.MAX_VALUE;
 				lastCompareY = Integer.MAX_VALUE;
 				if (mmp.mapImage != null) {
@@ -1730,7 +1991,8 @@
 					// calls the garbage collection
 					Vm.getUsedMemory(true);
 				}
-				// give memory free before loading the new map to avoid out of memory error
+				// give memory free before loading the new map to avoid out
+				// of memory error
 				final String ImageFilename = currentMap.getImageFilename();
 				if (ImageFilename == null) {
 					mmp.mapImage = new MapImage();
@@ -1739,10 +2001,15 @@
 				} else {
 					if (ImageFilename.length() &gt; 0) {
 						// attention: when running in native java-vm,
-						// no exception will be thrown, not even OutOfMemeoryError
+						// no exception will be thrown, not even
+						// OutOfMemeoryError
 						mmp.mapImage = new MapImage(ImageFilename);
 					} else
-						mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
+						mmp.mapImage = new MapImage(); // no image
+														// associated with
+														// the calibration
+														// info (&quot;empty
+														// map&quot;)
 				}
 				mapImage1to1 = mmp.mapImage;
 				mmp.mapImage.properties = mmp.mapImage.properties | mImage.IsMoveable;
@@ -1752,7 +2019,8 @@
 				mmp.addImage(mmp.mapImage);
 				mmp.images.moveToBack(mmp.mapImage);
 				rebuildOverlaySet();
-				forceMapLoad = true; // forces updateOnlyPosition to redraw
+				forceMapLoad = true; // forces updateOnlyPosition to
+										// redraw
 				updateAfterMapChange(where);
 				forceMapLoad = false;
 				directionArrows.setMap(currentMap);
@@ -1795,8 +2063,19 @@
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
-				updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to
-													// test: select a map with a much greater value of m per pixel manually
+				updateOnlyPosition(where, false); // TODO this doesn't
+													// work correctly if the
+													// resolution changed, I
+													// guess because the
+													// pixels of PosCircle
+													// will be interpreted
+													// from the new
+													// resolution, but
+													// should be interpreted
+													// using the old
+													// resolution to
+				// test: select a map with a much greater value of m per
+				// pixel manually
 				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;) + newmap.getImageFilename() + MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
 						FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
@@ -1812,7 +2091,16 @@
 		}
 		final Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
 		final Point centerOnMap = currentMap.calcMapXY(newCenter);
-		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
 		final int h = (height != 0 ? height : pref.myAppHeight);
 		final int mapPosX = w / 2 - centerOnMap.x;
 		final int mapPosY = h / 2 - centerOnMap.y;
@@ -1860,10 +2148,7 @@
 	}
 
 	/*
-	 * public void setZoomingMode() {
-	 * repaintNow();
-	 * zoomingMode = true;
-	 * }
+	 * public void setZoomingMode() { repaintNow(); zoomingMode = true; }
 	 */
 	/**
 	 * zommes in if w&gt;0 and out if w&lt;0
@@ -1873,8 +2158,24 @@
 	 * @param h
 	 */
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width * (this.width &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
-		int newImageHeight = (int) (this.height * (this.width &lt; 481 ? 2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
+		int newImageWidth = (int) (this.width * (this.width &lt; 481 ? 2 : 1.6)); // (maximal)
+																				// size
+																				// of
+																				// the
+																				// zoomed
+																				// image
+		int newImageHeight = (int) (this.height * (this.width &lt; 481 ? 2 : 1.6)); // dont
+																					// make
+																					// this
+																					// to
+																					// big,
+																					// otherwise
+																					// it
+																					// causes
+																					// out
+																					// of
+																					// memory
+																					// errors
 		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w / 2, firstclickpoint.y + h / 2);
 		float zoomFactor;
 		if (h &lt; 0) {
@@ -1885,10 +2186,15 @@
 			zoomFactor = java.lang.Math.min((float) this.width / (float) w, (float) this.height / (float) h);
 		} else { // zoom out
 			w = java.lang.Math.abs(w);
-			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+			firstclickpoint.x = firstclickpoint.x - w; // make
+														// firstclickedpoint
+														// the upper left
+														// corner
 			zoomFactor = java.lang.Math.max((float) w / (float) this.width, (float) h / (float) this.height);
 		}
-		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
+		// calculate rect in unzoomed image in a way that the centre of the
+		// new image is the centre of selected area but give priority to the
+		// prefered image size of the scaled image
 		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
 		final Point mappos = getMapPositionOnScreen();
@@ -1902,7 +2208,11 @@
 			if (newImageRect.y &lt; 0)
 				newImageRect.y = 0;
 			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
-				newImageRect.x = mapImage1to1.getWidth() - newImageWidth; // align right if right overlaping
+				newImageRect.x = mapImage1to1.getWidth() - newImageWidth; // align
+																			// right
+																			// if
+																			// right
+																			// overlaping
 			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
 				newImageRect.y = mapImage1to1.getHeight() - newImageHeight;
 			// crop if after shifting still overlapping
@@ -1952,7 +2262,8 @@
 	 * @param zoomFactor
 	 *            relative to original image
 	 * @param newImageRect
-	 *            Rect in the 1:1 image that contains the area to be zoomed into
+	 *            Rect in the 1:1 image that contains the area to be zoomed
+	 *            into
 	 * @param center
 	 */
 	public void zoomFromUnscaled(float zoomFactor, Rect newImageRect, CWPoint center) {
@@ -1984,7 +2295,8 @@
 				// tmp = mapImage1to1;
 			} // if (tmp != null) currentMap.zoom();}
 			Vm.getUsedMemory(true);
-			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage = tmp; // use unscaled or no image in case of
+								// OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
 			if (mapHidden)
 				mmp.mapImage.hide();
@@ -1998,7 +2310,8 @@
 		{
 			currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 		}
-		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
+		// scaleWanted = currentMap.scale; use this if you want to change
+		// automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
 		Vm.getUsedMemory(true); // call garbage collection
 		setCenterOfScreen(center, false);
@@ -2013,7 +2326,10 @@
 		if (ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED)) {
 			running = false;
 		}
-		if (ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; ((((KeyEvent) ev).key == IKeys.ESCAPE) || (((KeyEvent) ev).key == IKeys.ENTER) || (((KeyEvent) ev).key == IKeys.ACTION))) {
+		if (ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; //
+				((((KeyEvent) ev).key == IKeys.ESCAPE) || //
+						(((KeyEvent) ev).key == IKeys.ENTER) || //
+				(((KeyEvent) ev).key == IKeys.ACTION))) {
 			this.close(0);
 			ev.consumed = true;
 		}
@@ -2174,7 +2490,8 @@
 		for (int i = 0; i &lt; SkyOrientation.LUMINARY_NAMES.length; i++) {
 			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
 		}
-		set(ControlConstants.WantHoldDown, true); // want to get simulated right-clicks
+		set(ControlConstants.WantHoldDown, true); // want to get simulated
+													// right-clicks
 	}
 
 	public boolean imageBeginDragged(AniImage which, Point pos) {
@@ -2188,7 +2505,8 @@
 			return false;
 		}
 		// move (drag) map
-		// if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		// if (!(which == null || which == mapImage || which instanceof
+		// TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.dontUpdatePos;
 		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
@@ -2213,7 +2531,8 @@
 
 	public void onPenEvent(PenEvent ev) {
 		if (ignoreNextDrag) {
-			// On PDA next event after a Kontext ist a drag, that will move the map unwanted
+			// On PDA next event after a Kontext ist a drag, that will move
+			// the map unwanted
 			ignoreNextDrag = false;
 			if (ev.type == PenEvent.PEN_DRAG)
 				return; // ignoring now
@@ -2228,7 +2547,8 @@
 			} else {
 				saveMapLoc = new Point(ev.x, ev.y);
 				if (ev.modifiers == PenEvent.RIGHT_BUTTON) {
-					// context penHeld is fired directly on PDA (cause WantHoldDown Control Modifier)
+					// context penHeld is fired directly on PDA (cause
+					// WantHoldDown Control Modifier)
 					// but not on PC (Java) , therefor it is here
 					penHeld(new Point(ev.x, ev.y));
 				} else {
@@ -2246,7 +2566,8 @@
 					mm.dontUpdatePos = saveGpsIgnoreStatus;
 					if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15) {
 						repaintNow();
-						return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+						return; // dont make to big zoom jumps - it is most
+								// probable not an intentional zoom
 					}
 					mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 				}
@@ -2279,7 +2600,13 @@
 					else
 						top = saveMapLoc.y;
 					dr.setPen(new Pen(new Color(255, 0, 0), Pen.SOLID, 3));
-					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
+					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug
+																														// in
+																														// ewe:
+																														// thickness
+																														// parameter
+																														// is
+																														// ignored
 				}
 			}
 		}
@@ -2309,7 +2636,9 @@
 		if (mapImage != null) {
 			p = mapImage.locAlways;
 			mapImage.move(p.x + diffX, p.y + diffY);
-			// if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+			// if (mm.mapHidden) mapImage.properties |=
+			// AniImage.IsInvisible; // this is neccesarry because move will
+			// unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
@@ -2346,13 +2675,22 @@
 				mm.ignoreGps = true;
 				mm.setMap(l.selectedMap, mm.posCircle.where);
 				if (mm.currentMap.fileNameWFL.length() &gt; 0)
-					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if
+																		// map
+																		// has
+																		// an
+																		// image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				// Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				// double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
-				// mm.posCircleX = 0; // place map to the upper left corner of windows
+				// Point posCXY = new Point (0,0);
+				// mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				// double lat = mm.currentMap.affine[0]*posCXY.x +
+				// mm.currentMap.affine[2]*posCXY.y +
+				// mm.currentMap.affine[4];
+				// mm.posCircleX = 0; // place map to the upper left corner
+				// of windows
 				// mm.posCircleY = 0;
-				// mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+				// mm.updateOnlyPosition(mm.currentMap.affine[4],
+				// mm.currentMap.affine[5], true);
 			}
 		}
 	}
@@ -2377,7 +2715,8 @@
 			if (clickedOnImage != null &amp;&amp; clickedOnImage instanceof MapSymbol) {
 				if (((MapSymbol) clickedOnImage).mapObject instanceof CacheHolder) {
 					clickedCache = (CacheHolder) (((MapSymbol) clickedOnImage).mapObject);
-					// clickedCache == null can happen if clicked on the goto-symbol
+					// clickedCache == null can happen if clicked on the
+					// goto-symbol
 					if (clickedCache != null) {
 						CacheHolder ch = clickedCache;
 						if (clickedCache.isAddiWpt()) {
@@ -2436,17 +2775,15 @@
 				}
 			}
 			/*
-			 * this kontext will be replaced by the settings of the rose in the goto panel
+			 * this kontext will be replaced by the settings of the rose in
+			 * the goto panel
 			 * 
-			 * if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
-			 * }
-			 * else {
+			 * if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) { } else {
 			 * for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
-			 * kontextMenu.addItem(miLuminary[i]);
-			 * if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-			 * else miLuminary[i].modifiers &amp;= MenuItem.Checked;
-			 * }
-			 * }
+			 * kontextMenu.addItem(miLuminary[i]); if (i ==
+			 * mm.myNavigation.luminary) miLuminary[i].modifiers |=
+			 * MenuItem.Checked; else miLuminary[i].modifiers &amp;=
+			 * MenuItem.Checked; } }
 			 */
 			onlyIfCache = false;
 			if (kontextMenu.items.size() &gt; 0) {
@@ -2542,14 +2879,12 @@
 						(new MessageBox(&quot;Mission&quot;, STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription, &quot;&lt;br&gt;&quot;, &quot;\n&quot;), FormBase.OKB)).execute();
 					}
 					/*
-					 * for (int i=0; i&lt;miLuminary.length; i++) {
-					 * if (action == miLuminary[i]) {
-					 * kontextMenu.close();
+					 * for (int i=0; i&lt;miLuminary.length; i++) { if (action ==
+					 * miLuminary[i]) { kontextMenu.close();
 					 * mm.myNavigation.setLuminary(i);
 					 * mm.updateGps(mm.myNavigation.gpsPos.getFix());
-					 * miLuminary[i].modifiers |= MenuItem.Checked;
-					 * } else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
-					 * }
+					 * miLuminary[i].modifiers |= MenuItem.Checked; } else
+					 * miLuminary[i].modifiers &amp;= ~MenuItem.Checked; }
 					 */
 				}
 			} // if (ev.target == kontextMenu)
@@ -2589,8 +2924,10 @@
 
 	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap) {
 		this.title = MyLocale.getMsg(4271, &quot;Maps&quot;);
-		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
-		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100);
+		// else
+		// set width to screenwidth *3/4 but to at least 240 if the screen
+		// is big engough for 240px width
 		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth() * 3 / 4, java.lang.Math.min(240, MyLocale.getScreenWidth())), MyLocale.getScreenHeight() * 3 / 4);
 		this.maps = maps;
 		MapInfoObject map;
@@ -2737,7 +3074,15 @@
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okButton || ev.target == list) { // ev.target == list is posted by mList if a selection was double clicked
+			if (ev.target == okButton || ev.target == list) { // ev.target
+																// == list
+																// is posted
+																// by mList
+																// if a
+																// selection
+																// was
+																// double
+																// clicked
 				mapSelected();
 			}
 		}
@@ -2796,7 +3141,11 @@
 	}
 
 	public void setDirections(float gd, float sd, float md) {
-		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage
+													// only update if the is
+													// a change of
+													// directions of more
+													// than 1 degree
 				|| java.lang.Math.abs(sunDir - sd) &gt; 1 || java.lang.Math.abs(moveDir - md) &gt; 1) {
 			// dirsChanged = false;
 			gotoDir = gd;
@@ -2824,16 +3173,14 @@
 		return;
 		/*
 		 * if (!dirsChanged) {
-		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
-		 * return;
-		 * }
-		 * dirsChanged = false;
-		 * //super.doDraw(g, options);
-		 * draw.setColor(Color.White);
-		 * draw.fillRect(0, 0, location.width, location.height);
-		 * minY = Integer.MAX_VALUE;
-		 * drawArrows(draw);
-		 * draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); //
+		 * the transparency with a transparent color doesn't work in ewe-vm
+		 * for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 return; }
+		 * dirsChanged = false; //super.doDraw(g, options);
+		 * draw.setColor(Color.White); draw.fillRect(0, 0, location.width,
+		 * location.height); minY = Integer.MAX_VALUE; drawArrows(draw);
+		 * draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); //
+		 * this trick (note: wrong transparentColor) forces a redraw
 		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
 		 */}
 
@@ -2857,7 +3204,21 @@
 			makeArrow(sunDirArrow, sunDir, 0.75f);
 		} else
 			sunDirArrow = null;
-		if (map != null &amp;&amp; java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI) { // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+		if (map != null &amp;&amp; java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI) { // show
+																									// northth
+																									// arrow
+																									// only
+																									// if
+																									// it
+																									// has
+																									// more
+																									// than
+																									// 1.5
+																									// degree
+																									// deviation
+																									// from
+																									// vertical
+																									// direction
 			if (northDirArrow == null)
 				northDirArrow = new Point[2];
 			makeArrow(northDirArrow, 0, 1.0f); // north direction


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003017.html">[Cachewolf-svn] r3026 - trunk/res_noewe/webmapservices
</A></li>
	<LI>Next message: <A HREF="003019.html">[Cachewolf-svn] r3028 - in trunk/src/CacheWolf: . exp imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3018">[ date ]</a>
              <a href="thread.html#3018">[ thread ]</a>
              <a href="subject.html#3018">[ subject ]</a>
              <a href="author.html#3018">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
