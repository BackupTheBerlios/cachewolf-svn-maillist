<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3028 - in trunk/src/CacheWolf: . exp imp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-June/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3028%20-%20in%20trunk/src/CacheWolf%3A%20.%20exp%20imp&In-Reply-To=%3C20110616203547.CF157481297%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003018.html">
   <LINK REL="Next"  HREF="003020.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3028 - in trunk/src/CacheWolf: . exp imp</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3028%20-%20in%20trunk/src/CacheWolf%3A%20.%20exp%20imp&In-Reply-To=%3C20110616203547.CF157481297%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3028 - in trunk/src/CacheWolf: . exp imp">araber95 at mail.berlios.de
       </A><BR>
    <I>Thu Jun 16 10:35:47 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003018.html">[Cachewolf-svn] r3027 - in trunk/src/CacheWolf: . imp navi
</A></li>
        <LI>Next message: <A HREF="003020.html">[Cachewolf-svn] r3029 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3019">[ date ]</a>
              <a href="thread.html#3019">[ thread ]</a>
              <a href="subject.html#3019">[ subject ]</a>
              <a href="author.html#3019">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-06-16 22:35:47 +0200 (Thu, 16 Jun 2011)
New Revision: 3028

Modified:
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/exp/GpxExportNg.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
1. test for gpx-Export to POI to see if the exe works(and the jar)
2. correct import from gc if picture url redirect sets cookie
3. use big Icons setup in preferences

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-06-15 20:53:01 UTC (rev 3027)
+++ trunk/src/CacheWolf/Preferences.java	2011-06-16 20:35:47 UTC (rev 3028)
@@ -58,9 +58,8 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
- * A class to hold the preferences that were loaded upon start up of
- * CacheWolf. This class is also capable of parsing the prefs.xml file as
- * well as saving the current settings of preferences.
+ * A class to hold the preferences that were loaded upon start up of CacheWolf. This class is also capable of parsing
+ * the prefs.xml file as well as saving the current settings of preferences.
  */
 public class Preferences extends MinML {
 
@@ -71,7 +70,7 @@
 	public static final int GPSD_DISABLED = 0; // do not use gpsd
 	public static final int GPSD_FORMAT_OLD = 1; // use old protocol
 	public static final int GPSD_FORMAT_NEW = 2; // use new protocol
-													// (JSON)
+	// (JSON)
 	public static final int YES = 0;
 	public static final int NO = 1;
 	public static final int ASK = 2;
@@ -106,8 +105,8 @@
 
 	/**
 	 * Call this method to set the path of the config file &lt;br&gt;
-	 * If you call it with null it defaults to [program-dir]/pref.xml if p
-	 * is a directory &quot;pref.xml&quot; will automatically appended
+	 * If you call it with null it defaults to [program-dir]/pref.xml if p is a directory &quot;pref.xml&quot; will automatically
+	 * appended
 	 * 
 	 * @param p
 	 */
@@ -115,10 +114,9 @@
 		String p_;
 		if (p == null) {
 			/*
-			 * String test; test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;); // returns in
-			 * java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application
-			 * data&gt; log(&quot;Vm.getenv(APPDATA: &quot; + test); // this works also
-			 * in win32.exe (ewe-vm on win xp) test = Vm.getenv(&quot;HOME&quot;,
+			 * String test; test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;);
+			 * // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt; log(&quot;Vm.getenv(APPDATA: &quot; + test);
+			 * // this works also in win32.exe (ewe-vm on win xp) test = Vm.getenv(&quot;HOME&quot;,
 			 * &quot;/&quot;); // This should return on *nix system the home dir
 			 * log(&quot;Vm.getenv(HOME: &quot; + test); test =
 			 * System.getProperty(&quot;user.dir&quot;); // return in java-vm on win
@@ -139,16 +137,8 @@
 			else
 				p_ = p;
 		}
-		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is
-																// necessary
-																// in case
-																// that the
-																// root dir
-																// is the
-																// dir where
-																// the
-																// pref.xml
-																// is stored
+		// this is necessary in case that the root dir is the dir where the pref.xml is stored
+		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;);
 		pathToConfigFile = pathToConfigFile.replace('\\', '/');
 		p = System.getProperty(&quot;os.name&quot;);
 		if (p == null || p.indexOf(&quot;indows&quot;) != -1) {
@@ -189,8 +179,7 @@
 	/** Name of last used profile */
 	public String lastProfile = &quot;&quot;;
 	/**
-	 * If true, the last profile is reloaded automatically without a
-	 * dialogue
+	 * If true, the last profile is reloaded automatically without a dialogue
 	 */
 	public boolean autoReloadLastProfile = false;
 	/** If true current cetre will be set from gps position */
@@ -200,8 +189,7 @@
 	/** Optional password */
 	public String password = &quot;&quot;;
 	/**
-	 * This is an alternative alias used to identify found caches (i.e. if
-	 * using multiple IDs)
+	 * This is an alternative alias used to identify found caches (i.e. if using multiple IDs)
 	 */
 	public String myAlias2 = &quot;&quot;;
 	/** The path to the browser */
@@ -241,9 +229,8 @@
 	public boolean showStatus = true;
 	// public boolean noTabs=false;
 	/**
-	 * True if the application can be closed by clicking on the close button
-	 * in the top line. This can be set to avoid accidental closing of the
-	 * application
+	 * True if the application can be closed by clicking on the close button in the top line. This can be set to avoid
+	 * accidental closing of the application
 	 */
 	public boolean hasCloseButton = true;
 	/** True if the SIP is always visible */
@@ -253,22 +240,19 @@
 	/** The widths for each column in list view */
 	public String listColWidth = &quot;15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30&quot;;
 	/**
-	 * The columns which are to be displayed in TravelbugsJourneyScreen. See
-	 * also TravelbugJourney
+	 * The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney
 	 */
 	public String travelbugColMap = &quot;1,4,5,6,8,9,10,7&quot;;
 	/** The column widths for the travelbug journeys. */
 	public String travelbugColWidth = &quot;212,136,62,90,50,56,90,38,50,50,94,50&quot;;
 	/**
-	 * If this flag is true, only non-logged travelbug journeys will be
-	 * shown
+	 * If this flag is true, only non-logged travelbug journeys will be shown
 	 */
 	public boolean travelbugShowOnlyNonLogged = false;
 	/** If this is true, deleted images are shown with a ? in the imagepanel */
 	public boolean showDeletedImages = true;
 	/**
-	 * This setting determines how many logs are shown per page of hintlogs
-	 * (default 5)
+	 * This setting determines how many logs are shown per page of hintlogs (default 5)
 	 */
 	public int logsPerPage = DEFAULT_LOGS_PER_PAGE;
 	/** Initial height of hints field (set to 0 to hide them initially) */
@@ -278,8 +262,7 @@
 	/** True if the Solver should ignore the case of variables */
 	public boolean solverIgnoreCase = true;
 	/**
-	 * True if the solver expects arguments for trigonometric functions in
-	 * degrees
+	 * True if the solver expects arguments for trigonometric functions in degrees
 	 */
 	public boolean solverDegMode = true;
 	/** True if the description panel should show images */
@@ -289,16 +272,14 @@
 	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
 	public String garminGPSBabelOptions = &quot;&quot;;
 	/**
-	 * Max. length for Garmin waypoint names (for etrex which can only
-	 * accept 6 chars)
+	 * Max. length for Garmin waypoint names (for etrex which can only accept 6 chars)
 	 */
 	public int garminMaxLen = 0;
 	/** OC true = alle neu Laden false = wenn &#196;nderungsdatum neuer */
 	public boolean downloadAllOC = false;
 	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
 	/**
-	 * The currently used centre point, can be different from the profile's
-	 * centrepoint. This is used for spidering
+	 * The currently used centre point, can be different from the profile's centrepoint. This is used for spidering
 	 */
 	private CWPoint curCentrePt = new CWPoint();
 	/** True if a login screen is displayed on each spider operation */
@@ -310,8 +291,7 @@
 	/** Number of CacheHolder details that are kept in memory */
 	public int maxDetails = 50;
 	/**
-	 * Number of details to delete when maxDetails have been stored in
-	 * cachesWithLoadedDetails
+	 * Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails
 	 */
 	public int deleteDetails = 5;
 	/** The locale code (DE, EN, ...) */
@@ -380,8 +360,7 @@
 
 	// ////////////////////////////////////////////
 	/**
-	 * The debug switch (Can be used to activate dormant code) by adding the
-	 * line:
+	 * The debug switch (Can be used to activate dormant code) by adding the line:
 	 * 
 	 * &lt;pre&gt;
 	 * &lt;debug value=&quot;true&quot; /&gt;
@@ -393,10 +372,9 @@
 	// ////////////////////////////////////////////
 
 	/**
-	 * This switches the behaviour of GUI-Element factories. If set to true,
-	 * it will construct alternative Forms. It can only be set in the
-	 * Preference-File directly, not by user-interaction now. Add &lt;MobileGui
-	 * value=&quot;true&quot;/&gt; to your pref.xml
+	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms. It can
+	 * only be set in the Preference-File directly, not by user-interaction now. Add &lt;MobileGui value=&quot;true&quot;/&gt; to your
+	 * pref.xml
 	 */
 	public boolean mobileGUI = false;
 
@@ -418,9 +396,8 @@
 	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
-	 * Method to open and parse the config file (pref.xml). Results are
-	 * stored in the public variables of this class. If you want to specify
-	 * a non default config file call setPathToConfigFile() first.
+	 * Method to open and parse the config file (pref.xml). Results are stored in the public variables of this class. If
+	 * you want to specify a non default config file call setPathToConfigFile() first.
 	 */
 	public void readPrefFile() {
 		if (pathToConfigFile == null)
@@ -439,7 +416,6 @@
 			else
 				log(&quot;Error reading pref.xml: &quot;, e);
 		}
-		useBigIcons = MyLocale.getScreenWidth() &gt;= 400; // &amp;&amp; Vm.isMobile()
 		isBigScreen = (MyLocale.getScreenWidth() &gt;= 400) &amp;&amp; (MyLocale.getScreenHeight() &gt;= 600);
 	}
 
@@ -452,11 +428,8 @@
 		String pf = Vm.getPlatform();
 		String testlist[] = null;
 		if (pf.equals(&quot;Java&quot;) || pf.equals(&quot;Win32&quot;)) {
-			String progdir = Vm.getenv(&quot;ProgramFiles&quot;, null); // at least
-																// in
-																// java-Win
-																// XP this
-																// is set
+			// at least in java-Win XP this is set
+			String progdir = Vm.getenv(&quot;ProgramFiles&quot;, null);
 			String homedir = Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
 			if (progdir != null) {
 				String test[] = { homedir + &quot;/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe&quot;, progdir + &quot;/Firefox/firefox.exe&quot;, progdir + &quot;/Opera/opera.exe&quot;, progdir + &quot;/Internet Explorer/iexplore.exe&quot; };
@@ -483,8 +456,8 @@
 
 	/** Helper variables for XML parser */
 	private StringBuffer collectElement = null;
-	private String lastName; // The string to the last XML that was
-								// processed
+	// The string to the last XML that was processed
+	private String lastName;
 
 	private long getLongAttr(AttributeList atts, String name) {
 		String stmp = atts.getValue(name);
@@ -496,8 +469,7 @@
 	}
 
 	/**
-	 * Method that gets called when a new element has been identified in
-	 * pref.xml
+	 * Method that gets called when a new element has been identified in pref.xml
 	 */
 	public void startElement(String name, AttributeList atts) {
 		lastName = name;
@@ -596,6 +568,11 @@
 				myAppHeight = Convert.toInt(atts.getValue(&quot;h&quot;));
 				myAppWidth = Convert.toInt(atts.getValue(&quot;w&quot;));
 			}
+			if (atts.getValue(&quot;useBigIcons&quot;) != null)
+				useBigIcons = Boolean.valueOf(atts.getValue(&quot;useBigIcons&quot;)).booleanValue();
+			else {
+				useBigIcons = MyLocale.getScreenWidth() &gt;= 400 &amp;&amp; Vm.isMobile();
+			}
 		} else if (name.equals(&quot;hintlogpanel&quot;)) {
 			logsPerPage = Convert.parseInt(atts.getValue(&quot;logsperpage&quot;));
 			String strInitialHintHeight = atts.getValue(&quot;initialhintheight&quot;);
@@ -747,15 +724,13 @@
 
 	public void characters(char ch[], int start, int length) {
 		if (collectElement != null) {
-			collectElement.append(ch, start, length); // Collect the name
-														// of the last
-														// profile
+			// Collect the name of the last profile
+			collectElement.append(ch, start, length);
 		}
 	}
 
 	/**
-	 * Method that gets called when the end of an element has been
-	 * identified in pref.xml
+	 * Method that gets called when the end of an element has been identified in pref.xml
 	 */
 	public void endElement(String tag) {
 		if (tag.equals(&quot;lastprofile&quot;)) {
@@ -845,6 +820,7 @@
 					+ &quot; hasclosebutton=\&quot;&quot; + hasCloseButton + &quot;\&quot;&quot; //
 					+ &quot; h=\&quot;&quot; + myAppHeight + &quot;\&quot;&quot; //
 					+ &quot; w=\&quot;&quot; + myAppWidth + &quot;\&quot;&quot; //
+					+ &quot; useBigIcons=\&quot;&quot; + useBigIcons + &quot;\&quot;&quot; //
 					+ &quot;/&gt;\n&quot; //
 
 					+ &quot;    &lt;fixedsip state=\&quot;&quot; + SafeXML.strxmlencode(fixSIP) + &quot;\&quot;/&gt;\n&quot; //
@@ -904,10 +880,8 @@
 				outp.print(this.getFilter(filterIDs[i]).toXML(filterIDs[i]));
 			}
 			if (debug)
-				outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the
-																// debug
-																// switch if
-																// it is set
+				// Keep the debug switch if it is set
+				outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;);
 			// save last path of different exporters
 			Iterator itPath = exporterPaths.entries();
 			MapEntry entry;
@@ -928,13 +902,8 @@
 			outp.print(&quot;    &lt;SortingGroupedByCache on=\&quot;&quot; + SafeXML.strxmlencode(SortingGroupedByCache) + &quot;\&quot;/&gt;\n&quot;);
 			outp.print(&quot;    &lt;Symbols useOwnSymbols=\&quot;&quot; + SafeXML.strxmlencode(useOwnSymbols) + &quot;\&quot;/&gt;\n&quot;);
 			if (mobileGUI)
-				outp.print(&quot;    &lt;MobileGui value=\&quot;true\&quot; /&gt;\n&quot;); // Keep
-																	// the
-																	// vmgui
-																	// switch
-																	// if it
-																	// is
-																	// set
+				// Keep the vmgui switch if it is set
+				outp.print(&quot;    &lt;MobileGui value=\&quot;true\&quot; /&gt;\n&quot;);
 			outp.print(&quot;&lt;/preferences&gt;&quot;);
 			outp.close();
 		} catch (Exception e) {
@@ -1004,11 +973,9 @@
 	}
 
 	/**
-	 * gets the path to the calibrated maps it first tries if there are
-	 * manually imported maps in &lt;baseDir&gt;/maps/standard then it tries the
-	 * legacy dir: &lt;program-dir&gt;/maps In case in both locations are no
-	 * .wfl-files it returns &lt;baseDir&gt;/maps/expedia - the place where the
-	 * automatically downloaded maps are placed.
+	 * gets the path to the calibrated maps it first tries if there are manually imported maps in
+	 * &lt;baseDir&gt;/maps/standard then it tries the legacy dir: &lt;program-dir&gt;/maps In case in both locations are no
+	 * .wfl-files it returns &lt;baseDir&gt;/maps/expedia - the place where the automatically downloaded maps are placed.
 	 * 
 	 * 
 	 */
@@ -1030,8 +997,8 @@
 			return absoluteBaseDir + mapsPath;
 		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_DIRECTORIES_ONLY | FileBase.LIST_ALWAYS_INCLUDE_DIRECTORIES);
 		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of
-											// &lt;baseDir&gt;/maps/standard are
-											// .wfl files
+			// &lt;baseDir&gt;/maps/standard are
+			// .wfl files
 			String[] f2;
 			for (int i = 0; i &lt; f.length; i++) {
 				t.set(null, ret + &quot;/&quot; + f[i]);
@@ -1079,15 +1046,14 @@
 	/**
 	 * @param create
 	 *            if true the directory if it doesn't exist will be created
-	 * @return the path where manually imported maps should be stored this
-	 *         should be adjustable in preferences...
+	 * @return the path where manually imported maps should be stored this should be adjustable in preferences...
 	 */
 	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = absoluteBaseDir + mapsPath;
 		if (create &amp;&amp; !(new FileBugfix(mapsDir).isDirectory())) { // dir
-																	// exists?
+			// exists?
 			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation
-															// failed?
+				// failed?
 				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + mapsDir, FormBase.OKB)).exec();
 				return null;
 			}
@@ -1102,9 +1068,8 @@
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().absoluteBaseDir.length()).replace('\\', '/');
 		String mapsDir = Global.getPref().absoluteBaseDir + &quot;maps/&quot; + Common.ClearForFileName(mapkind) + &quot;/&quot; + subdir;
 		if (!(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
-			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation
-															// failed?
-			{
+			if (new FileBugfix(mapsDir).mkdirs() == false) {
+				// dir creation failed?
 				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
 				return null;
 			}
@@ -1113,10 +1078,8 @@
 	}
 
 	public String getMapExpediaLoadPath() {
-		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps/expedia&quot;; // baseDir
-																						// has
-																						// trailing
-																						// /
+		// baseDir has trailing /
+		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps/expedia&quot;;
 	}
 
 	// ////////////////////////////////////////////////////////////////////////////////////
@@ -1128,31 +1091,26 @@
 	static protected final int PROFILE_SELECTOR_ONOROFF = 2;
 
 	/**
-	 * tries to get the home data dir of the user e.g. &quot;c:\documents and...\&lt;user&gt;\my
-	 * documents&quot; or &quot;/home/&lt;user&gt;&quot; in linux if none could be identified,
-	 * &quot;/&quot; is returned.
+	 * tries to get the home data dir of the user e.g. &quot;c:\documents and...\&lt;user&gt;\my documents&quot; or &quot;/home/&lt;user&gt;&quot; in
+	 * linux if none could be identified, &quot;/&quot; is returned.
 	 * 
 	 * @return
 	 */
 	public String getHomeDir() {
 		String test;
-		test = Vm.getenv(&quot;HOMEDRIVE&quot;, &quot;&quot;); // returns in java-vm on win xp:
-											// c:\&lt;dokumente und
-											// Einstellungen&gt;\&lt;username&gt;\&lt;application
-											// data&gt;
-		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in
-												// win32.exe (ewe-vm on win
-												// xp)
-		test += Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;); // returns in java-vm on win xp:
-											// c:\&lt;dokumente und
-											// Einstellungen&gt;\&lt;username&gt;\&lt;application
-											// data&gt;
-		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in
-												// win32.exe (ewe-vm on win
-												// xp)
+		// returns in java-vm on win xp:
+		// c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
+		test = Vm.getenv(&quot;HOMEDRIVE&quot;, &quot;&quot;);
+		log(&quot;[Preferences:getHomeDir]&quot; + test);
+		// this works also in win32.exe (ewe-vm on win xp)
+		test += Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
+		// returns in java-vm on win xp:
+		// c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
+		log(&quot;[Preferences:getHomeDir]&quot; + test);
+		// this works also in win32.exe (ewe-vm on win xp)
 		if (test.length() == 0)
-			test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;); // This should return on *nix
-											// system the home dir
+			// This should return on *nix system the home dir
+			test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;);
 		if (test.length() == 0)
 			test = &quot;/&quot;;
 		return test;
@@ -1183,10 +1141,10 @@
 		checkAbsoluteBaseDir();
 		boolean profileExists = true; // Assume that the profile exists
 		do {
-			if (!profileExists || (showProfileSelector == PROFILE_SELECTOR_FORCED_ON) || (showProfileSelector == PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)) { // Ask
-																																										// for
-																																										// the
-																																										// profile
+			if (!profileExists//
+					|| (showProfileSelector == PROFILE_SELECTOR_FORCED_ON)//
+					|| (showProfileSelector == PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)//
+			) {
 				ProfilesForm f = new ProfilesForm(absoluteBaseDir, lastProfile, !profileExists || hasNewButton ? 0 : 1);
 				int code = f.execute();
 				// If no profile chosen (includes a new one), terminate
@@ -1196,7 +1154,8 @@
 				prof.clearProfile();
 				prof.setCenterCoords(savecenter);
 				// prof.hasUnsavedChanges = true;
-				// curCentrePt.set(0,0); // No centre yet
+				// curCentrePt.set(0,0);
+				// No centre yet
 				lastProfile = f.newSelectedProfile;
 			}
 			profileExists = (new FileBugfix(absoluteBaseDir + lastProfile)).exists();
@@ -1280,9 +1239,8 @@
 	private final String LOGFILENAME = FileBase.getProgramDirectory() + &quot;/log.txt&quot;;
 
 	/**
-	 * Method to delete an existing log file. Called on every SpiderGC. The
-	 * log file is also cleared when Preferences is created and the filesize &gt;
-	 * 60KB
+	 * Method to delete an existing log file. Called on every SpiderGC. The log file is also cleared when Preferences is
+	 * created and the filesize &gt; 60KB
 	 */
 	public void logInit() {
 		File logFile = new FileBugfix(LOGFILENAME);
@@ -1299,9 +1257,8 @@
 	boolean forceLog = false;
 
 	/**
-	 * Method to log messages to a file called log.txt It will always append
-	 * to an existing file. To show the message on the console, the global
-	 * variable debug must be set. This can be done by adding
+	 * Method to log messages to a file called log.txt It will always append to an existing file. To show the message on
+	 * the console, the global variable debug must be set. This can be done by adding
 	 * 
 	 * &lt;pre&gt;
 	 * &lt;debug value=&quot;true&quot;&gt;
@@ -1347,12 +1304,9 @@
 	 * @param e
 	 *            The exception
 	 * @param withStackTrace
-	 *            If true and the debug switch is true, the stack trace is
-	 *            appended to the log The debug switch can be set by
-	 *            including the line &lt;i&gt;&lt;debug
-	 *            value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file
-	 *            or by manually setting it (i.e. in BE versions or RC
-	 *            versions) by including the line
+	 *            If true and the debug switch is true, the stack trace is appended to the log The debug switch can be
+	 *            set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file or by
+	 *            manually setting it (i.e. in BE versions or RC versions) by including the line
 	 * 
 	 * &lt;pre&gt;
 	 * Global.getPref().debug = true;
@@ -1374,9 +1328,8 @@
 	}
 
 	/**
-	 * Log an exception to the log file without a stack trace, i.e. where a
-	 * stack trace is not needed because the location/cause of the error is
-	 * clear
+	 * Log an exception to the log file without a stack trace, i.e. where a stack trace is not needed because the
+	 * location/cause of the error is clear
 	 * 
 	 * @param message
 	 *            Optional message (Can be empty string)
@@ -1428,8 +1381,8 @@
 	}
 
 	/**
-	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter
-	 * with the given ID is saved in the preferences.
+	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is saved in the
+	 * preferences.
 	 * 
 	 * @param filterID
 	 *            ID of the filter to check
@@ -1440,8 +1393,8 @@
 	}
 
 	/**
-	 * Returns the FilterData object saved with the given ID. The ID is not
-	 * saved in the object, so it may be resaved under another ID.
+	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, so it may be resaved
+	 * under another ID.
 	 * 
 	 * @param filterID
 	 *            ID of the FilterData object
@@ -1452,9 +1405,8 @@
 	}
 
 	/**
-	 * Adds a FilterData object to the list. If a FilterData object is
-	 * already saved unter the given ID, the old object is removed and the
-	 * new one is set at its place.
+	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the given ID, the old object
+	 * is removed and the new one is set at its place.
 	 * 
 	 * @param filterID
 	 *            ID to associate with the filter object
@@ -1466,8 +1418,8 @@
 	}
 
 	/**
-	 * Removed the FilterData object which is saved with the given ID. If no
-	 * such FilterData object exists, nothing happens.
+	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object exists, nothing
+	 * happens.
 	 * 
 	 * @param filterID
 	 *            ID of FilterData object to remove
@@ -1477,8 +1429,7 @@
 	}
 
 	/**
-	 * Returns a alphabetically sorted array of ID of saved FilterData
-	 * objects.
+	 * Returns a alphabetically sorted array of ID of saved FilterData objects.
 	 * 
 	 * @return Array of IDs
 	 */
@@ -1508,25 +1459,18 @@
 			p.waitFor();
 			gpsbabel = &quot;gpsbabel&quot;;
 		} catch (IOException ioex) {
-			// Most of the time there will be an exception, so don't
-			// complain
-		}
-		if (gpsbabel == null) {
 			try {
 				ewe.sys.Process p = Vm.exec(&quot;gpsbabel.exe -V&quot;);
 				p.waitFor();
 				gpsbabel = &quot;gpsbabel.exe&quot;;
-			} catch (IOException ioex) {
-				// Most of the time there will be an exception, so don't
-				// complain
+			} catch (IOException io_ex) {
 			}
 		}
 	}
 
 	/**
 	 * get directory where pref.xml is stored&lt;br&gt;
-	 * use this if you need a path where the user has sufficient rights to
-	 * create a file
+	 * use this if you need a path where the user has sufficient rights to create a file
 	 */
 	public String getPathToConfigFile() {
 		return pathToConfigFile;

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2011-06-15 20:53:01 UTC (rev 3027)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2011-06-16 20:35:47 UTC (rev 3028)
@@ -54,13 +54,14 @@
 import ewe.ui.mTabbedPanel;
 
 /**
- * This class displays a user interface allowing the user to change and set preferences. It also provides a method to save the changed preferences that are saved immediatly when the user presses &quot;Apply&quot;. Class ID=600
+ * This class displays a user interface allowing the user to change and set preferences. It also provides a method to
+ * save the changed preferences that are saved immediatly when the user presses &quot;Apply&quot;. Class ID=600
  */
 public class PreferencesScreen extends Form {
 	mButton cancelB, applyB, brwBt, gpsB;
 	mChoice inpLanguage, inpMetric, inpSpiderUpdates;
 	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, inpLogsPerPage, inpMaxLogsToSpider, inpPassword, inpGcMemberID, inpUserID;
-	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, chkSetCurrentCentreFromGPSPosition,
+	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkUseBigIcons, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, chkSetCurrentCentreFromGPSPosition,
 			chkSortingGroupedByCache, chkuseOwnSymbols, chkDebug, chkPM;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
@@ -183,7 +184,6 @@
 		frmScreen.addLast(pnlScreen, HSTRETCH, HFILL);
 
 		frmScreen.addLast(chkHasCloseButton = new mCheckBox(MyLocale.getMsg(631, &quot;PDA has close Button&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
-		// lblTitle.setTag(INSETS,new Insets(2,0,0,0));
 		chkHasCloseButton.setState(pref.hasCloseButton);
 		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626, &quot;Menu top&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkMenuAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
@@ -194,17 +194,21 @@
 		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628, &quot;Status&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkShowStatus.setState(pref.showStatus);
 		chkShowStatus.setTag(INSETS, new Insets(0, 0, 2, 0));
+		frmScreen.addLast(chkUseBigIcons = new mCheckBox(&quot;use big Icons&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkUseBigIcons.setState(pref.useBigIcons);
 		pnlDisplay.addLast(frmScreen, CellConstants.HSTRETCH, CellConstants.FILL);
 
 		Frame frmImages = new Frame();
 		frmImages.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_TOP | UIConstants.BF_BOTTOM;
-		// frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		// frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH,
+		// (CellConstants.DONTFILL|CellConstants.LEFT));
 		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624, &quot;Show deleted images&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkShowDeletedImg.setTag(INSETS, new Insets(2, 0, 0, 0));
 		if (pref.showDeletedImages)
 			chkShowDeletedImg.setState(true);
 		// mLabel dummy;
-		// frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
+		// frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH,
+		// (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
 		// dummy.setTag(INSETS,new Insets(0,0,2,0));
 		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638, &quot;Show pictures in description&quot;)), CellConstants.VSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT | CellConstants.NORTH));
 		chkDescShowImg.setTag(INSETS, new Insets(0, 0, 2, 0));
@@ -246,7 +250,8 @@
 		chkProxyActive.setState(pref.proxyActive);
 		pnlMore.addLast(pnlProxy, HSTRETCH, HFILL);
 		pnlMore.addNext(new mLabel(MyLocale.getMsg(592, &quot;Language (needs restart)&quot;)), DONTSTRETCH, DONTFILL | LEFT);
-		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory() + &quot;/languages&quot;).list(&quot;*.cfg&quot;, FileBase.LIST_FILES_ONLY)); // &quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		// &quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory() + &quot;/languages&quot;).list(&quot;*.cfg&quot;, FileBase.LIST_FILES_ONLY));
 		if (tmp == null)
 			tmp = new String[0];
 		String[] langs = new String[tmp.length + 1];
@@ -340,7 +345,8 @@
 				pref.myproxy = Proxy.getText();
 				pref.myproxyport = ProxyPort.getText();
 				pref.proxyActive = chkProxyActive.getState();
-				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
+				// TODO generate an error message if proxy port is not a number
+				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive);
 				pref.autoReloadLastProfile = chkAutoLoad.getState();
 				pref.isPremium = chkPM.getState();
 				pref.setCurrentCentreFromGPSPosition = chkSetCurrentCentreFromGPSPosition.getState();
@@ -351,6 +357,7 @@
 				pref.tabsAtTop = chkTabsAtTop.getState();
 				pref.showStatus = chkShowStatus.getState();
 				pref.hasCloseButton = chkHasCloseButton.getState();
+				pref.useBigIcons = chkUseBigIcons.getState();
 				pref.travelbugColMap = tccBugs.getSelectedCols();
 				pref.listColMap = tccList.getSelectedCols();
 				pref.descShowImg = chkDescShowImg.getState();

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-06-15 20:53:01 UTC (rev 3027)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-06-16 20:35:47 UTC (rev 3028)
@@ -77,6 +77,7 @@
 	private static void initPermanentRequestorProperty() {
 		permanentRequestorProperties = new PropertyList();
 		permanentRequestorProperties.add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+		// permanentRequestorProperties.add(&quot;Connection&quot;, &quot;close&quot;);
 		permanentRequestorProperties.add(&quot;Connection&quot;, &quot;keep-alive&quot;);
 	}
 
@@ -168,11 +169,20 @@
 			urltmp = conn.getRedirectTo();
 			if (urltmp != null) {
 				conn.disconnect();
+				// mainly implemented for opencaching.de ... login
 				final PropertyList pl = UrlFetcher.getDocumentProperties();
 				if (pl != null) {
 					String cookie = (String) pl.getValue(&quot;Set-Cookie&quot;, &quot;&quot;);
-					if (!cookie.equals(&quot;&quot;))
-						setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
+					if (cookie.length() &gt; 0) {
+						if (postData == null)
+							// do not overwrite existing cookie (mostly for geocaching.com)
+							// normally a cookie exists for a website
+							// we do not handle that correct
+							setRequestorProperty(&quot;Cookie&quot;, cookie);
+						else
+							// needed for opencaching.de ... login
+							setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
+					}
 				}
 				conn = conn.getRedirectedConnection(urltmp);
 				forceRedirect = false; // one time or more redirected
@@ -195,7 +205,8 @@
 
 	/**
 	 * @param url
-	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false otherwise
+	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false
+	 *         otherwise
 	 */
 	private static boolean isUrlEncoded(String url) {
 		final String allowed = new String(&quot;-_.~!*'();:@&amp;=+$,/?%#[]&quot;);
@@ -213,7 +224,8 @@
 
 	/**
 	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation&lt;br&gt;
-	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the server expects, what encoding you must use.
+	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the
+	 * server expects, what encoding you must use.
 	 * 
 	 * @param cc
 	 * @return
@@ -232,7 +244,8 @@
 	final static String hex = ewe.util.TextEncoder.hex;
 
 	/**
-	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all chars to be &lt; 127. This method is mainly copied from there
+	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all
+	 * chars to be &lt; 127. This method is mainly copied from there
 	 * 
 	 * @param url
 	 *            The unencoded URL.

Modified: trunk/src/CacheWolf/exp/GpxExportNg.java
===================================================================
--- trunk/src/CacheWolf/exp/GpxExportNg.java	2011-06-15 20:53:01 UTC (rev 3027)
+++ trunk/src/CacheWolf/exp/GpxExportNg.java	2011-06-16 20:35:47 UTC (rev 3028)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.Attribute;
@@ -85,12 +85,11 @@
 import ewe.util.zip.ZipFile;
 
 /**
- * experimental GPX exporter that should better handle the various tasks that
- * can be accomplished with GPX
+ * experimental GPX exporter that should better handle the various tasks that can be accomplished with GPX
  */
 public class GpxExportNg {
 	/** new line */
-	final static String newLine=&quot;\r\n&quot;;
+	final static String newLine = &quot;\r\n&quot;;
 	/** decimal separator for lat- and lon-String */
 	// final static char decimalSeparator='.';
 	/** export is in compact format */
@@ -119,7 +118,7 @@
 	final static String FALSE = &quot;False&quot;;
 	/** object used to determine custom symbols and POI categories */
 	private static GarminMap poiMapper = new GarminMap();
-	/** maximum number of logs to export. can be overwritten with preferences, default unlimited*/
+	/** maximum number of logs to export. can be overwritten with preferences, default unlimited */
 	private int maxLogs = ewe.math.Number.INTEGER_MAX_VALUE;
 	/** number of errors / warnings during export */
 	private int exportErrors = 0;
@@ -127,48 +126,48 @@
 	private String finderid;
 
 	// we need to fake desc to make clients like GSAK accept additional waypoints together with caches
-	final static String GPXHEADER = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;+(newLine)
-			+(&quot;&lt;gpx&quot;)
-			+(&quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot;&quot;)
-			+(&quot; xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot;&quot;)
-			+(&quot; version=\&quot;1.0\&quot;&quot;)
-			+(&quot; creator=\&quot;CacheWolf\&quot;&quot;)
-			+(&quot; xsi:schemaLocation=\&quot;&quot;)
-				+(&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> &quot;)
-				+(&quot;<A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> &quot;)
-				+(&quot;<A HREF="http://www.groundspeak.com/cache/1/0/1">http://www.groundspeak.com/cache/1/0/1</A> &quot;)
-				+(&quot;<A HREF="http://www.groundspeak.com/cache/1/0/1/cache.xsd">http://www.groundspeak.com/cache/1/0/1/cache.xsd</A>&quot;)
-			+(&quot;\&quot;&quot;)
-			+(&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&quot;)
-			+(&quot;&gt;&quot;)
-			+(newLine)
-			+(&quot;&lt;name&gt;@@NAME@@&lt;/name&gt;&quot;)+(newLine)
-			+(&quot;&lt;desc&gt;This is an individual cache generated from Geocaching.com&lt;/desc&gt;&quot;)+(newLine)
-			+(&quot;&lt;author&gt;Various users from geocaching.com and/or opencaching.de&lt;/author&gt;&quot;)+(newLine)
-			+(&quot;&lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">contact at cachewolf.de</A>&lt;/email&gt;&quot;)+(newLine)
-			+(&quot;&lt;url&gt;<A HREF="http://www.cachewolf.de/&lt;/url">http://www.cachewolf.de/&lt;/url</A>&gt;&quot;)+(newLine)
-			+(&quot;&lt;urlname&gt;CacheWolf - Paperless Geocaching&lt;/urlname&gt;&quot;)+(newLine)
-			+(&quot;&lt;time&gt;@@CREATEDATE@@T07:00:00Z&lt;/time&gt;&quot;)+(newLine)
-			+(&quot;&lt;keywords&gt;cache, geocache, waypoints&lt;/keywords&gt;&quot;)+(newLine)
+	final static String GPXHEADER = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot; + (newLine)//
+			+ (&quot;&lt;gpx&quot;)//
+			+ (&quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot;&quot;)//
+			+ (&quot; xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot;&quot;)//
+			+ (&quot; version=\&quot;1.0\&quot;&quot;)//
+			+ (&quot; creator=\&quot;CacheWolf\&quot;&quot;)//
+			+ (&quot; xsi:schemaLocation=\&quot;&quot;)//
+			+ (&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> &quot;)//
+			+ (&quot;<A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> &quot;)//
+			+ (&quot;<A HREF="http://www.groundspeak.com/cache/1/0/1">http://www.groundspeak.com/cache/1/0/1</A> &quot;)//
+			+ (&quot;<A HREF="http://www.groundspeak.com/cache/1/0/1/cache.xsd">http://www.groundspeak.com/cache/1/0/1/cache.xsd</A>&quot;)//
+			+ (&quot;\&quot;&quot;)//
+			+ (&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&quot;)//
+			+ (&quot;&gt;&quot;)//
+			+ (newLine)//
+			+ (&quot;&lt;name&gt;@@NAME@@&lt;/name&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;desc&gt;This is an individual cache generated from Geocaching.com&lt;/desc&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;author&gt;Various users from geocaching.com and/or opencaching.de&lt;/author&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">contact at cachewolf.de</A>&lt;/email&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;url&gt;<A HREF="http://www.cachewolf.de/&lt;/url">http://www.cachewolf.de/&lt;/url</A>&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;urlname&gt;CacheWolf - Paperless Geocaching&lt;/urlname&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;time&gt;@@CREATEDATE@@T07:00:00Z&lt;/time&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;keywords&gt;cache, geocache, waypoints&lt;/keywords&gt;&quot;) + (newLine)//
 	// TODO: is it worth a second loop?
 	// +(&quot;&lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot; maxlon=\&quot;6.918817\&quot; /&gt;&quot;)
 	;
 
-	final static String GPXLOG = &quot;\t\t\t\t&lt;groundspeak:log id=\&quot;@@LOGID@@\&quot;&gt;&quot;+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:date&gt;@@LOGDATE@@T00:00:00&lt;/groundspeak:date&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:type&gt;@@LOGTYPE@@&lt;/groundspeak:type&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:finder id=\&quot;@@LOGFINDERID@@\&quot;&gt;@@LOGFINDER@@&lt;/groundspeak:finder&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:text encoded=\&quot;@@LOGENCODE@@\&quot;&gt;@@LOGTEXT@@&lt;/groundspeak:text&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t&lt;/groundspeak:log&gt;&quot;)+(newLine);
+	final static String GPXLOG = &quot;\t\t\t\t&lt;groundspeak:log id=\&quot;@@LOGID@@\&quot;&gt;&quot; + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:date&gt;@@LOGDATE@@T00:00:00&lt;/groundspeak:date&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:type&gt;@@LOGTYPE@@&lt;/groundspeak:type&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:finder id=\&quot;@@LOGFINDERID@@\&quot;&gt;@@LOGFINDER@@&lt;/groundspeak:finder&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:text encoded=\&quot;@@LOGENCODE@@\&quot;&gt;@@LOGTEXT@@&lt;/groundspeak:text&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t&lt;/groundspeak:log&gt;&quot;) + (newLine);//
 
-	final static String GPXTB = &quot;\t\t\t\t&lt;groundspeak:travelbug id=\&quot;@@TBID@@\&quot; ref=\&quot;@@TBREF@@\&quot;&gt;&quot;+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:name&gt;@@TBNAME@@&lt;/groundspeak:name&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t&lt;/groundspeak:travelbug&gt;&quot;)+(newLine);
+	final static String GPXTB = &quot;\t\t\t\t&lt;groundspeak:travelbug id=\&quot;@@TBID@@\&quot; ref=\&quot;@@TBREF@@\&quot;&gt;&quot; + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:name&gt;@@TBNAME@@&lt;/groundspeak:name&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t&lt;/groundspeak:travelbug&gt;&quot;) + (newLine);//
 
 	// FIXME: don't use this until GPX import can strip this off as well
-	final static String GPXADDIINMAIN = &quot;@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@&quot;
-			+(&quot;@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@&quot;)
-			+(&quot;@@ADDILONG@@@@ADDIDELIM@@&quot;);
+	final static String GPXADDIINMAIN = &quot;@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@&quot;//
+			+ (&quot;@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@&quot;)//
+			+ (&quot;@@ADDILONG@@@@ADDIDELIM@@&quot;);//
 
 	private static boolean customIcons;
 	private static boolean sendToGarmin;
@@ -184,16 +183,18 @@
 	private static String bitmapFileName;
 
 	public GpxExportNg() {
-		bitmapFileName = FileBase.getProgramDirectory() + &quot;/exporticons/GarminPOI.zip&quot;; //own version
-		if (!(hasBitmaps=new File(bitmapFileName).exists())) {
-			bitmapFileName=FileBase.getProgramDirectory() + &quot;/exporticons/exporticons/GarminPOI.zip&quot;; //cw default version
-			hasBitmaps=new File(bitmapFileName).exists();			
+		bitmapFileName = FileBase.getProgramDirectory() + &quot;/exporticons/GarminPOI.zip&quot;; // own version
+		if (!(hasBitmaps = new File(bitmapFileName).exists())) {
+			// cw default version
+			bitmapFileName = FileBase.getProgramDirectory() + &quot;/exporticons/exporticons/GarminPOI.zip&quot;;
+			hasBitmaps = new File(bitmapFileName).exists();
 		}
 
 		hasGpsbabel = Global.getPref().gpsbabel != null;
 
 		finderid = Global.getPref().gcMemberId;
-		if (finderid.equals(&quot;&quot;)) Global.getPref().log(&quot;GPX Export: warning gcmemberid not set, check pref.xml&quot;,null);
+		if (finderid.equals(&quot;&quot;))
+			Global.getPref().log(&quot;GPX Export: warning gcmemberid not set, check pref.xml&quot;, null);
 	}
 
 	public void doit() {
@@ -224,11 +225,9 @@
 			ZipFile poiZip = null;
 
 			if (exportTarget == OUTPUT_POI) {
-				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,
-						Global.getPref().getExportPath(expName + &quot;-POI&quot;));
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getExportPath(expName + &quot;-POI&quot;));
 			} else {
-				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,
-						Global.getPref().getExportPath(expName + &quot;-GPI&quot;));
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getExportPath(expName + &quot;-GPI&quot;));
 			}
 
 			fc.setTitle(&quot;Select target directory:&quot;);
@@ -244,9 +243,8 @@
 			}
 
 			if (!poiMapper.exists) {
-				Global.getPref().log(&quot;GPX Export: unable to load garminmap.xml&quot;,null);
-				new MessageBox(&quot;Export Error&quot;, &quot;unable to load garminmap.xml&quot;,
-						FormBase.OKB).execute();
+				Global.getPref().log(&quot;GPX Export: unable to load garminmap.xml&quot;, null);
+				new MessageBox(&quot;Export Error&quot;, &quot;unable to load garminmap.xml&quot;, FormBase.OKB).execute();
 				return;
 			}
 
@@ -258,12 +256,12 @@
 				tempDir = outDir;
 				String tmp[] = new FileBugfix(tempDir).list(prefix + &quot;*.gpx&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 				for (int i = 0; i &lt; tmp.length; i++) {
-					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+					FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 					tmpFile.delete();
 				}
 				tmp = new FileBugfix(tempDir).list(prefix + &quot;*.bmp&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 				for (int i = 0; i &lt; tmp.length; i++) {
-					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+					FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 					tmpFile.delete();
 				}
 			}
@@ -286,30 +284,22 @@
 					if (!ch.isVisible()) {
 						continue;
 					} else if (ch.is_incomplete()) {
-						Global.getPref().log(
-								&quot;skipping export of incomplete waypoint &quot;
-								+ ch.getWayPoint(),null);
+						Global.getPref().log(&quot;skipping export of incomplete waypoint &quot; + ch.getWayPoint(), null);
 					} else {
 						String poiId = poiMapper.getPoiId(ch);
 						if (null == poiId) {
-							Global.getPref().log(
-									&quot;GPX Export: unmatched POI ID for &quot;
-									+ ch.getWayPoint() + &quot; of type &quot;
-									+ ch.getType(),null);
+							Global.getPref().log(&quot;GPX Export: unmatched POI ID for &quot; + ch.getWayPoint() + &quot; of type &quot; + ch.getType(), null);
 							exportErrors++;
 						} else {
 							PrintWriter writer;
 							if (fileHandles.containsKey(poiId)) {
 								writer = (PrintWriter) fileHandles.get(poiId);
 							} else {
-								writer = new PrintWriter(new BufferedWriter(
-										new FileWriter(new File(tempDir
-												+ FileBase.separator + prefix
-												+ poiId + &quot;.gpx&quot;))));
+								writer = new PrintWriter(new BufferedWriter(new FileWriter(new File(tempDir + FileBase.separator + prefix + poiId + &quot;.gpx&quot;))));
 								fileHandles.put(poiId, writer);
 								writer.print(formatHeader());
 							}
-							String strOut=formatCache(ch);
+							String strOut = formatCache(ch);
 							if (!strOut.equals(&quot;&quot;)) {
 								writer.print(strOut);
 							}
@@ -331,16 +321,15 @@
 				if (exportTarget == OUTPUT_POI) {
 					// only clean up output directory if user has chosen non empty prefix,
 					// since otherwise all present POI would be deleted
-					if (! prefix.equals(&quot;&quot;)) {
-						String tmp[] = new FileBugfix(outDir).list(
-								prefix + &quot;*.gpi&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+					if (!prefix.equals(&quot;&quot;)) {
+						String tmp[] = new FileBugfix(outDir).list(prefix + &quot;*.gpi&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 						for (int i = 0; i &lt; tmp.length; i++) {
 							FileBugfix tmpFile = new FileBugfix(outDir + FileBase.separator + tmp[i]);
 							tmpFile.delete();
 						}
 					}
 					pbf.exit(0);
-					poiCategories=fileHandles.size();
+					poiCategories = fileHandles.size();
 					pbf.setTask(h, &quot;Transfer&quot;);
 					pbf.exec();
 				}
@@ -351,7 +340,7 @@
 					String key = (String) keys.nextElement();
 					PrintWriter writer = (PrintWriter) fileHandles.get(key);
 
-					writer.print(&quot;&lt;/gpx&gt;&quot;+newLine);
+					writer.print(&quot;&lt;/gpx&gt;&quot; + newLine);
 					writer.close();
 					if (exportTarget == OUTPUT_POI) {
 						poiCounter++;
@@ -366,42 +355,35 @@
 
 						if (exportTarget == OUTPUT_POI) {
 							String[] cmdStack = new String[9];
-							cmdStack[0]=Global.getPref().gpsbabel;
-							cmdStack[1]=&quot;-i&quot;;
-							cmdStack[2]=&quot;gpx&quot;;
-							cmdStack[3]=&quot;-f&quot;;
-							cmdStack[4]=tempDir + FileBase.separator + prefix + key + &quot;.gpx&quot;;
-							cmdStack[5]=&quot;-o&quot;;
-							cmdStack[6]=&quot;garmin_gpi,sleep=1,category=&quot;+prefix + key+&quot;,bitmap=&quot;+tempDir + FileBase.separator + prefix + key	+ &quot;.bmp&quot;;
-							cmdStack[7]=&quot;-F&quot;;
-							cmdStack[8]=outDir + FileBase.separator + prefix + key + &quot;.gpi&quot;;
+							cmdStack[0] = Global.getPref().gpsbabel;
+							cmdStack[1] = &quot;-i&quot;;
+							cmdStack[2] = &quot;gpx&quot;;
+							cmdStack[3] = &quot;-f&quot;;
+							cmdStack[4] = tempDir + FileBase.separator + prefix + key + &quot;.gpx&quot;;
+							cmdStack[5] = &quot;-o&quot;;
+							cmdStack[6] = &quot;garmin_gpi,sleep=1,category=&quot; + prefix + key + &quot;,bitmap=&quot; + tempDir + FileBase.separator + prefix + key + &quot;.bmp&quot;;
+							cmdStack[7] = &quot;-F&quot;;
+							cmdStack[8] = outDir + FileBase.separator + prefix + key + &quot;.gpi&quot;;
 
-							Process babelProcess = startProcess(cmdStack);
+							Process babelProcess = null;
+							babelProcess = startProcess(cmdStack);
 							StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
-							while (errorStream.isOpen()) {
-								String errorMsg = errorStream.readALine();
-								if (errorMsg != null) {
-									Global.getPref().log(&quot;GPX Export: &quot; + errorMsg,null);
-									exportErrors++;
-								}
-								try {
-									babelProcess.exitValue();
-									errorStream.close();
-								} catch (IllegalThreadStateException e) {
-									// still running
-								}
+							babelProcess.waitFor();
+							String errorMsg = errorStream.readALine();
+							if (errorMsg != null) {
+								Global.getPref().log(&quot;GPX Export: &quot; + errorMsg, null);
+								exportErrors++;
 							}
+							errorStream.close();
 						}
-
 					}
 				}
 
 				if (exportTarget == OUTPUT_POI) {
 					FileBugfix tmpdir = new FileBugfix(tempDir);
-					String tmp[] = new FileBugfix(tempDir).list(prefix + &quot;*.*&quot;,
-							ewe.io.FileBase.LIST_FILES_ONLY);
+					String tmp[] = new FileBugfix(tempDir).list(prefix + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 					for (int i = 0; i &lt; tmp.length; i++) {
-						FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+						FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 						tmpFile.delete();
 					}
 					tmpdir.delete();
@@ -418,7 +400,7 @@
 			if (customIcons) {
 				if (!poiMapper.exists) {
 					customIcons = false;
-					Global.getPref().log(&quot;unable to load garminmap.xml&quot;,null);
+					Global.getPref().log(&quot;unable to load garminmap.xml&quot;, null);
 				}
 			}
 
@@ -433,8 +415,7 @@
 			final File file;
 
 			if (!sendToGarmin) {
-				final FileChooser fc = new FileChooser(FileChooserBase.SAVE,
-						Global.getPref().getExportPath(expName + &quot;-GPX&quot;));
+				final FileChooser fc = new FileChooser(FileChooserBase.SAVE, Global.getPref().getExportPath(expName + &quot;-GPX&quot;));
 
 				fc.setTitle(&quot;Select target GPX file:&quot;);
 				fc.addMask(&quot;*.gpx&quot;);
@@ -443,8 +424,7 @@
 					return;
 
 				file = fc.getChosenFile();
-				Global.getPref()
-						.setExportPath(expName + &quot;-GPX&quot;, file.getPath());
+				Global.getPref().setExportPath(expName + &quot;-GPX&quot;, file.getPath());
 			} else {
 				file = new File(&quot;&quot;).createTempFile(&quot;gpxexport&quot;, null, null);
 			}
@@ -459,12 +439,12 @@
 
 				outp.print(formatHeader());
 
-				//pbf.showMainTask = false;
-				//pbf.setTask(h, &quot;Exporting ...&quot;);
-				//pbf.exec();
-				//h.progressResolution=0;
+				// pbf.showMainTask = false;
+				// pbf.setTask(h, &quot;Exporting ...&quot;);
+				// pbf.exec();
+				// h.progressResolution=0;
 
-				Global.getPref().log(&quot;start: &quot;+new Time().getTime());
+				Global.getPref().log(&quot;start: &quot; + new Time().getTime());
 				CacheDB cDB = Global.getProfile().cacheDB;
 				for (int i = 0; i &lt; cDB.size(); i++) {
 					CacheHolder ch = cDB.get(i);
@@ -472,68 +452,60 @@
 						continue;
 					} else if (ch.is_incomplete()) {
 						exportErrors++;
-						Global.getPref().log(&quot;GPX Export: skipping export of incomplete waypoint &quot; + ch.getWayPoint(),null);
+						Global.getPref().log(&quot;GPX Export: skipping export of incomplete waypoint &quot; + ch.getWayPoint(), null);
 					} else {
-						String strOut=formatCache(ch);
+						String strOut = formatCache(ch);
 						if (!strOut.equals(&quot;&quot;)) {
 							outp.print(strOut);
 							expCount++;
 						}
 					}
-					
-					//h.progress = expCount / totalCount;
-					//h.changed();
-					
-					if (Global.mainTab.statBar!=null) Global.mainTab.statBar.updateDisplay(&quot; &quot;+((expCount * 100) / totalCount)+&quot;% &quot;);
+
+					// h.progress = expCount / totalCount;
+					// h.changed();
+
+					if (Global.mainTab.statBar != null)
+						Global.mainTab.statBar.updateDisplay(&quot; &quot; + ((expCount * 100) / totalCount) + &quot;% &quot;);
 				}
 
-				Global.getPref().log(&quot;stop: &quot;+new Time().getTime());
-				if (Global.mainTab.statBar!=null) Global.mainTab.statBar.updateDisplay(&quot;done:&quot;+expCount);
+				Global.getPref().log(&quot;stop: &quot; + new Time().getTime());
+				if (Global.mainTab.statBar != null)
+					Global.mainTab.statBar.updateDisplay(&quot;done:&quot; + expCount);
 				// pbf.exit(0);
 
-				outp.print(&quot;&lt;/gpx&gt;&quot;+newLine);
+				outp.print(&quot;&lt;/gpx&gt;&quot; + newLine);
 				outp.close();
 			} catch (Exception ex) {
 				exportErrors++;
 				Global.getPref().log(&quot;GPX Export: unable to write output to &quot; + file.toString(), ex, true);
-				new MessageBox(&quot;Export Error&quot;, &quot;unable to write output to &quot;	+ file.toString(), FormBase.OKB).execute();
+				new MessageBox(&quot;Export Error&quot;, &quot;unable to write output to &quot; + file.toString(), FormBase.OKB).execute();
 				return;
-			}
-			finally {
+			} finally {
 				Vm.showWait(false);
 			}
 
-
 			if (sendToGarmin) {
 				try {
 					String[] cmdStack = new String[9];
-					cmdStack[0]=Global.getPref().gpsbabel;
-					cmdStack[1]=&quot;-i&quot;;
-					cmdStack[2]=&quot;gpx&quot;;
-					cmdStack[3]=&quot;-f&quot;;
-					cmdStack[4]=file.getCreationName();
-					cmdStack[5]=&quot;-o&quot;;
-					cmdStack[6]=&quot;garmin&quot;;
-					cmdStack[7]=&quot;-F&quot;;
-					cmdStack[8]=Global.getPref().garminConn+(&quot;:&quot;);
-
-					Process babelProcess = this.startProcess(cmdStack);
-					if (babelProcess != null) {
-						StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
-						while (errorStream.isOpen()) {
-							String errorMsg = errorStream.readALine();
-							if (errorMsg != null) {
-								Global.getPref().log(&quot;[GPX Export:sendToGarmin] &quot; + errorMsg,null);
-								exportErrors++;
-							}
-							try {
-								babelProcess.exitValue();
-								errorStream.close();
-							} catch (IllegalThreadStateException e) {
-								// still running
-							}
-						}
+					cmdStack[0] = Global.getPref().gpsbabel;
+					cmdStack[1] = &quot;-i&quot;;
+					cmdStack[2] = &quot;gpx&quot;;
+					cmdStack[3] = &quot;-f&quot;;
+					cmdStack[4] = file.getCreationName();
+					cmdStack[5] = &quot;-o&quot;;
+					cmdStack[6] = &quot;garmin&quot;;
+					cmdStack[7] = &quot;-F&quot;;
+					cmdStack[8] = Global.getPref().garminConn + (&quot;:&quot;);
+					Process babelProcess = null;
+					babelProcess = startProcess(cmdStack);
+					StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
+					babelProcess.waitFor();
+					String errorMsg = errorStream.readALine();
+					if (errorMsg != null) {
+						Global.getPref().log(&quot;GPX Export: &quot; + errorMsg, null);
+						exportErrors++;
 					}
+					errorStream.close();
 				} catch (Exception ex) {
 					Global.getPref().log(&quot;GPX Export error :&quot;, ex, true);
 				}
@@ -541,13 +513,13 @@
 			}
 		}
 		if (exportErrors &gt; 0) {
-			new MessageBox(&quot;Export Error&quot;, exportErrors	+ &quot; errors during export. Check log for details.&quot;,
-					FormBase.OKB).execute();
+			new MessageBox(&quot;Export Error&quot;, exportErrors + &quot; errors during export. Check log for details.&quot;, FormBase.OKB).execute();
 		}
 	}
 
 	/**
 	 * wrapper for formatting a cache. will call some subroutines to do the actual work
+	 * 
 	 * @param ch
 	 * @return
 	 */
@@ -573,12 +545,12 @@
 			ret.append(&quot;  &lt;/wpt&gt;&quot;).append(newLine);
 		} catch (IllegalArgumentException e) {
 			exportErrors++;
-			ch.checkIncomplete();  // ch.setIncomplete(true);
-			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; check incomplete &quot;,	e, true);
+			ch.checkIncomplete(); // ch.setIncomplete(true);
+			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; check incomplete &quot;, e, true);
 			return &quot;&quot;;
 		} catch (Exception e) {
 			exportErrors++;
-			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; caused &quot;, e,	true);
+			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; caused &quot;, e, true);
 			return &quot;&quot;;
 		}
 
@@ -587,6 +559,7 @@
 
 	/**
 	 * generate minimal waypoint information according to GPX specification
+	 * 
 	 * @param ch
 	 * @return
 	 */
@@ -594,23 +567,23 @@
 
 		StringBuffer ret = new StringBuffer();
 
-//			.append(&quot;\t\t&lt;desc&gt;@@WPDESC@@&lt;/desc&gt;&quot;).append(newLine)
+		// .append(&quot;\t\t&lt;desc&gt;@@WPDESC@@&lt;/desc&gt;&quot;).append(newLine)
 
-		ret.append(&quot;  &lt;wpt lat=\&quot;&quot;+ch.pos.getLatDeg(CWPoint.DD)+&quot;\&quot; lon=\&quot;&quot;+ch.pos.getLonDeg(CWPoint.DD)+&quot;\&quot;&gt;&quot;).append(newLine);
+		ret.append(&quot;  &lt;wpt lat=\&quot;&quot; + ch.pos.getLatDeg(CWPoint.DD) + &quot;\&quot; lon=\&quot;&quot; + ch.pos.getLonDeg(CWPoint.DD) + &quot;\&quot;&gt;&quot;).append(newLine);
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
 			if (ch.isAddiWpt()) {
 				try {
-					ret.append(&quot;    &lt;time&gt;&quot;+ch.mainCache.getDateHidden()+&quot;T07:00:00Z&lt;/time&gt;&quot;).append(newLine);
+					ret.append(&quot;    &lt;time&gt;&quot; + ch.mainCache.getDateHidden() + &quot;T07:00:00Z&lt;/time&gt;&quot;).append(newLine);
 				} catch (Exception e) {
-					Global.getPref().log(ch.getWayPoint() + &quot; has no parent&quot;,null);
+					Global.getPref().log(ch.getWayPoint() + &quot; has no parent&quot;, null);
 					exportErrors++;
 					ret.append(&quot;    &lt;time&gt;1970-01-01T00:00:00&lt;/time&gt;&quot;).append(newLine);
 				}
 			} else if (ch.isCustomWpt()) {
 				ret.append(&quot;    &lt;time&gt;1970-01-01T00:00:00&lt;/time&gt;&quot;).append(newLine);
 			} else {
-				ret.append(&quot;    &lt;time&gt;&quot;+ch.getDateHidden()+&quot;T00:00:00&lt;/time&gt;&quot;).append(newLine);
+				ret.append(&quot;    &lt;time&gt;&quot; + ch.getDateHidden() + &quot;T00:00:00&lt;/time&gt;&quot;).append(newLine);
 			}
 		}
 
@@ -620,13 +593,13 @@
 			} else if (ch.isCustomWpt()) {
 				ret.append(&quot;    &lt;name&gt;&quot;).append(SafeXML.cleanGPX(ch.getWayPoint())).append(&quot;&lt;/name&gt;&quot;).append(newLine);
 			} else {
-				ret.append(&quot;    &lt;name&gt;&quot;).append(SafeXML.cleanGPX(ch.getWayPoint()))
-						.append(&quot; &quot;)
-						.append(CacheType.getExportShortId(ch.getType()))
-						.append(String.valueOf(ch.getHard()))
-						.append(String.valueOf(ch.getTerrain()))
-						.append(CacheSize.getExportShortId(ch.getCacheSize()))
-						.append(String.valueOf(ch.getNoFindLogs()))
+				ret.append(&quot;    &lt;name&gt;&quot;).append(SafeXML.cleanGPX(ch.getWayPoint()))//
+						.append(&quot; &quot;)//
+						.append(CacheType.getExportShortId(ch.getType()))//
+						.append(String.valueOf(ch.getHard()))//
+						.append(String.valueOf(ch.getTerrain()))//
+						.append(CacheSize.getExportShortId(ch.getCacheSize()))//
+						.append(String.valueOf(ch.getNoFindLogs()))//
 						.append(&quot;&lt;/name&gt;&quot;).append(newLine);
 			}
 		} else if (exportIds == WPNAME_NAME_SMART) {
@@ -655,17 +628,17 @@
 		if (ch.isAddiWpt() || ch.isCustomWpt()) {
 			ret.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName())).append(&quot;&lt;/desc&gt;&quot;).append(newLine);
 		} else {
-			ret.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName()))
-					.append(&quot; by &quot;)
-					.append(SafeXML.cleanGPX(ch.getCacheOwner()))
-					.append(&quot;, &quot;)
-					.append(CacheType.type2GSTypeTag(ch.getType()))
-					.append(&quot; (&quot;)
-					.append(CacheTerrDiff.shortDT(ch.getHard()))
-					.append(&quot;/&quot;)
-					.append(CacheTerrDiff.shortDT(ch.getTerrain()))
-					.append(&quot;)&quot;)
-					.append(&quot;&lt;/desc&gt;&quot;).append(newLine);					
+			ret.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName()))//
+					.append(&quot; by &quot;)//
+					.append(SafeXML.cleanGPX(ch.getCacheOwner()))//
+					.append(&quot;, &quot;)//
+					.append(CacheType.type2GSTypeTag(ch.getType()))//
+					.append(&quot; (&quot;)//
+					.append(CacheTerrDiff.shortDT(ch.getHard()))//
+					.append(&quot;/&quot;)//
+					.append(CacheTerrDiff.shortDT(ch.getTerrain()))//
+					.append(&quot;)&quot;)//
+					.append(&quot;&lt;/desc&gt;&quot;).append(newLine);
 		}
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
@@ -698,40 +671,47 @@
 
 	/**
 	 * format gc.com extended cache information as found in a PQ
-	 * @param ch cacheholder
-	 * @return formatted cache information for cache waypoints or emty string for all other waypoints (additional / custom)
+	 * 
+	 * @param ch
+	 *            cacheholder
+	 * @return formatted cache information for cache waypoints or emty string for all other waypoints (additional /
+	 *         custom)
 	 */
 	private String formatPqExtensions(CacheHolder ch) {
 
-		// no  details for addis or custom waypoints
+		// no details for addis or custom waypoints
 		if (ch.isCustomWpt() || ch.isAddiWpt())
 			return &quot;&quot;;
 		StringBuffer ret = new StringBuffer();
-		ret.append(&quot;    &lt;groundspeak:cache id=\&quot;&quot;).append(ch.GetCacheID()).append(&quot;\&quot; available=\&quot;&quot;).append(ch.is_available() ? TRUE : FALSE).append(&quot;\&quot; archived=\&quot;&quot;).append(ch.is_archived() ? TRUE : FALSE).append(&quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:name&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName())).append(&quot;&lt;/groundspeak:name&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:placed_by&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:owner id=\&quot;&quot;).append(&quot;31415&quot;).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:owner&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.type2GSTypeTag(ch.getType())).append(&quot;&lt;/groundspeak:type&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(CacheSize.cw2ExportString(ch.getCacheSize())).append(&quot;&lt;/groundspeak:container&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:attributes&gt;&quot;).append(newLine)
-		.append(formatAttributes(ch))
-		.append(&quot;      &lt;/groundspeak:attributes&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getHard())).append(&quot;&lt;/groundspeak:difficulty&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:terrain&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getTerrain())).append(&quot;&lt;/groundspeak:terrain&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:country&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).Country)).append(&quot;&lt;/groundspeak:country&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:state&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).State)).append(&quot;&lt;/groundspeak:state&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:short_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&lt;/groundspeak:short_description&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:long_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(formatLongDescription(ch))).append(&quot;&lt;/groundspeak:long_description&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:encoded_hints&gt;&quot;).append(SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints))).append(&quot;&lt;/groundspeak:encoded_hints&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:logs&gt;&quot;).append(newLine)
-		.append(formatLogs(ch))
-		.append(&quot;      &lt;/groundspeak:logs&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:travelbugs&gt;&quot;).append(newLine)
-		.append(formatTbs(ch))
-		.append(&quot;      &lt;/groundspeak:travelbugs&gt;&quot;).append(newLine)
-		.append(&quot;    &lt;/groundspeak:cache&gt;&quot;).append(newLine);
+		ret.append(&quot;    &lt;groundspeak:cache id=\&quot;&quot;).append(ch.GetCacheID())//
+				.append(&quot;\&quot; available=\&quot;&quot;).append(ch.is_available() ? TRUE : FALSE)//
+				.append(&quot;\&quot; archived=\&quot;&quot;).append(ch.is_archived() ? TRUE : FALSE)//
+				.append(&quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:name&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName())).append(&quot;&lt;/groundspeak:name&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:placed_by&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:owner id=\&quot;&quot;).append(&quot;31415&quot;).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:owner&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.type2GSTypeTag(ch.getType())).append(&quot;&lt;/groundspeak:type&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(CacheSize.cw2ExportString(ch.getCacheSize())).append(&quot;&lt;/groundspeak:container&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:attributes&gt;&quot;).append(newLine)//
+				.append(formatAttributes(ch))//
+				.append(&quot;      &lt;/groundspeak:attributes&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getHard())).append(&quot;&lt;/groundspeak:difficulty&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:terrain&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getTerrain())).append(&quot;&lt;/groundspeak:terrain&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:country&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).Country)).append(&quot;&lt;/groundspeak:country&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:state&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).State)).append(&quot;&lt;/groundspeak:state&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:short_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&lt;/groundspeak:short_description&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:long_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(formatLongDescription(ch))).append(&quot;&lt;/groundspeak:long_description&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:encoded_hints&gt;&quot;).append(SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints))).append(&quot;&lt;/groundspeak:encoded_hints&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:logs&gt;&quot;).append(newLine)//
+				.append(formatLogs(ch))//
+				.append(&quot;      &lt;/groundspeak:logs&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:travelbugs&gt;&quot;).append(newLine)//
+				.append(formatTbs(ch))//
+				.append(&quot;      &lt;/groundspeak:travelbugs&gt;&quot;).append(newLine)//
+				.append(&quot;    &lt;/groundspeak:cache&gt;&quot;).append(newLine);//
 		return ret.toString();
 	}
+
 	/**
 	 * 
 	 */
@@ -739,95 +719,97 @@
 		StringBuffer ret = new StringBuffer();
 		Travelbug Tb;
 		for (int i = 0; i &lt; ch.getCacheDetails(true).Travelbugs.size(); i++) {
-			Tb=ch.getCacheDetails(true).Travelbugs.getTB(i);
-			ret.append(&quot;        &lt;groundspeak:travelbug id=\&quot;&quot;).
-			append(Integer.toString(i)).
-			append(&quot;\&quot; ref=\&quot;TB\&quot;&gt;&quot;).
-			// append(newLine).
-			// append(&quot;          &lt;groundspeak:name&gt;&quot;).
-			append(&quot;&lt;groundspeak:name&gt;&quot;).
-			append(SafeXML.cleanGPX(Tb.getName())).
-			append(&quot;&lt;/groundspeak:name&gt;&quot;).
-			// append(newLine).
-			// append(&quot;        &lt;/groundspeak:travelbug&gt;\r\n&quot;);
-			append(&quot;&lt;/groundspeak:travelbug&gt;\r\n&quot;);
+			Tb = ch.getCacheDetails(true).Travelbugs.getTB(i);
+			ret.append(&quot;        &lt;groundspeak:travelbug id=\&quot;&quot;).//
+					append(Integer.toString(i)).//
+					append(&quot;\&quot; ref=\&quot;TB\&quot;&gt;&quot;).//
+					// append(newLine).//
+					// append(&quot; &lt;groundspeak:name&gt;&quot;).//
+					append(&quot;&lt;groundspeak:name&gt;&quot;).//
+					append(SafeXML.cleanGPX(Tb.getName())).//
+					append(&quot;&lt;/groundspeak:name&gt;&quot;).//
+					// append(newLine).//
+					// append(&quot; &lt;/groundspeak:travelbug&gt;\r\n&quot;);//
+					append(&quot;&lt;/groundspeak:travelbug&gt;\r\n&quot;);//
 		}
 		return ret.toString();
 	}
+
 	/**
 	 * 
 	 */
-	private String formatAttributes(CacheHolder ch){
+	private String formatAttributes(CacheHolder ch) {
 		StringBuffer ret = new StringBuffer();
 		Attribute attrib;
 		for (int i = 0; i &lt; ch.getCacheDetails(true).attributes.count(); i++) {
 			// &lt;groundspeak:attribute id=&quot;X&quot; inc=&quot;Y&quot;&gt;text f&#252;r X&lt;/groundspeak:attribute&gt;
-			attrib=ch.getCacheDetails(true).attributes.getAttribute(i);
+			attrib = ch.getCacheDetails(true).attributes.getAttribute(i);
 			if (attrib.getGCId().length() &gt; 0) {
-				ret.append(&quot;        &lt;groundspeak:attribute id=\&quot;&quot;).
-				append(attrib.getGCId()).
-				append(&quot;\&quot; inc=\&quot;&quot;).
-				append(attrib.getInc()).
-				append(&quot;\&quot;&gt;&quot;).
-				append(attrib.getGCText()).
-				append(&quot;&lt;/groundspeak:attribute&gt;&quot;).
-				append(newLine);
+				ret.append(&quot;        &lt;groundspeak:attribute id=\&quot;&quot;).//
+						append(attrib.getGCId()).//
+						append(&quot;\&quot; inc=\&quot;&quot;).//
+						append(attrib.getInc()).//
+						append(&quot;\&quot;&gt;&quot;).//
+						append(attrib.getGCText()).//
+						append(&quot;&lt;/groundspeak:attribute&gt;&quot;).//
+						append(newLine);//
 			}
 		}
 		return ret.toString();
 	}
+
 	/**
 	 * format cache logs as found in a gc.com GPX file
-	 * @param ch CacheHolder containing the logs
+	 * 
+	 * @param ch
+	 *            CacheHolder containing the logs
 	 * @return formatted logs or empty string if no logs are present
 	 */
 	private String formatLogs(CacheHolder ch) {
-		CacheHolderDetail chD=ch.getCacheDetails(false);
+		CacheHolderDetail chD = ch.getCacheDetails(false);
 		LogList logs = chD.CacheLogs;
 		StringBuffer ret = new StringBuffer();
 		int exportlogs;
-		if (exportStyle == STYLE_GPX_PQLIKE &amp;&amp; maxLogs &lt; logs.size())
-			{exportlogs = maxLogs;}
-		else {exportlogs = logs.size();}
+		if (exportStyle == STYLE_GPX_PQLIKE &amp;&amp; maxLogs &lt; logs.size()) {
+			exportlogs = maxLogs;
+		} else {
+			exportlogs = logs.size();
+		}
 		if (exportStyle == STYLE_GPX_MYFINDS) {
 			// only own log
 			if (chD.OwnLogId.equals(&quot;&quot;) || chD.OwnLog == null) {
-				Global.getPref().log(chD.getParent().getWayPoint()+&quot; missing own LogID&quot;, null);
-				return &quot;&quot;;				
+				Global.getPref().log(chD.getParent().getWayPoint() + &quot; missing own LogID&quot;, null);
+				return &quot;&quot;;
 			}
-			addLog(chD.OwnLogId, chD.OwnLog, finderid ,ret);
-		}
-		else {
+			addLog(chD.OwnLogId, chD.OwnLog, finderid, ret);
+		} else {
 			// add log with attributes
-			if (attrib2Log){
-				addLog (ch.GetCacheID()+Integer.toString(exportlogs), createAttrLog(ch),&quot;&quot;,ret);
+			if (attrib2Log) {
+				addLog(ch.GetCacheID() + Integer.toString(exportlogs), createAttrLog(ch), &quot;&quot;, ret);
 			}
 			for (int i = 0; i &lt; exportlogs; i++) {
-				addLog(ch.GetCacheID()+Integer.toString(i), logs.getLog(i),&quot;&quot; ,ret);
+				addLog(ch.GetCacheID() + Integer.toString(i), logs.getLog(i), &quot;&quot;, ret);
 			}
 		}
 		return ret.toString();
 	}
+
 	private Log createAttrLog(CacheHolder ch) {
 		Attribute attrib;
 		StringBuffer logText = new StringBuffer();
 		for (int i = 0; i &lt; ch.getCacheDetails(true).attributes.count(); i++) {
-			attrib=ch.getCacheDetails(true).attributes.getAttribute(i);
-			logText.append(attrib.getInc()==1?&quot;Yes: &quot;:&quot;No: &quot;).
-			append(attrib.getMsg()).
-			append(&quot;&lt;br /&gt;&quot;).
-			append(newLine);
+			attrib = ch.getCacheDetails(true).attributes.getAttribute(i);
+			logText.append(attrib.getInc() == 1 ? &quot;Yes: &quot; : &quot;No: &quot;).append(attrib.getMsg()).append(&quot;&lt;br /&gt;&quot;).append(newLine);
 		}
 		if (ch.hasNote()) {
-			logText.append(SafeXML.cleanGPX(ch.getCacheDetails(true).getCacheNotes())).
-			append(&quot;&lt;br /&gt;&quot;).
-			append(newLine);
+			logText.append(SafeXML.cleanGPX(ch.getCacheDetails(true).getCacheNotes())).append(&quot;&lt;br /&gt;&quot;).append(newLine);
 		}
-		if (logText.length() == 0 &amp;&amp; !ch.getLastSync().equals(&quot;&quot;)) logText.append(MyLocale.getMsg(1051,&quot;Last sync date&quot;));
+		if (logText.length() == 0 &amp;&amp; !ch.getLastSync().equals(&quot;&quot;))
+			logText.append(MyLocale.getMsg(1051, &quot;Last sync date&quot;));
 		Log log = new Log(&quot;icon_note.gif&quot;, DateFormat.yyyyMMddHHmmss2gpxLogdate(ch.getLastSync()), &quot;CacheWolf&quot;, logText.toString());
 		return log;
 	}
-	
+
 	private StringBuffer addLog(String logId, Log log, String FinderID, StringBuffer ret) {
 		Transformer trans = new Transformer(true);
 		trans.add(new Regex(&quot;@@LOGID@@&quot;, logId));
@@ -843,16 +825,20 @@
 
 	/**
 	 * format the header of the GPX file
+	 * 
 	 * @return
 	 */
 	private String formatHeader() {
-		//FIXME: extend profile to add &lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot; maxlon=\&quot;6.918817\&quot; /&gt;
-		//Global.getProfile().getSourroundingArea(false);
+		// FIXME: extend profile to add &lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot;
+		// maxlon=\&quot;6.918817\&quot; /&gt;
+		// Global.getProfile().getSourroundingArea(false);
 		Transformer trans = new Transformer(true);
 		trans.add(new Regex(&quot;@@CREATEDATE@@&quot;, new Date().setToCurrentTime().setFormat(&quot;yyyy-MM-dd&quot;).toString()));
-		if (exportStyle==STYLE_GPX_MYFINDS)
-			 {trans.add(new Regex(&quot;@@NAME@@&quot;,&quot;My Finds Pocket Query&quot;));}
-		else {trans.add(new Regex(&quot;@@NAME@@&quot;,&quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;));}
+		if (exportStyle == STYLE_GPX_MYFINDS) {
+			trans.add(new Regex(&quot;@@NAME@@&quot;, &quot;My Finds Pocket Query&quot;));
+		} else {
+			trans.add(new Regex(&quot;@@NAME@@&quot;, &quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;));
+		}
 		return trans.replaceFirst(GPXHEADER);
 		/*
 		String ret = STRreplace.replace(GPXHEADER,&quot;@@CREATEDATE@@&quot;, new Date().setToCurrentTime().setFormat(&quot;yyyy-MM-dd&quot;).toString());
@@ -865,7 +851,9 @@
 
 	/**
 	 * format a long description as found in the gc.com GPX files
-	 * @param ch CacheHolder to format
+	 * 
+	 * @param ch
+	 *            CacheHolder to format
 	 * @return formatted output
 	 */
 	private String formatLongDescription(CacheHolder ch) {
@@ -896,9 +884,9 @@
 					trans.add(new Regex(&quot;@@ADDIID@@&quot;, addi.getWayPoint()));
 					trans.add(new Regex(&quot;@@ADDISHORT@@&quot;, addi.getCacheName()));
 					trans.add(new Regex(&quot;@@ADDIDELIM@@&quot;, delim));
-					trans.add(new Regex(&quot;@@ADDILAT@@&quot;,formatAddiLatLon(addi.pos)));
+					trans.add(new Regex(&quot;@@ADDILAT@@&quot;, formatAddiLatLon(addi.pos)));
 					trans.add(new Regex(&quot;@@ADDILON@@&quot;, &quot;&quot;));
-					trans.add(new Regex(&quot;@@ADDILONG@@&quot;,addi.getCacheDetails(true).LongDescription));
+					trans.add(new Regex(&quot;@@ADDILONG@@&quot;, addi.getCacheDetails(true).LongDescription));
 					ret.append(trans.replaceAll(GPXADDIINMAIN));
 				}
 				ret.append(delim).append(newLine);
@@ -909,11 +897,10 @@
 
 	/**
 	 * create a position information suitable for a gc.com PQlike export
-	 *
+	 * 
 	 * @param pos
 	 *            position
-	 * @return if position is valid return the cachewolf formatted position,
-	 *         otherwise return teh string used in PQs
+	 * @return if position is valid return the cachewolf formatted position, otherwise return teh string used in PQs
 	 */
 	private String formatAddiLatLon(CWPoint pos) {
 		if (pos.isValid()) {
@@ -924,7 +911,9 @@
 	}
 
 	/**
-	 * copy the bitmap identified by &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; from &lt;code&gt;poiZip&lt;/code&gt; to &lt;code&gt;outdir&lt;/code&gt;
+	 * copy the bitmap identified by &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; from &lt;code&gt;poiZip&lt;/code&gt; to
+	 * &lt;code&gt;outdir&lt;/code&gt;
+	 * 
 	 * @param outdir
 	 * @param type
 	 * @param prefix
@@ -943,7 +932,7 @@
 
 			buff = new byte[icon.getSize()];
 			InputStream fis = poiZip.getInputStream(icon);
-			FileOutputStream fos = new FileOutputStream(outdir+(FileBase.separator)+prefix+type+&quot;.bmp&quot;);
+			FileOutputStream fos = new FileOutputStream(outdir + (FileBase.separator) + prefix + type + &quot;.bmp&quot;);
 			while (0 &lt; (len = fis.read(buff)))
 				fos.write(buff, 0, len);
 			fos.flush();
@@ -961,28 +950,31 @@
 
 	/**
 	 * Execute the command defined by cmd
-	 * @param cmd command and options to execute. if command or options include a space quatation marks are added. this will not wirk with the java version on unix systems
+	 * 
+	 * @param cmd
+	 *            command and options to execute. if command or options include a space quatation marks are added. this
+	 *            will not wirk with the java version on unix systems
 	 * @return a handle to the process on success or null otherwise
 	 */
 	Process startProcess(String[] cmd) {
 		String command = &quot;&quot;;
 		if (cmd.length == 0) {
 			exportErrors++;
-			Global.getPref().log(&quot;GPX Export: empty gpsbabel command&quot;,null);
+			Global.getPref().log(&quot;GPX Export: empty gpsbabel command&quot;, null);
 			return null;
 		}
 
 		for (int i = 0; i &lt; cmd.length; i++) {
 			if (cmd[i].indexOf(&quot; &quot;) &gt; -1) {
-				cmd[i]=&quot;\&quot;&quot;+cmd[i]+&quot;\&quot;&quot;;
+				cmd[i] = &quot;\&quot;&quot; + cmd[i] + &quot;\&quot;&quot;;
 			}
-			command = command+cmd[i]+&quot; &quot;;
+			command = command + cmd[i] + &quot; &quot;;
 		}
 
 		try {
 			return Vm.exec(command);
 		} catch (IOException e) {
-			Global.getPref().log(&quot;error excuting &quot;+command, e, true);
+			Global.getPref().log(&quot;error excuting &quot; + command, e, true);
 			exportErrors++;
 			return null;
 		}
@@ -1020,32 +1012,32 @@
 			this.setTitle(&quot;GPX Export&quot;);
 			this.resizable = false;
 
-			btnOk = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
-			btnCancel = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+			btnOk = new mButton(MyLocale.getMsg(1605, &quot;OK&quot;));
+			btnCancel = new mButton(MyLocale.getMsg(1604, &quot;Cancel&quot;));
 
 			chIds = new mChoice();
 			chIds.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chIds.addItem(MyLocale.getMsg(31415,&quot;Classic IDs&quot;)); // index 0
-			chIds.addItem(MyLocale.getMsg(31415,&quot;Smart IDs&quot;)); // index 1
-//			chIds.addItem(MyLocale.getMsg(31415,&quot;Smart Names&quot;)); // index 2
+			chIds.addItem(MyLocale.getMsg(31415, &quot;Classic IDs&quot;)); // index 0
+			chIds.addItem(MyLocale.getMsg(31415, &quot;Smart IDs&quot;)); // index 1
+			// chIds.addItem(MyLocale.getMsg(31415,&quot;Smart Names&quot;)); // index 2
 			chIds.select(chosenIds);
 
 			chStyle = new mChoice();
 			chStyle.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chStyle.addItem(MyLocale.getMsg(31415,&quot;Compact&quot;)); // index 0
-			chStyle.addItem(MyLocale.getMsg(31415,&quot;PQ like&quot;)); // index 1
-			chStyle.addItem(MyLocale.getMsg(31415,&quot;MyFinds&quot;)); // index 2
+			chStyle.addItem(MyLocale.getMsg(31415, &quot;Compact&quot;)); // index 0
+			chStyle.addItem(MyLocale.getMsg(31415, &quot;PQ like&quot;)); // index 1
+			chStyle.addItem(MyLocale.getMsg(31415, &quot;MyFinds&quot;)); // index 2
 			chStyle.select(chosenStyle);
 
 			chTarget = new mChoice();
 			chTarget.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chTarget.addItem(MyLocale.getMsg(31415,&quot;Single GPX&quot;)); // index 0
-			chTarget.addItem(MyLocale.getMsg(31415,&quot;Separate GPX&quot;)); // index 1
+			chTarget.addItem(MyLocale.getMsg(31415, &quot;Single GPX&quot;)); // index 0
+			chTarget.addItem(MyLocale.getMsg(31415, &quot;Separate GPX&quot;)); // index 1
 			if (hasBitmaps &amp;&amp; hasGarminMap &amp;&amp; hasGpsbabel) {
-				chTarget.addItem(MyLocale.getMsg(31415,&quot;POI&quot;)); // index 2
+				chTarget.addItem(MyLocale.getMsg(31415, &quot;POI&quot;)); // index 2
 			}
 			chTarget.select(chosenTarget);
 
@@ -1055,39 +1047,41 @@
 			ibMaxLogs = new mInput(String.valueOf(Global.getPref().numberOfLogsToExport));
 			ibMaxLogs.modify(ControlConstants.Disabled, 0);
 
-			cbSeperateHints = new mCheckBox(MyLocale.getMsg(31415,&quot;Separate Hints&quot;));
+			cbSeperateHints = new mCheckBox(MyLocale.getMsg(31415, &quot;Separate Hints&quot;));
 			cbSeperateHints.modify(ControlConstants.Disabled, 0);
 
-			cbSendToGarmin = new mCheckBox(MyLocale.getMsg(31415,&quot;send to Garmin&quot;));
-			if (!hasGpsbabel) cbSendToGarmin.modify(ControlConstants.Disabled, 0);
+			cbSendToGarmin = new mCheckBox(MyLocale.getMsg(31415, &quot;send to Garmin&quot;));
+			if (!hasGpsbabel)
+				cbSendToGarmin.modify(ControlConstants.Disabled, 0);
 
-			cbCustomIcons = new mCheckBox(MyLocale.getMsg(31415,&quot;Custom Icons&quot;));
-			if (!hasGarminMap) cbCustomIcons.modify(ControlConstants.Disabled, 0);
+			cbCustomIcons = new mCheckBox(MyLocale.getMsg(31415, &quot;Custom Icons&quot;));
+			if (!hasGarminMap)
+				cbCustomIcons.modify(ControlConstants.Disabled, 0);
 
-			cbAttrib2Log = new mCheckBox(MyLocale.getMsg(31415,&quot;Attrib.-&gt;Log&quot;));
-			
-			addNext(new mLabel(MyLocale.getMsg(31415,&quot;GPX Style&quot;)));
+			cbAttrib2Log = new mCheckBox(MyLocale.getMsg(31415, &quot;Attrib.-&gt;Log&quot;));
+
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;GPX Style&quot;)));
 			addLast(chStyle);
 
-			addNext(new mLabel(MyLocale.getMsg(31415,&quot;WP Names&quot;)));
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;WP Names&quot;)));
 			addLast(chIds);
 
-			addNext(new mLabel(MyLocale.getMsg(31415,&quot;Output&quot;)));
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;Output&quot;)));
 			addLast(chTarget);
 
 			addNext(cbCustomIcons);
 			addLast(cbSendToGarmin);
 
-//			addLast(cbSeperateHints);
+			// addLast(cbSeperateHints);
 
-            addNext(new mLabel(MyLocale.getMsg(31415,&quot;Prefix&quot;)));
-            addLast(ibPrefix);
-            
-            addLast(cbAttrib2Log);
-            
-            addNext(new mLabel(MyLocale.getMsg(31415,&quot;Max Logs&quot;)));
-            addLast(ibMaxLogs);
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;Prefix&quot;)));
+			addLast(ibPrefix);
 
+			addLast(cbAttrib2Log);
+
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;Max Logs&quot;)));
+			addLast(ibMaxLogs);
+
 			addButton(btnOk);
 			addButton(btnCancel);
 
@@ -1095,10 +1089,9 @@
 			checkTarget();
 			checkIds();
 		}
-		
+
 		/**
-		 * in  : chStyle.selectedIndex;
-		 * out : chosenStyle
+		 * in : chStyle.selectedIndex; out : chosenStyle
 		 */
 		private void checkStyle() {
 			if (chStyle.selectedIndex == 2) { // my finds export
@@ -1127,7 +1120,7 @@
 				cbAttrib2Log.state = false;
 				if (cbAttrib2Log.change(ControlConstants.Disabled, 0))
 					cbAttrib2Log.repaint();
-				
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1153,7 +1146,7 @@
 
 				if (cbAttrib2Log.change(0, ControlConstants.Disabled))
 					cbAttrib2Log.repaint();
-				
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1178,7 +1171,7 @@
 
 				if (cbAttrib2Log.change(ControlConstants.Disabled, 0))
 					cbAttrib2Log.repaint();
-		
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1192,8 +1185,7 @@
 		}
 
 		/**
-		 * in : chTarget.selectedIndex
-		 * out: chosenTarget
+		 * in : chTarget.selectedIndex out: chosenTarget
 		 */
 		private void checkTarget() {
 			if (chTarget.selectedIndex == 2) { // POI
@@ -1230,7 +1222,7 @@
 				if (hasGarminMapFrm &amp;&amp; cbCustomIcons.change(0, ControlConstants.Disabled))
 					cbCustomIcons.repaint();
 
-				cbSeperateHints.state=false;
+				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
 
@@ -1247,10 +1239,10 @@
 			chosenTarget = chTarget.selectedIndex;
 			chosenIds = chIds.selectedIndex;
 		}
-		
+
 		/**
-		 * react to GUI events and toogle access to the checkboxes according to
-		 * radio button settings pass everything else to &lt;code&gt;super()&lt;/code&gt;
+		 * react to GUI events and toogle access to the checkboxes according to radio button settings pass everything
+		 * else to &lt;code&gt;super()&lt;/code&gt;
 		 */
 		public void onEvent(Event ev) {
 			if (ev instanceof DataChangeEvent &amp;&amp; ev.type == DataChangeEvent.DATA_CHANGED) {
@@ -1294,14 +1286,16 @@
 
 		/**
 		 * amount of data to be exported
+		 * 
 		 * @return 0 Compact, 1 PQ like, 2 MyFinds
 		 */
-		private int getExportStyle () {
+		private int getExportStyle() {
 			return chosenStyle;
 		}
 
 		/**
 		 * style of waypoint identifiers
+		 * 
 		 * @return 0 Classic IDs, 1 Smart IDs, 3 Smart Names (should only be used with gpsbabel)
 		 */
 		private int getWpNameStyle() {
@@ -1310,6 +1304,7 @@
 
 		/**
 		 * what kind of output should be generated
+		 * 
 		 * @return 0 single file, 1 separate files, 2 POI (GPI) files
 		 */
 		private int getOutputTarget() {
@@ -1318,7 +1313,7 @@
 
 		/**
 		 * check if user wants to send output straight to a Garmin GPSr
-		 *
+		 * 
 		 * @return true for GPSr transfer, false otherwise
 		 */
 		private boolean getSendToGarmin() {
@@ -1327,7 +1322,7 @@
 
 		/**
 		 * check if user wants custom icons
-		 *
+		 * 
 		 * @return true if user wants custom icons, false otherwise
 		 */
 		private boolean getCustomIcons() {
@@ -1336,7 +1331,7 @@
 
 		/**
 		 * get the number of logs to export. used in PQlike export.
-		 *
+		 * 
 		 * @return number of logs to export
 		 */
 		private int getMaxLogs() {
@@ -1345,19 +1340,19 @@
 
 		/**
 		 * get prefix for separate file export
-		 *
+		 * 
 		 * @return prefix for separate file export
 		 */
 		private String getPrefix() {
 			return ibPrefix.getText();
 		}
-		
+
 		/**
 		 * check if user wants to export attributes as log
 		 * 
 		 * @return true if attributes should exported as log, false otherwise
 		 */
-		private boolean getAttrib2Log (){
+		private boolean getAttrib2Log() {
 			return cbAttrib2Log.state;
 		}
 	}

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-06-15 20:53:01 UTC (rev 3027)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-06-16 20:35:47 UTC (rev 3028)
@@ -1008,7 +1008,7 @@
 
 	/**
 	 * Method to spider a single cache. It assumes a login has already been performed!
-	 * 
+	 *
 	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with
 	 *         next cache
 	 */
@@ -1055,7 +1055,7 @@
 
 	/**
 	 * Fetch the coordinates of a waypoint from GC
-	 * 
+	 *
 	 * @param wayPoint
 	 *            the name of the waypoint
 	 * @return the cache coordinates
@@ -1100,13 +1100,13 @@
 			if (loggedIn)
 				return true;
 			else {
-				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences | Einstellungen.&quot;, FormBase.OKB)).execute();
+				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences | Einstellungen.\nsee <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A>&quot;, FormBase.OKB)).execute();
 				return false;
 			}
 		} else {
 			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
 			if (true) {
-				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences| Einstellungen.&quot;, FormBase.OKB)).execute();
+				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences| Einstellungen.\nsee <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A>&quot;, FormBase.OKB)).execute();
 				return false; // until SSL/https works
 			}
 		}
@@ -1341,7 +1341,7 @@
 	}
 
 	/*
-	 * 
+	 *
 	 */
 	private void initialiseProperties() {
 		try {
@@ -1384,7 +1384,7 @@
 	}
 
 	/*
-	 * 
+	 *
 	 */
 	private void getFirstListPage(int distance) {
 		// Get first page
@@ -1747,7 +1747,7 @@
 
 	/**
 	 * check if new Update exists
-	 * 
+	 *
 	 * @param ch
 	 *            CacheHolder
 	 * @param CacheDescription
@@ -1832,7 +1832,7 @@
 
 	/**
 	 * Get num found
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return numFound
@@ -1952,7 +1952,7 @@
 
 	/**
 	 * Get the waypoint name
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Name of waypoint to add to list
@@ -2177,9 +2177,9 @@
 
 	/*
 	 * @param CacheHolder ch
-	 * 
+	 *
 	 * @param String cacheDescGC
-	 * 
+	 *
 	 * @return boolean newLogExists
 	 */
 	private boolean newFoundExists(CacheHolder ch, String cacheDescription) {
@@ -2221,9 +2221,9 @@
 	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already
 	 * existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file
 	 * and fetching the images.
-	 * 
+	 *
 	 * This is the workhorse function of the spider.
-	 * 
+	 *
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
 	 * @param boolean
@@ -2429,7 +2429,7 @@
 
 	/**
 	 * Get the coordinates of the cache
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cache coordinates
@@ -2448,7 +2448,7 @@
 
 	/**
 	 * Get the long description
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the long description
@@ -2483,7 +2483,7 @@
 
 	/**
 	 * Get the cache location (country and state)
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the location (country and state) of the cache
@@ -2500,7 +2500,7 @@
 
 	/**
 	 * Get the cache name
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the name of the cache
@@ -2517,7 +2517,7 @@
 
 	/**
 	 * Get the cache owner
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the cache owner
@@ -2534,7 +2534,7 @@
 
 	/**
 	 * Get the date when the cache was hidden
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Hidden date
@@ -2551,7 +2551,7 @@
 
 	/**
 	 * Get the hints
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cachehints
@@ -2568,7 +2568,7 @@
 
 	/**
 	 * Get the cache size
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cache size
@@ -2586,7 +2586,7 @@
 
 	/**
 	 * Get the Difficulty
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return The cache difficulty
@@ -2604,7 +2604,7 @@
 
 	/**
 	 * Get the terrain rating
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Terrain rating
@@ -2622,7 +2622,7 @@
 
 	/**
 	 * Get the waypoint type
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the waypoint type (Tradi, Multi, etc.)
@@ -2639,7 +2639,7 @@
 
 	/**
 	 * Get the logs
-	 * 
+	 *
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @param chD
@@ -2706,7 +2706,7 @@
 
 	/**
 	 * This methods cleans up the path for inlined smilies in logtexts.
-	 * 
+	 *
 	 * @param logText
 	 * @return
 	 */
@@ -2724,7 +2724,7 @@
 	/**
 	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each
 	 * travelbug
-	 * 
+	 *
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
@@ -2778,7 +2778,7 @@
 	/**
 	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and
 	 * the pictures section (including the spoiler)
-	 * 
+	 *
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @param chD
@@ -2965,7 +2965,7 @@
 
 	/**
 	 * Read an image from the server
-	 * 
+	 *
 	 * @param imgUrl
 	 *            The Url of the image
 	 * @param target
@@ -2987,7 +2987,7 @@
 
 	/**
 	 * Read all additional waypoints from a previously fetched cachepage.
-	 * 
+	 *
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @param wayPoint
@@ -3122,7 +3122,7 @@
 	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical
 	 * names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
 	 * Note that each bug has both an ID and a GUID.
-	 * 
+	 *
 	 * @param name
 	 *            The name (or partial name) of a travelbug
 	 * @return the id of the bug
@@ -3158,7 +3158,7 @@
 	/**
 	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be
 	 * a GUID, otherwise it is an ID.
-	 * 
+	 *
 	 * @param guid
 	 *            the guid or id of the travelbug
 	 * @return The mission
@@ -3191,7 +3191,7 @@
 
 	/**
 	 * Fetch a bug's mission for a given tracking number
-	 * 
+	 *
 	 * @param trackNr
 	 *            the tracking number of the travelbug
 	 * @return The mission
@@ -3223,7 +3223,7 @@
 
 	/**
 	 * Fetch a bug's mission and namefor a given tracking number
-	 * 
+	 *
 	 * @param TB
 	 *            the travelbug
 	 * @return true if suceeded
@@ -3270,7 +3270,7 @@
 
 		/**
 		 * Gets an entry in spider.def by its key (tag)
-		 * 
+		 *
 		 * @param key
 		 *            The key which is attributed to a specific entry
 		 * @return The value for the key


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003018.html">[Cachewolf-svn] r3027 - in trunk/src/CacheWolf: . imp navi
</A></li>
	<LI>Next message: <A HREF="003020.html">[Cachewolf-svn] r3029 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3019">[ date ]</a>
              <a href="thread.html#3019">[ thread ]</a>
              <a href="subject.html#3019">[ subject ]</a>
              <a href="author.html#3019">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
